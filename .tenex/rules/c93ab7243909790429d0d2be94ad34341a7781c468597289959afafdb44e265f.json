{
  "eventId": "c93ab7243909790429d0d2be94ad34341a7781c468597289959afafdb44e265f",
  "title": "NDK Best Practices",
  "description": "Best practices to develop nostr clients with NDK",
  "content": "# NDK Expert Best Practices (Core/Terminal)\n\nThis document outlines best practices for using the core Nostr Development Kit (NDK) library, particularly relevant for terminal-based applications or environments without specific UI frameworks.\n\n## 1. Connection to Relays\n\n*   **Explicit Relays:** Always initialize `NDK` with a set of `explicitRelayUrls`. Relying solely on user relay lists (Kind 3/10002) can be unreliable, especially during initial connection or for fetching those lists themselves.\n    ```typescript\n    import NDK from \"@nostr-dev-kit/ndk\";\n\n    const explicitRelays = [\"wss://relay.damus.io\", \"wss://relay.primal.net\"];\n    const ndk = new NDK({ explicitRelayUrls: explicitRelays });\n    ```\n*   **Connection Management:** Call `ndk.connect()` early in your application lifecycle. You can optionally pass a timeout. Monitor connection status using the `pool` events if needed.\n    ```typescript\n    ndk.connect(2000)\n        .then(() => console.log(\"Connected\"))\n        .catch((e) => console.error(\"Connection failed\", e));\n\n    ndk.pool.on(\"relay:connect\", (relay) => {\n        console.log(\"Connected to relay:\", relay.url);\n    });\n    ndk.pool.on(\"relay:disconnect\", (relay) => {\n        console.log(\"Disconnected from relay:\", relay.url);\n    });\n    ```\n*   **Dynamic Relays:** Fetch user-specific relay lists (Kind 10002 or Kind 3) after establishing initial connections and add them to the pool if necessary using `ndk.pool.addRelay()` or by creating `NDKRelaySet`s.\n\n## 2. Signer / Session Management\n\n*   **Signer Initialization:** Instantiate and assign a signer to the `ndk.signer` property as early as possible.\n    *   **Private Key (Use with caution):** Suitable for backend services or CLI tools where the key is securely managed.\n        ```typescript\n        import NDK, { NDKPrivateKeySigner } from \"@nostr-dev-kit/ndk\";\n\n        const pkSigner = new NDKPrivateKeySigner(\"nsec...\");\n        const ndk = new NDK({ signer: pkSigner });\n        ```\n    *   **NIP-07 Signer:** For browser extensions like getalby, nos2x, etc. Check for `window.nostr`.\n        ```typescript\n        import NDK, { NDKNip07Signer } from \"@nostr-dev-kit/ndk\";\n\n        if (window.nostr) {\n            const nip07Signer = new NDKNip07Signer();\n            const ndk = new NDK({ signer: nip07Signer });\n            nip07Signer.user().then(user => {\n                ndk.activeUser = user;\n                console.log(`Logged in as ${user.npub}`);\n            });\n        } else {\n            console.error(\"NIP-07 Signer (browser extension) not found.\");\n        }\n        ```\n    *   **NIP-46 Signer (Remote Signer):** For connecting to remote signers like Nostr Connect apps. Requires a secret and potentially a relay for communication.\n        ```typescript\n        import NDK, { NDKNip46Signer } from \"@nostr-dev-kit/ndk\";\n\n        const nip46Signer = new NDKNip46Signer(ndk, \"npub_of_remote_signer\", new NDKPrivateKeySigner(\"local_app_nsec...\"));\n        nip46Signer.rpc.relay = ndk.pool.getRelay(\"wss://relay.nostrconnect.com\");\n        ndk.signer = nip46Signer;\n\n        nip46Signer.connect().then(() => {\n            console.log(\"Connected to remote signer\");\n            nip46Signer.user().then(user => {\n                ndk.activeUser = user;\n                console.log(`Logged in as remote user ${user.npub}`);\n            });\n        });\n        ```\n*   **Active User:** Once the signer is ready and the user's pubkey is known, set `ndk.activeUser` for convenience in other parts of the application.\n    ```typescript\n    const user = await ndk.signer.user();\n    ndk.activeUser = user;\n    ```\n\n## 3. Cache Adapters\n\n*   **Default (Memory):** NDK uses an in-memory cache by default (`NDKCacheAdapterMemory`). This is suitable for short-lived scripts or environments where persistence isn't needed.\n*   **Custom Adapters:** For persistence or more complex caching, implement a custom cache adapter conforming to the `NDKCacheAdapter` interface or use pre-built ones like `ndk-cache-dexie` (browser), `ndk-cache-redis` (server), or `ndk-cache-sqlite-wasm` (browser). Pass the adapter instance during `NDK` initialization.\n    ```typescript\n    import NDK from \"@nostr-dev-kit/ndk\";\n\n\n    ```\n*   **Cache Usage:** NDK automatically uses the configured cache for profiles, events, and relay sets. Be mindful of cache invalidation if needed, although NDK handles replacing events based on NIP-01 rules (newer `created_at`).\n\n## 4. Fetching Data via Subscriptions\n\n*   **Use `fetchEvents`:** This is the primary method for fetching events. It returns a promise resolving to a set of `NDKEvent` objects.\n    ```typescript\n    const filter: NDKFilter = { kinds: [1], authors: [\"pubkey...\"], limit: 10 };\n    const events: Set<NDKEvent> = await ndk.fetchEvents(filter);\n    events.forEach(event => console.log(event.content));\n    ```\n*   **Use `subscribeEvents` for Real-time Updates:** For continuous updates, use `subscribeEvents`. It returns an `NDKSubscription` object. Remember to call `sub.stop()` when done.\n    ```typescript\n    const filter: NDKFilter = { kinds: [1], authors: [\"pubkey...\"], \"#t\": [\"ndk\"] };\n    const sub = ndk.subscribeEvents(filter, { closeOnEose: false });\n\n    sub.on(\"event\", (event: NDKEvent) => {\n        console.log(\"Received real-time event:\", event.content);\n    });\n\n    sub.on(\"eose\", () => {\n        console.log(\"Initial events loaded, waiting for new ones...\");\n    });\n\n    sub.start();\n\n\n    ```\n*   **Subscription Options:** Utilize `NDKSubscriptionOptions` for fine-grained control:\n    *   `closeOnEose`: Set to `false` for continuous subscriptions (default is `true`).\n    *   `groupable`: Set to `false` if you need immediate events instead of waiting for the `groupableDelay` (default is `true`).\n    *   `groupableDelay`: Time in ms to wait before emitting grouped events (default 100ms).\n    *   `cacheUsage`: Control how the cache is used (`CacheOnly`, `RelayOnly`, `Both`, `PARALLEL`). `PARALLEL` often provides the best UX.\n*   **Filter Specificity:** Use specific filters (kinds, authors, tags, ids) to minimize the data requested from relays. Avoid overly broad filters.\n*   **Fetching Single Events:** Use `fetchEvent` (singular) for fetching a single event by ID or filter, often useful for fetching profiles or specific referenced events.\n\n## 5. Fetching Profile Information\n\n*   **Use `ndk.getUser()`:** Get an `NDKUser` object. This doesn't automatically fetch the profile.\n    ```typescript\n    const user: NDKUser = ndk.getUser({ pubkey: \"pubkey...\" });\n    ```\n*   **Fetch Profile:** Call `user.fetchProfile()` to retrieve the kind 0 event. NDK handles caching.\n    ```typescript\n    const profile = await user.fetchProfile();\n    if (profile) {\n        console.log(`User name: ${profile.name}`);\n        console.log(`User bio: ${profile.about}`);\n    }\n    ```\n*   **Access Profile Data:** Access profile fields directly from the `user.profile` object after fetching.\n    ```typescript\n    if (user.profile) {\n        console.log(user.profile.nip05);\n    }\n    ```\n\n## 6. Publishing Events\n\n*   **Create `NDKEvent`:** Instantiate `NDKEvent` and set its properties (`kind`, `content`, `tags`).\n    ```typescript\n    const event = new NDKEvent(ndk);\n    event.kind = 1;\n    event.content = \"Hello from NDK!\";\n    event.tags = [[\"t\", \"ndk-test\"]];\n    ```\n*   **Sign:** Ensure `ndk.signer` is set. Signing happens automatically before publishing via `event.sign()`. For replaceable/parameterized replaceable events, call `sign()` explicitly if you need the ID before publishing, otherwise `publish()` handles it.\n*   **Publish:** Call `event.publish()`. This method is **optimistic** by default. It returns a promise that resolves with the set of relays the event was *sent* to, but doesn't guarantee successful writing or propagation.\n    ```typescript\n    try {\n        const publishedToRelays = await event.publish();\n        console.log(`Event ${event.id} published to ${publishedToRelays.size} relays`);\n\n    } catch (error) {\n        console.error(\"Failed to publish event:\", error);\n\n    }\n    ```\n*   **Replaceable Events:** Use `publishReplaceable()` for kinds 0, 3, 10000-19999, and 30000-39999.\n    ```typescript\n    const profileEvent = new NDKEvent(ndk);\n    profileEvent.kind = 0;\n    profileEvent.content = JSON.stringify({ name: \"New Name\" });\n    await profileEvent.publishReplaceable();\n    ```\n*   **Parameterized Replaceable Events:** Set the `d` tag and use `publishReplaceable()`.\n    ```typescript\n    const articleEvent = new NDKEvent(ndk);\n    articleEvent.kind = 30023;\n    articleEvent.content = \"My article content...\";\n    articleEvent.tags = [[\"d\", \"my-article-identifier\"], [\"title\", \"My Article\"]];\n    await articleEvent.publishReplaceable();\n    ```\n*   **Targeted Relays:** Publish to a specific set of relays using an `NDKRelaySet`.\n    ```typescript\n    const specificRelaySet = NDKRelaySet.fromRelayUrls([\"wss://relay.example.com\"], ndk);\n    await event.publish(specificRelaySet);\n    ```\n\n## 7. Event-Kind Wrapping\n\n*   **Prefer Kind Wrappers:** Use the specific classes provided in `ndk-core/src/events/kinds/*` (e.g., `NDKArticle`, `NDKNote`, `NDKUserProfile`, `NDKHighlight`, `NDKRelayList`) instead of manipulating raw `NDKEvent` tags and content whenever possible.\n*   **Instantiation:** Create wrappers directly or use the static `from(event)` method.\n    ```typescript\n    import { NDKArticle, NDKEvent } from \"@nostr-dev-kit/ndk\";\n\n\n    const article = new NDKArticle(ndk);\n    article.title = \"My New Article\";\n    article.content = \"Article body...\";\n    article.publishReplaceable();\n\n\n    const rawEvent: NDKEvent = await ndk.fetchEvent(\"note1...\");\n    if (rawEvent?.kind === NDKKind.Article) {\n        const wrappedArticle = NDKArticle.from(rawEvent);\n        console.log(wrappedArticle.title);\n    }\n    ```\n*   **Convenience Methods:** Utilize the getters and setters provided by the wrappers (e.g., `article.title`, `relayList.readRelayUrls`).\n\n## 8. Zapping\n\n*   **Instantiate `NDKZapper`:** Create an instance with the target (user or event), amount (in msat), and optional configuration.\n    ```typescript\n    import { NDKZapper, NDKUser } from \"@nostr-dev-kit/ndk\";\n\n    const targetUser = ndk.getUser({ pubkey: \"target_pubkey...\" });\n    const amountMsat = 21000;\n    const zapper = new NDKZapper(targetUser, amountMsat, \"msat\", { ndk, signer: ndk.signer, comment: \"Great post!\" });\n    ```\n*   **Provide Payment Callbacks:** You MUST provide `lnPay` and/or `cashuPay` callbacks in the `NDKZapper` options or globally in `ndk.walletConfig`. These functions handle the actual payment logic (fetching invoice, paying, providing proofs).\n    ```typescript\n\n    zapper.lnPay = async (paymentInfo) => {\n        console.log(`Need to pay LN invoice: ${paymentInfo.pr}`);\n\n\n\n        return undefined;\n    };\n    ```\n*   **Initiate Zap:** Call `zapper.zap()`. This handles fetching recipient zap info (LUD-06/16, NIP-61), generating zap requests (NIP-57), calling your payment callbacks, and publishing nutzaps (NIP-61).\n    ```typescript\n    try {\n        const results = await zapper.zap();\n        console.log(\"Zap results:\", results);\n        results.forEach((result, split) => {\n            if (result instanceof Error) {\n                console.error(`Zap failed for ${split.pubkey}: ${result.message}`);\n            } else {\n                console.log(`Zap successful for ${split.pubkey}:`, result);\n            }\n        });\n    } catch (error) {\n        console.error(\"Zap process failed:\", error);\n    }\n    ```\n*   **Event Handling:** Listen to events emitted by the `NDKZapper` instance (`ln_invoice`, `ln_payment`, `split:complete`, `complete`, `notice`) for detailed progress updates.\n*   **Splits:** Be aware that `NDKZapper` automatically handles zap splits defined in the target event's `zap` tags. Your payment callbacks will be called for each split recipient.\n\n## 9. Wallet Operations (`ndk-wallet`)\n\n*   **Core NDK doesn't include wallet UI/logic.** The `ndk-wallet` package provides implementations for common wallet interactions (NWC, WebLN, Cashu).\n*   **Integration:** In a core/terminal context, you would typically integrate `ndk-wallet` components to provide the necessary `lnPay` or `cashuPay` callbacks to `NDKZapper`.\n    *   **NWC:** Instantiate `NDKNwcWallet` with connection details, connect, and use its `payInvoice` method within your `lnPay` callback.\n    *   **Cashu:** Instantiate `NDKCashuWallet` (requires a mint interface), load state, and use its methods (`payLnInvoice`, `send`) within your `cashuPay` or `lnPay` callbacks.\n*   **Configuration:** Set up `ndk.walletConfig` globally or pass callbacks directly to `NDKZapper`.\n    ```typescript\n\n\n\n\n\n    ```\n\nRemember to handle errors gracefully throughout your application, especially during network operations like connecting, fetching, and publishing.",
  "version": "6",
  "fetchedAt": 1750348841147
}