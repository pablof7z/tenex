"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/typescript-lru-cache";
exports.ids = ["vendor-chunks/typescript-lru-cache"];
exports.modules = {

/***/ "(ssr)/./node_modules/typescript-lru-cache/dist/LRUCache.js":
/*!************************************************************!*\
  !*** ./node_modules/typescript-lru-cache/dist/LRUCache.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LRUCache = void 0;\r\nconst LRUCacheNode_1 = __webpack_require__(/*! ./LRUCacheNode */ \"(ssr)/./node_modules/typescript-lru-cache/dist/LRUCacheNode.js\");\r\n/**\r\n * A key value cache that implements the LRU policy.\r\n *\r\n * @typeparam TKey The type of the keys in the cache. Defaults to `string`.\r\n * @typeparam TValue The type of the values in the cache. Defaults to `any`.\r\n *\r\n * @see {@link https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)}\r\n */\r\nclass LRUCache {\r\n    /**\r\n     * Creates a new instance of the LRUCache.\r\n     *\r\n     * @param options Additional configuration options for the LRUCache.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * // No options.\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // With options.\r\n     * const cache = new LRUCache({\r\n     *  entryExpirationTimeInMS: 10000\r\n     * });\r\n     * ```\r\n     */\r\n    constructor(options) {\r\n        this.lookupTable = new Map();\r\n        this.head = null;\r\n        this.tail = null;\r\n        const { maxSize = 25, entryExpirationTimeInMS = null, onEntryEvicted, onEntryMarkedAsMostRecentlyUsed, cloneFn, clone } = options !== null && options !== void 0 ? options : {};\r\n        if (Number.isNaN(maxSize) || maxSize <= 0) {\r\n            throw new Error('maxSize must be greater than 0.');\r\n        }\r\n        if (typeof entryExpirationTimeInMS === 'number' &&\r\n            (entryExpirationTimeInMS <= 0 || Number.isNaN(entryExpirationTimeInMS))) {\r\n            throw new Error('entryExpirationTimeInMS must either be null (no expiry) or greater than 0');\r\n        }\r\n        this.maxSizeInternal = maxSize;\r\n        this.entryExpirationTimeInMS = entryExpirationTimeInMS;\r\n        this.onEntryEvicted = onEntryEvicted;\r\n        this.onEntryMarkedAsMostRecentlyUsed = onEntryMarkedAsMostRecentlyUsed;\r\n        this.clone = clone;\r\n        this.cloneFn = cloneFn;\r\n    }\r\n    /**\r\n     * Returns the number of entries in the LRUCache object.\r\n     * If the cache has entryExpirationTimeInMS set, expired entries will be removed before the size is returned.\r\n     *\r\n     * @returns The number of entries in the cache.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * const size = cache.size;\r\n     *\r\n     * // Will log 1\r\n     * console.log(size);\r\n     * ```\r\n     */\r\n    get size() {\r\n        this.cleanCache();\r\n        return this.lookupTable.size;\r\n    }\r\n    /**\r\n     * Returns the number of entries that can still be added to the LRUCache without evicting existing entries.\r\n     *\r\n     * @returns The number of entries that can still be added without evicting existing entries.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache({ maxSize: 10 });\r\n     *\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * const remainingSize = cache.remainingSize;\r\n     *\r\n     * // Will log 9 due to 9 spots remaining before reaching maxSize of 10.\r\n     * console.log(remainingSize);\r\n     * ```\r\n     */\r\n    get remainingSize() {\r\n        return this.maxSizeInternal - this.size;\r\n    }\r\n    /**\r\n     * Returns the most recently used (newest) entry in the cache.\r\n     * This will not mark the entry as recently used.\r\n     * If the newest node is expired, it will be removed.\r\n     *\r\n     * @returns The most recently used (newest) entry in the cache.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache({ maxSize: 10 });\r\n     *\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * const newest = cache.newest;\r\n     *\r\n     * // Will log testValue\r\n     * console.log(newest.value);\r\n     *\r\n     * // Will log testKey\r\n     * console.log(newest.key);\r\n     * ```\r\n     */\r\n    get newest() {\r\n        if (!this.head) {\r\n            return null;\r\n        }\r\n        if (this.head.isExpired) {\r\n            this.removeNodeFromListAndLookupTable(this.head);\r\n            return this.newest;\r\n        }\r\n        return this.mapNodeToEntry(this.head);\r\n    }\r\n    /**\r\n     * Returns the least recently used (oldest) entry in the cache.\r\n     * This will not mark the entry as recently used.\r\n     * If the oldest node is expired, it will be removed.\r\n     *\r\n     * @returns The least recently used (oldest) entry in the cache.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache({ maxSize: 10 });\r\n     *\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * const oldest = cache.oldest;\r\n     *\r\n     * // Will log testValue\r\n     * console.log(oldest.value);\r\n     *\r\n     * // Will log testKey\r\n     * console.log(oldest.key);\r\n     * ```\r\n     */\r\n    get oldest() {\r\n        if (!this.tail) {\r\n            return null;\r\n        }\r\n        if (this.tail.isExpired) {\r\n            this.removeNodeFromListAndLookupTable(this.tail);\r\n            return this.oldest;\r\n        }\r\n        return this.mapNodeToEntry(this.tail);\r\n    }\r\n    /**\r\n     * Gets or sets the maxSize of the cache.\r\n     * This will evict the least recently used entries if needed to reach new maxSize.\r\n     *\r\n     * @param value The new value for maxSize. Must be greater than 0.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache({ maxSize: 10 });\r\n     *\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Will be 10\r\n     * const maxSize = cache.maxSize;\r\n     *\r\n     * // Set new maxSize to 5. If there are more than 5 items in the cache, the least recently used entries will be removed until cache size is 5.\r\n     * cache.maxSize = 5;\r\n     * ```\r\n     */\r\n    get maxSize() {\r\n        return this.maxSizeInternal;\r\n    }\r\n    set maxSize(value) {\r\n        if (Number.isNaN(value) || value <= 0) {\r\n            throw new Error('maxSize must be greater than 0.');\r\n        }\r\n        this.maxSizeInternal = value;\r\n        this.enforceSizeLimit();\r\n    }\r\n    /**\r\n     * Sets the value for the key in the LRUCache object. Returns the LRUCache object.\r\n     * This marks the newly added entry as the most recently used entry.\r\n     * If adding the new entry makes the cache size go above maxSize,\r\n     * this will evict the least recently used entries until size is equal to maxSize.\r\n     *\r\n     * @param key The key of the entry.\r\n     * @param value The value to set for the key.\r\n     * @param entryOptions Additional configuration options for the cache entry.\r\n     *\r\n     * @returns The LRUCache instance.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Set the key key2 to value value2. Pass in optional options.\r\n     * cache.set('key2', 'value2', { entryExpirationTimeInMS: 10 });\r\n     * ```\r\n     */\r\n    set(key, value, entryOptions) {\r\n        const currentNodeForKey = this.lookupTable.get(key);\r\n        if (currentNodeForKey) {\r\n            this.removeNodeFromListAndLookupTable(currentNodeForKey);\r\n        }\r\n        const node = new LRUCacheNode_1.LRUCacheNode(key, value, {\r\n            entryExpirationTimeInMS: this.entryExpirationTimeInMS,\r\n            onEntryEvicted: this.onEntryEvicted,\r\n            onEntryMarkedAsMostRecentlyUsed: this.onEntryMarkedAsMostRecentlyUsed,\r\n            clone: this.clone,\r\n            cloneFn: this.cloneFn,\r\n            ...entryOptions\r\n        });\r\n        this.setNodeAsHead(node);\r\n        this.lookupTable.set(key, node);\r\n        this.enforceSizeLimit();\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns the value associated to the key, or null if there is none or if the entry is expired.\r\n     * If an entry is returned, this marks the returned entry as the most recently used entry.\r\n     *\r\n     * @param key The key of the entry to get.\r\n     *\r\n     * @returns The cached value or null.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Will be 'testValue'. Entry will now be most recently used.\r\n     * const item1 = cache.get('testKey');\r\n     *\r\n     * // Will be null\r\n     * const item2 = cache.get('keyNotInCache');\r\n     * ```\r\n     */\r\n    get(key) {\r\n        const node = this.lookupTable.get(key);\r\n        if (!node) {\r\n            return null;\r\n        }\r\n        if (node.isExpired) {\r\n            this.removeNodeFromListAndLookupTable(node);\r\n            return null;\r\n        }\r\n        this.setNodeAsHead(node);\r\n        return node.value;\r\n    }\r\n    /**\r\n     * Returns the value associated to the key, or null if there is none or if the entry is expired.\r\n     * If an entry is returned, this will not mark the entry as most recently accessed.\r\n     * Useful if a value is needed but the order of the cache should not be changed.\r\n     *\r\n     * @param key The key of the entry to get.\r\n     *\r\n     * @returns The cached value or null.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Will be 'testValue'\r\n     * const item1 = cache.peek('testKey');\r\n     *\r\n     * // Will be null\r\n     * const item2 = cache.peek('keyNotInCache');\r\n     * ```\r\n     */\r\n    peek(key) {\r\n        const node = this.lookupTable.get(key);\r\n        if (!node) {\r\n            return null;\r\n        }\r\n        if (node.isExpired) {\r\n            this.removeNodeFromListAndLookupTable(node);\r\n            return null;\r\n        }\r\n        return node.value;\r\n    }\r\n    /**\r\n     * Deletes the entry for the passed in key.\r\n     *\r\n     * @param key The key of the entry to delete\r\n     *\r\n     * @returns True if an element in the LRUCache object existed and has been removed,\r\n     * or false if the element does not exist.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Will be true\r\n     * const wasDeleted = cache.delete('testKey');\r\n     *\r\n     * // Will be false\r\n     * const wasDeleted2 = cache.delete('keyNotInCache');\r\n     * ```\r\n     */\r\n    delete(key) {\r\n        const node = this.lookupTable.get(key);\r\n        if (!node) {\r\n            return false;\r\n        }\r\n        return this.removeNodeFromListAndLookupTable(node);\r\n    }\r\n    /**\r\n     * Returns a boolean asserting whether a value has been associated to the key in the LRUCache object or not.\r\n     * This does not mark the entry as recently used.\r\n     * If the cache has a key but the entry is expired, it will be removed and false will be returned.\r\n     *\r\n     * @param key The key of the entry to check if exists\r\n     *\r\n     * @returns true if the cache contains the supplied key. False if not.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Will be true\r\n     * const wasDeleted = cache.has('testKey');\r\n     *\r\n     * // Will be false\r\n     * const wasDeleted2 = cache.has('keyNotInCache');\r\n     * ```\r\n     */\r\n    has(key) {\r\n        const node = this.lookupTable.get(key);\r\n        if (!node) {\r\n            return false;\r\n        }\r\n        if (node.isExpired) {\r\n            this.removeNodeFromListAndLookupTable(node);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Removes all entries in the cache.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Clear cache.\r\n     * cache.clear();\r\n     * ```\r\n     */\r\n    clear() {\r\n        this.head = null;\r\n        this.tail = null;\r\n        this.lookupTable.clear();\r\n    }\r\n    /**\r\n     * Searches the cache for an entry matching the passed in condition.\r\n     * Expired entries will be skipped (and removed).\r\n     * If multiply entries in the cache match the condition, the most recently used entry will be returned.\r\n     * If an entry is returned, this marks the returned entry as the most recently used entry.\r\n     *\r\n     * @param condition The condition to apply to each entry in the\r\n     *\r\n     * @returns The first cache entry to match the condition. Null if none match.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // item will be { key: 'testKey', value: 'testValue }\r\n     * const item = cache.find(entry => {\r\n     *   const { key, value } = entry;\r\n     *\r\n     *   if (key === 'testKey' || value === 'something') {\r\n     *     return true;\r\n     *   }\r\n     *\r\n     *   return false;\r\n     * });\r\n     *\r\n     * // item2 will be null\r\n     * const item2 = cache.find(entry => entry.key === 'notInCache');\r\n     * ```\r\n     */\r\n    find(condition) {\r\n        let node = this.head;\r\n        while (node) {\r\n            if (node.isExpired) {\r\n                const next = node.next;\r\n                this.removeNodeFromListAndLookupTable(node);\r\n                node = next;\r\n                continue;\r\n            }\r\n            const entry = this.mapNodeToEntry(node);\r\n            if (condition(entry)) {\r\n                this.setNodeAsHead(node);\r\n                return entry;\r\n            }\r\n            node = node.next;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Iterates over and applies the callback function to each entry in the cache.\r\n     * Iterates in order from most recently accessed entry to least recently.\r\n     * Expired entries will be skipped (and removed).\r\n     * No entry will be marked as recently used.\r\n     *\r\n     * @param callback the callback function to apply to the entry\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * cache.forEach((key, value, index) => {\r\n     *   // do something with key, value, and/or index\r\n     * });\r\n     * ```\r\n     */\r\n    forEach(callback) {\r\n        let node = this.head;\r\n        let index = 0;\r\n        while (node) {\r\n            if (node.isExpired) {\r\n                const next = node.next;\r\n                this.removeNodeFromListAndLookupTable(node);\r\n                node = next;\r\n                continue;\r\n            }\r\n            callback(node.value, node.key, index);\r\n            node = node.next;\r\n            index++;\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Generator which can be used with for ... of ... to iterate over the cache values.\r\n     * Iterates in order from most recently accessed entry to least recently.\r\n     * Expired entries will be skipped (and removed).\r\n     * No entry will be marked as accessed.\r\n     *\r\n     * @returns A Generator for the cache values.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * for (const value of cache.values()) {\r\n     *   // do something with the value\r\n     * }\r\n     * ```\r\n     */\r\n    *values() {\r\n        let node = this.head;\r\n        while (node) {\r\n            if (node.isExpired) {\r\n                const next = node.next;\r\n                this.removeNodeFromListAndLookupTable(node);\r\n                node = next;\r\n                continue;\r\n            }\r\n            yield node.value;\r\n            node = node.next;\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Generator which can be used with for ... of ... to iterate over the cache keys.\r\n     * Iterates in order from most recently accessed entry to least recently.\r\n     * Expired entries will be skipped (and removed).\r\n     * No entry will be marked as accessed.\r\n     *\r\n     * @returns A Generator for the cache keys.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * for (const key of cache.keys()) {\r\n     *   // do something with the key\r\n     * }\r\n     * ```\r\n     */\r\n    *keys() {\r\n        let node = this.head;\r\n        while (node) {\r\n            if (node.isExpired) {\r\n                const next = node.next;\r\n                this.removeNodeFromListAndLookupTable(node);\r\n                node = next;\r\n                continue;\r\n            }\r\n            yield node.key;\r\n            node = node.next;\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Generator which can be used with for ... of ... to iterate over the cache entries.\r\n     * Iterates in order from most recently accessed entry to least recently.\r\n     * Expired entries will be skipped (and removed).\r\n     * No entry will be marked as accessed.\r\n     *\r\n     * @returns A Generator for the cache entries.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * for (const entry of cache.entries()) {\r\n     *   const { key, value } = entry;\r\n     *   // do something with the entry\r\n     * }\r\n     * ```\r\n     */\r\n    *entries() {\r\n        let node = this.head;\r\n        while (node) {\r\n            if (node.isExpired) {\r\n                const next = node.next;\r\n                this.removeNodeFromListAndLookupTable(node);\r\n                node = next;\r\n                continue;\r\n            }\r\n            yield this.mapNodeToEntry(node);\r\n            node = node.next;\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Generator which can be used with for ... of ... to iterate over the cache entries.\r\n     * Iterates in order from most recently accessed entry to least recently.\r\n     * Expired entries will be skipped (and removed).\r\n     * No entry will be marked as accessed.\r\n     *\r\n     * @returns A Generator for the cache entries.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * for (const entry of cache) {\r\n     *   const { key, value } = entry;\r\n     *   // do something with the entry\r\n     * }\r\n     * ```\r\n     */\r\n    *[Symbol.iterator]() {\r\n        let node = this.head;\r\n        while (node) {\r\n            if (node.isExpired) {\r\n                const next = node.next;\r\n                this.removeNodeFromListAndLookupTable(node);\r\n                node = next;\r\n                continue;\r\n            }\r\n            yield this.mapNodeToEntry(node);\r\n            node = node.next;\r\n        }\r\n    }\r\n    enforceSizeLimit() {\r\n        let node = this.tail;\r\n        while (node !== null && this.size > this.maxSizeInternal) {\r\n            const prev = node.prev;\r\n            this.removeNodeFromListAndLookupTable(node);\r\n            node = prev;\r\n        }\r\n    }\r\n    mapNodeToEntry({ key, value }) {\r\n        return {\r\n            key,\r\n            value\r\n        };\r\n    }\r\n    setNodeAsHead(node) {\r\n        this.removeNodeFromList(node);\r\n        if (!this.head) {\r\n            this.head = node;\r\n            this.tail = node;\r\n        }\r\n        else {\r\n            node.next = this.head;\r\n            this.head.prev = node;\r\n            this.head = node;\r\n        }\r\n        node.invokeOnEntryMarkedAsMostRecentlyUsed();\r\n    }\r\n    removeNodeFromList(node) {\r\n        if (node.prev !== null) {\r\n            node.prev.next = node.next;\r\n        }\r\n        if (node.next !== null) {\r\n            node.next.prev = node.prev;\r\n        }\r\n        if (this.head === node) {\r\n            this.head = node.next;\r\n        }\r\n        if (this.tail === node) {\r\n            this.tail = node.prev;\r\n        }\r\n        node.next = null;\r\n        node.prev = null;\r\n    }\r\n    removeNodeFromListAndLookupTable(node) {\r\n        node.invokeOnEvicted();\r\n        this.removeNodeFromList(node);\r\n        return this.lookupTable.delete(node.key);\r\n    }\r\n    cleanCache() {\r\n        // Don't spend time cleaning if entries don't expire.\r\n        if (!this.entryExpirationTimeInMS) {\r\n            return;\r\n        }\r\n        const expiredNodes = [];\r\n        for (const node of this.lookupTable.values()) {\r\n            if (node.isExpired) {\r\n                expiredNodes.push(node);\r\n            }\r\n        }\r\n        expiredNodes.forEach(node => this.removeNodeFromListAndLookupTable(node));\r\n    }\r\n}\r\nexports.LRUCache = LRUCache;\r\n//# sourceMappingURL=LRUCache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1scnUtY2FjaGUvZGlzdC9MUlVDYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsdUJBQXVCLG1CQUFPLENBQUMsc0ZBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdIQUFnSDtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsNkJBQTZCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyIvVXNlcnMvcGFibG9mZXJuYW5kZXovdGVzdDEyMy9URU5FWC1wZmttYzkvbWFpbi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1scnUtY2FjaGUvZGlzdC9MUlVDYWNoZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkxSVUNhY2hlID0gdm9pZCAwO1xyXG5jb25zdCBMUlVDYWNoZU5vZGVfMSA9IHJlcXVpcmUoXCIuL0xSVUNhY2hlTm9kZVwiKTtcclxuLyoqXHJcbiAqIEEga2V5IHZhbHVlIGNhY2hlIHRoYXQgaW1wbGVtZW50cyB0aGUgTFJVIHBvbGljeS5cclxuICpcclxuICogQHR5cGVwYXJhbSBUS2V5IFRoZSB0eXBlIG9mIHRoZSBrZXlzIGluIHRoZSBjYWNoZS4gRGVmYXVsdHMgdG8gYHN0cmluZ2AuXHJcbiAqIEB0eXBlcGFyYW0gVFZhbHVlIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIGNhY2hlLiBEZWZhdWx0cyB0byBgYW55YC5cclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FjaGVfcmVwbGFjZW1lbnRfcG9saWNpZXMjTGVhc3RfcmVjZW50bHlfdXNlZF8oTFJVKX1cclxuICovXHJcbmNsYXNzIExSVUNhY2hlIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgTFJVQ2FjaGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBMUlVDYWNoZS5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogLy8gTm8gb3B0aW9ucy5cclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gV2l0aCBvcHRpb25zLlxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoe1xyXG4gICAgICogIGVudHJ5RXhwaXJhdGlvblRpbWVJbk1TOiAxMDAwMFxyXG4gICAgICogfSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMubG9va3VwVGFibGUgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IHsgbWF4U2l6ZSA9IDI1LCBlbnRyeUV4cGlyYXRpb25UaW1lSW5NUyA9IG51bGwsIG9uRW50cnlFdmljdGVkLCBvbkVudHJ5TWFya2VkQXNNb3N0UmVjZW50bHlVc2VkLCBjbG9uZUZuLCBjbG9uZSB9ID0gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XHJcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihtYXhTaXplKSB8fCBtYXhTaXplIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXhTaXplIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnlFeHBpcmF0aW9uVGltZUluTVMgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgICAgIChlbnRyeUV4cGlyYXRpb25UaW1lSW5NUyA8PSAwIHx8IE51bWJlci5pc05hTihlbnRyeUV4cGlyYXRpb25UaW1lSW5NUykpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZW50cnlFeHBpcmF0aW9uVGltZUluTVMgbXVzdCBlaXRoZXIgYmUgbnVsbCAobm8gZXhwaXJ5KSBvciBncmVhdGVyIHRoYW4gMCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1heFNpemVJbnRlcm5hbCA9IG1heFNpemU7XHJcbiAgICAgICAgdGhpcy5lbnRyeUV4cGlyYXRpb25UaW1lSW5NUyA9IGVudHJ5RXhwaXJhdGlvblRpbWVJbk1TO1xyXG4gICAgICAgIHRoaXMub25FbnRyeUV2aWN0ZWQgPSBvbkVudHJ5RXZpY3RlZDtcclxuICAgICAgICB0aGlzLm9uRW50cnlNYXJrZWRBc01vc3RSZWNlbnRseVVzZWQgPSBvbkVudHJ5TWFya2VkQXNNb3N0UmVjZW50bHlVc2VkO1xyXG4gICAgICAgIHRoaXMuY2xvbmUgPSBjbG9uZTtcclxuICAgICAgICB0aGlzLmNsb25lRm4gPSBjbG9uZUZuO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgTFJVQ2FjaGUgb2JqZWN0LlxyXG4gICAgICogSWYgdGhlIGNhY2hlIGhhcyBlbnRyeUV4cGlyYXRpb25UaW1lSW5NUyBzZXQsIGV4cGlyZWQgZW50cmllcyB3aWxsIGJlIHJlbW92ZWQgYmVmb3JlIHRoZSBzaXplIGlzIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY2FjaGUuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKCk7XHJcbiAgICAgKlxyXG4gICAgICogY2FjaGUuc2V0KCd0ZXN0S2V5JywgJ3Rlc3RWYWx1ZScpO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IHNpemUgPSBjYWNoZS5zaXplO1xyXG4gICAgICpcclxuICAgICAqIC8vIFdpbGwgbG9nIDFcclxuICAgICAqIGNvbnNvbGUubG9nKHNpemUpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHRoaXMuY2xlYW5DYWNoZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvb2t1cFRhYmxlLnNpemU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbnRyaWVzIHRoYXQgY2FuIHN0aWxsIGJlIGFkZGVkIHRvIHRoZSBMUlVDYWNoZSB3aXRob3V0IGV2aWN0aW5nIGV4aXN0aW5nIGVudHJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBlbnRyaWVzIHRoYXQgY2FuIHN0aWxsIGJlIGFkZGVkIHdpdGhvdXQgZXZpY3RpbmcgZXhpc3RpbmcgZW50cmllcy5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoeyBtYXhTaXplOiAxMCB9KTtcclxuICAgICAqXHJcbiAgICAgKiBjYWNoZS5zZXQoJ3Rlc3RLZXknLCAndGVzdFZhbHVlJyk7XHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgcmVtYWluaW5nU2l6ZSA9IGNhY2hlLnJlbWFpbmluZ1NpemU7XHJcbiAgICAgKlxyXG4gICAgICogLy8gV2lsbCBsb2cgOSBkdWUgdG8gOSBzcG90cyByZW1haW5pbmcgYmVmb3JlIHJlYWNoaW5nIG1heFNpemUgb2YgMTAuXHJcbiAgICAgKiBjb25zb2xlLmxvZyhyZW1haW5pbmdTaXplKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBnZXQgcmVtYWluaW5nU2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXhTaXplSW50ZXJuYWwgLSB0aGlzLnNpemU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG1vc3QgcmVjZW50bHkgdXNlZCAobmV3ZXN0KSBlbnRyeSBpbiB0aGUgY2FjaGUuXHJcbiAgICAgKiBUaGlzIHdpbGwgbm90IG1hcmsgdGhlIGVudHJ5IGFzIHJlY2VudGx5IHVzZWQuXHJcbiAgICAgKiBJZiB0aGUgbmV3ZXN0IG5vZGUgaXMgZXhwaXJlZCwgaXQgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBtb3N0IHJlY2VudGx5IHVzZWQgKG5ld2VzdCkgZW50cnkgaW4gdGhlIGNhY2hlLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSh7IG1heFNpemU6IDEwIH0pO1xyXG4gICAgICpcclxuICAgICAqIGNhY2hlLnNldCgndGVzdEtleScsICd0ZXN0VmFsdWUnKTtcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBuZXdlc3QgPSBjYWNoZS5uZXdlc3Q7XHJcbiAgICAgKlxyXG4gICAgICogLy8gV2lsbCBsb2cgdGVzdFZhbHVlXHJcbiAgICAgKiBjb25zb2xlLmxvZyhuZXdlc3QudmFsdWUpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFdpbGwgbG9nIHRlc3RLZXlcclxuICAgICAqIGNvbnNvbGUubG9nKG5ld2VzdC5rZXkpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGdldCBuZXdlc3QoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmhlYWQuaXNFeHBpcmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZUZyb21MaXN0QW5kTG9va3VwVGFibGUodGhpcy5oZWFkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV3ZXN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5tYXBOb2RlVG9FbnRyeSh0aGlzLmhlYWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsZWFzdCByZWNlbnRseSB1c2VkIChvbGRlc3QpIGVudHJ5IGluIHRoZSBjYWNoZS5cclxuICAgICAqIFRoaXMgd2lsbCBub3QgbWFyayB0aGUgZW50cnkgYXMgcmVjZW50bHkgdXNlZC5cclxuICAgICAqIElmIHRoZSBvbGRlc3Qgbm9kZSBpcyBleHBpcmVkLCBpdCB3aWxsIGJlIHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgKG9sZGVzdCkgZW50cnkgaW4gdGhlIGNhY2hlLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSh7IG1heFNpemU6IDEwIH0pO1xyXG4gICAgICpcclxuICAgICAqIGNhY2hlLnNldCgndGVzdEtleScsICd0ZXN0VmFsdWUnKTtcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBvbGRlc3QgPSBjYWNoZS5vbGRlc3Q7XHJcbiAgICAgKlxyXG4gICAgICogLy8gV2lsbCBsb2cgdGVzdFZhbHVlXHJcbiAgICAgKiBjb25zb2xlLmxvZyhvbGRlc3QudmFsdWUpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFdpbGwgbG9nIHRlc3RLZXlcclxuICAgICAqIGNvbnNvbGUubG9nKG9sZGVzdC5rZXkpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGdldCBvbGRlc3QoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnRhaWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnRhaWwuaXNFeHBpcmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZUZyb21MaXN0QW5kTG9va3VwVGFibGUodGhpcy50YWlsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2xkZXN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5tYXBOb2RlVG9FbnRyeSh0aGlzLnRhaWwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1heFNpemUgb2YgdGhlIGNhY2hlLlxyXG4gICAgICogVGhpcyB3aWxsIGV2aWN0IHRoZSBsZWFzdCByZWNlbnRseSB1c2VkIGVudHJpZXMgaWYgbmVlZGVkIHRvIHJlYWNoIG5ldyBtYXhTaXplLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgbmV3IHZhbHVlIGZvciBtYXhTaXplLiBNdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSh7IG1heFNpemU6IDEwIH0pO1xyXG4gICAgICpcclxuICAgICAqIGNhY2hlLnNldCgndGVzdEtleScsICd0ZXN0VmFsdWUnKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBXaWxsIGJlIDEwXHJcbiAgICAgKiBjb25zdCBtYXhTaXplID0gY2FjaGUubWF4U2l6ZTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBTZXQgbmV3IG1heFNpemUgdG8gNS4gSWYgdGhlcmUgYXJlIG1vcmUgdGhhbiA1IGl0ZW1zIGluIHRoZSBjYWNoZSwgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgZW50cmllcyB3aWxsIGJlIHJlbW92ZWQgdW50aWwgY2FjaGUgc2l6ZSBpcyA1LlxyXG4gICAgICogY2FjaGUubWF4U2l6ZSA9IDU7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZ2V0IG1heFNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4U2l6ZUludGVybmFsO1xyXG4gICAgfVxyXG4gICAgc2V0IG1heFNpemUodmFsdWUpIHtcclxuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWF4U2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1heFNpemVJbnRlcm5hbCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuZW5mb3JjZVNpemVMaW1pdCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgdGhlIGtleSBpbiB0aGUgTFJVQ2FjaGUgb2JqZWN0LiBSZXR1cm5zIHRoZSBMUlVDYWNoZSBvYmplY3QuXHJcbiAgICAgKiBUaGlzIG1hcmtzIHRoZSBuZXdseSBhZGRlZCBlbnRyeSBhcyB0aGUgbW9zdCByZWNlbnRseSB1c2VkIGVudHJ5LlxyXG4gICAgICogSWYgYWRkaW5nIHRoZSBuZXcgZW50cnkgbWFrZXMgdGhlIGNhY2hlIHNpemUgZ28gYWJvdmUgbWF4U2l6ZSxcclxuICAgICAqIHRoaXMgd2lsbCBldmljdCB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZCBlbnRyaWVzIHVudGlsIHNpemUgaXMgZXF1YWwgdG8gbWF4U2l6ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5LlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgZm9yIHRoZSBrZXkuXHJcbiAgICAgKiBAcGFyYW0gZW50cnlPcHRpb25zIEFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgY2FjaGUgZW50cnkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIExSVUNhY2hlIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFNldCB0aGUga2V5IHRlc3RLZXkgdG8gdmFsdWUgdGVzdFZhbHVlXHJcbiAgICAgKiBjYWNoZS5zZXQoJ3Rlc3RLZXknLCAndGVzdFZhbHVlJyk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gU2V0IHRoZSBrZXkga2V5MiB0byB2YWx1ZSB2YWx1ZTIuIFBhc3MgaW4gb3B0aW9uYWwgb3B0aW9ucy5cclxuICAgICAqIGNhY2hlLnNldCgna2V5MicsICd2YWx1ZTInLCB7IGVudHJ5RXhwaXJhdGlvblRpbWVJbk1TOiAxMCB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBzZXQoa2V5LCB2YWx1ZSwgZW50cnlPcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudE5vZGVGb3JLZXkgPSB0aGlzLmxvb2t1cFRhYmxlLmdldChrZXkpO1xyXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZUZvcktleSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGVGcm9tTGlzdEFuZExvb2t1cFRhYmxlKGN1cnJlbnROb2RlRm9yS2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBMUlVDYWNoZU5vZGVfMS5MUlVDYWNoZU5vZGUoa2V5LCB2YWx1ZSwge1xyXG4gICAgICAgICAgICBlbnRyeUV4cGlyYXRpb25UaW1lSW5NUzogdGhpcy5lbnRyeUV4cGlyYXRpb25UaW1lSW5NUyxcclxuICAgICAgICAgICAgb25FbnRyeUV2aWN0ZWQ6IHRoaXMub25FbnRyeUV2aWN0ZWQsXHJcbiAgICAgICAgICAgIG9uRW50cnlNYXJrZWRBc01vc3RSZWNlbnRseVVzZWQ6IHRoaXMub25FbnRyeU1hcmtlZEFzTW9zdFJlY2VudGx5VXNlZCxcclxuICAgICAgICAgICAgY2xvbmU6IHRoaXMuY2xvbmUsXHJcbiAgICAgICAgICAgIGNsb25lRm46IHRoaXMuY2xvbmVGbixcclxuICAgICAgICAgICAgLi4uZW50cnlPcHRpb25zXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zZXROb2RlQXNIZWFkKG5vZGUpO1xyXG4gICAgICAgIHRoaXMubG9va3VwVGFibGUuc2V0KGtleSwgbm9kZSk7XHJcbiAgICAgICAgdGhpcy5lbmZvcmNlU2l6ZUxpbWl0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgdG8gdGhlIGtleSwgb3IgbnVsbCBpZiB0aGVyZSBpcyBub25lIG9yIGlmIHRoZSBlbnRyeSBpcyBleHBpcmVkLlxyXG4gICAgICogSWYgYW4gZW50cnkgaXMgcmV0dXJuZWQsIHRoaXMgbWFya3MgdGhlIHJldHVybmVkIGVudHJ5IGFzIHRoZSBtb3N0IHJlY2VudGx5IHVzZWQgZW50cnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBnZXQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIGNhY2hlZCB2YWx1ZSBvciBudWxsLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFNldCB0aGUga2V5IHRlc3RLZXkgdG8gdmFsdWUgdGVzdFZhbHVlXHJcbiAgICAgKiBjYWNoZS5zZXQoJ3Rlc3RLZXknLCAndGVzdFZhbHVlJyk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gV2lsbCBiZSAndGVzdFZhbHVlJy4gRW50cnkgd2lsbCBub3cgYmUgbW9zdCByZWNlbnRseSB1c2VkLlxyXG4gICAgICogY29uc3QgaXRlbTEgPSBjYWNoZS5nZXQoJ3Rlc3RLZXknKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBXaWxsIGJlIG51bGxcclxuICAgICAqIGNvbnN0IGl0ZW0yID0gY2FjaGUuZ2V0KCdrZXlOb3RJbkNhY2hlJyk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmxvb2t1cFRhYmxlLmdldChrZXkpO1xyXG4gICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUuaXNFeHBpcmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZUZyb21MaXN0QW5kTG9va3VwVGFibGUobm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldE5vZGVBc0hlYWQobm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgdG8gdGhlIGtleSwgb3IgbnVsbCBpZiB0aGVyZSBpcyBub25lIG9yIGlmIHRoZSBlbnRyeSBpcyBleHBpcmVkLlxyXG4gICAgICogSWYgYW4gZW50cnkgaXMgcmV0dXJuZWQsIHRoaXMgd2lsbCBub3QgbWFyayB0aGUgZW50cnkgYXMgbW9zdCByZWNlbnRseSBhY2Nlc3NlZC5cclxuICAgICAqIFVzZWZ1bCBpZiBhIHZhbHVlIGlzIG5lZWRlZCBidXQgdGhlIG9yZGVyIG9mIHRoZSBjYWNoZSBzaG91bGQgbm90IGJlIGNoYW5nZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBnZXQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIGNhY2hlZCB2YWx1ZSBvciBudWxsLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFNldCB0aGUga2V5IHRlc3RLZXkgdG8gdmFsdWUgdGVzdFZhbHVlXHJcbiAgICAgKiBjYWNoZS5zZXQoJ3Rlc3RLZXknLCAndGVzdFZhbHVlJyk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gV2lsbCBiZSAndGVzdFZhbHVlJ1xyXG4gICAgICogY29uc3QgaXRlbTEgPSBjYWNoZS5wZWVrKCd0ZXN0S2V5Jyk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gV2lsbCBiZSBudWxsXHJcbiAgICAgKiBjb25zdCBpdGVtMiA9IGNhY2hlLnBlZWsoJ2tleU5vdEluQ2FjaGUnKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBwZWVrKGtleSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmxvb2t1cFRhYmxlLmdldChrZXkpO1xyXG4gICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUuaXNFeHBpcmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZUZyb21MaXN0QW5kTG9va3VwVGFibGUobm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgZW50cnkgZm9yIHRoZSBwYXNzZWQgaW4ga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gZGVsZXRlXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBhbiBlbGVtZW50IGluIHRoZSBMUlVDYWNoZSBvYmplY3QgZXhpc3RlZCBhbmQgaGFzIGJlZW4gcmVtb3ZlZCxcclxuICAgICAqIG9yIGZhbHNlIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0LlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFNldCB0aGUga2V5IHRlc3RLZXkgdG8gdmFsdWUgdGVzdFZhbHVlXHJcbiAgICAgKiBjYWNoZS5zZXQoJ3Rlc3RLZXknLCAndGVzdFZhbHVlJyk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gV2lsbCBiZSB0cnVlXHJcbiAgICAgKiBjb25zdCB3YXNEZWxldGVkID0gY2FjaGUuZGVsZXRlKCd0ZXN0S2V5Jyk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gV2lsbCBiZSBmYWxzZVxyXG4gICAgICogY29uc3Qgd2FzRGVsZXRlZDIgPSBjYWNoZS5kZWxldGUoJ2tleU5vdEluQ2FjaGUnKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBkZWxldGUoa2V5KSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubG9va3VwVGFibGUuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTm9kZUZyb21MaXN0QW5kTG9va3VwVGFibGUobm9kZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGFzc2VydGluZyB3aGV0aGVyIGEgdmFsdWUgaGFzIGJlZW4gYXNzb2NpYXRlZCB0byB0aGUga2V5IGluIHRoZSBMUlVDYWNoZSBvYmplY3Qgb3Igbm90LlxyXG4gICAgICogVGhpcyBkb2VzIG5vdCBtYXJrIHRoZSBlbnRyeSBhcyByZWNlbnRseSB1c2VkLlxyXG4gICAgICogSWYgdGhlIGNhY2hlIGhhcyBhIGtleSBidXQgdGhlIGVudHJ5IGlzIGV4cGlyZWQsIGl0IHdpbGwgYmUgcmVtb3ZlZCBhbmQgZmFsc2Ugd2lsbCBiZSByZXR1cm5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrIGlmIGV4aXN0c1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGNhY2hlIGNvbnRhaW5zIHRoZSBzdXBwbGllZCBrZXkuIEZhbHNlIGlmIG5vdC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBTZXQgdGhlIGtleSB0ZXN0S2V5IHRvIHZhbHVlIHRlc3RWYWx1ZVxyXG4gICAgICogY2FjaGUuc2V0KCd0ZXN0S2V5JywgJ3Rlc3RWYWx1ZScpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFdpbGwgYmUgdHJ1ZVxyXG4gICAgICogY29uc3Qgd2FzRGVsZXRlZCA9IGNhY2hlLmhhcygndGVzdEtleScpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFdpbGwgYmUgZmFsc2VcclxuICAgICAqIGNvbnN0IHdhc0RlbGV0ZWQyID0gY2FjaGUuaGFzKCdrZXlOb3RJbkNhY2hlJyk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgaGFzKGtleSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmxvb2t1cFRhYmxlLmdldChrZXkpO1xyXG4gICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlLmlzRXhwaXJlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGVGcm9tTGlzdEFuZExvb2t1cFRhYmxlKG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFsbCBlbnRyaWVzIGluIHRoZSBjYWNoZS5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBTZXQgdGhlIGtleSB0ZXN0S2V5IHRvIHZhbHVlIHRlc3RWYWx1ZVxyXG4gICAgICogY2FjaGUuc2V0KCd0ZXN0S2V5JywgJ3Rlc3RWYWx1ZScpO1xyXG4gICAgICpcclxuICAgICAqIC8vIENsZWFyIGNhY2hlLlxyXG4gICAgICogY2FjaGUuY2xlYXIoKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sb29rdXBUYWJsZS5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWFyY2hlcyB0aGUgY2FjaGUgZm9yIGFuIGVudHJ5IG1hdGNoaW5nIHRoZSBwYXNzZWQgaW4gY29uZGl0aW9uLlxyXG4gICAgICogRXhwaXJlZCBlbnRyaWVzIHdpbGwgYmUgc2tpcHBlZCAoYW5kIHJlbW92ZWQpLlxyXG4gICAgICogSWYgbXVsdGlwbHkgZW50cmllcyBpbiB0aGUgY2FjaGUgbWF0Y2ggdGhlIGNvbmRpdGlvbiwgdGhlIG1vc3QgcmVjZW50bHkgdXNlZCBlbnRyeSB3aWxsIGJlIHJldHVybmVkLlxyXG4gICAgICogSWYgYW4gZW50cnkgaXMgcmV0dXJuZWQsIHRoaXMgbWFya3MgdGhlIHJldHVybmVkIGVudHJ5IGFzIHRoZSBtb3N0IHJlY2VudGx5IHVzZWQgZW50cnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbmRpdGlvbiBUaGUgY29uZGl0aW9uIHRvIGFwcGx5IHRvIGVhY2ggZW50cnkgaW4gdGhlXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIGZpcnN0IGNhY2hlIGVudHJ5IHRvIG1hdGNoIHRoZSBjb25kaXRpb24uIE51bGwgaWYgbm9uZSBtYXRjaC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBTZXQgdGhlIGtleSB0ZXN0S2V5IHRvIHZhbHVlIHRlc3RWYWx1ZVxyXG4gICAgICogY2FjaGUuc2V0KCd0ZXN0S2V5JywgJ3Rlc3RWYWx1ZScpO1xyXG4gICAgICpcclxuICAgICAqIC8vIGl0ZW0gd2lsbCBiZSB7IGtleTogJ3Rlc3RLZXknLCB2YWx1ZTogJ3Rlc3RWYWx1ZSB9XHJcbiAgICAgKiBjb25zdCBpdGVtID0gY2FjaGUuZmluZChlbnRyeSA9PiB7XHJcbiAgICAgKiAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gZW50cnk7XHJcbiAgICAgKlxyXG4gICAgICogICBpZiAoa2V5ID09PSAndGVzdEtleScgfHwgdmFsdWUgPT09ICdzb21ldGhpbmcnKSB7XHJcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgKiAgIH1cclxuICAgICAqXHJcbiAgICAgKiAgIHJldHVybiBmYWxzZTtcclxuICAgICAqIH0pO1xyXG4gICAgICpcclxuICAgICAqIC8vIGl0ZW0yIHdpbGwgYmUgbnVsbFxyXG4gICAgICogY29uc3QgaXRlbTIgPSBjYWNoZS5maW5kKGVudHJ5ID0+IGVudHJ5LmtleSA9PT0gJ25vdEluQ2FjaGUnKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBmaW5kKGNvbmRpdGlvbikge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmlzRXhwaXJlZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5vZGUubmV4dDtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZUZyb21MaXN0QW5kTG9va3VwVGFibGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbmV4dDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5tYXBOb2RlVG9FbnRyeShub2RlKTtcclxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvbihlbnRyeSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUFzSGVhZChub2RlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhbmQgYXBwbGllcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZWFjaCBlbnRyeSBpbiB0aGUgY2FjaGUuXHJcbiAgICAgKiBJdGVyYXRlcyBpbiBvcmRlciBmcm9tIG1vc3QgcmVjZW50bHkgYWNjZXNzZWQgZW50cnkgdG8gbGVhc3QgcmVjZW50bHkuXHJcbiAgICAgKiBFeHBpcmVkIGVudHJpZXMgd2lsbCBiZSBza2lwcGVkIChhbmQgcmVtb3ZlZCkuXHJcbiAgICAgKiBObyBlbnRyeSB3aWxsIGJlIG1hcmtlZCBhcyByZWNlbnRseSB1c2VkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIGVudHJ5XHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gU2V0IHRoZSBrZXkgdGVzdEtleSB0byB2YWx1ZSB0ZXN0VmFsdWVcclxuICAgICAqIGNhY2hlLnNldCgndGVzdEtleScsICd0ZXN0VmFsdWUnKTtcclxuICAgICAqXHJcbiAgICAgKiBjYWNoZS5mb3JFYWNoKChrZXksIHZhbHVlLCBpbmRleCkgPT4ge1xyXG4gICAgICogICAvLyBkbyBzb21ldGhpbmcgd2l0aCBrZXksIHZhbHVlLCBhbmQvb3IgaW5kZXhcclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGZvckVhY2goY2FsbGJhY2spIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuaGVhZDtcclxuICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmlzRXhwaXJlZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5vZGUubmV4dDtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZUZyb21MaXN0QW5kTG9va3VwVGFibGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbmV4dDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKG5vZGUudmFsdWUsIG5vZGUua2V5LCBpbmRleCk7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgR2VuZXJhdG9yIHdoaWNoIGNhbiBiZSB1c2VkIHdpdGggZm9yIC4uLiBvZiAuLi4gdG8gaXRlcmF0ZSBvdmVyIHRoZSBjYWNoZSB2YWx1ZXMuXHJcbiAgICAgKiBJdGVyYXRlcyBpbiBvcmRlciBmcm9tIG1vc3QgcmVjZW50bHkgYWNjZXNzZWQgZW50cnkgdG8gbGVhc3QgcmVjZW50bHkuXHJcbiAgICAgKiBFeHBpcmVkIGVudHJpZXMgd2lsbCBiZSBza2lwcGVkIChhbmQgcmVtb3ZlZCkuXHJcbiAgICAgKiBObyBlbnRyeSB3aWxsIGJlIG1hcmtlZCBhcyBhY2Nlc3NlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBBIEdlbmVyYXRvciBmb3IgdGhlIGNhY2hlIHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBTZXQgdGhlIGtleSB0ZXN0S2V5IHRvIHZhbHVlIHRlc3RWYWx1ZVxyXG4gICAgICogY2FjaGUuc2V0KCd0ZXN0S2V5JywgJ3Rlc3RWYWx1ZScpO1xyXG4gICAgICpcclxuICAgICAqIGZvciAoY29uc3QgdmFsdWUgb2YgY2FjaGUudmFsdWVzKCkpIHtcclxuICAgICAqICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHZhbHVlXHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgKnZhbHVlcygpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuaGVhZDtcclxuICAgICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5pc0V4cGlyZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGVGcm9tTGlzdEFuZExvb2t1cFRhYmxlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5leHQ7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5aWVsZCBub2RlLnZhbHVlO1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIEdlbmVyYXRvciB3aGljaCBjYW4gYmUgdXNlZCB3aXRoIGZvciAuLi4gb2YgLi4uIHRvIGl0ZXJhdGUgb3ZlciB0aGUgY2FjaGUga2V5cy5cclxuICAgICAqIEl0ZXJhdGVzIGluIG9yZGVyIGZyb20gbW9zdCByZWNlbnRseSBhY2Nlc3NlZCBlbnRyeSB0byBsZWFzdCByZWNlbnRseS5cclxuICAgICAqIEV4cGlyZWQgZW50cmllcyB3aWxsIGJlIHNraXBwZWQgKGFuZCByZW1vdmVkKS5cclxuICAgICAqIE5vIGVudHJ5IHdpbGwgYmUgbWFya2VkIGFzIGFjY2Vzc2VkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEEgR2VuZXJhdG9yIGZvciB0aGUgY2FjaGUga2V5cy5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBTZXQgdGhlIGtleSB0ZXN0S2V5IHRvIHZhbHVlIHRlc3RWYWx1ZVxyXG4gICAgICogY2FjaGUuc2V0KCd0ZXN0S2V5JywgJ3Rlc3RWYWx1ZScpO1xyXG4gICAgICpcclxuICAgICAqIGZvciAoY29uc3Qga2V5IG9mIGNhY2hlLmtleXMoKSkge1xyXG4gICAgICogICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUga2V5XHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgKmtleXMoKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuaXNFeHBpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbm9kZS5uZXh0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlRnJvbUxpc3RBbmRMb29rdXBUYWJsZShub2RlKTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeWllbGQgbm9kZS5rZXk7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgR2VuZXJhdG9yIHdoaWNoIGNhbiBiZSB1c2VkIHdpdGggZm9yIC4uLiBvZiAuLi4gdG8gaXRlcmF0ZSBvdmVyIHRoZSBjYWNoZSBlbnRyaWVzLlxyXG4gICAgICogSXRlcmF0ZXMgaW4gb3JkZXIgZnJvbSBtb3N0IHJlY2VudGx5IGFjY2Vzc2VkIGVudHJ5IHRvIGxlYXN0IHJlY2VudGx5LlxyXG4gICAgICogRXhwaXJlZCBlbnRyaWVzIHdpbGwgYmUgc2tpcHBlZCAoYW5kIHJlbW92ZWQpLlxyXG4gICAgICogTm8gZW50cnkgd2lsbCBiZSBtYXJrZWQgYXMgYWNjZXNzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQSBHZW5lcmF0b3IgZm9yIHRoZSBjYWNoZSBlbnRyaWVzLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFNldCB0aGUga2V5IHRlc3RLZXkgdG8gdmFsdWUgdGVzdFZhbHVlXHJcbiAgICAgKiBjYWNoZS5zZXQoJ3Rlc3RLZXknLCAndGVzdFZhbHVlJyk7XHJcbiAgICAgKlxyXG4gICAgICogZm9yIChjb25zdCBlbnRyeSBvZiBjYWNoZS5lbnRyaWVzKCkpIHtcclxuICAgICAqICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBlbnRyeTtcclxuICAgICAqICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIGVudHJ5XHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgKmVudHJpZXMoKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuaXNFeHBpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbm9kZS5uZXh0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlRnJvbUxpc3RBbmRMb29rdXBUYWJsZShub2RlKTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeWllbGQgdGhpcy5tYXBOb2RlVG9FbnRyeShub2RlKTtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBHZW5lcmF0b3Igd2hpY2ggY2FuIGJlIHVzZWQgd2l0aCBmb3IgLi4uIG9mIC4uLiB0byBpdGVyYXRlIG92ZXIgdGhlIGNhY2hlIGVudHJpZXMuXHJcbiAgICAgKiBJdGVyYXRlcyBpbiBvcmRlciBmcm9tIG1vc3QgcmVjZW50bHkgYWNjZXNzZWQgZW50cnkgdG8gbGVhc3QgcmVjZW50bHkuXHJcbiAgICAgKiBFeHBpcmVkIGVudHJpZXMgd2lsbCBiZSBza2lwcGVkIChhbmQgcmVtb3ZlZCkuXHJcbiAgICAgKiBObyBlbnRyeSB3aWxsIGJlIG1hcmtlZCBhcyBhY2Nlc3NlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBBIEdlbmVyYXRvciBmb3IgdGhlIGNhY2hlIGVudHJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gU2V0IHRoZSBrZXkgdGVzdEtleSB0byB2YWx1ZSB0ZXN0VmFsdWVcclxuICAgICAqIGNhY2hlLnNldCgndGVzdEtleScsICd0ZXN0VmFsdWUnKTtcclxuICAgICAqXHJcbiAgICAgKiBmb3IgKGNvbnN0IGVudHJ5IG9mIGNhY2hlKSB7XHJcbiAgICAgKiAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gZW50cnk7XHJcbiAgICAgKiAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSBlbnRyeVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuaGVhZDtcclxuICAgICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5pc0V4cGlyZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGVGcm9tTGlzdEFuZExvb2t1cFRhYmxlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5leHQ7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLm1hcE5vZGVUb0VudHJ5KG5vZGUpO1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVuZm9yY2VTaXplTGltaXQoKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnRhaWw7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgdGhpcy5zaXplID4gdGhpcy5tYXhTaXplSW50ZXJuYWwpIHtcclxuICAgICAgICAgICAgY29uc3QgcHJldiA9IG5vZGUucHJldjtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlRnJvbUxpc3RBbmRMb29rdXBUYWJsZShub2RlKTtcclxuICAgICAgICAgICAgbm9kZSA9IHByZXY7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWFwTm9kZVRvRW50cnkoeyBrZXksIHZhbHVlIH0pIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBrZXksXHJcbiAgICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHNldE5vZGVBc0hlYWQobm9kZSkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlTm9kZUZyb21MaXN0KG5vZGUpO1xyXG4gICAgICAgIGlmICghdGhpcy5oZWFkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlLm5leHQgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZC5wcmV2ID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy5oZWFkID0gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZS5pbnZva2VPbkVudHJ5TWFya2VkQXNNb3N0UmVjZW50bHlVc2VkKCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVOb2RlRnJvbUxpc3Qobm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlLnByZXYgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgbm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlLm5leHQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmhlYWQgPT09IG5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkID0gbm9kZS5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy50YWlsID09PSBub2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5vZGUucHJldjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZS5uZXh0ID0gbnVsbDtcclxuICAgICAgICBub2RlLnByZXYgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTm9kZUZyb21MaXN0QW5kTG9va3VwVGFibGUobm9kZSkge1xyXG4gICAgICAgIG5vZGUuaW52b2tlT25FdmljdGVkKCk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVOb2RlRnJvbUxpc3Qobm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9va3VwVGFibGUuZGVsZXRlKG5vZGUua2V5KTtcclxuICAgIH1cclxuICAgIGNsZWFuQ2FjaGUoKSB7XHJcbiAgICAgICAgLy8gRG9uJ3Qgc3BlbmQgdGltZSBjbGVhbmluZyBpZiBlbnRyaWVzIGRvbid0IGV4cGlyZS5cclxuICAgICAgICBpZiAoIXRoaXMuZW50cnlFeHBpcmF0aW9uVGltZUluTVMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBleHBpcmVkTm9kZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5sb29rdXBUYWJsZS52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5pc0V4cGlyZWQpIHtcclxuICAgICAgICAgICAgICAgIGV4cGlyZWROb2Rlcy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cGlyZWROb2Rlcy5mb3JFYWNoKG5vZGUgPT4gdGhpcy5yZW1vdmVOb2RlRnJvbUxpc3RBbmRMb29rdXBUYWJsZShub2RlKSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5MUlVDYWNoZSA9IExSVUNhY2hlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MUlVDYWNoZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/typescript-lru-cache/dist/LRUCache.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/typescript-lru-cache/dist/LRUCacheNode.js":
/*!****************************************************************!*\
  !*** ./node_modules/typescript-lru-cache/dist/LRUCacheNode.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LRUCacheNode = void 0;\r\nclass LRUCacheNode {\r\n    constructor(key, value, options) {\r\n        const { entryExpirationTimeInMS = null, next = null, prev = null, onEntryEvicted, onEntryMarkedAsMostRecentlyUsed, clone, cloneFn } = options !== null && options !== void 0 ? options : {};\r\n        if (typeof entryExpirationTimeInMS === 'number' &&\r\n            (entryExpirationTimeInMS <= 0 || Number.isNaN(entryExpirationTimeInMS))) {\r\n            throw new Error('entryExpirationTimeInMS must either be null (no expiry) or greater than 0');\r\n        }\r\n        this.clone = clone !== null && clone !== void 0 ? clone : false;\r\n        this.cloneFn = cloneFn !== null && cloneFn !== void 0 ? cloneFn : this.defaultClone;\r\n        this.key = key;\r\n        this.internalValue = this.clone ? this.cloneFn(value) : value;\r\n        this.created = Date.now();\r\n        this.entryExpirationTimeInMS = entryExpirationTimeInMS;\r\n        this.next = next;\r\n        this.prev = prev;\r\n        this.onEntryEvicted = onEntryEvicted;\r\n        this.onEntryMarkedAsMostRecentlyUsed = onEntryMarkedAsMostRecentlyUsed;\r\n    }\r\n    get value() {\r\n        return this.clone ? this.cloneFn(this.internalValue) : this.internalValue;\r\n    }\r\n    get isExpired() {\r\n        return typeof this.entryExpirationTimeInMS === 'number' && Date.now() - this.created > this.entryExpirationTimeInMS;\r\n    }\r\n    invokeOnEvicted() {\r\n        if (this.onEntryEvicted) {\r\n            const { key, value, isExpired } = this;\r\n            this.onEntryEvicted({ key, value, isExpired });\r\n        }\r\n    }\r\n    invokeOnEntryMarkedAsMostRecentlyUsed() {\r\n        if (this.onEntryMarkedAsMostRecentlyUsed) {\r\n            const { key, value } = this;\r\n            this.onEntryMarkedAsMostRecentlyUsed({ key, value });\r\n        }\r\n    }\r\n    defaultClone(value) {\r\n        if (typeof value === 'boolean' || typeof value === 'string' || typeof value === 'number') {\r\n            return value;\r\n        }\r\n        return JSON.parse(JSON.stringify(value));\r\n    }\r\n}\r\nexports.LRUCacheNode = LRUCacheNode;\r\n//# sourceMappingURL=LRUCacheNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1scnUtY2FjaGUvZGlzdC9MUlVDYWNoZU5vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxnQkFBZ0IsNEhBQTRIO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQyxtREFBbUQsWUFBWTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYWJsb2Zlcm5hbmRlei90ZXN0MTIzL1RFTkVYLXBma21jOS9tYWluL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxydS1jYWNoZS9kaXN0L0xSVUNhY2hlTm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkxSVUNhY2hlTm9kZSA9IHZvaWQgMDtcclxuY2xhc3MgTFJVQ2FjaGVOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCB7IGVudHJ5RXhwaXJhdGlvblRpbWVJbk1TID0gbnVsbCwgbmV4dCA9IG51bGwsIHByZXYgPSBudWxsLCBvbkVudHJ5RXZpY3RlZCwgb25FbnRyeU1hcmtlZEFzTW9zdFJlY2VudGx5VXNlZCwgY2xvbmUsIGNsb25lRm4gfSA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnlFeHBpcmF0aW9uVGltZUluTVMgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgICAgIChlbnRyeUV4cGlyYXRpb25UaW1lSW5NUyA8PSAwIHx8IE51bWJlci5pc05hTihlbnRyeUV4cGlyYXRpb25UaW1lSW5NUykpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZW50cnlFeHBpcmF0aW9uVGltZUluTVMgbXVzdCBlaXRoZXIgYmUgbnVsbCAobm8gZXhwaXJ5KSBvciBncmVhdGVyIHRoYW4gMCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNsb25lID0gY2xvbmUgIT09IG51bGwgJiYgY2xvbmUgIT09IHZvaWQgMCA/IGNsb25lIDogZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jbG9uZUZuID0gY2xvbmVGbiAhPT0gbnVsbCAmJiBjbG9uZUZuICE9PSB2b2lkIDAgPyBjbG9uZUZuIDogdGhpcy5kZWZhdWx0Q2xvbmU7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbFZhbHVlID0gdGhpcy5jbG9uZSA/IHRoaXMuY2xvbmVGbih2YWx1ZSkgOiB2YWx1ZTtcclxuICAgICAgICB0aGlzLmNyZWF0ZWQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHRoaXMuZW50cnlFeHBpcmF0aW9uVGltZUluTVMgPSBlbnRyeUV4cGlyYXRpb25UaW1lSW5NUztcclxuICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xyXG4gICAgICAgIHRoaXMucHJldiA9IHByZXY7XHJcbiAgICAgICAgdGhpcy5vbkVudHJ5RXZpY3RlZCA9IG9uRW50cnlFdmljdGVkO1xyXG4gICAgICAgIHRoaXMub25FbnRyeU1hcmtlZEFzTW9zdFJlY2VudGx5VXNlZCA9IG9uRW50cnlNYXJrZWRBc01vc3RSZWNlbnRseVVzZWQ7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUgPyB0aGlzLmNsb25lRm4odGhpcy5pbnRlcm5hbFZhbHVlKSA6IHRoaXMuaW50ZXJuYWxWYWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBpc0V4cGlyZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLmVudHJ5RXhwaXJhdGlvblRpbWVJbk1TID09PSAnbnVtYmVyJyAmJiBEYXRlLm5vdygpIC0gdGhpcy5jcmVhdGVkID4gdGhpcy5lbnRyeUV4cGlyYXRpb25UaW1lSW5NUztcclxuICAgIH1cclxuICAgIGludm9rZU9uRXZpY3RlZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5vbkVudHJ5RXZpY3RlZCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUsIGlzRXhwaXJlZCB9ID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5vbkVudHJ5RXZpY3RlZCh7IGtleSwgdmFsdWUsIGlzRXhwaXJlZCB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpbnZva2VPbkVudHJ5TWFya2VkQXNNb3N0UmVjZW50bHlVc2VkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9uRW50cnlNYXJrZWRBc01vc3RSZWNlbnRseVVzZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLm9uRW50cnlNYXJrZWRBc01vc3RSZWNlbnRseVVzZWQoeyBrZXksIHZhbHVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlZmF1bHRDbG9uZSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTFJVQ2FjaGVOb2RlID0gTFJVQ2FjaGVOb2RlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MUlVDYWNoZU5vZGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/typescript-lru-cache/dist/LRUCacheNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/typescript-lru-cache/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/typescript-lru-cache/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n__exportStar(__webpack_require__(/*! ./LRUCache */ \"(ssr)/./node_modules/typescript-lru-cache/dist/LRUCache.js\"), exports);\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1scnUtY2FjaGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsOEVBQVk7QUFDakMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYWJsb2Zlcm5hbmRlei90ZXN0MTIzL1RFTkVYLXBma21jOS9tYWluL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxydS1jYWNoZS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xyXG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcclxuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KSk7XHJcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9MUlVDYWNoZVwiKSwgZXhwb3J0cyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/typescript-lru-cache/dist/index.js\n");

/***/ })

};
;