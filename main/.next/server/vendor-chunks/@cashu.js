"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@cashu";
exports.ids = ["vendor-chunks/@cashu"];
exports.modules = {

/***/ "(ssr)/./node_modules/@cashu/cashu-ts/lib/cashu-ts.es.js":
/*!*********************************************************!*\
  !*** ./node_modules/@cashu/cashu-ts/lib/cashu-ts.es.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CashuMint: () => (/* binding */ P),\n/* harmony export */   CashuWallet: () => (/* binding */ Be),\n/* harmony export */   CheckStateEnum: () => (/* binding */ le),\n/* harmony export */   HttpResponseError: () => (/* binding */ R),\n/* harmony export */   MeltQuoteState: () => (/* binding */ N),\n/* harmony export */   MintOperationError: () => (/* binding */ st),\n/* harmony export */   MintQuoteState: () => (/* binding */ j),\n/* harmony export */   NetworkError: () => (/* binding */ et),\n/* harmony export */   OutputData: () => (/* binding */ q),\n/* harmony export */   PaymentRequest: () => (/* binding */ Z),\n/* harmony export */   PaymentRequestTransportType: () => (/* binding */ fe),\n/* harmony export */   decodePaymentRequest: () => (/* binding */ De),\n/* harmony export */   deriveKeysetId: () => (/* binding */ Ue),\n/* harmony export */   getDecodedToken: () => (/* binding */ se),\n/* harmony export */   getDecodedTokenBinary: () => (/* binding */ xe),\n/* harmony export */   getEncodedToken: () => (/* binding */ Te),\n/* harmony export */   getEncodedTokenBinary: () => (/* binding */ Oe),\n/* harmony export */   getEncodedTokenV4: () => (/* binding */ ee),\n/* harmony export */   hasValidDleq: () => (/* binding */ ae),\n/* harmony export */   injectWebSocketImpl: () => (/* binding */ Fe),\n/* harmony export */   setGlobalRequestOptions: () => (/* binding */ Ne)\n/* harmony export */ });\n/* harmony import */ var _cashu_crypto_modules_client_NUT12__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cashu/crypto/modules/client/NUT12 */ \"(ssr)/./node_modules/@cashu/crypto/modules/esm/client/NUT12.js\");\n/* harmony import */ var _cashu_crypto_modules_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cashu/crypto/modules/common */ \"(ssr)/./node_modules/@cashu/crypto/modules/esm/common/index.js\");\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var _cashu_crypto_modules_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @cashu/crypto/modules/client */ \"(ssr)/./node_modules/@cashu/crypto/modules/esm/client/index.js\");\n/* harmony import */ var _cashu_crypto_modules_client_NUT11__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @cashu/crypto/modules/client/NUT11 */ \"(ssr)/./node_modules/@cashu/crypto/modules/esm/client/NUT11.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _cashu_crypto_modules_client_NUT09__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @cashu/crypto/modules/client/NUT09 */ \"(ssr)/./node_modules/@cashu/crypto/modules/esm/client/NUT09.js\");\n\n\n\n\n\n\n\n\n\n\nfunction Ot(s) {\n  return buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(s).toString(\"base64\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nfunction gt(s) {\n  return buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(s, \"base64\");\n}\nfunction xt(s) {\n  const t = JSON.stringify(s);\n  return Bt(buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(t).toString(\"base64\"));\n}\nfunction Ft(s) {\n  const t = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(Nt(s), \"base64\").toString();\n  return JSON.parse(t);\n}\nfunction Nt(s) {\n  return s.replace(/-/g, \"+\").replace(/_/g, \"/\").split(\"=\")[0];\n}\nfunction Bt(s) {\n  return s.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").split(\"=\")[0];\n}\nfunction Kt(s) {\n  return typeof s == \"number\" || typeof s == \"string\";\n}\nfunction J(s) {\n  const t = [];\n  return Y(s, t), new Uint8Array(t);\n}\nfunction Y(s, t) {\n  if (s === null)\n    t.push(246);\n  else if (s === void 0)\n    t.push(247);\n  else if (typeof s == \"boolean\")\n    t.push(s ? 245 : 244);\n  else if (typeof s == \"number\")\n    wt(s, t);\n  else if (typeof s == \"string\")\n    kt(s, t);\n  else if (Array.isArray(s))\n    Qt(s, t);\n  else if (s instanceof Uint8Array)\n    Rt(s, t);\n  else if (typeof s == \"object\")\n    Lt(s, t);\n  else\n    throw new Error(\"Unsupported type\");\n}\nfunction wt(s, t) {\n  if (s < 24)\n    t.push(s);\n  else if (s < 256)\n    t.push(24, s);\n  else if (s < 65536)\n    t.push(25, s >> 8, s & 255);\n  else if (s < 4294967296)\n    t.push(26, s >> 24, s >> 16 & 255, s >> 8 & 255, s & 255);\n  else\n    throw new Error(\"Unsupported integer size\");\n}\nfunction Rt(s, t) {\n  const e = s.length;\n  if (e < 24)\n    t.push(64 + e);\n  else if (e < 256)\n    t.push(88, e);\n  else if (e < 65536)\n    t.push(89, e >> 8 & 255, e & 255);\n  else if (e < 4294967296)\n    t.push(\n      90,\n      e >> 24 & 255,\n      e >> 16 & 255,\n      e >> 8 & 255,\n      e & 255\n    );\n  else\n    throw new Error(\"Byte string too long to encode\");\n  for (let n = 0; n < s.length; n++)\n    t.push(s[n]);\n}\nfunction kt(s, t) {\n  const e = new TextEncoder().encode(s), n = e.length;\n  if (n < 24)\n    t.push(96 + n);\n  else if (n < 256)\n    t.push(120, n);\n  else if (n < 65536)\n    t.push(121, n >> 8 & 255, n & 255);\n  else if (n < 4294967296)\n    t.push(\n      122,\n      n >> 24 & 255,\n      n >> 16 & 255,\n      n >> 8 & 255,\n      n & 255\n    );\n  else\n    throw new Error(\"String too long to encode\");\n  for (let r = 0; r < e.length; r++)\n    t.push(e[r]);\n}\nfunction Qt(s, t) {\n  const e = s.length;\n  if (e < 24)\n    t.push(128 | e);\n  else if (e < 256)\n    t.push(152, e);\n  else if (e < 65536)\n    t.push(153, e >> 8, e & 255);\n  else\n    throw new Error(\"Unsupported array length\");\n  for (const n of s)\n    Y(n, t);\n}\nfunction Lt(s, t) {\n  const e = Object.keys(s);\n  wt(e.length, t), t[t.length - 1] |= 160;\n  for (const n of e)\n    kt(n, t), Y(s[n], t);\n}\nfunction X(s) {\n  const t = new DataView(s.buffer, s.byteOffset, s.byteLength);\n  return W(t, 0).value;\n}\nfunction W(s, t) {\n  if (t >= s.byteLength)\n    throw new Error(\"Unexpected end of data\");\n  const e = s.getUint8(t++), n = e >> 5, r = e & 31;\n  switch (n) {\n    case 0:\n      return Wt(s, t, r);\n    case 1:\n      return jt(s, t, r);\n    case 2:\n      return Ct(s, t, r);\n    case 3:\n      return Ht(s, t, r);\n    case 4:\n      return $t(s, t, r);\n    case 5:\n      return zt(s, t, r);\n    case 7:\n      return Gt(s, t, r);\n    default:\n      throw new Error(`Unsupported major type: ${n}`);\n  }\n}\nfunction B(s, t, e) {\n  if (e < 24) return { value: e, offset: t };\n  if (e === 24) return { value: s.getUint8(t++), offset: t };\n  if (e === 25) {\n    const n = s.getUint16(t, !1);\n    return t += 2, { value: n, offset: t };\n  }\n  if (e === 26) {\n    const n = s.getUint32(t, !1);\n    return t += 4, { value: n, offset: t };\n  }\n  if (e === 27) {\n    const n = s.getUint32(t, !1), r = s.getUint32(t + 4, !1);\n    return t += 8, { value: n * 2 ** 32 + r, offset: t };\n  }\n  throw new Error(`Unsupported length: ${e}`);\n}\nfunction Wt(s, t, e) {\n  const { value: n, offset: r } = B(s, t, e);\n  return { value: n, offset: r };\n}\nfunction jt(s, t, e) {\n  const { value: n, offset: r } = B(s, t, e);\n  return { value: -1 - n, offset: r };\n}\nfunction Ct(s, t, e) {\n  const { value: n, offset: r } = B(s, t, e);\n  if (r + n > s.byteLength)\n    throw new Error(\"Byte string length exceeds data length\");\n  return { value: new Uint8Array(s.buffer, s.byteOffset + r, n), offset: r + n };\n}\nfunction Ht(s, t, e) {\n  const { value: n, offset: r } = B(s, t, e);\n  if (r + n > s.byteLength)\n    throw new Error(\"String length exceeds data length\");\n  const o = new Uint8Array(s.buffer, s.byteOffset + r, n);\n  return { value: new TextDecoder().decode(o), offset: r + n };\n}\nfunction $t(s, t, e) {\n  const { value: n, offset: r } = B(s, t, e), o = [];\n  let i = r;\n  for (let c = 0; c < n; c++) {\n    const a = W(s, i);\n    o.push(a.value), i = a.offset;\n  }\n  return { value: o, offset: i };\n}\nfunction zt(s, t, e) {\n  const { value: n, offset: r } = B(s, t, e), o = {};\n  let i = r;\n  for (let c = 0; c < n; c++) {\n    const a = W(s, i);\n    if (!Kt(a.value))\n      throw new Error(\"Invalid key type\");\n    const h = W(s, a.offset);\n    o[a.value] = h.value, i = h.offset;\n  }\n  return { value: o, offset: i };\n}\nfunction Vt(s) {\n  const t = (s & 31744) >> 10, e = s & 1023, n = s & 32768 ? -1 : 1;\n  return t === 0 ? n * 2 ** -14 * (e / 1024) : t === 31 ? e ? NaN : n * (1 / 0) : n * 2 ** (t - 15) * (1 + e / 1024);\n}\nfunction Gt(s, t, e) {\n  if (e < 24)\n    switch (e) {\n      case 20:\n        return { value: !1, offset: t };\n      case 21:\n        return { value: !0, offset: t };\n      case 22:\n        return { value: null, offset: t };\n      case 23:\n        return { value: void 0, offset: t };\n      default:\n        throw new Error(`Unknown simple value: ${e}`);\n    }\n  if (e === 24) return { value: s.getUint8(t++), offset: t };\n  if (e === 25) {\n    const n = Vt(s.getUint16(t, !1));\n    return t += 2, { value: n, offset: t };\n  }\n  if (e === 26) {\n    const n = s.getFloat32(t, !1);\n    return t += 4, { value: n, offset: t };\n  }\n  if (e === 27) {\n    const n = s.getFloat64(t, !1);\n    return t += 8, { value: n, offset: t };\n  }\n  throw new Error(`Unknown simple or float value: ${e}`);\n}\nclass Z {\n  constructor(t, e, n, r, o, i, c = !1) {\n    this.transport = t, this.id = e, this.amount = n, this.unit = r, this.mints = o, this.description = i, this.singleUse = c;\n  }\n  toRawRequest() {\n    const t = {\n      t: this.transport.map((e) => ({ t: e.type, a: e.target, g: e.tags }))\n    };\n    return this.id && (t.i = this.id), this.amount && (t.a = this.amount), this.unit && (t.u = this.unit), this.mints && (t.m = this.mints), this.description && (t.d = this.description), this.singleUse && (t.s = this.singleUse), t;\n  }\n  toEncodedRequest() {\n    const t = this.toRawRequest(), e = J(t);\n    return \"creqA\" + buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(e).toString(\"base64\");\n  }\n  getTransport(t) {\n    return this.transport.find((e) => e.type === t);\n  }\n  static fromRawRequest(t) {\n    const e = t.t.map((n) => ({\n      type: n.t,\n      target: n.a,\n      tags: n.g\n    }));\n    return new Z(\n      e,\n      t.i,\n      t.a,\n      t.u,\n      t.m,\n      t.d,\n      t.s\n    );\n  }\n  static fromEncodedRequest(t) {\n    if (!t.startsWith(\"creq\"))\n      throw new Error(\"unsupported pr: invalid prefix\");\n    if (t[4] !== \"A\")\n      throw new Error(\"unsupported pr version\");\n    const n = t.slice(5), r = gt(n), o = X(r);\n    return this.fromRawRequest(o);\n  }\n}\nconst Jt = \"A\", Yt = \"cashu\";\nfunction S(s, t, e, n) {\n  if (e) {\n    const o = ft(e);\n    if (o > s)\n      throw new Error(`Split is greater than total amount: ${o} > ${s}`);\n    if (e.some((i) => !_t(i, t)))\n      throw new Error(\"Provided amount preferences do not match the amounts of the mint keyset.\");\n    s = s - ft(e);\n  } else\n    e = [];\n  return bt(t, \"desc\").forEach((o) => {\n    const i = Math.floor(s / o);\n    for (let c = 0; c < i; ++c) e?.push(o);\n    s %= o;\n  }), e.sort((o, i) => o - i);\n}\nfunction dt(s, t, e, n) {\n  const r = [], o = s.map((h) => h.amount);\n  bt(e, \"asc\").forEach((h) => {\n    const d = o.filter((m) => m === h).length, f = Math.max(n - d, 0);\n    for (let m = 0; m < f && !(r.reduce((u, l) => u + l, 0) + h > t); ++m)\n      r.push(h);\n  });\n  const c = t - r.reduce((h, d) => h + d, 0);\n  return c && S(c, e).forEach((d) => {\n    r.push(d);\n  }), r.sort((h, d) => h - d);\n}\nfunction bt(s, t = \"desc\") {\n  return t == \"desc\" ? Object.keys(s).map((e) => parseInt(e)).sort((e, n) => n - e) : Object.keys(s).map((e) => parseInt(e)).sort((e, n) => e - n);\n}\nfunction _t(s, t) {\n  return s in t;\n}\nfunction Xt(s) {\n  return Et((0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(s));\n}\nfunction Et(s) {\n  return BigInt(`0x${s}`);\n}\nfunction Zt(s) {\n  return s.toString(16).padStart(64, \"0\");\n}\nfunction lt(s) {\n  return /^[a-f0-9]*$/i.test(s);\n}\nfunction Pt(s) {\n  return Array.isArray(s) ? s.some((t) => !lt(t.id)) : lt(s.id);\n}\nfunction te(s) {\n  const t = { token: [{ mint: s.mint, proofs: s.proofs }] };\n  return s.unit && (t.unit = s.unit), s.memo && (t.memo = s.memo), Yt + Jt + xt(t);\n}\nfunction Te(s, t) {\n  if (Pt(s.proofs) || t?.version === 3) {\n    if (t?.version === 4)\n      throw new Error(\"can not encode to v4 token if proofs contain non-hex keyset id\");\n    return te(s);\n  }\n  return ee(s);\n}\nfunction ee(s) {\n  if (s.proofs.forEach((c) => {\n    if (c.dleq && c.dleq.r == null)\n      throw new Error(\"Missing blinding factor in included DLEQ proof\");\n  }), Pt(s.proofs))\n    throw new Error(\"can not encode to v4 token if proofs contain non-hex keyset id\");\n  const e = St(s), n = J(e), r = \"cashu\", o = \"B\", i = Ot(n);\n  return r + o + i;\n}\nfunction St(s) {\n  const t = {}, e = s.mint;\n  for (let r = 0; r < s.proofs.length; r++) {\n    const o = s.proofs[r];\n    t[o.id] ? t[o.id].push(o) : t[o.id] = [o];\n  }\n  const n = {\n    m: e,\n    u: s.unit || \"sat\",\n    t: Object.keys(t).map(\n      (r) => ({\n        i: (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(r),\n        p: t[r].map(\n          (o) => ({\n            a: o.amount,\n            s: o.secret,\n            c: (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(o.C),\n            ...o.dleq && {\n              d: {\n                e: (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(o.dleq.e),\n                s: (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(o.dleq.s),\n                r: (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(o.dleq.r ?? \"00\")\n              }\n            }\n          })\n        )\n      })\n    )\n  };\n  return s.memo && (n.d = s.memo), n;\n}\nfunction It(s) {\n  const t = [];\n  s.t.forEach(\n    (n) => n.p.forEach((r) => {\n      t.push({\n        secret: r.s,\n        C: (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(r.c),\n        amount: r.a,\n        id: (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(n.i),\n        ...r.d && {\n          dleq: {\n            r: (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(r.d.r),\n            s: (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(r.d.s),\n            e: (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(r.d.e)\n          }\n        }\n      });\n    })\n  );\n  const e = { mint: s.m, proofs: t, unit: s.u || \"sat\" };\n  return s.d && (e.memo = s.d), e;\n}\nfunction se(s) {\n  return [\"web+cashu://\", \"cashu://\", \"cashu:\", \"cashu\"].forEach((e) => {\n    s.startsWith(e) && (s = s.slice(e.length));\n  }), ne(s);\n}\nfunction ne(s) {\n  const t = s.slice(0, 1), e = s.slice(1);\n  if (t === \"A\") {\n    const n = Ft(e);\n    if (n.token.length > 1)\n      throw new Error(\"Multi entry token are not supported\");\n    const r = n.token[0], o = {\n      mint: r.mint,\n      proofs: r.proofs,\n      unit: n.unit || \"sat\"\n    };\n    return n.memo && (o.memo = n.memo), o;\n  } else if (t === \"B\") {\n    const n = gt(e), r = X(n);\n    return It(r);\n  }\n  throw new Error(\"Token version is not supported\");\n}\nfunction Ue(s) {\n  const t = Object.entries(s).sort((r, o) => +r[0] - +o[0]).map(([, r]) => (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(r)).reduce((r, o) => re(r, o), new Uint8Array()), e = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_7__.sha256)(t);\n  return \"00\" + Buffer.from(e).toString(\"hex\").slice(0, 14);\n}\nfunction re(s, t) {\n  const e = new Uint8Array(s.length + t.length);\n  return e.set(s), e.set(t, s.length), e;\n}\nfunction v(s) {\n  return typeof s == \"object\";\n}\nfunction E(...s) {\n  return s.map((t) => t.replace(/(^\\/+|\\/+$)/g, \"\")).join(\"/\");\n}\nfunction oe(s) {\n  return s.replace(/\\/$/, \"\");\n}\nfunction U(s) {\n  return s.reduce((t, e) => t + e.amount, 0);\n}\nfunction De(s) {\n  return Z.fromEncodedRequest(s);\n}\nclass ie {\n  get value() {\n    return this._value;\n  }\n  set value(t) {\n    this._value = t;\n  }\n  get next() {\n    return this._next;\n  }\n  set next(t) {\n    this._next = t;\n  }\n  constructor(t) {\n    this._value = t, this._next = null;\n  }\n}\nclass ce {\n  get first() {\n    return this._first;\n  }\n  set first(t) {\n    this._first = t;\n  }\n  get last() {\n    return this._last;\n  }\n  set last(t) {\n    this._last = t;\n  }\n  get size() {\n    return this._size;\n  }\n  set size(t) {\n    this._size = t;\n  }\n  constructor() {\n    this._first = null, this._last = null, this._size = 0;\n  }\n  enqueue(t) {\n    const e = new ie(t);\n    return this._size === 0 || !this._last ? (this._first = e, this._last = e) : (this._last.next = e, this._last = e), this._size++, !0;\n  }\n  dequeue() {\n    if (this._size === 0 || !this._first) return null;\n    const t = this._first;\n    return this._first = t.next, t.next = null, this._size--, t.value;\n  }\n}\nfunction L(s) {\n  return s.map((t) => {\n    const e = { ...t };\n    return delete e.dleq, e;\n  });\n}\nfunction ae(s, t) {\n  if (s.dleq == null)\n    return !1;\n  const e = {\n    e: (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(s.dleq.e),\n    s: (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(s.dleq.s),\n    r: Et(s.dleq.r ?? \"00\")\n  };\n  if (!_t(s.amount, t.keys))\n    throw new Error(`undefined key for amount ${s.amount}`);\n  const n = t.keys[s.amount];\n  return !!(0,_cashu_crypto_modules_client_NUT12__WEBPACK_IMPORTED_MODULE_0__.verifyDLEQProof_reblind)(\n    new TextEncoder().encode(s.secret),\n    e,\n    (0,_cashu_crypto_modules_common__WEBPACK_IMPORTED_MODULE_1__.pointFromHex)(s.C),\n    (0,_cashu_crypto_modules_common__WEBPACK_IMPORTED_MODULE_1__.pointFromHex)(n)\n  );\n}\nfunction ue(...s) {\n  const t = s.reduce((r, o) => r + o.length, 0), e = new Uint8Array(t);\n  let n = 0;\n  for (let r = 0; r < s.length; r++)\n    e.set(s[r], n), n = n + s[r].length;\n  return e;\n}\nfunction Oe(s) {\n  const t = new TextEncoder(), e = St(s), n = J(e), r = t.encode(\"craw\"), o = t.encode(\"B\");\n  return ue(r, o, n);\n}\nfunction xe(s) {\n  const t = new TextDecoder(), e = t.decode(s.slice(0, 4)), n = t.decode(new Uint8Array([s[4]]));\n  if (e !== \"craw\" || n !== \"B\")\n    throw new Error(\"not a valid binary token\");\n  const r = s.slice(5), o = X(r);\n  return It(o);\n}\nfunction ft(s) {\n  return s.reduce((t, e) => t + e, 0);\n}\nlet tt;\ntypeof WebSocket < \"u\" && (tt = WebSocket);\nfunction Fe(s) {\n  tt = s;\n}\nfunction he() {\n  return tt;\n}\nclass x {\n  constructor() {\n    this.connectionMap = /* @__PURE__ */ new Map();\n  }\n  static getInstance() {\n    return x.instace || (x.instace = new x()), x.instace;\n  }\n  getConnection(t) {\n    if (this.connectionMap.has(t))\n      return this.connectionMap.get(t);\n    const e = new de(t);\n    return this.connectionMap.set(t, e), e;\n  }\n}\nclass de {\n  constructor(t) {\n    this.subListeners = {}, this.rpcListeners = {}, this.rpcId = 0, this._WS = he(), this.url = new URL(t), this.messageQueue = new ce();\n  }\n  connect() {\n    return this.connectionPromise || (this.connectionPromise = new Promise((t, e) => {\n      try {\n        this.ws = new this._WS(this.url);\n      } catch (n) {\n        e(n);\n        return;\n      }\n      this.ws.onopen = () => {\n        t();\n      }, this.ws.onerror = () => {\n        e(new Error(\"Failed to open WebSocket\"));\n      }, this.ws.onmessage = (n) => {\n        this.messageQueue.enqueue(n.data), this.handlingInterval || (this.handlingInterval = setInterval(\n          this.handleNextMesage.bind(this),\n          0\n        ));\n      }, this.ws.onclose = () => {\n        this.connectionPromise = void 0;\n      };\n    })), this.connectionPromise;\n  }\n  sendRequest(t, e) {\n    if (this.ws?.readyState !== 1)\n      throw new Error(\"Socket not open...\");\n    const n = this.rpcId;\n    this.rpcId++;\n    const r = JSON.stringify({ jsonrpc: \"2.0\", method: t, params: e, id: n });\n    this.ws?.send(r);\n  }\n  closeSubscription(t) {\n    this.ws?.send(JSON.stringify([\"CLOSE\", t]));\n  }\n  addSubListener(t, e) {\n    (this.subListeners[t] = this.subListeners[t] || []).push(e);\n  }\n  //TODO: Move to RPCManagerClass\n  addRpcListener(t, e, n) {\n    this.rpcListeners[n] = { callback: t, errorCallback: e };\n  }\n  //TODO: Move to RPCManagerClass\n  removeRpcListener(t) {\n    delete this.rpcListeners[t];\n  }\n  removeListener(t, e) {\n    if (this.subListeners[t].length === 1) {\n      delete this.subListeners[t];\n      return;\n    }\n    this.subListeners[t] = this.subListeners[t].filter((n) => n !== e);\n  }\n  async ensureConnection() {\n    this.ws?.readyState !== 1 && await this.connect();\n  }\n  handleNextMesage() {\n    if (this.messageQueue.size === 0) {\n      clearInterval(this.handlingInterval), this.handlingInterval = void 0;\n      return;\n    }\n    const t = this.messageQueue.dequeue();\n    let e;\n    try {\n      if (e = JSON.parse(t), \"result\" in e && e.id != null)\n        this.rpcListeners[e.id] && (this.rpcListeners[e.id].callback(), this.removeRpcListener(e.id));\n      else if (\"error\" in e && e.id != null)\n        this.rpcListeners[e.id] && (this.rpcListeners[e.id].errorCallback(e.error), this.removeRpcListener(e.id));\n      else if (\"method\" in e && !(\"id\" in e)) {\n        const n = e.params.subId;\n        if (!n)\n          return;\n        if (this.subListeners[n]?.length > 0) {\n          const r = e;\n          this.subListeners[n].forEach((o) => o(r.params.payload));\n        }\n      }\n    } catch (n) {\n      console.error(n);\n      return;\n    }\n  }\n  createSubscription(t, e, n) {\n    if (this.ws?.readyState !== 1)\n      return n(new Error(\"Socket is not open\"));\n    const r = (Math.random() + 1).toString(36).substring(7);\n    return this.addRpcListener(\n      () => {\n        this.addSubListener(r, e);\n      },\n      (o) => {\n        n(new Error(o.message));\n      },\n      this.rpcId\n    ), this.sendRequest(\"subscribe\", { ...t, subId: r }), this.rpcId++, r;\n  }\n  cancelSubscription(t, e) {\n    this.removeListener(t, e), this.rpcId++, this.sendRequest(\"unsubscribe\", { subId: t });\n  }\n  get activeSubscriptions() {\n    return Object.keys(this.subListeners);\n  }\n  close() {\n    this.ws && this.ws?.close();\n  }\n}\nvar le = /* @__PURE__ */ ((s) => (s.UNSPENT = \"UNSPENT\", s.PENDING = \"PENDING\", s.SPENT = \"SPENT\", s))(le || {}), N = /* @__PURE__ */ ((s) => (s.UNPAID = \"UNPAID\", s.PENDING = \"PENDING\", s.PAID = \"PAID\", s))(N || {}), j = /* @__PURE__ */ ((s) => (s.UNPAID = \"UNPAID\", s.PAID = \"PAID\", s.ISSUED = \"ISSUED\", s))(j || {}), fe = /* @__PURE__ */ ((s) => (s.POST = \"post\", s.NOSTR = \"nostr\", s))(fe || {});\nclass R extends Error {\n  constructor(t, e) {\n    super(t), this.status = e, this.name = \"HttpResponseError\", Object.setPrototypeOf(this, R.prototype);\n  }\n}\nclass et extends Error {\n  constructor(t) {\n    super(t), this.name = \"NetworkError\", Object.setPrototypeOf(this, et.prototype);\n  }\n}\nclass st extends R {\n  constructor(t, e) {\n    super(e || \"Unknown mint operation error\", 400), this.code = t, this.name = \"MintOperationError\", Object.setPrototypeOf(this, st.prototype);\n  }\n}\nlet At = {};\nfunction Ne(s) {\n  At = s;\n}\nasync function pe({\n  endpoint: s,\n  requestBody: t,\n  headers: e,\n  ...n\n}) {\n  const r = t ? JSON.stringify(t) : void 0, o = {\n    Accept: \"application/json, text/plain, */*\",\n    ...r ? { \"Content-Type\": \"application/json\" } : void 0,\n    ...e\n  };\n  let i;\n  try {\n    i = await fetch(s, { body: r, headers: o, ...n });\n  } catch (c) {\n    throw new et(c instanceof Error ? c.message : \"Network request failed\");\n  }\n  if (!i.ok) {\n    const c = await i.json().catch(() => ({ error: \"bad response\" }));\n    throw i.status === 400 && \"code\" in c && \"detail\" in c ? new st(c.code, c.detail) : new R(\n      \"error\" in c ? c.error : c.detail || \"HTTP request failed\",\n      i.status\n    );\n  }\n  try {\n    return await i.json();\n  } catch (c) {\n    throw console.error(\"Failed to parse HTTP response\", c), new R(\"bad response\", i.status);\n  }\n}\nasync function A(s) {\n  return await pe({ ...s, ...At });\n}\nfunction H(s) {\n  return s.state || (console.warn(\n    \"Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)\"\n  ), typeof s.paid == \"boolean\" && (s.state = s.paid ? N.PAID : N.UNPAID)), s;\n}\nfunction pt(s) {\n  return s.state || (console.warn(\n    \"Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)\"\n  ), typeof s.paid == \"boolean\" && (s.state = s.paid ? j.PAID : j.UNPAID)), s;\n}\nfunction me(s) {\n  return Array.isArray(s?.contact) && s?.contact.length > 0 && (s.contact = s.contact.map((t) => Array.isArray(t) && t.length === 2 && typeof t[0] == \"string\" && typeof t[1] == \"string\" ? (console.warn(\n    \"Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117\"\n  ), { method: t[0], info: t[1] }) : t)), s;\n}\nclass P {\n  /**\n   * @param _mintUrl requires mint URL to create this object\n   * @param _customRequest if passed, use custom request implementation for network communication with the mint\n   */\n  constructor(t, e) {\n    this._mintUrl = t, this._customRequest = e, this._mintUrl = oe(t), this._customRequest = e;\n  }\n  get mintUrl() {\n    return this._mintUrl;\n  }\n  /**\n   * fetches mints info at the /info endpoint\n   * @param mintUrl\n   * @param customRequest\n   */\n  static async getInfo(t, e) {\n    const r = await (e || A)({\n      endpoint: E(t, \"/v1/info\")\n    });\n    return me(r);\n  }\n  /**\n   * fetches mints info at the /info endpoint\n   */\n  async getInfo() {\n    return P.getInfo(this._mintUrl, this._customRequest);\n  }\n  /**\n   * Performs a swap operation with ecash inputs and outputs.\n   * @param mintUrl\n   * @param swapPayload payload containing inputs and outputs\n   * @param customRequest\n   * @returns signed outputs\n   */\n  static async swap(t, e, n) {\n    const o = await (n || A)({\n      endpoint: E(t, \"/v1/swap\"),\n      method: \"POST\",\n      requestBody: e\n    });\n    if (!v(o) || !Array.isArray(o?.signatures))\n      throw new Error(o.detail ?? \"bad response\");\n    return o;\n  }\n  /**\n   * Performs a swap operation with ecash inputs and outputs.\n   * @param swapPayload payload containing inputs and outputs\n   * @returns signed outputs\n   */\n  async swap(t) {\n    return P.swap(this._mintUrl, t, this._customRequest);\n  }\n  /**\n   * Requests a new mint quote from the mint.\n   * @param mintUrl\n   * @param mintQuotePayload Payload for creating a new mint quote\n   * @param customRequest\n   * @returns the mint will create and return a new mint quote containing a payment request for the specified amount and unit\n   */\n  static async createMintQuote(t, e, n) {\n    const o = await (n || A)({\n      endpoint: E(t, \"/v1/mint/quote/bolt11\"),\n      method: \"POST\",\n      requestBody: e\n    });\n    return pt(o);\n  }\n  /**\n   * Requests a new mint quote from the mint.\n   * @param mintQuotePayload Payload for creating a new mint quote\n   * @returns the mint will create and return a new mint quote containing a payment request for the specified amount and unit\n   */\n  async createMintQuote(t) {\n    return P.createMintQuote(this._mintUrl, t, this._customRequest);\n  }\n  /**\n   * Gets an existing mint quote from the mint.\n   * @param mintUrl\n   * @param quote Quote ID\n   * @param customRequest\n   * @returns the mint will create and return a Lightning invoice for the specified amount\n   */\n  static async checkMintQuote(t, e, n) {\n    const o = await (n || A)({\n      endpoint: E(t, \"/v1/mint/quote/bolt11\", e),\n      method: \"GET\"\n    });\n    return pt(o);\n  }\n  /**\n   * Gets an existing mint quote from the mint.\n   * @param quote Quote ID\n   * @returns the mint will create and return a Lightning invoice for the specified amount\n   */\n  async checkMintQuote(t) {\n    return P.checkMintQuote(this._mintUrl, t, this._customRequest);\n  }\n  /**\n   * Mints new tokens by requesting blind signatures on the provided outputs.\n   * @param mintUrl\n   * @param mintPayload Payload containing the outputs to get blind signatures on\n   * @param customRequest\n   * @returns serialized blinded signatures\n   */\n  static async mint(t, e, n) {\n    const o = await (n || A)({\n      endpoint: E(t, \"/v1/mint/bolt11\"),\n      method: \"POST\",\n      requestBody: e\n    });\n    if (!v(o) || !Array.isArray(o?.signatures))\n      throw new Error(\"bad response\");\n    return o;\n  }\n  /**\n   * Mints new tokens by requesting blind signatures on the provided outputs.\n   * @param mintPayload Payload containing the outputs to get blind signatures on\n   * @returns serialized blinded signatures\n   */\n  async mint(t) {\n    return P.mint(this._mintUrl, t, this._customRequest);\n  }\n  /**\n   * Requests a new melt quote from the mint.\n   * @param mintUrl\n   * @param MeltQuotePayload\n   * @returns\n   */\n  static async createMeltQuote(t, e, n) {\n    const o = await (n || A)({\n      endpoint: E(t, \"/v1/melt/quote/bolt11\"),\n      method: \"POST\",\n      requestBody: e\n    }), i = H(o);\n    if (!v(i) || typeof i?.amount != \"number\" || typeof i?.fee_reserve != \"number\" || typeof i?.quote != \"string\")\n      throw new Error(\"bad response\");\n    return i;\n  }\n  /**\n   * Requests a new melt quote from the mint.\n   * @param MeltQuotePayload\n   * @returns\n   */\n  async createMeltQuote(t) {\n    return P.createMeltQuote(this._mintUrl, t, this._customRequest);\n  }\n  /**\n   * Gets an existing melt quote.\n   * @param mintUrl\n   * @param quote Quote ID\n   * @returns\n   */\n  static async checkMeltQuote(t, e, n) {\n    const o = await (n || A)({\n      endpoint: E(t, \"/v1/melt/quote/bolt11\", e),\n      method: \"GET\"\n    }), i = H(o);\n    if (!v(i) || typeof i?.amount != \"number\" || typeof i?.fee_reserve != \"number\" || typeof i?.quote != \"string\" || typeof i?.state != \"string\" || !Object.values(N).includes(i.state))\n      throw new Error(\"bad response\");\n    return i;\n  }\n  /**\n   * Gets an existing melt quote.\n   * @param quote Quote ID\n   * @returns\n   */\n  async checkMeltQuote(t) {\n    return P.checkMeltQuote(this._mintUrl, t, this._customRequest);\n  }\n  /**\n   * Requests the mint to pay for a Bolt11 payment request by providing ecash as inputs to be spent. The inputs contain the amount and the fee_reserves for a Lightning payment. The payload can also contain blank outputs in order to receive back overpaid Lightning fees.\n   * @param mintUrl\n   * @param meltPayload\n   * @param customRequest\n   * @returns\n   */\n  static async melt(t, e, n) {\n    const o = await (n || A)({\n      endpoint: E(t, \"/v1/melt/bolt11\"),\n      method: \"POST\",\n      requestBody: e\n    }), i = H(o);\n    if (!v(i) || typeof i?.state != \"string\" || !Object.values(N).includes(i.state))\n      throw new Error(\"bad response\");\n    return i;\n  }\n  /**\n   * Ask mint to perform a melt operation. This pays a lightning invoice and destroys tokens matching its amount + fees\n   * @param meltPayload\n   * @returns\n   */\n  async melt(t) {\n    return P.melt(this._mintUrl, t, this._customRequest);\n  }\n  /**\n   * Checks if specific proofs have already been redeemed\n   * @param mintUrl\n   * @param checkPayload\n   * @param customRequest\n   * @returns redeemed and unredeemed ordered list of booleans\n   */\n  static async check(t, e, n) {\n    const o = await (n || A)({\n      endpoint: E(t, \"/v1/checkstate\"),\n      method: \"POST\",\n      requestBody: e\n    });\n    if (!v(o) || !Array.isArray(o?.states))\n      throw new Error(\"bad response\");\n    return o;\n  }\n  /**\n   * Get the mints public keys\n   * @param mintUrl\n   * @param keysetId optional param to get the keys for a specific keyset. If not specified, the keys from all active keysets are fetched\n   * @param customRequest\n   * @returns\n   */\n  static async getKeys(t, e, n) {\n    e && (e = e.replace(/\\//g, \"_\").replace(/\\+/g, \"-\"));\n    const o = await (n || A)({\n      endpoint: e ? E(t, \"/v1/keys\", e) : E(t, \"/v1/keys\")\n    });\n    if (!v(o) || !Array.isArray(o.keysets))\n      throw new Error(\"bad response\");\n    return o;\n  }\n  /**\n   * Get the mints public keys\n   * @param keysetId optional param to get the keys for a specific keyset. If not specified, the keys from all active keysets are fetched\n   * @returns the mints public keys\n   */\n  async getKeys(t, e) {\n    return await P.getKeys(\n      e || this._mintUrl,\n      t,\n      this._customRequest\n    );\n  }\n  /**\n   * Get the mints keysets in no specific order\n   * @param mintUrl\n   * @param customRequest\n   * @returns all the mints past and current keysets.\n   */\n  static async getKeySets(t, e) {\n    return (e || A)({ endpoint: E(t, \"/v1/keysets\") });\n  }\n  /**\n   * Get the mints keysets in no specific order\n   * @returns all the mints past and current keysets.\n   */\n  async getKeySets() {\n    return P.getKeySets(this._mintUrl, this._customRequest);\n  }\n  /**\n   * Checks if specific proofs have already been redeemed\n   * @param checkPayload\n   * @returns redeemed and unredeemed ordered list of booleans\n   */\n  async check(t) {\n    return P.check(this._mintUrl, t, this._customRequest);\n  }\n  static async restore(t, e, n) {\n    const o = await (n || A)({\n      endpoint: E(t, \"/v1/restore\"),\n      method: \"POST\",\n      requestBody: e\n    });\n    if (!v(o) || !Array.isArray(o?.outputs) || !Array.isArray(o?.signatures))\n      throw new Error(\"bad response\");\n    return o;\n  }\n  async restore(t) {\n    return P.restore(this._mintUrl, t, this._customRequest);\n  }\n  /**\n   * Tries to establish a websocket connection with the websocket mint url according to NUT-17\n   */\n  async connectWebSocket() {\n    if (this.ws)\n      await this.ws.ensureConnection();\n    else {\n      const t = new URL(this._mintUrl), e = \"v1/ws\";\n      t.pathname && (t.pathname.endsWith(\"/\") ? t.pathname += e : t.pathname += \"/\" + e), this.ws = x.getInstance().getConnection(\n        `${t.protocol === \"https:\" ? \"wss\" : \"ws\"}://${t.host}${t.pathname}`\n      );\n      try {\n        await this.ws.connect();\n      } catch (n) {\n        throw console.log(n), new Error(\"Failed to connect to WebSocket...\");\n      }\n    }\n  }\n  /**\n   * Closes a websocket connection\n   */\n  disconnectWebSocket() {\n    this.ws && this.ws.close();\n  }\n  get webSocketConnection() {\n    return this.ws;\n  }\n}\nclass mt {\n  constructor(t) {\n    this._mintInfo = t;\n  }\n  isSupported(t) {\n    switch (t) {\n      case 4:\n      case 5:\n        return this.checkMintMelt(t);\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 11:\n      case 12:\n      case 14:\n      case 20:\n        return this.checkGenericNut(t);\n      case 17:\n        return this.checkNut17();\n      case 15:\n        return this.checkNut15();\n      default:\n        throw new Error(\"nut is not supported by cashu-ts\");\n    }\n  }\n  checkGenericNut(t) {\n    return this._mintInfo.nuts[t]?.supported ? { supported: !0 } : { supported: !1 };\n  }\n  checkMintMelt(t) {\n    const e = this._mintInfo.nuts[t];\n    return e && e.methods.length > 0 && !e.disabled ? { disabled: !1, params: e.methods } : { disabled: !0, params: e.methods };\n  }\n  checkNut17() {\n    return this._mintInfo.nuts[17] && this._mintInfo.nuts[17].supported.length > 0 ? { supported: !0, params: this._mintInfo.nuts[17].supported } : { supported: !1 };\n  }\n  checkNut15() {\n    return this._mintInfo.nuts[15] && this._mintInfo.nuts[15].methods.length > 0 ? { supported: !0, params: this._mintInfo.nuts[15].methods } : { supported: !1 };\n  }\n  get contact() {\n    return this._mintInfo.contact;\n  }\n  get description() {\n    return this._mintInfo.description;\n  }\n  get description_long() {\n    return this._mintInfo.description_long;\n  }\n  get name() {\n    return this._mintInfo.name;\n  }\n  get pubkey() {\n    return this._mintInfo.pubkey;\n  }\n  get nuts() {\n    return this._mintInfo.nuts;\n  }\n  get version() {\n    return this._mintInfo.version;\n  }\n  get motd() {\n    return this._mintInfo.motd;\n  }\n}\nfunction ye(s, t) {\n  let e = s;\n  for (const r of t)\n    e += r.B_;\n  const n = new TextEncoder().encode(e);\n  return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_7__.sha256)(n);\n}\nfunction ge(s, t, e) {\n  const n = ye(t, e), r = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_8__.hexToBytes)(s), o = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_9__.schnorr.sign(n, r);\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_8__.bytesToHex)(o);\n}\nclass $ {\n  constructor(t, e, n) {\n    this.amount = t, this.B_ = e, this.id = n;\n  }\n  getSerializedBlindedMessage() {\n    return { amount: this.amount, B_: this.B_.toHex(!0), id: this.id };\n  }\n}\nfunction z(s) {\n  return typeof s == \"function\";\n}\nclass q {\n  constructor(t, e, n) {\n    this.secret = n, this.blindingFactor = e, this.blindedMessage = t;\n  }\n  toProof(t, e) {\n    let n;\n    t.dleq && (n = {\n      s: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_8__.hexToBytes)(t.dleq.s),\n      e: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_8__.hexToBytes)(t.dleq.e),\n      r: this.blindingFactor\n    });\n    const r = {\n      id: t.id,\n      amount: t.amount,\n      C_: (0,_cashu_crypto_modules_common__WEBPACK_IMPORTED_MODULE_1__.pointFromHex)(t.C_),\n      dleq: n\n    }, o = (0,_cashu_crypto_modules_common__WEBPACK_IMPORTED_MODULE_1__.pointFromHex)(e.keys[t.amount]), i = (0,_cashu_crypto_modules_client__WEBPACK_IMPORTED_MODULE_3__.constructProofFromPromise)(r, this.blindingFactor, this.secret, o);\n    return {\n      ...(0,_cashu_crypto_modules_client__WEBPACK_IMPORTED_MODULE_3__.serializeProof)(i),\n      ...n && {\n        dleq: {\n          s: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_8__.bytesToHex)(n.s),\n          e: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_8__.bytesToHex)(n.e),\n          r: Zt(n.r ?? BigInt(0))\n        }\n      }\n    };\n  }\n  static createP2PKData(t, e, n, r) {\n    return S(e, n.keys, r).map((i) => this.createSingleP2PKData(t, i, n.id));\n  }\n  static createSingleP2PKData(t, e, n) {\n    const r = [\n      \"P2PK\",\n      {\n        nonce: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_8__.bytesToHex)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_8__.randomBytes)(32)),\n        data: t.pubkey,\n        tags: []\n      }\n    ];\n    t.locktime && r[1].tags.push([\"locktime\", t.locktime]), t.refundKeys && r[1].tags.push([\"refund\", t.refundKeys]);\n    const o = JSON.stringify(r), i = new TextEncoder().encode(o), { r: c, B_: a } = (0,_cashu_crypto_modules_client__WEBPACK_IMPORTED_MODULE_3__.blindMessage)(i);\n    return new q(\n      new $(e, a, n).getSerializedBlindedMessage(),\n      c,\n      i\n    );\n  }\n  static createRandomData(t, e, n) {\n    return S(t, e.keys, n).map((o) => this.createSingleRandomData(o, e.id));\n  }\n  static createSingleRandomData(t, e) {\n    const n = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_8__.bytesToHex)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_8__.randomBytes)(32)), r = new TextEncoder().encode(n), { r: o, B_: i } = (0,_cashu_crypto_modules_client__WEBPACK_IMPORTED_MODULE_3__.blindMessage)(r);\n    return new q(\n      new $(t, i, e).getSerializedBlindedMessage(),\n      o,\n      r\n    );\n  }\n  static createDeterministicData(t, e, n, r, o) {\n    return S(t, r.keys, o).map(\n      (c, a) => this.createSingleDeterministicData(c, e, n + a, r.id)\n    );\n  }\n  static createSingleDeterministicData(t, e, n, r) {\n    const o = (0,_cashu_crypto_modules_client_NUT09__WEBPACK_IMPORTED_MODULE_5__.deriveSecret)(e, r, n), i = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_8__.bytesToHex)(o), c = new TextEncoder().encode(i), a = Xt((0,_cashu_crypto_modules_client_NUT09__WEBPACK_IMPORTED_MODULE_5__.deriveBlindingFactor)(e, r, n)), { r: h, B_: d } = (0,_cashu_crypto_modules_client__WEBPACK_IMPORTED_MODULE_3__.blindMessage)(c, a);\n    return new q(\n      new $(t, d, r).getSerializedBlindedMessage(),\n      h,\n      c\n    );\n  }\n}\nconst we = 3, ke = \"sat\";\nclass Be {\n  /**\n   * @param mint Cashu mint instance is used to make api calls\n   * @param options.unit optionally set unit (default is 'sat')\n   * @param options.keys public keys from the mint (will be fetched from mint if not provided)\n   * @param options.keysets keysets from the mint (will be fetched from mint if not provided)\n   * @param options.mintInfo mint info from the mint (will be fetched from mint if not provided)\n   * @param options.denominationTarget target number proofs per denomination (default: see @constant DEFAULT_DENOMINATION_TARGET)\n   * @param options.bip39seed BIP39 seed for deterministic secrets.\n   * @param options.keepFactory A function that will be used by all parts of the library that produce proofs to be kept (change, etc.).\n   * This can lead to poor performance, in which case the seed should be directly provided\n   */\n  constructor(t, e) {\n    this._keys = /* @__PURE__ */ new Map(), this._keysets = [], this._seed = void 0, this._unit = ke, this._mintInfo = void 0, this._denominationTarget = we, this.mint = t;\n    let n = [];\n    if (e?.keys && !Array.isArray(e.keys) ? n = [e.keys] : e?.keys && Array.isArray(e?.keys) && (n = e?.keys), n && n.forEach((r) => this._keys.set(r.id, r)), e?.unit && (this._unit = e?.unit), e?.keysets && (this._keysets = e.keysets), e?.mintInfo && (this._mintInfo = new mt(e.mintInfo)), e?.denominationTarget && (this._denominationTarget = e.denominationTarget), e?.bip39seed) {\n      if (e.bip39seed instanceof Uint8Array) {\n        this._seed = e.bip39seed;\n        return;\n      }\n      throw new Error(\"bip39seed must be a valid UInt8Array\");\n    }\n    e?.keepFactory && (this._keepFactory = e.keepFactory);\n  }\n  get unit() {\n    return this._unit;\n  }\n  get keys() {\n    return this._keys;\n  }\n  get keysetId() {\n    if (!this._keysetId)\n      throw new Error(\"No keysetId set\");\n    return this._keysetId;\n  }\n  set keysetId(t) {\n    this._keysetId = t;\n  }\n  get keysets() {\n    return this._keysets;\n  }\n  get mintInfo() {\n    if (!this._mintInfo)\n      throw new Error(\"Mint info not loaded\");\n    return this._mintInfo;\n  }\n  /**\n   * Get information about the mint\n   * @returns mint info\n   */\n  async getMintInfo() {\n    const t = await this.mint.getInfo();\n    return this._mintInfo = new mt(t), this._mintInfo;\n  }\n  /**\n   * Get stored information about the mint or request it if not loaded.\n   * @returns mint info\n   */\n  async lazyGetMintInfo() {\n    return this._mintInfo ? this._mintInfo : await this.getMintInfo();\n  }\n  /**\n   * Load mint information, keysets and keys. This function can be called if no keysets are passed in the constructor\n   */\n  async loadMint() {\n    await this.getMintInfo(), await this.getKeySets(), await this.getKeys();\n  }\n  /**\n   * Choose a keyset to activate based on the lowest input fee\n   *\n   * Note: this function will filter out deprecated base64 keysets\n   *\n   * @param keysets keysets to choose from\n   * @returns active keyset\n   */\n  getActiveKeyset(t) {\n    let e = t.filter((r) => r.active);\n    e = e.filter((r) => r.id.startsWith(\"00\"));\n    const n = e.sort(\n      (r, o) => (r.input_fee_ppk ?? 0) - (o.input_fee_ppk ?? 0)\n    )[0];\n    if (!n)\n      throw new Error(\"No active keyset found\");\n    return n;\n  }\n  /**\n   * Get keysets from the mint with the unit of the wallet\n   * @returns keysets with wallet's unit\n   */\n  async getKeySets() {\n    const e = (await this.mint.getKeySets()).keysets.filter((n) => n.unit === this._unit);\n    return this._keysets = e, this._keysets;\n  }\n  /**\n   * Get all active keys from the mint and set the keyset with the lowest fees as the active wallet keyset.\n   * @returns keyset\n   */\n  async getAllKeys() {\n    const t = await this.mint.getKeys();\n    return this._keys = new Map(t.keysets.map((e) => [e.id, e])), this.keysetId = this.getActiveKeyset(this._keysets).id, t.keysets;\n  }\n  /**\n   * Get public keys from the mint. If keys were already fetched, it will return those.\n   *\n   * If `keysetId` is set, it will fetch and return that specific keyset.\n   * Otherwise, we select an active keyset with the unit of the wallet.\n   *\n   * @param keysetId optional keysetId to get keys for\n   * @param forceRefresh? if set to true, it will force refresh the keyset from the mint\n   * @returns keyset\n   */\n  async getKeys(t, e) {\n    if ((!(this._keysets.length > 0) || e) && await this.getKeySets(), t || (t = this.getActiveKeyset(this._keysets).id), !this._keysets.find((n) => n.id === t) && (await this.getKeySets(), !this._keysets.find((n) => n.id === t)))\n      throw new Error(`could not initialize keys. No keyset with id '${t}' found`);\n    if (!this._keys.get(t)) {\n      const n = await this.mint.getKeys(t);\n      this._keys.set(t, n.keysets[0]);\n    }\n    return this.keysetId = t, this._keys.get(t);\n  }\n  /**\n   * Receive an encoded or raw Cashu token (only supports single tokens. It will only process the first token in the token array)\n   * @param {(string|Token)} token - Cashu token, either as string or decoded\n   * @param {ReceiveOptions} [options] - Optional configuration for token processing\n   * @returns New token with newly created proofs, token entries that had errors\n   */\n  async receive(t, e) {\n    const { requireDleq: n, keysetId: r, outputAmounts: o, counter: i, pubkey: c, privkey: a, outputData: h, p2pk: d } = e || {};\n    typeof t == \"string\" && (t = se(t));\n    const f = await this.getKeys(r);\n    if (n && t.proofs.some((k) => !ae(k, f)))\n      throw new Error(\"Token contains proofs with invalid DLEQ\");\n    const m = U(t.proofs) - this.getFeesForProofs(t.proofs);\n    let u;\n    h ? u = { send: h } : this._keepFactory && (u = { send: this._keepFactory });\n    const l = this.createSwapPayload(\n      m,\n      t.proofs,\n      f,\n      o,\n      i,\n      c,\n      a,\n      u,\n      d\n    ), { signatures: w } = await this.mint.swap(l.payload), y = l.outputData.map((k, p) => k.toProof(w[p], f)), g = [];\n    return l.sortedIndices.forEach((k, p) => {\n      g[k] = y[p];\n    }), g;\n  }\n  /**\n   * Send proofs of a given amount, by providing at least the required amount of proofs\n   * @param amount amount to send\n   * @param proofs array of proofs (accumulated amount of proofs must be >= than amount)\n   * @param {SendOptions} [options] - Optional parameters for configuring the send operation\n   * @returns {SendResponse}\n   */\n  async send(t, e, n) {\n    const {\n      proofsWeHave: r,\n      offline: o,\n      includeFees: i,\n      includeDleq: c,\n      keysetId: a,\n      outputAmounts: h,\n      pubkey: d,\n      privkey: f,\n      outputData: m\n    } = n || {};\n    if (c && (e = e.filter((y) => y.dleq != null)), U(e) < t)\n      throw new Error(\"Not enough funds available to send\");\n    const { keep: u, send: l } = this.selectProofsToSend(\n      e,\n      t,\n      n?.includeFees\n    ), w = i ? this.getFeesForProofs(l) : 0;\n    if (!o && (U(l) != t + w || // if the exact amount cannot be selected\n    h || d || f || a || m)) {\n      const { keep: y, send: g } = this.selectProofsToSend(\n        e,\n        t,\n        !0\n      );\n      r?.push(...y);\n      const k = await this.swap(t, g, n);\n      let { keep: p, send: _ } = k;\n      const T = k.serialized;\n      return p = y.concat(p), c || (_ = L(_)), { keep: p, send: _, serialized: T };\n    }\n    if (U(l) < t + w)\n      throw new Error(\"Not enough funds available to send\");\n    return c ? { keep: u, send: l } : { keep: u, send: L(l) };\n  }\n  selectProofsToSend(t, e, n) {\n    const r = t.sort((u, l) => u.amount - l.amount), o = r.filter((u) => u.amount <= e).sort((u, l) => l.amount - u.amount), c = r.filter((u) => u.amount > e).sort((u, l) => u.amount - l.amount)[0];\n    if (!o.length && c)\n      return {\n        keep: t.filter((u) => u.secret !== c.secret),\n        send: [c]\n      };\n    if (!o.length && !c)\n      return { keep: t, send: [] };\n    let a = e, h = [o[0]];\n    const d = [], f = n ? this.getFeesForProofs(h) : 0;\n    if (a -= h[0].amount - f / 1e3, a > 0) {\n      const { keep: u, send: l } = this.selectProofsToSend(\n        o.slice(1),\n        a,\n        n\n      );\n      h.push(...l), d.push(...u);\n    }\n    const m = n ? this.getFeesForProofs(h) : 0;\n    return U(h) < e + m && c && (h = [c]), {\n      keep: t.filter((u) => !h.includes(u)),\n      send: h\n    };\n  }\n  /**\n   * calculates the fees based on inputs (proofs)\n   * @param proofs input proofs to calculate fees for\n   * @returns fee amount\n   */\n  getFeesForProofs(t) {\n    if (!this._keysets.length)\n      throw new Error(\"Could not calculate fees. No keysets found\");\n    return new Set(t.map((r) => r.id)).forEach((r) => {\n      if (!this._keysets.find((o) => o.id === r))\n        throw new Error(`Could not calculate fees. No keyset found with id: ${r}`);\n    }), Math.floor(\n      Math.max(\n        (t.reduce(\n          (r, o) => r + (this._keysets.find((i) => i.id === o.id)?.input_fee_ppk || 0),\n          0\n        ) + 999) / 1e3,\n        0\n      )\n    );\n  }\n  /**\n   * calculates the fees based on inputs for a given keyset\n   * @param nInputs number of inputs\n   * @param keysetId keysetId used to lookup `input_fee_ppk`\n   * @returns fee amount\n   */\n  getFeesForKeyset(t, e) {\n    return Math.floor(\n      Math.max(\n        (t * (this._keysets.find((r) => r.id === e)?.input_fee_ppk || 0) + 999) / 1e3,\n        0\n      )\n    );\n  }\n  /**\n   * Splits and creates sendable tokens\n   * if no amount is specified, the amount is implied by the cumulative amount of all proofs\n   * if both amount and preference are set, but the preference cannot fulfill the amount, then we use the default split\n   *  @param {SwapOptions} [options] - Optional parameters for configuring the swap operation\n   * @returns promise of the change- and send-proofs\n   */\n  async swap(t, e, n) {\n    let { outputAmounts: r } = n || {};\n    const { includeFees: o, keysetId: i, counter: c, pubkey: a, privkey: h, proofsWeHave: d, outputData: f, p2pk: m } = n || {}, u = await this.getKeys(i), l = e;\n    let w = t;\n    const y = U(e);\n    let g = y - w - this.getFeesForProofs(l), k = r?.sendAmounts || S(w, u.keys);\n    if (o) {\n      let b = this.getFeesForKeyset(k.length, u.id), I = S(b, u.keys);\n      for (; this.getFeesForKeyset(k.concat(I).length, u.id) > b; )\n        b++, I = S(b, u.keys);\n      k = k.concat(I), w += b, g -= b;\n    }\n    let p;\n    if (!r?.keepAmounts && d)\n      p = dt(\n        d,\n        g,\n        u.keys,\n        this._denominationTarget\n      );\n    else if (r) {\n      if (r.keepAmounts?.reduce((b, I) => b + I, 0) != g)\n        throw new Error(\"Keep amounts do not match amount to keep\");\n      p = r.keepAmounts;\n    }\n    if (w + this.getFeesForProofs(l) > y)\n      throw console.error(\n        `Not enough funds available (${y}) for swap amountToSend: ${w} + fee: ${this.getFeesForProofs(\n          l\n        )} | length: ${l.length}`\n      ), new Error(\"Not enough funds available for swap\");\n    if (w + this.getFeesForProofs(l) + g != y)\n      throw new Error(\"Amounts do not match for swap\");\n    r = {\n      keepAmounts: p,\n      sendAmounts: k\n    };\n    const _ = f?.keep || this._keepFactory, T = f?.send, K = this.createSwapPayload(\n      w,\n      l,\n      u,\n      r,\n      c,\n      a,\n      h,\n      { keep: _, send: T },\n      m\n    ), { signatures: qt } = await this.mint.swap(K.payload), nt = K.outputData.map((b, I) => b.toProof(qt[I], u)), rt = [], ot = [], it = Array(K.keepVector.length), ct = Array(nt.length);\n    return K.sortedIndices.forEach((b, I) => {\n      it[b] = K.keepVector[I], ct[b] = nt[I];\n    }), ct.forEach((b, I) => {\n      it[I] ? rt.push(b) : ot.push(b);\n    }), {\n      keep: rt,\n      send: ot\n    };\n  }\n  /**\n   * Restores batches of deterministic proofs until no more signatures are returned from the mint\n   * @param [gapLimit=300] the amount of empty counters that should be returned before restoring ends (defaults to 300)\n   * @param [batchSize=100] the amount of proofs that should be restored at a time (defaults to 100)\n   * @param [counter=0] the counter that should be used as a starting point (defaults to 0)\n   * @param [keysetId] which keysetId to use for the restoration. If none is passed the instance's default one will be used\n   */\n  async batchRestore(t = 300, e = 100, n = 0, r) {\n    const o = Math.ceil(t / e), i = [];\n    let c, a = 0;\n    for (; a < o; ) {\n      const h = await this.restore(n, e, { keysetId: r });\n      h.proofs.length > 0 ? (a = 0, i.push(...h.proofs), c = h.lastCounterWithSignature) : a++, n += e;\n    }\n    return { proofs: i, lastCounterWithSignature: c };\n  }\n  /**\n   * Regenerates\n   * @param start set starting point for count (first cycle for each keyset should usually be 0)\n   * @param count set number of blinded messages that should be generated\n   * @param options.keysetId set a custom keysetId to restore from. keysetIds can be loaded with `CashuMint.getKeySets()`\n   */\n  async restore(t, e, n) {\n    const { keysetId: r } = n || {}, o = await this.getKeys(r);\n    if (!this._seed)\n      throw new Error(\"CashuWallet must be initialized with a seed to use restore\");\n    const i = Array(e).fill(1), c = q.createDeterministicData(\n      i.length,\n      this._seed,\n      t,\n      o,\n      i\n    ), { outputs: a, signatures: h } = await this.mint.restore({\n      outputs: c.map((u) => u.blindedMessage)\n    }), d = {};\n    a.forEach((u, l) => d[u.B_] = h[l]);\n    const f = [];\n    let m;\n    for (let u = 0; u < c.length; u++) {\n      const l = d[c[u].blindedMessage.B_];\n      l && (m = t + u, c[u].blindedMessage.amount = l.amount, f.push(c[u].toProof(l, o)));\n    }\n    return {\n      proofs: f,\n      lastCounterWithSignature: m\n    };\n  }\n  /**\n   * Requests a mint quote form the mint. Response returns a Lightning payment request for the requested given amount and unit.\n   * @param amount Amount requesting for mint.\n   * @param description optional description for the mint quote\n   * @param pubkey optional public key to lock the quote to\n   * @returns the mint will return a mint quote with a Lightning invoice for minting tokens of the specified amount and unit\n   */\n  async createMintQuote(t, e) {\n    const n = {\n      unit: this._unit,\n      amount: t,\n      description: e\n    };\n    return await this.mint.createMintQuote(n);\n  }\n  /**\n   * Requests a mint quote from the mint that is locked to a public key.\n   * @param amount Amount requesting for mint.\n   * @param pubkey public key to lock the quote to\n   * @param description optional description for the mint quote\n   * @returns the mint will return a mint quote with a Lightning invoice for minting tokens of the specified amount and unit.\n   * The quote will be locked to the specified `pubkey`.\n   */\n  async createLockedMintQuote(t, e, n) {\n    const { supported: r } = (await this.getMintInfo()).isSupported(20);\n    if (!r)\n      throw new Error(\"Mint does not support NUT-20\");\n    const o = {\n      unit: this._unit,\n      amount: t,\n      description: n,\n      pubkey: e\n    }, i = await this.mint.createMintQuote(o);\n    if (!i.pubkey)\n      throw new Error(\"Mint returned unlocked mint quote\");\n    return i;\n  }\n  /**\n   * Gets an existing mint quote from the mint.\n   * @param quote Quote ID\n   * @returns the mint will create and return a Lightning invoice for the specified amount\n   */\n  async checkMintQuote(t) {\n    return await this.mint.checkMintQuote(t);\n  }\n  async mintProofs(t, e, n) {\n    let { outputAmounts: r } = n || {};\n    const { counter: o, pubkey: i, p2pk: c, keysetId: a, proofsWeHave: h, outputData: d, privateKey: f } = n || {}, m = await this.getKeys(a);\n    !r && h && (r = {\n      keepAmounts: dt(h, t, m.keys, this._denominationTarget),\n      sendAmounts: []\n    });\n    let u = [];\n    if (d)\n      if (z(d)) {\n        const y = S(t, m.keys, r?.keepAmounts);\n        for (let g = 0; g < y.length; g++)\n          u.push(d(y[g], m));\n      } else\n        u = d;\n    else if (this._keepFactory) {\n      const y = S(t, m.keys, r?.keepAmounts);\n      for (let g = 0; g < y.length; g++)\n        u.push(this._keepFactory(y[g], m));\n    } else\n      u = this.createOutputData(\n        t,\n        m,\n        o,\n        i,\n        r?.keepAmounts,\n        c\n      );\n    let l;\n    if (typeof e != \"string\") {\n      if (!f)\n        throw new Error(\"Can not sign locked quote without private key\");\n      const y = u.map((k) => k.blindedMessage), g = ge(f, e.quote, y);\n      l = {\n        outputs: y,\n        quote: e.quote,\n        signature: g\n      };\n    } else\n      l = {\n        outputs: u.map((y) => y.blindedMessage),\n        quote: e\n      };\n    const { signatures: w } = await this.mint.mint(l);\n    return u.map((y, g) => y.toProof(w[g], m));\n  }\n  /**\n   * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order to pay a Lightning invoice.\n   * @param invoice LN invoice that needs to get a fee estimate\n   * @returns the mint will create and return a melt quote for the invoice with an amount and fee reserve\n   */\n  async createMeltQuote(t) {\n    const e = {\n      unit: this._unit,\n      request: t\n    };\n    return await this.mint.createMeltQuote(e);\n  }\n  /**\n   * Requests a multi path melt quote from the mint.\n   * @param invoice LN invoice that needs to get a fee estimate\n   * @param partialAmount the partial amount of the invoice's total to be paid by this instance\n   * @returns the mint will create and return a melt quote for the invoice with an amount and fee reserve\n   */\n  async createMultiPathMeltQuote(t, e) {\n    const { supported: n, params: r } = (await this.lazyGetMintInfo()).isSupported(15);\n    if (!n)\n      throw new Error(\"Mint does not support NUT-15\");\n    if (!r?.some((h) => h.method === \"bolt11\" && h.unit === this.unit))\n      throw new Error(`Mint does not support MPP for bolt11 and ${this.unit}`);\n    const i = {\n      mpp: {\n        amount: e\n      }\n    }, c = {\n      unit: this._unit,\n      request: t,\n      options: i\n    };\n    return await this.mint.createMeltQuote(c);\n  }\n  /**\n   * Return an existing melt quote from the mint.\n   * @param quote ID of the melt quote\n   * @returns the mint will return an existing melt quote\n   */\n  async checkMeltQuote(t) {\n    return await this.mint.checkMeltQuote(t);\n  }\n  /**\n   * Melt proofs for a melt quote. proofsToSend must be at least amount+fee_reserve form the melt quote. This function does not perform coin selection!.\n   * Returns melt quote and change proofs\n   * @param meltQuote ID of the melt quote\n   * @param proofsToSend proofs to melt\n   * @param {MeltProofOptions} [options] - Optional parameters for configuring the Melting Proof operation\n   * @returns\n   */\n  async meltProofs(t, e, n) {\n    const { keysetId: r, counter: o, privkey: i } = n || {}, c = await this.getKeys(r), a = this.createBlankOutputs(\n      U(e) - t.amount,\n      c,\n      o,\n      this._keepFactory\n    );\n    i != null && (e = (0,_cashu_crypto_modules_client_NUT11__WEBPACK_IMPORTED_MODULE_4__.getSignedProofs)(\n      e.map((f) => ({\n        amount: f.amount,\n        C: (0,_cashu_crypto_modules_common__WEBPACK_IMPORTED_MODULE_1__.pointFromHex)(f.C),\n        id: f.id,\n        secret: new TextEncoder().encode(f.secret)\n      })),\n      i\n    ).map((f) => (0,_cashu_crypto_modules_client__WEBPACK_IMPORTED_MODULE_3__.serializeProof)(f))), e = L(e);\n    const h = {\n      quote: t.quote,\n      inputs: e,\n      outputs: a.map((f) => f.blindedMessage)\n    }, d = await this.mint.melt(h);\n    return {\n      quote: d,\n      change: d.change?.map((f, m) => a[m].toProof(f, c)) ?? []\n    };\n  }\n  /**\n   * Creates a split payload\n   * @param amount amount to send\n   * @param proofsToSend proofs to split*\n   * @param outputAmounts? optionally specify the output's amounts to keep and to send.\n   * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect\n   * @param pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!\n   * @param privkey? will create a signature on the @param proofsToSend secrets if set\n   * @returns\n   */\n  createSwapPayload(t, e, n, r, o, i, c, a, h) {\n    const d = e.reduce((p, _) => p + _.amount, 0);\n    r && r.sendAmounts && !r.keepAmounts && (r.keepAmounts = S(\n      d - t - this.getFeesForProofs(e),\n      n.keys\n    ));\n    const f = d - t - this.getFeesForProofs(e);\n    let m = [], u = [];\n    if (a?.keep)\n      if (z(a.keep)) {\n        const p = a.keep;\n        S(f, n.keys).forEach((T) => {\n          m.push(p(T, n));\n        });\n      } else\n        m = a.keep;\n    else\n      m = this.createOutputData(\n        f,\n        n,\n        o,\n        void 0,\n        r?.keepAmounts,\n        void 0,\n        this._keepFactory\n      );\n    if (a?.send)\n      if (z(a.send)) {\n        const p = a.send;\n        S(t, n.keys).forEach((T) => {\n          u.push(p(T, n));\n        });\n      } else\n        u = a.send;\n    else\n      u = this.createOutputData(\n        t,\n        n,\n        o ? o + m.length : void 0,\n        i,\n        r?.sendAmounts,\n        h\n      );\n    c && (e = (0,_cashu_crypto_modules_client_NUT11__WEBPACK_IMPORTED_MODULE_4__.getSignedProofs)(\n      e.map((p) => ({\n        amount: p.amount,\n        C: (0,_cashu_crypto_modules_common__WEBPACK_IMPORTED_MODULE_1__.pointFromHex)(p.C),\n        id: p.id,\n        secret: new TextEncoder().encode(p.secret)\n      })),\n      c\n    ).map((p) => (0,_cashu_crypto_modules_client__WEBPACK_IMPORTED_MODULE_3__.serializeProof)(p))), e = L(e);\n    const l = [...m, ...u], w = l.map((p, _) => _).sort(\n      (p, _) => l[p].blindedMessage.amount - l[_].blindedMessage.amount\n    ), y = [\n      ...Array(m.length).fill(!0),\n      ...Array(u.length).fill(!1)\n    ], g = w.map((p) => l[p]), k = w.map((p) => y[p]);\n    return {\n      payload: {\n        inputs: e,\n        outputs: g.map((p) => p.blindedMessage)\n      },\n      outputData: g,\n      keepVector: k,\n      sortedIndices: w\n    };\n  }\n  /**\n   * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)\n   * @param proofs (only the `secret` field is required)\n   * @returns\n   */\n  async checkProofsStates(t) {\n    const e = new TextEncoder(), n = t.map((i) => (0,_cashu_crypto_modules_common__WEBPACK_IMPORTED_MODULE_1__.hashToCurve)(e.encode(i.secret)).toHex(!0)), r = 100, o = [];\n    for (let i = 0; i < n.length; i += r) {\n      const c = n.slice(i, i + r), { states: a } = await this.mint.check({\n        Ys: c\n      }), h = {};\n      a.forEach((d) => {\n        h[d.Y] = d;\n      });\n      for (let d = 0; d < c.length; d++) {\n        const f = h[c[d]];\n        if (!f)\n          throw new Error(\"Could not find state for proof with Y: \" + c[d]);\n        o.push(f);\n      }\n    }\n    return o;\n  }\n  /**\n   * Register a callback to be called whenever a mint quote's state changes\n   * @param quoteIds List of mint quote IDs that should be subscribed to\n   * @param callback Callback function that will be called whenever a mint quote state changes\n   * @param errorCallback\n   * @returns\n   */\n  async onMintQuoteUpdates(t, e, n) {\n    if (await this.mint.connectWebSocket(), !this.mint.webSocketConnection)\n      throw new Error(\"failed to establish WebSocket connection.\");\n    const r = this.mint.webSocketConnection.createSubscription(\n      { kind: \"bolt11_mint_quote\", filters: t },\n      e,\n      n\n    );\n    return () => {\n      this.mint.webSocketConnection?.cancelSubscription(r, e);\n    };\n  }\n  /**\n   * Register a callback to be called whenever a melt quote's state changes\n   * @param quoteIds List of melt quote IDs that should be subscribed to\n   * @param callback Callback function that will be called whenever a melt quote state changes\n   * @param errorCallback\n   * @returns\n   */\n  async onMeltQuotePaid(t, e, n) {\n    return this.onMeltQuoteUpdates(\n      [t],\n      (r) => {\n        r.state === N.PAID && e(r);\n      },\n      n\n    );\n  }\n  /**\n   * Register a callback to be called when a single mint quote gets paid\n   * @param quoteId Mint quote id that should be subscribed to\n   * @param callback Callback function that will be called when this mint quote gets paid\n   * @param errorCallback\n   * @returns\n   */\n  async onMintQuotePaid(t, e, n) {\n    return this.onMintQuoteUpdates(\n      [t],\n      (r) => {\n        r.state === j.PAID && e(r);\n      },\n      n\n    );\n  }\n  /**\n   * Register a callback to be called when a single melt quote gets paid\n   * @param quoteId Melt quote id that should be subscribed to\n   * @param callback Callback function that will be called when this melt quote gets paid\n   * @param errorCallback\n   * @returns\n   */\n  async onMeltQuoteUpdates(t, e, n) {\n    if (await this.mint.connectWebSocket(), !this.mint.webSocketConnection)\n      throw new Error(\"failed to establish WebSocket connection.\");\n    const r = this.mint.webSocketConnection.createSubscription(\n      { kind: \"bolt11_melt_quote\", filters: t },\n      e,\n      n\n    );\n    return () => {\n      this.mint.webSocketConnection?.cancelSubscription(r, e);\n    };\n  }\n  /**\n   * Register a callback to be called whenever a subscribed proof state changes\n   * @param proofs List of proofs that should be subscribed to\n   * @param callback Callback function that will be called whenever a proof's state changes\n   * @param errorCallback\n   * @returns\n   */\n  async onProofStateUpdates(t, e, n) {\n    if (await this.mint.connectWebSocket(), !this.mint.webSocketConnection)\n      throw new Error(\"failed to establish WebSocket connection.\");\n    const r = new TextEncoder(), o = {};\n    for (let a = 0; a < t.length; a++) {\n      const h = (0,_cashu_crypto_modules_common__WEBPACK_IMPORTED_MODULE_1__.hashToCurve)(r.encode(t[a].secret)).toHex(!0);\n      o[h] = t[a];\n    }\n    const i = Object.keys(o), c = this.mint.webSocketConnection.createSubscription(\n      { kind: \"proof_state\", filters: i },\n      (a) => {\n        e({ ...a, proof: o[a.Y] });\n      },\n      n\n    );\n    return () => {\n      this.mint.webSocketConnection?.cancelSubscription(c, e);\n    };\n  }\n  /**\n   * Creates blinded messages for a according to @param amounts\n   * @param amount array of amounts to create blinded messages for\n   * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect\n   * @param keyksetId? override the keysetId derived from the current mintKeys with a custom one. This should be a keyset that was fetched from the `/keysets` endpoint\n   * @param pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!\n   * @returns blinded messages, secrets, rs, and amounts\n   */\n  createOutputData(t, e, n, r, o, i, c) {\n    let a;\n    if (r)\n      a = q.createP2PKData({ pubkey: r }, t, e, o);\n    else if (n || n === 0) {\n      if (!this._seed)\n        throw new Error(\"cannot create deterministic messages without seed\");\n      a = q.createDeterministicData(\n        t,\n        this._seed,\n        n,\n        e,\n        o\n      );\n    } else i ? a = q.createP2PKData(i, t, e, o) : c ? a = S(t, e.keys).map((d) => c(d, e)) : a = q.createRandomData(t, e, o);\n    return a;\n  }\n  /**\n   * Creates NUT-08 blank outputs (fee returns) for a given fee reserve\n   * See: https://github.com/cashubtc/nuts/blob/main/08.md\n   * @param amount amount to cover with blank outputs\n   * @param keysetId mint keysetId\n   * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect\n   * @returns blinded messages, secrets, and rs\n   */\n  createBlankOutputs(t, e, n, r) {\n    let o = Math.ceil(Math.log2(t)) || 1;\n    o < 0 && (o = 0);\n    const i = o ? Array(o).fill(1) : [];\n    return this.createOutputData(t, e, n, void 0, i, void 0, r);\n  }\n}\n\n//# sourceMappingURL=cashu-ts.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhc2h1L2Nhc2h1LXRzL2xpYi9jYXNodS10cy5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1GO0FBQ0M7QUFDSjtBQUM1QjtBQUNmO0FBQ2tGO0FBQzVDO0FBQ25CO0FBQ2tDO0FBQ1U7QUFDcEc7QUFDQSxTQUFTLDBDQUFDO0FBQ1Y7QUFDQTtBQUNBLFNBQVMsMENBQUM7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBDQUFDO0FBQ2I7QUFDQTtBQUNBLFlBQVksMENBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUNBQXVDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1Q0FBdUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEMsZ0JBQWdCLHlFQUFFO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUNBQWlDO0FBQ3pDO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdUJFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYWJsb2Zlcm5hbmRlei90ZXN0MTIzL1RFTkVYLXBma21jOS9tYWluL25vZGVfbW9kdWxlcy9AY2FzaHUvY2FzaHUtdHMvbGliL2Nhc2h1LXRzLmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZlcmlmeURMRVFQcm9vZl9yZWJsaW5kIGFzIHZ0IH0gZnJvbSBcIkBjYXNodS9jcnlwdG8vbW9kdWxlcy9jbGllbnQvTlVUMTJcIjtcbmltcG9ydCB7IHBvaW50RnJvbUhleCBhcyBGLCBoYXNoVG9DdXJ2ZSBhcyBhdCB9IGZyb20gXCJAY2FzaHUvY3J5cHRvL21vZHVsZXMvY29tbW9uXCI7XG5pbXBvcnQgeyBoZXhUb0J5dGVzIGFzIE0sIGJ5dGVzVG9IZXggYXMgRCB9IGZyb20gXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzXCI7XG5pbXBvcnQgeyBzaGEyNTYgYXMgeXQgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIjtcbmltcG9ydCB7IEJ1ZmZlciBhcyBRIH0gZnJvbSBcImJ1ZmZlclwiO1xuaW1wb3J0IHsgY29uc3RydWN0UHJvb2ZGcm9tUHJvbWlzZSBhcyBNdCwgc2VyaWFsaXplUHJvb2YgYXMgViwgYmxpbmRNZXNzYWdlIGFzIEMgfSBmcm9tIFwiQGNhc2h1L2NyeXB0by9tb2R1bGVzL2NsaWVudFwiO1xuaW1wb3J0IHsgZ2V0U2lnbmVkUHJvb2ZzIGFzIHV0IH0gZnJvbSBcIkBjYXNodS9jcnlwdG8vbW9kdWxlcy9jbGllbnQvTlVUMTFcIjtcbmltcG9ydCB7IHNjaG5vcnIgYXMgVHQgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGhleFRvQnl0ZXMgYXMgRywgYnl0ZXNUb0hleCBhcyBPLCByYW5kb21CeXRlcyBhcyBodCB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBkZXJpdmVTZWNyZXQgYXMgVXQsIGRlcml2ZUJsaW5kaW5nRmFjdG9yIGFzIER0IH0gZnJvbSBcIkBjYXNodS9jcnlwdG8vbW9kdWxlcy9jbGllbnQvTlVUMDlcIjtcbmZ1bmN0aW9uIE90KHMpIHtcbiAgcmV0dXJuIFEuZnJvbShzKS50b1N0cmluZyhcImJhc2U2NFwiKS5yZXBsYWNlKC9cXCsvZywgXCItXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIikucmVwbGFjZSgvPSskLywgXCJcIik7XG59XG5mdW5jdGlvbiBndChzKSB7XG4gIHJldHVybiBRLmZyb20ocywgXCJiYXNlNjRcIik7XG59XG5mdW5jdGlvbiB4dChzKSB7XG4gIGNvbnN0IHQgPSBKU09OLnN0cmluZ2lmeShzKTtcbiAgcmV0dXJuIEJ0KFEuZnJvbSh0KS50b1N0cmluZyhcImJhc2U2NFwiKSk7XG59XG5mdW5jdGlvbiBGdChzKSB7XG4gIGNvbnN0IHQgPSBRLmZyb20oTnQocyksIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCk7XG4gIHJldHVybiBKU09OLnBhcnNlKHQpO1xufVxuZnVuY3Rpb24gTnQocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKS5zcGxpdChcIj1cIilbMF07XG59XG5mdW5jdGlvbiBCdChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1xcKy9nLCBcIi1cIikucmVwbGFjZSgvXFwvL2csIFwiX1wiKS5zcGxpdChcIj1cIilbMF07XG59XG5mdW5jdGlvbiBLdChzKSB7XG4gIHJldHVybiB0eXBlb2YgcyA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBzID09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBKKHMpIHtcbiAgY29uc3QgdCA9IFtdO1xuICByZXR1cm4gWShzLCB0KSwgbmV3IFVpbnQ4QXJyYXkodCk7XG59XG5mdW5jdGlvbiBZKHMsIHQpIHtcbiAgaWYgKHMgPT09IG51bGwpXG4gICAgdC5wdXNoKDI0Nik7XG4gIGVsc2UgaWYgKHMgPT09IHZvaWQgMClcbiAgICB0LnB1c2goMjQ3KTtcbiAgZWxzZSBpZiAodHlwZW9mIHMgPT0gXCJib29sZWFuXCIpXG4gICAgdC5wdXNoKHMgPyAyNDUgOiAyNDQpO1xuICBlbHNlIGlmICh0eXBlb2YgcyA9PSBcIm51bWJlclwiKVxuICAgIHd0KHMsIHQpO1xuICBlbHNlIGlmICh0eXBlb2YgcyA9PSBcInN0cmluZ1wiKVxuICAgIGt0KHMsIHQpO1xuICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHMpKVxuICAgIFF0KHMsIHQpO1xuICBlbHNlIGlmIChzIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICBSdChzLCB0KTtcbiAgZWxzZSBpZiAodHlwZW9mIHMgPT0gXCJvYmplY3RcIilcbiAgICBMdChzLCB0KTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHR5cGVcIik7XG59XG5mdW5jdGlvbiB3dChzLCB0KSB7XG4gIGlmIChzIDwgMjQpXG4gICAgdC5wdXNoKHMpO1xuICBlbHNlIGlmIChzIDwgMjU2KVxuICAgIHQucHVzaCgyNCwgcyk7XG4gIGVsc2UgaWYgKHMgPCA2NTUzNilcbiAgICB0LnB1c2goMjUsIHMgPj4gOCwgcyAmIDI1NSk7XG4gIGVsc2UgaWYgKHMgPCA0Mjk0OTY3Mjk2KVxuICAgIHQucHVzaCgyNiwgcyA+PiAyNCwgcyA+PiAxNiAmIDI1NSwgcyA+PiA4ICYgMjU1LCBzICYgMjU1KTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGludGVnZXIgc2l6ZVwiKTtcbn1cbmZ1bmN0aW9uIFJ0KHMsIHQpIHtcbiAgY29uc3QgZSA9IHMubGVuZ3RoO1xuICBpZiAoZSA8IDI0KVxuICAgIHQucHVzaCg2NCArIGUpO1xuICBlbHNlIGlmIChlIDwgMjU2KVxuICAgIHQucHVzaCg4OCwgZSk7XG4gIGVsc2UgaWYgKGUgPCA2NTUzNilcbiAgICB0LnB1c2goODksIGUgPj4gOCAmIDI1NSwgZSAmIDI1NSk7XG4gIGVsc2UgaWYgKGUgPCA0Mjk0OTY3Mjk2KVxuICAgIHQucHVzaChcbiAgICAgIDkwLFxuICAgICAgZSA+PiAyNCAmIDI1NSxcbiAgICAgIGUgPj4gMTYgJiAyNTUsXG4gICAgICBlID4+IDggJiAyNTUsXG4gICAgICBlICYgMjU1XG4gICAgKTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJ5dGUgc3RyaW5nIHRvbyBsb25nIHRvIGVuY29kZVwiKTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBzLmxlbmd0aDsgbisrKVxuICAgIHQucHVzaChzW25dKTtcbn1cbmZ1bmN0aW9uIGt0KHMsIHQpIHtcbiAgY29uc3QgZSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzKSwgbiA9IGUubGVuZ3RoO1xuICBpZiAobiA8IDI0KVxuICAgIHQucHVzaCg5NiArIG4pO1xuICBlbHNlIGlmIChuIDwgMjU2KVxuICAgIHQucHVzaCgxMjAsIG4pO1xuICBlbHNlIGlmIChuIDwgNjU1MzYpXG4gICAgdC5wdXNoKDEyMSwgbiA+PiA4ICYgMjU1LCBuICYgMjU1KTtcbiAgZWxzZSBpZiAobiA8IDQyOTQ5NjcyOTYpXG4gICAgdC5wdXNoKFxuICAgICAgMTIyLFxuICAgICAgbiA+PiAyNCAmIDI1NSxcbiAgICAgIG4gPj4gMTYgJiAyNTUsXG4gICAgICBuID4+IDggJiAyNTUsXG4gICAgICBuICYgMjU1XG4gICAgKTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmluZyB0b28gbG9uZyB0byBlbmNvZGVcIik7XG4gIGZvciAobGV0IHIgPSAwOyByIDwgZS5sZW5ndGg7IHIrKylcbiAgICB0LnB1c2goZVtyXSk7XG59XG5mdW5jdGlvbiBRdChzLCB0KSB7XG4gIGNvbnN0IGUgPSBzLmxlbmd0aDtcbiAgaWYgKGUgPCAyNClcbiAgICB0LnB1c2goMTI4IHwgZSk7XG4gIGVsc2UgaWYgKGUgPCAyNTYpXG4gICAgdC5wdXNoKDE1MiwgZSk7XG4gIGVsc2UgaWYgKGUgPCA2NTUzNilcbiAgICB0LnB1c2goMTUzLCBlID4+IDgsIGUgJiAyNTUpO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgYXJyYXkgbGVuZ3RoXCIpO1xuICBmb3IgKGNvbnN0IG4gb2YgcylcbiAgICBZKG4sIHQpO1xufVxuZnVuY3Rpb24gTHQocywgdCkge1xuICBjb25zdCBlID0gT2JqZWN0LmtleXMocyk7XG4gIHd0KGUubGVuZ3RoLCB0KSwgdFt0Lmxlbmd0aCAtIDFdIHw9IDE2MDtcbiAgZm9yIChjb25zdCBuIG9mIGUpXG4gICAga3QobiwgdCksIFkoc1tuXSwgdCk7XG59XG5mdW5jdGlvbiBYKHMpIHtcbiAgY29uc3QgdCA9IG5ldyBEYXRhVmlldyhzLmJ1ZmZlciwgcy5ieXRlT2Zmc2V0LCBzLmJ5dGVMZW5ndGgpO1xuICByZXR1cm4gVyh0LCAwKS52YWx1ZTtcbn1cbmZ1bmN0aW9uIFcocywgdCkge1xuICBpZiAodCA+PSBzLmJ5dGVMZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgZGF0YVwiKTtcbiAgY29uc3QgZSA9IHMuZ2V0VWludDgodCsrKSwgbiA9IGUgPj4gNSwgciA9IGUgJiAzMTtcbiAgc3dpdGNoIChuKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIFd0KHMsIHQsIHIpO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBqdChzLCB0LCByKTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gQ3QocywgdCwgcik7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIEh0KHMsIHQsIHIpO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiAkdChzLCB0LCByKTtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4genQocywgdCwgcik7XG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuIEd0KHMsIHQsIHIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG1ham9yIHR5cGU6ICR7bn1gKTtcbiAgfVxufVxuZnVuY3Rpb24gQihzLCB0LCBlKSB7XG4gIGlmIChlIDwgMjQpIHJldHVybiB7IHZhbHVlOiBlLCBvZmZzZXQ6IHQgfTtcbiAgaWYgKGUgPT09IDI0KSByZXR1cm4geyB2YWx1ZTogcy5nZXRVaW50OCh0KyspLCBvZmZzZXQ6IHQgfTtcbiAgaWYgKGUgPT09IDI1KSB7XG4gICAgY29uc3QgbiA9IHMuZ2V0VWludDE2KHQsICExKTtcbiAgICByZXR1cm4gdCArPSAyLCB7IHZhbHVlOiBuLCBvZmZzZXQ6IHQgfTtcbiAgfVxuICBpZiAoZSA9PT0gMjYpIHtcbiAgICBjb25zdCBuID0gcy5nZXRVaW50MzIodCwgITEpO1xuICAgIHJldHVybiB0ICs9IDQsIHsgdmFsdWU6IG4sIG9mZnNldDogdCB9O1xuICB9XG4gIGlmIChlID09PSAyNykge1xuICAgIGNvbnN0IG4gPSBzLmdldFVpbnQzMih0LCAhMSksIHIgPSBzLmdldFVpbnQzMih0ICsgNCwgITEpO1xuICAgIHJldHVybiB0ICs9IDgsIHsgdmFsdWU6IG4gKiAyICoqIDMyICsgciwgb2Zmc2V0OiB0IH07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsZW5ndGg6ICR7ZX1gKTtcbn1cbmZ1bmN0aW9uIFd0KHMsIHQsIGUpIHtcbiAgY29uc3QgeyB2YWx1ZTogbiwgb2Zmc2V0OiByIH0gPSBCKHMsIHQsIGUpO1xuICByZXR1cm4geyB2YWx1ZTogbiwgb2Zmc2V0OiByIH07XG59XG5mdW5jdGlvbiBqdChzLCB0LCBlKSB7XG4gIGNvbnN0IHsgdmFsdWU6IG4sIG9mZnNldDogciB9ID0gQihzLCB0LCBlKTtcbiAgcmV0dXJuIHsgdmFsdWU6IC0xIC0gbiwgb2Zmc2V0OiByIH07XG59XG5mdW5jdGlvbiBDdChzLCB0LCBlKSB7XG4gIGNvbnN0IHsgdmFsdWU6IG4sIG9mZnNldDogciB9ID0gQihzLCB0LCBlKTtcbiAgaWYgKHIgKyBuID4gcy5ieXRlTGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJ5dGUgc3RyaW5nIGxlbmd0aCBleGNlZWRzIGRhdGEgbGVuZ3RoXCIpO1xuICByZXR1cm4geyB2YWx1ZTogbmV3IFVpbnQ4QXJyYXkocy5idWZmZXIsIHMuYnl0ZU9mZnNldCArIHIsIG4pLCBvZmZzZXQ6IHIgKyBuIH07XG59XG5mdW5jdGlvbiBIdChzLCB0LCBlKSB7XG4gIGNvbnN0IHsgdmFsdWU6IG4sIG9mZnNldDogciB9ID0gQihzLCB0LCBlKTtcbiAgaWYgKHIgKyBuID4gcy5ieXRlTGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmluZyBsZW5ndGggZXhjZWVkcyBkYXRhIGxlbmd0aFwiKTtcbiAgY29uc3QgbyA9IG5ldyBVaW50OEFycmF5KHMuYnVmZmVyLCBzLmJ5dGVPZmZzZXQgKyByLCBuKTtcbiAgcmV0dXJuIHsgdmFsdWU6IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShvKSwgb2Zmc2V0OiByICsgbiB9O1xufVxuZnVuY3Rpb24gJHQocywgdCwgZSkge1xuICBjb25zdCB7IHZhbHVlOiBuLCBvZmZzZXQ6IHIgfSA9IEIocywgdCwgZSksIG8gPSBbXTtcbiAgbGV0IGkgPSByO1xuICBmb3IgKGxldCBjID0gMDsgYyA8IG47IGMrKykge1xuICAgIGNvbnN0IGEgPSBXKHMsIGkpO1xuICAgIG8ucHVzaChhLnZhbHVlKSwgaSA9IGEub2Zmc2V0O1xuICB9XG4gIHJldHVybiB7IHZhbHVlOiBvLCBvZmZzZXQ6IGkgfTtcbn1cbmZ1bmN0aW9uIHp0KHMsIHQsIGUpIHtcbiAgY29uc3QgeyB2YWx1ZTogbiwgb2Zmc2V0OiByIH0gPSBCKHMsIHQsIGUpLCBvID0ge307XG4gIGxldCBpID0gcjtcbiAgZm9yIChsZXQgYyA9IDA7IGMgPCBuOyBjKyspIHtcbiAgICBjb25zdCBhID0gVyhzLCBpKTtcbiAgICBpZiAoIUt0KGEudmFsdWUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXkgdHlwZVwiKTtcbiAgICBjb25zdCBoID0gVyhzLCBhLm9mZnNldCk7XG4gICAgb1thLnZhbHVlXSA9IGgudmFsdWUsIGkgPSBoLm9mZnNldDtcbiAgfVxuICByZXR1cm4geyB2YWx1ZTogbywgb2Zmc2V0OiBpIH07XG59XG5mdW5jdGlvbiBWdChzKSB7XG4gIGNvbnN0IHQgPSAocyAmIDMxNzQ0KSA+PiAxMCwgZSA9IHMgJiAxMDIzLCBuID0gcyAmIDMyNzY4ID8gLTEgOiAxO1xuICByZXR1cm4gdCA9PT0gMCA/IG4gKiAyICoqIC0xNCAqIChlIC8gMTAyNCkgOiB0ID09PSAzMSA/IGUgPyBOYU4gOiBuICogKDEgLyAwKSA6IG4gKiAyICoqICh0IC0gMTUpICogKDEgKyBlIC8gMTAyNCk7XG59XG5mdW5jdGlvbiBHdChzLCB0LCBlKSB7XG4gIGlmIChlIDwgMjQpXG4gICAgc3dpdGNoIChlKSB7XG4gICAgICBjYXNlIDIwOlxuICAgICAgICByZXR1cm4geyB2YWx1ZTogITEsIG9mZnNldDogdCB9O1xuICAgICAgY2FzZSAyMTpcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6ICEwLCBvZmZzZXQ6IHQgfTtcbiAgICAgIGNhc2UgMjI6XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBudWxsLCBvZmZzZXQ6IHQgfTtcbiAgICAgIGNhc2UgMjM6XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2b2lkIDAsIG9mZnNldDogdCB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHNpbXBsZSB2YWx1ZTogJHtlfWApO1xuICAgIH1cbiAgaWYgKGUgPT09IDI0KSByZXR1cm4geyB2YWx1ZTogcy5nZXRVaW50OCh0KyspLCBvZmZzZXQ6IHQgfTtcbiAgaWYgKGUgPT09IDI1KSB7XG4gICAgY29uc3QgbiA9IFZ0KHMuZ2V0VWludDE2KHQsICExKSk7XG4gICAgcmV0dXJuIHQgKz0gMiwgeyB2YWx1ZTogbiwgb2Zmc2V0OiB0IH07XG4gIH1cbiAgaWYgKGUgPT09IDI2KSB7XG4gICAgY29uc3QgbiA9IHMuZ2V0RmxvYXQzMih0LCAhMSk7XG4gICAgcmV0dXJuIHQgKz0gNCwgeyB2YWx1ZTogbiwgb2Zmc2V0OiB0IH07XG4gIH1cbiAgaWYgKGUgPT09IDI3KSB7XG4gICAgY29uc3QgbiA9IHMuZ2V0RmxvYXQ2NCh0LCAhMSk7XG4gICAgcmV0dXJuIHQgKz0gOCwgeyB2YWx1ZTogbiwgb2Zmc2V0OiB0IH07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHNpbXBsZSBvciBmbG9hdCB2YWx1ZTogJHtlfWApO1xufVxuY2xhc3MgWiB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIG4sIHIsIG8sIGksIGMgPSAhMSkge1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdCwgdGhpcy5pZCA9IGUsIHRoaXMuYW1vdW50ID0gbiwgdGhpcy51bml0ID0gciwgdGhpcy5taW50cyA9IG8sIHRoaXMuZGVzY3JpcHRpb24gPSBpLCB0aGlzLnNpbmdsZVVzZSA9IGM7XG4gIH1cbiAgdG9SYXdSZXF1ZXN0KCkge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICB0OiB0aGlzLnRyYW5zcG9ydC5tYXAoKGUpID0+ICh7IHQ6IGUudHlwZSwgYTogZS50YXJnZXQsIGc6IGUudGFncyB9KSlcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmlkICYmICh0LmkgPSB0aGlzLmlkKSwgdGhpcy5hbW91bnQgJiYgKHQuYSA9IHRoaXMuYW1vdW50KSwgdGhpcy51bml0ICYmICh0LnUgPSB0aGlzLnVuaXQpLCB0aGlzLm1pbnRzICYmICh0Lm0gPSB0aGlzLm1pbnRzKSwgdGhpcy5kZXNjcmlwdGlvbiAmJiAodC5kID0gdGhpcy5kZXNjcmlwdGlvbiksIHRoaXMuc2luZ2xlVXNlICYmICh0LnMgPSB0aGlzLnNpbmdsZVVzZSksIHQ7XG4gIH1cbiAgdG9FbmNvZGVkUmVxdWVzdCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy50b1Jhd1JlcXVlc3QoKSwgZSA9IEoodCk7XG4gICAgcmV0dXJuIFwiY3JlcUFcIiArIFEuZnJvbShlKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgfVxuICBnZXRUcmFuc3BvcnQodCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5maW5kKChlKSA9PiBlLnR5cGUgPT09IHQpO1xuICB9XG4gIHN0YXRpYyBmcm9tUmF3UmVxdWVzdCh0KSB7XG4gICAgY29uc3QgZSA9IHQudC5tYXAoKG4pID0+ICh7XG4gICAgICB0eXBlOiBuLnQsXG4gICAgICB0YXJnZXQ6IG4uYSxcbiAgICAgIHRhZ3M6IG4uZ1xuICAgIH0pKTtcbiAgICByZXR1cm4gbmV3IFooXG4gICAgICBlLFxuICAgICAgdC5pLFxuICAgICAgdC5hLFxuICAgICAgdC51LFxuICAgICAgdC5tLFxuICAgICAgdC5kLFxuICAgICAgdC5zXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgZnJvbUVuY29kZWRSZXF1ZXN0KHQpIHtcbiAgICBpZiAoIXQuc3RhcnRzV2l0aChcImNyZXFcIikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBwcjogaW52YWxpZCBwcmVmaXhcIik7XG4gICAgaWYgKHRbNF0gIT09IFwiQVwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgcHIgdmVyc2lvblwiKTtcbiAgICBjb25zdCBuID0gdC5zbGljZSg1KSwgciA9IGd0KG4pLCBvID0gWChyKTtcbiAgICByZXR1cm4gdGhpcy5mcm9tUmF3UmVxdWVzdChvKTtcbiAgfVxufVxuY29uc3QgSnQgPSBcIkFcIiwgWXQgPSBcImNhc2h1XCI7XG5mdW5jdGlvbiBTKHMsIHQsIGUsIG4pIHtcbiAgaWYgKGUpIHtcbiAgICBjb25zdCBvID0gZnQoZSk7XG4gICAgaWYgKG8gPiBzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTcGxpdCBpcyBncmVhdGVyIHRoYW4gdG90YWwgYW1vdW50OiAke299ID4gJHtzfWApO1xuICAgIGlmIChlLnNvbWUoKGkpID0+ICFfdChpLCB0KSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlZCBhbW91bnQgcHJlZmVyZW5jZXMgZG8gbm90IG1hdGNoIHRoZSBhbW91bnRzIG9mIHRoZSBtaW50IGtleXNldC5cIik7XG4gICAgcyA9IHMgLSBmdChlKTtcbiAgfSBlbHNlXG4gICAgZSA9IFtdO1xuICByZXR1cm4gYnQodCwgXCJkZXNjXCIpLmZvckVhY2goKG8pID0+IHtcbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcihzIC8gbyk7XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBpOyArK2MpIGU/LnB1c2gobyk7XG4gICAgcyAlPSBvO1xuICB9KSwgZS5zb3J0KChvLCBpKSA9PiBvIC0gaSk7XG59XG5mdW5jdGlvbiBkdChzLCB0LCBlLCBuKSB7XG4gIGNvbnN0IHIgPSBbXSwgbyA9IHMubWFwKChoKSA9PiBoLmFtb3VudCk7XG4gIGJ0KGUsIFwiYXNjXCIpLmZvckVhY2goKGgpID0+IHtcbiAgICBjb25zdCBkID0gby5maWx0ZXIoKG0pID0+IG0gPT09IGgpLmxlbmd0aCwgZiA9IE1hdGgubWF4KG4gLSBkLCAwKTtcbiAgICBmb3IgKGxldCBtID0gMDsgbSA8IGYgJiYgIShyLnJlZHVjZSgodSwgbCkgPT4gdSArIGwsIDApICsgaCA+IHQpOyArK20pXG4gICAgICByLnB1c2goaCk7XG4gIH0pO1xuICBjb25zdCBjID0gdCAtIHIucmVkdWNlKChoLCBkKSA9PiBoICsgZCwgMCk7XG4gIHJldHVybiBjICYmIFMoYywgZSkuZm9yRWFjaCgoZCkgPT4ge1xuICAgIHIucHVzaChkKTtcbiAgfSksIHIuc29ydCgoaCwgZCkgPT4gaCAtIGQpO1xufVxuZnVuY3Rpb24gYnQocywgdCA9IFwiZGVzY1wiKSB7XG4gIHJldHVybiB0ID09IFwiZGVzY1wiID8gT2JqZWN0LmtleXMocykubWFwKChlKSA9PiBwYXJzZUludChlKSkuc29ydCgoZSwgbikgPT4gbiAtIGUpIDogT2JqZWN0LmtleXMocykubWFwKChlKSA9PiBwYXJzZUludChlKSkuc29ydCgoZSwgbikgPT4gZSAtIG4pO1xufVxuZnVuY3Rpb24gX3QocywgdCkge1xuICByZXR1cm4gcyBpbiB0O1xufVxuZnVuY3Rpb24gWHQocykge1xuICByZXR1cm4gRXQoRChzKSk7XG59XG5mdW5jdGlvbiBFdChzKSB7XG4gIHJldHVybiBCaWdJbnQoYDB4JHtzfWApO1xufVxuZnVuY3Rpb24gWnQocykge1xuICByZXR1cm4gcy50b1N0cmluZygxNikucGFkU3RhcnQoNjQsIFwiMFwiKTtcbn1cbmZ1bmN0aW9uIGx0KHMpIHtcbiAgcmV0dXJuIC9eW2EtZjAtOV0qJC9pLnRlc3Qocyk7XG59XG5mdW5jdGlvbiBQdChzKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHMpID8gcy5zb21lKCh0KSA9PiAhbHQodC5pZCkpIDogbHQocy5pZCk7XG59XG5mdW5jdGlvbiB0ZShzKSB7XG4gIGNvbnN0IHQgPSB7IHRva2VuOiBbeyBtaW50OiBzLm1pbnQsIHByb29mczogcy5wcm9vZnMgfV0gfTtcbiAgcmV0dXJuIHMudW5pdCAmJiAodC51bml0ID0gcy51bml0KSwgcy5tZW1vICYmICh0Lm1lbW8gPSBzLm1lbW8pLCBZdCArIEp0ICsgeHQodCk7XG59XG5mdW5jdGlvbiBUZShzLCB0KSB7XG4gIGlmIChQdChzLnByb29mcykgfHwgdD8udmVyc2lvbiA9PT0gMykge1xuICAgIGlmICh0Py52ZXJzaW9uID09PSA0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuIG5vdCBlbmNvZGUgdG8gdjQgdG9rZW4gaWYgcHJvb2ZzIGNvbnRhaW4gbm9uLWhleCBrZXlzZXQgaWRcIik7XG4gICAgcmV0dXJuIHRlKHMpO1xuICB9XG4gIHJldHVybiBlZShzKTtcbn1cbmZ1bmN0aW9uIGVlKHMpIHtcbiAgaWYgKHMucHJvb2ZzLmZvckVhY2goKGMpID0+IHtcbiAgICBpZiAoYy5kbGVxICYmIGMuZGxlcS5yID09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGJsaW5kaW5nIGZhY3RvciBpbiBpbmNsdWRlZCBETEVRIHByb29mXCIpO1xuICB9KSwgUHQocy5wcm9vZnMpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImNhbiBub3QgZW5jb2RlIHRvIHY0IHRva2VuIGlmIHByb29mcyBjb250YWluIG5vbi1oZXgga2V5c2V0IGlkXCIpO1xuICBjb25zdCBlID0gU3QocyksIG4gPSBKKGUpLCByID0gXCJjYXNodVwiLCBvID0gXCJCXCIsIGkgPSBPdChuKTtcbiAgcmV0dXJuIHIgKyBvICsgaTtcbn1cbmZ1bmN0aW9uIFN0KHMpIHtcbiAgY29uc3QgdCA9IHt9LCBlID0gcy5taW50O1xuICBmb3IgKGxldCByID0gMDsgciA8IHMucHJvb2ZzLmxlbmd0aDsgcisrKSB7XG4gICAgY29uc3QgbyA9IHMucHJvb2ZzW3JdO1xuICAgIHRbby5pZF0gPyB0W28uaWRdLnB1c2gobykgOiB0W28uaWRdID0gW29dO1xuICB9XG4gIGNvbnN0IG4gPSB7XG4gICAgbTogZSxcbiAgICB1OiBzLnVuaXQgfHwgXCJzYXRcIixcbiAgICB0OiBPYmplY3Qua2V5cyh0KS5tYXAoXG4gICAgICAocikgPT4gKHtcbiAgICAgICAgaTogTShyKSxcbiAgICAgICAgcDogdFtyXS5tYXAoXG4gICAgICAgICAgKG8pID0+ICh7XG4gICAgICAgICAgICBhOiBvLmFtb3VudCxcbiAgICAgICAgICAgIHM6IG8uc2VjcmV0LFxuICAgICAgICAgICAgYzogTShvLkMpLFxuICAgICAgICAgICAgLi4uby5kbGVxICYmIHtcbiAgICAgICAgICAgICAgZDoge1xuICAgICAgICAgICAgICAgIGU6IE0oby5kbGVxLmUpLFxuICAgICAgICAgICAgICAgIHM6IE0oby5kbGVxLnMpLFxuICAgICAgICAgICAgICAgIHI6IE0oby5kbGVxLnIgPz8gXCIwMFwiKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgfSlcbiAgICApXG4gIH07XG4gIHJldHVybiBzLm1lbW8gJiYgKG4uZCA9IHMubWVtbyksIG47XG59XG5mdW5jdGlvbiBJdChzKSB7XG4gIGNvbnN0IHQgPSBbXTtcbiAgcy50LmZvckVhY2goXG4gICAgKG4pID0+IG4ucC5mb3JFYWNoKChyKSA9PiB7XG4gICAgICB0LnB1c2goe1xuICAgICAgICBzZWNyZXQ6IHIucyxcbiAgICAgICAgQzogRChyLmMpLFxuICAgICAgICBhbW91bnQ6IHIuYSxcbiAgICAgICAgaWQ6IEQobi5pKSxcbiAgICAgICAgLi4uci5kICYmIHtcbiAgICAgICAgICBkbGVxOiB7XG4gICAgICAgICAgICByOiBEKHIuZC5yKSxcbiAgICAgICAgICAgIHM6IEQoci5kLnMpLFxuICAgICAgICAgICAgZTogRChyLmQuZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pXG4gICk7XG4gIGNvbnN0IGUgPSB7IG1pbnQ6IHMubSwgcHJvb2ZzOiB0LCB1bml0OiBzLnUgfHwgXCJzYXRcIiB9O1xuICByZXR1cm4gcy5kICYmIChlLm1lbW8gPSBzLmQpLCBlO1xufVxuZnVuY3Rpb24gc2Uocykge1xuICByZXR1cm4gW1wid2ViK2Nhc2h1Oi8vXCIsIFwiY2FzaHU6Ly9cIiwgXCJjYXNodTpcIiwgXCJjYXNodVwiXS5mb3JFYWNoKChlKSA9PiB7XG4gICAgcy5zdGFydHNXaXRoKGUpICYmIChzID0gcy5zbGljZShlLmxlbmd0aCkpO1xuICB9KSwgbmUocyk7XG59XG5mdW5jdGlvbiBuZShzKSB7XG4gIGNvbnN0IHQgPSBzLnNsaWNlKDAsIDEpLCBlID0gcy5zbGljZSgxKTtcbiAgaWYgKHQgPT09IFwiQVwiKSB7XG4gICAgY29uc3QgbiA9IEZ0KGUpO1xuICAgIGlmIChuLnRva2VuLmxlbmd0aCA+IDEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdWx0aSBlbnRyeSB0b2tlbiBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICBjb25zdCByID0gbi50b2tlblswXSwgbyA9IHtcbiAgICAgIG1pbnQ6IHIubWludCxcbiAgICAgIHByb29mczogci5wcm9vZnMsXG4gICAgICB1bml0OiBuLnVuaXQgfHwgXCJzYXRcIlxuICAgIH07XG4gICAgcmV0dXJuIG4ubWVtbyAmJiAoby5tZW1vID0gbi5tZW1vKSwgbztcbiAgfSBlbHNlIGlmICh0ID09PSBcIkJcIikge1xuICAgIGNvbnN0IG4gPSBndChlKSwgciA9IFgobik7XG4gICAgcmV0dXJuIEl0KHIpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlRva2VuIHZlcnNpb24gaXMgbm90IHN1cHBvcnRlZFwiKTtcbn1cbmZ1bmN0aW9uIFVlKHMpIHtcbiAgY29uc3QgdCA9IE9iamVjdC5lbnRyaWVzKHMpLnNvcnQoKHIsIG8pID0+ICtyWzBdIC0gK29bMF0pLm1hcCgoWywgcl0pID0+IE0ocikpLnJlZHVjZSgociwgbykgPT4gcmUociwgbyksIG5ldyBVaW50OEFycmF5KCkpLCBlID0geXQodCk7XG4gIHJldHVybiBcIjAwXCIgKyBCdWZmZXIuZnJvbShlKS50b1N0cmluZyhcImhleFwiKS5zbGljZSgwLCAxNCk7XG59XG5mdW5jdGlvbiByZShzLCB0KSB7XG4gIGNvbnN0IGUgPSBuZXcgVWludDhBcnJheShzLmxlbmd0aCArIHQubGVuZ3RoKTtcbiAgcmV0dXJuIGUuc2V0KHMpLCBlLnNldCh0LCBzLmxlbmd0aCksIGU7XG59XG5mdW5jdGlvbiB2KHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBzID09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBFKC4uLnMpIHtcbiAgcmV0dXJuIHMubWFwKCh0KSA9PiB0LnJlcGxhY2UoLyheXFwvK3xcXC8rJCkvZywgXCJcIikpLmpvaW4oXCIvXCIpO1xufVxuZnVuY3Rpb24gb2Uocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG59XG5mdW5jdGlvbiBVKHMpIHtcbiAgcmV0dXJuIHMucmVkdWNlKCh0LCBlKSA9PiB0ICsgZS5hbW91bnQsIDApO1xufVxuZnVuY3Rpb24gRGUocykge1xuICByZXR1cm4gWi5mcm9tRW5jb2RlZFJlcXVlc3Qocyk7XG59XG5jbGFzcyBpZSB7XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cbiAgc2V0IHZhbHVlKHQpIHtcbiAgICB0aGlzLl92YWx1ZSA9IHQ7XG4gIH1cbiAgZ2V0IG5leHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25leHQ7XG4gIH1cbiAgc2V0IG5leHQodCkge1xuICAgIHRoaXMuX25leHQgPSB0O1xuICB9XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB0aGlzLl92YWx1ZSA9IHQsIHRoaXMuX25leHQgPSBudWxsO1xuICB9XG59XG5jbGFzcyBjZSB7XG4gIGdldCBmaXJzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3Q7XG4gIH1cbiAgc2V0IGZpcnN0KHQpIHtcbiAgICB0aGlzLl9maXJzdCA9IHQ7XG4gIH1cbiAgZ2V0IGxhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xhc3Q7XG4gIH1cbiAgc2V0IGxhc3QodCkge1xuICAgIHRoaXMuX2xhc3QgPSB0O1xuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9zaXplO1xuICB9XG4gIHNldCBzaXplKHQpIHtcbiAgICB0aGlzLl9zaXplID0gdDtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9maXJzdCA9IG51bGwsIHRoaXMuX2xhc3QgPSBudWxsLCB0aGlzLl9zaXplID0gMDtcbiAgfVxuICBlbnF1ZXVlKHQpIHtcbiAgICBjb25zdCBlID0gbmV3IGllKHQpO1xuICAgIHJldHVybiB0aGlzLl9zaXplID09PSAwIHx8ICF0aGlzLl9sYXN0ID8gKHRoaXMuX2ZpcnN0ID0gZSwgdGhpcy5fbGFzdCA9IGUpIDogKHRoaXMuX2xhc3QubmV4dCA9IGUsIHRoaXMuX2xhc3QgPSBlKSwgdGhpcy5fc2l6ZSsrLCAhMDtcbiAgfVxuICBkZXF1ZXVlKCkge1xuICAgIGlmICh0aGlzLl9zaXplID09PSAwIHx8ICF0aGlzLl9maXJzdCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgdCA9IHRoaXMuX2ZpcnN0O1xuICAgIHJldHVybiB0aGlzLl9maXJzdCA9IHQubmV4dCwgdC5uZXh0ID0gbnVsbCwgdGhpcy5fc2l6ZS0tLCB0LnZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBMKHMpIHtcbiAgcmV0dXJuIHMubWFwKCh0KSA9PiB7XG4gICAgY29uc3QgZSA9IHsgLi4udCB9O1xuICAgIHJldHVybiBkZWxldGUgZS5kbGVxLCBlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFlKHMsIHQpIHtcbiAgaWYgKHMuZGxlcSA9PSBudWxsKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3QgZSA9IHtcbiAgICBlOiBNKHMuZGxlcS5lKSxcbiAgICBzOiBNKHMuZGxlcS5zKSxcbiAgICByOiBFdChzLmRsZXEuciA/PyBcIjAwXCIpXG4gIH07XG4gIGlmICghX3Qocy5hbW91bnQsIHQua2V5cykpXG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bmRlZmluZWQga2V5IGZvciBhbW91bnQgJHtzLmFtb3VudH1gKTtcbiAgY29uc3QgbiA9IHQua2V5c1tzLmFtb3VudF07XG4gIHJldHVybiAhIXZ0KFxuICAgIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzLnNlY3JldCksXG4gICAgZSxcbiAgICBGKHMuQyksXG4gICAgRihuKVxuICApO1xufVxuZnVuY3Rpb24gdWUoLi4ucykge1xuICBjb25zdCB0ID0gcy5yZWR1Y2UoKHIsIG8pID0+IHIgKyBvLmxlbmd0aCwgMCksIGUgPSBuZXcgVWludDhBcnJheSh0KTtcbiAgbGV0IG4gPSAwO1xuICBmb3IgKGxldCByID0gMDsgciA8IHMubGVuZ3RoOyByKyspXG4gICAgZS5zZXQoc1tyXSwgbiksIG4gPSBuICsgc1tyXS5sZW5ndGg7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gT2Uocykge1xuICBjb25zdCB0ID0gbmV3IFRleHRFbmNvZGVyKCksIGUgPSBTdChzKSwgbiA9IEooZSksIHIgPSB0LmVuY29kZShcImNyYXdcIiksIG8gPSB0LmVuY29kZShcIkJcIik7XG4gIHJldHVybiB1ZShyLCBvLCBuKTtcbn1cbmZ1bmN0aW9uIHhlKHMpIHtcbiAgY29uc3QgdCA9IG5ldyBUZXh0RGVjb2RlcigpLCBlID0gdC5kZWNvZGUocy5zbGljZSgwLCA0KSksIG4gPSB0LmRlY29kZShuZXcgVWludDhBcnJheShbc1s0XV0pKTtcbiAgaWYgKGUgIT09IFwiY3Jhd1wiIHx8IG4gIT09IFwiQlwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBhIHZhbGlkIGJpbmFyeSB0b2tlblwiKTtcbiAgY29uc3QgciA9IHMuc2xpY2UoNSksIG8gPSBYKHIpO1xuICByZXR1cm4gSXQobyk7XG59XG5mdW5jdGlvbiBmdChzKSB7XG4gIHJldHVybiBzLnJlZHVjZSgodCwgZSkgPT4gdCArIGUsIDApO1xufVxubGV0IHR0O1xudHlwZW9mIFdlYlNvY2tldCA8IFwidVwiICYmICh0dCA9IFdlYlNvY2tldCk7XG5mdW5jdGlvbiBGZShzKSB7XG4gIHR0ID0gcztcbn1cbmZ1bmN0aW9uIGhlKCkge1xuICByZXR1cm4gdHQ7XG59XG5jbGFzcyB4IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgcmV0dXJuIHguaW5zdGFjZSB8fCAoeC5pbnN0YWNlID0gbmV3IHgoKSksIHguaW5zdGFjZTtcbiAgfVxuICBnZXRDb25uZWN0aW9uKHQpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uTWFwLmhhcyh0KSlcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25NYXAuZ2V0KHQpO1xuICAgIGNvbnN0IGUgPSBuZXcgZGUodCk7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbk1hcC5zZXQodCwgZSksIGU7XG4gIH1cbn1cbmNsYXNzIGRlIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHRoaXMuc3ViTGlzdGVuZXJzID0ge30sIHRoaXMucnBjTGlzdGVuZXJzID0ge30sIHRoaXMucnBjSWQgPSAwLCB0aGlzLl9XUyA9IGhlKCksIHRoaXMudXJsID0gbmV3IFVSTCh0KSwgdGhpcy5tZXNzYWdlUXVldWUgPSBuZXcgY2UoKTtcbiAgfVxuICBjb25uZWN0KCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlIHx8ICh0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gbmV3IFByb21pc2UoKHQsIGUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMud3MgPSBuZXcgdGhpcy5fV1ModGhpcy51cmwpO1xuICAgICAgfSBjYXRjaCAobikge1xuICAgICAgICBlKG4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLndzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgdCgpO1xuICAgICAgfSwgdGhpcy53cy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICBlKG5ldyBFcnJvcihcIkZhaWxlZCB0byBvcGVuIFdlYlNvY2tldFwiKSk7XG4gICAgICB9LCB0aGlzLndzLm9ubWVzc2FnZSA9IChuKSA9PiB7XG4gICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlLmVucXVldWUobi5kYXRhKSwgdGhpcy5oYW5kbGluZ0ludGVydmFsIHx8ICh0aGlzLmhhbmRsaW5nSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgICAgICB0aGlzLmhhbmRsZU5leHRNZXNhZ2UuYmluZCh0aGlzKSxcbiAgICAgICAgICAwXG4gICAgICAgICkpO1xuICAgICAgfSwgdGhpcy53cy5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdm9pZCAwO1xuICAgICAgfTtcbiAgICB9KSksIHRoaXMuY29ubmVjdGlvblByb21pc2U7XG4gIH1cbiAgc2VuZFJlcXVlc3QodCwgZSkge1xuICAgIGlmICh0aGlzLndzPy5yZWFkeVN0YXRlICE9PSAxKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU29ja2V0IG5vdCBvcGVuLi4uXCIpO1xuICAgIGNvbnN0IG4gPSB0aGlzLnJwY0lkO1xuICAgIHRoaXMucnBjSWQrKztcbiAgICBjb25zdCByID0gSlNPTi5zdHJpbmdpZnkoeyBqc29ucnBjOiBcIjIuMFwiLCBtZXRob2Q6IHQsIHBhcmFtczogZSwgaWQ6IG4gfSk7XG4gICAgdGhpcy53cz8uc2VuZChyKTtcbiAgfVxuICBjbG9zZVN1YnNjcmlwdGlvbih0KSB7XG4gICAgdGhpcy53cz8uc2VuZChKU09OLnN0cmluZ2lmeShbXCJDTE9TRVwiLCB0XSkpO1xuICB9XG4gIGFkZFN1Ykxpc3RlbmVyKHQsIGUpIHtcbiAgICAodGhpcy5zdWJMaXN0ZW5lcnNbdF0gPSB0aGlzLnN1Ykxpc3RlbmVyc1t0XSB8fCBbXSkucHVzaChlKTtcbiAgfVxuICAvL1RPRE86IE1vdmUgdG8gUlBDTWFuYWdlckNsYXNzXG4gIGFkZFJwY0xpc3RlbmVyKHQsIGUsIG4pIHtcbiAgICB0aGlzLnJwY0xpc3RlbmVyc1tuXSA9IHsgY2FsbGJhY2s6IHQsIGVycm9yQ2FsbGJhY2s6IGUgfTtcbiAgfVxuICAvL1RPRE86IE1vdmUgdG8gUlBDTWFuYWdlckNsYXNzXG4gIHJlbW92ZVJwY0xpc3RlbmVyKHQpIHtcbiAgICBkZWxldGUgdGhpcy5ycGNMaXN0ZW5lcnNbdF07XG4gIH1cbiAgcmVtb3ZlTGlzdGVuZXIodCwgZSkge1xuICAgIGlmICh0aGlzLnN1Ykxpc3RlbmVyc1t0XS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnN1Ykxpc3RlbmVyc1t0XTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdWJMaXN0ZW5lcnNbdF0gPSB0aGlzLnN1Ykxpc3RlbmVyc1t0XS5maWx0ZXIoKG4pID0+IG4gIT09IGUpO1xuICB9XG4gIGFzeW5jIGVuc3VyZUNvbm5lY3Rpb24oKSB7XG4gICAgdGhpcy53cz8ucmVhZHlTdGF0ZSAhPT0gMSAmJiBhd2FpdCB0aGlzLmNvbm5lY3QoKTtcbiAgfVxuICBoYW5kbGVOZXh0TWVzYWdlKCkge1xuICAgIGlmICh0aGlzLm1lc3NhZ2VRdWV1ZS5zaXplID09PSAwKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuaGFuZGxpbmdJbnRlcnZhbCksIHRoaXMuaGFuZGxpbmdJbnRlcnZhbCA9IHZvaWQgMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdCA9IHRoaXMubWVzc2FnZVF1ZXVlLmRlcXVldWUoKTtcbiAgICBsZXQgZTtcbiAgICB0cnkge1xuICAgICAgaWYgKGUgPSBKU09OLnBhcnNlKHQpLCBcInJlc3VsdFwiIGluIGUgJiYgZS5pZCAhPSBudWxsKVxuICAgICAgICB0aGlzLnJwY0xpc3RlbmVyc1tlLmlkXSAmJiAodGhpcy5ycGNMaXN0ZW5lcnNbZS5pZF0uY2FsbGJhY2soKSwgdGhpcy5yZW1vdmVScGNMaXN0ZW5lcihlLmlkKSk7XG4gICAgICBlbHNlIGlmIChcImVycm9yXCIgaW4gZSAmJiBlLmlkICE9IG51bGwpXG4gICAgICAgIHRoaXMucnBjTGlzdGVuZXJzW2UuaWRdICYmICh0aGlzLnJwY0xpc3RlbmVyc1tlLmlkXS5lcnJvckNhbGxiYWNrKGUuZXJyb3IpLCB0aGlzLnJlbW92ZVJwY0xpc3RlbmVyKGUuaWQpKTtcbiAgICAgIGVsc2UgaWYgKFwibWV0aG9kXCIgaW4gZSAmJiAhKFwiaWRcIiBpbiBlKSkge1xuICAgICAgICBjb25zdCBuID0gZS5wYXJhbXMuc3ViSWQ7XG4gICAgICAgIGlmICghbilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnN1Ykxpc3RlbmVyc1tuXT8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHIgPSBlO1xuICAgICAgICAgIHRoaXMuc3ViTGlzdGVuZXJzW25dLmZvckVhY2goKG8pID0+IG8oci5wYXJhbXMucGF5bG9hZCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAobikge1xuICAgICAgY29uc29sZS5lcnJvcihuKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY3JlYXRlU3Vic2NyaXB0aW9uKHQsIGUsIG4pIHtcbiAgICBpZiAodGhpcy53cz8ucmVhZHlTdGF0ZSAhPT0gMSlcbiAgICAgIHJldHVybiBuKG5ldyBFcnJvcihcIlNvY2tldCBpcyBub3Qgb3BlblwiKSk7XG4gICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICsgMSkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KTtcbiAgICByZXR1cm4gdGhpcy5hZGRScGNMaXN0ZW5lcihcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5hZGRTdWJMaXN0ZW5lcihyLCBlKTtcbiAgICAgIH0sXG4gICAgICAobykgPT4ge1xuICAgICAgICBuKG5ldyBFcnJvcihvLm1lc3NhZ2UpKTtcbiAgICAgIH0sXG4gICAgICB0aGlzLnJwY0lkXG4gICAgKSwgdGhpcy5zZW5kUmVxdWVzdChcInN1YnNjcmliZVwiLCB7IC4uLnQsIHN1YklkOiByIH0pLCB0aGlzLnJwY0lkKyssIHI7XG4gIH1cbiAgY2FuY2VsU3Vic2NyaXB0aW9uKHQsIGUpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHQsIGUpLCB0aGlzLnJwY0lkKyssIHRoaXMuc2VuZFJlcXVlc3QoXCJ1bnN1YnNjcmliZVwiLCB7IHN1YklkOiB0IH0pO1xuICB9XG4gIGdldCBhY3RpdmVTdWJzY3JpcHRpb25zKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN1Ykxpc3RlbmVycyk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy53cyAmJiB0aGlzLndzPy5jbG9zZSgpO1xuICB9XG59XG52YXIgbGUgPSAvKiBAX19QVVJFX18gKi8gKChzKSA9PiAocy5VTlNQRU5UID0gXCJVTlNQRU5UXCIsIHMuUEVORElORyA9IFwiUEVORElOR1wiLCBzLlNQRU5UID0gXCJTUEVOVFwiLCBzKSkobGUgfHwge30pLCBOID0gLyogQF9fUFVSRV9fICovICgocykgPT4gKHMuVU5QQUlEID0gXCJVTlBBSURcIiwgcy5QRU5ESU5HID0gXCJQRU5ESU5HXCIsIHMuUEFJRCA9IFwiUEFJRFwiLCBzKSkoTiB8fCB7fSksIGogPSAvKiBAX19QVVJFX18gKi8gKChzKSA9PiAocy5VTlBBSUQgPSBcIlVOUEFJRFwiLCBzLlBBSUQgPSBcIlBBSURcIiwgcy5JU1NVRUQgPSBcIklTU1VFRFwiLCBzKSkoaiB8fCB7fSksIGZlID0gLyogQF9fUFVSRV9fICovICgocykgPT4gKHMuUE9TVCA9IFwicG9zdFwiLCBzLk5PU1RSID0gXCJub3N0clwiLCBzKSkoZmUgfHwge30pO1xuY2xhc3MgUiBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLnN0YXR1cyA9IGUsIHRoaXMubmFtZSA9IFwiSHR0cFJlc3BvbnNlRXJyb3JcIiwgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFIucHJvdG90eXBlKTtcbiAgfVxufVxuY2xhc3MgZXQgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5uYW1lID0gXCJOZXR3b3JrRXJyb3JcIiwgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIGV0LnByb3RvdHlwZSk7XG4gIH1cbn1cbmNsYXNzIHN0IGV4dGVuZHMgUiB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBzdXBlcihlIHx8IFwiVW5rbm93biBtaW50IG9wZXJhdGlvbiBlcnJvclwiLCA0MDApLCB0aGlzLmNvZGUgPSB0LCB0aGlzLm5hbWUgPSBcIk1pbnRPcGVyYXRpb25FcnJvclwiLCBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgc3QucHJvdG90eXBlKTtcbiAgfVxufVxubGV0IEF0ID0ge307XG5mdW5jdGlvbiBOZShzKSB7XG4gIEF0ID0gcztcbn1cbmFzeW5jIGZ1bmN0aW9uIHBlKHtcbiAgZW5kcG9pbnQ6IHMsXG4gIHJlcXVlc3RCb2R5OiB0LFxuICBoZWFkZXJzOiBlLFxuICAuLi5uXG59KSB7XG4gIGNvbnN0IHIgPSB0ID8gSlNPTi5zdHJpbmdpZnkodCkgOiB2b2lkIDAsIG8gPSB7XG4gICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKlwiLFxuICAgIC4uLnIgPyB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0gOiB2b2lkIDAsXG4gICAgLi4uZVxuICB9O1xuICBsZXQgaTtcbiAgdHJ5IHtcbiAgICBpID0gYXdhaXQgZmV0Y2gocywgeyBib2R5OiByLCBoZWFkZXJzOiBvLCAuLi5uIH0pO1xuICB9IGNhdGNoIChjKSB7XG4gICAgdGhyb3cgbmV3IGV0KGMgaW5zdGFuY2VvZiBFcnJvciA/IGMubWVzc2FnZSA6IFwiTmV0d29yayByZXF1ZXN0IGZhaWxlZFwiKTtcbiAgfVxuICBpZiAoIWkub2spIHtcbiAgICBjb25zdCBjID0gYXdhaXQgaS5qc29uKCkuY2F0Y2goKCkgPT4gKHsgZXJyb3I6IFwiYmFkIHJlc3BvbnNlXCIgfSkpO1xuICAgIHRocm93IGkuc3RhdHVzID09PSA0MDAgJiYgXCJjb2RlXCIgaW4gYyAmJiBcImRldGFpbFwiIGluIGMgPyBuZXcgc3QoYy5jb2RlLCBjLmRldGFpbCkgOiBuZXcgUihcbiAgICAgIFwiZXJyb3JcIiBpbiBjID8gYy5lcnJvciA6IGMuZGV0YWlsIHx8IFwiSFRUUCByZXF1ZXN0IGZhaWxlZFwiLFxuICAgICAgaS5zdGF0dXNcbiAgICApO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGkuanNvbigpO1xuICB9IGNhdGNoIChjKSB7XG4gICAgdGhyb3cgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBIVFRQIHJlc3BvbnNlXCIsIGMpLCBuZXcgUihcImJhZCByZXNwb25zZVwiLCBpLnN0YXR1cyk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIEEocykge1xuICByZXR1cm4gYXdhaXQgcGUoeyAuLi5zLCAuLi5BdCB9KTtcbn1cbmZ1bmN0aW9uIEgocykge1xuICByZXR1cm4gcy5zdGF0ZSB8fCAoY29uc29sZS53YXJuKFxuICAgIFwiRmllbGQgJ3N0YXRlJyBub3QgZm91bmQgaW4gTWVsdFF1b3RlUmVzcG9uc2UuIFVwZGF0ZSBOVVQtMDUgb2YgbWludDogaHR0cHM6Ly9naXRodWIuY29tL2Nhc2h1YnRjL251dHMvcHVsbC8xMzYpXCJcbiAgKSwgdHlwZW9mIHMucGFpZCA9PSBcImJvb2xlYW5cIiAmJiAocy5zdGF0ZSA9IHMucGFpZCA/IE4uUEFJRCA6IE4uVU5QQUlEKSksIHM7XG59XG5mdW5jdGlvbiBwdChzKSB7XG4gIHJldHVybiBzLnN0YXRlIHx8IChjb25zb2xlLndhcm4oXG4gICAgXCJGaWVsZCAnc3RhdGUnIG5vdCBmb3VuZCBpbiBNaW50UXVvdGVSZXNwb25zZS4gVXBkYXRlIE5VVC0wNCBvZiBtaW50OiBodHRwczovL2dpdGh1Yi5jb20vY2FzaHVidGMvbnV0cy9wdWxsLzE0MSlcIlxuICApLCB0eXBlb2Ygcy5wYWlkID09IFwiYm9vbGVhblwiICYmIChzLnN0YXRlID0gcy5wYWlkID8gai5QQUlEIDogai5VTlBBSUQpKSwgcztcbn1cbmZ1bmN0aW9uIG1lKHMpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocz8uY29udGFjdCkgJiYgcz8uY29udGFjdC5sZW5ndGggPiAwICYmIChzLmNvbnRhY3QgPSBzLmNvbnRhY3QubWFwKCh0KSA9PiBBcnJheS5pc0FycmF5KHQpICYmIHQubGVuZ3RoID09PSAyICYmIHR5cGVvZiB0WzBdID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHRbMV0gPT0gXCJzdHJpbmdcIiA/IChjb25zb2xlLndhcm4oXG4gICAgXCJNaW50IHJldHVybmVkIGRlcHJlY2F0ZWQgJ2NvbnRhY3QnIGZpZWxkOiBVcGRhdGUgTlVULTA2OiBodHRwczovL2dpdGh1Yi5jb20vY2FzaHVidGMvbnV0cy9wdWxsLzExN1wiXG4gICksIHsgbWV0aG9kOiB0WzBdLCBpbmZvOiB0WzFdIH0pIDogdCkpLCBzO1xufVxuY2xhc3MgUCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gX21pbnRVcmwgcmVxdWlyZXMgbWludCBVUkwgdG8gY3JlYXRlIHRoaXMgb2JqZWN0XG4gICAqIEBwYXJhbSBfY3VzdG9tUmVxdWVzdCBpZiBwYXNzZWQsIHVzZSBjdXN0b20gcmVxdWVzdCBpbXBsZW1lbnRhdGlvbiBmb3IgbmV0d29yayBjb21tdW5pY2F0aW9uIHdpdGggdGhlIG1pbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICB0aGlzLl9taW50VXJsID0gdCwgdGhpcy5fY3VzdG9tUmVxdWVzdCA9IGUsIHRoaXMuX21pbnRVcmwgPSBvZSh0KSwgdGhpcy5fY3VzdG9tUmVxdWVzdCA9IGU7XG4gIH1cbiAgZ2V0IG1pbnRVcmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbnRVcmw7XG4gIH1cbiAgLyoqXG4gICAqIGZldGNoZXMgbWludHMgaW5mbyBhdCB0aGUgL2luZm8gZW5kcG9pbnRcbiAgICogQHBhcmFtIG1pbnRVcmxcbiAgICogQHBhcmFtIGN1c3RvbVJlcXVlc3RcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRJbmZvKHQsIGUpIHtcbiAgICBjb25zdCByID0gYXdhaXQgKGUgfHwgQSkoe1xuICAgICAgZW5kcG9pbnQ6IEUodCwgXCIvdjEvaW5mb1wiKVxuICAgIH0pO1xuICAgIHJldHVybiBtZShyKTtcbiAgfVxuICAvKipcbiAgICogZmV0Y2hlcyBtaW50cyBpbmZvIGF0IHRoZSAvaW5mbyBlbmRwb2ludFxuICAgKi9cbiAgYXN5bmMgZ2V0SW5mbygpIHtcbiAgICByZXR1cm4gUC5nZXRJbmZvKHRoaXMuX21pbnRVcmwsIHRoaXMuX2N1c3RvbVJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIHN3YXAgb3BlcmF0aW9uIHdpdGggZWNhc2ggaW5wdXRzIGFuZCBvdXRwdXRzLlxuICAgKiBAcGFyYW0gbWludFVybFxuICAgKiBAcGFyYW0gc3dhcFBheWxvYWQgcGF5bG9hZCBjb250YWluaW5nIGlucHV0cyBhbmQgb3V0cHV0c1xuICAgKiBAcGFyYW0gY3VzdG9tUmVxdWVzdFxuICAgKiBAcmV0dXJucyBzaWduZWQgb3V0cHV0c1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIHN3YXAodCwgZSwgbikge1xuICAgIGNvbnN0IG8gPSBhd2FpdCAobiB8fCBBKSh7XG4gICAgICBlbmRwb2ludDogRSh0LCBcIi92MS9zd2FwXCIpLFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIHJlcXVlc3RCb2R5OiBlXG4gICAgfSk7XG4gICAgaWYgKCF2KG8pIHx8ICFBcnJheS5pc0FycmF5KG8/LnNpZ25hdHVyZXMpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKG8uZGV0YWlsID8/IFwiYmFkIHJlc3BvbnNlXCIpO1xuICAgIHJldHVybiBvO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIHN3YXAgb3BlcmF0aW9uIHdpdGggZWNhc2ggaW5wdXRzIGFuZCBvdXRwdXRzLlxuICAgKiBAcGFyYW0gc3dhcFBheWxvYWQgcGF5bG9hZCBjb250YWluaW5nIGlucHV0cyBhbmQgb3V0cHV0c1xuICAgKiBAcmV0dXJucyBzaWduZWQgb3V0cHV0c1xuICAgKi9cbiAgYXN5bmMgc3dhcCh0KSB7XG4gICAgcmV0dXJuIFAuc3dhcCh0aGlzLl9taW50VXJsLCB0LCB0aGlzLl9jdXN0b21SZXF1ZXN0KTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgYSBuZXcgbWludCBxdW90ZSBmcm9tIHRoZSBtaW50LlxuICAgKiBAcGFyYW0gbWludFVybFxuICAgKiBAcGFyYW0gbWludFF1b3RlUGF5bG9hZCBQYXlsb2FkIGZvciBjcmVhdGluZyBhIG5ldyBtaW50IHF1b3RlXG4gICAqIEBwYXJhbSBjdXN0b21SZXF1ZXN0XG4gICAqIEByZXR1cm5zIHRoZSBtaW50IHdpbGwgY3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgbWludCBxdW90ZSBjb250YWluaW5nIGEgcGF5bWVudCByZXF1ZXN0IGZvciB0aGUgc3BlY2lmaWVkIGFtb3VudCBhbmQgdW5pdFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZU1pbnRRdW90ZSh0LCBlLCBuKSB7XG4gICAgY29uc3QgbyA9IGF3YWl0IChuIHx8IEEpKHtcbiAgICAgIGVuZHBvaW50OiBFKHQsIFwiL3YxL21pbnQvcXVvdGUvYm9sdDExXCIpLFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIHJlcXVlc3RCb2R5OiBlXG4gICAgfSk7XG4gICAgcmV0dXJuIHB0KG8pO1xuICB9XG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBhIG5ldyBtaW50IHF1b3RlIGZyb20gdGhlIG1pbnQuXG4gICAqIEBwYXJhbSBtaW50UXVvdGVQYXlsb2FkIFBheWxvYWQgZm9yIGNyZWF0aW5nIGEgbmV3IG1pbnQgcXVvdGVcbiAgICogQHJldHVybnMgdGhlIG1pbnQgd2lsbCBjcmVhdGUgYW5kIHJldHVybiBhIG5ldyBtaW50IHF1b3RlIGNvbnRhaW5pbmcgYSBwYXltZW50IHJlcXVlc3QgZm9yIHRoZSBzcGVjaWZpZWQgYW1vdW50IGFuZCB1bml0XG4gICAqL1xuICBhc3luYyBjcmVhdGVNaW50UXVvdGUodCkge1xuICAgIHJldHVybiBQLmNyZWF0ZU1pbnRRdW90ZSh0aGlzLl9taW50VXJsLCB0LCB0aGlzLl9jdXN0b21SZXF1ZXN0KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhbiBleGlzdGluZyBtaW50IHF1b3RlIGZyb20gdGhlIG1pbnQuXG4gICAqIEBwYXJhbSBtaW50VXJsXG4gICAqIEBwYXJhbSBxdW90ZSBRdW90ZSBJRFxuICAgKiBAcGFyYW0gY3VzdG9tUmVxdWVzdFxuICAgKiBAcmV0dXJucyB0aGUgbWludCB3aWxsIGNyZWF0ZSBhbmQgcmV0dXJuIGEgTGlnaHRuaW5nIGludm9pY2UgZm9yIHRoZSBzcGVjaWZpZWQgYW1vdW50XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgY2hlY2tNaW50UXVvdGUodCwgZSwgbikge1xuICAgIGNvbnN0IG8gPSBhd2FpdCAobiB8fCBBKSh7XG4gICAgICBlbmRwb2ludDogRSh0LCBcIi92MS9taW50L3F1b3RlL2JvbHQxMVwiLCBlKSxcbiAgICAgIG1ldGhvZDogXCJHRVRcIlxuICAgIH0pO1xuICAgIHJldHVybiBwdChvKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhbiBleGlzdGluZyBtaW50IHF1b3RlIGZyb20gdGhlIG1pbnQuXG4gICAqIEBwYXJhbSBxdW90ZSBRdW90ZSBJRFxuICAgKiBAcmV0dXJucyB0aGUgbWludCB3aWxsIGNyZWF0ZSBhbmQgcmV0dXJuIGEgTGlnaHRuaW5nIGludm9pY2UgZm9yIHRoZSBzcGVjaWZpZWQgYW1vdW50XG4gICAqL1xuICBhc3luYyBjaGVja01pbnRRdW90ZSh0KSB7XG4gICAgcmV0dXJuIFAuY2hlY2tNaW50UXVvdGUodGhpcy5fbWludFVybCwgdCwgdGhpcy5fY3VzdG9tUmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIE1pbnRzIG5ldyB0b2tlbnMgYnkgcmVxdWVzdGluZyBibGluZCBzaWduYXR1cmVzIG9uIHRoZSBwcm92aWRlZCBvdXRwdXRzLlxuICAgKiBAcGFyYW0gbWludFVybFxuICAgKiBAcGFyYW0gbWludFBheWxvYWQgUGF5bG9hZCBjb250YWluaW5nIHRoZSBvdXRwdXRzIHRvIGdldCBibGluZCBzaWduYXR1cmVzIG9uXG4gICAqIEBwYXJhbSBjdXN0b21SZXF1ZXN0XG4gICAqIEByZXR1cm5zIHNlcmlhbGl6ZWQgYmxpbmRlZCBzaWduYXR1cmVzXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgbWludCh0LCBlLCBuKSB7XG4gICAgY29uc3QgbyA9IGF3YWl0IChuIHx8IEEpKHtcbiAgICAgIGVuZHBvaW50OiBFKHQsIFwiL3YxL21pbnQvYm9sdDExXCIpLFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIHJlcXVlc3RCb2R5OiBlXG4gICAgfSk7XG4gICAgaWYgKCF2KG8pIHx8ICFBcnJheS5pc0FycmF5KG8/LnNpZ25hdHVyZXMpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHJlc3BvbnNlXCIpO1xuICAgIHJldHVybiBvO1xuICB9XG4gIC8qKlxuICAgKiBNaW50cyBuZXcgdG9rZW5zIGJ5IHJlcXVlc3RpbmcgYmxpbmQgc2lnbmF0dXJlcyBvbiB0aGUgcHJvdmlkZWQgb3V0cHV0cy5cbiAgICogQHBhcmFtIG1pbnRQYXlsb2FkIFBheWxvYWQgY29udGFpbmluZyB0aGUgb3V0cHV0cyB0byBnZXQgYmxpbmQgc2lnbmF0dXJlcyBvblxuICAgKiBAcmV0dXJucyBzZXJpYWxpemVkIGJsaW5kZWQgc2lnbmF0dXJlc1xuICAgKi9cbiAgYXN5bmMgbWludCh0KSB7XG4gICAgcmV0dXJuIFAubWludCh0aGlzLl9taW50VXJsLCB0LCB0aGlzLl9jdXN0b21SZXF1ZXN0KTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgYSBuZXcgbWVsdCBxdW90ZSBmcm9tIHRoZSBtaW50LlxuICAgKiBAcGFyYW0gbWludFVybFxuICAgKiBAcGFyYW0gTWVsdFF1b3RlUGF5bG9hZFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZU1lbHRRdW90ZSh0LCBlLCBuKSB7XG4gICAgY29uc3QgbyA9IGF3YWl0IChuIHx8IEEpKHtcbiAgICAgIGVuZHBvaW50OiBFKHQsIFwiL3YxL21lbHQvcXVvdGUvYm9sdDExXCIpLFxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIHJlcXVlc3RCb2R5OiBlXG4gICAgfSksIGkgPSBIKG8pO1xuICAgIGlmICghdihpKSB8fCB0eXBlb2YgaT8uYW1vdW50ICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGk/LmZlZV9yZXNlcnZlICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGk/LnF1b3RlICE9IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcmVzcG9uc2VcIik7XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGEgbmV3IG1lbHQgcXVvdGUgZnJvbSB0aGUgbWludC5cbiAgICogQHBhcmFtIE1lbHRRdW90ZVBheWxvYWRcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGNyZWF0ZU1lbHRRdW90ZSh0KSB7XG4gICAgcmV0dXJuIFAuY3JlYXRlTWVsdFF1b3RlKHRoaXMuX21pbnRVcmwsIHQsIHRoaXMuX2N1c3RvbVJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGFuIGV4aXN0aW5nIG1lbHQgcXVvdGUuXG4gICAqIEBwYXJhbSBtaW50VXJsXG4gICAqIEBwYXJhbSBxdW90ZSBRdW90ZSBJRFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNoZWNrTWVsdFF1b3RlKHQsIGUsIG4pIHtcbiAgICBjb25zdCBvID0gYXdhaXQgKG4gfHwgQSkoe1xuICAgICAgZW5kcG9pbnQ6IEUodCwgXCIvdjEvbWVsdC9xdW90ZS9ib2x0MTFcIiwgZSksXG4gICAgICBtZXRob2Q6IFwiR0VUXCJcbiAgICB9KSwgaSA9IEgobyk7XG4gICAgaWYgKCF2KGkpIHx8IHR5cGVvZiBpPy5hbW91bnQgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgaT8uZmVlX3Jlc2VydmUgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgaT8ucXVvdGUgIT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgaT8uc3RhdGUgIT0gXCJzdHJpbmdcIiB8fCAhT2JqZWN0LnZhbHVlcyhOKS5pbmNsdWRlcyhpLnN0YXRlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCByZXNwb25zZVwiKTtcbiAgICByZXR1cm4gaTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhbiBleGlzdGluZyBtZWx0IHF1b3RlLlxuICAgKiBAcGFyYW0gcXVvdGUgUXVvdGUgSURcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGNoZWNrTWVsdFF1b3RlKHQpIHtcbiAgICByZXR1cm4gUC5jaGVja01lbHRRdW90ZSh0aGlzLl9taW50VXJsLCB0LCB0aGlzLl9jdXN0b21SZXF1ZXN0KTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgdGhlIG1pbnQgdG8gcGF5IGZvciBhIEJvbHQxMSBwYXltZW50IHJlcXVlc3QgYnkgcHJvdmlkaW5nIGVjYXNoIGFzIGlucHV0cyB0byBiZSBzcGVudC4gVGhlIGlucHV0cyBjb250YWluIHRoZSBhbW91bnQgYW5kIHRoZSBmZWVfcmVzZXJ2ZXMgZm9yIGEgTGlnaHRuaW5nIHBheW1lbnQuIFRoZSBwYXlsb2FkIGNhbiBhbHNvIGNvbnRhaW4gYmxhbmsgb3V0cHV0cyBpbiBvcmRlciB0byByZWNlaXZlIGJhY2sgb3ZlcnBhaWQgTGlnaHRuaW5nIGZlZXMuXG4gICAqIEBwYXJhbSBtaW50VXJsXG4gICAqIEBwYXJhbSBtZWx0UGF5bG9hZFxuICAgKiBAcGFyYW0gY3VzdG9tUmVxdWVzdFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIG1lbHQodCwgZSwgbikge1xuICAgIGNvbnN0IG8gPSBhd2FpdCAobiB8fCBBKSh7XG4gICAgICBlbmRwb2ludDogRSh0LCBcIi92MS9tZWx0L2JvbHQxMVwiKSxcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICByZXF1ZXN0Qm9keTogZVxuICAgIH0pLCBpID0gSChvKTtcbiAgICBpZiAoIXYoaSkgfHwgdHlwZW9mIGk/LnN0YXRlICE9IFwic3RyaW5nXCIgfHwgIU9iamVjdC52YWx1ZXMoTikuaW5jbHVkZXMoaS5zdGF0ZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcmVzcG9uc2VcIik7XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgLyoqXG4gICAqIEFzayBtaW50IHRvIHBlcmZvcm0gYSBtZWx0IG9wZXJhdGlvbi4gVGhpcyBwYXlzIGEgbGlnaHRuaW5nIGludm9pY2UgYW5kIGRlc3Ryb3lzIHRva2VucyBtYXRjaGluZyBpdHMgYW1vdW50ICsgZmVlc1xuICAgKiBAcGFyYW0gbWVsdFBheWxvYWRcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIG1lbHQodCkge1xuICAgIHJldHVybiBQLm1lbHQodGhpcy5fbWludFVybCwgdCwgdGhpcy5fY3VzdG9tUmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBzcGVjaWZpYyBwcm9vZnMgaGF2ZSBhbHJlYWR5IGJlZW4gcmVkZWVtZWRcbiAgICogQHBhcmFtIG1pbnRVcmxcbiAgICogQHBhcmFtIGNoZWNrUGF5bG9hZFxuICAgKiBAcGFyYW0gY3VzdG9tUmVxdWVzdFxuICAgKiBAcmV0dXJucyByZWRlZW1lZCBhbmQgdW5yZWRlZW1lZCBvcmRlcmVkIGxpc3Qgb2YgYm9vbGVhbnNcbiAgICovXG4gIHN0YXRpYyBhc3luYyBjaGVjayh0LCBlLCBuKSB7XG4gICAgY29uc3QgbyA9IGF3YWl0IChuIHx8IEEpKHtcbiAgICAgIGVuZHBvaW50OiBFKHQsIFwiL3YxL2NoZWNrc3RhdGVcIiksXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgcmVxdWVzdEJvZHk6IGVcbiAgICB9KTtcbiAgICBpZiAoIXYobykgfHwgIUFycmF5LmlzQXJyYXkobz8uc3RhdGVzKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCByZXNwb25zZVwiKTtcbiAgICByZXR1cm4gbztcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtaW50cyBwdWJsaWMga2V5c1xuICAgKiBAcGFyYW0gbWludFVybFxuICAgKiBAcGFyYW0ga2V5c2V0SWQgb3B0aW9uYWwgcGFyYW0gdG8gZ2V0IHRoZSBrZXlzIGZvciBhIHNwZWNpZmljIGtleXNldC4gSWYgbm90IHNwZWNpZmllZCwgdGhlIGtleXMgZnJvbSBhbGwgYWN0aXZlIGtleXNldHMgYXJlIGZldGNoZWRcbiAgICogQHBhcmFtIGN1c3RvbVJlcXVlc3RcbiAgICogQHJldHVybnNcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRLZXlzKHQsIGUsIG4pIHtcbiAgICBlICYmIChlID0gZS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoL1xcKy9nLCBcIi1cIikpO1xuICAgIGNvbnN0IG8gPSBhd2FpdCAobiB8fCBBKSh7XG4gICAgICBlbmRwb2ludDogZSA/IEUodCwgXCIvdjEva2V5c1wiLCBlKSA6IEUodCwgXCIvdjEva2V5c1wiKVxuICAgIH0pO1xuICAgIGlmICghdihvKSB8fCAhQXJyYXkuaXNBcnJheShvLmtleXNldHMpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHJlc3BvbnNlXCIpO1xuICAgIHJldHVybiBvO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbnRzIHB1YmxpYyBrZXlzXG4gICAqIEBwYXJhbSBrZXlzZXRJZCBvcHRpb25hbCBwYXJhbSB0byBnZXQgdGhlIGtleXMgZm9yIGEgc3BlY2lmaWMga2V5c2V0LiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUga2V5cyBmcm9tIGFsbCBhY3RpdmUga2V5c2V0cyBhcmUgZmV0Y2hlZFxuICAgKiBAcmV0dXJucyB0aGUgbWludHMgcHVibGljIGtleXNcbiAgICovXG4gIGFzeW5jIGdldEtleXModCwgZSkge1xuICAgIHJldHVybiBhd2FpdCBQLmdldEtleXMoXG4gICAgICBlIHx8IHRoaXMuX21pbnRVcmwsXG4gICAgICB0LFxuICAgICAgdGhpcy5fY3VzdG9tUmVxdWVzdFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbWludHMga2V5c2V0cyBpbiBubyBzcGVjaWZpYyBvcmRlclxuICAgKiBAcGFyYW0gbWludFVybFxuICAgKiBAcGFyYW0gY3VzdG9tUmVxdWVzdFxuICAgKiBAcmV0dXJucyBhbGwgdGhlIG1pbnRzIHBhc3QgYW5kIGN1cnJlbnQga2V5c2V0cy5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRLZXlTZXRzKHQsIGUpIHtcbiAgICByZXR1cm4gKGUgfHwgQSkoeyBlbmRwb2ludDogRSh0LCBcIi92MS9rZXlzZXRzXCIpIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbnRzIGtleXNldHMgaW4gbm8gc3BlY2lmaWMgb3JkZXJcbiAgICogQHJldHVybnMgYWxsIHRoZSBtaW50cyBwYXN0IGFuZCBjdXJyZW50IGtleXNldHMuXG4gICAqL1xuICBhc3luYyBnZXRLZXlTZXRzKCkge1xuICAgIHJldHVybiBQLmdldEtleVNldHModGhpcy5fbWludFVybCwgdGhpcy5fY3VzdG9tUmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBzcGVjaWZpYyBwcm9vZnMgaGF2ZSBhbHJlYWR5IGJlZW4gcmVkZWVtZWRcbiAgICogQHBhcmFtIGNoZWNrUGF5bG9hZFxuICAgKiBAcmV0dXJucyByZWRlZW1lZCBhbmQgdW5yZWRlZW1lZCBvcmRlcmVkIGxpc3Qgb2YgYm9vbGVhbnNcbiAgICovXG4gIGFzeW5jIGNoZWNrKHQpIHtcbiAgICByZXR1cm4gUC5jaGVjayh0aGlzLl9taW50VXJsLCB0LCB0aGlzLl9jdXN0b21SZXF1ZXN0KTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgcmVzdG9yZSh0LCBlLCBuKSB7XG4gICAgY29uc3QgbyA9IGF3YWl0IChuIHx8IEEpKHtcbiAgICAgIGVuZHBvaW50OiBFKHQsIFwiL3YxL3Jlc3RvcmVcIiksXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgcmVxdWVzdEJvZHk6IGVcbiAgICB9KTtcbiAgICBpZiAoIXYobykgfHwgIUFycmF5LmlzQXJyYXkobz8ub3V0cHV0cykgfHwgIUFycmF5LmlzQXJyYXkobz8uc2lnbmF0dXJlcykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcmVzcG9uc2VcIik7XG4gICAgcmV0dXJuIG87XG4gIH1cbiAgYXN5bmMgcmVzdG9yZSh0KSB7XG4gICAgcmV0dXJuIFAucmVzdG9yZSh0aGlzLl9taW50VXJsLCB0LCB0aGlzLl9jdXN0b21SZXF1ZXN0KTtcbiAgfVxuICAvKipcbiAgICogVHJpZXMgdG8gZXN0YWJsaXNoIGEgd2Vic29ja2V0IGNvbm5lY3Rpb24gd2l0aCB0aGUgd2Vic29ja2V0IG1pbnQgdXJsIGFjY29yZGluZyB0byBOVVQtMTdcbiAgICovXG4gIGFzeW5jIGNvbm5lY3RXZWJTb2NrZXQoKSB7XG4gICAgaWYgKHRoaXMud3MpXG4gICAgICBhd2FpdCB0aGlzLndzLmVuc3VyZUNvbm5lY3Rpb24oKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHQgPSBuZXcgVVJMKHRoaXMuX21pbnRVcmwpLCBlID0gXCJ2MS93c1wiO1xuICAgICAgdC5wYXRobmFtZSAmJiAodC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikgPyB0LnBhdGhuYW1lICs9IGUgOiB0LnBhdGhuYW1lICs9IFwiL1wiICsgZSksIHRoaXMud3MgPSB4LmdldEluc3RhbmNlKCkuZ2V0Q29ubmVjdGlvbihcbiAgICAgICAgYCR7dC5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwid3NzXCIgOiBcIndzXCJ9Oi8vJHt0Lmhvc3R9JHt0LnBhdGhuYW1lfWBcbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLndzLmNvbm5lY3QoKTtcbiAgICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgICAgdGhyb3cgY29uc29sZS5sb2cobiksIG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb25uZWN0IHRvIFdlYlNvY2tldC4uLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyBhIHdlYnNvY2tldCBjb25uZWN0aW9uXG4gICAqL1xuICBkaXNjb25uZWN0V2ViU29ja2V0KCkge1xuICAgIHRoaXMud3MgJiYgdGhpcy53cy5jbG9zZSgpO1xuICB9XG4gIGdldCB3ZWJTb2NrZXRDb25uZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLndzO1xuICB9XG59XG5jbGFzcyBtdCB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB0aGlzLl9taW50SW5mbyA9IHQ7XG4gIH1cbiAgaXNTdXBwb3J0ZWQodCkge1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSA0OlxuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy5jaGVja01pbnRNZWx0KHQpO1xuICAgICAgY2FzZSA3OlxuICAgICAgY2FzZSA4OlxuICAgICAgY2FzZSA5OlxuICAgICAgY2FzZSAxMDpcbiAgICAgIGNhc2UgMTE6XG4gICAgICBjYXNlIDEyOlxuICAgICAgY2FzZSAxNDpcbiAgICAgIGNhc2UgMjA6XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrR2VuZXJpY051dCh0KTtcbiAgICAgIGNhc2UgMTc6XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrTnV0MTcoKTtcbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrTnV0MTUoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm51dCBpcyBub3Qgc3VwcG9ydGVkIGJ5IGNhc2h1LXRzXCIpO1xuICAgIH1cbiAgfVxuICBjaGVja0dlbmVyaWNOdXQodCkge1xuICAgIHJldHVybiB0aGlzLl9taW50SW5mby5udXRzW3RdPy5zdXBwb3J0ZWQgPyB7IHN1cHBvcnRlZDogITAgfSA6IHsgc3VwcG9ydGVkOiAhMSB9O1xuICB9XG4gIGNoZWNrTWludE1lbHQodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9taW50SW5mby5udXRzW3RdO1xuICAgIHJldHVybiBlICYmIGUubWV0aG9kcy5sZW5ndGggPiAwICYmICFlLmRpc2FibGVkID8geyBkaXNhYmxlZDogITEsIHBhcmFtczogZS5tZXRob2RzIH0gOiB7IGRpc2FibGVkOiAhMCwgcGFyYW1zOiBlLm1ldGhvZHMgfTtcbiAgfVxuICBjaGVja051dDE3KCkge1xuICAgIHJldHVybiB0aGlzLl9taW50SW5mby5udXRzWzE3XSAmJiB0aGlzLl9taW50SW5mby5udXRzWzE3XS5zdXBwb3J0ZWQubGVuZ3RoID4gMCA/IHsgc3VwcG9ydGVkOiAhMCwgcGFyYW1zOiB0aGlzLl9taW50SW5mby5udXRzWzE3XS5zdXBwb3J0ZWQgfSA6IHsgc3VwcG9ydGVkOiAhMSB9O1xuICB9XG4gIGNoZWNrTnV0MTUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbnRJbmZvLm51dHNbMTVdICYmIHRoaXMuX21pbnRJbmZvLm51dHNbMTVdLm1ldGhvZHMubGVuZ3RoID4gMCA/IHsgc3VwcG9ydGVkOiAhMCwgcGFyYW1zOiB0aGlzLl9taW50SW5mby5udXRzWzE1XS5tZXRob2RzIH0gOiB7IHN1cHBvcnRlZDogITEgfTtcbiAgfVxuICBnZXQgY29udGFjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWludEluZm8uY29udGFjdDtcbiAgfVxuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbnRJbmZvLmRlc2NyaXB0aW9uO1xuICB9XG4gIGdldCBkZXNjcmlwdGlvbl9sb25nKCkge1xuICAgIHJldHVybiB0aGlzLl9taW50SW5mby5kZXNjcmlwdGlvbl9sb25nO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9taW50SW5mby5uYW1lO1xuICB9XG4gIGdldCBwdWJrZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbnRJbmZvLnB1YmtleTtcbiAgfVxuICBnZXQgbnV0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWludEluZm8ubnV0cztcbiAgfVxuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWludEluZm8udmVyc2lvbjtcbiAgfVxuICBnZXQgbW90ZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWludEluZm8ubW90ZDtcbiAgfVxufVxuZnVuY3Rpb24geWUocywgdCkge1xuICBsZXQgZSA9IHM7XG4gIGZvciAoY29uc3QgciBvZiB0KVxuICAgIGUgKz0gci5CXztcbiAgY29uc3QgbiA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShlKTtcbiAgcmV0dXJuIHl0KG4pO1xufVxuZnVuY3Rpb24gZ2UocywgdCwgZSkge1xuICBjb25zdCBuID0geWUodCwgZSksIHIgPSBHKHMpLCBvID0gVHQuc2lnbihuLCByKTtcbiAgcmV0dXJuIE8obyk7XG59XG5jbGFzcyAkIHtcbiAgY29uc3RydWN0b3IodCwgZSwgbikge1xuICAgIHRoaXMuYW1vdW50ID0gdCwgdGhpcy5CXyA9IGUsIHRoaXMuaWQgPSBuO1xuICB9XG4gIGdldFNlcmlhbGl6ZWRCbGluZGVkTWVzc2FnZSgpIHtcbiAgICByZXR1cm4geyBhbW91bnQ6IHRoaXMuYW1vdW50LCBCXzogdGhpcy5CXy50b0hleCghMCksIGlkOiB0aGlzLmlkIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHoocykge1xuICByZXR1cm4gdHlwZW9mIHMgPT0gXCJmdW5jdGlvblwiO1xufVxuY2xhc3MgcSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIG4pIHtcbiAgICB0aGlzLnNlY3JldCA9IG4sIHRoaXMuYmxpbmRpbmdGYWN0b3IgPSBlLCB0aGlzLmJsaW5kZWRNZXNzYWdlID0gdDtcbiAgfVxuICB0b1Byb29mKHQsIGUpIHtcbiAgICBsZXQgbjtcbiAgICB0LmRsZXEgJiYgKG4gPSB7XG4gICAgICBzOiBHKHQuZGxlcS5zKSxcbiAgICAgIGU6IEcodC5kbGVxLmUpLFxuICAgICAgcjogdGhpcy5ibGluZGluZ0ZhY3RvclxuICAgIH0pO1xuICAgIGNvbnN0IHIgPSB7XG4gICAgICBpZDogdC5pZCxcbiAgICAgIGFtb3VudDogdC5hbW91bnQsXG4gICAgICBDXzogRih0LkNfKSxcbiAgICAgIGRsZXE6IG5cbiAgICB9LCBvID0gRihlLmtleXNbdC5hbW91bnRdKSwgaSA9IE10KHIsIHRoaXMuYmxpbmRpbmdGYWN0b3IsIHRoaXMuc2VjcmV0LCBvKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uVihpKSxcbiAgICAgIC4uLm4gJiYge1xuICAgICAgICBkbGVxOiB7XG4gICAgICAgICAgczogTyhuLnMpLFxuICAgICAgICAgIGU6IE8obi5lKSxcbiAgICAgICAgICByOiBadChuLnIgPz8gQmlnSW50KDApKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlUDJQS0RhdGEodCwgZSwgbiwgcikge1xuICAgIHJldHVybiBTKGUsIG4ua2V5cywgcikubWFwKChpKSA9PiB0aGlzLmNyZWF0ZVNpbmdsZVAyUEtEYXRhKHQsIGksIG4uaWQpKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlU2luZ2xlUDJQS0RhdGEodCwgZSwgbikge1xuICAgIGNvbnN0IHIgPSBbXG4gICAgICBcIlAyUEtcIixcbiAgICAgIHtcbiAgICAgICAgbm9uY2U6IE8oaHQoMzIpKSxcbiAgICAgICAgZGF0YTogdC5wdWJrZXksXG4gICAgICAgIHRhZ3M6IFtdXG4gICAgICB9XG4gICAgXTtcbiAgICB0LmxvY2t0aW1lICYmIHJbMV0udGFncy5wdXNoKFtcImxvY2t0aW1lXCIsIHQubG9ja3RpbWVdKSwgdC5yZWZ1bmRLZXlzICYmIHJbMV0udGFncy5wdXNoKFtcInJlZnVuZFwiLCB0LnJlZnVuZEtleXNdKTtcbiAgICBjb25zdCBvID0gSlNPTi5zdHJpbmdpZnkociksIGkgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobyksIHsgcjogYywgQl86IGEgfSA9IEMoaSk7XG4gICAgcmV0dXJuIG5ldyBxKFxuICAgICAgbmV3ICQoZSwgYSwgbikuZ2V0U2VyaWFsaXplZEJsaW5kZWRNZXNzYWdlKCksXG4gICAgICBjLFxuICAgICAgaVxuICAgICk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZVJhbmRvbURhdGEodCwgZSwgbikge1xuICAgIHJldHVybiBTKHQsIGUua2V5cywgbikubWFwKChvKSA9PiB0aGlzLmNyZWF0ZVNpbmdsZVJhbmRvbURhdGEobywgZS5pZCkpO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVTaW5nbGVSYW5kb21EYXRhKHQsIGUpIHtcbiAgICBjb25zdCBuID0gTyhodCgzMikpLCByID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKG4pLCB7IHI6IG8sIEJfOiBpIH0gPSBDKHIpO1xuICAgIHJldHVybiBuZXcgcShcbiAgICAgIG5ldyAkKHQsIGksIGUpLmdldFNlcmlhbGl6ZWRCbGluZGVkTWVzc2FnZSgpLFxuICAgICAgbyxcbiAgICAgIHJcbiAgICApO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVEZXRlcm1pbmlzdGljRGF0YSh0LCBlLCBuLCByLCBvKSB7XG4gICAgcmV0dXJuIFModCwgci5rZXlzLCBvKS5tYXAoXG4gICAgICAoYywgYSkgPT4gdGhpcy5jcmVhdGVTaW5nbGVEZXRlcm1pbmlzdGljRGF0YShjLCBlLCBuICsgYSwgci5pZClcbiAgICApO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVTaW5nbGVEZXRlcm1pbmlzdGljRGF0YSh0LCBlLCBuLCByKSB7XG4gICAgY29uc3QgbyA9IFV0KGUsIHIsIG4pLCBpID0gTyhvKSwgYyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShpKSwgYSA9IFh0KER0KGUsIHIsIG4pKSwgeyByOiBoLCBCXzogZCB9ID0gQyhjLCBhKTtcbiAgICByZXR1cm4gbmV3IHEoXG4gICAgICBuZXcgJCh0LCBkLCByKS5nZXRTZXJpYWxpemVkQmxpbmRlZE1lc3NhZ2UoKSxcbiAgICAgIGgsXG4gICAgICBjXG4gICAgKTtcbiAgfVxufVxuY29uc3Qgd2UgPSAzLCBrZSA9IFwic2F0XCI7XG5jbGFzcyBCZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gbWludCBDYXNodSBtaW50IGluc3RhbmNlIGlzIHVzZWQgdG8gbWFrZSBhcGkgY2FsbHNcbiAgICogQHBhcmFtIG9wdGlvbnMudW5pdCBvcHRpb25hbGx5IHNldCB1bml0IChkZWZhdWx0IGlzICdzYXQnKVxuICAgKiBAcGFyYW0gb3B0aW9ucy5rZXlzIHB1YmxpYyBrZXlzIGZyb20gdGhlIG1pbnQgKHdpbGwgYmUgZmV0Y2hlZCBmcm9tIG1pbnQgaWYgbm90IHByb3ZpZGVkKVxuICAgKiBAcGFyYW0gb3B0aW9ucy5rZXlzZXRzIGtleXNldHMgZnJvbSB0aGUgbWludCAod2lsbCBiZSBmZXRjaGVkIGZyb20gbWludCBpZiBub3QgcHJvdmlkZWQpXG4gICAqIEBwYXJhbSBvcHRpb25zLm1pbnRJbmZvIG1pbnQgaW5mbyBmcm9tIHRoZSBtaW50ICh3aWxsIGJlIGZldGNoZWQgZnJvbSBtaW50IGlmIG5vdCBwcm92aWRlZClcbiAgICogQHBhcmFtIG9wdGlvbnMuZGVub21pbmF0aW9uVGFyZ2V0IHRhcmdldCBudW1iZXIgcHJvb2ZzIHBlciBkZW5vbWluYXRpb24gKGRlZmF1bHQ6IHNlZSBAY29uc3RhbnQgREVGQVVMVF9ERU5PTUlOQVRJT05fVEFSR0VUKVxuICAgKiBAcGFyYW0gb3B0aW9ucy5iaXAzOXNlZWQgQklQMzkgc2VlZCBmb3IgZGV0ZXJtaW5pc3RpYyBzZWNyZXRzLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5rZWVwRmFjdG9yeSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIGJ5IGFsbCBwYXJ0cyBvZiB0aGUgbGlicmFyeSB0aGF0IHByb2R1Y2UgcHJvb2ZzIHRvIGJlIGtlcHQgKGNoYW5nZSwgZXRjLikuXG4gICAqIFRoaXMgY2FuIGxlYWQgdG8gcG9vciBwZXJmb3JtYW5jZSwgaW4gd2hpY2ggY2FzZSB0aGUgc2VlZCBzaG91bGQgYmUgZGlyZWN0bHkgcHJvdmlkZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICB0aGlzLl9rZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5fa2V5c2V0cyA9IFtdLCB0aGlzLl9zZWVkID0gdm9pZCAwLCB0aGlzLl91bml0ID0ga2UsIHRoaXMuX21pbnRJbmZvID0gdm9pZCAwLCB0aGlzLl9kZW5vbWluYXRpb25UYXJnZXQgPSB3ZSwgdGhpcy5taW50ID0gdDtcbiAgICBsZXQgbiA9IFtdO1xuICAgIGlmIChlPy5rZXlzICYmICFBcnJheS5pc0FycmF5KGUua2V5cykgPyBuID0gW2Uua2V5c10gOiBlPy5rZXlzICYmIEFycmF5LmlzQXJyYXkoZT8ua2V5cykgJiYgKG4gPSBlPy5rZXlzKSwgbiAmJiBuLmZvckVhY2goKHIpID0+IHRoaXMuX2tleXMuc2V0KHIuaWQsIHIpKSwgZT8udW5pdCAmJiAodGhpcy5fdW5pdCA9IGU/LnVuaXQpLCBlPy5rZXlzZXRzICYmICh0aGlzLl9rZXlzZXRzID0gZS5rZXlzZXRzKSwgZT8ubWludEluZm8gJiYgKHRoaXMuX21pbnRJbmZvID0gbmV3IG10KGUubWludEluZm8pKSwgZT8uZGVub21pbmF0aW9uVGFyZ2V0ICYmICh0aGlzLl9kZW5vbWluYXRpb25UYXJnZXQgPSBlLmRlbm9taW5hdGlvblRhcmdldCksIGU/LmJpcDM5c2VlZCkge1xuICAgICAgaWYgKGUuYmlwMzlzZWVkIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICB0aGlzLl9zZWVkID0gZS5iaXAzOXNlZWQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJpcDM5c2VlZCBtdXN0IGJlIGEgdmFsaWQgVUludDhBcnJheVwiKTtcbiAgICB9XG4gICAgZT8ua2VlcEZhY3RvcnkgJiYgKHRoaXMuX2tlZXBGYWN0b3J5ID0gZS5rZWVwRmFjdG9yeSk7XG4gIH1cbiAgZ2V0IHVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VuaXQ7XG4gIH1cbiAgZ2V0IGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleXM7XG4gIH1cbiAgZ2V0IGtleXNldElkKCkge1xuICAgIGlmICghdGhpcy5fa2V5c2V0SWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBrZXlzZXRJZCBzZXRcIik7XG4gICAgcmV0dXJuIHRoaXMuX2tleXNldElkO1xuICB9XG4gIHNldCBrZXlzZXRJZCh0KSB7XG4gICAgdGhpcy5fa2V5c2V0SWQgPSB0O1xuICB9XG4gIGdldCBrZXlzZXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9rZXlzZXRzO1xuICB9XG4gIGdldCBtaW50SW5mbygpIHtcbiAgICBpZiAoIXRoaXMuX21pbnRJbmZvKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWludCBpbmZvIG5vdCBsb2FkZWRcIik7XG4gICAgcmV0dXJuIHRoaXMuX21pbnRJbmZvO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1pbnRcbiAgICogQHJldHVybnMgbWludCBpbmZvXG4gICAqL1xuICBhc3luYyBnZXRNaW50SW5mbygpIHtcbiAgICBjb25zdCB0ID0gYXdhaXQgdGhpcy5taW50LmdldEluZm8oKTtcbiAgICByZXR1cm4gdGhpcy5fbWludEluZm8gPSBuZXcgbXQodCksIHRoaXMuX21pbnRJbmZvO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgc3RvcmVkIGluZm9ybWF0aW9uIGFib3V0IHRoZSBtaW50IG9yIHJlcXVlc3QgaXQgaWYgbm90IGxvYWRlZC5cbiAgICogQHJldHVybnMgbWludCBpbmZvXG4gICAqL1xuICBhc3luYyBsYXp5R2V0TWludEluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbnRJbmZvID8gdGhpcy5fbWludEluZm8gOiBhd2FpdCB0aGlzLmdldE1pbnRJbmZvKCk7XG4gIH1cbiAgLyoqXG4gICAqIExvYWQgbWludCBpbmZvcm1hdGlvbiwga2V5c2V0cyBhbmQga2V5cy4gVGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIGlmIG5vIGtleXNldHMgYXJlIHBhc3NlZCBpbiB0aGUgY29uc3RydWN0b3JcbiAgICovXG4gIGFzeW5jIGxvYWRNaW50KCkge1xuICAgIGF3YWl0IHRoaXMuZ2V0TWludEluZm8oKSwgYXdhaXQgdGhpcy5nZXRLZXlTZXRzKCksIGF3YWl0IHRoaXMuZ2V0S2V5cygpO1xuICB9XG4gIC8qKlxuICAgKiBDaG9vc2UgYSBrZXlzZXQgdG8gYWN0aXZhdGUgYmFzZWQgb24gdGhlIGxvd2VzdCBpbnB1dCBmZWVcbiAgICpcbiAgICogTm90ZTogdGhpcyBmdW5jdGlvbiB3aWxsIGZpbHRlciBvdXQgZGVwcmVjYXRlZCBiYXNlNjQga2V5c2V0c1xuICAgKlxuICAgKiBAcGFyYW0ga2V5c2V0cyBrZXlzZXRzIHRvIGNob29zZSBmcm9tXG4gICAqIEByZXR1cm5zIGFjdGl2ZSBrZXlzZXRcbiAgICovXG4gIGdldEFjdGl2ZUtleXNldCh0KSB7XG4gICAgbGV0IGUgPSB0LmZpbHRlcigocikgPT4gci5hY3RpdmUpO1xuICAgIGUgPSBlLmZpbHRlcigocikgPT4gci5pZC5zdGFydHNXaXRoKFwiMDBcIikpO1xuICAgIGNvbnN0IG4gPSBlLnNvcnQoXG4gICAgICAociwgbykgPT4gKHIuaW5wdXRfZmVlX3BwayA/PyAwKSAtIChvLmlucHV0X2ZlZV9wcGsgPz8gMClcbiAgICApWzBdO1xuICAgIGlmICghbilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFjdGl2ZSBrZXlzZXQgZm91bmRcIik7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgLyoqXG4gICAqIEdldCBrZXlzZXRzIGZyb20gdGhlIG1pbnQgd2l0aCB0aGUgdW5pdCBvZiB0aGUgd2FsbGV0XG4gICAqIEByZXR1cm5zIGtleXNldHMgd2l0aCB3YWxsZXQncyB1bml0XG4gICAqL1xuICBhc3luYyBnZXRLZXlTZXRzKCkge1xuICAgIGNvbnN0IGUgPSAoYXdhaXQgdGhpcy5taW50LmdldEtleVNldHMoKSkua2V5c2V0cy5maWx0ZXIoKG4pID0+IG4udW5pdCA9PT0gdGhpcy5fdW5pdCk7XG4gICAgcmV0dXJuIHRoaXMuX2tleXNldHMgPSBlLCB0aGlzLl9rZXlzZXRzO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIGFjdGl2ZSBrZXlzIGZyb20gdGhlIG1pbnQgYW5kIHNldCB0aGUga2V5c2V0IHdpdGggdGhlIGxvd2VzdCBmZWVzIGFzIHRoZSBhY3RpdmUgd2FsbGV0IGtleXNldC5cbiAgICogQHJldHVybnMga2V5c2V0XG4gICAqL1xuICBhc3luYyBnZXRBbGxLZXlzKCkge1xuICAgIGNvbnN0IHQgPSBhd2FpdCB0aGlzLm1pbnQuZ2V0S2V5cygpO1xuICAgIHJldHVybiB0aGlzLl9rZXlzID0gbmV3IE1hcCh0LmtleXNldHMubWFwKChlKSA9PiBbZS5pZCwgZV0pKSwgdGhpcy5rZXlzZXRJZCA9IHRoaXMuZ2V0QWN0aXZlS2V5c2V0KHRoaXMuX2tleXNldHMpLmlkLCB0LmtleXNldHM7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBwdWJsaWMga2V5cyBmcm9tIHRoZSBtaW50LiBJZiBrZXlzIHdlcmUgYWxyZWFkeSBmZXRjaGVkLCBpdCB3aWxsIHJldHVybiB0aG9zZS5cbiAgICpcbiAgICogSWYgYGtleXNldElkYCBpcyBzZXQsIGl0IHdpbGwgZmV0Y2ggYW5kIHJldHVybiB0aGF0IHNwZWNpZmljIGtleXNldC5cbiAgICogT3RoZXJ3aXNlLCB3ZSBzZWxlY3QgYW4gYWN0aXZlIGtleXNldCB3aXRoIHRoZSB1bml0IG9mIHRoZSB3YWxsZXQuXG4gICAqXG4gICAqIEBwYXJhbSBrZXlzZXRJZCBvcHRpb25hbCBrZXlzZXRJZCB0byBnZXQga2V5cyBmb3JcbiAgICogQHBhcmFtIGZvcmNlUmVmcmVzaD8gaWYgc2V0IHRvIHRydWUsIGl0IHdpbGwgZm9yY2UgcmVmcmVzaCB0aGUga2V5c2V0IGZyb20gdGhlIG1pbnRcbiAgICogQHJldHVybnMga2V5c2V0XG4gICAqL1xuICBhc3luYyBnZXRLZXlzKHQsIGUpIHtcbiAgICBpZiAoKCEodGhpcy5fa2V5c2V0cy5sZW5ndGggPiAwKSB8fCBlKSAmJiBhd2FpdCB0aGlzLmdldEtleVNldHMoKSwgdCB8fCAodCA9IHRoaXMuZ2V0QWN0aXZlS2V5c2V0KHRoaXMuX2tleXNldHMpLmlkKSwgIXRoaXMuX2tleXNldHMuZmluZCgobikgPT4gbi5pZCA9PT0gdCkgJiYgKGF3YWl0IHRoaXMuZ2V0S2V5U2V0cygpLCAhdGhpcy5fa2V5c2V0cy5maW5kKChuKSA9PiBuLmlkID09PSB0KSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvdWxkIG5vdCBpbml0aWFsaXplIGtleXMuIE5vIGtleXNldCB3aXRoIGlkICcke3R9JyBmb3VuZGApO1xuICAgIGlmICghdGhpcy5fa2V5cy5nZXQodCkpIHtcbiAgICAgIGNvbnN0IG4gPSBhd2FpdCB0aGlzLm1pbnQuZ2V0S2V5cyh0KTtcbiAgICAgIHRoaXMuX2tleXMuc2V0KHQsIG4ua2V5c2V0c1swXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmtleXNldElkID0gdCwgdGhpcy5fa2V5cy5nZXQodCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlY2VpdmUgYW4gZW5jb2RlZCBvciByYXcgQ2FzaHUgdG9rZW4gKG9ubHkgc3VwcG9ydHMgc2luZ2xlIHRva2Vucy4gSXQgd2lsbCBvbmx5IHByb2Nlc3MgdGhlIGZpcnN0IHRva2VuIGluIHRoZSB0b2tlbiBhcnJheSlcbiAgICogQHBhcmFtIHsoc3RyaW5nfFRva2VuKX0gdG9rZW4gLSBDYXNodSB0b2tlbiwgZWl0aGVyIGFzIHN0cmluZyBvciBkZWNvZGVkXG4gICAqIEBwYXJhbSB7UmVjZWl2ZU9wdGlvbnN9IFtvcHRpb25zXSAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRva2VuIHByb2Nlc3NpbmdcbiAgICogQHJldHVybnMgTmV3IHRva2VuIHdpdGggbmV3bHkgY3JlYXRlZCBwcm9vZnMsIHRva2VuIGVudHJpZXMgdGhhdCBoYWQgZXJyb3JzXG4gICAqL1xuICBhc3luYyByZWNlaXZlKHQsIGUpIHtcbiAgICBjb25zdCB7IHJlcXVpcmVEbGVxOiBuLCBrZXlzZXRJZDogciwgb3V0cHV0QW1vdW50czogbywgY291bnRlcjogaSwgcHVia2V5OiBjLCBwcml2a2V5OiBhLCBvdXRwdXREYXRhOiBoLCBwMnBrOiBkIH0gPSBlIHx8IHt9O1xuICAgIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgKHQgPSBzZSh0KSk7XG4gICAgY29uc3QgZiA9IGF3YWl0IHRoaXMuZ2V0S2V5cyhyKTtcbiAgICBpZiAobiAmJiB0LnByb29mcy5zb21lKChrKSA9PiAhYWUoaywgZikpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9rZW4gY29udGFpbnMgcHJvb2ZzIHdpdGggaW52YWxpZCBETEVRXCIpO1xuICAgIGNvbnN0IG0gPSBVKHQucHJvb2ZzKSAtIHRoaXMuZ2V0RmVlc0ZvclByb29mcyh0LnByb29mcyk7XG4gICAgbGV0IHU7XG4gICAgaCA/IHUgPSB7IHNlbmQ6IGggfSA6IHRoaXMuX2tlZXBGYWN0b3J5ICYmICh1ID0geyBzZW5kOiB0aGlzLl9rZWVwRmFjdG9yeSB9KTtcbiAgICBjb25zdCBsID0gdGhpcy5jcmVhdGVTd2FwUGF5bG9hZChcbiAgICAgIG0sXG4gICAgICB0LnByb29mcyxcbiAgICAgIGYsXG4gICAgICBvLFxuICAgICAgaSxcbiAgICAgIGMsXG4gICAgICBhLFxuICAgICAgdSxcbiAgICAgIGRcbiAgICApLCB7IHNpZ25hdHVyZXM6IHcgfSA9IGF3YWl0IHRoaXMubWludC5zd2FwKGwucGF5bG9hZCksIHkgPSBsLm91dHB1dERhdGEubWFwKChrLCBwKSA9PiBrLnRvUHJvb2Yod1twXSwgZikpLCBnID0gW107XG4gICAgcmV0dXJuIGwuc29ydGVkSW5kaWNlcy5mb3JFYWNoKChrLCBwKSA9PiB7XG4gICAgICBnW2tdID0geVtwXTtcbiAgICB9KSwgZztcbiAgfVxuICAvKipcbiAgICogU2VuZCBwcm9vZnMgb2YgYSBnaXZlbiBhbW91bnQsIGJ5IHByb3ZpZGluZyBhdCBsZWFzdCB0aGUgcmVxdWlyZWQgYW1vdW50IG9mIHByb29mc1xuICAgKiBAcGFyYW0gYW1vdW50IGFtb3VudCB0byBzZW5kXG4gICAqIEBwYXJhbSBwcm9vZnMgYXJyYXkgb2YgcHJvb2ZzIChhY2N1bXVsYXRlZCBhbW91bnQgb2YgcHJvb2ZzIG11c3QgYmUgPj0gdGhhbiBhbW91bnQpXG4gICAqIEBwYXJhbSB7U2VuZE9wdGlvbnN9IFtvcHRpb25zXSAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIGNvbmZpZ3VyaW5nIHRoZSBzZW5kIG9wZXJhdGlvblxuICAgKiBAcmV0dXJucyB7U2VuZFJlc3BvbnNlfVxuICAgKi9cbiAgYXN5bmMgc2VuZCh0LCBlLCBuKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJvb2ZzV2VIYXZlOiByLFxuICAgICAgb2ZmbGluZTogbyxcbiAgICAgIGluY2x1ZGVGZWVzOiBpLFxuICAgICAgaW5jbHVkZURsZXE6IGMsXG4gICAgICBrZXlzZXRJZDogYSxcbiAgICAgIG91dHB1dEFtb3VudHM6IGgsXG4gICAgICBwdWJrZXk6IGQsXG4gICAgICBwcml2a2V5OiBmLFxuICAgICAgb3V0cHV0RGF0YTogbVxuICAgIH0gPSBuIHx8IHt9O1xuICAgIGlmIChjICYmIChlID0gZS5maWx0ZXIoKHkpID0+IHkuZGxlcSAhPSBudWxsKSksIFUoZSkgPCB0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGVub3VnaCBmdW5kcyBhdmFpbGFibGUgdG8gc2VuZFwiKTtcbiAgICBjb25zdCB7IGtlZXA6IHUsIHNlbmQ6IGwgfSA9IHRoaXMuc2VsZWN0UHJvb2ZzVG9TZW5kKFxuICAgICAgZSxcbiAgICAgIHQsXG4gICAgICBuPy5pbmNsdWRlRmVlc1xuICAgICksIHcgPSBpID8gdGhpcy5nZXRGZWVzRm9yUHJvb2ZzKGwpIDogMDtcbiAgICBpZiAoIW8gJiYgKFUobCkgIT0gdCArIHcgfHwgLy8gaWYgdGhlIGV4YWN0IGFtb3VudCBjYW5ub3QgYmUgc2VsZWN0ZWRcbiAgICBoIHx8IGQgfHwgZiB8fCBhIHx8IG0pKSB7XG4gICAgICBjb25zdCB7IGtlZXA6IHksIHNlbmQ6IGcgfSA9IHRoaXMuc2VsZWN0UHJvb2ZzVG9TZW5kKFxuICAgICAgICBlLFxuICAgICAgICB0LFxuICAgICAgICAhMFxuICAgICAgKTtcbiAgICAgIHI/LnB1c2goLi4ueSk7XG4gICAgICBjb25zdCBrID0gYXdhaXQgdGhpcy5zd2FwKHQsIGcsIG4pO1xuICAgICAgbGV0IHsga2VlcDogcCwgc2VuZDogXyB9ID0gaztcbiAgICAgIGNvbnN0IFQgPSBrLnNlcmlhbGl6ZWQ7XG4gICAgICByZXR1cm4gcCA9IHkuY29uY2F0KHApLCBjIHx8IChfID0gTChfKSksIHsga2VlcDogcCwgc2VuZDogXywgc2VyaWFsaXplZDogVCB9O1xuICAgIH1cbiAgICBpZiAoVShsKSA8IHQgKyB3KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGVub3VnaCBmdW5kcyBhdmFpbGFibGUgdG8gc2VuZFwiKTtcbiAgICByZXR1cm4gYyA/IHsga2VlcDogdSwgc2VuZDogbCB9IDogeyBrZWVwOiB1LCBzZW5kOiBMKGwpIH07XG4gIH1cbiAgc2VsZWN0UHJvb2ZzVG9TZW5kKHQsIGUsIG4pIHtcbiAgICBjb25zdCByID0gdC5zb3J0KCh1LCBsKSA9PiB1LmFtb3VudCAtIGwuYW1vdW50KSwgbyA9IHIuZmlsdGVyKCh1KSA9PiB1LmFtb3VudCA8PSBlKS5zb3J0KCh1LCBsKSA9PiBsLmFtb3VudCAtIHUuYW1vdW50KSwgYyA9IHIuZmlsdGVyKCh1KSA9PiB1LmFtb3VudCA+IGUpLnNvcnQoKHUsIGwpID0+IHUuYW1vdW50IC0gbC5hbW91bnQpWzBdO1xuICAgIGlmICghby5sZW5ndGggJiYgYylcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtlZXA6IHQuZmlsdGVyKCh1KSA9PiB1LnNlY3JldCAhPT0gYy5zZWNyZXQpLFxuICAgICAgICBzZW5kOiBbY11cbiAgICAgIH07XG4gICAgaWYgKCFvLmxlbmd0aCAmJiAhYylcbiAgICAgIHJldHVybiB7IGtlZXA6IHQsIHNlbmQ6IFtdIH07XG4gICAgbGV0IGEgPSBlLCBoID0gW29bMF1dO1xuICAgIGNvbnN0IGQgPSBbXSwgZiA9IG4gPyB0aGlzLmdldEZlZXNGb3JQcm9vZnMoaCkgOiAwO1xuICAgIGlmIChhIC09IGhbMF0uYW1vdW50IC0gZiAvIDFlMywgYSA+IDApIHtcbiAgICAgIGNvbnN0IHsga2VlcDogdSwgc2VuZDogbCB9ID0gdGhpcy5zZWxlY3RQcm9vZnNUb1NlbmQoXG4gICAgICAgIG8uc2xpY2UoMSksXG4gICAgICAgIGEsXG4gICAgICAgIG5cbiAgICAgICk7XG4gICAgICBoLnB1c2goLi4ubCksIGQucHVzaCguLi51KTtcbiAgICB9XG4gICAgY29uc3QgbSA9IG4gPyB0aGlzLmdldEZlZXNGb3JQcm9vZnMoaCkgOiAwO1xuICAgIHJldHVybiBVKGgpIDwgZSArIG0gJiYgYyAmJiAoaCA9IFtjXSksIHtcbiAgICAgIGtlZXA6IHQuZmlsdGVyKCh1KSA9PiAhaC5pbmNsdWRlcyh1KSksXG4gICAgICBzZW5kOiBoXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogY2FsY3VsYXRlcyB0aGUgZmVlcyBiYXNlZCBvbiBpbnB1dHMgKHByb29mcylcbiAgICogQHBhcmFtIHByb29mcyBpbnB1dCBwcm9vZnMgdG8gY2FsY3VsYXRlIGZlZXMgZm9yXG4gICAqIEByZXR1cm5zIGZlZSBhbW91bnRcbiAgICovXG4gIGdldEZlZXNGb3JQcm9vZnModCkge1xuICAgIGlmICghdGhpcy5fa2V5c2V0cy5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY2FsY3VsYXRlIGZlZXMuIE5vIGtleXNldHMgZm91bmRcIik7XG4gICAgcmV0dXJuIG5ldyBTZXQodC5tYXAoKHIpID0+IHIuaWQpKS5mb3JFYWNoKChyKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2tleXNldHMuZmluZCgobykgPT4gby5pZCA9PT0gcikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGNhbGN1bGF0ZSBmZWVzLiBObyBrZXlzZXQgZm91bmQgd2l0aCBpZDogJHtyfWApO1xuICAgIH0pLCBNYXRoLmZsb29yKFxuICAgICAgTWF0aC5tYXgoXG4gICAgICAgICh0LnJlZHVjZShcbiAgICAgICAgICAociwgbykgPT4gciArICh0aGlzLl9rZXlzZXRzLmZpbmQoKGkpID0+IGkuaWQgPT09IG8uaWQpPy5pbnB1dF9mZWVfcHBrIHx8IDApLFxuICAgICAgICAgIDBcbiAgICAgICAgKSArIDk5OSkgLyAxZTMsXG4gICAgICAgIDBcbiAgICAgIClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBjYWxjdWxhdGVzIHRoZSBmZWVzIGJhc2VkIG9uIGlucHV0cyBmb3IgYSBnaXZlbiBrZXlzZXRcbiAgICogQHBhcmFtIG5JbnB1dHMgbnVtYmVyIG9mIGlucHV0c1xuICAgKiBAcGFyYW0ga2V5c2V0SWQga2V5c2V0SWQgdXNlZCB0byBsb29rdXAgYGlucHV0X2ZlZV9wcGtgXG4gICAqIEByZXR1cm5zIGZlZSBhbW91bnRcbiAgICovXG4gIGdldEZlZXNGb3JLZXlzZXQodCwgZSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKFxuICAgICAgTWF0aC5tYXgoXG4gICAgICAgICh0ICogKHRoaXMuX2tleXNldHMuZmluZCgocikgPT4gci5pZCA9PT0gZSk/LmlucHV0X2ZlZV9wcGsgfHwgMCkgKyA5OTkpIC8gMWUzLFxuICAgICAgICAwXG4gICAgICApXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogU3BsaXRzIGFuZCBjcmVhdGVzIHNlbmRhYmxlIHRva2Vuc1xuICAgKiBpZiBubyBhbW91bnQgaXMgc3BlY2lmaWVkLCB0aGUgYW1vdW50IGlzIGltcGxpZWQgYnkgdGhlIGN1bXVsYXRpdmUgYW1vdW50IG9mIGFsbCBwcm9vZnNcbiAgICogaWYgYm90aCBhbW91bnQgYW5kIHByZWZlcmVuY2UgYXJlIHNldCwgYnV0IHRoZSBwcmVmZXJlbmNlIGNhbm5vdCBmdWxmaWxsIHRoZSBhbW91bnQsIHRoZW4gd2UgdXNlIHRoZSBkZWZhdWx0IHNwbGl0XG4gICAqICBAcGFyYW0ge1N3YXBPcHRpb25zfSBbb3B0aW9uc10gLSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBjb25maWd1cmluZyB0aGUgc3dhcCBvcGVyYXRpb25cbiAgICogQHJldHVybnMgcHJvbWlzZSBvZiB0aGUgY2hhbmdlLSBhbmQgc2VuZC1wcm9vZnNcbiAgICovXG4gIGFzeW5jIHN3YXAodCwgZSwgbikge1xuICAgIGxldCB7IG91dHB1dEFtb3VudHM6IHIgfSA9IG4gfHwge307XG4gICAgY29uc3QgeyBpbmNsdWRlRmVlczogbywga2V5c2V0SWQ6IGksIGNvdW50ZXI6IGMsIHB1YmtleTogYSwgcHJpdmtleTogaCwgcHJvb2ZzV2VIYXZlOiBkLCBvdXRwdXREYXRhOiBmLCBwMnBrOiBtIH0gPSBuIHx8IHt9LCB1ID0gYXdhaXQgdGhpcy5nZXRLZXlzKGkpLCBsID0gZTtcbiAgICBsZXQgdyA9IHQ7XG4gICAgY29uc3QgeSA9IFUoZSk7XG4gICAgbGV0IGcgPSB5IC0gdyAtIHRoaXMuZ2V0RmVlc0ZvclByb29mcyhsKSwgayA9IHI/LnNlbmRBbW91bnRzIHx8IFModywgdS5rZXlzKTtcbiAgICBpZiAobykge1xuICAgICAgbGV0IGIgPSB0aGlzLmdldEZlZXNGb3JLZXlzZXQoay5sZW5ndGgsIHUuaWQpLCBJID0gUyhiLCB1LmtleXMpO1xuICAgICAgZm9yICg7IHRoaXMuZ2V0RmVlc0ZvcktleXNldChrLmNvbmNhdChJKS5sZW5ndGgsIHUuaWQpID4gYjsgKVxuICAgICAgICBiKyssIEkgPSBTKGIsIHUua2V5cyk7XG4gICAgICBrID0gay5jb25jYXQoSSksIHcgKz0gYiwgZyAtPSBiO1xuICAgIH1cbiAgICBsZXQgcDtcbiAgICBpZiAoIXI/LmtlZXBBbW91bnRzICYmIGQpXG4gICAgICBwID0gZHQoXG4gICAgICAgIGQsXG4gICAgICAgIGcsXG4gICAgICAgIHUua2V5cyxcbiAgICAgICAgdGhpcy5fZGVub21pbmF0aW9uVGFyZ2V0XG4gICAgICApO1xuICAgIGVsc2UgaWYgKHIpIHtcbiAgICAgIGlmIChyLmtlZXBBbW91bnRzPy5yZWR1Y2UoKGIsIEkpID0+IGIgKyBJLCAwKSAhPSBnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZWVwIGFtb3VudHMgZG8gbm90IG1hdGNoIGFtb3VudCB0byBrZWVwXCIpO1xuICAgICAgcCA9IHIua2VlcEFtb3VudHM7XG4gICAgfVxuICAgIGlmICh3ICsgdGhpcy5nZXRGZWVzRm9yUHJvb2ZzKGwpID4geSlcbiAgICAgIHRocm93IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBOb3QgZW5vdWdoIGZ1bmRzIGF2YWlsYWJsZSAoJHt5fSkgZm9yIHN3YXAgYW1vdW50VG9TZW5kOiAke3d9ICsgZmVlOiAke3RoaXMuZ2V0RmVlc0ZvclByb29mcyhcbiAgICAgICAgICBsXG4gICAgICAgICl9IHwgbGVuZ3RoOiAke2wubGVuZ3RofWBcbiAgICAgICksIG5ldyBFcnJvcihcIk5vdCBlbm91Z2ggZnVuZHMgYXZhaWxhYmxlIGZvciBzd2FwXCIpO1xuICAgIGlmICh3ICsgdGhpcy5nZXRGZWVzRm9yUHJvb2ZzKGwpICsgZyAhPSB5KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW1vdW50cyBkbyBub3QgbWF0Y2ggZm9yIHN3YXBcIik7XG4gICAgciA9IHtcbiAgICAgIGtlZXBBbW91bnRzOiBwLFxuICAgICAgc2VuZEFtb3VudHM6IGtcbiAgICB9O1xuICAgIGNvbnN0IF8gPSBmPy5rZWVwIHx8IHRoaXMuX2tlZXBGYWN0b3J5LCBUID0gZj8uc2VuZCwgSyA9IHRoaXMuY3JlYXRlU3dhcFBheWxvYWQoXG4gICAgICB3LFxuICAgICAgbCxcbiAgICAgIHUsXG4gICAgICByLFxuICAgICAgYyxcbiAgICAgIGEsXG4gICAgICBoLFxuICAgICAgeyBrZWVwOiBfLCBzZW5kOiBUIH0sXG4gICAgICBtXG4gICAgKSwgeyBzaWduYXR1cmVzOiBxdCB9ID0gYXdhaXQgdGhpcy5taW50LnN3YXAoSy5wYXlsb2FkKSwgbnQgPSBLLm91dHB1dERhdGEubWFwKChiLCBJKSA9PiBiLnRvUHJvb2YocXRbSV0sIHUpKSwgcnQgPSBbXSwgb3QgPSBbXSwgaXQgPSBBcnJheShLLmtlZXBWZWN0b3IubGVuZ3RoKSwgY3QgPSBBcnJheShudC5sZW5ndGgpO1xuICAgIHJldHVybiBLLnNvcnRlZEluZGljZXMuZm9yRWFjaCgoYiwgSSkgPT4ge1xuICAgICAgaXRbYl0gPSBLLmtlZXBWZWN0b3JbSV0sIGN0W2JdID0gbnRbSV07XG4gICAgfSksIGN0LmZvckVhY2goKGIsIEkpID0+IHtcbiAgICAgIGl0W0ldID8gcnQucHVzaChiKSA6IG90LnB1c2goYik7XG4gICAgfSksIHtcbiAgICAgIGtlZXA6IHJ0LFxuICAgICAgc2VuZDogb3RcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXN0b3JlcyBiYXRjaGVzIG9mIGRldGVybWluaXN0aWMgcHJvb2ZzIHVudGlsIG5vIG1vcmUgc2lnbmF0dXJlcyBhcmUgcmV0dXJuZWQgZnJvbSB0aGUgbWludFxuICAgKiBAcGFyYW0gW2dhcExpbWl0PTMwMF0gdGhlIGFtb3VudCBvZiBlbXB0eSBjb3VudGVycyB0aGF0IHNob3VsZCBiZSByZXR1cm5lZCBiZWZvcmUgcmVzdG9yaW5nIGVuZHMgKGRlZmF1bHRzIHRvIDMwMClcbiAgICogQHBhcmFtIFtiYXRjaFNpemU9MTAwXSB0aGUgYW1vdW50IG9mIHByb29mcyB0aGF0IHNob3VsZCBiZSByZXN0b3JlZCBhdCBhIHRpbWUgKGRlZmF1bHRzIHRvIDEwMClcbiAgICogQHBhcmFtIFtjb3VudGVyPTBdIHRoZSBjb3VudGVyIHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgYSBzdGFydGluZyBwb2ludCAoZGVmYXVsdHMgdG8gMClcbiAgICogQHBhcmFtIFtrZXlzZXRJZF0gd2hpY2gga2V5c2V0SWQgdG8gdXNlIGZvciB0aGUgcmVzdG9yYXRpb24uIElmIG5vbmUgaXMgcGFzc2VkIHRoZSBpbnN0YW5jZSdzIGRlZmF1bHQgb25lIHdpbGwgYmUgdXNlZFxuICAgKi9cbiAgYXN5bmMgYmF0Y2hSZXN0b3JlKHQgPSAzMDAsIGUgPSAxMDAsIG4gPSAwLCByKSB7XG4gICAgY29uc3QgbyA9IE1hdGguY2VpbCh0IC8gZSksIGkgPSBbXTtcbiAgICBsZXQgYywgYSA9IDA7XG4gICAgZm9yICg7IGEgPCBvOyApIHtcbiAgICAgIGNvbnN0IGggPSBhd2FpdCB0aGlzLnJlc3RvcmUobiwgZSwgeyBrZXlzZXRJZDogciB9KTtcbiAgICAgIGgucHJvb2ZzLmxlbmd0aCA+IDAgPyAoYSA9IDAsIGkucHVzaCguLi5oLnByb29mcyksIGMgPSBoLmxhc3RDb3VudGVyV2l0aFNpZ25hdHVyZSkgOiBhKyssIG4gKz0gZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcHJvb2ZzOiBpLCBsYXN0Q291bnRlcldpdGhTaWduYXR1cmU6IGMgfTtcbiAgfVxuICAvKipcbiAgICogUmVnZW5lcmF0ZXNcbiAgICogQHBhcmFtIHN0YXJ0IHNldCBzdGFydGluZyBwb2ludCBmb3IgY291bnQgKGZpcnN0IGN5Y2xlIGZvciBlYWNoIGtleXNldCBzaG91bGQgdXN1YWxseSBiZSAwKVxuICAgKiBAcGFyYW0gY291bnQgc2V0IG51bWJlciBvZiBibGluZGVkIG1lc3NhZ2VzIHRoYXQgc2hvdWxkIGJlIGdlbmVyYXRlZFxuICAgKiBAcGFyYW0gb3B0aW9ucy5rZXlzZXRJZCBzZXQgYSBjdXN0b20ga2V5c2V0SWQgdG8gcmVzdG9yZSBmcm9tLiBrZXlzZXRJZHMgY2FuIGJlIGxvYWRlZCB3aXRoIGBDYXNodU1pbnQuZ2V0S2V5U2V0cygpYFxuICAgKi9cbiAgYXN5bmMgcmVzdG9yZSh0LCBlLCBuKSB7XG4gICAgY29uc3QgeyBrZXlzZXRJZDogciB9ID0gbiB8fCB7fSwgbyA9IGF3YWl0IHRoaXMuZ2V0S2V5cyhyKTtcbiAgICBpZiAoIXRoaXMuX3NlZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYXNodVdhbGxldCBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggYSBzZWVkIHRvIHVzZSByZXN0b3JlXCIpO1xuICAgIGNvbnN0IGkgPSBBcnJheShlKS5maWxsKDEpLCBjID0gcS5jcmVhdGVEZXRlcm1pbmlzdGljRGF0YShcbiAgICAgIGkubGVuZ3RoLFxuICAgICAgdGhpcy5fc2VlZCxcbiAgICAgIHQsXG4gICAgICBvLFxuICAgICAgaVxuICAgICksIHsgb3V0cHV0czogYSwgc2lnbmF0dXJlczogaCB9ID0gYXdhaXQgdGhpcy5taW50LnJlc3RvcmUoe1xuICAgICAgb3V0cHV0czogYy5tYXAoKHUpID0+IHUuYmxpbmRlZE1lc3NhZ2UpXG4gICAgfSksIGQgPSB7fTtcbiAgICBhLmZvckVhY2goKHUsIGwpID0+IGRbdS5CX10gPSBoW2xdKTtcbiAgICBjb25zdCBmID0gW107XG4gICAgbGV0IG07XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCBjLmxlbmd0aDsgdSsrKSB7XG4gICAgICBjb25zdCBsID0gZFtjW3VdLmJsaW5kZWRNZXNzYWdlLkJfXTtcbiAgICAgIGwgJiYgKG0gPSB0ICsgdSwgY1t1XS5ibGluZGVkTWVzc2FnZS5hbW91bnQgPSBsLmFtb3VudCwgZi5wdXNoKGNbdV0udG9Qcm9vZihsLCBvKSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcHJvb2ZzOiBmLFxuICAgICAgbGFzdENvdW50ZXJXaXRoU2lnbmF0dXJlOiBtXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgYSBtaW50IHF1b3RlIGZvcm0gdGhlIG1pbnQuIFJlc3BvbnNlIHJldHVybnMgYSBMaWdodG5pbmcgcGF5bWVudCByZXF1ZXN0IGZvciB0aGUgcmVxdWVzdGVkIGdpdmVuIGFtb3VudCBhbmQgdW5pdC5cbiAgICogQHBhcmFtIGFtb3VudCBBbW91bnQgcmVxdWVzdGluZyBmb3IgbWludC5cbiAgICogQHBhcmFtIGRlc2NyaXB0aW9uIG9wdGlvbmFsIGRlc2NyaXB0aW9uIGZvciB0aGUgbWludCBxdW90ZVxuICAgKiBAcGFyYW0gcHVia2V5IG9wdGlvbmFsIHB1YmxpYyBrZXkgdG8gbG9jayB0aGUgcXVvdGUgdG9cbiAgICogQHJldHVybnMgdGhlIG1pbnQgd2lsbCByZXR1cm4gYSBtaW50IHF1b3RlIHdpdGggYSBMaWdodG5pbmcgaW52b2ljZSBmb3IgbWludGluZyB0b2tlbnMgb2YgdGhlIHNwZWNpZmllZCBhbW91bnQgYW5kIHVuaXRcbiAgICovXG4gIGFzeW5jIGNyZWF0ZU1pbnRRdW90ZSh0LCBlKSB7XG4gICAgY29uc3QgbiA9IHtcbiAgICAgIHVuaXQ6IHRoaXMuX3VuaXQsXG4gICAgICBhbW91bnQ6IHQsXG4gICAgICBkZXNjcmlwdGlvbjogZVxuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMubWludC5jcmVhdGVNaW50UXVvdGUobik7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGEgbWludCBxdW90ZSBmcm9tIHRoZSBtaW50IHRoYXQgaXMgbG9ja2VkIHRvIGEgcHVibGljIGtleS5cbiAgICogQHBhcmFtIGFtb3VudCBBbW91bnQgcmVxdWVzdGluZyBmb3IgbWludC5cbiAgICogQHBhcmFtIHB1YmtleSBwdWJsaWMga2V5IHRvIGxvY2sgdGhlIHF1b3RlIHRvXG4gICAqIEBwYXJhbSBkZXNjcmlwdGlvbiBvcHRpb25hbCBkZXNjcmlwdGlvbiBmb3IgdGhlIG1pbnQgcXVvdGVcbiAgICogQHJldHVybnMgdGhlIG1pbnQgd2lsbCByZXR1cm4gYSBtaW50IHF1b3RlIHdpdGggYSBMaWdodG5pbmcgaW52b2ljZSBmb3IgbWludGluZyB0b2tlbnMgb2YgdGhlIHNwZWNpZmllZCBhbW91bnQgYW5kIHVuaXQuXG4gICAqIFRoZSBxdW90ZSB3aWxsIGJlIGxvY2tlZCB0byB0aGUgc3BlY2lmaWVkIGBwdWJrZXlgLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlTG9ja2VkTWludFF1b3RlKHQsIGUsIG4pIHtcbiAgICBjb25zdCB7IHN1cHBvcnRlZDogciB9ID0gKGF3YWl0IHRoaXMuZ2V0TWludEluZm8oKSkuaXNTdXBwb3J0ZWQoMjApO1xuICAgIGlmICghcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pbnQgZG9lcyBub3Qgc3VwcG9ydCBOVVQtMjBcIik7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIHVuaXQ6IHRoaXMuX3VuaXQsXG4gICAgICBhbW91bnQ6IHQsXG4gICAgICBkZXNjcmlwdGlvbjogbixcbiAgICAgIHB1YmtleTogZVxuICAgIH0sIGkgPSBhd2FpdCB0aGlzLm1pbnQuY3JlYXRlTWludFF1b3RlKG8pO1xuICAgIGlmICghaS5wdWJrZXkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaW50IHJldHVybmVkIHVubG9ja2VkIG1pbnQgcXVvdGVcIik7XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYW4gZXhpc3RpbmcgbWludCBxdW90ZSBmcm9tIHRoZSBtaW50LlxuICAgKiBAcGFyYW0gcXVvdGUgUXVvdGUgSURcbiAgICogQHJldHVybnMgdGhlIG1pbnQgd2lsbCBjcmVhdGUgYW5kIHJldHVybiBhIExpZ2h0bmluZyBpbnZvaWNlIGZvciB0aGUgc3BlY2lmaWVkIGFtb3VudFxuICAgKi9cbiAgYXN5bmMgY2hlY2tNaW50UXVvdGUodCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLm1pbnQuY2hlY2tNaW50UXVvdGUodCk7XG4gIH1cbiAgYXN5bmMgbWludFByb29mcyh0LCBlLCBuKSB7XG4gICAgbGV0IHsgb3V0cHV0QW1vdW50czogciB9ID0gbiB8fCB7fTtcbiAgICBjb25zdCB7IGNvdW50ZXI6IG8sIHB1YmtleTogaSwgcDJwazogYywga2V5c2V0SWQ6IGEsIHByb29mc1dlSGF2ZTogaCwgb3V0cHV0RGF0YTogZCwgcHJpdmF0ZUtleTogZiB9ID0gbiB8fCB7fSwgbSA9IGF3YWl0IHRoaXMuZ2V0S2V5cyhhKTtcbiAgICAhciAmJiBoICYmIChyID0ge1xuICAgICAga2VlcEFtb3VudHM6IGR0KGgsIHQsIG0ua2V5cywgdGhpcy5fZGVub21pbmF0aW9uVGFyZ2V0KSxcbiAgICAgIHNlbmRBbW91bnRzOiBbXVxuICAgIH0pO1xuICAgIGxldCB1ID0gW107XG4gICAgaWYgKGQpXG4gICAgICBpZiAoeihkKSkge1xuICAgICAgICBjb25zdCB5ID0gUyh0LCBtLmtleXMsIHI/LmtlZXBBbW91bnRzKTtcbiAgICAgICAgZm9yIChsZXQgZyA9IDA7IGcgPCB5Lmxlbmd0aDsgZysrKVxuICAgICAgICAgIHUucHVzaChkKHlbZ10sIG0pKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB1ID0gZDtcbiAgICBlbHNlIGlmICh0aGlzLl9rZWVwRmFjdG9yeSkge1xuICAgICAgY29uc3QgeSA9IFModCwgbS5rZXlzLCByPy5rZWVwQW1vdW50cyk7XG4gICAgICBmb3IgKGxldCBnID0gMDsgZyA8IHkubGVuZ3RoOyBnKyspXG4gICAgICAgIHUucHVzaCh0aGlzLl9rZWVwRmFjdG9yeSh5W2ddLCBtKSk7XG4gICAgfSBlbHNlXG4gICAgICB1ID0gdGhpcy5jcmVhdGVPdXRwdXREYXRhKFxuICAgICAgICB0LFxuICAgICAgICBtLFxuICAgICAgICBvLFxuICAgICAgICBpLFxuICAgICAgICByPy5rZWVwQW1vdW50cyxcbiAgICAgICAgY1xuICAgICAgKTtcbiAgICBsZXQgbDtcbiAgICBpZiAodHlwZW9mIGUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKCFmKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHNpZ24gbG9ja2VkIHF1b3RlIHdpdGhvdXQgcHJpdmF0ZSBrZXlcIik7XG4gICAgICBjb25zdCB5ID0gdS5tYXAoKGspID0+IGsuYmxpbmRlZE1lc3NhZ2UpLCBnID0gZ2UoZiwgZS5xdW90ZSwgeSk7XG4gICAgICBsID0ge1xuICAgICAgICBvdXRwdXRzOiB5LFxuICAgICAgICBxdW90ZTogZS5xdW90ZSxcbiAgICAgICAgc2lnbmF0dXJlOiBnXG4gICAgICB9O1xuICAgIH0gZWxzZVxuICAgICAgbCA9IHtcbiAgICAgICAgb3V0cHV0czogdS5tYXAoKHkpID0+IHkuYmxpbmRlZE1lc3NhZ2UpLFxuICAgICAgICBxdW90ZTogZVxuICAgICAgfTtcbiAgICBjb25zdCB7IHNpZ25hdHVyZXM6IHcgfSA9IGF3YWl0IHRoaXMubWludC5taW50KGwpO1xuICAgIHJldHVybiB1Lm1hcCgoeSwgZykgPT4geS50b1Byb29mKHdbZ10sIG0pKTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgYSBtZWx0IHF1b3RlIGZyb20gdGhlIG1pbnQuIFJlc3BvbnNlIHJldHVybnMgYW1vdW50IGFuZCBmZWVzIGZvciBhIGdpdmVuIHVuaXQgaW4gb3JkZXIgdG8gcGF5IGEgTGlnaHRuaW5nIGludm9pY2UuXG4gICAqIEBwYXJhbSBpbnZvaWNlIExOIGludm9pY2UgdGhhdCBuZWVkcyB0byBnZXQgYSBmZWUgZXN0aW1hdGVcbiAgICogQHJldHVybnMgdGhlIG1pbnQgd2lsbCBjcmVhdGUgYW5kIHJldHVybiBhIG1lbHQgcXVvdGUgZm9yIHRoZSBpbnZvaWNlIHdpdGggYW4gYW1vdW50IGFuZCBmZWUgcmVzZXJ2ZVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlTWVsdFF1b3RlKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgdW5pdDogdGhpcy5fdW5pdCxcbiAgICAgIHJlcXVlc3Q6IHRcbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLm1pbnQuY3JlYXRlTWVsdFF1b3RlKGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBhIG11bHRpIHBhdGggbWVsdCBxdW90ZSBmcm9tIHRoZSBtaW50LlxuICAgKiBAcGFyYW0gaW52b2ljZSBMTiBpbnZvaWNlIHRoYXQgbmVlZHMgdG8gZ2V0IGEgZmVlIGVzdGltYXRlXG4gICAqIEBwYXJhbSBwYXJ0aWFsQW1vdW50IHRoZSBwYXJ0aWFsIGFtb3VudCBvZiB0aGUgaW52b2ljZSdzIHRvdGFsIHRvIGJlIHBhaWQgYnkgdGhpcyBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB0aGUgbWludCB3aWxsIGNyZWF0ZSBhbmQgcmV0dXJuIGEgbWVsdCBxdW90ZSBmb3IgdGhlIGludm9pY2Ugd2l0aCBhbiBhbW91bnQgYW5kIGZlZSByZXNlcnZlXG4gICAqL1xuICBhc3luYyBjcmVhdGVNdWx0aVBhdGhNZWx0UXVvdGUodCwgZSkge1xuICAgIGNvbnN0IHsgc3VwcG9ydGVkOiBuLCBwYXJhbXM6IHIgfSA9IChhd2FpdCB0aGlzLmxhenlHZXRNaW50SW5mbygpKS5pc1N1cHBvcnRlZCgxNSk7XG4gICAgaWYgKCFuKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWludCBkb2VzIG5vdCBzdXBwb3J0IE5VVC0xNVwiKTtcbiAgICBpZiAoIXI/LnNvbWUoKGgpID0+IGgubWV0aG9kID09PSBcImJvbHQxMVwiICYmIGgudW5pdCA9PT0gdGhpcy51bml0KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWludCBkb2VzIG5vdCBzdXBwb3J0IE1QUCBmb3IgYm9sdDExIGFuZCAke3RoaXMudW5pdH1gKTtcbiAgICBjb25zdCBpID0ge1xuICAgICAgbXBwOiB7XG4gICAgICAgIGFtb3VudDogZVxuICAgICAgfVxuICAgIH0sIGMgPSB7XG4gICAgICB1bml0OiB0aGlzLl91bml0LFxuICAgICAgcmVxdWVzdDogdCxcbiAgICAgIG9wdGlvbnM6IGlcbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLm1pbnQuY3JlYXRlTWVsdFF1b3RlKGMpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gZXhpc3RpbmcgbWVsdCBxdW90ZSBmcm9tIHRoZSBtaW50LlxuICAgKiBAcGFyYW0gcXVvdGUgSUQgb2YgdGhlIG1lbHQgcXVvdGVcbiAgICogQHJldHVybnMgdGhlIG1pbnQgd2lsbCByZXR1cm4gYW4gZXhpc3RpbmcgbWVsdCBxdW90ZVxuICAgKi9cbiAgYXN5bmMgY2hlY2tNZWx0UXVvdGUodCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLm1pbnQuY2hlY2tNZWx0UXVvdGUodCk7XG4gIH1cbiAgLyoqXG4gICAqIE1lbHQgcHJvb2ZzIGZvciBhIG1lbHQgcXVvdGUuIHByb29mc1RvU2VuZCBtdXN0IGJlIGF0IGxlYXN0IGFtb3VudCtmZWVfcmVzZXJ2ZSBmb3JtIHRoZSBtZWx0IHF1b3RlLiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gY29pbiBzZWxlY3Rpb24hLlxuICAgKiBSZXR1cm5zIG1lbHQgcXVvdGUgYW5kIGNoYW5nZSBwcm9vZnNcbiAgICogQHBhcmFtIG1lbHRRdW90ZSBJRCBvZiB0aGUgbWVsdCBxdW90ZVxuICAgKiBAcGFyYW0gcHJvb2ZzVG9TZW5kIHByb29mcyB0byBtZWx0XG4gICAqIEBwYXJhbSB7TWVsdFByb29mT3B0aW9uc30gW29wdGlvbnNdIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgY29uZmlndXJpbmcgdGhlIE1lbHRpbmcgUHJvb2Ygb3BlcmF0aW9uXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBtZWx0UHJvb2ZzKHQsIGUsIG4pIHtcbiAgICBjb25zdCB7IGtleXNldElkOiByLCBjb3VudGVyOiBvLCBwcml2a2V5OiBpIH0gPSBuIHx8IHt9LCBjID0gYXdhaXQgdGhpcy5nZXRLZXlzKHIpLCBhID0gdGhpcy5jcmVhdGVCbGFua091dHB1dHMoXG4gICAgICBVKGUpIC0gdC5hbW91bnQsXG4gICAgICBjLFxuICAgICAgbyxcbiAgICAgIHRoaXMuX2tlZXBGYWN0b3J5XG4gICAgKTtcbiAgICBpICE9IG51bGwgJiYgKGUgPSB1dChcbiAgICAgIGUubWFwKChmKSA9PiAoe1xuICAgICAgICBhbW91bnQ6IGYuYW1vdW50LFxuICAgICAgICBDOiBGKGYuQyksXG4gICAgICAgIGlkOiBmLmlkLFxuICAgICAgICBzZWNyZXQ6IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShmLnNlY3JldClcbiAgICAgIH0pKSxcbiAgICAgIGlcbiAgICApLm1hcCgoZikgPT4gVihmKSkpLCBlID0gTChlKTtcbiAgICBjb25zdCBoID0ge1xuICAgICAgcXVvdGU6IHQucXVvdGUsXG4gICAgICBpbnB1dHM6IGUsXG4gICAgICBvdXRwdXRzOiBhLm1hcCgoZikgPT4gZi5ibGluZGVkTWVzc2FnZSlcbiAgICB9LCBkID0gYXdhaXQgdGhpcy5taW50Lm1lbHQoaCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHF1b3RlOiBkLFxuICAgICAgY2hhbmdlOiBkLmNoYW5nZT8ubWFwKChmLCBtKSA9PiBhW21dLnRvUHJvb2YoZiwgYykpID8/IFtdXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNwbGl0IHBheWxvYWRcbiAgICogQHBhcmFtIGFtb3VudCBhbW91bnQgdG8gc2VuZFxuICAgKiBAcGFyYW0gcHJvb2ZzVG9TZW5kIHByb29mcyB0byBzcGxpdCpcbiAgICogQHBhcmFtIG91dHB1dEFtb3VudHM/IG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgb3V0cHV0J3MgYW1vdW50cyB0byBrZWVwIGFuZCB0byBzZW5kLlxuICAgKiBAcGFyYW0gY291bnRlcj8gb3B0aW9uYWxseSBzZXQgY291bnRlciB0byBkZXJpdmUgc2VjcmV0IGRldGVybWluaXN0aWNhbGx5LiBDYXNodVdhbGxldCBjbGFzcyBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggc2VlZCBwaHJhc2UgdG8gdGFrZSBlZmZlY3RcbiAgICogQHBhcmFtIHB1YmtleT8gb3B0aW9uYWxseSBsb2NrcyBlY2FzaCB0byBwdWJrZXkuIFdpbGwgbm90IGJlIGRldGVybWluaXN0aWMsIGV2ZW4gaWYgY291bnRlciBpcyBzZXQhXG4gICAqIEBwYXJhbSBwcml2a2V5PyB3aWxsIGNyZWF0ZSBhIHNpZ25hdHVyZSBvbiB0aGUgQHBhcmFtIHByb29mc1RvU2VuZCBzZWNyZXRzIGlmIHNldFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgY3JlYXRlU3dhcFBheWxvYWQodCwgZSwgbiwgciwgbywgaSwgYywgYSwgaCkge1xuICAgIGNvbnN0IGQgPSBlLnJlZHVjZSgocCwgXykgPT4gcCArIF8uYW1vdW50LCAwKTtcbiAgICByICYmIHIuc2VuZEFtb3VudHMgJiYgIXIua2VlcEFtb3VudHMgJiYgKHIua2VlcEFtb3VudHMgPSBTKFxuICAgICAgZCAtIHQgLSB0aGlzLmdldEZlZXNGb3JQcm9vZnMoZSksXG4gICAgICBuLmtleXNcbiAgICApKTtcbiAgICBjb25zdCBmID0gZCAtIHQgLSB0aGlzLmdldEZlZXNGb3JQcm9vZnMoZSk7XG4gICAgbGV0IG0gPSBbXSwgdSA9IFtdO1xuICAgIGlmIChhPy5rZWVwKVxuICAgICAgaWYgKHooYS5rZWVwKSkge1xuICAgICAgICBjb25zdCBwID0gYS5rZWVwO1xuICAgICAgICBTKGYsIG4ua2V5cykuZm9yRWFjaCgoVCkgPT4ge1xuICAgICAgICAgIG0ucHVzaChwKFQsIG4pKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgbSA9IGEua2VlcDtcbiAgICBlbHNlXG4gICAgICBtID0gdGhpcy5jcmVhdGVPdXRwdXREYXRhKFxuICAgICAgICBmLFxuICAgICAgICBuLFxuICAgICAgICBvLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHI/LmtlZXBBbW91bnRzLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHRoaXMuX2tlZXBGYWN0b3J5XG4gICAgICApO1xuICAgIGlmIChhPy5zZW5kKVxuICAgICAgaWYgKHooYS5zZW5kKSkge1xuICAgICAgICBjb25zdCBwID0gYS5zZW5kO1xuICAgICAgICBTKHQsIG4ua2V5cykuZm9yRWFjaCgoVCkgPT4ge1xuICAgICAgICAgIHUucHVzaChwKFQsIG4pKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdSA9IGEuc2VuZDtcbiAgICBlbHNlXG4gICAgICB1ID0gdGhpcy5jcmVhdGVPdXRwdXREYXRhKFxuICAgICAgICB0LFxuICAgICAgICBuLFxuICAgICAgICBvID8gbyArIG0ubGVuZ3RoIDogdm9pZCAwLFxuICAgICAgICBpLFxuICAgICAgICByPy5zZW5kQW1vdW50cyxcbiAgICAgICAgaFxuICAgICAgKTtcbiAgICBjICYmIChlID0gdXQoXG4gICAgICBlLm1hcCgocCkgPT4gKHtcbiAgICAgICAgYW1vdW50OiBwLmFtb3VudCxcbiAgICAgICAgQzogRihwLkMpLFxuICAgICAgICBpZDogcC5pZCxcbiAgICAgICAgc2VjcmV0OiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocC5zZWNyZXQpXG4gICAgICB9KSksXG4gICAgICBjXG4gICAgKS5tYXAoKHApID0+IFYocCkpKSwgZSA9IEwoZSk7XG4gICAgY29uc3QgbCA9IFsuLi5tLCAuLi51XSwgdyA9IGwubWFwKChwLCBfKSA9PiBfKS5zb3J0KFxuICAgICAgKHAsIF8pID0+IGxbcF0uYmxpbmRlZE1lc3NhZ2UuYW1vdW50IC0gbFtfXS5ibGluZGVkTWVzc2FnZS5hbW91bnRcbiAgICApLCB5ID0gW1xuICAgICAgLi4uQXJyYXkobS5sZW5ndGgpLmZpbGwoITApLFxuICAgICAgLi4uQXJyYXkodS5sZW5ndGgpLmZpbGwoITEpXG4gICAgXSwgZyA9IHcubWFwKChwKSA9PiBsW3BdKSwgayA9IHcubWFwKChwKSA9PiB5W3BdKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGF5bG9hZDoge1xuICAgICAgICBpbnB1dHM6IGUsXG4gICAgICAgIG91dHB1dHM6IGcubWFwKChwKSA9PiBwLmJsaW5kZWRNZXNzYWdlKVxuICAgICAgfSxcbiAgICAgIG91dHB1dERhdGE6IGcsXG4gICAgICBrZWVwVmVjdG9yOiBrLFxuICAgICAgc29ydGVkSW5kaWNlczogd1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbiBhcnJheSBvZiB0aGUgc3RhdGVzIG9mIHByb29mcyBmcm9tIHRoZSBtaW50IChhcyBhbiBhcnJheSBvZiBDaGVja1N0YXRlRW51bSdzKVxuICAgKiBAcGFyYW0gcHJvb2ZzIChvbmx5IHRoZSBgc2VjcmV0YCBmaWVsZCBpcyByZXF1aXJlZClcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGNoZWNrUHJvb2ZzU3RhdGVzKHQpIHtcbiAgICBjb25zdCBlID0gbmV3IFRleHRFbmNvZGVyKCksIG4gPSB0Lm1hcCgoaSkgPT4gYXQoZS5lbmNvZGUoaS5zZWNyZXQpKS50b0hleCghMCkpLCByID0gMTAwLCBvID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSArPSByKSB7XG4gICAgICBjb25zdCBjID0gbi5zbGljZShpLCBpICsgciksIHsgc3RhdGVzOiBhIH0gPSBhd2FpdCB0aGlzLm1pbnQuY2hlY2soe1xuICAgICAgICBZczogY1xuICAgICAgfSksIGggPSB7fTtcbiAgICAgIGEuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICBoW2QuWV0gPSBkO1xuICAgICAgfSk7XG4gICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGMubGVuZ3RoOyBkKyspIHtcbiAgICAgICAgY29uc3QgZiA9IGhbY1tkXV07XG4gICAgICAgIGlmICghZilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBzdGF0ZSBmb3IgcHJvb2Ygd2l0aCBZOiBcIiArIGNbZF0pO1xuICAgICAgICBvLnB1c2goZik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1pbnQgcXVvdGUncyBzdGF0ZSBjaGFuZ2VzXG4gICAqIEBwYXJhbSBxdW90ZUlkcyBMaXN0IG9mIG1pbnQgcXVvdGUgSURzIHRoYXQgc2hvdWxkIGJlIHN1YnNjcmliZWQgdG9cbiAgICogQHBhcmFtIGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtaW50IHF1b3RlIHN0YXRlIGNoYW5nZXNcbiAgICogQHBhcmFtIGVycm9yQ2FsbGJhY2tcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIG9uTWludFF1b3RlVXBkYXRlcyh0LCBlLCBuKSB7XG4gICAgaWYgKGF3YWl0IHRoaXMubWludC5jb25uZWN0V2ViU29ja2V0KCksICF0aGlzLm1pbnQud2ViU29ja2V0Q29ubmVjdGlvbilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBlc3RhYmxpc2ggV2ViU29ja2V0IGNvbm5lY3Rpb24uXCIpO1xuICAgIGNvbnN0IHIgPSB0aGlzLm1pbnQud2ViU29ja2V0Q29ubmVjdGlvbi5jcmVhdGVTdWJzY3JpcHRpb24oXG4gICAgICB7IGtpbmQ6IFwiYm9sdDExX21pbnRfcXVvdGVcIiwgZmlsdGVyczogdCB9LFxuICAgICAgZSxcbiAgICAgIG5cbiAgICApO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLm1pbnQud2ViU29ja2V0Q29ubmVjdGlvbj8uY2FuY2VsU3Vic2NyaXB0aW9uKHIsIGUpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW5ldmVyIGEgbWVsdCBxdW90ZSdzIHN0YXRlIGNoYW5nZXNcbiAgICogQHBhcmFtIHF1b3RlSWRzIExpc3Qgb2YgbWVsdCBxdW90ZSBJRHMgdGhhdCBzaG91bGQgYmUgc3Vic2NyaWJlZCB0b1xuICAgKiBAcGFyYW0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1lbHQgcXVvdGUgc3RhdGUgY2hhbmdlc1xuICAgKiBAcGFyYW0gZXJyb3JDYWxsYmFja1xuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgb25NZWx0UXVvdGVQYWlkKHQsIGUsIG4pIHtcbiAgICByZXR1cm4gdGhpcy5vbk1lbHRRdW90ZVVwZGF0ZXMoXG4gICAgICBbdF0sXG4gICAgICAocikgPT4ge1xuICAgICAgICByLnN0YXRlID09PSBOLlBBSUQgJiYgZShyKTtcbiAgICAgIH0sXG4gICAgICBuXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiBhIHNpbmdsZSBtaW50IHF1b3RlIGdldHMgcGFpZFxuICAgKiBAcGFyYW0gcXVvdGVJZCBNaW50IHF1b3RlIGlkIHRoYXQgc2hvdWxkIGJlIHN1YnNjcmliZWQgdG9cbiAgICogQHBhcmFtIGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGlzIG1pbnQgcXVvdGUgZ2V0cyBwYWlkXG4gICAqIEBwYXJhbSBlcnJvckNhbGxiYWNrXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBvbk1pbnRRdW90ZVBhaWQodCwgZSwgbikge1xuICAgIHJldHVybiB0aGlzLm9uTWludFF1b3RlVXBkYXRlcyhcbiAgICAgIFt0XSxcbiAgICAgIChyKSA9PiB7XG4gICAgICAgIHIuc3RhdGUgPT09IGouUEFJRCAmJiBlKHIpO1xuICAgICAgfSxcbiAgICAgIG5cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB3aGVuIGEgc2luZ2xlIG1lbHQgcXVvdGUgZ2V0cyBwYWlkXG4gICAqIEBwYXJhbSBxdW90ZUlkIE1lbHQgcXVvdGUgaWQgdGhhdCBzaG91bGQgYmUgc3Vic2NyaWJlZCB0b1xuICAgKiBAcGFyYW0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoaXMgbWVsdCBxdW90ZSBnZXRzIHBhaWRcbiAgICogQHBhcmFtIGVycm9yQ2FsbGJhY2tcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIG9uTWVsdFF1b3RlVXBkYXRlcyh0LCBlLCBuKSB7XG4gICAgaWYgKGF3YWl0IHRoaXMubWludC5jb25uZWN0V2ViU29ja2V0KCksICF0aGlzLm1pbnQud2ViU29ja2V0Q29ubmVjdGlvbilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBlc3RhYmxpc2ggV2ViU29ja2V0IGNvbm5lY3Rpb24uXCIpO1xuICAgIGNvbnN0IHIgPSB0aGlzLm1pbnQud2ViU29ja2V0Q29ubmVjdGlvbi5jcmVhdGVTdWJzY3JpcHRpb24oXG4gICAgICB7IGtpbmQ6IFwiYm9sdDExX21lbHRfcXVvdGVcIiwgZmlsdGVyczogdCB9LFxuICAgICAgZSxcbiAgICAgIG5cbiAgICApO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLm1pbnQud2ViU29ja2V0Q29ubmVjdGlvbj8uY2FuY2VsU3Vic2NyaXB0aW9uKHIsIGUpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW5ldmVyIGEgc3Vic2NyaWJlZCBwcm9vZiBzdGF0ZSBjaGFuZ2VzXG4gICAqIEBwYXJhbSBwcm9vZnMgTGlzdCBvZiBwcm9vZnMgdGhhdCBzaG91bGQgYmUgc3Vic2NyaWJlZCB0b1xuICAgKiBAcGFyYW0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIHByb29mJ3Mgc3RhdGUgY2hhbmdlc1xuICAgKiBAcGFyYW0gZXJyb3JDYWxsYmFja1xuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgb25Qcm9vZlN0YXRlVXBkYXRlcyh0LCBlLCBuKSB7XG4gICAgaWYgKGF3YWl0IHRoaXMubWludC5jb25uZWN0V2ViU29ja2V0KCksICF0aGlzLm1pbnQud2ViU29ja2V0Q29ubmVjdGlvbilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBlc3RhYmxpc2ggV2ViU29ja2V0IGNvbm5lY3Rpb24uXCIpO1xuICAgIGNvbnN0IHIgPSBuZXcgVGV4dEVuY29kZXIoKSwgbyA9IHt9O1xuICAgIGZvciAobGV0IGEgPSAwOyBhIDwgdC5sZW5ndGg7IGErKykge1xuICAgICAgY29uc3QgaCA9IGF0KHIuZW5jb2RlKHRbYV0uc2VjcmV0KSkudG9IZXgoITApO1xuICAgICAgb1toXSA9IHRbYV07XG4gICAgfVxuICAgIGNvbnN0IGkgPSBPYmplY3Qua2V5cyhvKSwgYyA9IHRoaXMubWludC53ZWJTb2NrZXRDb25uZWN0aW9uLmNyZWF0ZVN1YnNjcmlwdGlvbihcbiAgICAgIHsga2luZDogXCJwcm9vZl9zdGF0ZVwiLCBmaWx0ZXJzOiBpIH0sXG4gICAgICAoYSkgPT4ge1xuICAgICAgICBlKHsgLi4uYSwgcHJvb2Y6IG9bYS5ZXSB9KTtcbiAgICAgIH0sXG4gICAgICBuXG4gICAgKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5taW50LndlYlNvY2tldENvbm5lY3Rpb24/LmNhbmNlbFN1YnNjcmlwdGlvbihjLCBlKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGJsaW5kZWQgbWVzc2FnZXMgZm9yIGEgYWNjb3JkaW5nIHRvIEBwYXJhbSBhbW91bnRzXG4gICAqIEBwYXJhbSBhbW91bnQgYXJyYXkgb2YgYW1vdW50cyB0byBjcmVhdGUgYmxpbmRlZCBtZXNzYWdlcyBmb3JcbiAgICogQHBhcmFtIGNvdW50ZXI/IG9wdGlvbmFsbHkgc2V0IGNvdW50ZXIgdG8gZGVyaXZlIHNlY3JldCBkZXRlcm1pbmlzdGljYWxseS4gQ2FzaHVXYWxsZXQgY2xhc3MgbXVzdCBiZSBpbml0aWFsaXplZCB3aXRoIHNlZWQgcGhyYXNlIHRvIHRha2UgZWZmZWN0XG4gICAqIEBwYXJhbSBrZXlrc2V0SWQ/IG92ZXJyaWRlIHRoZSBrZXlzZXRJZCBkZXJpdmVkIGZyb20gdGhlIGN1cnJlbnQgbWludEtleXMgd2l0aCBhIGN1c3RvbSBvbmUuIFRoaXMgc2hvdWxkIGJlIGEga2V5c2V0IHRoYXQgd2FzIGZldGNoZWQgZnJvbSB0aGUgYC9rZXlzZXRzYCBlbmRwb2ludFxuICAgKiBAcGFyYW0gcHVia2V5PyBvcHRpb25hbGx5IGxvY2tzIGVjYXNoIHRvIHB1YmtleS4gV2lsbCBub3QgYmUgZGV0ZXJtaW5pc3RpYywgZXZlbiBpZiBjb3VudGVyIGlzIHNldCFcbiAgICogQHJldHVybnMgYmxpbmRlZCBtZXNzYWdlcywgc2VjcmV0cywgcnMsIGFuZCBhbW91bnRzXG4gICAqL1xuICBjcmVhdGVPdXRwdXREYXRhKHQsIGUsIG4sIHIsIG8sIGksIGMpIHtcbiAgICBsZXQgYTtcbiAgICBpZiAocilcbiAgICAgIGEgPSBxLmNyZWF0ZVAyUEtEYXRhKHsgcHVia2V5OiByIH0sIHQsIGUsIG8pO1xuICAgIGVsc2UgaWYgKG4gfHwgbiA9PT0gMCkge1xuICAgICAgaWYgKCF0aGlzLl9zZWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgY3JlYXRlIGRldGVybWluaXN0aWMgbWVzc2FnZXMgd2l0aG91dCBzZWVkXCIpO1xuICAgICAgYSA9IHEuY3JlYXRlRGV0ZXJtaW5pc3RpY0RhdGEoXG4gICAgICAgIHQsXG4gICAgICAgIHRoaXMuX3NlZWQsXG4gICAgICAgIG4sXG4gICAgICAgIGUsXG4gICAgICAgIG9cbiAgICAgICk7XG4gICAgfSBlbHNlIGkgPyBhID0gcS5jcmVhdGVQMlBLRGF0YShpLCB0LCBlLCBvKSA6IGMgPyBhID0gUyh0LCBlLmtleXMpLm1hcCgoZCkgPT4gYyhkLCBlKSkgOiBhID0gcS5jcmVhdGVSYW5kb21EYXRhKHQsIGUsIG8pO1xuICAgIHJldHVybiBhO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIE5VVC0wOCBibGFuayBvdXRwdXRzIChmZWUgcmV0dXJucykgZm9yIGEgZ2l2ZW4gZmVlIHJlc2VydmVcbiAgICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vY2FzaHVidGMvbnV0cy9ibG9iL21haW4vMDgubWRcbiAgICogQHBhcmFtIGFtb3VudCBhbW91bnQgdG8gY292ZXIgd2l0aCBibGFuayBvdXRwdXRzXG4gICAqIEBwYXJhbSBrZXlzZXRJZCBtaW50IGtleXNldElkXG4gICAqIEBwYXJhbSBjb3VudGVyPyBvcHRpb25hbGx5IHNldCBjb3VudGVyIHRvIGRlcml2ZSBzZWNyZXQgZGV0ZXJtaW5pc3RpY2FsbHkuIENhc2h1V2FsbGV0IGNsYXNzIG11c3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBzZWVkIHBocmFzZSB0byB0YWtlIGVmZmVjdFxuICAgKiBAcmV0dXJucyBibGluZGVkIG1lc3NhZ2VzLCBzZWNyZXRzLCBhbmQgcnNcbiAgICovXG4gIGNyZWF0ZUJsYW5rT3V0cHV0cyh0LCBlLCBuLCByKSB7XG4gICAgbGV0IG8gPSBNYXRoLmNlaWwoTWF0aC5sb2cyKHQpKSB8fCAxO1xuICAgIG8gPCAwICYmIChvID0gMCk7XG4gICAgY29uc3QgaSA9IG8gPyBBcnJheShvKS5maWxsKDEpIDogW107XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlT3V0cHV0RGF0YSh0LCBlLCBuLCB2b2lkIDAsIGksIHZvaWQgMCwgcik7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFAgYXMgQ2FzaHVNaW50LFxuICBCZSBhcyBDYXNodVdhbGxldCxcbiAgbGUgYXMgQ2hlY2tTdGF0ZUVudW0sXG4gIFIgYXMgSHR0cFJlc3BvbnNlRXJyb3IsXG4gIE4gYXMgTWVsdFF1b3RlU3RhdGUsXG4gIHN0IGFzIE1pbnRPcGVyYXRpb25FcnJvcixcbiAgaiBhcyBNaW50UXVvdGVTdGF0ZSxcbiAgZXQgYXMgTmV0d29ya0Vycm9yLFxuICBxIGFzIE91dHB1dERhdGEsXG4gIFogYXMgUGF5bWVudFJlcXVlc3QsXG4gIGZlIGFzIFBheW1lbnRSZXF1ZXN0VHJhbnNwb3J0VHlwZSxcbiAgRGUgYXMgZGVjb2RlUGF5bWVudFJlcXVlc3QsXG4gIFVlIGFzIGRlcml2ZUtleXNldElkLFxuICBzZSBhcyBnZXREZWNvZGVkVG9rZW4sXG4gIHhlIGFzIGdldERlY29kZWRUb2tlbkJpbmFyeSxcbiAgVGUgYXMgZ2V0RW5jb2RlZFRva2VuLFxuICBPZSBhcyBnZXRFbmNvZGVkVG9rZW5CaW5hcnksXG4gIGVlIGFzIGdldEVuY29kZWRUb2tlblY0LFxuICBhZSBhcyBoYXNWYWxpZERsZXEsXG4gIEZlIGFzIGluamVjdFdlYlNvY2tldEltcGwsXG4gIE5lIGFzIHNldEdsb2JhbFJlcXVlc3RPcHRpb25zXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FzaHUtdHMuZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cashu/cashu-ts/lib/cashu-ts.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cashu/crypto/modules/esm/client/NUT09.js":
/*!****************************************************************!*\
  !*** ./node_modules/@cashu/crypto/modules/esm/client/NUT09.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deriveSeedFromMnemonic = exports.generateNewMnemonic = exports.deriveBlindingFactor = exports.deriveSecret = void 0;\nconst bip32_1 = __webpack_require__(/*! @scure/bip32 */ \"(ssr)/./node_modules/@cashu/crypto/node_modules/@scure/bip32/lib/index.js\");\nconst index_js_1 = __webpack_require__(/*! ../common/index.js */ \"(ssr)/./node_modules/@cashu/crypto/modules/esm/common/index.js\");\nconst bip39_1 = __webpack_require__(/*! @scure/bip39 */ \"(ssr)/./node_modules/@cashu/crypto/node_modules/@scure/bip39/index.js\");\nconst english_1 = __webpack_require__(/*! @scure/bip39/wordlists/english */ \"(ssr)/./node_modules/@cashu/crypto/node_modules/@scure/bip39/wordlists/english.js\");\nconst STANDARD_DERIVATION_PATH = `m/129372'/0'`;\nvar DerivationType;\n(function (DerivationType) {\n    DerivationType[DerivationType[\"SECRET\"] = 0] = \"SECRET\";\n    DerivationType[DerivationType[\"BLINDING_FACTOR\"] = 1] = \"BLINDING_FACTOR\";\n})(DerivationType || (DerivationType = {}));\nconst deriveSecret = (seed, keysetId, counter) => {\n    return derive(seed, keysetId, counter, DerivationType.SECRET);\n};\nexports.deriveSecret = deriveSecret;\nconst deriveBlindingFactor = (seed, keysetId, counter) => {\n    return derive(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n};\nexports.deriveBlindingFactor = deriveBlindingFactor;\nconst derive = (seed, keysetId, counter, secretOrBlinding) => {\n    const hdkey = bip32_1.HDKey.fromMasterSeed(seed);\n    const keysetIdInt = (0, index_js_1.getKeysetIdInt)(keysetId);\n    const derivationPath = `${STANDARD_DERIVATION_PATH}/${keysetIdInt}'/${counter}'/${secretOrBlinding}`;\n    const derived = hdkey.derive(derivationPath);\n    if (derived.privateKey === null) {\n        throw new Error('Could not derive private key');\n    }\n    return derived.privateKey;\n};\nconst generateNewMnemonic = () => {\n    const mnemonic = (0, bip39_1.generateMnemonic)(english_1.wordlist, 128);\n    return mnemonic;\n};\nexports.generateNewMnemonic = generateNewMnemonic;\nconst deriveSeedFromMnemonic = (mnemonic) => {\n    const seed = (0, bip39_1.mnemonicToSeedSync)(mnemonic);\n    return seed;\n};\nexports.deriveSeedFromMnemonic = deriveSeedFromMnemonic;\n//# sourceMappingURL=NUT09.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhc2h1L2NyeXB0by9tb2R1bGVzL2VzbS9jbGllbnQvTlVUMDkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCLEdBQUcsMkJBQTJCLEdBQUcsNEJBQTRCLEdBQUcsb0JBQW9CO0FBQ2xILGdCQUFnQixtQkFBTyxDQUFDLCtGQUFjO0FBQ3RDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUFvQjtBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQywyRkFBYztBQUN0QyxrQkFBa0IsbUJBQU8sQ0FBQyx5SEFBZ0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QixHQUFHLFlBQVksSUFBSSxRQUFRLElBQUksaUJBQWlCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCIiwic291cmNlcyI6WyIvVXNlcnMvcGFibG9mZXJuYW5kZXovdGVzdDEyMy9URU5FWC1wZmttYzkvbWFpbi9ub2RlX21vZHVsZXMvQGNhc2h1L2NyeXB0by9tb2R1bGVzL2VzbS9jbGllbnQvTlVUMDkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlcml2ZVNlZWRGcm9tTW5lbW9uaWMgPSBleHBvcnRzLmdlbmVyYXRlTmV3TW5lbW9uaWMgPSBleHBvcnRzLmRlcml2ZUJsaW5kaW5nRmFjdG9yID0gZXhwb3J0cy5kZXJpdmVTZWNyZXQgPSB2b2lkIDA7XG5jb25zdCBiaXAzMl8xID0gcmVxdWlyZShcIkBzY3VyZS9iaXAzMlwiKTtcbmNvbnN0IGluZGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2luZGV4LmpzXCIpO1xuY29uc3QgYmlwMzlfMSA9IHJlcXVpcmUoXCJAc2N1cmUvYmlwMzlcIik7XG5jb25zdCBlbmdsaXNoXzEgPSByZXF1aXJlKFwiQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9lbmdsaXNoXCIpO1xuY29uc3QgU1RBTkRBUkRfREVSSVZBVElPTl9QQVRIID0gYG0vMTI5MzcyJy8wJ2A7XG52YXIgRGVyaXZhdGlvblR5cGU7XG4oZnVuY3Rpb24gKERlcml2YXRpb25UeXBlKSB7XG4gICAgRGVyaXZhdGlvblR5cGVbRGVyaXZhdGlvblR5cGVbXCJTRUNSRVRcIl0gPSAwXSA9IFwiU0VDUkVUXCI7XG4gICAgRGVyaXZhdGlvblR5cGVbRGVyaXZhdGlvblR5cGVbXCJCTElORElOR19GQUNUT1JcIl0gPSAxXSA9IFwiQkxJTkRJTkdfRkFDVE9SXCI7XG59KShEZXJpdmF0aW9uVHlwZSB8fCAoRGVyaXZhdGlvblR5cGUgPSB7fSkpO1xuY29uc3QgZGVyaXZlU2VjcmV0ID0gKHNlZWQsIGtleXNldElkLCBjb3VudGVyKSA9PiB7XG4gICAgcmV0dXJuIGRlcml2ZShzZWVkLCBrZXlzZXRJZCwgY291bnRlciwgRGVyaXZhdGlvblR5cGUuU0VDUkVUKTtcbn07XG5leHBvcnRzLmRlcml2ZVNlY3JldCA9IGRlcml2ZVNlY3JldDtcbmNvbnN0IGRlcml2ZUJsaW5kaW5nRmFjdG9yID0gKHNlZWQsIGtleXNldElkLCBjb3VudGVyKSA9PiB7XG4gICAgcmV0dXJuIGRlcml2ZShzZWVkLCBrZXlzZXRJZCwgY291bnRlciwgRGVyaXZhdGlvblR5cGUuQkxJTkRJTkdfRkFDVE9SKTtcbn07XG5leHBvcnRzLmRlcml2ZUJsaW5kaW5nRmFjdG9yID0gZGVyaXZlQmxpbmRpbmdGYWN0b3I7XG5jb25zdCBkZXJpdmUgPSAoc2VlZCwga2V5c2V0SWQsIGNvdW50ZXIsIHNlY3JldE9yQmxpbmRpbmcpID0+IHtcbiAgICBjb25zdCBoZGtleSA9IGJpcDMyXzEuSERLZXkuZnJvbU1hc3RlclNlZWQoc2VlZCk7XG4gICAgY29uc3Qga2V5c2V0SWRJbnQgPSAoMCwgaW5kZXhfanNfMS5nZXRLZXlzZXRJZEludCkoa2V5c2V0SWQpO1xuICAgIGNvbnN0IGRlcml2YXRpb25QYXRoID0gYCR7U1RBTkRBUkRfREVSSVZBVElPTl9QQVRIfS8ke2tleXNldElkSW50fScvJHtjb3VudGVyfScvJHtzZWNyZXRPckJsaW5kaW5nfWA7XG4gICAgY29uc3QgZGVyaXZlZCA9IGhka2V5LmRlcml2ZShkZXJpdmF0aW9uUGF0aCk7XG4gICAgaWYgKGRlcml2ZWQucHJpdmF0ZUtleSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXJpdmUgcHJpdmF0ZSBrZXknKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcml2ZWQucHJpdmF0ZUtleTtcbn07XG5jb25zdCBnZW5lcmF0ZU5ld01uZW1vbmljID0gKCkgPT4ge1xuICAgIGNvbnN0IG1uZW1vbmljID0gKDAsIGJpcDM5XzEuZ2VuZXJhdGVNbmVtb25pYykoZW5nbGlzaF8xLndvcmRsaXN0LCAxMjgpO1xuICAgIHJldHVybiBtbmVtb25pYztcbn07XG5leHBvcnRzLmdlbmVyYXRlTmV3TW5lbW9uaWMgPSBnZW5lcmF0ZU5ld01uZW1vbmljO1xuY29uc3QgZGVyaXZlU2VlZEZyb21NbmVtb25pYyA9IChtbmVtb25pYykgPT4ge1xuICAgIGNvbnN0IHNlZWQgPSAoMCwgYmlwMzlfMS5tbmVtb25pY1RvU2VlZFN5bmMpKG1uZW1vbmljKTtcbiAgICByZXR1cm4gc2VlZDtcbn07XG5leHBvcnRzLmRlcml2ZVNlZWRGcm9tTW5lbW9uaWMgPSBkZXJpdmVTZWVkRnJvbU1uZW1vbmljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TlVUMDkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cashu/crypto/modules/esm/client/NUT09.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cashu/crypto/modules/esm/client/NUT11.js":
/*!****************************************************************!*\
  !*** ./node_modules/@cashu/crypto/modules/esm/client/NUT11.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getSignedProof = exports.getSignedOutputs = exports.getSignedOutput = exports.getSignedProofs = exports.signBlindedMessage = exports.signP2PKsecret = exports.createP2PKsecret = void 0;\nconst utils_1 = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/abstract/utils.js\");\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/sha256.js\");\nconst secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/secp256k1.js\");\nconst utils_2 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nconst NUT11_js_1 = __webpack_require__(/*! ../common/NUT11.js */ \"(ssr)/./node_modules/@cashu/crypto/modules/esm/common/NUT11.js\");\nconst createP2PKsecret = (pubkey) => {\n    const newSecret = [\n        'P2PK',\n        {\n            nonce: (0, utils_1.bytesToHex)((0, utils_2.randomBytes)(32)),\n            data: pubkey\n        }\n    ];\n    const parsed = JSON.stringify(newSecret);\n    return new TextEncoder().encode(parsed);\n};\nexports.createP2PKsecret = createP2PKsecret;\nconst signP2PKsecret = (secret, privateKey) => {\n    const msghash = (0, sha256_1.sha256)(new TextDecoder().decode(secret));\n    const sig = secp256k1_1.schnorr.sign(msghash, privateKey);\n    return sig;\n};\nexports.signP2PKsecret = signP2PKsecret;\nconst signBlindedMessage = (B_, privateKey) => {\n    const msgHash = (0, sha256_1.sha256)(B_);\n    const sig = secp256k1_1.schnorr.sign(msgHash, privateKey);\n    return sig;\n};\nexports.signBlindedMessage = signBlindedMessage;\nconst getSignedProofs = (proofs, privateKey) => {\n    return proofs.map((p) => {\n        try {\n            const parsed = (0, NUT11_js_1.parseSecret)(p.secret);\n            if (parsed[0] !== 'P2PK') {\n                throw new Error('unknown secret type');\n            }\n            return (0, exports.getSignedProof)(p, (0, utils_1.hexToBytes)(privateKey));\n        }\n        catch (error) {\n            return p;\n        }\n    });\n};\nexports.getSignedProofs = getSignedProofs;\nconst getSignedOutput = (output, privateKey) => {\n    const B_ = output.B_.toHex(true);\n    const signature = (0, exports.signBlindedMessage)(B_, privateKey);\n    output.witness = { signatures: [(0, utils_1.bytesToHex)(signature)] };\n    return output;\n};\nexports.getSignedOutput = getSignedOutput;\nconst getSignedOutputs = (outputs, privateKey) => {\n    return outputs.map((o) => (0, exports.getSignedOutput)(o, privateKey));\n};\nexports.getSignedOutputs = getSignedOutputs;\nconst getSignedProof = (proof, privateKey) => {\n    if (!proof.witness) {\n        proof.witness = {\n            signatures: [(0, utils_1.bytesToHex)((0, exports.signP2PKsecret)(proof.secret, privateKey))]\n        };\n    }\n    return proof;\n};\nexports.getSignedProof = getSignedProof;\n//# sourceMappingURL=NUT11.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhc2h1L2NyeXB0by9tb2R1bGVzL2VzbS9jbGllbnQvTlVUMTEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsMEJBQTBCLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCO0FBQ3RMLGdCQUFnQixtQkFBTyxDQUFDLDBGQUE4QjtBQUN0RCxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBc0I7QUFDL0Msb0JBQW9CLG1CQUFPLENBQUMsZ0ZBQXlCO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLHdFQUFxQjtBQUM3QyxtQkFBbUIsbUJBQU8sQ0FBQywwRkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyIvVXNlcnMvcGFibG9mZXJuYW5kZXovdGVzdDEyMy9URU5FWC1wZmttYzkvbWFpbi9ub2RlX21vZHVsZXMvQGNhc2h1L2NyeXB0by9tb2R1bGVzL2VzbS9jbGllbnQvTlVUMTEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFNpZ25lZFByb29mID0gZXhwb3J0cy5nZXRTaWduZWRPdXRwdXRzID0gZXhwb3J0cy5nZXRTaWduZWRPdXRwdXQgPSBleHBvcnRzLmdldFNpZ25lZFByb29mcyA9IGV4cG9ydHMuc2lnbkJsaW5kZWRNZXNzYWdlID0gZXhwb3J0cy5zaWduUDJQS3NlY3JldCA9IGV4cG9ydHMuY3JlYXRlUDJQS3NlY3JldCA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiKTtcbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCIpO1xuY29uc3Qgc2VjcDI1NmsxXzEgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIik7XG5jb25zdCB1dGlsc18yID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5jb25zdCBOVVQxMV9qc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9OVVQxMS5qc1wiKTtcbmNvbnN0IGNyZWF0ZVAyUEtzZWNyZXQgPSAocHVia2V5KSA9PiB7XG4gICAgY29uc3QgbmV3U2VjcmV0ID0gW1xuICAgICAgICAnUDJQSycsXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5vbmNlOiAoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KSgoMCwgdXRpbHNfMi5yYW5kb21CeXRlcykoMzIpKSxcbiAgICAgICAgICAgIGRhdGE6IHB1YmtleVxuICAgICAgICB9XG4gICAgXTtcbiAgICBjb25zdCBwYXJzZWQgPSBKU09OLnN0cmluZ2lmeShuZXdTZWNyZXQpO1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocGFyc2VkKTtcbn07XG5leHBvcnRzLmNyZWF0ZVAyUEtzZWNyZXQgPSBjcmVhdGVQMlBLc2VjcmV0O1xuY29uc3Qgc2lnblAyUEtzZWNyZXQgPSAoc2VjcmV0LCBwcml2YXRlS2V5KSA9PiB7XG4gICAgY29uc3QgbXNnaGFzaCA9ICgwLCBzaGEyNTZfMS5zaGEyNTYpKG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShzZWNyZXQpKTtcbiAgICBjb25zdCBzaWcgPSBzZWNwMjU2azFfMS5zY2hub3JyLnNpZ24obXNnaGFzaCwgcHJpdmF0ZUtleSk7XG4gICAgcmV0dXJuIHNpZztcbn07XG5leHBvcnRzLnNpZ25QMlBLc2VjcmV0ID0gc2lnblAyUEtzZWNyZXQ7XG5jb25zdCBzaWduQmxpbmRlZE1lc3NhZ2UgPSAoQl8sIHByaXZhdGVLZXkpID0+IHtcbiAgICBjb25zdCBtc2dIYXNoID0gKDAsIHNoYTI1Nl8xLnNoYTI1NikoQl8pO1xuICAgIGNvbnN0IHNpZyA9IHNlY3AyNTZrMV8xLnNjaG5vcnIuc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KTtcbiAgICByZXR1cm4gc2lnO1xufTtcbmV4cG9ydHMuc2lnbkJsaW5kZWRNZXNzYWdlID0gc2lnbkJsaW5kZWRNZXNzYWdlO1xuY29uc3QgZ2V0U2lnbmVkUHJvb2ZzID0gKHByb29mcywgcHJpdmF0ZUtleSkgPT4ge1xuICAgIHJldHVybiBwcm9vZnMubWFwKChwKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSAoMCwgTlVUMTFfanNfMS5wYXJzZVNlY3JldCkocC5zZWNyZXQpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZFswXSAhPT0gJ1AyUEsnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHNlY3JldCB0eXBlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuZ2V0U2lnbmVkUHJvb2YpKHAsICgwLCB1dGlsc18xLmhleFRvQnl0ZXMpKHByaXZhdGVLZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuZXhwb3J0cy5nZXRTaWduZWRQcm9vZnMgPSBnZXRTaWduZWRQcm9vZnM7XG5jb25zdCBnZXRTaWduZWRPdXRwdXQgPSAob3V0cHV0LCBwcml2YXRlS2V5KSA9PiB7XG4gICAgY29uc3QgQl8gPSBvdXRwdXQuQl8udG9IZXgodHJ1ZSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gKDAsIGV4cG9ydHMuc2lnbkJsaW5kZWRNZXNzYWdlKShCXywgcHJpdmF0ZUtleSk7XG4gICAgb3V0cHV0LndpdG5lc3MgPSB7IHNpZ25hdHVyZXM6IFsoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KShzaWduYXR1cmUpXSB9O1xuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuZXhwb3J0cy5nZXRTaWduZWRPdXRwdXQgPSBnZXRTaWduZWRPdXRwdXQ7XG5jb25zdCBnZXRTaWduZWRPdXRwdXRzID0gKG91dHB1dHMsIHByaXZhdGVLZXkpID0+IHtcbiAgICByZXR1cm4gb3V0cHV0cy5tYXAoKG8pID0+ICgwLCBleHBvcnRzLmdldFNpZ25lZE91dHB1dCkobywgcHJpdmF0ZUtleSkpO1xufTtcbmV4cG9ydHMuZ2V0U2lnbmVkT3V0cHV0cyA9IGdldFNpZ25lZE91dHB1dHM7XG5jb25zdCBnZXRTaWduZWRQcm9vZiA9IChwcm9vZiwgcHJpdmF0ZUtleSkgPT4ge1xuICAgIGlmICghcHJvb2Yud2l0bmVzcykge1xuICAgICAgICBwcm9vZi53aXRuZXNzID0ge1xuICAgICAgICAgICAgc2lnbmF0dXJlczogWygwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKCgwLCBleHBvcnRzLnNpZ25QMlBLc2VjcmV0KShwcm9vZi5zZWNyZXQsIHByaXZhdGVLZXkpKV1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHByb29mO1xufTtcbmV4cG9ydHMuZ2V0U2lnbmVkUHJvb2YgPSBnZXRTaWduZWRQcm9vZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5VVDExLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cashu/crypto/modules/esm/client/NUT11.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cashu/crypto/modules/esm/client/NUT12.js":
/*!****************************************************************!*\
  !*** ./node_modules/@cashu/crypto/modules/esm/client/NUT12.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.verifyDLEQProof_reblind = exports.verifyDLEQProof = void 0;\nconst index_js_1 = __webpack_require__(/*! ../common/index.js */ \"(ssr)/./node_modules/@cashu/crypto/modules/esm/common/index.js\");\nconst utils_1 = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/abstract/utils.js\");\nconst secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/secp256k1.js\");\nconst utils_js_1 = __webpack_require__(/*! ../util/utils.js */ \"(ssr)/./node_modules/@cashu/crypto/modules/esm/util/utils.js\");\nfunction arraysEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length)\n        return false;\n    for (let i = 0; i < arr1.length; i++) {\n        if (arr1[i] !== arr2[i])\n            return false;\n    }\n    return true;\n}\nconst verifyDLEQProof = (dleq, B_, C_, A) => {\n    const sG = secp256k1_1.secp256k1.ProjectivePoint.fromPrivateKey((0, utils_1.bytesToHex)(dleq.s));\n    const eA = A.multiply((0, utils_js_1.bytesToNumber)(dleq.e));\n    const sB_ = B_.multiply((0, utils_js_1.bytesToNumber)(dleq.s));\n    const eC_ = C_.multiply((0, utils_js_1.bytesToNumber)(dleq.e));\n    const R_1 = sG.subtract(eA); // R1 = sG - eA\n    const R_2 = sB_.subtract(eC_); // R2 = sB' - eC'\n    const hash = (0, index_js_1.hash_e)([R_1, R_2, A, C_]); // e == hash(R1, R2, A, C')\n    return arraysEqual(hash, dleq.e);\n};\nexports.verifyDLEQProof = verifyDLEQProof;\nconst verifyDLEQProof_reblind = (secret, // secret\ndleq, C, // unblinded e-cash signature point\nA // mint public key point\n) => {\n    if (dleq.r === undefined)\n        throw new Error('verifyDLEQProof_reblind: Undefined blinding factor');\n    const Y = (0, index_js_1.hashToCurve)(secret);\n    const C_ = C.add(A.multiply(dleq.r)); // Re-blind the e-cash signature\n    const bG = secp256k1_1.secp256k1.ProjectivePoint.fromPrivateKey(dleq.r);\n    const B_ = Y.add(bG); // Re-blind the message\n    return (0, exports.verifyDLEQProof)(dleq, B_, C_, A);\n};\nexports.verifyDLEQProof_reblind = verifyDLEQProof_reblind;\n//# sourceMappingURL=NUT12.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhc2h1L2NyeXB0by9tb2R1bGVzL2VzbS9jbGllbnQvTlVUMTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCLEdBQUcsdUJBQXVCO0FBQ3pELG1CQUFtQixtQkFBTyxDQUFDLDBGQUFvQjtBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBOEI7QUFDdEQsb0JBQW9CLG1CQUFPLENBQUMsZ0ZBQXlCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLHNGQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLG1DQUFtQztBQUNuQyw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CIiwic291cmNlcyI6WyIvVXNlcnMvcGFibG9mZXJuYW5kZXovdGVzdDEyMy9URU5FWC1wZmttYzkvbWFpbi9ub2RlX21vZHVsZXMvQGNhc2h1L2NyeXB0by9tb2R1bGVzL2VzbS9jbGllbnQvTlVUMTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcmlmeURMRVFQcm9vZl9yZWJsaW5kID0gZXhwb3J0cy52ZXJpZnlETEVRUHJvb2YgPSB2b2lkIDA7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9pbmRleC5qc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiKTtcbmNvbnN0IHNlY3AyNTZrMV8xID0gcmVxdWlyZShcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL3V0aWxzLmpzXCIpO1xuZnVuY3Rpb24gYXJyYXlzRXF1YWwoYXJyMSwgYXJyMikge1xuICAgIGlmIChhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycjEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3QgdmVyaWZ5RExFUVByb29mID0gKGRsZXEsIEJfLCBDXywgQSkgPT4ge1xuICAgIGNvbnN0IHNHID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5mcm9tUHJpdmF0ZUtleSgoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KShkbGVxLnMpKTtcbiAgICBjb25zdCBlQSA9IEEubXVsdGlwbHkoKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlcikoZGxlcS5lKSk7XG4gICAgY29uc3Qgc0JfID0gQl8ubXVsdGlwbHkoKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlcikoZGxlcS5zKSk7XG4gICAgY29uc3QgZUNfID0gQ18ubXVsdGlwbHkoKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlcikoZGxlcS5lKSk7XG4gICAgY29uc3QgUl8xID0gc0cuc3VidHJhY3QoZUEpOyAvLyBSMSA9IHNHIC0gZUFcbiAgICBjb25zdCBSXzIgPSBzQl8uc3VidHJhY3QoZUNfKTsgLy8gUjIgPSBzQicgLSBlQydcbiAgICBjb25zdCBoYXNoID0gKDAsIGluZGV4X2pzXzEuaGFzaF9lKShbUl8xLCBSXzIsIEEsIENfXSk7IC8vIGUgPT0gaGFzaChSMSwgUjIsIEEsIEMnKVxuICAgIHJldHVybiBhcnJheXNFcXVhbChoYXNoLCBkbGVxLmUpO1xufTtcbmV4cG9ydHMudmVyaWZ5RExFUVByb29mID0gdmVyaWZ5RExFUVByb29mO1xuY29uc3QgdmVyaWZ5RExFUVByb29mX3JlYmxpbmQgPSAoc2VjcmV0LCAvLyBzZWNyZXRcbmRsZXEsIEMsIC8vIHVuYmxpbmRlZCBlLWNhc2ggc2lnbmF0dXJlIHBvaW50XG5BIC8vIG1pbnQgcHVibGljIGtleSBwb2ludFxuKSA9PiB7XG4gICAgaWYgKGRsZXEuciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlcmlmeURMRVFQcm9vZl9yZWJsaW5kOiBVbmRlZmluZWQgYmxpbmRpbmcgZmFjdG9yJyk7XG4gICAgY29uc3QgWSA9ICgwLCBpbmRleF9qc18xLmhhc2hUb0N1cnZlKShzZWNyZXQpO1xuICAgIGNvbnN0IENfID0gQy5hZGQoQS5tdWx0aXBseShkbGVxLnIpKTsgLy8gUmUtYmxpbmQgdGhlIGUtY2FzaCBzaWduYXR1cmVcbiAgICBjb25zdCBiRyA9IHNlY3AyNTZrMV8xLnNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbVByaXZhdGVLZXkoZGxlcS5yKTtcbiAgICBjb25zdCBCXyA9IFkuYWRkKGJHKTsgLy8gUmUtYmxpbmQgdGhlIG1lc3NhZ2VcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMudmVyaWZ5RExFUVByb29mKShkbGVxLCBCXywgQ18sIEEpO1xufTtcbmV4cG9ydHMudmVyaWZ5RExFUVByb29mX3JlYmxpbmQgPSB2ZXJpZnlETEVRUHJvb2ZfcmVibGluZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5VVDEyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cashu/crypto/modules/esm/client/NUT12.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cashu/crypto/modules/esm/client/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@cashu/crypto/modules/esm/client/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeBlindedMessage = exports.deserializeProof = exports.serializeProof = exports.constructProofFromPromise = exports.unblindSignature = exports.blindMessage = exports.createRandomBlindedMessage = void 0;\nconst secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/secp256k1.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nconst utils_js_1 = __webpack_require__(/*! ../util/utils.js */ \"(ssr)/./node_modules/@cashu/crypto/modules/esm/util/utils.js\");\nconst index_js_1 = __webpack_require__(/*! ../common/index.js */ \"(ssr)/./node_modules/@cashu/crypto/modules/esm/common/index.js\");\nconst NUT11_js_1 = __webpack_require__(/*! ./NUT11.js */ \"(ssr)/./node_modules/@cashu/crypto/modules/esm/client/NUT11.js\");\nfunction createRandomBlindedMessage(privateKey) {\n    return blindMessage((0, utils_1.randomBytes)(32), (0, utils_js_1.bytesToNumber)(secp256k1_1.secp256k1.utils.randomPrivateKey()), privateKey);\n}\nexports.createRandomBlindedMessage = createRandomBlindedMessage;\nfunction blindMessage(secret, r, privateKey) {\n    const Y = (0, index_js_1.hashToCurve)(secret);\n    if (!r) {\n        r = (0, utils_js_1.bytesToNumber)(secp256k1_1.secp256k1.utils.randomPrivateKey());\n    }\n    const rG = secp256k1_1.secp256k1.ProjectivePoint.BASE.multiply(r);\n    const B_ = Y.add(rG);\n    if (privateKey !== undefined) {\n        return (0, NUT11_js_1.getSignedOutput)({ B_, r, secret }, privateKey);\n    }\n    return { B_, r, secret };\n}\nexports.blindMessage = blindMessage;\nfunction unblindSignature(C_, r, A) {\n    const C = C_.subtract(A.multiply(r));\n    return C;\n}\nexports.unblindSignature = unblindSignature;\nfunction constructProofFromPromise(promise, r, secret, key) {\n    const A = key;\n    const C = unblindSignature(promise.C_, r, A);\n    const proof = {\n        id: promise.id,\n        amount: promise.amount,\n        secret,\n        C\n    };\n    return proof;\n}\nexports.constructProofFromPromise = constructProofFromPromise;\nconst serializeProof = (proof) => {\n    return {\n        amount: proof.amount,\n        C: proof.C.toHex(true),\n        id: proof.id,\n        secret: new TextDecoder().decode(proof.secret),\n        witness: JSON.stringify(proof.witness)\n    };\n};\nexports.serializeProof = serializeProof;\nconst deserializeProof = (proof) => {\n    return {\n        amount: proof.amount,\n        C: (0, index_js_1.pointFromHex)(proof.C),\n        id: proof.id,\n        secret: new TextEncoder().encode(proof.secret),\n        witness: proof.witness ? JSON.parse(proof.witness) : undefined\n    };\n};\nexports.deserializeProof = deserializeProof;\nconst serializeBlindedMessage = (bm, amount) => {\n    return {\n        B_: bm.B_.toHex(true),\n        amount: amount\n    };\n};\nexports.serializeBlindedMessage = serializeBlindedMessage;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhc2h1L2NyeXB0by9tb2R1bGVzL2VzbS9jbGllbnQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCLEdBQUcsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcsaUNBQWlDLEdBQUcsd0JBQXdCLEdBQUcsb0JBQW9CLEdBQUcsa0NBQWtDO0FBQzlNLG9CQUFvQixtQkFBTyxDQUFDLGdGQUF5QjtBQUNyRCxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBcUI7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsc0ZBQWtCO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUFvQjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxlQUFlO0FBQ2hFO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYWJsb2Zlcm5hbmRlei90ZXN0MTIzL1RFTkVYLXBma21jOS9tYWluL25vZGVfbW9kdWxlcy9AY2FzaHUvY3J5cHRvL21vZHVsZXMvZXNtL2NsaWVudC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2VyaWFsaXplQmxpbmRlZE1lc3NhZ2UgPSBleHBvcnRzLmRlc2VyaWFsaXplUHJvb2YgPSBleHBvcnRzLnNlcmlhbGl6ZVByb29mID0gZXhwb3J0cy5jb25zdHJ1Y3RQcm9vZkZyb21Qcm9taXNlID0gZXhwb3J0cy51bmJsaW5kU2lnbmF0dXJlID0gZXhwb3J0cy5ibGluZE1lc3NhZ2UgPSBleHBvcnRzLmNyZWF0ZVJhbmRvbUJsaW5kZWRNZXNzYWdlID0gdm9pZCAwO1xuY29uc3Qgc2VjcDI1NmsxXzEgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4uL3V0aWwvdXRpbHMuanNcIik7XG5jb25zdCBpbmRleF9qc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9pbmRleC5qc1wiKTtcbmNvbnN0IE5VVDExX2pzXzEgPSByZXF1aXJlKFwiLi9OVVQxMS5qc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVJhbmRvbUJsaW5kZWRNZXNzYWdlKHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gYmxpbmRNZXNzYWdlKCgwLCB1dGlsc18xLnJhbmRvbUJ5dGVzKSgzMiksICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXIpKHNlY3AyNTZrMV8xLnNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCkpLCBwcml2YXRlS2V5KTtcbn1cbmV4cG9ydHMuY3JlYXRlUmFuZG9tQmxpbmRlZE1lc3NhZ2UgPSBjcmVhdGVSYW5kb21CbGluZGVkTWVzc2FnZTtcbmZ1bmN0aW9uIGJsaW5kTWVzc2FnZShzZWNyZXQsIHIsIHByaXZhdGVLZXkpIHtcbiAgICBjb25zdCBZID0gKDAsIGluZGV4X2pzXzEuaGFzaFRvQ3VydmUpKHNlY3JldCk7XG4gICAgaWYgKCFyKSB7XG4gICAgICAgIHIgPSAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyKShzZWNwMjU2azFfMS5zZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpKTtcbiAgICB9XG4gICAgY29uc3QgckcgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LkJBU0UubXVsdGlwbHkocik7XG4gICAgY29uc3QgQl8gPSBZLmFkZChyRyk7XG4gICAgaWYgKHByaXZhdGVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gKDAsIE5VVDExX2pzXzEuZ2V0U2lnbmVkT3V0cHV0KSh7IEJfLCByLCBzZWNyZXQgfSwgcHJpdmF0ZUtleSk7XG4gICAgfVxuICAgIHJldHVybiB7IEJfLCByLCBzZWNyZXQgfTtcbn1cbmV4cG9ydHMuYmxpbmRNZXNzYWdlID0gYmxpbmRNZXNzYWdlO1xuZnVuY3Rpb24gdW5ibGluZFNpZ25hdHVyZShDXywgciwgQSkge1xuICAgIGNvbnN0IEMgPSBDXy5zdWJ0cmFjdChBLm11bHRpcGx5KHIpKTtcbiAgICByZXR1cm4gQztcbn1cbmV4cG9ydHMudW5ibGluZFNpZ25hdHVyZSA9IHVuYmxpbmRTaWduYXR1cmU7XG5mdW5jdGlvbiBjb25zdHJ1Y3RQcm9vZkZyb21Qcm9taXNlKHByb21pc2UsIHIsIHNlY3JldCwga2V5KSB7XG4gICAgY29uc3QgQSA9IGtleTtcbiAgICBjb25zdCBDID0gdW5ibGluZFNpZ25hdHVyZShwcm9taXNlLkNfLCByLCBBKTtcbiAgICBjb25zdCBwcm9vZiA9IHtcbiAgICAgICAgaWQ6IHByb21pc2UuaWQsXG4gICAgICAgIGFtb3VudDogcHJvbWlzZS5hbW91bnQsXG4gICAgICAgIHNlY3JldCxcbiAgICAgICAgQ1xuICAgIH07XG4gICAgcmV0dXJuIHByb29mO1xufVxuZXhwb3J0cy5jb25zdHJ1Y3RQcm9vZkZyb21Qcm9taXNlID0gY29uc3RydWN0UHJvb2ZGcm9tUHJvbWlzZTtcbmNvbnN0IHNlcmlhbGl6ZVByb29mID0gKHByb29mKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYW1vdW50OiBwcm9vZi5hbW91bnQsXG4gICAgICAgIEM6IHByb29mLkMudG9IZXgodHJ1ZSksXG4gICAgICAgIGlkOiBwcm9vZi5pZCxcbiAgICAgICAgc2VjcmV0OiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUocHJvb2Yuc2VjcmV0KSxcbiAgICAgICAgd2l0bmVzczogSlNPTi5zdHJpbmdpZnkocHJvb2Yud2l0bmVzcylcbiAgICB9O1xufTtcbmV4cG9ydHMuc2VyaWFsaXplUHJvb2YgPSBzZXJpYWxpemVQcm9vZjtcbmNvbnN0IGRlc2VyaWFsaXplUHJvb2YgPSAocHJvb2YpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhbW91bnQ6IHByb29mLmFtb3VudCxcbiAgICAgICAgQzogKDAsIGluZGV4X2pzXzEucG9pbnRGcm9tSGV4KShwcm9vZi5DKSxcbiAgICAgICAgaWQ6IHByb29mLmlkLFxuICAgICAgICBzZWNyZXQ6IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShwcm9vZi5zZWNyZXQpLFxuICAgICAgICB3aXRuZXNzOiBwcm9vZi53aXRuZXNzID8gSlNPTi5wYXJzZShwcm9vZi53aXRuZXNzKSA6IHVuZGVmaW5lZFxuICAgIH07XG59O1xuZXhwb3J0cy5kZXNlcmlhbGl6ZVByb29mID0gZGVzZXJpYWxpemVQcm9vZjtcbmNvbnN0IHNlcmlhbGl6ZUJsaW5kZWRNZXNzYWdlID0gKGJtLCBhbW91bnQpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBCXzogYm0uQl8udG9IZXgodHJ1ZSksXG4gICAgICAgIGFtb3VudDogYW1vdW50XG4gICAgfTtcbn07XG5leHBvcnRzLnNlcmlhbGl6ZUJsaW5kZWRNZXNzYWdlID0gc2VyaWFsaXplQmxpbmRlZE1lc3NhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cashu/crypto/modules/esm/client/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cashu/crypto/modules/esm/common/NUT11.js":
/*!****************************************************************!*\
  !*** ./node_modules/@cashu/crypto/modules/esm/common/NUT11.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseSecret = void 0;\nconst parseSecret = (secret) => {\n    try {\n        if (secret instanceof Uint8Array) {\n            secret = new TextDecoder().decode(secret);\n        }\n        return JSON.parse(secret);\n    }\n    catch (e) {\n        throw new Error(\"can't parse secret\");\n    }\n};\nexports.parseSecret = parseSecret;\n//# sourceMappingURL=NUT11.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhc2h1L2NyeXB0by9tb2R1bGVzL2VzbS9jb21tb24vTlVUMTEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYWJsb2Zlcm5hbmRlei90ZXN0MTIzL1RFTkVYLXBma21jOS9tYWluL25vZGVfbW9kdWxlcy9AY2FzaHUvY3J5cHRvL21vZHVsZXMvZXNtL2NvbW1vbi9OVVQxMS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VTZWNyZXQgPSB2b2lkIDA7XG5jb25zdCBwYXJzZVNlY3JldCA9IChzZWNyZXQpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoc2VjcmV0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgc2VjcmV0ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHNlY3JldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc2VjcmV0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgcGFyc2Ugc2VjcmV0XCIpO1xuICAgIH1cbn07XG5leHBvcnRzLnBhcnNlU2VjcmV0ID0gcGFyc2VTZWNyZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OVVQxMS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cashu/crypto/modules/esm/common/NUT11.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cashu/crypto/modules/esm/common/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@cashu/crypto/modules/esm/common/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deriveKeysetId = exports.deserializeMintKeys = exports.serializeMintKeys = exports.createRandomPrivateKey = exports.getKeysetIdInt = exports.pointFromHex = exports.pointFromBytes = exports.hash_e = exports.hashToCurve = void 0;\nconst secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/secp256k1.js\");\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/sha256.js\");\nconst utils_1 = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/abstract/utils.js\");\nconst utils_js_1 = __webpack_require__(/*! ../util/utils.js */ \"(ssr)/./node_modules/@cashu/crypto/modules/esm/util/utils.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\nconst DOMAIN_SEPARATOR = (0, utils_1.hexToBytes)('536563703235366b315f48617368546f43757276655f43617368755f');\nfunction hashToCurve(secret) {\n    const msgToHash = (0, sha256_1.sha256)(buffer_1.Buffer.concat([DOMAIN_SEPARATOR, secret]));\n    const counter = new Uint32Array(1);\n    const maxIterations = 2 ** 16;\n    for (let i = 0; i < maxIterations; i++) {\n        const counterBytes = new Uint8Array(counter.buffer);\n        const hash = (0, sha256_1.sha256)(buffer_1.Buffer.concat([msgToHash, counterBytes]));\n        try {\n            return pointFromHex((0, utils_1.bytesToHex)(buffer_1.Buffer.concat([new Uint8Array([0x02]), hash])));\n        }\n        catch (error) {\n            counter[0]++;\n        }\n    }\n    throw new Error('No valid point found');\n}\nexports.hashToCurve = hashToCurve;\nfunction hash_e(pubkeys) {\n    const hexStrings = pubkeys.map((p) => p.toHex(false));\n    const e_ = hexStrings.join('');\n    const e = (0, sha256_1.sha256)(new TextEncoder().encode(e_));\n    return e;\n}\nexports.hash_e = hash_e;\nfunction pointFromBytes(bytes) {\n    return secp256k1_1.secp256k1.ProjectivePoint.fromHex((0, utils_1.bytesToHex)(bytes));\n}\nexports.pointFromBytes = pointFromBytes;\nfunction pointFromHex(hex) {\n    return secp256k1_1.secp256k1.ProjectivePoint.fromHex(hex);\n}\nexports.pointFromHex = pointFromHex;\nconst getKeysetIdInt = (keysetId) => {\n    let keysetIdInt;\n    if (/^[a-fA-F0-9]+$/.test(keysetId)) {\n        keysetIdInt = (0, utils_js_1.hexToNumber)(keysetId) % BigInt(2 ** 31 - 1);\n    }\n    else {\n        //legacy keyset compatibility\n        keysetIdInt = (0, utils_js_1.bytesToNumber)((0, utils_js_1.encodeBase64toUint8)(keysetId)) % BigInt(2 ** 31 - 1);\n    }\n    return keysetIdInt;\n};\nexports.getKeysetIdInt = getKeysetIdInt;\nfunction createRandomPrivateKey() {\n    return secp256k1_1.secp256k1.utils.randomPrivateKey();\n}\nexports.createRandomPrivateKey = createRandomPrivateKey;\nfunction serializeMintKeys(mintKeys) {\n    const serializedMintKeys = {};\n    Object.keys(mintKeys).forEach((p) => {\n        serializedMintKeys[p] = (0, utils_1.bytesToHex)(mintKeys[p]);\n    });\n    return serializedMintKeys;\n}\nexports.serializeMintKeys = serializeMintKeys;\nfunction deserializeMintKeys(serializedMintKeys) {\n    const mintKeys = {};\n    Object.keys(serializedMintKeys).forEach((p) => {\n        mintKeys[p] = (0, utils_1.hexToBytes)(serializedMintKeys[p]);\n    });\n    return mintKeys;\n}\nexports.deserializeMintKeys = deserializeMintKeys;\nfunction deriveKeysetId(keys) {\n    const KEYSET_VERSION = '00';\n    const mapBigInt = (k) => {\n        return [BigInt(k[0]), k[1]];\n    };\n    const pubkeysConcat = Object.entries(serializeMintKeys(keys))\n        .map(mapBigInt)\n        .sort((a, b) => (a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0))\n        .map(([, pubKey]) => (0, utils_1.hexToBytes)(pubKey))\n        .reduce((prev, curr) => mergeUInt8Arrays(prev, curr), new Uint8Array());\n    const hash = (0, sha256_1.sha256)(pubkeysConcat);\n    const hashHex = buffer_1.Buffer.from(hash).toString('hex').slice(0, 14);\n    return '00' + hashHex;\n}\nexports.deriveKeysetId = deriveKeysetId;\nfunction mergeUInt8Arrays(a1, a2) {\n    // sum of individual array lengths\n    const mergedArray = new Uint8Array(a1.length + a2.length);\n    mergedArray.set(a1);\n    mergedArray.set(a2, a1.length);\n    return mergedArray;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhc2h1L2NyeXB0by9tb2R1bGVzL2VzbS9jb21tb24vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsMkJBQTJCLEdBQUcseUJBQXlCLEdBQUcsOEJBQThCLEdBQUcsc0JBQXNCLEdBQUcsb0JBQW9CLEdBQUcsc0JBQXNCLEdBQUcsY0FBYyxHQUFHLG1CQUFtQjtBQUNqTyxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBeUI7QUFDckQsaUJBQWlCLG1CQUFPLENBQUMsMEVBQXNCO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLDBGQUE4QjtBQUN0RCxtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBa0I7QUFDN0MsaUJBQWlCLG1CQUFPLENBQUMscURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFibG9mZXJuYW5kZXovdGVzdDEyMy9URU5FWC1wZmttYzkvbWFpbi9ub2RlX21vZHVsZXMvQGNhc2h1L2NyeXB0by9tb2R1bGVzL2VzbS9jb21tb24vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlcml2ZUtleXNldElkID0gZXhwb3J0cy5kZXNlcmlhbGl6ZU1pbnRLZXlzID0gZXhwb3J0cy5zZXJpYWxpemVNaW50S2V5cyA9IGV4cG9ydHMuY3JlYXRlUmFuZG9tUHJpdmF0ZUtleSA9IGV4cG9ydHMuZ2V0S2V5c2V0SWRJbnQgPSBleHBvcnRzLnBvaW50RnJvbUhleCA9IGV4cG9ydHMucG9pbnRGcm9tQnl0ZXMgPSBleHBvcnRzLmhhc2hfZSA9IGV4cG9ydHMuaGFzaFRvQ3VydmUgPSB2b2lkIDA7XG5jb25zdCBzZWNwMjU2azFfMSA9IHJlcXVpcmUoXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiKTtcbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL3V0aWxzLmpzXCIpO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbmNvbnN0IERPTUFJTl9TRVBBUkFUT1IgPSAoMCwgdXRpbHNfMS5oZXhUb0J5dGVzKSgnNTM2NTYzNzAzMjM1MzY2YjMxNWY0ODYxNzM2ODU0NmY0Mzc1NzI3NjY1NWY0MzYxNzM2ODc1NWYnKTtcbmZ1bmN0aW9uIGhhc2hUb0N1cnZlKHNlY3JldCkge1xuICAgIGNvbnN0IG1zZ1RvSGFzaCA9ICgwLCBzaGEyNTZfMS5zaGEyNTYpKGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW0RPTUFJTl9TRVBBUkFUT1IsIHNlY3JldF0pKTtcbiAgICBjb25zdCBjb3VudGVyID0gbmV3IFVpbnQzMkFycmF5KDEpO1xuICAgIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSAyICoqIDE2O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4SXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXJCeXRlcyA9IG5ldyBVaW50OEFycmF5KGNvdW50ZXIuYnVmZmVyKTtcbiAgICAgICAgY29uc3QgaGFzaCA9ICgwLCBzaGEyNTZfMS5zaGEyNTYpKGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW21zZ1RvSGFzaCwgY291bnRlckJ5dGVzXSkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50RnJvbUhleCgoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KShidWZmZXJfMS5CdWZmZXIuY29uY2F0KFtuZXcgVWludDhBcnJheShbMHgwMl0pLCBoYXNoXSkpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvdW50ZXJbMF0rKztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIHBvaW50IGZvdW5kJyk7XG59XG5leHBvcnRzLmhhc2hUb0N1cnZlID0gaGFzaFRvQ3VydmU7XG5mdW5jdGlvbiBoYXNoX2UocHVia2V5cykge1xuICAgIGNvbnN0IGhleFN0cmluZ3MgPSBwdWJrZXlzLm1hcCgocCkgPT4gcC50b0hleChmYWxzZSkpO1xuICAgIGNvbnN0IGVfID0gaGV4U3RyaW5ncy5qb2luKCcnKTtcbiAgICBjb25zdCBlID0gKDAsIHNoYTI1Nl8xLnNoYTI1NikobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGVfKSk7XG4gICAgcmV0dXJuIGU7XG59XG5leHBvcnRzLmhhc2hfZSA9IGhhc2hfZTtcbmZ1bmN0aW9uIHBvaW50RnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgcmV0dXJuIHNlY3AyNTZrMV8xLnNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQuZnJvbUhleCgoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KShieXRlcykpO1xufVxuZXhwb3J0cy5wb2ludEZyb21CeXRlcyA9IHBvaW50RnJvbUJ5dGVzO1xuZnVuY3Rpb24gcG9pbnRGcm9tSGV4KGhleCkge1xuICAgIHJldHVybiBzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoaGV4KTtcbn1cbmV4cG9ydHMucG9pbnRGcm9tSGV4ID0gcG9pbnRGcm9tSGV4O1xuY29uc3QgZ2V0S2V5c2V0SWRJbnQgPSAoa2V5c2V0SWQpID0+IHtcbiAgICBsZXQga2V5c2V0SWRJbnQ7XG4gICAgaWYgKC9eW2EtZkEtRjAtOV0rJC8udGVzdChrZXlzZXRJZCkpIHtcbiAgICAgICAga2V5c2V0SWRJbnQgPSAoMCwgdXRpbHNfanNfMS5oZXhUb051bWJlcikoa2V5c2V0SWQpICUgQmlnSW50KDIgKiogMzEgLSAxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vbGVnYWN5IGtleXNldCBjb21wYXRpYmlsaXR5XG4gICAgICAgIGtleXNldElkSW50ID0gKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlcikoKDAsIHV0aWxzX2pzXzEuZW5jb2RlQmFzZTY0dG9VaW50OCkoa2V5c2V0SWQpKSAlIEJpZ0ludCgyICoqIDMxIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzZXRJZEludDtcbn07XG5leHBvcnRzLmdldEtleXNldElkSW50ID0gZ2V0S2V5c2V0SWRJbnQ7XG5mdW5jdGlvbiBjcmVhdGVSYW5kb21Qcml2YXRlS2V5KCkge1xuICAgIHJldHVybiBzZWNwMjU2azFfMS5zZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xufVxuZXhwb3J0cy5jcmVhdGVSYW5kb21Qcml2YXRlS2V5ID0gY3JlYXRlUmFuZG9tUHJpdmF0ZUtleTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZU1pbnRLZXlzKG1pbnRLZXlzKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZE1pbnRLZXlzID0ge307XG4gICAgT2JqZWN0LmtleXMobWludEtleXMpLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgc2VyaWFsaXplZE1pbnRLZXlzW3BdID0gKDAsIHV0aWxzXzEuYnl0ZXNUb0hleCkobWludEtleXNbcF0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzZXJpYWxpemVkTWludEtleXM7XG59XG5leHBvcnRzLnNlcmlhbGl6ZU1pbnRLZXlzID0gc2VyaWFsaXplTWludEtleXM7XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZU1pbnRLZXlzKHNlcmlhbGl6ZWRNaW50S2V5cykge1xuICAgIGNvbnN0IG1pbnRLZXlzID0ge307XG4gICAgT2JqZWN0LmtleXMoc2VyaWFsaXplZE1pbnRLZXlzKS5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgIG1pbnRLZXlzW3BdID0gKDAsIHV0aWxzXzEuaGV4VG9CeXRlcykoc2VyaWFsaXplZE1pbnRLZXlzW3BdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWludEtleXM7XG59XG5leHBvcnRzLmRlc2VyaWFsaXplTWludEtleXMgPSBkZXNlcmlhbGl6ZU1pbnRLZXlzO1xuZnVuY3Rpb24gZGVyaXZlS2V5c2V0SWQoa2V5cykge1xuICAgIGNvbnN0IEtFWVNFVF9WRVJTSU9OID0gJzAwJztcbiAgICBjb25zdCBtYXBCaWdJbnQgPSAoaykgPT4ge1xuICAgICAgICByZXR1cm4gW0JpZ0ludChrWzBdKSwga1sxXV07XG4gICAgfTtcbiAgICBjb25zdCBwdWJrZXlzQ29uY2F0ID0gT2JqZWN0LmVudHJpZXMoc2VyaWFsaXplTWludEtleXMoa2V5cykpXG4gICAgICAgIC5tYXAobWFwQmlnSW50KVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gKGFbMF0gPCBiWzBdID8gLTEgOiBhWzBdID4gYlswXSA/IDEgOiAwKSlcbiAgICAgICAgLm1hcCgoWywgcHViS2V5XSkgPT4gKDAsIHV0aWxzXzEuaGV4VG9CeXRlcykocHViS2V5KSlcbiAgICAgICAgLnJlZHVjZSgocHJldiwgY3VycikgPT4gbWVyZ2VVSW50OEFycmF5cyhwcmV2LCBjdXJyKSwgbmV3IFVpbnQ4QXJyYXkoKSk7XG4gICAgY29uc3QgaGFzaCA9ICgwLCBzaGEyNTZfMS5zaGEyNTYpKHB1YmtleXNDb25jYXQpO1xuICAgIGNvbnN0IGhhc2hIZXggPSBidWZmZXJfMS5CdWZmZXIuZnJvbShoYXNoKS50b1N0cmluZygnaGV4Jykuc2xpY2UoMCwgMTQpO1xuICAgIHJldHVybiAnMDAnICsgaGFzaEhleDtcbn1cbmV4cG9ydHMuZGVyaXZlS2V5c2V0SWQgPSBkZXJpdmVLZXlzZXRJZDtcbmZ1bmN0aW9uIG1lcmdlVUludDhBcnJheXMoYTEsIGEyKSB7XG4gICAgLy8gc3VtIG9mIGluZGl2aWR1YWwgYXJyYXkgbGVuZ3Roc1xuICAgIGNvbnN0IG1lcmdlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYTEubGVuZ3RoICsgYTIubGVuZ3RoKTtcbiAgICBtZXJnZWRBcnJheS5zZXQoYTEpO1xuICAgIG1lcmdlZEFycmF5LnNldChhMiwgYTEubGVuZ3RoKTtcbiAgICByZXR1cm4gbWVyZ2VkQXJyYXk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cashu/crypto/modules/esm/common/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cashu/crypto/modules/esm/util/utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/@cashu/crypto/modules/esm/util/utils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encodeBase64toUint8 = exports.hexToNumber = exports.bytesToNumber = void 0;\nconst utils_1 = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/abstract/utils.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\nfunction bytesToNumber(bytes) {\n    return hexToNumber((0, utils_1.bytesToHex)(bytes));\n}\nexports.bytesToNumber = bytesToNumber;\nfunction hexToNumber(hex) {\n    return BigInt(`0x${hex}`);\n}\nexports.hexToNumber = hexToNumber;\nfunction encodeBase64toUint8(base64String) {\n    return buffer_1.Buffer.from(base64String, 'base64');\n}\nexports.encodeBase64toUint8 = encodeBase64toUint8;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhc2h1L2NyeXB0by9tb2R1bGVzL2VzbS91dGlsL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixHQUFHLG1CQUFtQixHQUFHLHFCQUFxQjtBQUN6RSxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBOEI7QUFDdEQsaUJBQWlCLG1CQUFPLENBQUMscURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsdUJBQXVCLElBQUk7QUFDM0I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyIvVXNlcnMvcGFibG9mZXJuYW5kZXovdGVzdDEyMy9URU5FWC1wZmttYzkvbWFpbi9ub2RlX21vZHVsZXMvQGNhc2h1L2NyeXB0by9tb2R1bGVzL2VzbS91dGlsL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmNvZGVCYXNlNjR0b1VpbnQ4ID0gZXhwb3J0cy5oZXhUb051bWJlciA9IGV4cG9ydHMuYnl0ZXNUb051bWJlciA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiKTtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlci9cIik7XG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKCgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKGJ5dGVzKSk7XG59XG5leHBvcnRzLmJ5dGVzVG9OdW1iZXIgPSBieXRlc1RvTnVtYmVyO1xuZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgcmV0dXJuIEJpZ0ludChgMHgke2hleH1gKTtcbn1cbmV4cG9ydHMuaGV4VG9OdW1iZXIgPSBoZXhUb051bWJlcjtcbmZ1bmN0aW9uIGVuY29kZUJhc2U2NHRvVWludDgoYmFzZTY0U3RyaW5nKSB7XG4gICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGJhc2U2NFN0cmluZywgJ2Jhc2U2NCcpO1xufVxuZXhwb3J0cy5lbmNvZGVCYXNlNjR0b1VpbnQ4ID0gZW5jb2RlQmFzZTY0dG9VaW50ODtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cashu/crypto/modules/esm/util/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cashu/crypto/node_modules/@scure/bip32/lib/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@cashu/crypto/node_modules/@scure/bip32/lib/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HDKey = exports.HARDENED_OFFSET = void 0;\n/**\n * @module BIP32 hierarchical deterministic (HD) wallets over secp256k1.\n * @example\n * ```js\n * import { HDKey } from \"@scure/bip32\";\n * const hdkey1 = HDKey.fromMasterSeed(seed);\n * const hdkey2 = HDKey.fromExtendedKey(base58key);\n * const hdkey3 = HDKey.fromJSON({ xpriv: string });\n *\n * // props\n * [hdkey1.depth, hdkey1.index, hdkey1.chainCode];\n * console.log(hdkey2.privateKey, hdkey2.publicKey);\n * console.log(hdkey3.derive(\"m/0/2147483647'/1\"));\n * const sig = hdkey3.sign(hash);\n * hdkey3.verify(hash, sig);\n * ```\n */\n/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nconst hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@noble/hashes/hmac.js\");\nconst ripemd160_1 = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(ssr)/./node_modules/@noble/hashes/ripemd160.js\");\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/sha256.js\");\nconst sha512_1 = __webpack_require__(/*! @noble/hashes/sha512 */ \"(ssr)/./node_modules/@noble/hashes/sha512.js\");\nconst _assert_1 = __webpack_require__(/*! @noble/hashes/_assert */ \"(ssr)/./node_modules/@noble/hashes/_assert.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nconst secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/secp256k1.js\");\nconst modular_1 = __webpack_require__(/*! @noble/curves/abstract/modular */ \"(ssr)/./node_modules/@noble/curves/abstract/modular.js\");\nconst base_1 = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/index.js\");\nconst Point = secp256k1_1.secp256k1.ProjectivePoint;\nconst base58check = (0, base_1.createBase58check)(sha256_1.sha256);\nfunction bytesToNumber(bytes) {\n    (0, _assert_1.abytes)(bytes);\n    const h = bytes.length === 0 ? '0' : (0, utils_1.bytesToHex)(bytes);\n    return BigInt('0x' + h);\n}\nfunction numberToBytes(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('bigint expected');\n    return (0, utils_1.hexToBytes)(num.toString(16).padStart(64, '0'));\n}\nconst MASTER_SECRET = (0, utils_1.utf8ToBytes)('Bitcoin seed');\n// Bitcoin hardcoded by default\nconst BITCOIN_VERSIONS = { private: 0x0488ade4, public: 0x0488b21e };\nexports.HARDENED_OFFSET = 0x80000000;\nconst hash160 = (data) => (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(data));\nconst fromU32 = (data) => (0, utils_1.createView)(data).getUint32(0, false);\nconst toU32 = (n) => {\n    if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {\n        throw new Error('invalid number, should be from 0 to 2**32-1, got ' + n);\n    }\n    const buf = new Uint8Array(4);\n    (0, utils_1.createView)(buf).setUint32(0, n, false);\n    return buf;\n};\nclass HDKey {\n    get fingerprint() {\n        if (!this.pubHash) {\n            throw new Error('No publicKey set!');\n        }\n        return fromU32(this.pubHash);\n    }\n    get identifier() {\n        return this.pubHash;\n    }\n    get pubKeyHash() {\n        return this.pubHash;\n    }\n    get privateKey() {\n        return this.privKeyBytes || null;\n    }\n    get publicKey() {\n        return this.pubKey || null;\n    }\n    get privateExtendedKey() {\n        const priv = this.privateKey;\n        if (!priv) {\n            throw new Error('No private key');\n        }\n        return base58check.encode(this.serialize(this.versions.private, (0, utils_1.concatBytes)(new Uint8Array([0]), priv)));\n    }\n    get publicExtendedKey() {\n        if (!this.pubKey) {\n            throw new Error('No public key');\n        }\n        return base58check.encode(this.serialize(this.versions.public, this.pubKey));\n    }\n    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {\n        (0, _assert_1.abytes)(seed);\n        if (8 * seed.length < 128 || 8 * seed.length > 512) {\n            throw new Error('HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got ' +\n                seed.length);\n        }\n        const I = (0, hmac_1.hmac)(sha512_1.sha512, MASTER_SECRET, seed);\n        return new HDKey({\n            versions,\n            chainCode: I.slice(32),\n            privateKey: I.slice(0, 32),\n        });\n    }\n    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {\n        // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        const keyBuffer = base58check.decode(base58key);\n        const keyView = (0, utils_1.createView)(keyBuffer);\n        const version = keyView.getUint32(0, false);\n        const opt = {\n            versions,\n            depth: keyBuffer[4],\n            parentFingerprint: keyView.getUint32(5, false),\n            index: keyView.getUint32(9, false),\n            chainCode: keyBuffer.slice(13, 45),\n        };\n        const key = keyBuffer.slice(45);\n        const isPriv = key[0] === 0;\n        if (version !== versions[isPriv ? 'private' : 'public']) {\n            throw new Error('Version mismatch');\n        }\n        if (isPriv) {\n            return new HDKey({ ...opt, privateKey: key.slice(1) });\n        }\n        else {\n            return new HDKey({ ...opt, publicKey: key });\n        }\n    }\n    static fromJSON(json) {\n        return HDKey.fromExtendedKey(json.xpriv);\n    }\n    constructor(opt) {\n        this.depth = 0;\n        this.index = 0;\n        this.chainCode = null;\n        this.parentFingerprint = 0;\n        if (!opt || typeof opt !== 'object') {\n            throw new Error('HDKey.constructor must not be called directly');\n        }\n        this.versions = opt.versions || BITCOIN_VERSIONS;\n        this.depth = opt.depth || 0;\n        this.chainCode = opt.chainCode || null;\n        this.index = opt.index || 0;\n        this.parentFingerprint = opt.parentFingerprint || 0;\n        if (!this.depth) {\n            if (this.parentFingerprint || this.index) {\n                throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');\n            }\n        }\n        if (opt.publicKey && opt.privateKey) {\n            throw new Error('HDKey: publicKey and privateKey at same time.');\n        }\n        if (opt.privateKey) {\n            if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(opt.privateKey)) {\n                throw new Error('Invalid private key');\n            }\n            this.privKey =\n                typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);\n            this.privKeyBytes = numberToBytes(this.privKey);\n            this.pubKey = secp256k1_1.secp256k1.getPublicKey(opt.privateKey, true);\n        }\n        else if (opt.publicKey) {\n            this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true); // force compressed point\n        }\n        else {\n            throw new Error('HDKey: no public or private key provided');\n        }\n        this.pubHash = hash160(this.pubKey);\n    }\n    derive(path) {\n        if (!/^[mM]'?/.test(path)) {\n            throw new Error('Path must start with \"m\" or \"M\"');\n        }\n        if (/^[mM]'?$/.test(path)) {\n            return this;\n        }\n        const parts = path.replace(/^[mM]'?\\//, '').split('/');\n        // tslint:disable-next-line\n        let child = this;\n        for (const c of parts) {\n            const m = /^(\\d+)('?)$/.exec(c);\n            const m1 = m && m[1];\n            if (!m || m.length !== 3 || typeof m1 !== 'string')\n                throw new Error('invalid child index: ' + c);\n            let idx = +m1;\n            if (!Number.isSafeInteger(idx) || idx >= exports.HARDENED_OFFSET) {\n                throw new Error('Invalid index');\n            }\n            // hardened key\n            if (m[2] === \"'\") {\n                idx += exports.HARDENED_OFFSET;\n            }\n            child = child.deriveChild(idx);\n        }\n        return child;\n    }\n    deriveChild(index) {\n        if (!this.pubKey || !this.chainCode) {\n            throw new Error('No publicKey or chainCode set');\n        }\n        let data = toU32(index);\n        if (index >= exports.HARDENED_OFFSET) {\n            // Hardened\n            const priv = this.privateKey;\n            if (!priv) {\n                throw new Error('Could not derive hardened child key');\n            }\n            // Hardened child: 0x00 || ser256(kpar) || ser32(index)\n            data = (0, utils_1.concatBytes)(new Uint8Array([0]), priv, data);\n        }\n        else {\n            // Normal child: serP(point(kpar)) || ser32(index)\n            data = (0, utils_1.concatBytes)(this.pubKey, data);\n        }\n        const I = (0, hmac_1.hmac)(sha512_1.sha512, this.chainCode, data);\n        const childTweak = bytesToNumber(I.slice(0, 32));\n        const chainCode = I.slice(32);\n        if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(childTweak)) {\n            throw new Error('Tweak bigger than curve order');\n        }\n        const opt = {\n            versions: this.versions,\n            chainCode,\n            depth: this.depth + 1,\n            parentFingerprint: this.fingerprint,\n            index,\n        };\n        try {\n            // Private parent key -> private child key\n            if (this.privateKey) {\n                const added = (0, modular_1.mod)(this.privKey + childTweak, secp256k1_1.secp256k1.CURVE.n);\n                if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(added)) {\n                    throw new Error('The tweak was out of range or the resulted private key is invalid');\n                }\n                opt.privateKey = added;\n            }\n            else {\n                const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));\n                // Cryptographically impossible: hmac-sha512 preimage would need to be found\n                if (added.equals(Point.ZERO)) {\n                    throw new Error('The tweak was equal to negative P, which made the result key invalid');\n                }\n                opt.publicKey = added.toRawBytes(true);\n            }\n            return new HDKey(opt);\n        }\n        catch (err) {\n            return this.deriveChild(index + 1);\n        }\n    }\n    sign(hash) {\n        if (!this.privateKey) {\n            throw new Error('No privateKey set!');\n        }\n        (0, _assert_1.abytes)(hash, 32);\n        return secp256k1_1.secp256k1.sign(hash, this.privKey).toCompactRawBytes();\n    }\n    verify(hash, signature) {\n        (0, _assert_1.abytes)(hash, 32);\n        (0, _assert_1.abytes)(signature, 64);\n        if (!this.publicKey) {\n            throw new Error('No publicKey set!');\n        }\n        let sig;\n        try {\n            sig = secp256k1_1.secp256k1.Signature.fromCompact(signature);\n        }\n        catch (error) {\n            return false;\n        }\n        return secp256k1_1.secp256k1.verify(sig, hash, this.publicKey);\n    }\n    wipePrivateData() {\n        this.privKey = undefined;\n        if (this.privKeyBytes) {\n            this.privKeyBytes.fill(0);\n            this.privKeyBytes = undefined;\n        }\n        return this;\n    }\n    toJSON() {\n        return {\n            xpriv: this.privateExtendedKey,\n            xpub: this.publicExtendedKey,\n        };\n    }\n    serialize(version, key) {\n        if (!this.chainCode) {\n            throw new Error('No chainCode set');\n        }\n        (0, _assert_1.abytes)(key, 33);\n        // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        return (0, utils_1.concatBytes)(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);\n    }\n}\nexports.HDKey = HDKey;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhc2h1L2NyeXB0by9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxzRUFBb0I7QUFDM0Msb0JBQW9CLG1CQUFPLENBQUMsZ0ZBQXlCO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLDBFQUFzQjtBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBc0I7QUFDL0Msa0JBQWtCLG1CQUFPLENBQUMsNEVBQXVCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLHdFQUFxQjtBQUM3QyxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBeUI7QUFDckQsa0JBQWtCLG1CQUFPLENBQUMsOEZBQWdDO0FBQzFELGVBQWUsbUJBQU8sQ0FBQyxrRUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0NBQWtDO0FBQ2pFO0FBQ0E7QUFDQSwrQkFBK0Isd0JBQXdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYWJsb2Zlcm5hbmRlei90ZXN0MTIzL1RFTkVYLXBma21jOS9tYWluL25vZGVfbW9kdWxlcy9AY2FzaHUvY3J5cHRvL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IREtleSA9IGV4cG9ydHMuSEFSREVORURfT0ZGU0VUID0gdm9pZCAwO1xuLyoqXG4gKiBAbW9kdWxlIEJJUDMyIGhpZXJhcmNoaWNhbCBkZXRlcm1pbmlzdGljIChIRCkgd2FsbGV0cyBvdmVyIHNlY3AyNTZrMS5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgSERLZXkgfSBmcm9tIFwiQHNjdXJlL2JpcDMyXCI7XG4gKiBjb25zdCBoZGtleTEgPSBIREtleS5mcm9tTWFzdGVyU2VlZChzZWVkKTtcbiAqIGNvbnN0IGhka2V5MiA9IEhES2V5LmZyb21FeHRlbmRlZEtleShiYXNlNThrZXkpO1xuICogY29uc3QgaGRrZXkzID0gSERLZXkuZnJvbUpTT04oeyB4cHJpdjogc3RyaW5nIH0pO1xuICpcbiAqIC8vIHByb3BzXG4gKiBbaGRrZXkxLmRlcHRoLCBoZGtleTEuaW5kZXgsIGhka2V5MS5jaGFpbkNvZGVdO1xuICogY29uc29sZS5sb2coaGRrZXkyLnByaXZhdGVLZXksIGhka2V5Mi5wdWJsaWNLZXkpO1xuICogY29uc29sZS5sb2coaGRrZXkzLmRlcml2ZShcIm0vMC8yMTQ3NDgzNjQ3Jy8xXCIpKTtcbiAqIGNvbnN0IHNpZyA9IGhka2V5My5zaWduKGhhc2gpO1xuICogaGRrZXkzLnZlcmlmeShoYXNoLCBzaWcpO1xuICogYGBgXG4gKi9cbi8qISBzY3VyZS1iaXAzMiAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdHJpY2lvIFBhbGxhZGlubywgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCBobWFjXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9obWFjXCIpO1xuY29uc3QgcmlwZW1kMTYwXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjBcIik7XG5jb25zdCBzaGEyNTZfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiKTtcbmNvbnN0IHNoYTUxMl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhNTEyXCIpO1xuY29uc3QgX2Fzc2VydF8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvX2Fzc2VydFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IHNlY3AyNTZrMV8xID0gcmVxdWlyZShcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCIpO1xuY29uc3QgbW9kdWxhcl8xID0gcmVxdWlyZShcIkBub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvbW9kdWxhclwiKTtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCJAc2N1cmUvYmFzZVwiKTtcbmNvbnN0IFBvaW50ID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludDtcbmNvbnN0IGJhc2U1OGNoZWNrID0gKDAsIGJhc2VfMS5jcmVhdGVCYXNlNThjaGVjaykoc2hhMjU2XzEuc2hhMjU2KTtcbmZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXIoYnl0ZXMpIHtcbiAgICAoMCwgX2Fzc2VydF8xLmFieXRlcykoYnl0ZXMpO1xuICAgIGNvbnN0IGggPSBieXRlcy5sZW5ndGggPT09IDAgPyAnMCcgOiAoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KShieXRlcyk7XG4gICAgcmV0dXJuIEJpZ0ludCgnMHgnICsgaCk7XG59XG5mdW5jdGlvbiBudW1iZXJUb0J5dGVzKG51bSkge1xuICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaWdpbnQgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEuaGV4VG9CeXRlcykobnVtLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgJzAnKSk7XG59XG5jb25zdCBNQVNURVJfU0VDUkVUID0gKDAsIHV0aWxzXzEudXRmOFRvQnl0ZXMpKCdCaXRjb2luIHNlZWQnKTtcbi8vIEJpdGNvaW4gaGFyZGNvZGVkIGJ5IGRlZmF1bHRcbmNvbnN0IEJJVENPSU5fVkVSU0lPTlMgPSB7IHByaXZhdGU6IDB4MDQ4OGFkZTQsIHB1YmxpYzogMHgwNDg4YjIxZSB9O1xuZXhwb3J0cy5IQVJERU5FRF9PRkZTRVQgPSAweDgwMDAwMDAwO1xuY29uc3QgaGFzaDE2MCA9IChkYXRhKSA9PiAoMCwgcmlwZW1kMTYwXzEucmlwZW1kMTYwKSgoMCwgc2hhMjU2XzEuc2hhMjU2KShkYXRhKSk7XG5jb25zdCBmcm9tVTMyID0gKGRhdGEpID0+ICgwLCB1dGlsc18xLmNyZWF0ZVZpZXcpKGRhdGEpLmdldFVpbnQzMigwLCBmYWxzZSk7XG5jb25zdCB0b1UzMiA9IChuKSA9PiB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMCB8fCBuID4gMiAqKiAzMiAtIDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG51bWJlciwgc2hvdWxkIGJlIGZyb20gMCB0byAyKiozMi0xLCBnb3QgJyArIG4pO1xuICAgIH1cbiAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAoMCwgdXRpbHNfMS5jcmVhdGVWaWV3KShidWYpLnNldFVpbnQzMigwLCBuLCBmYWxzZSk7XG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5jbGFzcyBIREtleSB7XG4gICAgZ2V0IGZpbmdlcnByaW50KCkge1xuICAgICAgICBpZiAoIXRoaXMucHViSGFzaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwdWJsaWNLZXkgc2V0IScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tVTMyKHRoaXMucHViSGFzaCk7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJIYXNoO1xuICAgIH1cbiAgICBnZXQgcHViS2V5SGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHViSGFzaDtcbiAgICB9XG4gICAgZ2V0IHByaXZhdGVLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZLZXlCeXRlcyB8fCBudWxsO1xuICAgIH1cbiAgICBnZXQgcHVibGljS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJLZXkgfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByaXZhdGVFeHRlbmRlZEtleSgpIHtcbiAgICAgICAgY29uc3QgcHJpdiA9IHRoaXMucHJpdmF0ZUtleTtcbiAgICAgICAgaWYgKCFwcml2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U1OGNoZWNrLmVuY29kZSh0aGlzLnNlcmlhbGl6ZSh0aGlzLnZlcnNpb25zLnByaXZhdGUsICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShuZXcgVWludDhBcnJheShbMF0pLCBwcml2KSkpO1xuICAgIH1cbiAgICBnZXQgcHVibGljRXh0ZW5kZWRLZXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5wdWJLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHVibGljIGtleScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlNThjaGVjay5lbmNvZGUodGhpcy5zZXJpYWxpemUodGhpcy52ZXJzaW9ucy5wdWJsaWMsIHRoaXMucHViS2V5KSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTWFzdGVyU2VlZChzZWVkLCB2ZXJzaW9ucyA9IEJJVENPSU5fVkVSU0lPTlMpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfMS5hYnl0ZXMpKHNlZWQpO1xuICAgICAgICBpZiAoOCAqIHNlZWQubGVuZ3RoIDwgMTI4IHx8IDggKiBzZWVkLmxlbmd0aCA+IDUxMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIREtleTogc2VlZCBsZW5ndGggbXVzdCBiZSBiZXR3ZWVuIDEyOCBhbmQgNTEyIGJpdHM7IDI1NiBiaXRzIGlzIGFkdmlzZWQsIGdvdCAnICtcbiAgICAgICAgICAgICAgICBzZWVkLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgSSA9ICgwLCBobWFjXzEuaG1hYykoc2hhNTEyXzEuc2hhNTEyLCBNQVNURVJfU0VDUkVULCBzZWVkKTtcbiAgICAgICAgcmV0dXJuIG5ldyBIREtleSh7XG4gICAgICAgICAgICB2ZXJzaW9ucyxcbiAgICAgICAgICAgIGNoYWluQ29kZTogSS5zbGljZSgzMiksXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBJLnNsaWNlKDAsIDMyKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRLZXkoYmFzZTU4a2V5LCB2ZXJzaW9ucyA9IEJJVENPSU5fVkVSU0lPTlMpIHtcbiAgICAgICAgLy8gPT4gdmVyc2lvbig0KSB8fCBkZXB0aCgxKSB8fCBmaW5nZXJwcmludCg0KSB8fCBpbmRleCg0KSB8fCBjaGFpbigzMikgfHwga2V5KDMzKVxuICAgICAgICBjb25zdCBrZXlCdWZmZXIgPSBiYXNlNThjaGVjay5kZWNvZGUoYmFzZTU4a2V5KTtcbiAgICAgICAgY29uc3Qga2V5VmlldyA9ICgwLCB1dGlsc18xLmNyZWF0ZVZpZXcpKGtleUJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBrZXlWaWV3LmdldFVpbnQzMigwLCBmYWxzZSk7XG4gICAgICAgIGNvbnN0IG9wdCA9IHtcbiAgICAgICAgICAgIHZlcnNpb25zLFxuICAgICAgICAgICAgZGVwdGg6IGtleUJ1ZmZlcls0XSxcbiAgICAgICAgICAgIHBhcmVudEZpbmdlcnByaW50OiBrZXlWaWV3LmdldFVpbnQzMig1LCBmYWxzZSksXG4gICAgICAgICAgICBpbmRleDoga2V5Vmlldy5nZXRVaW50MzIoOSwgZmFsc2UpLFxuICAgICAgICAgICAgY2hhaW5Db2RlOiBrZXlCdWZmZXIuc2xpY2UoMTMsIDQ1KSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5QnVmZmVyLnNsaWNlKDQ1KTtcbiAgICAgICAgY29uc3QgaXNQcml2ID0ga2V5WzBdID09PSAwO1xuICAgICAgICBpZiAodmVyc2lvbiAhPT0gdmVyc2lvbnNbaXNQcml2ID8gJ3ByaXZhdGUnIDogJ3B1YmxpYyddKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnNpb24gbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcml2KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhES2V5KHsgLi4ub3B0LCBwcml2YXRlS2V5OiBrZXkuc2xpY2UoMSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhES2V5KHsgLi4ub3B0LCBwdWJsaWNLZXk6IGtleSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICByZXR1cm4gSERLZXkuZnJvbUV4dGVuZGVkS2V5KGpzb24ueHByaXYpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvcHQpIHtcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmNoYWluQ29kZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyZW50RmluZ2VycHJpbnQgPSAwO1xuICAgICAgICBpZiAoIW9wdCB8fCB0eXBlb2Ygb3B0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIREtleS5jb25zdHJ1Y3RvciBtdXN0IG5vdCBiZSBjYWxsZWQgZGlyZWN0bHknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcnNpb25zID0gb3B0LnZlcnNpb25zIHx8IEJJVENPSU5fVkVSU0lPTlM7XG4gICAgICAgIHRoaXMuZGVwdGggPSBvcHQuZGVwdGggfHwgMDtcbiAgICAgICAgdGhpcy5jaGFpbkNvZGUgPSBvcHQuY2hhaW5Db2RlIHx8IG51bGw7XG4gICAgICAgIHRoaXMuaW5kZXggPSBvcHQuaW5kZXggfHwgMDtcbiAgICAgICAgdGhpcy5wYXJlbnRGaW5nZXJwcmludCA9IG9wdC5wYXJlbnRGaW5nZXJwcmludCB8fCAwO1xuICAgICAgICBpZiAoIXRoaXMuZGVwdGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudEZpbmdlcnByaW50IHx8IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hES2V5OiB6ZXJvIGRlcHRoIHdpdGggbm9uLXplcm8gaW5kZXgvcGFyZW50IGZpbmdlcnByaW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdC5wdWJsaWNLZXkgJiYgb3B0LnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSERLZXk6IHB1YmxpY0tleSBhbmQgcHJpdmF0ZUtleSBhdCBzYW1lIHRpbWUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdC5wcml2YXRlS2V5KSB7XG4gICAgICAgICAgICBpZiAoIXNlY3AyNTZrMV8xLnNlY3AyNTZrMS51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleShvcHQucHJpdmF0ZUtleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJpdktleSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIG9wdC5wcml2YXRlS2V5ID09PSAnYmlnaW50JyA/IG9wdC5wcml2YXRlS2V5IDogYnl0ZXNUb051bWJlcihvcHQucHJpdmF0ZUtleSk7XG4gICAgICAgICAgICB0aGlzLnByaXZLZXlCeXRlcyA9IG51bWJlclRvQnl0ZXModGhpcy5wcml2S2V5KTtcbiAgICAgICAgICAgIHRoaXMucHViS2V5ID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLmdldFB1YmxpY0tleShvcHQucHJpdmF0ZUtleSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0LnB1YmxpY0tleSkge1xuICAgICAgICAgICAgdGhpcy5wdWJLZXkgPSBQb2ludC5mcm9tSGV4KG9wdC5wdWJsaWNLZXkpLnRvUmF3Qnl0ZXModHJ1ZSk7IC8vIGZvcmNlIGNvbXByZXNzZWQgcG9pbnRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSERLZXk6IG5vIHB1YmxpYyBvciBwcml2YXRlIGtleSBwcm92aWRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHViSGFzaCA9IGhhc2gxNjAodGhpcy5wdWJLZXkpO1xuICAgIH1cbiAgICBkZXJpdmUocGF0aCkge1xuICAgICAgICBpZiAoIS9eW21NXSc/Ly50ZXN0KHBhdGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggbXVzdCBzdGFydCB3aXRoIFwibVwiIG9yIFwiTVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9eW21NXSc/JC8udGVzdChwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFydHMgPSBwYXRoLnJlcGxhY2UoL15bbU1dJz9cXC8vLCAnJykuc3BsaXQoJy8nKTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGxldCBjaGlsZCA9IHRoaXM7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBwYXJ0cykge1xuICAgICAgICAgICAgY29uc3QgbSA9IC9eKFxcZCspKCc/KSQvLmV4ZWMoYyk7XG4gICAgICAgICAgICBjb25zdCBtMSA9IG0gJiYgbVsxXTtcbiAgICAgICAgICAgIGlmICghbSB8fCBtLmxlbmd0aCAhPT0gMyB8fCB0eXBlb2YgbTEgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjaGlsZCBpbmRleDogJyArIGMpO1xuICAgICAgICAgICAgbGV0IGlkeCA9ICttMTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaWR4KSB8fCBpZHggPj0gZXhwb3J0cy5IQVJERU5FRF9PRkZTRVQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5kZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhcmRlbmVkIGtleVxuICAgICAgICAgICAgaWYgKG1bMl0gPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgICAgaWR4ICs9IGV4cG9ydHMuSEFSREVORURfT0ZGU0VUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5kZXJpdmVDaGlsZChpZHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgZGVyaXZlQ2hpbGQoaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnB1YktleSB8fCAhdGhpcy5jaGFpbkNvZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHVibGljS2V5IG9yIGNoYWluQ29kZSBzZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9IHRvVTMyKGluZGV4KTtcbiAgICAgICAgaWYgKGluZGV4ID49IGV4cG9ydHMuSEFSREVORURfT0ZGU0VUKSB7XG4gICAgICAgICAgICAvLyBIYXJkZW5lZFxuICAgICAgICAgICAgY29uc3QgcHJpdiA9IHRoaXMucHJpdmF0ZUtleTtcbiAgICAgICAgICAgIGlmICghcHJpdikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRlcml2ZSBoYXJkZW5lZCBjaGlsZCBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhcmRlbmVkIGNoaWxkOiAweDAwIHx8IHNlcjI1NihrcGFyKSB8fCBzZXIzMihpbmRleClcbiAgICAgICAgICAgIGRhdGEgPSAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykobmV3IFVpbnQ4QXJyYXkoWzBdKSwgcHJpdiwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOb3JtYWwgY2hpbGQ6IHNlclAocG9pbnQoa3BhcikpIHx8IHNlcjMyKGluZGV4KVxuICAgICAgICAgICAgZGF0YSA9ICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKSh0aGlzLnB1YktleSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgSSA9ICgwLCBobWFjXzEuaG1hYykoc2hhNTEyXzEuc2hhNTEyLCB0aGlzLmNoYWluQ29kZSwgZGF0YSk7XG4gICAgICAgIGNvbnN0IGNoaWxkVHdlYWsgPSBieXRlc1RvTnVtYmVyKEkuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgY29uc3QgY2hhaW5Db2RlID0gSS5zbGljZSgzMik7XG4gICAgICAgIGlmICghc2VjcDI1NmsxXzEuc2VjcDI1NmsxLnV0aWxzLmlzVmFsaWRQcml2YXRlS2V5KGNoaWxkVHdlYWspKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R3ZWFrIGJpZ2dlciB0aGFuIGN1cnZlIG9yZGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0ID0ge1xuICAgICAgICAgICAgdmVyc2lvbnM6IHRoaXMudmVyc2lvbnMsXG4gICAgICAgICAgICBjaGFpbkNvZGUsXG4gICAgICAgICAgICBkZXB0aDogdGhpcy5kZXB0aCArIDEsXG4gICAgICAgICAgICBwYXJlbnRGaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gUHJpdmF0ZSBwYXJlbnQga2V5IC0+IHByaXZhdGUgY2hpbGQga2V5XG4gICAgICAgICAgICBpZiAodGhpcy5wcml2YXRlS2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkZWQgPSAoMCwgbW9kdWxhcl8xLm1vZCkodGhpcy5wcml2S2V5ICsgY2hpbGRUd2Vhaywgc2VjcDI1NmsxXzEuc2VjcDI1NmsxLkNVUlZFLm4pO1xuICAgICAgICAgICAgICAgIGlmICghc2VjcDI1NmsxXzEuc2VjcDI1NmsxLnV0aWxzLmlzVmFsaWRQcml2YXRlS2V5KGFkZGVkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0d2VhayB3YXMgb3V0IG9mIHJhbmdlIG9yIHRoZSByZXN1bHRlZCBwcml2YXRlIGtleSBpcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdC5wcml2YXRlS2V5ID0gYWRkZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRlZCA9IFBvaW50LmZyb21IZXgodGhpcy5wdWJLZXkpLmFkZChQb2ludC5mcm9tUHJpdmF0ZUtleShjaGlsZFR3ZWFrKSk7XG4gICAgICAgICAgICAgICAgLy8gQ3J5cHRvZ3JhcGhpY2FsbHkgaW1wb3NzaWJsZTogaG1hYy1zaGE1MTIgcHJlaW1hZ2Ugd291bGQgbmVlZCB0byBiZSBmb3VuZFxuICAgICAgICAgICAgICAgIGlmIChhZGRlZC5lcXVhbHMoUG9pbnQuWkVSTykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdHdlYWsgd2FzIGVxdWFsIHRvIG5lZ2F0aXZlIFAsIHdoaWNoIG1hZGUgdGhlIHJlc3VsdCBrZXkgaW52YWxpZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHQucHVibGljS2V5ID0gYWRkZWQudG9SYXdCeXRlcyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgSERLZXkob3B0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXJpdmVDaGlsZChpbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNpZ24oaGFzaCkge1xuICAgICAgICBpZiAoIXRoaXMucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwcml2YXRlS2V5IHNldCEnKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgX2Fzc2VydF8xLmFieXRlcykoaGFzaCwgMzIpO1xuICAgICAgICByZXR1cm4gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLnNpZ24oaGFzaCwgdGhpcy5wcml2S2V5KS50b0NvbXBhY3RSYXdCeXRlcygpO1xuICAgIH1cbiAgICB2ZXJpZnkoaGFzaCwgc2lnbmF0dXJlKSB7XG4gICAgICAgICgwLCBfYXNzZXJ0XzEuYWJ5dGVzKShoYXNoLCAzMik7XG4gICAgICAgICgwLCBfYXNzZXJ0XzEuYWJ5dGVzKShzaWduYXR1cmUsIDY0KTtcbiAgICAgICAgaWYgKCF0aGlzLnB1YmxpY0tleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwdWJsaWNLZXkgc2V0IScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaWc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzaWcgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuU2lnbmF0dXJlLmZyb21Db21wYWN0KHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlY3AyNTZrMV8xLnNlY3AyNTZrMS52ZXJpZnkoc2lnLCBoYXNoLCB0aGlzLnB1YmxpY0tleSk7XG4gICAgfVxuICAgIHdpcGVQcml2YXRlRGF0YSgpIHtcbiAgICAgICAgdGhpcy5wcml2S2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5wcml2S2V5Qnl0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJpdktleUJ5dGVzLmZpbGwoMCk7XG4gICAgICAgICAgICB0aGlzLnByaXZLZXlCeXRlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeHByaXY6IHRoaXMucHJpdmF0ZUV4dGVuZGVkS2V5LFxuICAgICAgICAgICAgeHB1YjogdGhpcy5wdWJsaWNFeHRlbmRlZEtleSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2VyaWFsaXplKHZlcnNpb24sIGtleSkge1xuICAgICAgICBpZiAoIXRoaXMuY2hhaW5Db2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNoYWluQ29kZSBzZXQnKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgX2Fzc2VydF8xLmFieXRlcykoa2V5LCAzMyk7XG4gICAgICAgIC8vIHZlcnNpb24oNCkgfHwgZGVwdGgoMSkgfHwgZmluZ2VycHJpbnQoNCkgfHwgaW5kZXgoNCkgfHwgY2hhaW4oMzIpIHx8IGtleSgzMylcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKSh0b1UzMih2ZXJzaW9uKSwgbmV3IFVpbnQ4QXJyYXkoW3RoaXMuZGVwdGhdKSwgdG9VMzIodGhpcy5wYXJlbnRGaW5nZXJwcmludCksIHRvVTMyKHRoaXMuaW5kZXgpLCB0aGlzLmNoYWluQ29kZSwga2V5KTtcbiAgICB9XG59XG5leHBvcnRzLkhES2V5ID0gSERLZXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cashu/crypto/node_modules/@scure/bip32/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cashu/crypto/node_modules/@scure/bip39/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@cashu/crypto/node_modules/@scure/bip39/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Audited & minimal JS implementation of\n * [BIP39 mnemonic phrases](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).\n * @module\n * @example\n```js\nimport * as bip39 from '@scure/bip39';\nimport { wordlist } from '@scure/bip39/wordlists/english';\nconst mn = bip39.generateMnemonic(wordlist);\nconsole.log(mn);\nconst ent = bip39.mnemonicToEntropy(mn, wordlist)\nbip39.entropyToMnemonic(ent, wordlist);\nbip39.validateMnemonic(mn, wordlist);\nawait bip39.mnemonicToSeed(mn, 'password');\nbip39.mnemonicToSeedSync(mn, 'password');\n\n// Wordlists\nimport { wordlist as czech } from '@scure/bip39/wordlists/czech';\nimport { wordlist as english } from '@scure/bip39/wordlists/english';\nimport { wordlist as french } from '@scure/bip39/wordlists/french';\nimport { wordlist as italian } from '@scure/bip39/wordlists/italian';\nimport { wordlist as japanese } from '@scure/bip39/wordlists/japanese';\nimport { wordlist as korean } from '@scure/bip39/wordlists/korean';\nimport { wordlist as portuguese } from '@scure/bip39/wordlists/portuguese';\nimport { wordlist as simplifiedChinese } from '@scure/bip39/wordlists/simplified-chinese';\nimport { wordlist as spanish } from '@scure/bip39/wordlists/spanish';\nimport { wordlist as traditionalChinese } from '@scure/bip39/wordlists/traditional-chinese';\n```\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.generateMnemonic = generateMnemonic;\nexports.mnemonicToEntropy = mnemonicToEntropy;\nexports.entropyToMnemonic = entropyToMnemonic;\nexports.validateMnemonic = validateMnemonic;\nexports.mnemonicToSeed = mnemonicToSeed;\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\n/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nconst _assert_1 = __webpack_require__(/*! @noble/hashes/_assert */ \"(ssr)/./node_modules/@noble/hashes/_assert.js\");\nconst pbkdf2_1 = __webpack_require__(/*! @noble/hashes/pbkdf2 */ \"(ssr)/./node_modules/@noble/hashes/pbkdf2.js\");\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/sha256.js\");\nconst sha512_1 = __webpack_require__(/*! @noble/hashes/sha512 */ \"(ssr)/./node_modules/@noble/hashes/sha512.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nconst base_1 = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/index.js\");\n// Japanese wordlist\nconst isJapanese = (wordlist) => wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093';\n// Normalization replaces equivalent sequences of characters\n// so that any two texts that are equivalent will be reduced\n// to the same sequence of code points, called the normal form of the original text.\n// https://tonsky.me/blog/unicode/#why-is-a----\nfunction nfkd(str) {\n    if (typeof str !== 'string')\n        throw new TypeError('invalid mnemonic type: ' + typeof str);\n    return str.normalize('NFKD');\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(' ');\n    if (![12, 15, 18, 21, 24].includes(words.length))\n        throw new Error('Invalid mnemonic');\n    return { nfkd: norm, words };\n}\nfunction aentropy(ent) {\n    (0, _assert_1.abytes)(ent, 16, 20, 24, 28, 32);\n}\n/**\n * Generate x random words. Uses Cryptographically-Secure Random Number Generator.\n * @param wordlist imported wordlist for specific language\n * @param strength mnemonic strength 128-256 bits\n * @example\n * generateMnemonic(wordlist, 128)\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nfunction generateMnemonic(wordlist, strength = 128) {\n    (0, _assert_1.anumber)(strength);\n    if (strength % 32 !== 0 || strength > 256)\n        throw new TypeError('Invalid entropy');\n    return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);\n}\nconst calcChecksum = (entropy) => {\n    // Checksum is ent.length/4 bits long\n    const bitsLeft = 8 - entropy.length / 4;\n    // Zero rightmost \"bitsLeft\" bits in byte\n    // For example: bitsLeft=4 val=10111101 -> 10110000\n    return new Uint8Array([((0, sha256_1.sha256)(entropy)[0] >> bitsLeft) << bitsLeft]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== 'string')\n        throw new Error('Wordlist: expected array of 2048 strings');\n    wordlist.forEach((i) => {\n        if (typeof i !== 'string')\n            throw new Error('wordlist: non-string element: ' + i);\n    });\n    return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));\n}\n/**\n * Reversible: Converts mnemonic string to raw entropy in form of byte array.\n * @param mnemonic 12-24 words\n * @param wordlist imported wordlist for specific language\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToEntropy(mnem, wordlist)\n * // Produces\n * new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ])\n */\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    aentropy(entropy);\n    return entropy;\n}\n/**\n * Reversible: Converts raw entropy in form of byte array to mnemonic string.\n * @param entropy byte array\n * @param wordlist imported wordlist for specific language\n * @returns 12-24 words\n * @example\n * const ent = new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ]);\n * entropyToMnemonic(ent, wordlist);\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nfunction entropyToMnemonic(entropy, wordlist) {\n    aentropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? '\\u3000' : ' ');\n}\n/**\n * Validates mnemonic for being 12-24 words contained in `wordlist`.\n */\nfunction validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nconst psalt = (passphrase) => nfkd('mnemonic' + passphrase);\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * await mnemonicToSeed(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nfunction mnemonicToSeed(mnemonic, passphrase = '') {\n    return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });\n}\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedSync(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nfunction mnemonicToSeedSync(mnemonic, passphrase = '') {\n    return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhc2h1L2NyeXB0by9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLG9CQUFvQjtBQUM3QixTQUFTLHNCQUFzQjtBQUMvQixTQUFTLHFCQUFxQjtBQUM5QixTQUFTLHNCQUFzQjtBQUMvQixTQUFTLHVCQUF1QjtBQUNoQyxTQUFTLHFCQUFxQjtBQUM5QixTQUFTLHlCQUF5QjtBQUNsQyxTQUFTLGdDQUFnQztBQUN6QyxTQUFTLHNCQUFzQjtBQUMvQixTQUFTLGlDQUFpQztBQUMxQztBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIsMEJBQTBCO0FBQzFCO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsNEVBQXVCO0FBQ2pELGlCQUFpQixtQkFBTyxDQUFDLDBFQUFzQjtBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBc0I7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsMEVBQXNCO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLHdFQUFxQjtBQUM3QyxlQUFlLG1CQUFPLENBQUMsa0VBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUcsb0JBQW9CO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxvQkFBb0I7QUFDcEgiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYWJsb2Zlcm5hbmRlei90ZXN0MTIzL1RFTkVYLXBma21jOS9tYWluL25vZGVfbW9kdWxlcy9AY2FzaHUvY3J5cHRvL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEF1ZGl0ZWQgJiBtaW5pbWFsIEpTIGltcGxlbWVudGF0aW9uIG9mXG4gKiBbQklQMzkgbW5lbW9uaWMgcGhyYXNlc10oaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDAzOS5tZWRpYXdpa2kpLlxuICogQG1vZHVsZVxuICogQGV4YW1wbGVcbmBgYGpzXG5pbXBvcnQgKiBhcyBiaXAzOSBmcm9tICdAc2N1cmUvYmlwMzknO1xuaW1wb3J0IHsgd29yZGxpc3QgfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL2VuZ2xpc2gnO1xuY29uc3QgbW4gPSBiaXAzOS5nZW5lcmF0ZU1uZW1vbmljKHdvcmRsaXN0KTtcbmNvbnNvbGUubG9nKG1uKTtcbmNvbnN0IGVudCA9IGJpcDM5Lm1uZW1vbmljVG9FbnRyb3B5KG1uLCB3b3JkbGlzdClcbmJpcDM5LmVudHJvcHlUb01uZW1vbmljKGVudCwgd29yZGxpc3QpO1xuYmlwMzkudmFsaWRhdGVNbmVtb25pYyhtbiwgd29yZGxpc3QpO1xuYXdhaXQgYmlwMzkubW5lbW9uaWNUb1NlZWQobW4sICdwYXNzd29yZCcpO1xuYmlwMzkubW5lbW9uaWNUb1NlZWRTeW5jKG1uLCAncGFzc3dvcmQnKTtcblxuLy8gV29yZGxpc3RzXG5pbXBvcnQgeyB3b3JkbGlzdCBhcyBjemVjaCB9IGZyb20gJ0BzY3VyZS9iaXAzOS93b3JkbGlzdHMvY3plY2gnO1xuaW1wb3J0IHsgd29yZGxpc3QgYXMgZW5nbGlzaCB9IGZyb20gJ0BzY3VyZS9iaXAzOS93b3JkbGlzdHMvZW5nbGlzaCc7XG5pbXBvcnQgeyB3b3JkbGlzdCBhcyBmcmVuY2ggfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL2ZyZW5jaCc7XG5pbXBvcnQgeyB3b3JkbGlzdCBhcyBpdGFsaWFuIH0gZnJvbSAnQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9pdGFsaWFuJztcbmltcG9ydCB7IHdvcmRsaXN0IGFzIGphcGFuZXNlIH0gZnJvbSAnQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9qYXBhbmVzZSc7XG5pbXBvcnQgeyB3b3JkbGlzdCBhcyBrb3JlYW4gfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL2tvcmVhbic7XG5pbXBvcnQgeyB3b3JkbGlzdCBhcyBwb3J0dWd1ZXNlIH0gZnJvbSAnQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9wb3J0dWd1ZXNlJztcbmltcG9ydCB7IHdvcmRsaXN0IGFzIHNpbXBsaWZpZWRDaGluZXNlIH0gZnJvbSAnQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9zaW1wbGlmaWVkLWNoaW5lc2UnO1xuaW1wb3J0IHsgd29yZGxpc3QgYXMgc3BhbmlzaCB9IGZyb20gJ0BzY3VyZS9iaXAzOS93b3JkbGlzdHMvc3BhbmlzaCc7XG5pbXBvcnQgeyB3b3JkbGlzdCBhcyB0cmFkaXRpb25hbENoaW5lc2UgfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL3RyYWRpdGlvbmFsLWNoaW5lc2UnO1xuYGBgXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2VuZXJhdGVNbmVtb25pYyA9IGdlbmVyYXRlTW5lbW9uaWM7XG5leHBvcnRzLm1uZW1vbmljVG9FbnRyb3B5ID0gbW5lbW9uaWNUb0VudHJvcHk7XG5leHBvcnRzLmVudHJvcHlUb01uZW1vbmljID0gZW50cm9weVRvTW5lbW9uaWM7XG5leHBvcnRzLnZhbGlkYXRlTW5lbW9uaWMgPSB2YWxpZGF0ZU1uZW1vbmljO1xuZXhwb3J0cy5tbmVtb25pY1RvU2VlZCA9IG1uZW1vbmljVG9TZWVkO1xuZXhwb3J0cy5tbmVtb25pY1RvU2VlZFN5bmMgPSBtbmVtb25pY1RvU2VlZFN5bmM7XG4vKiEgc2N1cmUtYmlwMzkgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXRyaWNpbyBQYWxsYWRpbm8sIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgX2Fzc2VydF8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvX2Fzc2VydFwiKTtcbmNvbnN0IHBia2RmMl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvcGJrZGYyXCIpO1xuY29uc3Qgc2hhMjU2XzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIik7XG5jb25zdCBzaGE1MTJfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTUxMlwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCJAc2N1cmUvYmFzZVwiKTtcbi8vIEphcGFuZXNlIHdvcmRsaXN0XG5jb25zdCBpc0phcGFuZXNlID0gKHdvcmRsaXN0KSA9PiB3b3JkbGlzdFswXSA9PT0gJ1xcdTMwNDJcXHUzMDQ0XFx1MzA1M1xcdTMwNGZcXHUzMDU3XFx1MzA5Myc7XG4vLyBOb3JtYWxpemF0aW9uIHJlcGxhY2VzIGVxdWl2YWxlbnQgc2VxdWVuY2VzIG9mIGNoYXJhY3RlcnNcbi8vIHNvIHRoYXQgYW55IHR3byB0ZXh0cyB0aGF0IGFyZSBlcXVpdmFsZW50IHdpbGwgYmUgcmVkdWNlZFxuLy8gdG8gdGhlIHNhbWUgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMsIGNhbGxlZCB0aGUgbm9ybWFsIGZvcm0gb2YgdGhlIG9yaWdpbmFsIHRleHQuXG4vLyBodHRwczovL3RvbnNreS5tZS9ibG9nL3VuaWNvZGUvI3doeS1pcy1hLS0tLVxuZnVuY3Rpb24gbmZrZChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgbW5lbW9uaWMgdHlwZTogJyArIHR5cGVvZiBzdHIpO1xuICAgIHJldHVybiBzdHIubm9ybWFsaXplKCdORktEJyk7XG59XG5mdW5jdGlvbiBub3JtYWxpemUoc3RyKSB7XG4gICAgY29uc3Qgbm9ybSA9IG5ma2Qoc3RyKTtcbiAgICBjb25zdCB3b3JkcyA9IG5vcm0uc3BsaXQoJyAnKTtcbiAgICBpZiAoIVsxMiwgMTUsIDE4LCAyMSwgMjRdLmluY2x1ZGVzKHdvcmRzLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtbmVtb25pYycpO1xuICAgIHJldHVybiB7IG5ma2Q6IG5vcm0sIHdvcmRzIH07XG59XG5mdW5jdGlvbiBhZW50cm9weShlbnQpIHtcbiAgICAoMCwgX2Fzc2VydF8xLmFieXRlcykoZW50LCAxNiwgMjAsIDI0LCAyOCwgMzIpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSB4IHJhbmRvbSB3b3Jkcy4gVXNlcyBDcnlwdG9ncmFwaGljYWxseS1TZWN1cmUgUmFuZG9tIE51bWJlciBHZW5lcmF0b3IuXG4gKiBAcGFyYW0gd29yZGxpc3QgaW1wb3J0ZWQgd29yZGxpc3QgZm9yIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBAcGFyYW0gc3RyZW5ndGggbW5lbW9uaWMgc3RyZW5ndGggMTI4LTI1NiBiaXRzXG4gKiBAZXhhbXBsZVxuICogZ2VuZXJhdGVNbmVtb25pYyh3b3JkbGlzdCwgMTI4KVxuICogLy8gJ2xlZ2FsIHdpbm5lciB0aGFuayB5ZWFyIHdhdmUgc2F1c2FnZSB3b3J0aCB1c2VmdWwgbGVnYWwgd2lubmVyIHRoYW5rIHllbGxvdydcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVNbmVtb25pYyh3b3JkbGlzdCwgc3RyZW5ndGggPSAxMjgpIHtcbiAgICAoMCwgX2Fzc2VydF8xLmFudW1iZXIpKHN0cmVuZ3RoKTtcbiAgICBpZiAoc3RyZW5ndGggJSAzMiAhPT0gMCB8fCBzdHJlbmd0aCA+IDI1NilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBlbnRyb3B5Jyk7XG4gICAgcmV0dXJuIGVudHJvcHlUb01uZW1vbmljKCgwLCB1dGlsc18xLnJhbmRvbUJ5dGVzKShzdHJlbmd0aCAvIDgpLCB3b3JkbGlzdCk7XG59XG5jb25zdCBjYWxjQ2hlY2tzdW0gPSAoZW50cm9weSkgPT4ge1xuICAgIC8vIENoZWNrc3VtIGlzIGVudC5sZW5ndGgvNCBiaXRzIGxvbmdcbiAgICBjb25zdCBiaXRzTGVmdCA9IDggLSBlbnRyb3B5Lmxlbmd0aCAvIDQ7XG4gICAgLy8gWmVybyByaWdodG1vc3QgXCJiaXRzTGVmdFwiIGJpdHMgaW4gYnl0ZVxuICAgIC8vIEZvciBleGFtcGxlOiBiaXRzTGVmdD00IHZhbD0xMDExMTEwMSAtPiAxMDExMDAwMFxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShbKCgwLCBzaGEyNTZfMS5zaGEyNTYpKGVudHJvcHkpWzBdID4+IGJpdHNMZWZ0KSA8PCBiaXRzTGVmdF0pO1xufTtcbmZ1bmN0aW9uIGdldENvZGVyKHdvcmRsaXN0KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHdvcmRsaXN0KSB8fCB3b3JkbGlzdC5sZW5ndGggIT09IDIwNDggfHwgdHlwZW9mIHdvcmRsaXN0WzBdICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3JkbGlzdDogZXhwZWN0ZWQgYXJyYXkgb2YgMjA0OCBzdHJpbmdzJyk7XG4gICAgd29yZGxpc3QuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3b3JkbGlzdDogbm9uLXN0cmluZyBlbGVtZW50OiAnICsgaSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJhc2VfMS51dGlscy5jaGFpbihiYXNlXzEudXRpbHMuY2hlY2tzdW0oMSwgY2FsY0NoZWNrc3VtKSwgYmFzZV8xLnV0aWxzLnJhZGl4MigxMSwgdHJ1ZSksIGJhc2VfMS51dGlscy5hbHBoYWJldCh3b3JkbGlzdCkpO1xufVxuLyoqXG4gKiBSZXZlcnNpYmxlOiBDb252ZXJ0cyBtbmVtb25pYyBzdHJpbmcgdG8gcmF3IGVudHJvcHkgaW4gZm9ybSBvZiBieXRlIGFycmF5LlxuICogQHBhcmFtIG1uZW1vbmljIDEyLTI0IHdvcmRzXG4gKiBAcGFyYW0gd29yZGxpc3QgaW1wb3J0ZWQgd29yZGxpc3QgZm9yIHNwZWNpZmljIGxhbmd1YWdlXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbW5lbSA9ICdsZWdhbCB3aW5uZXIgdGhhbmsgeWVhciB3YXZlIHNhdXNhZ2Ugd29ydGggdXNlZnVsIGxlZ2FsIHdpbm5lciB0aGFuayB5ZWxsb3cnO1xuICogbW5lbW9uaWNUb0VudHJvcHkobW5lbSwgd29yZGxpc3QpXG4gKiAvLyBQcm9kdWNlc1xuICogbmV3IFVpbnQ4QXJyYXkoW1xuICogICAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLFxuICogICAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmXG4gKiBdKVxuICovXG5mdW5jdGlvbiBtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpIHtcbiAgICBjb25zdCB7IHdvcmRzIH0gPSBub3JtYWxpemUobW5lbW9uaWMpO1xuICAgIGNvbnN0IGVudHJvcHkgPSBnZXRDb2Rlcih3b3JkbGlzdCkuZGVjb2RlKHdvcmRzKTtcbiAgICBhZW50cm9weShlbnRyb3B5KTtcbiAgICByZXR1cm4gZW50cm9weTtcbn1cbi8qKlxuICogUmV2ZXJzaWJsZTogQ29udmVydHMgcmF3IGVudHJvcHkgaW4gZm9ybSBvZiBieXRlIGFycmF5IHRvIG1uZW1vbmljIHN0cmluZy5cbiAqIEBwYXJhbSBlbnRyb3B5IGJ5dGUgYXJyYXlcbiAqIEBwYXJhbSB3b3JkbGlzdCBpbXBvcnRlZCB3b3JkbGlzdCBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIEByZXR1cm5zIDEyLTI0IHdvcmRzXG4gKiBAZXhhbXBsZVxuICogY29uc3QgZW50ID0gbmV3IFVpbnQ4QXJyYXkoW1xuICogICAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLFxuICogICAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmXG4gKiBdKTtcbiAqIGVudHJvcHlUb01uZW1vbmljKGVudCwgd29yZGxpc3QpO1xuICogLy8gJ2xlZ2FsIHdpbm5lciB0aGFuayB5ZWFyIHdhdmUgc2F1c2FnZSB3b3J0aCB1c2VmdWwgbGVnYWwgd2lubmVyIHRoYW5rIHllbGxvdydcbiAqL1xuZnVuY3Rpb24gZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSwgd29yZGxpc3QpIHtcbiAgICBhZW50cm9weShlbnRyb3B5KTtcbiAgICBjb25zdCB3b3JkcyA9IGdldENvZGVyKHdvcmRsaXN0KS5lbmNvZGUoZW50cm9weSk7XG4gICAgcmV0dXJuIHdvcmRzLmpvaW4oaXNKYXBhbmVzZSh3b3JkbGlzdCkgPyAnXFx1MzAwMCcgOiAnICcpO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgbW5lbW9uaWMgZm9yIGJlaW5nIDEyLTI0IHdvcmRzIGNvbnRhaW5lZCBpbiBgd29yZGxpc3RgLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU1uZW1vbmljKG1uZW1vbmljLCB3b3JkbGlzdCkge1xuICAgIHRyeSB7XG4gICAgICAgIG1uZW1vbmljVG9FbnRyb3B5KG1uZW1vbmljLCB3b3JkbGlzdCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBwc2FsdCA9IChwYXNzcGhyYXNlKSA9PiBuZmtkKCdtbmVtb25pYycgKyBwYXNzcGhyYXNlKTtcbi8qKlxuICogSXJyZXZlcnNpYmxlOiBVc2VzIEtERiB0byBkZXJpdmUgNjQgYnl0ZXMgb2Yga2V5IGRhdGEgZnJvbSBtbmVtb25pYyArIG9wdGlvbmFsIHBhc3N3b3JkLlxuICogQHBhcmFtIG1uZW1vbmljIDEyLTI0IHdvcmRzXG4gKiBAcGFyYW0gcGFzc3BocmFzZSBzdHJpbmcgdGhhdCB3aWxsIGFkZGl0aW9uYWxseSBwcm90ZWN0IHRoZSBrZXlcbiAqIEByZXR1cm5zIDY0IGJ5dGVzIG9mIGtleSBkYXRhXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbW5lbSA9ICdsZWdhbCB3aW5uZXIgdGhhbmsgeWVhciB3YXZlIHNhdXNhZ2Ugd29ydGggdXNlZnVsIGxlZ2FsIHdpbm5lciB0aGFuayB5ZWxsb3cnO1xuICogYXdhaXQgbW5lbW9uaWNUb1NlZWQobW5lbSwgJ3Bhc3N3b3JkJyk7XG4gKiAvLyBuZXcgVWludDhBcnJheShbLi4uNjQgYnl0ZXNdKVxuICovXG5mdW5jdGlvbiBtbmVtb25pY1RvU2VlZChtbmVtb25pYywgcGFzc3BocmFzZSA9ICcnKSB7XG4gICAgcmV0dXJuICgwLCBwYmtkZjJfMS5wYmtkZjJBc3luYykoc2hhNTEyXzEuc2hhNTEyLCBub3JtYWxpemUobW5lbW9uaWMpLm5ma2QsIHBzYWx0KHBhc3NwaHJhc2UpLCB7IGM6IDIwNDgsIGRrTGVuOiA2NCB9KTtcbn1cbi8qKlxuICogSXJyZXZlcnNpYmxlOiBVc2VzIEtERiB0byBkZXJpdmUgNjQgYnl0ZXMgb2Yga2V5IGRhdGEgZnJvbSBtbmVtb25pYyArIG9wdGlvbmFsIHBhc3N3b3JkLlxuICogQHBhcmFtIG1uZW1vbmljIDEyLTI0IHdvcmRzXG4gKiBAcGFyYW0gcGFzc3BocmFzZSBzdHJpbmcgdGhhdCB3aWxsIGFkZGl0aW9uYWxseSBwcm90ZWN0IHRoZSBrZXlcbiAqIEByZXR1cm5zIDY0IGJ5dGVzIG9mIGtleSBkYXRhXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbW5lbSA9ICdsZWdhbCB3aW5uZXIgdGhhbmsgeWVhciB3YXZlIHNhdXNhZ2Ugd29ydGggdXNlZnVsIGxlZ2FsIHdpbm5lciB0aGFuayB5ZWxsb3cnO1xuICogbW5lbW9uaWNUb1NlZWRTeW5jKG1uZW0sICdwYXNzd29yZCcpO1xuICogLy8gbmV3IFVpbnQ4QXJyYXkoWy4uLjY0IGJ5dGVzXSlcbiAqL1xuZnVuY3Rpb24gbW5lbW9uaWNUb1NlZWRTeW5jKG1uZW1vbmljLCBwYXNzcGhyYXNlID0gJycpIHtcbiAgICByZXR1cm4gKDAsIHBia2RmMl8xLnBia2RmMikoc2hhNTEyXzEuc2hhNTEyLCBub3JtYWxpemUobW5lbW9uaWMpLm5ma2QsIHBzYWx0KHBhc3NwaHJhc2UpLCB7IGM6IDIwNDgsIGRrTGVuOiA2NCB9KTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cashu/crypto/node_modules/@scure/bip39/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@cashu/crypto/node_modules/@scure/bip39/wordlists/english.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@cashu/crypto/node_modules/@scure/bip39/wordlists/english.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wordlist = void 0;\nexports.wordlist = `abandon\nability\nable\nabout\nabove\nabsent\nabsorb\nabstract\nabsurd\nabuse\naccess\naccident\naccount\naccuse\nachieve\nacid\nacoustic\nacquire\nacross\nact\naction\nactor\nactress\nactual\nadapt\nadd\naddict\naddress\nadjust\nadmit\nadult\nadvance\nadvice\naerobic\naffair\nafford\nafraid\nagain\nage\nagent\nagree\nahead\naim\nair\nairport\naisle\nalarm\nalbum\nalcohol\nalert\nalien\nall\nalley\nallow\nalmost\nalone\nalpha\nalready\nalso\nalter\nalways\namateur\namazing\namong\namount\namused\nanalyst\nanchor\nancient\nanger\nangle\nangry\nanimal\nankle\nannounce\nannual\nanother\nanswer\nantenna\nantique\nanxiety\nany\napart\napology\nappear\napple\napprove\napril\narch\narctic\narea\narena\nargue\narm\narmed\narmor\narmy\naround\narrange\narrest\narrive\narrow\nart\nartefact\nartist\nartwork\nask\naspect\nassault\nasset\nassist\nassume\nasthma\nathlete\natom\nattack\nattend\nattitude\nattract\nauction\naudit\naugust\naunt\nauthor\nauto\nautumn\naverage\navocado\navoid\nawake\naware\naway\nawesome\nawful\nawkward\naxis\nbaby\nbachelor\nbacon\nbadge\nbag\nbalance\nbalcony\nball\nbamboo\nbanana\nbanner\nbar\nbarely\nbargain\nbarrel\nbase\nbasic\nbasket\nbattle\nbeach\nbean\nbeauty\nbecause\nbecome\nbeef\nbefore\nbegin\nbehave\nbehind\nbelieve\nbelow\nbelt\nbench\nbenefit\nbest\nbetray\nbetter\nbetween\nbeyond\nbicycle\nbid\nbike\nbind\nbiology\nbird\nbirth\nbitter\nblack\nblade\nblame\nblanket\nblast\nbleak\nbless\nblind\nblood\nblossom\nblouse\nblue\nblur\nblush\nboard\nboat\nbody\nboil\nbomb\nbone\nbonus\nbook\nboost\nborder\nboring\nborrow\nboss\nbottom\nbounce\nbox\nboy\nbracket\nbrain\nbrand\nbrass\nbrave\nbread\nbreeze\nbrick\nbridge\nbrief\nbright\nbring\nbrisk\nbroccoli\nbroken\nbronze\nbroom\nbrother\nbrown\nbrush\nbubble\nbuddy\nbudget\nbuffalo\nbuild\nbulb\nbulk\nbullet\nbundle\nbunker\nburden\nburger\nburst\nbus\nbusiness\nbusy\nbutter\nbuyer\nbuzz\ncabbage\ncabin\ncable\ncactus\ncage\ncake\ncall\ncalm\ncamera\ncamp\ncan\ncanal\ncancel\ncandy\ncannon\ncanoe\ncanvas\ncanyon\ncapable\ncapital\ncaptain\ncar\ncarbon\ncard\ncargo\ncarpet\ncarry\ncart\ncase\ncash\ncasino\ncastle\ncasual\ncat\ncatalog\ncatch\ncategory\ncattle\ncaught\ncause\ncaution\ncave\nceiling\ncelery\ncement\ncensus\ncentury\ncereal\ncertain\nchair\nchalk\nchampion\nchange\nchaos\nchapter\ncharge\nchase\nchat\ncheap\ncheck\ncheese\nchef\ncherry\nchest\nchicken\nchief\nchild\nchimney\nchoice\nchoose\nchronic\nchuckle\nchunk\nchurn\ncigar\ncinnamon\ncircle\ncitizen\ncity\ncivil\nclaim\nclap\nclarify\nclaw\nclay\nclean\nclerk\nclever\nclick\nclient\ncliff\nclimb\nclinic\nclip\nclock\nclog\nclose\ncloth\ncloud\nclown\nclub\nclump\ncluster\nclutch\ncoach\ncoast\ncoconut\ncode\ncoffee\ncoil\ncoin\ncollect\ncolor\ncolumn\ncombine\ncome\ncomfort\ncomic\ncommon\ncompany\nconcert\nconduct\nconfirm\ncongress\nconnect\nconsider\ncontrol\nconvince\ncook\ncool\ncopper\ncopy\ncoral\ncore\ncorn\ncorrect\ncost\ncotton\ncouch\ncountry\ncouple\ncourse\ncousin\ncover\ncoyote\ncrack\ncradle\ncraft\ncram\ncrane\ncrash\ncrater\ncrawl\ncrazy\ncream\ncredit\ncreek\ncrew\ncricket\ncrime\ncrisp\ncritic\ncrop\ncross\ncrouch\ncrowd\ncrucial\ncruel\ncruise\ncrumble\ncrunch\ncrush\ncry\ncrystal\ncube\nculture\ncup\ncupboard\ncurious\ncurrent\ncurtain\ncurve\ncushion\ncustom\ncute\ncycle\ndad\ndamage\ndamp\ndance\ndanger\ndaring\ndash\ndaughter\ndawn\nday\ndeal\ndebate\ndebris\ndecade\ndecember\ndecide\ndecline\ndecorate\ndecrease\ndeer\ndefense\ndefine\ndefy\ndegree\ndelay\ndeliver\ndemand\ndemise\ndenial\ndentist\ndeny\ndepart\ndepend\ndeposit\ndepth\ndeputy\nderive\ndescribe\ndesert\ndesign\ndesk\ndespair\ndestroy\ndetail\ndetect\ndevelop\ndevice\ndevote\ndiagram\ndial\ndiamond\ndiary\ndice\ndiesel\ndiet\ndiffer\ndigital\ndignity\ndilemma\ndinner\ndinosaur\ndirect\ndirt\ndisagree\ndiscover\ndisease\ndish\ndismiss\ndisorder\ndisplay\ndistance\ndivert\ndivide\ndivorce\ndizzy\ndoctor\ndocument\ndog\ndoll\ndolphin\ndomain\ndonate\ndonkey\ndonor\ndoor\ndose\ndouble\ndove\ndraft\ndragon\ndrama\ndrastic\ndraw\ndream\ndress\ndrift\ndrill\ndrink\ndrip\ndrive\ndrop\ndrum\ndry\nduck\ndumb\ndune\nduring\ndust\ndutch\nduty\ndwarf\ndynamic\neager\neagle\nearly\nearn\nearth\neasily\neast\neasy\necho\necology\neconomy\nedge\nedit\neducate\neffort\negg\neight\neither\nelbow\nelder\nelectric\nelegant\nelement\nelephant\nelevator\nelite\nelse\nembark\nembody\nembrace\nemerge\nemotion\nemploy\nempower\nempty\nenable\nenact\nend\nendless\nendorse\nenemy\nenergy\nenforce\nengage\nengine\nenhance\nenjoy\nenlist\nenough\nenrich\nenroll\nensure\nenter\nentire\nentry\nenvelope\nepisode\nequal\nequip\nera\nerase\nerode\nerosion\nerror\nerupt\nescape\nessay\nessence\nestate\neternal\nethics\nevidence\nevil\nevoke\nevolve\nexact\nexample\nexcess\nexchange\nexcite\nexclude\nexcuse\nexecute\nexercise\nexhaust\nexhibit\nexile\nexist\nexit\nexotic\nexpand\nexpect\nexpire\nexplain\nexpose\nexpress\nextend\nextra\neye\neyebrow\nfabric\nface\nfaculty\nfade\nfaint\nfaith\nfall\nfalse\nfame\nfamily\nfamous\nfan\nfancy\nfantasy\nfarm\nfashion\nfat\nfatal\nfather\nfatigue\nfault\nfavorite\nfeature\nfebruary\nfederal\nfee\nfeed\nfeel\nfemale\nfence\nfestival\nfetch\nfever\nfew\nfiber\nfiction\nfield\nfigure\nfile\nfilm\nfilter\nfinal\nfind\nfine\nfinger\nfinish\nfire\nfirm\nfirst\nfiscal\nfish\nfit\nfitness\nfix\nflag\nflame\nflash\nflat\nflavor\nflee\nflight\nflip\nfloat\nflock\nfloor\nflower\nfluid\nflush\nfly\nfoam\nfocus\nfog\nfoil\nfold\nfollow\nfood\nfoot\nforce\nforest\nforget\nfork\nfortune\nforum\nforward\nfossil\nfoster\nfound\nfox\nfragile\nframe\nfrequent\nfresh\nfriend\nfringe\nfrog\nfront\nfrost\nfrown\nfrozen\nfruit\nfuel\nfun\nfunny\nfurnace\nfury\nfuture\ngadget\ngain\ngalaxy\ngallery\ngame\ngap\ngarage\ngarbage\ngarden\ngarlic\ngarment\ngas\ngasp\ngate\ngather\ngauge\ngaze\ngeneral\ngenius\ngenre\ngentle\ngenuine\ngesture\nghost\ngiant\ngift\ngiggle\nginger\ngiraffe\ngirl\ngive\nglad\nglance\nglare\nglass\nglide\nglimpse\nglobe\ngloom\nglory\nglove\nglow\nglue\ngoat\ngoddess\ngold\ngood\ngoose\ngorilla\ngospel\ngossip\ngovern\ngown\ngrab\ngrace\ngrain\ngrant\ngrape\ngrass\ngravity\ngreat\ngreen\ngrid\ngrief\ngrit\ngrocery\ngroup\ngrow\ngrunt\nguard\nguess\nguide\nguilt\nguitar\ngun\ngym\nhabit\nhair\nhalf\nhammer\nhamster\nhand\nhappy\nharbor\nhard\nharsh\nharvest\nhat\nhave\nhawk\nhazard\nhead\nhealth\nheart\nheavy\nhedgehog\nheight\nhello\nhelmet\nhelp\nhen\nhero\nhidden\nhigh\nhill\nhint\nhip\nhire\nhistory\nhobby\nhockey\nhold\nhole\nholiday\nhollow\nhome\nhoney\nhood\nhope\nhorn\nhorror\nhorse\nhospital\nhost\nhotel\nhour\nhover\nhub\nhuge\nhuman\nhumble\nhumor\nhundred\nhungry\nhunt\nhurdle\nhurry\nhurt\nhusband\nhybrid\nice\nicon\nidea\nidentify\nidle\nignore\nill\nillegal\nillness\nimage\nimitate\nimmense\nimmune\nimpact\nimpose\nimprove\nimpulse\ninch\ninclude\nincome\nincrease\nindex\nindicate\nindoor\nindustry\ninfant\ninflict\ninform\ninhale\ninherit\ninitial\ninject\ninjury\ninmate\ninner\ninnocent\ninput\ninquiry\ninsane\ninsect\ninside\ninspire\ninstall\nintact\ninterest\ninto\ninvest\ninvite\ninvolve\niron\nisland\nisolate\nissue\nitem\nivory\njacket\njaguar\njar\njazz\njealous\njeans\njelly\njewel\njob\njoin\njoke\njourney\njoy\njudge\njuice\njump\njungle\njunior\njunk\njust\nkangaroo\nkeen\nkeep\nketchup\nkey\nkick\nkid\nkidney\nkind\nkingdom\nkiss\nkit\nkitchen\nkite\nkitten\nkiwi\nknee\nknife\nknock\nknow\nlab\nlabel\nlabor\nladder\nlady\nlake\nlamp\nlanguage\nlaptop\nlarge\nlater\nlatin\nlaugh\nlaundry\nlava\nlaw\nlawn\nlawsuit\nlayer\nlazy\nleader\nleaf\nlearn\nleave\nlecture\nleft\nleg\nlegal\nlegend\nleisure\nlemon\nlend\nlength\nlens\nleopard\nlesson\nletter\nlevel\nliar\nliberty\nlibrary\nlicense\nlife\nlift\nlight\nlike\nlimb\nlimit\nlink\nlion\nliquid\nlist\nlittle\nlive\nlizard\nload\nloan\nlobster\nlocal\nlock\nlogic\nlonely\nlong\nloop\nlottery\nloud\nlounge\nlove\nloyal\nlucky\nluggage\nlumber\nlunar\nlunch\nluxury\nlyrics\nmachine\nmad\nmagic\nmagnet\nmaid\nmail\nmain\nmajor\nmake\nmammal\nman\nmanage\nmandate\nmango\nmansion\nmanual\nmaple\nmarble\nmarch\nmargin\nmarine\nmarket\nmarriage\nmask\nmass\nmaster\nmatch\nmaterial\nmath\nmatrix\nmatter\nmaximum\nmaze\nmeadow\nmean\nmeasure\nmeat\nmechanic\nmedal\nmedia\nmelody\nmelt\nmember\nmemory\nmention\nmenu\nmercy\nmerge\nmerit\nmerry\nmesh\nmessage\nmetal\nmethod\nmiddle\nmidnight\nmilk\nmillion\nmimic\nmind\nminimum\nminor\nminute\nmiracle\nmirror\nmisery\nmiss\nmistake\nmix\nmixed\nmixture\nmobile\nmodel\nmodify\nmom\nmoment\nmonitor\nmonkey\nmonster\nmonth\nmoon\nmoral\nmore\nmorning\nmosquito\nmother\nmotion\nmotor\nmountain\nmouse\nmove\nmovie\nmuch\nmuffin\nmule\nmultiply\nmuscle\nmuseum\nmushroom\nmusic\nmust\nmutual\nmyself\nmystery\nmyth\nnaive\nname\nnapkin\nnarrow\nnasty\nnation\nnature\nnear\nneck\nneed\nnegative\nneglect\nneither\nnephew\nnerve\nnest\nnet\nnetwork\nneutral\nnever\nnews\nnext\nnice\nnight\nnoble\nnoise\nnominee\nnoodle\nnormal\nnorth\nnose\nnotable\nnote\nnothing\nnotice\nnovel\nnow\nnuclear\nnumber\nnurse\nnut\noak\nobey\nobject\noblige\nobscure\nobserve\nobtain\nobvious\noccur\nocean\noctober\nodor\noff\noffer\noffice\noften\noil\nokay\nold\nolive\nolympic\nomit\nonce\none\nonion\nonline\nonly\nopen\nopera\nopinion\noppose\noption\norange\norbit\norchard\norder\nordinary\norgan\norient\noriginal\norphan\nostrich\nother\noutdoor\nouter\noutput\noutside\noval\noven\nover\nown\nowner\noxygen\noyster\nozone\npact\npaddle\npage\npair\npalace\npalm\npanda\npanel\npanic\npanther\npaper\nparade\nparent\npark\nparrot\nparty\npass\npatch\npath\npatient\npatrol\npattern\npause\npave\npayment\npeace\npeanut\npear\npeasant\npelican\npen\npenalty\npencil\npeople\npepper\nperfect\npermit\nperson\npet\nphone\nphoto\nphrase\nphysical\npiano\npicnic\npicture\npiece\npig\npigeon\npill\npilot\npink\npioneer\npipe\npistol\npitch\npizza\nplace\nplanet\nplastic\nplate\nplay\nplease\npledge\npluck\nplug\nplunge\npoem\npoet\npoint\npolar\npole\npolice\npond\npony\npool\npopular\nportion\nposition\npossible\npost\npotato\npottery\npoverty\npowder\npower\npractice\npraise\npredict\nprefer\nprepare\npresent\npretty\nprevent\nprice\npride\nprimary\nprint\npriority\nprison\nprivate\nprize\nproblem\nprocess\nproduce\nprofit\nprogram\nproject\npromote\nproof\nproperty\nprosper\nprotect\nproud\nprovide\npublic\npudding\npull\npulp\npulse\npumpkin\npunch\npupil\npuppy\npurchase\npurity\npurpose\npurse\npush\nput\npuzzle\npyramid\nquality\nquantum\nquarter\nquestion\nquick\nquit\nquiz\nquote\nrabbit\nraccoon\nrace\nrack\nradar\nradio\nrail\nrain\nraise\nrally\nramp\nranch\nrandom\nrange\nrapid\nrare\nrate\nrather\nraven\nraw\nrazor\nready\nreal\nreason\nrebel\nrebuild\nrecall\nreceive\nrecipe\nrecord\nrecycle\nreduce\nreflect\nreform\nrefuse\nregion\nregret\nregular\nreject\nrelax\nrelease\nrelief\nrely\nremain\nremember\nremind\nremove\nrender\nrenew\nrent\nreopen\nrepair\nrepeat\nreplace\nreport\nrequire\nrescue\nresemble\nresist\nresource\nresponse\nresult\nretire\nretreat\nreturn\nreunion\nreveal\nreview\nreward\nrhythm\nrib\nribbon\nrice\nrich\nride\nridge\nrifle\nright\nrigid\nring\nriot\nripple\nrisk\nritual\nrival\nriver\nroad\nroast\nrobot\nrobust\nrocket\nromance\nroof\nrookie\nroom\nrose\nrotate\nrough\nround\nroute\nroyal\nrubber\nrude\nrug\nrule\nrun\nrunway\nrural\nsad\nsaddle\nsadness\nsafe\nsail\nsalad\nsalmon\nsalon\nsalt\nsalute\nsame\nsample\nsand\nsatisfy\nsatoshi\nsauce\nsausage\nsave\nsay\nscale\nscan\nscare\nscatter\nscene\nscheme\nschool\nscience\nscissors\nscorpion\nscout\nscrap\nscreen\nscript\nscrub\nsea\nsearch\nseason\nseat\nsecond\nsecret\nsection\nsecurity\nseed\nseek\nsegment\nselect\nsell\nseminar\nsenior\nsense\nsentence\nseries\nservice\nsession\nsettle\nsetup\nseven\nshadow\nshaft\nshallow\nshare\nshed\nshell\nsheriff\nshield\nshift\nshine\nship\nshiver\nshock\nshoe\nshoot\nshop\nshort\nshoulder\nshove\nshrimp\nshrug\nshuffle\nshy\nsibling\nsick\nside\nsiege\nsight\nsign\nsilent\nsilk\nsilly\nsilver\nsimilar\nsimple\nsince\nsing\nsiren\nsister\nsituate\nsix\nsize\nskate\nsketch\nski\nskill\nskin\nskirt\nskull\nslab\nslam\nsleep\nslender\nslice\nslide\nslight\nslim\nslogan\nslot\nslow\nslush\nsmall\nsmart\nsmile\nsmoke\nsmooth\nsnack\nsnake\nsnap\nsniff\nsnow\nsoap\nsoccer\nsocial\nsock\nsoda\nsoft\nsolar\nsoldier\nsolid\nsolution\nsolve\nsomeone\nsong\nsoon\nsorry\nsort\nsoul\nsound\nsoup\nsource\nsouth\nspace\nspare\nspatial\nspawn\nspeak\nspecial\nspeed\nspell\nspend\nsphere\nspice\nspider\nspike\nspin\nspirit\nsplit\nspoil\nsponsor\nspoon\nsport\nspot\nspray\nspread\nspring\nspy\nsquare\nsqueeze\nsquirrel\nstable\nstadium\nstaff\nstage\nstairs\nstamp\nstand\nstart\nstate\nstay\nsteak\nsteel\nstem\nstep\nstereo\nstick\nstill\nsting\nstock\nstomach\nstone\nstool\nstory\nstove\nstrategy\nstreet\nstrike\nstrong\nstruggle\nstudent\nstuff\nstumble\nstyle\nsubject\nsubmit\nsubway\nsuccess\nsuch\nsudden\nsuffer\nsugar\nsuggest\nsuit\nsummer\nsun\nsunny\nsunset\nsuper\nsupply\nsupreme\nsure\nsurface\nsurge\nsurprise\nsurround\nsurvey\nsuspect\nsustain\nswallow\nswamp\nswap\nswarm\nswear\nsweet\nswift\nswim\nswing\nswitch\nsword\nsymbol\nsymptom\nsyrup\nsystem\ntable\ntackle\ntag\ntail\ntalent\ntalk\ntank\ntape\ntarget\ntask\ntaste\ntattoo\ntaxi\nteach\nteam\ntell\nten\ntenant\ntennis\ntent\nterm\ntest\ntext\nthank\nthat\ntheme\nthen\ntheory\nthere\nthey\nthing\nthis\nthought\nthree\nthrive\nthrow\nthumb\nthunder\nticket\ntide\ntiger\ntilt\ntimber\ntime\ntiny\ntip\ntired\ntissue\ntitle\ntoast\ntobacco\ntoday\ntoddler\ntoe\ntogether\ntoilet\ntoken\ntomato\ntomorrow\ntone\ntongue\ntonight\ntool\ntooth\ntop\ntopic\ntopple\ntorch\ntornado\ntortoise\ntoss\ntotal\ntourist\ntoward\ntower\ntown\ntoy\ntrack\ntrade\ntraffic\ntragic\ntrain\ntransfer\ntrap\ntrash\ntravel\ntray\ntreat\ntree\ntrend\ntrial\ntribe\ntrick\ntrigger\ntrim\ntrip\ntrophy\ntrouble\ntruck\ntrue\ntruly\ntrumpet\ntrust\ntruth\ntry\ntube\ntuition\ntumble\ntuna\ntunnel\nturkey\nturn\nturtle\ntwelve\ntwenty\ntwice\ntwin\ntwist\ntwo\ntype\ntypical\nugly\numbrella\nunable\nunaware\nuncle\nuncover\nunder\nundo\nunfair\nunfold\nunhappy\nuniform\nunique\nunit\nuniverse\nunknown\nunlock\nuntil\nunusual\nunveil\nupdate\nupgrade\nuphold\nupon\nupper\nupset\nurban\nurge\nusage\nuse\nused\nuseful\nuseless\nusual\nutility\nvacant\nvacuum\nvague\nvalid\nvalley\nvalve\nvan\nvanish\nvapor\nvarious\nvast\nvault\nvehicle\nvelvet\nvendor\nventure\nvenue\nverb\nverify\nversion\nvery\nvessel\nveteran\nviable\nvibrant\nvicious\nvictory\nvideo\nview\nvillage\nvintage\nviolin\nvirtual\nvirus\nvisa\nvisit\nvisual\nvital\nvivid\nvocal\nvoice\nvoid\nvolcano\nvolume\nvote\nvoyage\nwage\nwagon\nwait\nwalk\nwall\nwalnut\nwant\nwarfare\nwarm\nwarrior\nwash\nwasp\nwaste\nwater\nwave\nway\nwealth\nweapon\nwear\nweasel\nweather\nweb\nwedding\nweekend\nweird\nwelcome\nwest\nwet\nwhale\nwhat\nwheat\nwheel\nwhen\nwhere\nwhip\nwhisper\nwide\nwidth\nwife\nwild\nwill\nwin\nwindow\nwine\nwing\nwink\nwinner\nwinter\nwire\nwisdom\nwise\nwish\nwitness\nwolf\nwoman\nwonder\nwood\nwool\nword\nwork\nworld\nworry\nworth\nwrap\nwreck\nwrestle\nwrist\nwrite\nwrong\nyard\nyear\nyellow\nyou\nyoung\nyouth\nzebra\nzero\nzone\nzoo`.split('\\n');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhc2h1L2NyeXB0by9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9lbmdsaXNoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYWJsb2Zlcm5hbmRlei90ZXN0MTIzL1RFTkVYLXBma21jOS9tYWluL25vZGVfbW9kdWxlcy9AY2FzaHUvY3J5cHRvL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvd29yZGxpc3RzL2VuZ2xpc2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndvcmRsaXN0ID0gdm9pZCAwO1xuZXhwb3J0cy53b3JkbGlzdCA9IGBhYmFuZG9uXG5hYmlsaXR5XG5hYmxlXG5hYm91dFxuYWJvdmVcbmFic2VudFxuYWJzb3JiXG5hYnN0cmFjdFxuYWJzdXJkXG5hYnVzZVxuYWNjZXNzXG5hY2NpZGVudFxuYWNjb3VudFxuYWNjdXNlXG5hY2hpZXZlXG5hY2lkXG5hY291c3RpY1xuYWNxdWlyZVxuYWNyb3NzXG5hY3RcbmFjdGlvblxuYWN0b3JcbmFjdHJlc3NcbmFjdHVhbFxuYWRhcHRcbmFkZFxuYWRkaWN0XG5hZGRyZXNzXG5hZGp1c3RcbmFkbWl0XG5hZHVsdFxuYWR2YW5jZVxuYWR2aWNlXG5hZXJvYmljXG5hZmZhaXJcbmFmZm9yZFxuYWZyYWlkXG5hZ2FpblxuYWdlXG5hZ2VudFxuYWdyZWVcbmFoZWFkXG5haW1cbmFpclxuYWlycG9ydFxuYWlzbGVcbmFsYXJtXG5hbGJ1bVxuYWxjb2hvbFxuYWxlcnRcbmFsaWVuXG5hbGxcbmFsbGV5XG5hbGxvd1xuYWxtb3N0XG5hbG9uZVxuYWxwaGFcbmFscmVhZHlcbmFsc29cbmFsdGVyXG5hbHdheXNcbmFtYXRldXJcbmFtYXppbmdcbmFtb25nXG5hbW91bnRcbmFtdXNlZFxuYW5hbHlzdFxuYW5jaG9yXG5hbmNpZW50XG5hbmdlclxuYW5nbGVcbmFuZ3J5XG5hbmltYWxcbmFua2xlXG5hbm5vdW5jZVxuYW5udWFsXG5hbm90aGVyXG5hbnN3ZXJcbmFudGVubmFcbmFudGlxdWVcbmFueGlldHlcbmFueVxuYXBhcnRcbmFwb2xvZ3lcbmFwcGVhclxuYXBwbGVcbmFwcHJvdmVcbmFwcmlsXG5hcmNoXG5hcmN0aWNcbmFyZWFcbmFyZW5hXG5hcmd1ZVxuYXJtXG5hcm1lZFxuYXJtb3JcbmFybXlcbmFyb3VuZFxuYXJyYW5nZVxuYXJyZXN0XG5hcnJpdmVcbmFycm93XG5hcnRcbmFydGVmYWN0XG5hcnRpc3RcbmFydHdvcmtcbmFza1xuYXNwZWN0XG5hc3NhdWx0XG5hc3NldFxuYXNzaXN0XG5hc3N1bWVcbmFzdGhtYVxuYXRobGV0ZVxuYXRvbVxuYXR0YWNrXG5hdHRlbmRcbmF0dGl0dWRlXG5hdHRyYWN0XG5hdWN0aW9uXG5hdWRpdFxuYXVndXN0XG5hdW50XG5hdXRob3JcbmF1dG9cbmF1dHVtblxuYXZlcmFnZVxuYXZvY2Fkb1xuYXZvaWRcbmF3YWtlXG5hd2FyZVxuYXdheVxuYXdlc29tZVxuYXdmdWxcbmF3a3dhcmRcbmF4aXNcbmJhYnlcbmJhY2hlbG9yXG5iYWNvblxuYmFkZ2VcbmJhZ1xuYmFsYW5jZVxuYmFsY29ueVxuYmFsbFxuYmFtYm9vXG5iYW5hbmFcbmJhbm5lclxuYmFyXG5iYXJlbHlcbmJhcmdhaW5cbmJhcnJlbFxuYmFzZVxuYmFzaWNcbmJhc2tldFxuYmF0dGxlXG5iZWFjaFxuYmVhblxuYmVhdXR5XG5iZWNhdXNlXG5iZWNvbWVcbmJlZWZcbmJlZm9yZVxuYmVnaW5cbmJlaGF2ZVxuYmVoaW5kXG5iZWxpZXZlXG5iZWxvd1xuYmVsdFxuYmVuY2hcbmJlbmVmaXRcbmJlc3RcbmJldHJheVxuYmV0dGVyXG5iZXR3ZWVuXG5iZXlvbmRcbmJpY3ljbGVcbmJpZFxuYmlrZVxuYmluZFxuYmlvbG9neVxuYmlyZFxuYmlydGhcbmJpdHRlclxuYmxhY2tcbmJsYWRlXG5ibGFtZVxuYmxhbmtldFxuYmxhc3RcbmJsZWFrXG5ibGVzc1xuYmxpbmRcbmJsb29kXG5ibG9zc29tXG5ibG91c2VcbmJsdWVcbmJsdXJcbmJsdXNoXG5ib2FyZFxuYm9hdFxuYm9keVxuYm9pbFxuYm9tYlxuYm9uZVxuYm9udXNcbmJvb2tcbmJvb3N0XG5ib3JkZXJcbmJvcmluZ1xuYm9ycm93XG5ib3NzXG5ib3R0b21cbmJvdW5jZVxuYm94XG5ib3lcbmJyYWNrZXRcbmJyYWluXG5icmFuZFxuYnJhc3NcbmJyYXZlXG5icmVhZFxuYnJlZXplXG5icmlja1xuYnJpZGdlXG5icmllZlxuYnJpZ2h0XG5icmluZ1xuYnJpc2tcbmJyb2Njb2xpXG5icm9rZW5cbmJyb256ZVxuYnJvb21cbmJyb3RoZXJcbmJyb3duXG5icnVzaFxuYnViYmxlXG5idWRkeVxuYnVkZ2V0XG5idWZmYWxvXG5idWlsZFxuYnVsYlxuYnVsa1xuYnVsbGV0XG5idW5kbGVcbmJ1bmtlclxuYnVyZGVuXG5idXJnZXJcbmJ1cnN0XG5idXNcbmJ1c2luZXNzXG5idXN5XG5idXR0ZXJcbmJ1eWVyXG5idXp6XG5jYWJiYWdlXG5jYWJpblxuY2FibGVcbmNhY3R1c1xuY2FnZVxuY2FrZVxuY2FsbFxuY2FsbVxuY2FtZXJhXG5jYW1wXG5jYW5cbmNhbmFsXG5jYW5jZWxcbmNhbmR5XG5jYW5ub25cbmNhbm9lXG5jYW52YXNcbmNhbnlvblxuY2FwYWJsZVxuY2FwaXRhbFxuY2FwdGFpblxuY2FyXG5jYXJib25cbmNhcmRcbmNhcmdvXG5jYXJwZXRcbmNhcnJ5XG5jYXJ0XG5jYXNlXG5jYXNoXG5jYXNpbm9cbmNhc3RsZVxuY2FzdWFsXG5jYXRcbmNhdGFsb2dcbmNhdGNoXG5jYXRlZ29yeVxuY2F0dGxlXG5jYXVnaHRcbmNhdXNlXG5jYXV0aW9uXG5jYXZlXG5jZWlsaW5nXG5jZWxlcnlcbmNlbWVudFxuY2Vuc3VzXG5jZW50dXJ5XG5jZXJlYWxcbmNlcnRhaW5cbmNoYWlyXG5jaGFsa1xuY2hhbXBpb25cbmNoYW5nZVxuY2hhb3NcbmNoYXB0ZXJcbmNoYXJnZVxuY2hhc2VcbmNoYXRcbmNoZWFwXG5jaGVja1xuY2hlZXNlXG5jaGVmXG5jaGVycnlcbmNoZXN0XG5jaGlja2VuXG5jaGllZlxuY2hpbGRcbmNoaW1uZXlcbmNob2ljZVxuY2hvb3NlXG5jaHJvbmljXG5jaHVja2xlXG5jaHVua1xuY2h1cm5cbmNpZ2FyXG5jaW5uYW1vblxuY2lyY2xlXG5jaXRpemVuXG5jaXR5XG5jaXZpbFxuY2xhaW1cbmNsYXBcbmNsYXJpZnlcbmNsYXdcbmNsYXlcbmNsZWFuXG5jbGVya1xuY2xldmVyXG5jbGlja1xuY2xpZW50XG5jbGlmZlxuY2xpbWJcbmNsaW5pY1xuY2xpcFxuY2xvY2tcbmNsb2dcbmNsb3NlXG5jbG90aFxuY2xvdWRcbmNsb3duXG5jbHViXG5jbHVtcFxuY2x1c3RlclxuY2x1dGNoXG5jb2FjaFxuY29hc3RcbmNvY29udXRcbmNvZGVcbmNvZmZlZVxuY29pbFxuY29pblxuY29sbGVjdFxuY29sb3JcbmNvbHVtblxuY29tYmluZVxuY29tZVxuY29tZm9ydFxuY29taWNcbmNvbW1vblxuY29tcGFueVxuY29uY2VydFxuY29uZHVjdFxuY29uZmlybVxuY29uZ3Jlc3NcbmNvbm5lY3RcbmNvbnNpZGVyXG5jb250cm9sXG5jb252aW5jZVxuY29va1xuY29vbFxuY29wcGVyXG5jb3B5XG5jb3JhbFxuY29yZVxuY29yblxuY29ycmVjdFxuY29zdFxuY290dG9uXG5jb3VjaFxuY291bnRyeVxuY291cGxlXG5jb3Vyc2VcbmNvdXNpblxuY292ZXJcbmNveW90ZVxuY3JhY2tcbmNyYWRsZVxuY3JhZnRcbmNyYW1cbmNyYW5lXG5jcmFzaFxuY3JhdGVyXG5jcmF3bFxuY3JhenlcbmNyZWFtXG5jcmVkaXRcbmNyZWVrXG5jcmV3XG5jcmlja2V0XG5jcmltZVxuY3Jpc3BcbmNyaXRpY1xuY3JvcFxuY3Jvc3NcbmNyb3VjaFxuY3Jvd2RcbmNydWNpYWxcbmNydWVsXG5jcnVpc2VcbmNydW1ibGVcbmNydW5jaFxuY3J1c2hcbmNyeVxuY3J5c3RhbFxuY3ViZVxuY3VsdHVyZVxuY3VwXG5jdXBib2FyZFxuY3VyaW91c1xuY3VycmVudFxuY3VydGFpblxuY3VydmVcbmN1c2hpb25cbmN1c3RvbVxuY3V0ZVxuY3ljbGVcbmRhZFxuZGFtYWdlXG5kYW1wXG5kYW5jZVxuZGFuZ2VyXG5kYXJpbmdcbmRhc2hcbmRhdWdodGVyXG5kYXduXG5kYXlcbmRlYWxcbmRlYmF0ZVxuZGVicmlzXG5kZWNhZGVcbmRlY2VtYmVyXG5kZWNpZGVcbmRlY2xpbmVcbmRlY29yYXRlXG5kZWNyZWFzZVxuZGVlclxuZGVmZW5zZVxuZGVmaW5lXG5kZWZ5XG5kZWdyZWVcbmRlbGF5XG5kZWxpdmVyXG5kZW1hbmRcbmRlbWlzZVxuZGVuaWFsXG5kZW50aXN0XG5kZW55XG5kZXBhcnRcbmRlcGVuZFxuZGVwb3NpdFxuZGVwdGhcbmRlcHV0eVxuZGVyaXZlXG5kZXNjcmliZVxuZGVzZXJ0XG5kZXNpZ25cbmRlc2tcbmRlc3BhaXJcbmRlc3Ryb3lcbmRldGFpbFxuZGV0ZWN0XG5kZXZlbG9wXG5kZXZpY2VcbmRldm90ZVxuZGlhZ3JhbVxuZGlhbFxuZGlhbW9uZFxuZGlhcnlcbmRpY2VcbmRpZXNlbFxuZGlldFxuZGlmZmVyXG5kaWdpdGFsXG5kaWduaXR5XG5kaWxlbW1hXG5kaW5uZXJcbmRpbm9zYXVyXG5kaXJlY3RcbmRpcnRcbmRpc2FncmVlXG5kaXNjb3ZlclxuZGlzZWFzZVxuZGlzaFxuZGlzbWlzc1xuZGlzb3JkZXJcbmRpc3BsYXlcbmRpc3RhbmNlXG5kaXZlcnRcbmRpdmlkZVxuZGl2b3JjZVxuZGl6enlcbmRvY3RvclxuZG9jdW1lbnRcbmRvZ1xuZG9sbFxuZG9scGhpblxuZG9tYWluXG5kb25hdGVcbmRvbmtleVxuZG9ub3JcbmRvb3JcbmRvc2VcbmRvdWJsZVxuZG92ZVxuZHJhZnRcbmRyYWdvblxuZHJhbWFcbmRyYXN0aWNcbmRyYXdcbmRyZWFtXG5kcmVzc1xuZHJpZnRcbmRyaWxsXG5kcmlua1xuZHJpcFxuZHJpdmVcbmRyb3BcbmRydW1cbmRyeVxuZHVja1xuZHVtYlxuZHVuZVxuZHVyaW5nXG5kdXN0XG5kdXRjaFxuZHV0eVxuZHdhcmZcbmR5bmFtaWNcbmVhZ2VyXG5lYWdsZVxuZWFybHlcbmVhcm5cbmVhcnRoXG5lYXNpbHlcbmVhc3RcbmVhc3lcbmVjaG9cbmVjb2xvZ3lcbmVjb25vbXlcbmVkZ2VcbmVkaXRcbmVkdWNhdGVcbmVmZm9ydFxuZWdnXG5laWdodFxuZWl0aGVyXG5lbGJvd1xuZWxkZXJcbmVsZWN0cmljXG5lbGVnYW50XG5lbGVtZW50XG5lbGVwaGFudFxuZWxldmF0b3JcbmVsaXRlXG5lbHNlXG5lbWJhcmtcbmVtYm9keVxuZW1icmFjZVxuZW1lcmdlXG5lbW90aW9uXG5lbXBsb3lcbmVtcG93ZXJcbmVtcHR5XG5lbmFibGVcbmVuYWN0XG5lbmRcbmVuZGxlc3NcbmVuZG9yc2VcbmVuZW15XG5lbmVyZ3lcbmVuZm9yY2VcbmVuZ2FnZVxuZW5naW5lXG5lbmhhbmNlXG5lbmpveVxuZW5saXN0XG5lbm91Z2hcbmVucmljaFxuZW5yb2xsXG5lbnN1cmVcbmVudGVyXG5lbnRpcmVcbmVudHJ5XG5lbnZlbG9wZVxuZXBpc29kZVxuZXF1YWxcbmVxdWlwXG5lcmFcbmVyYXNlXG5lcm9kZVxuZXJvc2lvblxuZXJyb3JcbmVydXB0XG5lc2NhcGVcbmVzc2F5XG5lc3NlbmNlXG5lc3RhdGVcbmV0ZXJuYWxcbmV0aGljc1xuZXZpZGVuY2VcbmV2aWxcbmV2b2tlXG5ldm9sdmVcbmV4YWN0XG5leGFtcGxlXG5leGNlc3NcbmV4Y2hhbmdlXG5leGNpdGVcbmV4Y2x1ZGVcbmV4Y3VzZVxuZXhlY3V0ZVxuZXhlcmNpc2VcbmV4aGF1c3RcbmV4aGliaXRcbmV4aWxlXG5leGlzdFxuZXhpdFxuZXhvdGljXG5leHBhbmRcbmV4cGVjdFxuZXhwaXJlXG5leHBsYWluXG5leHBvc2VcbmV4cHJlc3NcbmV4dGVuZFxuZXh0cmFcbmV5ZVxuZXllYnJvd1xuZmFicmljXG5mYWNlXG5mYWN1bHR5XG5mYWRlXG5mYWludFxuZmFpdGhcbmZhbGxcbmZhbHNlXG5mYW1lXG5mYW1pbHlcbmZhbW91c1xuZmFuXG5mYW5jeVxuZmFudGFzeVxuZmFybVxuZmFzaGlvblxuZmF0XG5mYXRhbFxuZmF0aGVyXG5mYXRpZ3VlXG5mYXVsdFxuZmF2b3JpdGVcbmZlYXR1cmVcbmZlYnJ1YXJ5XG5mZWRlcmFsXG5mZWVcbmZlZWRcbmZlZWxcbmZlbWFsZVxuZmVuY2VcbmZlc3RpdmFsXG5mZXRjaFxuZmV2ZXJcbmZld1xuZmliZXJcbmZpY3Rpb25cbmZpZWxkXG5maWd1cmVcbmZpbGVcbmZpbG1cbmZpbHRlclxuZmluYWxcbmZpbmRcbmZpbmVcbmZpbmdlclxuZmluaXNoXG5maXJlXG5maXJtXG5maXJzdFxuZmlzY2FsXG5maXNoXG5maXRcbmZpdG5lc3NcbmZpeFxuZmxhZ1xuZmxhbWVcbmZsYXNoXG5mbGF0XG5mbGF2b3JcbmZsZWVcbmZsaWdodFxuZmxpcFxuZmxvYXRcbmZsb2NrXG5mbG9vclxuZmxvd2VyXG5mbHVpZFxuZmx1c2hcbmZseVxuZm9hbVxuZm9jdXNcbmZvZ1xuZm9pbFxuZm9sZFxuZm9sbG93XG5mb29kXG5mb290XG5mb3JjZVxuZm9yZXN0XG5mb3JnZXRcbmZvcmtcbmZvcnR1bmVcbmZvcnVtXG5mb3J3YXJkXG5mb3NzaWxcbmZvc3RlclxuZm91bmRcbmZveFxuZnJhZ2lsZVxuZnJhbWVcbmZyZXF1ZW50XG5mcmVzaFxuZnJpZW5kXG5mcmluZ2VcbmZyb2dcbmZyb250XG5mcm9zdFxuZnJvd25cbmZyb3plblxuZnJ1aXRcbmZ1ZWxcbmZ1blxuZnVubnlcbmZ1cm5hY2VcbmZ1cnlcbmZ1dHVyZVxuZ2FkZ2V0XG5nYWluXG5nYWxheHlcbmdhbGxlcnlcbmdhbWVcbmdhcFxuZ2FyYWdlXG5nYXJiYWdlXG5nYXJkZW5cbmdhcmxpY1xuZ2FybWVudFxuZ2FzXG5nYXNwXG5nYXRlXG5nYXRoZXJcbmdhdWdlXG5nYXplXG5nZW5lcmFsXG5nZW5pdXNcbmdlbnJlXG5nZW50bGVcbmdlbnVpbmVcbmdlc3R1cmVcbmdob3N0XG5naWFudFxuZ2lmdFxuZ2lnZ2xlXG5naW5nZXJcbmdpcmFmZmVcbmdpcmxcbmdpdmVcbmdsYWRcbmdsYW5jZVxuZ2xhcmVcbmdsYXNzXG5nbGlkZVxuZ2xpbXBzZVxuZ2xvYmVcbmdsb29tXG5nbG9yeVxuZ2xvdmVcbmdsb3dcbmdsdWVcbmdvYXRcbmdvZGRlc3NcbmdvbGRcbmdvb2Rcbmdvb3NlXG5nb3JpbGxhXG5nb3NwZWxcbmdvc3NpcFxuZ292ZXJuXG5nb3duXG5ncmFiXG5ncmFjZVxuZ3JhaW5cbmdyYW50XG5ncmFwZVxuZ3Jhc3NcbmdyYXZpdHlcbmdyZWF0XG5ncmVlblxuZ3JpZFxuZ3JpZWZcbmdyaXRcbmdyb2Nlcnlcbmdyb3VwXG5ncm93XG5ncnVudFxuZ3VhcmRcbmd1ZXNzXG5ndWlkZVxuZ3VpbHRcbmd1aXRhclxuZ3VuXG5neW1cbmhhYml0XG5oYWlyXG5oYWxmXG5oYW1tZXJcbmhhbXN0ZXJcbmhhbmRcbmhhcHB5XG5oYXJib3JcbmhhcmRcbmhhcnNoXG5oYXJ2ZXN0XG5oYXRcbmhhdmVcbmhhd2tcbmhhemFyZFxuaGVhZFxuaGVhbHRoXG5oZWFydFxuaGVhdnlcbmhlZGdlaG9nXG5oZWlnaHRcbmhlbGxvXG5oZWxtZXRcbmhlbHBcbmhlblxuaGVyb1xuaGlkZGVuXG5oaWdoXG5oaWxsXG5oaW50XG5oaXBcbmhpcmVcbmhpc3RvcnlcbmhvYmJ5XG5ob2NrZXlcbmhvbGRcbmhvbGVcbmhvbGlkYXlcbmhvbGxvd1xuaG9tZVxuaG9uZXlcbmhvb2RcbmhvcGVcbmhvcm5cbmhvcnJvclxuaG9yc2Vcbmhvc3BpdGFsXG5ob3N0XG5ob3RlbFxuaG91clxuaG92ZXJcbmh1YlxuaHVnZVxuaHVtYW5cbmh1bWJsZVxuaHVtb3Jcbmh1bmRyZWRcbmh1bmdyeVxuaHVudFxuaHVyZGxlXG5odXJyeVxuaHVydFxuaHVzYmFuZFxuaHlicmlkXG5pY2Vcbmljb25cbmlkZWFcbmlkZW50aWZ5XG5pZGxlXG5pZ25vcmVcbmlsbFxuaWxsZWdhbFxuaWxsbmVzc1xuaW1hZ2VcbmltaXRhdGVcbmltbWVuc2VcbmltbXVuZVxuaW1wYWN0XG5pbXBvc2VcbmltcHJvdmVcbmltcHVsc2VcbmluY2hcbmluY2x1ZGVcbmluY29tZVxuaW5jcmVhc2VcbmluZGV4XG5pbmRpY2F0ZVxuaW5kb29yXG5pbmR1c3RyeVxuaW5mYW50XG5pbmZsaWN0XG5pbmZvcm1cbmluaGFsZVxuaW5oZXJpdFxuaW5pdGlhbFxuaW5qZWN0XG5pbmp1cnlcbmlubWF0ZVxuaW5uZXJcbmlubm9jZW50XG5pbnB1dFxuaW5xdWlyeVxuaW5zYW5lXG5pbnNlY3Rcbmluc2lkZVxuaW5zcGlyZVxuaW5zdGFsbFxuaW50YWN0XG5pbnRlcmVzdFxuaW50b1xuaW52ZXN0XG5pbnZpdGVcbmludm9sdmVcbmlyb25cbmlzbGFuZFxuaXNvbGF0ZVxuaXNzdWVcbml0ZW1cbml2b3J5XG5qYWNrZXRcbmphZ3VhclxuamFyXG5qYXp6XG5qZWFsb3VzXG5qZWFuc1xuamVsbHlcbmpld2VsXG5qb2JcbmpvaW5cbmpva2VcbmpvdXJuZXlcbmpveVxuanVkZ2Vcbmp1aWNlXG5qdW1wXG5qdW5nbGVcbmp1bmlvclxuanVua1xuanVzdFxua2FuZ2Fyb29cbmtlZW5cbmtlZXBcbmtldGNodXBcbmtleVxua2lja1xua2lkXG5raWRuZXlcbmtpbmRcbmtpbmdkb21cbmtpc3NcbmtpdFxua2l0Y2hlblxua2l0ZVxua2l0dGVuXG5raXdpXG5rbmVlXG5rbmlmZVxua25vY2tcbmtub3dcbmxhYlxubGFiZWxcbmxhYm9yXG5sYWRkZXJcbmxhZHlcbmxha2VcbmxhbXBcbmxhbmd1YWdlXG5sYXB0b3BcbmxhcmdlXG5sYXRlclxubGF0aW5cbmxhdWdoXG5sYXVuZHJ5XG5sYXZhXG5sYXdcbmxhd25cbmxhd3N1aXRcbmxheWVyXG5sYXp5XG5sZWFkZXJcbmxlYWZcbmxlYXJuXG5sZWF2ZVxubGVjdHVyZVxubGVmdFxubGVnXG5sZWdhbFxubGVnZW5kXG5sZWlzdXJlXG5sZW1vblxubGVuZFxubGVuZ3RoXG5sZW5zXG5sZW9wYXJkXG5sZXNzb25cbmxldHRlclxubGV2ZWxcbmxpYXJcbmxpYmVydHlcbmxpYnJhcnlcbmxpY2Vuc2VcbmxpZmVcbmxpZnRcbmxpZ2h0XG5saWtlXG5saW1iXG5saW1pdFxubGlua1xubGlvblxubGlxdWlkXG5saXN0XG5saXR0bGVcbmxpdmVcbmxpemFyZFxubG9hZFxubG9hblxubG9ic3RlclxubG9jYWxcbmxvY2tcbmxvZ2ljXG5sb25lbHlcbmxvbmdcbmxvb3BcbmxvdHRlcnlcbmxvdWRcbmxvdW5nZVxubG92ZVxubG95YWxcbmx1Y2t5XG5sdWdnYWdlXG5sdW1iZXJcbmx1bmFyXG5sdW5jaFxubHV4dXJ5XG5seXJpY3Ncbm1hY2hpbmVcbm1hZFxubWFnaWNcbm1hZ25ldFxubWFpZFxubWFpbFxubWFpblxubWFqb3Jcbm1ha2Vcbm1hbW1hbFxubWFuXG5tYW5hZ2Vcbm1hbmRhdGVcbm1hbmdvXG5tYW5zaW9uXG5tYW51YWxcbm1hcGxlXG5tYXJibGVcbm1hcmNoXG5tYXJnaW5cbm1hcmluZVxubWFya2V0XG5tYXJyaWFnZVxubWFza1xubWFzc1xubWFzdGVyXG5tYXRjaFxubWF0ZXJpYWxcbm1hdGhcbm1hdHJpeFxubWF0dGVyXG5tYXhpbXVtXG5tYXplXG5tZWFkb3dcbm1lYW5cbm1lYXN1cmVcbm1lYXRcbm1lY2hhbmljXG5tZWRhbFxubWVkaWFcbm1lbG9keVxubWVsdFxubWVtYmVyXG5tZW1vcnlcbm1lbnRpb25cbm1lbnVcbm1lcmN5XG5tZXJnZVxubWVyaXRcbm1lcnJ5XG5tZXNoXG5tZXNzYWdlXG5tZXRhbFxubWV0aG9kXG5taWRkbGVcbm1pZG5pZ2h0XG5taWxrXG5taWxsaW9uXG5taW1pY1xubWluZFxubWluaW11bVxubWlub3Jcbm1pbnV0ZVxubWlyYWNsZVxubWlycm9yXG5taXNlcnlcbm1pc3Ncbm1pc3Rha2Vcbm1peFxubWl4ZWRcbm1peHR1cmVcbm1vYmlsZVxubW9kZWxcbm1vZGlmeVxubW9tXG5tb21lbnRcbm1vbml0b3Jcbm1vbmtleVxubW9uc3RlclxubW9udGhcbm1vb25cbm1vcmFsXG5tb3JlXG5tb3JuaW5nXG5tb3NxdWl0b1xubW90aGVyXG5tb3Rpb25cbm1vdG9yXG5tb3VudGFpblxubW91c2Vcbm1vdmVcbm1vdmllXG5tdWNoXG5tdWZmaW5cbm11bGVcbm11bHRpcGx5XG5tdXNjbGVcbm11c2V1bVxubXVzaHJvb21cbm11c2ljXG5tdXN0XG5tdXR1YWxcbm15c2VsZlxubXlzdGVyeVxubXl0aFxubmFpdmVcbm5hbWVcbm5hcGtpblxubmFycm93XG5uYXN0eVxubmF0aW9uXG5uYXR1cmVcbm5lYXJcbm5lY2tcbm5lZWRcbm5lZ2F0aXZlXG5uZWdsZWN0XG5uZWl0aGVyXG5uZXBoZXdcbm5lcnZlXG5uZXN0XG5uZXRcbm5ldHdvcmtcbm5ldXRyYWxcbm5ldmVyXG5uZXdzXG5uZXh0XG5uaWNlXG5uaWdodFxubm9ibGVcbm5vaXNlXG5ub21pbmVlXG5ub29kbGVcbm5vcm1hbFxubm9ydGhcbm5vc2Vcbm5vdGFibGVcbm5vdGVcbm5vdGhpbmdcbm5vdGljZVxubm92ZWxcbm5vd1xubnVjbGVhclxubnVtYmVyXG5udXJzZVxubnV0XG5vYWtcbm9iZXlcbm9iamVjdFxub2JsaWdlXG5vYnNjdXJlXG5vYnNlcnZlXG5vYnRhaW5cbm9idmlvdXNcbm9jY3VyXG5vY2Vhblxub2N0b2Jlclxub2Rvclxub2ZmXG5vZmZlclxub2ZmaWNlXG5vZnRlblxub2lsXG5va2F5XG5vbGRcbm9saXZlXG5vbHltcGljXG5vbWl0XG5vbmNlXG5vbmVcbm9uaW9uXG5vbmxpbmVcbm9ubHlcbm9wZW5cbm9wZXJhXG5vcGluaW9uXG5vcHBvc2Vcbm9wdGlvblxub3JhbmdlXG5vcmJpdFxub3JjaGFyZFxub3JkZXJcbm9yZGluYXJ5XG5vcmdhblxub3JpZW50XG5vcmlnaW5hbFxub3JwaGFuXG5vc3RyaWNoXG5vdGhlclxub3V0ZG9vclxub3V0ZXJcbm91dHB1dFxub3V0c2lkZVxub3ZhbFxub3Zlblxub3Zlclxub3duXG5vd25lclxub3h5Z2VuXG5veXN0ZXJcbm96b25lXG5wYWN0XG5wYWRkbGVcbnBhZ2VcbnBhaXJcbnBhbGFjZVxucGFsbVxucGFuZGFcbnBhbmVsXG5wYW5pY1xucGFudGhlclxucGFwZXJcbnBhcmFkZVxucGFyZW50XG5wYXJrXG5wYXJyb3RcbnBhcnR5XG5wYXNzXG5wYXRjaFxucGF0aFxucGF0aWVudFxucGF0cm9sXG5wYXR0ZXJuXG5wYXVzZVxucGF2ZVxucGF5bWVudFxucGVhY2VcbnBlYW51dFxucGVhclxucGVhc2FudFxucGVsaWNhblxucGVuXG5wZW5hbHR5XG5wZW5jaWxcbnBlb3BsZVxucGVwcGVyXG5wZXJmZWN0XG5wZXJtaXRcbnBlcnNvblxucGV0XG5waG9uZVxucGhvdG9cbnBocmFzZVxucGh5c2ljYWxcbnBpYW5vXG5waWNuaWNcbnBpY3R1cmVcbnBpZWNlXG5waWdcbnBpZ2VvblxucGlsbFxucGlsb3RcbnBpbmtcbnBpb25lZXJcbnBpcGVcbnBpc3RvbFxucGl0Y2hcbnBpenphXG5wbGFjZVxucGxhbmV0XG5wbGFzdGljXG5wbGF0ZVxucGxheVxucGxlYXNlXG5wbGVkZ2VcbnBsdWNrXG5wbHVnXG5wbHVuZ2VcbnBvZW1cbnBvZXRcbnBvaW50XG5wb2xhclxucG9sZVxucG9saWNlXG5wb25kXG5wb255XG5wb29sXG5wb3B1bGFyXG5wb3J0aW9uXG5wb3NpdGlvblxucG9zc2libGVcbnBvc3RcbnBvdGF0b1xucG90dGVyeVxucG92ZXJ0eVxucG93ZGVyXG5wb3dlclxucHJhY3RpY2VcbnByYWlzZVxucHJlZGljdFxucHJlZmVyXG5wcmVwYXJlXG5wcmVzZW50XG5wcmV0dHlcbnByZXZlbnRcbnByaWNlXG5wcmlkZVxucHJpbWFyeVxucHJpbnRcbnByaW9yaXR5XG5wcmlzb25cbnByaXZhdGVcbnByaXplXG5wcm9ibGVtXG5wcm9jZXNzXG5wcm9kdWNlXG5wcm9maXRcbnByb2dyYW1cbnByb2plY3RcbnByb21vdGVcbnByb29mXG5wcm9wZXJ0eVxucHJvc3BlclxucHJvdGVjdFxucHJvdWRcbnByb3ZpZGVcbnB1YmxpY1xucHVkZGluZ1xucHVsbFxucHVscFxucHVsc2VcbnB1bXBraW5cbnB1bmNoXG5wdXBpbFxucHVwcHlcbnB1cmNoYXNlXG5wdXJpdHlcbnB1cnBvc2VcbnB1cnNlXG5wdXNoXG5wdXRcbnB1enpsZVxucHlyYW1pZFxucXVhbGl0eVxucXVhbnR1bVxucXVhcnRlclxucXVlc3Rpb25cbnF1aWNrXG5xdWl0XG5xdWl6XG5xdW90ZVxucmFiYml0XG5yYWNjb29uXG5yYWNlXG5yYWNrXG5yYWRhclxucmFkaW9cbnJhaWxcbnJhaW5cbnJhaXNlXG5yYWxseVxucmFtcFxucmFuY2hcbnJhbmRvbVxucmFuZ2VcbnJhcGlkXG5yYXJlXG5yYXRlXG5yYXRoZXJcbnJhdmVuXG5yYXdcbnJhem9yXG5yZWFkeVxucmVhbFxucmVhc29uXG5yZWJlbFxucmVidWlsZFxucmVjYWxsXG5yZWNlaXZlXG5yZWNpcGVcbnJlY29yZFxucmVjeWNsZVxucmVkdWNlXG5yZWZsZWN0XG5yZWZvcm1cbnJlZnVzZVxucmVnaW9uXG5yZWdyZXRcbnJlZ3VsYXJcbnJlamVjdFxucmVsYXhcbnJlbGVhc2VcbnJlbGllZlxucmVseVxucmVtYWluXG5yZW1lbWJlclxucmVtaW5kXG5yZW1vdmVcbnJlbmRlclxucmVuZXdcbnJlbnRcbnJlb3BlblxucmVwYWlyXG5yZXBlYXRcbnJlcGxhY2VcbnJlcG9ydFxucmVxdWlyZVxucmVzY3VlXG5yZXNlbWJsZVxucmVzaXN0XG5yZXNvdXJjZVxucmVzcG9uc2VcbnJlc3VsdFxucmV0aXJlXG5yZXRyZWF0XG5yZXR1cm5cbnJldW5pb25cbnJldmVhbFxucmV2aWV3XG5yZXdhcmRcbnJoeXRobVxucmliXG5yaWJib25cbnJpY2VcbnJpY2hcbnJpZGVcbnJpZGdlXG5yaWZsZVxucmlnaHRcbnJpZ2lkXG5yaW5nXG5yaW90XG5yaXBwbGVcbnJpc2tcbnJpdHVhbFxucml2YWxcbnJpdmVyXG5yb2FkXG5yb2FzdFxucm9ib3RcbnJvYnVzdFxucm9ja2V0XG5yb21hbmNlXG5yb29mXG5yb29raWVcbnJvb21cbnJvc2VcbnJvdGF0ZVxucm91Z2hcbnJvdW5kXG5yb3V0ZVxucm95YWxcbnJ1YmJlclxucnVkZVxucnVnXG5ydWxlXG5ydW5cbnJ1bndheVxucnVyYWxcbnNhZFxuc2FkZGxlXG5zYWRuZXNzXG5zYWZlXG5zYWlsXG5zYWxhZFxuc2FsbW9uXG5zYWxvblxuc2FsdFxuc2FsdXRlXG5zYW1lXG5zYW1wbGVcbnNhbmRcbnNhdGlzZnlcbnNhdG9zaGlcbnNhdWNlXG5zYXVzYWdlXG5zYXZlXG5zYXlcbnNjYWxlXG5zY2FuXG5zY2FyZVxuc2NhdHRlclxuc2NlbmVcbnNjaGVtZVxuc2Nob29sXG5zY2llbmNlXG5zY2lzc29yc1xuc2NvcnBpb25cbnNjb3V0XG5zY3JhcFxuc2NyZWVuXG5zY3JpcHRcbnNjcnViXG5zZWFcbnNlYXJjaFxuc2Vhc29uXG5zZWF0XG5zZWNvbmRcbnNlY3JldFxuc2VjdGlvblxuc2VjdXJpdHlcbnNlZWRcbnNlZWtcbnNlZ21lbnRcbnNlbGVjdFxuc2VsbFxuc2VtaW5hclxuc2VuaW9yXG5zZW5zZVxuc2VudGVuY2VcbnNlcmllc1xuc2VydmljZVxuc2Vzc2lvblxuc2V0dGxlXG5zZXR1cFxuc2V2ZW5cbnNoYWRvd1xuc2hhZnRcbnNoYWxsb3dcbnNoYXJlXG5zaGVkXG5zaGVsbFxuc2hlcmlmZlxuc2hpZWxkXG5zaGlmdFxuc2hpbmVcbnNoaXBcbnNoaXZlclxuc2hvY2tcbnNob2VcbnNob290XG5zaG9wXG5zaG9ydFxuc2hvdWxkZXJcbnNob3ZlXG5zaHJpbXBcbnNocnVnXG5zaHVmZmxlXG5zaHlcbnNpYmxpbmdcbnNpY2tcbnNpZGVcbnNpZWdlXG5zaWdodFxuc2lnblxuc2lsZW50XG5zaWxrXG5zaWxseVxuc2lsdmVyXG5zaW1pbGFyXG5zaW1wbGVcbnNpbmNlXG5zaW5nXG5zaXJlblxuc2lzdGVyXG5zaXR1YXRlXG5zaXhcbnNpemVcbnNrYXRlXG5za2V0Y2hcbnNraVxuc2tpbGxcbnNraW5cbnNraXJ0XG5za3VsbFxuc2xhYlxuc2xhbVxuc2xlZXBcbnNsZW5kZXJcbnNsaWNlXG5zbGlkZVxuc2xpZ2h0XG5zbGltXG5zbG9nYW5cbnNsb3RcbnNsb3dcbnNsdXNoXG5zbWFsbFxuc21hcnRcbnNtaWxlXG5zbW9rZVxuc21vb3RoXG5zbmFja1xuc25ha2VcbnNuYXBcbnNuaWZmXG5zbm93XG5zb2FwXG5zb2NjZXJcbnNvY2lhbFxuc29ja1xuc29kYVxuc29mdFxuc29sYXJcbnNvbGRpZXJcbnNvbGlkXG5zb2x1dGlvblxuc29sdmVcbnNvbWVvbmVcbnNvbmdcbnNvb25cbnNvcnJ5XG5zb3J0XG5zb3VsXG5zb3VuZFxuc291cFxuc291cmNlXG5zb3V0aFxuc3BhY2VcbnNwYXJlXG5zcGF0aWFsXG5zcGF3blxuc3BlYWtcbnNwZWNpYWxcbnNwZWVkXG5zcGVsbFxuc3BlbmRcbnNwaGVyZVxuc3BpY2VcbnNwaWRlclxuc3Bpa2VcbnNwaW5cbnNwaXJpdFxuc3BsaXRcbnNwb2lsXG5zcG9uc29yXG5zcG9vblxuc3BvcnRcbnNwb3RcbnNwcmF5XG5zcHJlYWRcbnNwcmluZ1xuc3B5XG5zcXVhcmVcbnNxdWVlemVcbnNxdWlycmVsXG5zdGFibGVcbnN0YWRpdW1cbnN0YWZmXG5zdGFnZVxuc3RhaXJzXG5zdGFtcFxuc3RhbmRcbnN0YXJ0XG5zdGF0ZVxuc3RheVxuc3RlYWtcbnN0ZWVsXG5zdGVtXG5zdGVwXG5zdGVyZW9cbnN0aWNrXG5zdGlsbFxuc3RpbmdcbnN0b2NrXG5zdG9tYWNoXG5zdG9uZVxuc3Rvb2xcbnN0b3J5XG5zdG92ZVxuc3RyYXRlZ3lcbnN0cmVldFxuc3RyaWtlXG5zdHJvbmdcbnN0cnVnZ2xlXG5zdHVkZW50XG5zdHVmZlxuc3R1bWJsZVxuc3R5bGVcbnN1YmplY3RcbnN1Ym1pdFxuc3Vid2F5XG5zdWNjZXNzXG5zdWNoXG5zdWRkZW5cbnN1ZmZlclxuc3VnYXJcbnN1Z2dlc3RcbnN1aXRcbnN1bW1lclxuc3VuXG5zdW5ueVxuc3Vuc2V0XG5zdXBlclxuc3VwcGx5XG5zdXByZW1lXG5zdXJlXG5zdXJmYWNlXG5zdXJnZVxuc3VycHJpc2VcbnN1cnJvdW5kXG5zdXJ2ZXlcbnN1c3BlY3RcbnN1c3RhaW5cbnN3YWxsb3dcbnN3YW1wXG5zd2FwXG5zd2FybVxuc3dlYXJcbnN3ZWV0XG5zd2lmdFxuc3dpbVxuc3dpbmdcbnN3aXRjaFxuc3dvcmRcbnN5bWJvbFxuc3ltcHRvbVxuc3lydXBcbnN5c3RlbVxudGFibGVcbnRhY2tsZVxudGFnXG50YWlsXG50YWxlbnRcbnRhbGtcbnRhbmtcbnRhcGVcbnRhcmdldFxudGFza1xudGFzdGVcbnRhdHRvb1xudGF4aVxudGVhY2hcbnRlYW1cbnRlbGxcbnRlblxudGVuYW50XG50ZW5uaXNcbnRlbnRcbnRlcm1cbnRlc3RcbnRleHRcbnRoYW5rXG50aGF0XG50aGVtZVxudGhlblxudGhlb3J5XG50aGVyZVxudGhleVxudGhpbmdcbnRoaXNcbnRob3VnaHRcbnRocmVlXG50aHJpdmVcbnRocm93XG50aHVtYlxudGh1bmRlclxudGlja2V0XG50aWRlXG50aWdlclxudGlsdFxudGltYmVyXG50aW1lXG50aW55XG50aXBcbnRpcmVkXG50aXNzdWVcbnRpdGxlXG50b2FzdFxudG9iYWNjb1xudG9kYXlcbnRvZGRsZXJcbnRvZVxudG9nZXRoZXJcbnRvaWxldFxudG9rZW5cbnRvbWF0b1xudG9tb3Jyb3dcbnRvbmVcbnRvbmd1ZVxudG9uaWdodFxudG9vbFxudG9vdGhcbnRvcFxudG9waWNcbnRvcHBsZVxudG9yY2hcbnRvcm5hZG9cbnRvcnRvaXNlXG50b3NzXG50b3RhbFxudG91cmlzdFxudG93YXJkXG50b3dlclxudG93blxudG95XG50cmFja1xudHJhZGVcbnRyYWZmaWNcbnRyYWdpY1xudHJhaW5cbnRyYW5zZmVyXG50cmFwXG50cmFzaFxudHJhdmVsXG50cmF5XG50cmVhdFxudHJlZVxudHJlbmRcbnRyaWFsXG50cmliZVxudHJpY2tcbnRyaWdnZXJcbnRyaW1cbnRyaXBcbnRyb3BoeVxudHJvdWJsZVxudHJ1Y2tcbnRydWVcbnRydWx5XG50cnVtcGV0XG50cnVzdFxudHJ1dGhcbnRyeVxudHViZVxudHVpdGlvblxudHVtYmxlXG50dW5hXG50dW5uZWxcbnR1cmtleVxudHVyblxudHVydGxlXG50d2VsdmVcbnR3ZW50eVxudHdpY2VcbnR3aW5cbnR3aXN0XG50d29cbnR5cGVcbnR5cGljYWxcbnVnbHlcbnVtYnJlbGxhXG51bmFibGVcbnVuYXdhcmVcbnVuY2xlXG51bmNvdmVyXG51bmRlclxudW5kb1xudW5mYWlyXG51bmZvbGRcbnVuaGFwcHlcbnVuaWZvcm1cbnVuaXF1ZVxudW5pdFxudW5pdmVyc2VcbnVua25vd25cbnVubG9ja1xudW50aWxcbnVudXN1YWxcbnVudmVpbFxudXBkYXRlXG51cGdyYWRlXG51cGhvbGRcbnVwb25cbnVwcGVyXG51cHNldFxudXJiYW5cbnVyZ2VcbnVzYWdlXG51c2VcbnVzZWRcbnVzZWZ1bFxudXNlbGVzc1xudXN1YWxcbnV0aWxpdHlcbnZhY2FudFxudmFjdXVtXG52YWd1ZVxudmFsaWRcbnZhbGxleVxudmFsdmVcbnZhblxudmFuaXNoXG52YXBvclxudmFyaW91c1xudmFzdFxudmF1bHRcbnZlaGljbGVcbnZlbHZldFxudmVuZG9yXG52ZW50dXJlXG52ZW51ZVxudmVyYlxudmVyaWZ5XG52ZXJzaW9uXG52ZXJ5XG52ZXNzZWxcbnZldGVyYW5cbnZpYWJsZVxudmlicmFudFxudmljaW91c1xudmljdG9yeVxudmlkZW9cbnZpZXdcbnZpbGxhZ2VcbnZpbnRhZ2VcbnZpb2xpblxudmlydHVhbFxudmlydXNcbnZpc2FcbnZpc2l0XG52aXN1YWxcbnZpdGFsXG52aXZpZFxudm9jYWxcbnZvaWNlXG52b2lkXG52b2xjYW5vXG52b2x1bWVcbnZvdGVcbnZveWFnZVxud2FnZVxud2Fnb25cbndhaXRcbndhbGtcbndhbGxcbndhbG51dFxud2FudFxud2FyZmFyZVxud2FybVxud2Fycmlvclxud2FzaFxud2FzcFxud2FzdGVcbndhdGVyXG53YXZlXG53YXlcbndlYWx0aFxud2VhcG9uXG53ZWFyXG53ZWFzZWxcbndlYXRoZXJcbndlYlxud2VkZGluZ1xud2Vla2VuZFxud2VpcmRcbndlbGNvbWVcbndlc3RcbndldFxud2hhbGVcbndoYXRcbndoZWF0XG53aGVlbFxud2hlblxud2hlcmVcbndoaXBcbndoaXNwZXJcbndpZGVcbndpZHRoXG53aWZlXG53aWxkXG53aWxsXG53aW5cbndpbmRvd1xud2luZVxud2luZ1xud2lua1xud2lubmVyXG53aW50ZXJcbndpcmVcbndpc2RvbVxud2lzZVxud2lzaFxud2l0bmVzc1xud29sZlxud29tYW5cbndvbmRlclxud29vZFxud29vbFxud29yZFxud29ya1xud29ybGRcbndvcnJ5XG53b3J0aFxud3JhcFxud3JlY2tcbndyZXN0bGVcbndyaXN0XG53cml0ZVxud3JvbmdcbnlhcmRcbnllYXJcbnllbGxvd1xueW91XG55b3VuZ1xueW91dGhcbnplYnJhXG56ZXJvXG56b25lXG56b29gLnNwbGl0KCdcXG4nKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@cashu/crypto/node_modules/@scure/bip39/wordlists/english.js\n");

/***/ })

};
;