"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@nostr-dev-kit+ndk@2.14.24_nostr-tools@2.14.2_typescript@5.8.3_";
exports.ids = ["vendor-chunks/@nostr-dev-kit+ndk@2.14.24_nostr-tools@2.14.2_typescript@5.8.3_"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@nostr-dev-kit+ndk@2.14.24_nostr-tools@2.14.2_typescript@5.8.3_/node_modules/@nostr-dev-kit/ndk/dist/index.mjs":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@nostr-dev-kit+ndk@2.14.24_nostr-tools@2.14.2_typescript@5.8.3_/node_modules/@nostr-dev-kit/ndk/dist/index.mjs ***!
  \*******************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BECH32_REGEX: () => (/* binding */ BECH32_REGEX),\n/* harmony export */   NDKAppHandlerEvent: () => (/* binding */ NDKAppHandlerEvent),\n/* harmony export */   NDKAppSettings: () => (/* binding */ NDKAppSettings),\n/* harmony export */   NDKArticle: () => (/* binding */ NDKArticle),\n/* harmony export */   NDKBlossomList: () => (/* binding */ NDKBlossomList),\n/* harmony export */   NDKCashuMintList: () => (/* binding */ NDKCashuMintList),\n/* harmony export */   NDKCashuToken: () => (/* binding */ NDKCashuToken),\n/* harmony export */   NDKCashuWalletTx: () => (/* binding */ NDKCashuWalletTx),\n/* harmony export */   NDKClassified: () => (/* binding */ NDKClassified),\n/* harmony export */   NDKDVMJobFeedback: () => (/* binding */ NDKDVMJobFeedback),\n/* harmony export */   NDKDVMJobResult: () => (/* binding */ NDKDVMJobResult),\n/* harmony export */   NDKDVMRequest: () => (/* binding */ NDKDVMRequest),\n/* harmony export */   NDKDraft: () => (/* binding */ NDKDraft),\n/* harmony export */   NDKDvmJobFeedbackStatus: () => (/* binding */ NDKDvmJobFeedbackStatus),\n/* harmony export */   NDKEvent: () => (/* binding */ NDKEvent),\n/* harmony export */   NDKFollowPack: () => (/* binding */ NDKFollowPack),\n/* harmony export */   NDKHighlight: () => (/* binding */ NDKHighlight),\n/* harmony export */   NDKImage: () => (/* binding */ NDKImage),\n/* harmony export */   NDKKind: () => (/* binding */ NDKKind),\n/* harmony export */   NDKList: () => (/* binding */ NDKList),\n/* harmony export */   NDKListKinds: () => (/* binding */ NDKListKinds),\n/* harmony export */   NDKNip07Signer: () => (/* binding */ NDKNip07Signer),\n/* harmony export */   NDKNip46Backend: () => (/* binding */ NDKNip46Backend),\n/* harmony export */   NDKNip46Signer: () => (/* binding */ NDKNip46Signer),\n/* harmony export */   NDKNostrRpc: () => (/* binding */ NDKNostrRpc),\n/* harmony export */   NDKNutzap: () => (/* binding */ NDKNutzap),\n/* harmony export */   NDKPool: () => (/* binding */ NDKPool),\n/* harmony export */   NDKPrivateKeySigner: () => (/* binding */ NDKPrivateKeySigner),\n/* harmony export */   NDKPublishError: () => (/* binding */ NDKPublishError),\n/* harmony export */   NDKRelay: () => (/* binding */ NDKRelay),\n/* harmony export */   NDKRelayAuthPolicies: () => (/* binding */ NDKRelayAuthPolicies),\n/* harmony export */   NDKRelayList: () => (/* binding */ NDKRelayList),\n/* harmony export */   NDKRelaySet: () => (/* binding */ NDKRelaySet),\n/* harmony export */   NDKRelayStatus: () => (/* binding */ NDKRelayStatus),\n/* harmony export */   NDKRepost: () => (/* binding */ NDKRepost),\n/* harmony export */   NDKSimpleGroup: () => (/* binding */ NDKSimpleGroup),\n/* harmony export */   NDKSimpleGroupMemberList: () => (/* binding */ NDKSimpleGroupMemberList),\n/* harmony export */   NDKSimpleGroupMetadata: () => (/* binding */ NDKSimpleGroupMetadata),\n/* harmony export */   NDKStory: () => (/* binding */ NDKStory),\n/* harmony export */   NDKStorySticker: () => (/* binding */ NDKStorySticker),\n/* harmony export */   NDKStoryStickerType: () => (/* binding */ NDKStoryStickerType),\n/* harmony export */   NDKSubscription: () => (/* binding */ NDKSubscription),\n/* harmony export */   NDKSubscriptionCacheUsage: () => (/* binding */ NDKSubscriptionCacheUsage),\n/* harmony export */   NDKSubscriptionReceipt: () => (/* binding */ NDKSubscriptionReceipt),\n/* harmony export */   NDKSubscriptionStart: () => (/* binding */ NDKSubscriptionStart),\n/* harmony export */   NDKSubscriptionTier: () => (/* binding */ NDKSubscriptionTier),\n/* harmony export */   NDKTranscriptionDVM: () => (/* binding */ NDKTranscriptionDVM),\n/* harmony export */   NDKUser: () => (/* binding */ NDKUser),\n/* harmony export */   NDKVideo: () => (/* binding */ NDKVideo),\n/* harmony export */   NDKWiki: () => (/* binding */ NDKWiki),\n/* harmony export */   NDKWikiMergeRequest: () => (/* binding */ NDKWikiMergeRequest),\n/* harmony export */   NDKZapper: () => (/* binding */ NDKZapper),\n/* harmony export */   NIP33_A_REGEX: () => (/* binding */ NIP33_A_REGEX),\n/* harmony export */   NdkNutzapStatus: () => (/* binding */ NdkNutzapStatus),\n/* harmony export */   SignatureVerificationStats: () => (/* binding */ SignatureVerificationStats),\n/* harmony export */   calculateRelaySetFromEvent: () => (/* binding */ calculateRelaySetFromEvent),\n/* harmony export */   calculateTermDurationInSeconds: () => (/* binding */ calculateTermDurationInSeconds),\n/* harmony export */   cashuPubkeyToNostrPubkey: () => (/* binding */ cashuPubkeyToNostrPubkey),\n/* harmony export */   compareFilter: () => (/* binding */ compareFilter),\n/* harmony export */   \"default\": () => (/* binding */ NDK),\n/* harmony export */   defaultOpts: () => (/* binding */ defaultOpts),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   dvmSchedule: () => (/* binding */ dvmSchedule),\n/* harmony export */   eventHasETagMarkers: () => (/* binding */ eventHasETagMarkers),\n/* harmony export */   eventIsPartOfThread: () => (/* binding */ eventIsPartOfThread),\n/* harmony export */   eventIsReply: () => (/* binding */ eventIsReply),\n/* harmony export */   eventReplies: () => (/* binding */ eventReplies),\n/* harmony export */   eventThreadIds: () => (/* binding */ eventThreadIds),\n/* harmony export */   eventThreads: () => (/* binding */ eventThreads),\n/* harmony export */   eventsBySameAuthor: () => (/* binding */ eventsBySameAuthor),\n/* harmony export */   filterAndRelaySetFromBech32: () => (/* binding */ filterAndRelaySetFromBech32),\n/* harmony export */   filterFingerprint: () => (/* binding */ filterFingerprint),\n/* harmony export */   filterForEventsTaggingId: () => (/* binding */ filterForEventsTaggingId),\n/* harmony export */   filterFromId: () => (/* binding */ filterFromId),\n/* harmony export */   generateContentTags: () => (/* binding */ generateContentTags),\n/* harmony export */   generateHashtags: () => (/* binding */ generateHashtags),\n/* harmony export */   generateSubId: () => (/* binding */ generateSubId),\n/* harmony export */   generateZapRequest: () => (/* binding */ generateZapRequest),\n/* harmony export */   getEventReplyId: () => (/* binding */ getEventReplyId),\n/* harmony export */   getNip57ZapSpecFromLud: () => (/* binding */ getNip57ZapSpecFromLud),\n/* harmony export */   getRelayListForUser: () => (/* binding */ getRelayListForUser),\n/* harmony export */   getRelayListForUsers: () => (/* binding */ getRelayListForUsers),\n/* harmony export */   getReplyTag: () => (/* binding */ getReplyTag),\n/* harmony export */   getRootEventId: () => (/* binding */ getRootEventId),\n/* harmony export */   getRootTag: () => (/* binding */ getRootTag),\n/* harmony export */   giftUnwrap: () => (/* binding */ giftUnwrap),\n/* harmony export */   giftWrap: () => (/* binding */ giftWrap),\n/* harmony export */   imetaTagToTag: () => (/* binding */ imetaTagToTag),\n/* harmony export */   isEventOriginalPost: () => (/* binding */ isEventOriginalPost),\n/* harmony export */   isNip33AValue: () => (/* binding */ isNip33AValue),\n/* harmony export */   mapImetaTag: () => (/* binding */ mapImetaTag),\n/* harmony export */   matchFilter: () => (/* binding */ matchFilter),\n/* harmony export */   mergeFilters: () => (/* binding */ mergeFilters),\n/* harmony export */   mergeTags: () => (/* binding */ mergeTags),\n/* harmony export */   ndkSignerFromPayload: () => (/* binding */ ndkSignerFromPayload),\n/* harmony export */   newAmount: () => (/* binding */ newAmount),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   normalizeRelayUrl: () => (/* binding */ normalizeRelayUrl),\n/* harmony export */   normalizeUrl: () => (/* binding */ normalizeUrl),\n/* harmony export */   parseTagToSubscriptionAmount: () => (/* binding */ parseTagToSubscriptionAmount),\n/* harmony export */   pinEvent: () => (/* binding */ pinEvent),\n/* harmony export */   possibleIntervalFrequencies: () => (/* binding */ possibleIntervalFrequencies),\n/* harmony export */   profileFromEvent: () => (/* binding */ profileFromEvent),\n/* harmony export */   proofP2pk: () => (/* binding */ proofP2pk),\n/* harmony export */   proofP2pkNostr: () => (/* binding */ proofP2pkNostr),\n/* harmony export */   proofsTotalBalance: () => (/* binding */ proofsTotalBalance),\n/* harmony export */   queryFullyFilled: () => (/* binding */ queryFullyFilled),\n/* harmony export */   registerSigner: () => (/* binding */ registerSigner),\n/* harmony export */   relayListFromKind3: () => (/* binding */ relayListFromKind3),\n/* harmony export */   relaysFromBech32: () => (/* binding */ relaysFromBech32),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializeProfile: () => (/* binding */ serializeProfile),\n/* harmony export */   startSignatureVerificationStats: () => (/* binding */ startSignatureVerificationStats),\n/* harmony export */   strToDimension: () => (/* binding */ strToDimension),\n/* harmony export */   strToPosition: () => (/* binding */ strToPosition),\n/* harmony export */   tryNormalizeRelayUrl: () => (/* binding */ tryNormalizeRelayUrl),\n/* harmony export */   uniqueTag: () => (/* binding */ uniqueTag),\n/* harmony export */   wrapEvent: () => (/* binding */ wrapEvent),\n/* harmony export */   zapInvoiceFromEvent: () => (/* binding */ zapInvoiceFromEvent)\n/* harmony export */ });\n/* harmony import */ var tseep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tseep */ \"(ssr)/./node_modules/.pnpm/tseep@1.3.1/node_modules/tseep/lib/index.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/index.js\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nostr-tools */ \"(ssr)/./node_modules/.pnpm/nostr-tools@2.14.2_typescript@5.8.3/node_modules/nostr-tools/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! typescript-lru-cache */ \"(ssr)/./node_modules/.pnpm/typescript-lru-cache@2.0.0/node_modules/typescript-lru-cache/dist/index.js\");\n/* harmony import */ var light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! light-bolt11-decoder */ \"(ssr)/./node_modules/.pnpm/light-bolt11-decoder@3.2.0/node_modules/light-bolt11-decoder/bolt11.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/.pnpm/@scure+base@1.2.6/node_modules/@scure/base/lib/esm/index.js\");\n// src/types.ts\nvar NdkNutzapStatus = /* @__PURE__ */ ((NdkNutzapStatus2) => {\n  NdkNutzapStatus2[\"INITIAL\"] = \"initial\";\n  NdkNutzapStatus2[\"PROCESSING\"] = \"processing\";\n  NdkNutzapStatus2[\"REDEEMED\"] = \"redeemed\";\n  NdkNutzapStatus2[\"SPENT\"] = \"spent\";\n  NdkNutzapStatus2[\"MISSING_PRIVKEY\"] = \"missing_privkey\";\n  NdkNutzapStatus2[\"TEMPORARY_ERROR\"] = \"temporary_error\";\n  NdkNutzapStatus2[\"PERMANENT_ERROR\"] = \"permanent_error\";\n  NdkNutzapStatus2[\"INVALID_NUTZAP\"] = \"invalid_nutzap\";\n  return NdkNutzapStatus2;\n})(NdkNutzapStatus || {});\n\n// src/events/kinds/index.ts\nvar NDKKind = /* @__PURE__ */ ((NDKKind2) => {\n  NDKKind2[NDKKind2[\"Metadata\"] = 0] = \"Metadata\";\n  NDKKind2[NDKKind2[\"Text\"] = 1] = \"Text\";\n  NDKKind2[NDKKind2[\"RecommendRelay\"] = 2] = \"RecommendRelay\";\n  NDKKind2[NDKKind2[\"Contacts\"] = 3] = \"Contacts\";\n  NDKKind2[NDKKind2[\"EncryptedDirectMessage\"] = 4] = \"EncryptedDirectMessage\";\n  NDKKind2[NDKKind2[\"EventDeletion\"] = 5] = \"EventDeletion\";\n  NDKKind2[NDKKind2[\"Repost\"] = 6] = \"Repost\";\n  NDKKind2[NDKKind2[\"Reaction\"] = 7] = \"Reaction\";\n  NDKKind2[NDKKind2[\"BadgeAward\"] = 8] = \"BadgeAward\";\n  NDKKind2[NDKKind2[\"GroupChat\"] = 9] = \"GroupChat\";\n  NDKKind2[NDKKind2[\"GroupNote\"] = 11] = \"GroupNote\";\n  NDKKind2[NDKKind2[\"GroupReply\"] = 12] = \"GroupReply\";\n  NDKKind2[NDKKind2[\"GiftWrapSeal\"] = 13] = \"GiftWrapSeal\";\n  NDKKind2[NDKKind2[\"PrivateDirectMessage\"] = 14] = \"PrivateDirectMessage\";\n  NDKKind2[NDKKind2[\"Image\"] = 20] = \"Image\";\n  NDKKind2[NDKKind2[\"Video\"] = 21] = \"Video\";\n  NDKKind2[NDKKind2[\"ShortVideo\"] = 22] = \"ShortVideo\";\n  NDKKind2[NDKKind2[\"Story\"] = 23] = \"Story\";\n  NDKKind2[NDKKind2[\"Vanish\"] = 62] = \"Vanish\";\n  NDKKind2[NDKKind2[\"CashuWalletBackup\"] = 375] = \"CashuWalletBackup\";\n  NDKKind2[NDKKind2[\"GiftWrap\"] = 1059] = \"GiftWrap\";\n  NDKKind2[NDKKind2[\"GenericRepost\"] = 16] = \"GenericRepost\";\n  NDKKind2[NDKKind2[\"ChannelCreation\"] = 40] = \"ChannelCreation\";\n  NDKKind2[NDKKind2[\"ChannelMetadata\"] = 41] = \"ChannelMetadata\";\n  NDKKind2[NDKKind2[\"ChannelMessage\"] = 42] = \"ChannelMessage\";\n  NDKKind2[NDKKind2[\"ChannelHideMessage\"] = 43] = \"ChannelHideMessage\";\n  NDKKind2[NDKKind2[\"ChannelMuteUser\"] = 44] = \"ChannelMuteUser\";\n  NDKKind2[NDKKind2[\"WikiMergeRequest\"] = 818] = \"WikiMergeRequest\";\n  NDKKind2[NDKKind2[\"GenericReply\"] = 1111] = \"GenericReply\";\n  NDKKind2[NDKKind2[\"Media\"] = 1063] = \"Media\";\n  NDKKind2[NDKKind2[\"DraftCheckpoint\"] = 1234] = \"DraftCheckpoint\";\n  NDKKind2[NDKKind2[\"Report\"] = 1984] = \"Report\";\n  NDKKind2[NDKKind2[\"Label\"] = 1985] = \"Label\";\n  NDKKind2[NDKKind2[\"DVMReqTextExtraction\"] = 5e3] = \"DVMReqTextExtraction\";\n  NDKKind2[NDKKind2[\"DVMReqTextSummarization\"] = 5001] = \"DVMReqTextSummarization\";\n  NDKKind2[NDKKind2[\"DVMReqTextTranslation\"] = 5002] = \"DVMReqTextTranslation\";\n  NDKKind2[NDKKind2[\"DVMReqTextGeneration\"] = 5050] = \"DVMReqTextGeneration\";\n  NDKKind2[NDKKind2[\"DVMReqImageGeneration\"] = 5100] = \"DVMReqImageGeneration\";\n  NDKKind2[NDKKind2[\"DVMReqTextToSpeech\"] = 5250] = \"DVMReqTextToSpeech\";\n  NDKKind2[NDKKind2[\"DVMReqDiscoveryNostrContent\"] = 5300] = \"DVMReqDiscoveryNostrContent\";\n  NDKKind2[NDKKind2[\"DVMReqDiscoveryNostrPeople\"] = 5301] = \"DVMReqDiscoveryNostrPeople\";\n  NDKKind2[NDKKind2[\"DVMReqTimestamping\"] = 5900] = \"DVMReqTimestamping\";\n  NDKKind2[NDKKind2[\"DVMEventSchedule\"] = 5905] = \"DVMEventSchedule\";\n  NDKKind2[NDKKind2[\"DVMJobFeedback\"] = 7e3] = \"DVMJobFeedback\";\n  NDKKind2[NDKKind2[\"Subscribe\"] = 7001] = \"Subscribe\";\n  NDKKind2[NDKKind2[\"Unsubscribe\"] = 7002] = \"Unsubscribe\";\n  NDKKind2[NDKKind2[\"SubscriptionReceipt\"] = 7003] = \"SubscriptionReceipt\";\n  NDKKind2[NDKKind2[\"CashuReserve\"] = 7373] = \"CashuReserve\";\n  NDKKind2[NDKKind2[\"CashuQuote\"] = 7374] = \"CashuQuote\";\n  NDKKind2[NDKKind2[\"CashuToken\"] = 7375] = \"CashuToken\";\n  NDKKind2[NDKKind2[\"CashuWalletTx\"] = 7376] = \"CashuWalletTx\";\n  NDKKind2[NDKKind2[\"GroupAdminAddUser\"] = 9e3] = \"GroupAdminAddUser\";\n  NDKKind2[NDKKind2[\"GroupAdminRemoveUser\"] = 9001] = \"GroupAdminRemoveUser\";\n  NDKKind2[NDKKind2[\"GroupAdminEditMetadata\"] = 9002] = \"GroupAdminEditMetadata\";\n  NDKKind2[NDKKind2[\"GroupAdminEditStatus\"] = 9006] = \"GroupAdminEditStatus\";\n  NDKKind2[NDKKind2[\"GroupAdminCreateGroup\"] = 9007] = \"GroupAdminCreateGroup\";\n  NDKKind2[NDKKind2[\"GroupAdminRequestJoin\"] = 9021] = \"GroupAdminRequestJoin\";\n  NDKKind2[NDKKind2[\"MuteList\"] = 1e4] = \"MuteList\";\n  NDKKind2[NDKKind2[\"PinList\"] = 10001] = \"PinList\";\n  NDKKind2[NDKKind2[\"RelayList\"] = 10002] = \"RelayList\";\n  NDKKind2[NDKKind2[\"BookmarkList\"] = 10003] = \"BookmarkList\";\n  NDKKind2[NDKKind2[\"CommunityList\"] = 10004] = \"CommunityList\";\n  NDKKind2[NDKKind2[\"PublicChatList\"] = 10005] = \"PublicChatList\";\n  NDKKind2[NDKKind2[\"BlockRelayList\"] = 10006] = \"BlockRelayList\";\n  NDKKind2[NDKKind2[\"SearchRelayList\"] = 10007] = \"SearchRelayList\";\n  NDKKind2[NDKKind2[\"SimpleGroupList\"] = 10009] = \"SimpleGroupList\";\n  NDKKind2[NDKKind2[\"InterestList\"] = 10015] = \"InterestList\";\n  NDKKind2[NDKKind2[\"CashuMintList\"] = 10019] = \"CashuMintList\";\n  NDKKind2[NDKKind2[\"EmojiList\"] = 10030] = \"EmojiList\";\n  NDKKind2[NDKKind2[\"DirectMessageReceiveRelayList\"] = 10050] = \"DirectMessageReceiveRelayList\";\n  NDKKind2[NDKKind2[\"BlossomList\"] = 10063] = \"BlossomList\";\n  NDKKind2[NDKKind2[\"NostrWaletConnectInfo\"] = 13194] = \"NostrWaletConnectInfo\";\n  NDKKind2[NDKKind2[\"TierList\"] = 17e3] = \"TierList\";\n  NDKKind2[NDKKind2[\"CashuWallet\"] = 17375] = \"CashuWallet\";\n  NDKKind2[NDKKind2[\"FollowSet\"] = 3e4] = \"FollowSet\";\n  NDKKind2[NDKKind2[\"CategorizedPeopleList\"] = 3e4 /* FollowSet */] = \"CategorizedPeopleList\";\n  NDKKind2[NDKKind2[\"CategorizedBookmarkList\"] = 30001] = \"CategorizedBookmarkList\";\n  NDKKind2[NDKKind2[\"RelaySet\"] = 30002] = \"RelaySet\";\n  NDKKind2[NDKKind2[\"CategorizedRelayList\"] = 30002 /* RelaySet */] = \"CategorizedRelayList\";\n  NDKKind2[NDKKind2[\"BookmarkSet\"] = 30003] = \"BookmarkSet\";\n  NDKKind2[NDKKind2[\"CurationSet\"] = 30004] = \"CurationSet\";\n  NDKKind2[NDKKind2[\"ArticleCurationSet\"] = 30004] = \"ArticleCurationSet\";\n  NDKKind2[NDKKind2[\"VideoCurationSet\"] = 30005] = \"VideoCurationSet\";\n  NDKKind2[NDKKind2[\"ImageCurationSet\"] = 30006] = \"ImageCurationSet\";\n  NDKKind2[NDKKind2[\"InterestSet\"] = 30015] = \"InterestSet\";\n  NDKKind2[NDKKind2[\"InterestsList\"] = 30015 /* InterestSet */] = \"InterestsList\";\n  NDKKind2[NDKKind2[\"EmojiSet\"] = 30030] = \"EmojiSet\";\n  NDKKind2[NDKKind2[\"ModularArticle\"] = 30040] = \"ModularArticle\";\n  NDKKind2[NDKKind2[\"ModularArticleItem\"] = 30041] = \"ModularArticleItem\";\n  NDKKind2[NDKKind2[\"Wiki\"] = 30818] = \"Wiki\";\n  NDKKind2[NDKKind2[\"Draft\"] = 31234] = \"Draft\";\n  NDKKind2[NDKKind2[\"SubscriptionTier\"] = 37001] = \"SubscriptionTier\";\n  NDKKind2[NDKKind2[\"EcashMintRecommendation\"] = 38e3] = \"EcashMintRecommendation\";\n  NDKKind2[NDKKind2[\"HighlightSet\"] = 39802] = \"HighlightSet\";\n  NDKKind2[NDKKind2[\"CategorizedHighlightList\"] = 39802 /* HighlightSet */] = \"CategorizedHighlightList\";\n  NDKKind2[NDKKind2[\"Nutzap\"] = 9321] = \"Nutzap\";\n  NDKKind2[NDKKind2[\"ZapRequest\"] = 9734] = \"ZapRequest\";\n  NDKKind2[NDKKind2[\"Zap\"] = 9735] = \"Zap\";\n  NDKKind2[NDKKind2[\"Highlight\"] = 9802] = \"Highlight\";\n  NDKKind2[NDKKind2[\"ClientAuth\"] = 22242] = \"ClientAuth\";\n  NDKKind2[NDKKind2[\"NostrWalletConnectReq\"] = 23194] = \"NostrWalletConnectReq\";\n  NDKKind2[NDKKind2[\"NostrWalletConnectRes\"] = 23195] = \"NostrWalletConnectRes\";\n  NDKKind2[NDKKind2[\"NostrConnect\"] = 24133] = \"NostrConnect\";\n  NDKKind2[NDKKind2[\"BlossomUpload\"] = 24242] = \"BlossomUpload\";\n  NDKKind2[NDKKind2[\"HttpAuth\"] = 27235] = \"HttpAuth\";\n  NDKKind2[NDKKind2[\"ProfileBadge\"] = 30008] = \"ProfileBadge\";\n  NDKKind2[NDKKind2[\"BadgeDefinition\"] = 30009] = \"BadgeDefinition\";\n  NDKKind2[NDKKind2[\"MarketStall\"] = 30017] = \"MarketStall\";\n  NDKKind2[NDKKind2[\"MarketProduct\"] = 30018] = \"MarketProduct\";\n  NDKKind2[NDKKind2[\"Article\"] = 30023] = \"Article\";\n  NDKKind2[NDKKind2[\"AppSpecificData\"] = 30078] = \"AppSpecificData\";\n  NDKKind2[NDKKind2[\"Classified\"] = 30402] = \"Classified\";\n  NDKKind2[NDKKind2[\"HorizontalVideo\"] = 34235] = \"HorizontalVideo\";\n  NDKKind2[NDKKind2[\"VerticalVideo\"] = 34236] = \"VerticalVideo\";\n  NDKKind2[NDKKind2[\"LegacyCashuWallet\"] = 37375] = \"LegacyCashuWallet\";\n  NDKKind2[NDKKind2[\"GroupMetadata\"] = 39e3] = \"GroupMetadata\";\n  NDKKind2[NDKKind2[\"GroupAdmins\"] = 39001] = \"GroupAdmins\";\n  NDKKind2[NDKKind2[\"GroupMembers\"] = 39002] = \"GroupMembers\";\n  NDKKind2[NDKKind2[\"FollowPack\"] = 39089] = \"FollowPack\";\n  NDKKind2[NDKKind2[\"MediaFollowPack\"] = 39092] = \"MediaFollowPack\";\n  NDKKind2[NDKKind2[\"AppRecommendation\"] = 31989] = \"AppRecommendation\";\n  NDKKind2[NDKKind2[\"AppHandler\"] = 31990] = \"AppHandler\";\n  return NDKKind2;\n})(NDKKind || {});\nvar NDKListKinds = [\n  1e4 /* MuteList */,\n  10001 /* PinList */,\n  10002 /* RelayList */,\n  10003 /* BookmarkList */,\n  10004 /* CommunityList */,\n  10005 /* PublicChatList */,\n  10006 /* BlockRelayList */,\n  10007 /* SearchRelayList */,\n  10015 /* InterestList */,\n  10030 /* EmojiList */,\n  10050 /* DirectMessageReceiveRelayList */,\n  3e4 /* FollowSet */,\n  30003 /* BookmarkSet */,\n  30001 /* CategorizedBookmarkList */,\n  // Backwards compatibility\n  30002 /* RelaySet */,\n  30004 /* ArticleCurationSet */,\n  30005 /* VideoCurationSet */,\n  30015 /* InterestSet */,\n  30030 /* EmojiSet */,\n  39802 /* HighlightSet */\n];\n\n// src/events/index.ts\n\n\n// src/relay/sets/calculate.ts\n\n\n// src/outbox/write.ts\nfunction getRelaysForSync(ndk, author, type = \"write\") {\n  if (!ndk.outboxTracker) return void 0;\n  const item = ndk.outboxTracker.data.get(author);\n  if (!item) return void 0;\n  if (type === \"write\") {\n    return item.writeRelays;\n  }\n  return item.readRelays;\n}\nasync function getWriteRelaysFor(ndk, author, type = \"write\") {\n  if (!ndk.outboxTracker) return void 0;\n  if (!ndk.outboxTracker.data.has(author)) {\n    await ndk.outboxTracker.trackUsers([author]);\n  }\n  return getRelaysForSync(ndk, author, type);\n}\n\n// src/outbox/relay-ranking.ts\nfunction getTopRelaysForAuthors(ndk, authors) {\n  const relaysWithCount = /* @__PURE__ */ new Map();\n  authors.forEach((author) => {\n    const writeRelays = getRelaysForSync(ndk, author);\n    if (writeRelays) {\n      writeRelays.forEach((relay) => {\n        const count = relaysWithCount.get(relay) || 0;\n        relaysWithCount.set(relay, count + 1);\n      });\n    }\n  });\n  const sortedRelays = Array.from(relaysWithCount.entries()).sort((a, b) => b[1] - a[1]);\n  return sortedRelays.map((entry) => entry[0]);\n}\n\n// src/outbox/index.ts\nfunction getAllRelaysForAllPubkeys(ndk, pubkeys, type = \"read\") {\n  const pubkeysToRelays = /* @__PURE__ */ new Map();\n  const authorsMissingRelays = /* @__PURE__ */ new Set();\n  pubkeys.forEach((pubkey) => {\n    const relays = getRelaysForSync(ndk, pubkey, type);\n    if (relays && relays.size > 0) {\n      relays.forEach((relay) => {\n        const pubkeysInRelay = pubkeysToRelays.get(relay) || /* @__PURE__ */ new Set();\n        pubkeysInRelay.add(pubkey);\n      });\n      pubkeysToRelays.set(pubkey, relays);\n    } else {\n      authorsMissingRelays.add(pubkey);\n    }\n  });\n  return { pubkeysToRelays, authorsMissingRelays };\n}\nfunction chooseRelayCombinationForPubkeys(ndk, pubkeys, type, { count, preferredRelays } = {}) {\n  count ??= 2;\n  preferredRelays ??= /* @__PURE__ */ new Set();\n  const pool = ndk.pool;\n  const connectedRelays = pool.connectedRelays();\n  connectedRelays.forEach((relay) => {\n    preferredRelays?.add(relay.url);\n  });\n  const relayToAuthorsMap = /* @__PURE__ */ new Map();\n  const { pubkeysToRelays, authorsMissingRelays } = getAllRelaysForAllPubkeys(ndk, pubkeys, type);\n  const sortedRelays = getTopRelaysForAuthors(ndk, pubkeys);\n  const addAuthorToRelay = (author, relay) => {\n    const authorsInRelay = relayToAuthorsMap.get(relay) || [];\n    authorsInRelay.push(author);\n    relayToAuthorsMap.set(relay, authorsInRelay);\n  };\n  for (const [author, authorRelays] of pubkeysToRelays.entries()) {\n    let missingRelayCount = count;\n    for (const relay of connectedRelays) {\n      if (authorRelays.has(relay.url)) {\n        addAuthorToRelay(author, relay.url);\n        missingRelayCount--;\n      }\n    }\n    for (const authorRelay of authorRelays) {\n      if (relayToAuthorsMap.has(authorRelay)) {\n        addAuthorToRelay(author, authorRelay);\n        missingRelayCount--;\n      }\n    }\n    if (missingRelayCount <= 0) continue;\n    for (const relay of sortedRelays) {\n      if (missingRelayCount <= 0) break;\n      if (authorRelays.has(relay)) {\n        addAuthorToRelay(author, relay);\n        missingRelayCount--;\n      }\n    }\n  }\n  for (const author of authorsMissingRelays) {\n    pool.permanentAndConnectedRelays().forEach((relay) => {\n      const authorsInRelay = relayToAuthorsMap.get(relay.url) || [];\n      authorsInRelay.push(author);\n      relayToAuthorsMap.set(relay.url, authorsInRelay);\n    });\n  }\n  return relayToAuthorsMap;\n}\n\n// src/outbox/read/with-authors.ts\nfunction getRelaysForFilterWithAuthors(ndk, authors, relayGoalPerAuthor = 2) {\n  return chooseRelayCombinationForPubkeys(ndk, authors, \"write\", { count: relayGoalPerAuthor });\n}\n\n// src/utils/normalize-url.ts\nfunction tryNormalizeRelayUrl(url) {\n  try {\n    return normalizeRelayUrl(url);\n  } catch {\n    return void 0;\n  }\n}\nfunction normalizeRelayUrl(url) {\n  let r = normalizeUrl(url, {\n    stripAuthentication: false,\n    stripWWW: false,\n    stripHash: true\n  });\n  if (!r.endsWith(\"/\")) {\n    r += \"/\";\n  }\n  return r;\n}\nfunction normalize(urls) {\n  const normalized = /* @__PURE__ */ new Set();\n  for (const url of urls) {\n    try {\n      normalized.add(normalizeRelayUrl(url));\n    } catch {\n    }\n  }\n  return Array.from(normalized);\n}\nvar DATA_URL_DEFAULT_MIME_TYPE = \"text/plain\";\nvar DATA_URL_DEFAULT_CHARSET = \"us-ascii\";\nvar testParameter = (name, filters) => filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);\nvar supportedProtocols = /* @__PURE__ */ new Set([\"https:\", \"http:\", \"file:\"]);\nvar hasCustomProtocol = (urlString) => {\n  try {\n    const { protocol } = new URL(urlString);\n    return protocol.endsWith(\":\") && !protocol.includes(\".\") && !supportedProtocols.has(protocol);\n  } catch {\n    return false;\n  }\n};\nvar normalizeDataURL = (urlString, { stripHash }) => {\n  const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);\n  if (!match) {\n    throw new Error(`Invalid URL: ${urlString}`);\n  }\n  const type = match.groups?.type ?? \"\";\n  const data = match.groups?.data ?? \"\";\n  let hash = match.groups?.hash ?? \"\";\n  const mediaType = type.split(\";\");\n  hash = stripHash ? \"\" : hash;\n  let isBase64 = false;\n  if (mediaType[mediaType.length - 1] === \"base64\") {\n    mediaType.pop();\n    isBase64 = true;\n  }\n  const mimeType = mediaType.shift()?.toLowerCase() ?? \"\";\n  const attributes = mediaType.map((attribute) => {\n    let [key, value = \"\"] = attribute.split(\"=\").map((string) => string.trim());\n    if (key === \"charset\") {\n      value = value.toLowerCase();\n      if (value === DATA_URL_DEFAULT_CHARSET) {\n        return \"\";\n      }\n    }\n    return `${key}${value ? `=${value}` : \"\"}`;\n  }).filter(Boolean);\n  const normalizedMediaType = [...attributes];\n  if (isBase64) {\n    normalizedMediaType.push(\"base64\");\n  }\n  if (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {\n    normalizedMediaType.unshift(mimeType);\n  }\n  return `data:${normalizedMediaType.join(\";\")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : \"\"}`;\n};\nfunction normalizeUrl(urlString, options = {}) {\n  options = {\n    defaultProtocol: \"http\",\n    normalizeProtocol: true,\n    forceHttp: false,\n    forceHttps: false,\n    stripAuthentication: true,\n    stripHash: false,\n    stripTextFragment: true,\n    stripWWW: true,\n    removeQueryParameters: [/^utm_\\w+/i],\n    removeTrailingSlash: true,\n    removeSingleSlash: true,\n    removeDirectoryIndex: false,\n    removeExplicitPort: false,\n    sortQueryParameters: true,\n    ...options\n  };\n  if (typeof options.defaultProtocol === \"string\" && !options.defaultProtocol.endsWith(\":\")) {\n    options.defaultProtocol = `${options.defaultProtocol}:`;\n  }\n  urlString = urlString.trim();\n  if (/^data:/i.test(urlString)) {\n    return normalizeDataURL(urlString, options);\n  }\n  if (hasCustomProtocol(urlString)) {\n    return urlString;\n  }\n  const hasRelativeProtocol = urlString.startsWith(\"//\");\n  const isRelativeUrl = !hasRelativeProtocol && /^\\.*\\//.test(urlString);\n  if (!isRelativeUrl) {\n    urlString = urlString.replace(/^(?!(?:\\w+:)?\\/\\/)|^\\/\\//, options.defaultProtocol);\n  }\n  const urlObject = new URL(urlString);\n  urlObject.hostname = urlObject.hostname.toLowerCase();\n  if (options.forceHttp && options.forceHttps) {\n    throw new Error(\"The `forceHttp` and `forceHttps` options cannot be used together\");\n  }\n  if (options.forceHttp && urlObject.protocol === \"https:\") {\n    urlObject.protocol = \"http:\";\n  }\n  if (options.forceHttps && urlObject.protocol === \"http:\") {\n    urlObject.protocol = \"https:\";\n  }\n  if (options.stripAuthentication) {\n    urlObject.username = \"\";\n    urlObject.password = \"\";\n  }\n  if (options.stripHash) {\n    urlObject.hash = \"\";\n  } else if (options.stripTextFragment) {\n    urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, \"\");\n  }\n  if (urlObject.pathname) {\n    const protocolRegex = /\\b[a-z][a-z\\d+\\-.]{1,50}:\\/\\//g;\n    let lastIndex = 0;\n    let result = \"\";\n    for (; ; ) {\n      const match = protocolRegex.exec(urlObject.pathname);\n      if (!match) {\n        break;\n      }\n      const protocol = match[0];\n      const protocolAtIndex = match.index;\n      const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);\n      result += intermediate.replace(/\\/{2,}/g, \"/\");\n      result += protocol;\n      lastIndex = protocolAtIndex + protocol.length;\n    }\n    const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);\n    result += remnant.replace(/\\/{2,}/g, \"/\");\n    urlObject.pathname = result;\n  }\n  if (urlObject.pathname) {\n    try {\n      urlObject.pathname = decodeURI(urlObject.pathname);\n    } catch {\n    }\n  }\n  if (options.removeDirectoryIndex === true) {\n    options.removeDirectoryIndex = [/^index\\.[a-z]+$/];\n  }\n  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {\n    let pathComponents = urlObject.pathname.split(\"/\");\n    const lastComponent = pathComponents[pathComponents.length - 1];\n    if (testParameter(lastComponent, options.removeDirectoryIndex)) {\n      pathComponents = pathComponents.slice(0, -1);\n      urlObject.pathname = `${pathComponents.slice(1).join(\"/\")}/`;\n    }\n  }\n  if (urlObject.hostname) {\n    urlObject.hostname = urlObject.hostname.replace(/\\.$/, \"\");\n    if (options.stripWWW && /^www\\.(?!www\\.)[a-z\\-\\d]{1,63}\\.[a-z.\\-\\d]{2,63}$/.test(urlObject.hostname)) {\n      urlObject.hostname = urlObject.hostname.replace(/^www\\./, \"\");\n    }\n  }\n  if (Array.isArray(options.removeQueryParameters)) {\n    for (const key of [...urlObject.searchParams.keys()]) {\n      if (testParameter(key, options.removeQueryParameters)) {\n        urlObject.searchParams.delete(key);\n      }\n    }\n  }\n  if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {\n    urlObject.search = \"\";\n  }\n  if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {\n    for (const key of [...urlObject.searchParams.keys()]) {\n      if (!testParameter(key, options.keepQueryParameters)) {\n        urlObject.searchParams.delete(key);\n      }\n    }\n  }\n  if (options.sortQueryParameters) {\n    urlObject.searchParams.sort();\n    try {\n      urlObject.search = decodeURIComponent(urlObject.search);\n    } catch {\n    }\n  }\n  if (options.removeTrailingSlash) {\n    urlObject.pathname = urlObject.pathname.replace(/\\/$/, \"\");\n  }\n  if (options.removeExplicitPort && urlObject.port) {\n    urlObject.port = \"\";\n  }\n  const oldUrlString = urlString;\n  urlString = urlObject.toString();\n  if (!options.removeSingleSlash && urlObject.pathname === \"/\" && !oldUrlString.endsWith(\"/\") && urlObject.hash === \"\") {\n    urlString = urlString.replace(/\\/$/, \"\");\n  }\n  if ((options.removeTrailingSlash || urlObject.pathname === \"/\") && urlObject.hash === \"\" && options.removeSingleSlash) {\n    urlString = urlString.replace(/\\/$/, \"\");\n  }\n  if (hasRelativeProtocol && !options.normalizeProtocol) {\n    urlString = urlString.replace(/^http:\\/\\//, \"//\");\n  }\n  if (options.stripProtocol) {\n    urlString = urlString.replace(/^(?:https?:)?\\/\\//, \"\");\n  }\n  return urlString;\n}\n\n// src/relay/index.ts\n\n\n\n// src/relay/connectivity.ts\nvar MAX_RECONNECT_ATTEMPTS = 5;\nvar FLAPPING_THRESHOLD_MS = 1e3;\nvar NDKRelayConnectivity = class {\n  ndkRelay;\n  ws;\n  _status;\n  timeoutMs;\n  connectedAt;\n  _connectionStats = {\n    attempts: 0,\n    success: 0,\n    durations: []\n  };\n  debug;\n  netDebug;\n  connectTimeout;\n  reconnectTimeout;\n  ndk;\n  openSubs = /* @__PURE__ */ new Map();\n  openCountRequests = /* @__PURE__ */ new Map();\n  openEventPublishes = /* @__PURE__ */ new Map();\n  serial = 0;\n  baseEoseTimeout = 4400;\n  constructor(ndkRelay, ndk) {\n    this.ndkRelay = ndkRelay;\n    this._status = 1 /* DISCONNECTED */;\n    const rand = Math.floor(Math.random() * 1e3);\n    this.debug = this.ndkRelay.debug.extend(`connectivity${rand}`);\n    this.ndk = ndk;\n  }\n  /**\n   * Connects to the NDK relay and handles the connection lifecycle.\n   *\n   * This method attempts to establish a WebSocket connection to the NDK relay specified in the `ndkRelay` object.\n   * If the connection is successful, it updates the connection statistics, sets the connection status to `CONNECTED`,\n   * and emits `connect` and `ready` events on the `ndkRelay` object.\n   *\n   * If the connection attempt fails, it handles the error by either initiating a reconnection attempt or emitting a\n   * `delayed-connect` event on the `ndkRelay` object, depending on the `reconnect` parameter.\n   *\n   * @param timeoutMs - The timeout in milliseconds for the connection attempt. If not provided, the default timeout from the `ndkRelay` object is used.\n   * @param reconnect - Indicates whether a reconnection should be attempted if the connection fails. Defaults to `true`.\n   * @returns A Promise that resolves when the connection is established, or rejects if the connection fails.\n   */\n  async connect(timeoutMs, reconnect = true) {\n    if (this._status !== 2 /* RECONNECTING */ && this._status !== 1 /* DISCONNECTED */ || this.reconnectTimeout) {\n      this.debug(\n        \"Relay requested to be connected but was in state %s or it had a reconnect timeout\",\n        this._status\n      );\n      return;\n    }\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = void 0;\n    }\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = void 0;\n    }\n    timeoutMs ??= this.timeoutMs;\n    if (!this.timeoutMs && timeoutMs) this.timeoutMs = timeoutMs;\n    if (this.timeoutMs) this.connectTimeout = setTimeout(() => this.onConnectionError(reconnect), this.timeoutMs);\n    try {\n      this.updateConnectionStats.attempt();\n      if (this._status === 1 /* DISCONNECTED */) this._status = 4 /* CONNECTING */;\n      else this._status = 2 /* RECONNECTING */;\n      this.ws = new WebSocket(this.ndkRelay.url);\n      this.ws.onopen = this.onConnect.bind(this);\n      this.ws.onclose = this.onDisconnect.bind(this);\n      this.ws.onmessage = this.onMessage.bind(this);\n      this.ws.onerror = this.onError.bind(this);\n    } catch (e) {\n      this.debug(`Failed to connect to ${this.ndkRelay.url}`, e);\n      this._status = 1 /* DISCONNECTED */;\n      if (reconnect) this.handleReconnection();\n      else this.ndkRelay.emit(\"delayed-connect\", 2 * 24 * 60 * 60 * 1e3);\n      throw e;\n    }\n  }\n  /**\n   * Disconnects the WebSocket connection to the NDK relay.\n   * This method sets the connection status to `NDKRelayStatus.DISCONNECTING`,\n   * attempts to close the WebSocket connection, and sets the status to\n   * `NDKRelayStatus.DISCONNECTED` if the disconnect operation fails.\n   */\n  disconnect() {\n    this._status = 0 /* DISCONNECTING */;\n    try {\n      this.ws?.close();\n    } catch (e) {\n      this.debug(\"Failed to disconnect\", e);\n      this._status = 1 /* DISCONNECTED */;\n    }\n  }\n  /**\n   * Handles the error that occurred when attempting to connect to the NDK relay.\n   * If `reconnect` is `true`, this method will initiate a reconnection attempt.\n   * Otherwise, it will emit a `delayed-connect` event on the `ndkRelay` object,\n   * indicating that a reconnection should be attempted after a delay.\n   *\n   * @param reconnect - Indicates whether a reconnection should be attempted.\n   */\n  onConnectionError(reconnect) {\n    this.debug(`Error connecting to ${this.ndkRelay.url}`, this.timeoutMs);\n    if (reconnect && !this.reconnectTimeout) {\n      this.handleReconnection();\n    }\n  }\n  /**\n   * Handles the connection event when the WebSocket connection is established.\n   * This method is called when the WebSocket connection is successfully opened.\n   * It clears any existing connection and reconnection timeouts, updates the connection statistics,\n   * sets the connection status to `CONNECTED`, and emits `connect` and `ready` events on the `ndkRelay` object.\n   */\n  onConnect() {\n    this.netDebug?.(\"connected\", this.ndkRelay);\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = void 0;\n    }\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = void 0;\n    }\n    this.updateConnectionStats.connected();\n    this._status = 5 /* CONNECTED */;\n    this.ndkRelay.emit(\"connect\");\n    this.ndkRelay.emit(\"ready\");\n  }\n  /**\n   * Handles the disconnection event when the WebSocket connection is closed.\n   * This method is called when the WebSocket connection is successfully closed.\n   * It updates the connection statistics, sets the connection status to `DISCONNECTED`,\n   * initiates a reconnection attempt if we didn't disconnect ourselves,\n   * and emits a `disconnect` event on the `ndkRelay` object.\n   */\n  onDisconnect() {\n    this.netDebug?.(\"disconnected\", this.ndkRelay);\n    this.updateConnectionStats.disconnected();\n    if (this._status === 5 /* CONNECTED */) {\n      this.handleReconnection();\n    }\n    this._status = 1 /* DISCONNECTED */;\n    this.ndkRelay.emit(\"disconnect\");\n  }\n  /**\n   * Handles incoming messages from the NDK relay WebSocket connection.\n   * This method is called whenever a message is received from the relay.\n   * It parses the message data and dispatches the appropriate handling logic based on the message type.\n   *\n   * @param event - The MessageEvent containing the received message data.\n   */\n  onMessage(event) {\n    this.netDebug?.(event.data, this.ndkRelay, \"recv\");\n    try {\n      const data = JSON.parse(event.data);\n      const [cmd, id, ..._rest] = data;\n      switch (cmd) {\n        case \"EVENT\": {\n          const so = this.openSubs.get(id);\n          const event2 = data[2];\n          if (!so) {\n            this.debug(`Received event for unknown subscription ${id}`);\n            return;\n          }\n          so.onevent(event2);\n          return;\n        }\n        case \"COUNT\": {\n          const payload = data[2];\n          const cr = this.openCountRequests.get(id);\n          if (cr) {\n            cr.resolve(payload.count);\n            this.openCountRequests.delete(id);\n          }\n          return;\n        }\n        case \"EOSE\": {\n          const so = this.openSubs.get(id);\n          if (!so) return;\n          so.oneose(id);\n          return;\n        }\n        case \"OK\": {\n          const ok = data[2];\n          const reason = data[3];\n          const ep = this.openEventPublishes.get(id);\n          const firstEp = ep?.pop();\n          if (!ep || !firstEp) {\n            this.debug(\"Received OK for unknown event publish\", id);\n            return;\n          }\n          if (ok) firstEp.resolve(reason);\n          else firstEp.reject(new Error(reason));\n          if (ep.length === 0) {\n            this.openEventPublishes.delete(id);\n          } else {\n            this.openEventPublishes.set(id, ep);\n          }\n          return;\n        }\n        case \"CLOSED\": {\n          const so = this.openSubs.get(id);\n          if (!so) return;\n          so.onclosed(data[2]);\n          return;\n        }\n        case \"NOTICE\":\n          this.onNotice(data[1]);\n          return;\n        case \"AUTH\": {\n          this.onAuthRequested(data[1]);\n          return;\n        }\n      }\n    } catch (error) {\n      this.debug(`Error parsing message from ${this.ndkRelay.url}: ${error.message}`, error?.stack);\n      return;\n    }\n  }\n  /**\n   * Handles an authentication request from the NDK relay.\n   *\n   * If an authentication policy is configured, it will be used to authenticate the connection.\n   * Otherwise, the `auth` event will be emitted to allow the application to handle the authentication.\n   *\n   * @param challenge - The authentication challenge provided by the NDK relay.\n   */\n  async onAuthRequested(challenge) {\n    const authPolicy = this.ndkRelay.authPolicy ?? this.ndk?.relayAuthDefaultPolicy;\n    this.debug(\"Relay requested authentication\", {\n      havePolicy: !!authPolicy\n    });\n    if (this._status === 7 /* AUTHENTICATING */) {\n      this.debug(\"Already authenticating, ignoring\");\n      return;\n    }\n    this._status = 6 /* AUTH_REQUESTED */;\n    if (authPolicy) {\n      if (this._status >= 5 /* CONNECTED */) {\n        this._status = 7 /* AUTHENTICATING */;\n        let res;\n        try {\n          res = await authPolicy(this.ndkRelay, challenge);\n        } catch (e) {\n          this.debug(\"Authentication policy threw an error\", e);\n          res = false;\n        }\n        this.debug(\"Authentication policy returned\", !!res);\n        if (res instanceof NDKEvent || res === true) {\n          if (res instanceof NDKEvent) {\n            await this.auth(res);\n          }\n          const authenticate = async () => {\n            if (this._status >= 5 /* CONNECTED */ && this._status < 8 /* AUTHENTICATED */) {\n              const event = new NDKEvent(this.ndk);\n              event.kind = 22242 /* ClientAuth */;\n              event.tags = [\n                [\"relay\", this.ndkRelay.url],\n                [\"challenge\", challenge]\n              ];\n              await event.sign();\n              this.auth(event).then(() => {\n                this._status = 8 /* AUTHENTICATED */;\n                this.ndkRelay.emit(\"authed\");\n                this.debug(\"Authentication successful\");\n              }).catch((e) => {\n                this._status = 6 /* AUTH_REQUESTED */;\n                this.ndkRelay.emit(\"auth:failed\", e);\n                this.debug(\"Authentication failed\", e);\n              });\n            } else {\n              this.debug(\"Authentication failed, it changed status, status is %d\", this._status);\n            }\n          };\n          if (res === true) {\n            if (!this.ndk?.signer) {\n              this.debug(\"No signer available for authentication localhost\");\n              this.ndk?.once(\"signer:ready\", authenticate);\n            } else {\n              authenticate().catch((e) => {\n                console.error(\"Error authenticating\", e);\n              });\n            }\n          }\n          this._status = 5 /* CONNECTED */;\n          this.ndkRelay.emit(\"authed\");\n        }\n      }\n    } else {\n      this.ndkRelay.emit(\"auth\", challenge);\n    }\n  }\n  /**\n   * Handles errors that occur on the WebSocket connection to the relay.\n   * @param error - The error or event that occurred.\n   */\n  onError(error) {\n    this.debug(`WebSocket error on ${this.ndkRelay.url}:`, error);\n  }\n  /**\n   * Gets the current status of the NDK relay connection.\n   * @returns {NDKRelayStatus} The current status of the NDK relay connection.\n   */\n  get status() {\n    return this._status;\n  }\n  /**\n   * Checks if the NDK relay connection is currently available.\n   * @returns {boolean} `true` if the relay connection is in the `CONNECTED` status, `false` otherwise.\n   */\n  isAvailable() {\n    return this._status === 5 /* CONNECTED */;\n  }\n  /**\n   * Checks if the NDK relay connection is flapping, which means the connection is rapidly\n   * disconnecting and reconnecting. This is determined by analyzing the durations of the\n   * last three connection attempts. If the standard deviation of the durations is less\n   * than 1000 milliseconds, the connection is considered to be flapping.\n   *\n   * @returns {boolean} `true` if the connection is flapping, `false` otherwise.\n   */\n  isFlapping() {\n    const durations = this._connectionStats.durations;\n    if (durations.length % 3 !== 0) return false;\n    const sum = durations.reduce((a, b) => a + b, 0);\n    const avg = sum / durations.length;\n    const variance = durations.map((x) => (x - avg) ** 2).reduce((a, b) => a + b, 0) / durations.length;\n    const stdDev = Math.sqrt(variance);\n    const isFlapping = stdDev < FLAPPING_THRESHOLD_MS;\n    return isFlapping;\n  }\n  /**\n   * Handles a notice received from the NDK relay.\n   * If the notice indicates the relay is complaining (e.g. \"too many\" or \"maximum\"),\n   * the method disconnects from the relay and attempts to reconnect after a 2-second delay.\n   * A debug message is logged with the relay URL and the notice text.\n   * The \"notice\" event is emitted on the ndkRelay instance with the notice text.\n   *\n   * @param notice - The notice text received from the NDK relay.\n   */\n  async onNotice(notice) {\n    this.ndkRelay.emit(\"notice\", notice);\n  }\n  /**\n   * Attempts to reconnect to the NDK relay after a connection is lost.\n   * This function is called recursively to handle multiple reconnection attempts.\n   * It checks if the relay is flapping and emits a \"flapping\" event if so.\n   * It then calculates a delay before the next reconnection attempt based on the number of previous attempts.\n   * The function sets a timeout to execute the next reconnection attempt after the calculated delay.\n   * If the maximum number of reconnection attempts is reached, a debug message is logged.\n   *\n   * @param attempt - The current attempt number (default is 0).\n   */\n  handleReconnection(attempt = 0) {\n    if (this.reconnectTimeout) return;\n    if (this.isFlapping()) {\n      this.ndkRelay.emit(\"flapping\", this._connectionStats);\n      this._status = 3 /* FLAPPING */;\n      return;\n    }\n    const reconnectDelay = this.connectedAt ? Math.max(0, 6e4 - (Date.now() - this.connectedAt)) : 5e3 * (this._connectionStats.attempts + 1);\n    this.reconnectTimeout = setTimeout(() => {\n      this.reconnectTimeout = void 0;\n      this._status = 2 /* RECONNECTING */;\n      this.connect().catch((_err) => {\n        if (attempt < MAX_RECONNECT_ATTEMPTS) {\n          setTimeout(\n            () => {\n              this.handleReconnection(attempt + 1);\n            },\n            1e3 * (attempt + 1) ^ 4\n          );\n        } else {\n          this.debug(\"Reconnect failed\");\n        }\n      });\n    }, reconnectDelay);\n    this.ndkRelay.emit(\"delayed-connect\", reconnectDelay);\n    this.debug(\"Reconnecting in\", reconnectDelay);\n    this._connectionStats.nextReconnectAt = Date.now() + reconnectDelay;\n  }\n  /**\n   * Sends a message to the NDK relay if the connection is in the CONNECTED state and the WebSocket is open.\n   * If the connection is not in the CONNECTED state or the WebSocket is not open, logs a debug message and throws an error.\n   *\n   * @param message - The message to send to the NDK relay.\n   * @throws {Error} If attempting to send on a closed relay connection.\n   */\n  async send(message) {\n    if (this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN) {\n      this.ws?.send(message);\n      this.netDebug?.(message, this.ndkRelay, \"send\");\n    } else {\n      this.debug(`Not connected to ${this.ndkRelay.url} (%d), not sending message ${message}`, this._status);\n    }\n  }\n  /**\n   * Authenticates the NDK event by sending it to the NDK relay and returning a promise that resolves with the result.\n   *\n   * @param event - The NDK event to authenticate.\n   * @returns A promise that resolves with the authentication result.\n   */\n  async auth(event) {\n    const ret = new Promise((resolve, reject) => {\n      const val = this.openEventPublishes.get(event.id) ?? [];\n      val.push({ resolve, reject });\n      this.openEventPublishes.set(event.id, val);\n    });\n    this.send(`[\"AUTH\",${JSON.stringify(event.rawEvent())}]`);\n    return ret;\n  }\n  /**\n   * Publishes an NDK event to the relay and returns a promise that resolves with the result.\n   *\n   * @param event - The NDK event to publish.\n   * @returns A promise that resolves with the result of the event publication.\n   * @throws {Error} If attempting to publish on a closed relay connection.\n   */\n  async publish(event) {\n    const ret = new Promise((resolve, reject) => {\n      const val = this.openEventPublishes.get(event.id) ?? [];\n      if (val.length > 0) {\n        console.warn(`Duplicate event publishing detected, you are publishing event ${event.id} twice`);\n      }\n      val.push({ resolve, reject });\n      this.openEventPublishes.set(event.id, val);\n    });\n    this.send(`[\"EVENT\",${JSON.stringify(event)}]`);\n    return ret;\n  }\n  /**\n   * Counts the number of events that match the provided filters.\n   *\n   * @param filters - The filters to apply to the count request.\n   * @param params - An optional object containing a custom id for the count request.\n   * @returns A promise that resolves with the number of matching events.\n   * @throws {Error} If attempting to send the count request on a closed relay connection.\n   */\n  async count(filters, params) {\n    this.serial++;\n    const id = params?.id || `count:${this.serial}`;\n    const ret = new Promise((resolve, reject) => {\n      this.openCountRequests.set(id, { resolve, reject });\n    });\n    this.send(`[\"COUNT\",\"${id}\",${JSON.stringify(filters).substring(1)}`);\n    return ret;\n  }\n  close(subId, reason) {\n    this.send(`[\"CLOSE\",\"${subId}\"]`);\n    const sub = this.openSubs.get(subId);\n    this.openSubs.delete(subId);\n    if (sub) sub.onclose(reason);\n  }\n  /**\n   * Subscribes to the NDK relay with the provided filters and parameters.\n   *\n   * @param filters - The filters to apply to the subscription.\n   * @param params - The subscription parameters, including an optional custom id.\n   * @returns A new NDKRelaySubscription instance.\n   */\n  req(relaySub) {\n    `${this.send(`[\"REQ\",\"${relaySub.subId}\",${JSON.stringify(relaySub.executeFilters).substring(1)}`)}]`;\n    this.openSubs.set(relaySub.subId, relaySub);\n  }\n  /**\n   * Utility functions to update the connection stats.\n   */\n  updateConnectionStats = {\n    connected: () => {\n      this._connectionStats.success++;\n      this._connectionStats.connectedAt = Date.now();\n    },\n    disconnected: () => {\n      if (this._connectionStats.connectedAt) {\n        this._connectionStats.durations.push(Date.now() - this._connectionStats.connectedAt);\n        if (this._connectionStats.durations.length > 100) {\n          this._connectionStats.durations.shift();\n        }\n      }\n      this._connectionStats.connectedAt = void 0;\n    },\n    attempt: () => {\n      this._connectionStats.attempts++;\n      this._connectionStats.connectedAt = Date.now();\n    }\n  };\n  /** Returns the connection stats. */\n  get connectionStats() {\n    return this._connectionStats;\n  }\n  /** Returns the relay URL */\n  get url() {\n    return this.ndkRelay.url;\n  }\n  get connected() {\n    return this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN;\n  }\n};\n\n// src/relay/publisher.ts\nvar NDKRelayPublisher = class {\n  ndkRelay;\n  debug;\n  constructor(ndkRelay) {\n    this.ndkRelay = ndkRelay;\n    this.debug = ndkRelay.debug.extend(\"publisher\");\n  }\n  /**\n   * Published an event to the relay; if the relay is not connected, it will\n   * wait for the relay to connect before publishing the event.\n   *\n   * If the relay does not connect within the timeout, the publish operation\n   * will fail.\n   * @param event  The event to publish\n   * @param timeoutMs  The timeout for the publish operation in milliseconds\n   * @returns A promise that resolves when the event has been published or rejects if the operation times out\n   */\n  async publish(event, timeoutMs = 2500) {\n    let timeout;\n    const publishConnected = () => {\n      return new Promise((resolve, reject) => {\n        try {\n          this.publishEvent(event).then((_result) => {\n            this.ndkRelay.emit(\"published\", event);\n            event.emit(\"relay:published\", this.ndkRelay);\n            resolve(true);\n          }).catch(reject);\n        } catch (err) {\n          reject(err);\n        }\n      });\n    };\n    const timeoutPromise = new Promise((_, reject) => {\n      timeout = setTimeout(() => {\n        timeout = void 0;\n        reject(new Error(`Timeout: ${timeoutMs}ms`));\n      }, timeoutMs);\n    });\n    const onConnectHandler = () => {\n      publishConnected().then((result) => connectResolve(result)).catch((err) => connectReject(err));\n    };\n    let connectResolve;\n    let connectReject;\n    const onError = (err) => {\n      this.ndkRelay.debug(\"Publish failed\", err, event.id);\n      this.ndkRelay.emit(\"publish:failed\", event, err);\n      event.emit(\"relay:publish:failed\", this.ndkRelay, err);\n      throw err;\n    };\n    const onFinally = () => {\n      if (timeout) clearTimeout(timeout);\n      this.ndkRelay.removeListener(\"connect\", onConnectHandler);\n    };\n    if (this.ndkRelay.status >= 5 /* CONNECTED */) {\n      return Promise.race([publishConnected(), timeoutPromise]).catch(onError).finally(onFinally);\n    }\n    if (this.ndkRelay.status <= 1 /* DISCONNECTED */) {\n      console.warn(\"Relay is disconnected, trying to connect to publish an event\", this.ndkRelay.url);\n      this.ndkRelay.connect();\n    } else {\n      console.warn(\"Relay not connected, waiting for connection to publish an event\", this.ndkRelay.url);\n    }\n    return Promise.race([\n      new Promise((resolve, reject) => {\n        connectResolve = resolve;\n        connectReject = reject;\n        this.ndkRelay.on(\"connect\", onConnectHandler);\n      }),\n      timeoutPromise\n    ]).catch(onError).finally(onFinally);\n  }\n  async publishEvent(event) {\n    return this.ndkRelay.connectivity.publish(event.rawEvent());\n  }\n};\n\n// src/subscription/grouping.ts\nfunction filterFingerprint(filters, closeOnEose) {\n  const elements = [];\n  for (const filter of filters) {\n    const keys = Object.entries(filter || {}).map(([key, values]) => {\n      if ([\"since\", \"until\"].includes(key)) {\n        return `${key}:${values}`;\n      }\n      return key;\n    }).sort().join(\"-\");\n    elements.push(keys);\n  }\n  let id = closeOnEose ? \"+\" : \"\";\n  id += elements.join(\"|\");\n  return id;\n}\nfunction mergeFilters(filters) {\n  const result = [];\n  const lastResult = {};\n  filters.filter((f) => !!f.limit).forEach((filterWithLimit) => result.push(filterWithLimit));\n  filters = filters.filter((f) => !f.limit);\n  if (filters.length === 0) return result;\n  filters.forEach((filter) => {\n    Object.entries(filter).forEach(([key, value]) => {\n      if (Array.isArray(value)) {\n        if (lastResult[key] === void 0) {\n          lastResult[key] = [...value];\n        } else {\n          lastResult[key] = Array.from(/* @__PURE__ */ new Set([...lastResult[key], ...value]));\n        }\n      } else {\n        lastResult[key] = value;\n      }\n    });\n  });\n  return [...result, lastResult];\n}\n\n// src/relay/subscription.ts\nvar NDKRelaySubscription = class {\n  fingerprint;\n  items = /* @__PURE__ */ new Map();\n  topSubManager;\n  debug;\n  /**\n   * Tracks the status of this REQ.\n   */\n  status = 0 /* INITIAL */;\n  onClose;\n  relay;\n  /**\n   * Whether this subscription has reached EOSE.\n   */\n  eosed = false;\n  /**\n   * Timeout at which this subscription will\n   * start executing.\n   */\n  executionTimer;\n  /**\n   * Track the time at which this subscription will fire.\n   */\n  fireTime;\n  /**\n   * The delay type that the current fireTime was calculated with.\n   */\n  delayType;\n  /**\n   * The filters that have been executed.\n   */\n  executeFilters;\n  id = Math.random().toString(36).substring(7);\n  /**\n   *\n   * @param fingerprint The fingerprint of this subscription.\n   */\n  constructor(relay, fingerprint, topSubManager) {\n    this.relay = relay;\n    this.topSubManager = topSubManager;\n    this.debug = relay.debug.extend(`sub[${this.id}]`);\n    this.fingerprint = fingerprint || Math.random().toString(36).substring(7);\n  }\n  _subId;\n  get subId() {\n    if (this._subId) return this._subId;\n    this._subId = this.fingerprint.slice(0, 15);\n    return this._subId;\n  }\n  subIdParts = /* @__PURE__ */ new Set();\n  addSubIdPart(part) {\n    this.subIdParts.add(part);\n  }\n  addItem(subscription, filters) {\n    this.debug(\"Adding item\", {\n      filters,\n      internalId: subscription.internalId,\n      status: this.status,\n      fingerprint: this.fingerprint,\n      id: this.subId,\n      items: this.items,\n      itemsSize: this.items.size\n    });\n    if (this.items.has(subscription.internalId)) return;\n    subscription.on(\"close\", this.removeItem.bind(this, subscription));\n    this.items.set(subscription.internalId, { subscription, filters });\n    if (this.status !== 3 /* RUNNING */) {\n      if (subscription.subId && (!this._subId || this._subId.length < 48)) {\n        if (this.status === 0 /* INITIAL */ || this.status === 1 /* PENDING */) {\n          this.addSubIdPart(subscription.subId);\n        }\n      }\n    }\n    switch (this.status) {\n      case 0 /* INITIAL */:\n        this.evaluateExecutionPlan(subscription);\n        break;\n      case 3 /* RUNNING */:\n        break;\n      case 1 /* PENDING */:\n        this.evaluateExecutionPlan(subscription);\n        break;\n      case 4 /* CLOSED */:\n        this.debug(\"Subscription is closed, cannot add new items %o (%o)\", subscription, filters);\n        throw new Error(\"Cannot add new items to a closed subscription\");\n    }\n  }\n  /**\n   * A subscription has been closed, remove it from the list of items.\n   * @param subscription\n   */\n  removeItem(subscription) {\n    this.items.delete(subscription.internalId);\n    if (this.items.size === 0) {\n      if (!this.eosed) return;\n      this.close();\n      this.cleanup();\n    }\n  }\n  close() {\n    if (this.status === 4 /* CLOSED */) return;\n    const prevStatus = this.status;\n    this.status = 4 /* CLOSED */;\n    if (prevStatus === 3 /* RUNNING */) {\n      try {\n        this.relay.close(this.subId);\n      } catch (e) {\n        this.debug(\"Error closing subscription\", e, this);\n      }\n    } else {\n      this.debug(\"Subscription wanted to close but it wasn't running, this is probably ok\", {\n        subId: this.subId,\n        prevStatus,\n        sub: this\n      });\n    }\n    this.cleanup();\n  }\n  cleanup() {\n    if (this.executionTimer) clearTimeout(this.executionTimer);\n    this.relay.off(\"ready\", this.executeOnRelayReady);\n    this.relay.off(\"authed\", this.reExecuteAfterAuth);\n    if (this.onClose) this.onClose(this);\n  }\n  evaluateExecutionPlan(subscription) {\n    if (!subscription.isGroupable()) {\n      this.status = 1 /* PENDING */;\n      this.execute();\n      return;\n    }\n    if (subscription.filters.find((filter) => !!filter.limit)) {\n      this.executeFilters = this.compileFilters();\n      if (this.executeFilters.length >= 10) {\n        this.status = 1 /* PENDING */;\n        this.execute();\n        return;\n      }\n    }\n    const delay = subscription.groupableDelay;\n    const delayType = subscription.groupableDelayType;\n    if (!delay) throw new Error(\"Cannot group a subscription without a delay\");\n    if (this.status === 0 /* INITIAL */) {\n      this.schedule(delay, delayType);\n    } else {\n      const existingDelayType = this.delayType;\n      const timeUntilFire = this.fireTime - Date.now();\n      if (existingDelayType === \"at-least\" && delayType === \"at-least\") {\n        if (timeUntilFire < delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-least\" && delayType === \"at-most\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-most\" && delayType === \"at-most\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-most\" && delayType === \"at-least\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else {\n        throw new Error(`Unknown delay type combination ${existingDelayType} ${delayType}`);\n      }\n    }\n  }\n  schedule(delay, delayType) {\n    this.status = 1 /* PENDING */;\n    const currentTime = Date.now();\n    this.fireTime = currentTime + delay;\n    this.delayType = delayType;\n    const timer = setTimeout(this.execute.bind(this), delay);\n    if (delayType === \"at-least\") {\n      this.executionTimer = timer;\n    }\n  }\n  executeOnRelayReady = () => {\n    if (this.status !== 2 /* WAITING */) return;\n    if (this.items.size === 0) {\n      this.debug(\"No items to execute; this relay was probably too slow to respond and the caller gave up\", {\n        status: this.status,\n        fingerprint: this.fingerprint,\n        items: this.items,\n        itemsSize: this.items.size,\n        id: this.id,\n        subId: this.subId\n      });\n      this.cleanup();\n      return;\n    }\n    this.debug(\"Executing on relay ready\", {\n      status: this.status,\n      fingerprint: this.fingerprint,\n      items: this.items,\n      itemsSize: this.items.size\n    });\n    this.status = 1 /* PENDING */;\n    this.execute();\n  };\n  finalizeSubId() {\n    if (this.subIdParts.size > 0) {\n      this._subId = Array.from(this.subIdParts).join(\"-\");\n    } else {\n      this._subId = this.fingerprint.slice(0, 15);\n    }\n    this._subId += `-${Math.random().toString(36).substring(2, 7)}`;\n  }\n  // we do it this way so that we can remove the listener\n  reExecuteAfterAuth = (() => {\n    const oldSubId = this.subId;\n    this.debug(\"Re-executing after auth\", this.items.size);\n    if (this.eosed) {\n      this.relay.close(this.subId);\n    } else {\n      this.debug(\"We are abandoning an opened subscription, once it EOSE's, the handler will close it\", {\n        oldSubId\n      });\n    }\n    this._subId = void 0;\n    this.status = 1 /* PENDING */;\n    this.execute();\n    this.debug(\"Re-executed after auth %s \\u{1F449} %s\", oldSubId, this.subId);\n  }).bind(this);\n  execute() {\n    if (this.status !== 1 /* PENDING */) {\n      return;\n    }\n    if (!this.relay.connected) {\n      this.status = 2 /* WAITING */;\n      this.debug(\"Waiting for relay to be ready\", {\n        status: this.status,\n        id: this.subId,\n        fingerprint: this.fingerprint,\n        items: this.items,\n        itemsSize: this.items.size\n      });\n      this.relay.once(\"ready\", this.executeOnRelayReady);\n      return;\n    }\n    if (this.relay.status < 8 /* AUTHENTICATED */) {\n      this.relay.once(\"authed\", this.reExecuteAfterAuth);\n    }\n    this.status = 3 /* RUNNING */;\n    this.finalizeSubId();\n    this.executeFilters = this.compileFilters();\n    this.relay.req(this);\n  }\n  onstart() {\n  }\n  onevent(event) {\n    this.topSubManager.dispatchEvent(event, this.relay);\n  }\n  oneose(subId) {\n    this.eosed = true;\n    if (subId !== this.subId) {\n      this.debug(\"Received EOSE for an abandoned subscription\", subId, this.subId);\n      this.relay.close(subId);\n      return;\n    }\n    if (this.items.size === 0) {\n      this.close();\n    }\n    for (const { subscription } of this.items.values()) {\n      subscription.eoseReceived(this.relay);\n      if (subscription.closeOnEose) {\n        this.debug(\"Removing item because of EOSE\", {\n          filters: subscription.filters,\n          internalId: subscription.internalId,\n          status: this.status,\n          fingerprint: this.fingerprint,\n          items: this.items,\n          itemsSize: this.items.size\n        });\n        this.removeItem(subscription);\n      }\n    }\n  }\n  onclose(_reason) {\n    this.status = 4 /* CLOSED */;\n  }\n  onclosed(reason) {\n    if (!reason) return;\n    for (const { subscription } of this.items.values()) {\n      subscription.closedReceived(this.relay, reason);\n    }\n  }\n  /**\n   * Grabs the filters from all the subscriptions\n   * and merges them into a single filter.\n   */\n  compileFilters() {\n    const mergedFilters = [];\n    const filters = Array.from(this.items.values()).map((item) => item.filters);\n    if (!filters[0]) {\n      this.debug(\"\\u{1F440} No filters to merge\", this.items);\n      console.error(\"BUG: No filters to merge!\", this.items);\n      return [];\n    }\n    const filterCount = filters[0].length;\n    for (let i = 0; i < filterCount; i++) {\n      const allFiltersAtIndex = filters.map((filter) => filter[i]);\n      mergedFilters.push(...mergeFilters(allFiltersAtIndex));\n    }\n    return mergedFilters;\n  }\n};\n\n// src/relay/sub-manager.ts\nvar NDKRelaySubscriptionManager = class {\n  relay;\n  subscriptions;\n  generalSubManager;\n  /**\n   * @param relay - The relay instance.\n   * @param generalSubManager - The subscription manager instance.\n   */\n  constructor(relay, generalSubManager) {\n    this.relay = relay;\n    this.subscriptions = /* @__PURE__ */ new Map();\n    this.generalSubManager = generalSubManager;\n  }\n  /**\n   * Adds a subscription to the manager.\n   */\n  addSubscription(sub, filters) {\n    let relaySub;\n    if (!sub.isGroupable()) {\n      relaySub = this.createSubscription(sub, filters);\n    } else {\n      const filterFp = filterFingerprint(filters, sub.closeOnEose);\n      if (filterFp) {\n        const existingSubs = this.subscriptions.get(filterFp);\n        relaySub = (existingSubs || []).find((sub2) => sub2.status < 3 /* RUNNING */);\n      }\n      relaySub ??= this.createSubscription(sub, filters, filterFp);\n    }\n    relaySub.addItem(sub, filters);\n  }\n  createSubscription(_sub, _filters, fingerprint) {\n    const relaySub = new NDKRelaySubscription(this.relay, fingerprint || null, this.generalSubManager);\n    relaySub.onClose = this.onRelaySubscriptionClose.bind(this);\n    const currentVal = this.subscriptions.get(relaySub.fingerprint) ?? [];\n    this.subscriptions.set(relaySub.fingerprint, [...currentVal, relaySub]);\n    return relaySub;\n  }\n  onRelaySubscriptionClose(sub) {\n    let currentVal = this.subscriptions.get(sub.fingerprint) ?? [];\n    if (!currentVal) {\n      console.warn(\"Unexpectedly did not find a subscription with fingerprint\", sub.fingerprint);\n    } else if (currentVal.length === 1) {\n      this.subscriptions.delete(sub.fingerprint);\n    } else {\n      currentVal = currentVal.filter((s) => s.id !== sub.id);\n      this.subscriptions.set(sub.fingerprint, currentVal);\n    }\n  }\n};\n\n// src/relay/signature-verification-stats.ts\n\nvar SignatureVerificationStats = class {\n  ndk;\n  debug;\n  intervalId = null;\n  intervalMs;\n  /**\n   * Creates a new SignatureVerificationStats instance\n   *\n   * @param ndk - The NDK instance to track stats for\n   * @param intervalMs - How often to print stats (in milliseconds)\n   */\n  constructor(ndk, intervalMs = 1e4) {\n    this.ndk = ndk;\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:signature-verification-stats\");\n    this.intervalMs = intervalMs;\n  }\n  /**\n   * Start tracking and reporting signature verification statistics\n   */\n  start() {\n    if (this.intervalId) {\n      this.debug(\"Stats tracking already started\");\n      return;\n    }\n    this.debug(`Starting signature verification stats reporting every ${this.intervalMs}ms`);\n    this.intervalId = setInterval(() => {\n      this.reportStats();\n    }, this.intervalMs);\n  }\n  /**\n   * Stop tracking and reporting signature verification statistics\n   */\n  stop() {\n    if (!this.intervalId) {\n      this.debug(\"Stats tracking not started\");\n      return;\n    }\n    clearInterval(this.intervalId);\n    this.intervalId = null;\n    this.debug(\"Stopped signature verification stats reporting\");\n  }\n  /**\n   * Report current signature verification statistics for all relays\n   */\n  reportStats() {\n    const stats = this.collectStats();\n    console.log(\"\\n=== Signature Verification Sampling Stats ===\");\n    console.log(`Timestamp: ${(/* @__PURE__ */ new Date()).toISOString()}`);\n    console.log(`Total Relays: ${stats.totalRelays}`);\n    console.log(`Connected Relays: ${stats.connectedRelays}`);\n    if (stats.relayStats.length === 0) {\n      console.log(\"No relay statistics available\");\n    } else {\n      console.log(\"\\nRelay Statistics:\");\n      stats.relayStats.sort((a, b) => a.url.localeCompare(b.url));\n      stats.relayStats.forEach((relayStat) => {\n        console.log(`\n  ${relayStat.url} ${relayStat.connected ? \"(connected)\" : \"(disconnected)\"}`);\n        console.log(`    Validated Events: ${relayStat.validatedCount}`);\n        console.log(`    Non-validated Events: ${relayStat.nonValidatedCount}`);\n        console.log(`    Total Events: ${relayStat.totalEvents}`);\n        console.log(\n          `    Current Validation Ratio: ${relayStat.validationRatio.toFixed(4)} (${(relayStat.validationRatio * 100).toFixed(2)}%)`\n        );\n        console.log(\n          `    Target Validation Ratio: ${relayStat.targetValidationRatio?.toFixed(4) || \"N/A\"} (${relayStat.targetValidationRatio ? (relayStat.targetValidationRatio * 100).toFixed(2) + \"%\" : \"N/A\"})`\n        );\n        console.log(`    Trusted: ${relayStat.trusted ? \"Yes\" : \"No\"}`);\n      });\n    }\n    console.log(\"\\nGlobal Settings:\");\n    console.log(\n      `  Initial Validation Ratio: ${stats.initialValidationRatio.toFixed(4)} (${(stats.initialValidationRatio * 100).toFixed(2)}%)`\n    );\n    console.log(\n      `  Lowest Validation Ratio: ${stats.lowestValidationRatio.toFixed(4)} (${(stats.lowestValidationRatio * 100).toFixed(2)}%)`\n    );\n    console.log(`  Auto-blacklist Invalid Relays: ${stats.autoBlacklistInvalidRelays ? \"Yes\" : \"No\"}`);\n    console.log(`  Blacklisted Relays: ${stats.blacklistedRelayCount}`);\n    console.log(\"===========================================\\n\");\n  }\n  /**\n   * Collect statistics from all relays\n   */\n  collectStats() {\n    const relayStats = [];\n    for (const relay of this.ndk.pool.relays.values()) {\n      relayStats.push({\n        url: relay.url,\n        connected: relay.connected,\n        validatedCount: relay.validatedEventCount,\n        nonValidatedCount: relay.nonValidatedEventCount,\n        totalEvents: relay.validatedEventCount + relay.nonValidatedEventCount,\n        validationRatio: relay.validationRatio,\n        targetValidationRatio: relay.targetValidationRatio,\n        trusted: relay.trusted\n      });\n    }\n    return {\n      totalRelays: this.ndk.pool.relays.size,\n      connectedRelays: this.ndk.pool.connectedRelays().length,\n      relayStats,\n      initialValidationRatio: this.ndk.initialValidationRatio,\n      lowestValidationRatio: this.ndk.lowestValidationRatio,\n      autoBlacklistInvalidRelays: this.ndk.autoBlacklistInvalidRelays,\n      blacklistedRelayCount: this.ndk.blacklistRelayUrls?.length || 0\n    };\n  }\n};\nfunction startSignatureVerificationStats(ndk, intervalMs = 1e4) {\n  const stats = new SignatureVerificationStats(ndk, intervalMs);\n  stats.start();\n  return stats;\n}\n\n// src/relay/index.ts\nvar NDKRelayStatus = /* @__PURE__ */ ((NDKRelayStatus2) => {\n  NDKRelayStatus2[NDKRelayStatus2[\"DISCONNECTING\"] = 0] = \"DISCONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"DISCONNECTED\"] = 1] = \"DISCONNECTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"FLAPPING\"] = 3] = \"FLAPPING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"CONNECTING\"] = 4] = \"CONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"CONNECTED\"] = 5] = \"CONNECTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTH_REQUESTED\"] = 6] = \"AUTH_REQUESTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTHENTICATING\"] = 7] = \"AUTHENTICATING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTHENTICATED\"] = 8] = \"AUTHENTICATED\";\n  return NDKRelayStatus2;\n})(NDKRelayStatus || {});\nvar NDKRelay = class _NDKRelay extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  url;\n  scores;\n  connectivity;\n  subs;\n  publisher;\n  authPolicy;\n  /**\n   * The lowest validation ratio this relay can reach.\n   */\n  lowestValidationRatio;\n  /**\n   * Current validation ratio this relay is targeting.\n   */\n  targetValidationRatio;\n  validationRatioFn;\n  /**\n   * This tracks events that have been seen by this relay\n   * with a valid signature.\n   */\n  validatedEventCount = 0;\n  /**\n   * This tracks events that have been seen by this relay\n   * but have not been validated.\n   */\n  nonValidatedEventCount = 0;\n  /**\n   * Whether this relay is trusted.\n   *\n   * Trusted relay's events do not get their signature verified.\n   */\n  trusted = false;\n  complaining = false;\n  debug;\n  static defaultValidationRatioUpdateFn = (relay, validatedCount, _nonValidatedCount) => {\n    if (relay.lowestValidationRatio === void 0 || relay.targetValidationRatio === void 0) return 1;\n    let newRatio = relay.validationRatio;\n    if (relay.validationRatio > relay.targetValidationRatio) {\n      const factor = validatedCount / 100;\n      newRatio = Math.max(relay.lowestValidationRatio, relay.validationRatio - factor);\n    }\n    if (newRatio < relay.validationRatio) {\n      return newRatio;\n    }\n    return relay.validationRatio;\n  };\n  constructor(url, authPolicy, ndk) {\n    super();\n    this.url = normalizeRelayUrl(url);\n    this.scores = /* @__PURE__ */ new Map();\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_1__(`ndk:relay:${url}`);\n    this.connectivity = new NDKRelayConnectivity(this, ndk);\n    this.connectivity.netDebug = ndk?.netDebug;\n    this.req = this.connectivity.req.bind(this.connectivity);\n    this.close = this.connectivity.close.bind(this.connectivity);\n    this.subs = new NDKRelaySubscriptionManager(this, ndk.subManager);\n    this.publisher = new NDKRelayPublisher(this);\n    this.authPolicy = authPolicy;\n    this.targetValidationRatio = ndk?.initialValidationRatio;\n    this.lowestValidationRatio = ndk?.lowestValidationRatio;\n    this.validationRatioFn = (ndk?.validationRatioFn ?? _NDKRelay.defaultValidationRatioUpdateFn).bind(this);\n    this.updateValidationRatio();\n    if (!ndk) {\n      console.trace(\"relay created without ndk\");\n    }\n  }\n  updateValidationRatio() {\n    if (this.validationRatioFn && this.validatedEventCount > 0) {\n      const newRatio = this.validationRatioFn(this, this.validatedEventCount, this.nonValidatedEventCount);\n      this.targetValidationRatio = newRatio;\n    }\n    setTimeout(() => {\n      this.updateValidationRatio();\n    }, 3e4);\n  }\n  get status() {\n    return this.connectivity.status;\n  }\n  get connectionStats() {\n    return this.connectivity.connectionStats;\n  }\n  /**\n   * Connects to the relay.\n   */\n  async connect(timeoutMs, reconnect = true) {\n    return this.connectivity.connect(timeoutMs, reconnect);\n  }\n  /**\n   * Disconnects from the relay.\n   */\n  disconnect() {\n    if (this.status === 1 /* DISCONNECTED */) {\n      return;\n    }\n    this.connectivity.disconnect();\n  }\n  /**\n   * Queues or executes the subscription of a specific set of filters\n   * within this relay.\n   *\n   * @param subscription NDKSubscription this filters belong to.\n   * @param filters Filters to execute\n   */\n  subscribe(subscription, filters) {\n    this.subs.addSubscription(subscription, filters);\n  }\n  /**\n   * Publishes an event to the relay with an optional timeout.\n   *\n   * If the relay is not connected, the event will be published when the relay connects,\n   * unless the timeout is reached before the relay connects.\n   *\n   * @param event The event to publish\n   * @param timeoutMs The timeout for the publish operation in milliseconds\n   * @returns A promise that resolves when the event has been published or rejects if the operation times out\n   */\n  async publish(event, timeoutMs = 2500) {\n    return this.publisher.publish(event, timeoutMs);\n  }\n  referenceTags() {\n    return [[\"r\", this.url]];\n  }\n  addValidatedEvent() {\n    this.validatedEventCount++;\n  }\n  addNonValidatedEvent() {\n    this.nonValidatedEventCount++;\n  }\n  /**\n   * The current validation ratio this relay has achieved.\n   */\n  get validationRatio() {\n    if (this.nonValidatedEventCount === 0) {\n      return 1;\n    }\n    return this.validatedEventCount / (this.validatedEventCount + this.nonValidatedEventCount);\n  }\n  shouldValidateEvent() {\n    if (this.trusted) {\n      return false;\n    }\n    if (this.targetValidationRatio === void 0) {\n      return true;\n    }\n    if (this.targetValidationRatio >= 1) return true;\n    return Math.random() < this.targetValidationRatio;\n  }\n  get connected() {\n    return this.connectivity.connected;\n  }\n  req;\n  close;\n};\n\n// src/relay/sets/index.ts\nvar NDKPublishError = class extends Error {\n  errors;\n  publishedToRelays;\n  /**\n   * Intended relay set where the publishing was intended to happen.\n   */\n  intendedRelaySet;\n  constructor(message, errors, publishedToRelays, intendedRelaySet) {\n    super(message);\n    this.errors = errors;\n    this.publishedToRelays = publishedToRelays;\n    this.intendedRelaySet = intendedRelaySet;\n  }\n  get relayErrors() {\n    const errors = [];\n    for (const [relay, err] of this.errors) {\n      errors.push(`${relay.url}: ${err}`);\n    }\n    return errors.join(\"\\n\");\n  }\n};\nvar NDKRelaySet = class _NDKRelaySet {\n  relays;\n  debug;\n  ndk;\n  pool;\n  constructor(relays, ndk, pool) {\n    this.relays = relays;\n    this.ndk = ndk;\n    this.pool = pool ?? ndk.pool;\n    this.debug = ndk.debug.extend(\"relayset\");\n  }\n  /**\n   * Adds a relay to this set.\n   */\n  addRelay(relay) {\n    this.relays.add(relay);\n  }\n  get relayUrls() {\n    return Array.from(this.relays).map((r) => r.url);\n  }\n  /**\n   * Creates a relay set from a list of relay URLs.\n   *\n   * If no connection to the relay is found in the pool it will temporarily\n   * connect to it.\n   *\n   * @param relayUrls - list of relay URLs to include in this set\n   * @param ndk\n   * @param connect - whether to connect to the relay immediately if it was already in the pool but not connected\n   * @returns NDKRelaySet\n   */\n  static fromRelayUrls(relayUrls, ndk, connect = true, pool) {\n    pool = pool ?? ndk.pool;\n    if (!pool) throw new Error(\"No pool provided\");\n    const relays = /* @__PURE__ */ new Set();\n    for (const url of relayUrls) {\n      const relay = pool.relays.get(normalizeRelayUrl(url));\n      if (relay) {\n        if (relay.status < 5 /* CONNECTED */ && connect) {\n          relay.connect();\n        }\n        relays.add(relay);\n      } else {\n        const temporaryRelay = new NDKRelay(normalizeRelayUrl(url), ndk?.relayAuthDefaultPolicy, ndk);\n        pool.useTemporaryRelay(temporaryRelay, void 0, `requested from fromRelayUrls ${relayUrls}`);\n        relays.add(temporaryRelay);\n      }\n    }\n    return new _NDKRelaySet(new Set(relays), ndk, pool);\n  }\n  /**\n   * Publish an event to all relays in this relay set.\n   *\n   * This method implements a robust mechanism for publishing events to multiple relays with\n   * built-in handling for race conditions, timeouts, and partial failures. The implementation\n   * uses a dual-tracking mechanism to ensure accurate reporting of which relays successfully\n   * received an event.\n   *\n   * Key aspects of this implementation:\n   *\n   * 1. DUAL-TRACKING MECHANISM:\n   *    - Promise-based tracking: Records successes/failures from the promises returned by relay.publish()\n   *    - Event-based tracking: Listens for 'relay:published' events that indicate successful publishing\n   *    This approach ensures we don't miss successful publishes even if there are subsequent errors in\n   *    the promise chain.\n   *\n   * 2. RACE CONDITION HANDLING:\n   *    - If a relay emits a success event but later fails in the promise chain, we still count it as a success\n   *    - If a relay times out after successfully publishing, we still count it as a success\n   *    - All relay operations happen in parallel, with proper tracking regardless of completion order\n   *\n   * 3. TIMEOUT MANAGEMENT:\n   *    - Individual timeouts for each relay operation\n   *    - Proper cleanup of timeouts to prevent memory leaks\n   *    - Clear timeout error reporting\n   *\n   * 4. ERROR HANDLING:\n   *    - Detailed tracking of specific errors for each failed relay\n   *    - Special handling for ephemeral events (which don't expect acknowledgement)\n   *    - RequiredRelayCount parameter to control the minimum success threshold\n   *\n   * @param event Event to publish\n   * @param timeoutMs Timeout in milliseconds for each relay publish operation\n   * @param requiredRelayCount The minimum number of relays we expect the event to be published to\n   * @returns A set of relays the event was published to\n   * @throws {NDKPublishError} If the event could not be published to at least `requiredRelayCount` relays\n   * @example\n   * ```typescript\n   * const relaySet = new NDKRelaySet(new Set([relay1, relay2]), ndk);\n   * const publishedToRelays = await relaySet.publish(event);\n   * // publishedToRelays can contain relay1, relay2, both, or none\n   * // depending on which relays the event was successfully published to\n   * if (publishedToRelays.size > 0) {\n   *   console.log(\"Event published to at least one relay\");\n   * }\n   * ```\n   */\n  async publish(event, timeoutMs, requiredRelayCount = 1) {\n    const publishedToRelays = /* @__PURE__ */ new Set();\n    const errors = /* @__PURE__ */ new Map();\n    const isEphemeral2 = event.isEphemeral();\n    event.publishStatus = \"pending\";\n    const relayPublishedHandler = (relay) => {\n      publishedToRelays.add(relay);\n    };\n    event.on(\"relay:published\", relayPublishedHandler);\n    try {\n      const promises = Array.from(this.relays).map((relay) => {\n        return new Promise((resolve) => {\n          const timeoutId = timeoutMs ? setTimeout(() => {\n            if (!publishedToRelays.has(relay)) {\n              errors.set(relay, new Error(`Publish timeout after ${timeoutMs}ms`));\n              resolve(false);\n            }\n          }, timeoutMs) : null;\n          relay.publish(event, timeoutMs).then((success) => {\n            if (timeoutId) clearTimeout(timeoutId);\n            if (success) {\n              publishedToRelays.add(relay);\n              resolve(true);\n            } else {\n              resolve(false);\n            }\n          }).catch((err) => {\n            if (timeoutId) clearTimeout(timeoutId);\n            if (!isEphemeral2) {\n              errors.set(relay, err);\n            }\n            resolve(false);\n          });\n        });\n      });\n      await Promise.all(promises);\n      if (publishedToRelays.size < requiredRelayCount) {\n        if (!isEphemeral2) {\n          const error = new NDKPublishError(\n            \"Not enough relays received the event (\" + publishedToRelays.size + \" published, \" + requiredRelayCount + \" required)\",\n            errors,\n            publishedToRelays,\n            this\n          );\n          event.publishStatus = \"error\";\n          event.publishError = error;\n          this.ndk?.emit(\"event:publish-failed\", event, error, this.relayUrls);\n          throw error;\n        }\n      } else {\n        event.publishStatus = \"success\";\n        event.emit(\"published\", { relaySet: this, publishedToRelays });\n      }\n      return publishedToRelays;\n    } finally {\n      event.off(\"relay:published\", relayPublishedHandler);\n    }\n  }\n  get size() {\n    return this.relays.size;\n  }\n};\n\n// src/relay/sets/calculate.ts\nvar d = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:outbox:calculate\");\nasync function calculateRelaySetFromEvent(ndk, event, requiredRelayCount) {\n  const relays = /* @__PURE__ */ new Set();\n  const authorWriteRelays = await getWriteRelaysFor(ndk, event.pubkey);\n  if (authorWriteRelays) {\n    authorWriteRelays.forEach((relayUrl) => {\n      const relay = ndk.pool?.getRelay(relayUrl);\n      if (relay) relays.add(relay);\n    });\n  }\n  let relayHints = event.tags.filter((tag) => [\"a\", \"e\"].includes(tag[0])).map((tag) => tag[2]).filter((url) => url?.startsWith(\"wss://\")).filter((url) => {\n    try {\n      new URL(url);\n      return true;\n    } catch {\n      return false;\n    }\n  }).map((url) => normalizeRelayUrl(url));\n  relayHints = Array.from(new Set(relayHints)).slice(0, 5);\n  relayHints.forEach((relayUrl) => {\n    const relay = ndk.pool?.getRelay(relayUrl, true, true);\n    if (relay) {\n      d(\"Adding relay hint %s\", relayUrl);\n      relays.add(relay);\n    }\n  });\n  const pTags = event.getMatchingTags(\"p\").map((tag) => tag[1]);\n  if (pTags.length < 5) {\n    const pTaggedRelays = Array.from(\n      chooseRelayCombinationForPubkeys(ndk, pTags, \"read\", {\n        preferredRelays: new Set(authorWriteRelays)\n      }).keys()\n    );\n    pTaggedRelays.forEach((relayUrl) => {\n      const relay = ndk.pool?.getRelay(relayUrl, false, true);\n      if (relay) {\n        d(\"Adding p-tagged relay %s\", relayUrl);\n        relays.add(relay);\n      }\n    });\n  } else {\n    d(\"Too many p-tags to consider %d\", pTags.length);\n  }\n  ndk.pool?.permanentAndConnectedRelays().forEach((relay) => relays.add(relay));\n  if (requiredRelayCount && relays.size < requiredRelayCount) {\n    const explicitRelays = ndk.explicitRelayUrls?.filter((url) => !Array.from(relays).some((r) => r.url === url)).slice(0, requiredRelayCount - relays.size);\n    explicitRelays?.forEach((url) => {\n      const relay = ndk.pool?.getRelay(url, false, true);\n      if (relay) {\n        d(\"Adding explicit relay %s\", url);\n        relays.add(relay);\n      }\n    });\n  }\n  return new NDKRelaySet(relays, ndk);\n}\nfunction calculateRelaySetsFromFilter(ndk, filters, pool) {\n  const result = /* @__PURE__ */ new Map();\n  const authors = /* @__PURE__ */ new Set();\n  filters.forEach((filter) => {\n    if (filter.authors) {\n      filter.authors.forEach((author) => authors.add(author));\n    }\n  });\n  if (authors.size > 0) {\n    const authorToRelaysMap = getRelaysForFilterWithAuthors(ndk, Array.from(authors));\n    for (const relayUrl of authorToRelaysMap.keys()) {\n      result.set(relayUrl, []);\n    }\n    for (const filter of filters) {\n      if (filter.authors) {\n        for (const [relayUrl, authors2] of authorToRelaysMap.entries()) {\n          const authorFilterAndRelayPubkeyIntersection = filter.authors.filter(\n            (author) => authors2.includes(author)\n          );\n          result.set(relayUrl, [\n            ...result.get(relayUrl),\n            {\n              ...filter,\n              // Overwrite authors sent to this relay with the authors that were\n              // present in the filter and are also present in the relay\n              authors: authorFilterAndRelayPubkeyIntersection\n            }\n          ]);\n        }\n      } else {\n        for (const relayUrl of authorToRelaysMap.keys()) {\n          result.set(relayUrl, [...result.get(relayUrl), filter]);\n        }\n      }\n    }\n  } else {\n    if (ndk.explicitRelayUrls) {\n      ndk.explicitRelayUrls.forEach((relayUrl) => {\n        result.set(relayUrl, filters);\n      });\n    }\n  }\n  if (result.size === 0) {\n    pool.permanentAndConnectedRelays().slice(0, 5).forEach((relay) => {\n      result.set(relay.url, filters);\n    });\n  }\n  return result;\n}\nfunction calculateRelaySetsFromFilters(ndk, filters, pool) {\n  const a = calculateRelaySetsFromFilter(ndk, filters, pool);\n  return a;\n}\n\n// src/events/content-tagger.ts\n\nfunction mergeTags(tags1, tags2) {\n  const tagMap = /* @__PURE__ */ new Map();\n  const generateKey = (tag) => tag.join(\",\");\n  const isContained = (smaller, larger) => {\n    return smaller.every((value, index) => value === larger[index]);\n  };\n  const processTag = (tag) => {\n    for (const [key, existingTag] of tagMap) {\n      if (isContained(existingTag, tag) || isContained(tag, existingTag)) {\n        if (tag.length >= existingTag.length) {\n          tagMap.set(key, tag);\n        }\n        return;\n      }\n    }\n    tagMap.set(generateKey(tag), tag);\n  };\n  tags1.concat(tags2).forEach(processTag);\n  return Array.from(tagMap.values());\n}\nfunction uniqueTag(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  const sameLength = aLength === bLength;\n  if (sameLength) {\n    if (a.every((v, i) => v === b[i])) {\n      return [a];\n    }\n    return [a, b];\n  }\n  if (aLength > bLength && a.every((v, i) => v === b[i])) {\n    return [a];\n  }\n  if (bLength > aLength && b.every((v, i) => v === a[i])) {\n    return [b];\n  }\n  return [a, b];\n}\nvar hashtagRegex = /(?<=\\s|^)(#[^\\s!@#$%^&*()=+./,[{\\]};:'\"?><]+)/g;\nfunction generateHashtags(content) {\n  const hashtags = content.match(hashtagRegex);\n  const tagIds = /* @__PURE__ */ new Set();\n  const tag = /* @__PURE__ */ new Set();\n  if (hashtags) {\n    for (const hashtag of hashtags) {\n      if (tagIds.has(hashtag.slice(1))) continue;\n      tag.add(hashtag.slice(1));\n      tagIds.add(hashtag.slice(1));\n    }\n  }\n  return Array.from(tag);\n}\nasync function generateContentTags(content, tags = []) {\n  const tagRegex = /(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g;\n  const promises = [];\n  const addTagIfNew = (t) => {\n    if (!tags.find((t2) => [\"q\", t[0]].includes(t2[0]) && t2[1] === t[1])) {\n      tags.push(t);\n    }\n  };\n  content = content.replace(tagRegex, (tag) => {\n    try {\n      const entity = tag.split(/(@|nostr:)/)[2];\n      const { type, data } = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(entity);\n      let t;\n      switch (type) {\n        case \"npub\":\n          t = [\"p\", data];\n          break;\n        case \"nprofile\":\n          t = [\"p\", data.pubkey];\n          break;\n        case \"note\":\n          promises.push(\n            new Promise(async (resolve) => {\n              addTagIfNew([\"q\", data, await maybeGetEventRelayUrl(entity)]);\n              resolve();\n            })\n          );\n          break;\n        case \"nevent\":\n          promises.push(\n            new Promise(async (resolve) => {\n              const { id, author } = data;\n              let { relays } = data;\n              if (!relays || relays.length === 0) {\n                relays = [await maybeGetEventRelayUrl(entity)];\n              }\n              addTagIfNew([\"q\", id, relays[0]]);\n              if (author) addTagIfNew([\"p\", author]);\n              resolve();\n            })\n          );\n          break;\n        case \"naddr\":\n          promises.push(\n            new Promise(async (resolve) => {\n              const id = [data.kind, data.pubkey, data.identifier].join(\":\");\n              let relays = data.relays ?? [];\n              if (relays.length === 0) {\n                relays = [await maybeGetEventRelayUrl(entity)];\n              }\n              addTagIfNew([\"q\", id, relays[0]]);\n              addTagIfNew([\"p\", data.pubkey]);\n              resolve();\n            })\n          );\n          break;\n        default:\n          return tag;\n      }\n      if (t) addTagIfNew(t);\n      return `nostr:${entity}`;\n    } catch (_error) {\n      return tag;\n    }\n  });\n  await Promise.all(promises);\n  const newTags = generateHashtags(content).map((hashtag) => [\"t\", hashtag]);\n  tags = mergeTags(tags, newTags);\n  return { content, tags };\n}\nasync function maybeGetEventRelayUrl(_nip19Id) {\n  return \"\";\n}\n\n// src/events/encryption.ts\nasync function encrypt(recipient, signer, scheme = \"nip44\") {\n  let encrypted;\n  if (!this.ndk) throw new Error(\"No NDK instance found!\");\n  let currentSigner = signer;\n  if (!currentSigner) {\n    this.ndk.assertSigner();\n    currentSigner = this.ndk.signer;\n  }\n  if (!currentSigner) throw new Error(\"no NDK signer\");\n  const currentRecipient = recipient || (() => {\n    const pTags = this.getMatchingTags(\"p\");\n    if (pTags.length !== 1) {\n      throw new Error(\"No recipient could be determined and no explicit recipient was provided\");\n    }\n    return this.ndk.getUser({ pubkey: pTags[0][1] });\n  })();\n  if (scheme === \"nip44\" && await isEncryptionEnabled(currentSigner, \"nip44\")) {\n    encrypted = await currentSigner.encrypt(currentRecipient, this.content, \"nip44\");\n  }\n  if ((!encrypted || scheme === \"nip04\") && await isEncryptionEnabled(currentSigner, \"nip04\")) {\n    encrypted = await currentSigner.encrypt(currentRecipient, this.content, \"nip04\");\n  }\n  if (!encrypted) throw new Error(\"Failed to encrypt event.\");\n  this.content = encrypted;\n}\nasync function decrypt(sender, signer, scheme) {\n  if (this.ndk?.cacheAdapter?.getDecryptedEvent) {\n    let cachedEvent = null;\n    if (typeof this.ndk.cacheAdapter.getDecryptedEvent === \"function\") {\n      cachedEvent = this.ndk.cacheAdapter.getDecryptedEvent(this.id);\n    }\n    if (cachedEvent) {\n      this.content = cachedEvent.content;\n      return;\n    }\n  }\n  let decrypted;\n  if (!this.ndk) throw new Error(\"No NDK instance found!\");\n  let currentSigner = signer;\n  if (!currentSigner) {\n    this.ndk.assertSigner();\n    currentSigner = this.ndk.signer;\n  }\n  if (!currentSigner) throw new Error(\"no NDK signer\");\n  const currentSender = sender || this.author;\n  if (!currentSender) throw new Error(\"No sender provided and no author available\");\n  const currentScheme = scheme || (this.content.match(/\\\\?iv=/) ? \"nip04\" : \"nip44\");\n  if ((currentScheme === \"nip04\" || this.kind === 4) && await isEncryptionEnabled(currentSigner, \"nip04\") && this.content.search(\"\\\\?iv=\")) {\n    decrypted = await currentSigner.decrypt(currentSender, this.content, \"nip04\");\n  }\n  if (!decrypted && currentScheme === \"nip44\" && await isEncryptionEnabled(currentSigner, \"nip44\")) {\n    decrypted = await currentSigner.decrypt(currentSender, this.content, \"nip44\");\n  }\n  if (!decrypted) throw new Error(\"Failed to decrypt event.\");\n  this.content = decrypted;\n  if (this.ndk?.cacheAdapter?.addDecryptedEvent) {\n    this.ndk.cacheAdapter.addDecryptedEvent(this);\n  }\n}\nasync function isEncryptionEnabled(signer, scheme) {\n  if (!signer.encryptionEnabled) return false;\n  if (!scheme) return true;\n  return Boolean(await signer.encryptionEnabled(scheme));\n}\n\n// src/thread/index.ts\nfunction eventsBySameAuthor(op, events) {\n  const eventsByAuthor = /* @__PURE__ */ new Map();\n  eventsByAuthor.set(op.id, op);\n  events.forEach((event) => {\n    if (event.pubkey === op.pubkey) {\n      eventsByAuthor.set(event.id, event);\n    }\n  });\n  return eventsByAuthor;\n}\nvar hasMarkers = (event, tagType) => {\n  return event.getMatchingTags(tagType).some((tag) => tag[3] && tag[3] !== \"\");\n};\nfunction eventIsReply(op, event, threadIds = /* @__PURE__ */ new Set(), tagType) {\n  tagType ??= op.tagType();\n  const tags = event.getMatchingTags(tagType);\n  threadIds.add(op.tagId());\n  if (threadIds.has(event.tagId())) return false;\n  const heedExplicitReplyMarker = () => {\n    let eventIsTagged = false;\n    for (const tag of tags) {\n      if (tag[3] === \"reply\") return threadIds.has(tag[1]);\n      const markerIsEmpty = tag[3] === \"\" || tag[3] === void 0;\n      const markerIsRoot = tag[3] === \"root\";\n      if (tag[1] === op.tagId() && (markerIsEmpty || markerIsRoot)) {\n        eventIsTagged = markerIsRoot ? \"root\" : true;\n      }\n    }\n    if (!eventIsTagged) return false;\n    if (eventIsTagged === \"root\") return true;\n  };\n  const explicitReplyMarker = heedExplicitReplyMarker();\n  if (explicitReplyMarker !== void 0) return explicitReplyMarker;\n  if (hasMarkers(event, tagType)) return false;\n  const expectedTags = op.getMatchingTags(\"e\").map((tag) => tag[1]);\n  expectedTags.push(op.id);\n  return event.getMatchingTags(\"e\").every((tag) => expectedTags.includes(tag[1]));\n}\nfunction eventThreads(op, events) {\n  const eventsByAuthor = eventsBySameAuthor(op, events);\n  const threadEvents = events.filter((event) => eventIsPartOfThread(op, event, eventsByAuthor));\n  return threadEvents.sort((a, b) => a.created_at - b.created_at);\n}\nfunction getEventReplyId(event) {\n  const replyTag = getReplyTag(event);\n  if (replyTag) return replyTag[1];\n  const rootTag = getRootTag(event);\n  if (rootTag) return rootTag[1];\n}\nfunction isEventOriginalPost(event) {\n  return getEventReplyId(event) === void 0;\n}\nfunction eventThreadIds(op, events) {\n  const threadIds = /* @__PURE__ */ new Map();\n  const threadEvents = eventThreads(op, events);\n  threadEvents.forEach((event) => threadIds.set(event.id, event));\n  return threadIds;\n}\nfunction eventReplies(op, events, threadEventIds) {\n  threadEventIds ??= new Set(eventThreadIds(op, events).keys());\n  return events.filter((event) => eventIsReply(op, event, threadEventIds));\n}\nfunction eventIsPartOfThread(op, event, eventsByAuthor) {\n  if (op.pubkey !== event.pubkey) return false;\n  const taggedEventIds = event.getMatchingTags(\"e\").map((tag) => tag[1]);\n  const allTaggedEventsAreByOriginalAuthor = taggedEventIds.every((id) => eventsByAuthor.has(id));\n  return allTaggedEventsAreByOriginalAuthor;\n}\nfunction eventHasETagMarkers(event) {\n  for (const tag of event.tags) {\n    if (tag[0] === \"e\" && (tag[3] ?? \"\").length > 0) return true;\n  }\n  return false;\n}\nfunction getRootEventId(event, searchTag) {\n  searchTag ??= event.tagType();\n  const rootEventTag = getRootTag(event, searchTag);\n  if (rootEventTag) return rootEventTag[1];\n  const replyTag = getReplyTag(event, searchTag);\n  return replyTag?.[1];\n}\nfunction getRootTag(event, searchTag) {\n  searchTag ??= event.tagType();\n  const rootEventTag = event.tags.find(isTagRootTag);\n  if (!rootEventTag) {\n    if (eventHasETagMarkers(event)) return;\n    const matchingTags = event.getMatchingTags(searchTag);\n    if (matchingTags.length < 3) return matchingTags[0];\n  }\n  return rootEventTag;\n}\nvar nip22RootTags = /* @__PURE__ */ new Set([\"A\", \"E\", \"I\"]);\nvar nip22ReplyTags = /* @__PURE__ */ new Set([\"a\", \"e\", \"i\"]);\nfunction getReplyTag(event, searchTag) {\n  if (event.kind === 1111 /* GenericReply */) {\n    let replyTag2;\n    for (const tag of event.tags) {\n      if (nip22RootTags.has(tag[0])) replyTag2 = tag;\n      else if (nip22ReplyTags.has(tag[0])) {\n        replyTag2 = tag;\n        break;\n      }\n    }\n    return replyTag2;\n  }\n  searchTag ??= event.tagType();\n  let hasMarkers2 = false;\n  let replyTag;\n  for (const tag of event.tags) {\n    if (tag[0] !== searchTag) continue;\n    if ((tag[3] ?? \"\").length > 0) hasMarkers2 = true;\n    if (hasMarkers2 && tag[3] === \"reply\") return tag;\n    if (hasMarkers2 && tag[3] === \"root\") replyTag = tag;\n    if (!hasMarkers2) replyTag = tag;\n  }\n  return replyTag;\n}\nfunction isTagRootTag(tag) {\n  return tag[0] === \"E\" || tag[3] === \"root\";\n}\n\n// src/events/fetch-tagged-event.ts\nasync function fetchTaggedEvent(tag, marker) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const t = this.getMatchingTags(tag, marker);\n  if (t.length === 0) return void 0;\n  const [_, id, hint] = t[0];\n  let relay = hint !== \"\" ? this.ndk.pool.getRelay(hint) : void 0;\n  const event = await this.ndk.fetchEvent(id, {}, relay);\n  return event;\n}\nasync function fetchRootEvent(subOpts) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const rootTag = getRootTag(this);\n  if (!rootTag) return void 0;\n  return this.ndk.fetchEventFromTag(rootTag, this, subOpts);\n}\nasync function fetchReplyEvent(subOpts) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const replyTag = getReplyTag(this);\n  if (!replyTag) return void 0;\n  return this.ndk.fetchEventFromTag(replyTag, this, subOpts);\n}\n\n// src/events/kind.ts\nfunction isReplaceable() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return [0, 3].includes(this.kind) || this.kind >= 1e4 && this.kind < 2e4 || this.kind >= 3e4 && this.kind < 4e4;\n}\nfunction isEphemeral() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return this.kind >= 2e4 && this.kind < 3e4;\n}\nfunction isParamReplaceable() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return this.kind >= 3e4 && this.kind < 4e4;\n}\n\n// src/events/nip19.ts\n\nvar DEFAULT_RELAY_COUNT = 2;\nfunction encode(maxRelayCount = DEFAULT_RELAY_COUNT) {\n  let relays = [];\n  if (this.onRelays.length > 0) {\n    relays = this.onRelays.map((relay) => relay.url);\n  } else if (this.relay) {\n    relays = [this.relay.url];\n  }\n  if (relays.length > maxRelayCount) {\n    relays = relays.slice(0, maxRelayCount);\n  }\n  if (this.isParamReplaceable()) {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.naddrEncode({\n      kind: this.kind,\n      pubkey: this.pubkey,\n      identifier: this.replaceableDTag(),\n      relays\n    });\n  }\n  if (relays.length > 0) {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.neventEncode({\n      id: this.tagId(),\n      relays,\n      author: this.pubkey\n    });\n  }\n  return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.noteEncode(this.tagId());\n}\n\n// src/events/repost.ts\nasync function repost(publish = true, signer) {\n  if (!signer && publish) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    signer = this.ndk.signer;\n  }\n  const e = new NDKEvent(this.ndk, {\n    kind: getKind(this)\n  });\n  if (!this.isProtected) e.content = JSON.stringify(this.rawEvent());\n  e.tag(this);\n  if (this.kind !== 1 /* Text */) {\n    e.tags.push([\"k\", `${this.kind}`]);\n  }\n  if (signer) await e.sign(signer);\n  if (publish) await e.publish();\n  return e;\n}\nfunction getKind(event) {\n  if (event.kind === 1) {\n    return 6 /* Repost */;\n  }\n  return 16 /* GenericRepost */;\n}\n\n// src/events/serializer.ts\nfunction serialize(includeSig = false, includeId = false) {\n  const payload = [0, this.pubkey, this.created_at, this.kind, this.tags, this.content];\n  if (includeSig) payload.push(this.sig);\n  if (includeId) payload.push(this.id);\n  return JSON.stringify(payload);\n}\nfunction deserialize(serializedEvent) {\n  const eventArray = JSON.parse(serializedEvent);\n  const ret = {\n    pubkey: eventArray[1],\n    created_at: eventArray[2],\n    kind: eventArray[3],\n    tags: eventArray[4],\n    content: eventArray[5]\n  };\n  if (eventArray.length >= 7) {\n    const first = eventArray[6];\n    const second = eventArray[7];\n    if (first && first.length === 128) {\n      ret.sig = first;\n      if (second && second.length === 64) {\n        ret.id = second;\n      }\n    } else if (first && first.length === 64) {\n      ret.id = first;\n      if (second && second.length === 128) {\n        ret.sig = second;\n      }\n    }\n  }\n  return ret;\n}\n\n// src/events/validation.ts\n\n\n\n\n\n// src/events/signature.ts\nvar worker;\nvar processingQueue = {};\nfunction signatureVerificationInit(w) {\n  worker = w;\n  worker.onmessage = (msg) => {\n    const [eventId, result] = msg.data;\n    const record = processingQueue[eventId];\n    if (!record) {\n      console.error(\"No record found for event\", eventId);\n      return;\n    }\n    delete processingQueue[eventId];\n    for (const resolve of record.resolves) {\n      resolve(result);\n    }\n  };\n}\nasync function verifySignatureAsync(event, _persist, relay) {\n  const ndkInstance = event.ndk;\n  const start = Date.now();\n  let result;\n  if (ndkInstance.signatureVerificationFunction) {\n    console.log(\"[NDK-CORE] Using custom signature verification function async\");\n    result = await ndkInstance.signatureVerificationFunction(event);\n    console.log(\"Custom signature verification result\", event.id, { result });\n  } else {\n    console.log(\"Using worker-based signature verification async\");\n    result = await new Promise((resolve) => {\n      const serialized = event.serialize();\n      let enqueue = false;\n      if (!processingQueue[event.id]) {\n        processingQueue[event.id] = { event, resolves: [], relay };\n        enqueue = true;\n      }\n      processingQueue[event.id].resolves.push(resolve);\n      if (!enqueue) return;\n      worker?.postMessage({\n        serialized,\n        id: event.id,\n        sig: event.sig,\n        pubkey: event.pubkey\n      });\n    });\n  }\n  ndkInstance.signatureVerificationTimeMs += Date.now() - start;\n  return result;\n}\n\n// src/events/validation.ts\nvar PUBKEY_REGEX = /^[a-f0-9]{64}$/;\nfunction validate() {\n  if (typeof this.kind !== \"number\") return false;\n  if (typeof this.content !== \"string\") return false;\n  if (typeof this.created_at !== \"number\") return false;\n  if (typeof this.pubkey !== \"string\") return false;\n  if (!this.pubkey.match(PUBKEY_REGEX)) return false;\n  if (!Array.isArray(this.tags)) return false;\n  for (let i = 0; i < this.tags.length; i++) {\n    const tag = this.tags[i];\n    if (!Array.isArray(tag)) return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\") return false;\n    }\n  }\n  return true;\n}\nvar verifiedSignatures = new typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({\n  maxSize: 1e3,\n  entryExpirationTimeInMS: 6e4\n});\nfunction verifySignature(persist) {\n  if (typeof this.signatureVerified === \"boolean\") return this.signatureVerified;\n  const prevVerification = verifiedSignatures.get(this.id);\n  if (prevVerification !== null) {\n    this.signatureVerified = !!prevVerification;\n    return this.signatureVerified;\n  }\n  try {\n    if (this.ndk?.asyncSigVerification) {\n      verifySignatureAsync(this, persist, this.relay).then((result) => {\n        if (persist) {\n          this.signatureVerified = result;\n          if (result) verifiedSignatures.set(this.id, this.sig);\n        }\n        if (!result) {\n          if (this.relay) {\n            this.ndk?.reportInvalidSignature(this, this.relay);\n          } else {\n            this.ndk?.reportInvalidSignature(this);\n          }\n          verifiedSignatures.set(this.id, false);\n        }\n      }).catch((err) => {\n        console.error(\"signature verification error\", this.id, err);\n      });\n    } else {\n      const hash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(new TextEncoder().encode(this.serialize()));\n      const res = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__.schnorr.verify(this.sig, hash, this.pubkey);\n      if (res) verifiedSignatures.set(this.id, this.sig);\n      else verifiedSignatures.set(this.id, false);\n      this.signatureVerified = res;\n      return res;\n    }\n  } catch (_err) {\n    this.signatureVerified = false;\n    return false;\n  }\n}\nfunction getEventHash() {\n  return getEventHashFromSerializedEvent(this.serialize());\n}\nfunction getEventHashFromSerializedEvent(serializedEvent) {\n  const eventHash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(new TextEncoder().encode(serializedEvent));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(eventHash);\n}\n\n// src/events/index.ts\nvar skipClientTagOnKinds = /* @__PURE__ */ new Set([\n  0 /* Metadata */,\n  4 /* EncryptedDirectMessage */,\n  1059 /* GiftWrap */,\n  13 /* GiftWrapSeal */,\n  3 /* Contacts */,\n  9734 /* ZapRequest */,\n  5 /* EventDeletion */\n]);\nvar NDKEvent = class _NDKEvent extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  created_at;\n  content = \"\";\n  tags = [];\n  kind;\n  id = \"\";\n  sig;\n  pubkey = \"\";\n  signatureVerified;\n  _author = void 0;\n  /**\n   * The relay that this event was first received from.\n   */\n  relay;\n  /**\n   * The relays that this event was received from and/or successfully published to.\n   */\n  get onRelays() {\n    let res = [];\n    if (!this.ndk) {\n      if (this.relay) res.push(this.relay);\n    } else {\n      res = this.ndk.subManager.seenEvents.get(this.id) || [];\n    }\n    return res;\n  }\n  /**\n   * The status of the publish operation.\n   */\n  publishStatus = \"success\";\n  publishError;\n  constructor(ndk, event) {\n    super();\n    this.ndk = ndk;\n    this.created_at = event?.created_at;\n    this.content = event?.content || \"\";\n    this.tags = event?.tags || [];\n    this.id = event?.id || \"\";\n    this.sig = event?.sig;\n    this.pubkey = event?.pubkey || \"\";\n    this.kind = event?.kind;\n    if (event instanceof _NDKEvent) {\n      if (this.relay) {\n        this.relay = event.relay;\n        this.ndk?.subManager.seenEvent(event.id, this.relay);\n      }\n      this.publishStatus = event.publishStatus;\n      this.publishError = event.publishError;\n    }\n  }\n  /**\n   * Deserialize an NDKEvent from a serialized payload.\n   * @param ndk\n   * @param event\n   * @returns\n   */\n  static deserialize(ndk, event) {\n    return new _NDKEvent(ndk, deserialize(event));\n  }\n  /**\n   * Returns the event as is.\n   */\n  rawEvent() {\n    return {\n      created_at: this.created_at,\n      content: this.content,\n      tags: this.tags,\n      kind: this.kind,\n      pubkey: this.pubkey,\n      id: this.id,\n      sig: this.sig\n    };\n  }\n  set author(user) {\n    this.pubkey = user.pubkey;\n    this._author = user;\n    this._author.ndk ??= this.ndk;\n  }\n  /**\n   * Returns an NDKUser for the author of the event.\n   */\n  get author() {\n    if (this._author) return this._author;\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const user = this.ndk.getUser({ pubkey: this.pubkey });\n    this._author = user;\n    return user;\n  }\n  /**\n   * NIP-73 tagging of external entities\n   * @param entity to be tagged\n   * @param type of the entity\n   * @param markerUrl to be used as the marker URL\n   *\n   * @example\n   * ```typescript\n   * event.tagExternal(\"https://example.com/article/123#nostr\", \"url\");\n   * event.tags => [[\"i\", \"https://example.com/123\"], [\"k\", \"https://example.com\"]]\n   * ```\n   *\n   * @example tag a podcast:item:guid\n   * ```typescript\n   * event.tagExternal(\"e32b4890-b9ea-4aef-a0bf-54b787833dc5\", \"podcast:item:guid\");\n   * event.tags => [[\"i\", \"podcast:item:guid:e32b4890-b9ea-4aef-a0bf-54b787833dc5\"], [\"k\", \"podcast:item:guid\"]]\n   * ```\n   *\n   * @see https://github.com/nostr-protocol/nips/blob/master/73.md\n   */\n  tagExternal(entity, type, markerUrl) {\n    const iTag = [\"i\"];\n    const kTag = [\"k\"];\n    switch (type) {\n      case \"url\": {\n        const url = new URL(entity);\n        url.hash = \"\";\n        iTag.push(url.toString());\n        kTag.push(`${url.protocol}//${url.host}`);\n        break;\n      }\n      case \"hashtag\":\n        iTag.push(`#${entity.toLowerCase()}`);\n        kTag.push(\"#\");\n        break;\n      case \"geohash\":\n        iTag.push(`geo:${entity.toLowerCase()}`);\n        kTag.push(\"geo\");\n        break;\n      case \"isbn\":\n        iTag.push(`isbn:${entity.replace(/-/g, \"\")}`);\n        kTag.push(\"isbn\");\n        break;\n      case \"podcast:guid\":\n        iTag.push(`podcast:guid:${entity}`);\n        kTag.push(\"podcast:guid\");\n        break;\n      case \"podcast:item:guid\":\n        iTag.push(`podcast:item:guid:${entity}`);\n        kTag.push(\"podcast:item:guid\");\n        break;\n      case \"podcast:publisher:guid\":\n        iTag.push(`podcast:publisher:guid:${entity}`);\n        kTag.push(\"podcast:publisher:guid\");\n        break;\n      case \"isan\":\n        iTag.push(`isan:${entity.split(\"-\").slice(0, 4).join(\"-\")}`);\n        kTag.push(\"isan\");\n        break;\n      case \"doi\":\n        iTag.push(`doi:${entity.toLowerCase()}`);\n        kTag.push(\"doi\");\n        break;\n      default:\n        throw new Error(`Unsupported NIP-73 entity type: ${type}`);\n    }\n    if (markerUrl) {\n      iTag.push(markerUrl);\n    }\n    this.tags.push(iTag);\n    this.tags.push(kTag);\n  }\n  /**\n   * Tag a user with an optional marker.\n   * @param target What is to be tagged. Can be an NDKUser, NDKEvent, or an NDKTag.\n   * @param marker The marker to use in the tag.\n   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event.\n   * @param forceTag Force a specific tag to be used instead of the default \"e\" or \"a\" tag.\n   * @example\n   * ```typescript\n   * reply.tag(opEvent, \"reply\");\n   * // reply.tags => [[\"e\", <id>, <relay>, \"reply\"]]\n   * ```\n   */\n  tag(target, marker, skipAuthorTag, forceTag) {\n    let tags = [];\n    const isNDKUser = target.fetchProfile !== void 0;\n    if (isNDKUser) {\n      forceTag ??= \"p\";\n      const tag = [forceTag, target.pubkey];\n      if (marker) tag.push(...[\"\", marker]);\n      tags.push(tag);\n    } else if (target instanceof _NDKEvent) {\n      const event = target;\n      skipAuthorTag ??= event?.pubkey === this.pubkey;\n      tags = event.referenceTags(marker, skipAuthorTag, forceTag);\n      for (const pTag of event.getMatchingTags(\"p\")) {\n        if (pTag[1] === this.pubkey) continue;\n        if (this.tags.find((t) => t[0] === \"p\" && t[1] === pTag[1])) continue;\n        this.tags.push([\"p\", pTag[1]]);\n      }\n    } else if (Array.isArray(target)) {\n      tags = [target];\n    } else {\n      throw new Error(\"Invalid argument\", target);\n    }\n    this.tags = mergeTags(this.tags, tags);\n  }\n  /**\n   * Return a NostrEvent object, trying to fill in missing fields\n   * when possible, adding tags when necessary.\n   * @param pubkey {string} The pubkey of the user who the event belongs to.\n   * @returns {Promise<NostrEvent>} A promise that resolves to a NostrEvent.\n   */\n  async toNostrEvent(pubkey) {\n    if (!pubkey && this.pubkey === \"\") {\n      const user = await this.ndk?.signer?.user();\n      this.pubkey = user?.pubkey || \"\";\n    }\n    if (!this.created_at) {\n      this.created_at = Math.floor(Date.now() / 1e3);\n    }\n    const { content, tags } = await this.generateTags();\n    this.content = content || \"\";\n    this.tags = tags;\n    try {\n      this.id = this.getEventHash();\n    } catch (_e) {\n    }\n    return this.rawEvent();\n  }\n  serialize = serialize.bind(this);\n  getEventHash = getEventHash.bind(this);\n  validate = validate.bind(this);\n  verifySignature = verifySignature.bind(this);\n  /**\n   * Is this event replaceable (whether parameterized or not)?\n   *\n   * This will return true for kind 0, 3, 10k-20k and 30k-40k\n   */\n  isReplaceable = isReplaceable.bind(this);\n  isEphemeral = isEphemeral.bind(this);\n  isDvm = () => this.kind && this.kind >= 5e3 && this.kind <= 7e3;\n  /**\n   * Is this event parameterized replaceable?\n   *\n   * This will return true for kind 30k-40k\n   */\n  isParamReplaceable = isParamReplaceable.bind(this);\n  /**\n   * Encodes a bech32 id.\n   *\n   * @param relays {string[]} The relays to encode in the id\n   * @returns {string} - Encoded naddr, note or nevent.\n   */\n  encode = encode.bind(this);\n  encrypt = encrypt.bind(this);\n  decrypt = decrypt.bind(this);\n  /**\n   * Get all tags with the given name\n   * @param tagName {string} The name of the tag to search for\n   * @returns {NDKTag[]} An array of the matching tags\n   */\n  getMatchingTags(tagName, marker) {\n    const t = this.tags.filter((tag) => tag[0] === tagName);\n    if (marker === void 0) return t;\n    return t.filter((tag) => tag[3] === marker);\n  }\n  /**\n   * Check if the event has a tag with the given name\n   * @param tagName\n   * @param marker\n   * @returns\n   */\n  hasTag(tagName, marker) {\n    return this.tags.some((tag) => tag[0] === tagName && (!marker || tag[3] === marker));\n  }\n  /**\n   * Get the first tag with the given name\n   * @param tagName Tag name to search for\n   * @returns The value of the first tag with the given name, or undefined if no such tag exists\n   */\n  tagValue(tagName, marker) {\n    const tags = this.getMatchingTags(tagName, marker);\n    if (tags.length === 0) return void 0;\n    return tags[0][1];\n  }\n  /**\n   * Gets the NIP-31 \"alt\" tag of the event.\n   */\n  get alt() {\n    return this.tagValue(\"alt\");\n  }\n  /**\n   * Sets the NIP-31 \"alt\" tag of the event. Use this to set an alt tag so\n   * clients that don't handle a particular event kind can display something\n   * useful for users.\n   */\n  set alt(alt) {\n    this.removeTag(\"alt\");\n    if (alt) this.tags.push([\"alt\", alt]);\n  }\n  /**\n   * Gets the NIP-33 \"d\" tag of the event.\n   */\n  get dTag() {\n    return this.tagValue(\"d\");\n  }\n  /**\n   * Sets the NIP-33 \"d\" tag of the event.\n   */\n  set dTag(value) {\n    this.removeTag(\"d\");\n    if (value) this.tags.push([\"d\", value]);\n  }\n  /**\n   * Remove all tags with the given name (e.g. \"d\", \"a\", \"p\")\n   * @param tagName Tag name(s) to search for and remove\n   * @param marker Optional marker to check for too\n   *\n   * @example\n   * Remove a tags with a \"defer\" marker\n   * ```typescript\n   * event.tags = [\n   *   [\"a\", \"....\", \"defer\"],\n   *   [\"a\", \"....\", \"no-defer\"],\n   * ]\n   *\n   * event.removeTag(\"a\", \"defer\");\n   *\n   * // event.tags => [[\"a\", \"....\", \"no-defer\"]]\n   *\n   * @returns {void}\n   */\n  removeTag(tagName, marker) {\n    const tagNames = Array.isArray(tagName) ? tagName : [tagName];\n    this.tags = this.tags.filter((tag) => {\n      const include = tagNames.includes(tag[0]);\n      const hasMarker = marker ? tag[3] === marker : true;\n      return !(include && hasMarker);\n    });\n  }\n  /**\n   * Replace a tag with a new value. If not found, it will be added.\n   * @param tag The tag to replace.\n   * @param value The new value for the tag.\n   */\n  replaceTag(tag) {\n    this.removeTag(tag[0]);\n    this.tags.push(tag);\n  }\n  /**\n   * Sign the event if a signer is present.\n   *\n   * It will generate tags.\n   * Repleacable events will have their created_at field set to the current time.\n   * @param signer {NDKSigner} The NDKSigner to use to sign the event\n   * @returns {Promise<string>} A Promise that resolves to the signature of the signed event.\n   */\n  async sign(signer) {\n    if (!signer) {\n      this.ndk?.assertSigner();\n      signer = this.ndk?.signer;\n    } else {\n      this.author = await signer.user();\n    }\n    const nostrEvent = await this.toNostrEvent();\n    this.sig = await signer.sign(nostrEvent);\n    return this.sig;\n  }\n  /**\n   *\n   * @param relaySet\n   * @param timeoutMs\n   * @param requiredRelayCount\n   * @returns\n   */\n  async publishReplaceable(relaySet, timeoutMs, requiredRelayCount) {\n    this.id = \"\";\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.sig = \"\";\n    return this.publish(relaySet, timeoutMs, requiredRelayCount);\n  }\n  /**\n   * Attempt to sign and then publish an NDKEvent to a given relaySet.\n   * If no relaySet is provided, the relaySet will be calculated by NDK.\n   * @param relaySet {NDKRelaySet} The relaySet to publish the even to.\n   * @param timeoutM {number} The timeout for the publish operation in milliseconds.\n   * @param requiredRelayCount The number of relays that must receive the event for the publish to be considered successful.\n   * @returns A promise that resolves to the relays the event was published to.\n   */\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    if (!requiredRelayCount) requiredRelayCount = 1;\n    if (!this.sig) await this.sign();\n    if (!this.ndk) throw new Error(\"NDKEvent must be associated with an NDK instance to publish\");\n    if (!relaySet || relaySet.size === 0) {\n      relaySet = this.ndk.devWriteRelaySet || await calculateRelaySetFromEvent(this.ndk, this, requiredRelayCount);\n    }\n    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {\n      const eTags = this.getMatchingTags(\"e\").map((tag) => tag[1]);\n      this.ndk.cacheAdapter.deleteEventIds(eTags);\n    }\n    const rawEvent = this.rawEvent();\n    if (this.ndk.cacheAdapter?.addUnpublishedEvent && shouldTrackUnpublishedEvent(this)) {\n      try {\n        this.ndk.cacheAdapter.addUnpublishedEvent(this, relaySet.relayUrls);\n      } catch (e) {\n        console.error(\"Error adding unpublished event to cache\", e);\n      }\n    }\n    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {\n      this.ndk.cacheAdapter.deleteEventIds(this.getMatchingTags(\"e\").map((tag) => tag[1]));\n    }\n    this.ndk.subManager.dispatchEvent(rawEvent, void 0, true);\n    const relays = await relaySet.publish(this, timeoutMs, requiredRelayCount);\n    relays.forEach((relay) => this.ndk?.subManager.seenEvent(this.id, relay));\n    return relays;\n  }\n  /**\n   * Generates tags for users, notes, and other events tagged in content.\n   * Will also generate random \"d\" tag for parameterized replaceable events where needed.\n   * @returns {ContentTag} The tags and content of the event.\n   */\n  async generateTags() {\n    let tags = [];\n    const g = await generateContentTags(this.content, this.tags);\n    const content = g.content;\n    tags = g.tags;\n    if (this.kind && this.isParamReplaceable()) {\n      const dTag = this.getMatchingTags(\"d\")[0];\n      if (!dTag) {\n        const title = this.tagValue(\"title\");\n        const randLength = title ? 6 : 16;\n        let str = [...Array(randLength)].map(() => Math.random().toString(36)[2]).join(\"\");\n        if (title && title.length > 0) {\n          str = `${title.replace(/[^a-z0-9]+/gi, \"-\").replace(/^-|-$/g, \"\")}-${str}`;\n        }\n        tags.push([\"d\", str]);\n      }\n    }\n    if (this.shouldAddClientTag) {\n      const clientTag = [\"client\", this.ndk?.clientName ?? \"\"];\n      if (this.ndk?.clientNip89) clientTag.push(this.ndk?.clientNip89);\n      tags.push(clientTag);\n    } else if (this.shouldStripClientTag) {\n      tags = tags.filter((tag) => tag[0] !== \"client\");\n    }\n    return { content: content || \"\", tags };\n  }\n  get shouldAddClientTag() {\n    if (!this.ndk?.clientName && !this.ndk?.clientNip89) return false;\n    if (skipClientTagOnKinds.has(this.kind)) return false;\n    if (this.isEphemeral()) return false;\n    if (this.isReplaceable() && !this.isParamReplaceable()) return false;\n    if (this.isDvm()) return false;\n    if (this.hasTag(\"client\")) return false;\n    return true;\n  }\n  get shouldStripClientTag() {\n    return skipClientTagOnKinds.has(this.kind);\n  }\n  muted() {\n    const authorMutedEntry = this.ndk?.mutedIds.get(this.pubkey);\n    if (authorMutedEntry && authorMutedEntry === \"p\") return \"author\";\n    const eventTagReference = this.tagReference();\n    const eventMutedEntry = this.ndk?.mutedIds.get(eventTagReference[1]);\n    if (eventMutedEntry && eventMutedEntry === eventTagReference[0]) return \"event\";\n    return null;\n  }\n  /**\n   * Returns the \"d\" tag of a parameterized replaceable event or throws an error if the event isn't\n   * a parameterized replaceable event.\n   * @returns {string} the \"d\" tag of the event.\n   *\n   * @deprecated Use `dTag` instead.\n   */\n  replaceableDTag() {\n    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {\n      const dTag = this.getMatchingTags(\"d\")[0];\n      const dTagId = dTag ? dTag[1] : \"\";\n      return dTagId;\n    }\n    throw new Error(\"Event is not a parameterized replaceable event\");\n  }\n  /**\n   * Provides a deduplication key for the event.\n   *\n   * For kinds 0, 3, 10k-20k this will be the event <kind>:<pubkey>\n   * For kinds 30k-40k this will be the event <kind>:<pubkey>:<d-tag>\n   * For all other kinds this will be the event id\n   */\n  deduplicationKey() {\n    if (this.kind === 0 || this.kind === 3 || this.kind && this.kind >= 1e4 && this.kind < 2e4) {\n      return `${this.kind}:${this.pubkey}`;\n    }\n    return this.tagId();\n  }\n  /**\n   * Returns the id of the event or, if it's a parameterized event, the generated id of the event using \"d\" tag, pubkey, and kind.\n   * @returns {string} The id\n   */\n  tagId() {\n    if (this.isParamReplaceable()) {\n      return this.tagAddress();\n    }\n    return this.id;\n  }\n  /**\n   * Returns a stable reference value for a replaceable event.\n   *\n   * Param replaceable events are returned in the expected format of `<kind>:<pubkey>:<d-tag>`.\n   * Kind-replaceable events are returned in the format of `<kind>:<pubkey>:`.\n   *\n   * @returns {string} A stable reference value for replaceable events\n   */\n  tagAddress() {\n    if (this.isParamReplaceable()) {\n      const dTagId = this.dTag ?? \"\";\n      return `${this.kind}:${this.pubkey}:${dTagId}`;\n    }\n    if (this.isReplaceable()) {\n      return `${this.kind}:${this.pubkey}:`;\n    }\n    throw new Error(\"Event is not a replaceable event\");\n  }\n  /**\n   * Determines the type of tag that can be used to reference this event from another event.\n   * @returns {string} The tag type\n   * @example\n   * event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   * event.tagType(); // \"a\"\n   */\n  tagType() {\n    return this.isParamReplaceable() ? \"a\" : \"e\";\n  }\n  /**\n   * Get the tag that can be used to reference this event from another event.\n   *\n   * Consider using referenceTags() instead (unless you have a good reason to use this)\n   *\n   * @example\n   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *     event.tagReference(); // [\"a\", \"30000:pubkey:d-code\"]\n   *\n   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *     event.tagReference(); // [\"e\", \"eventid\"]\n   * @returns {NDKTag} The NDKTag object referencing this event\n   */\n  tagReference(marker) {\n    let tag;\n    if (this.isParamReplaceable()) {\n      tag = [\"a\", this.tagAddress()];\n    } else {\n      tag = [\"e\", this.tagId()];\n    }\n    if (this.relay) {\n      tag.push(this.relay.url);\n    } else {\n      tag.push(\"\");\n    }\n    tag.push(marker ?? \"\");\n    if (!this.isParamReplaceable()) {\n      tag.push(this.pubkey);\n    }\n    return tag;\n  }\n  /**\n   * Get the tags that can be used to reference this event from another event\n   * @param marker The marker to use in the tag\n   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event\n   * @param forceTag Force a specific tag to be used instead of the default \"e\" or \"a\" tag\n   * @example\n   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *     event.referenceTags(); // [[\"a\", \"30000:pubkey:d-code\"], [\"e\", \"parent-id\"]]\n   *\n   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *     event.referenceTags(); // [[\"e\", \"parent-id\"]]\n   * @returns {NDKTag} The NDKTag object referencing this event\n   */\n  referenceTags(marker, skipAuthorTag, forceTag) {\n    let tags = [];\n    if (this.isParamReplaceable()) {\n      tags = [\n        [forceTag ?? \"a\", this.tagAddress()],\n        [forceTag ?? \"e\", this.id]\n      ];\n    } else {\n      tags = [[forceTag ?? \"e\", this.id]];\n    }\n    tags = tags.map((tag) => {\n      if (tag[0] === \"e\" || marker) {\n        tag.push(this.relay?.url ?? \"\");\n      } else if (this.relay?.url) {\n        tag.push(this.relay?.url);\n      }\n      return tag;\n    });\n    tags.forEach((tag) => {\n      if (tag[0] === \"e\") {\n        tag.push(marker ?? \"\");\n        tag.push(this.pubkey);\n      } else if (marker) {\n        tag.push(marker);\n      }\n    });\n    tags = [...tags, ...this.getMatchingTags(\"h\")];\n    if (!skipAuthorTag) tags.push(...this.author.referenceTags());\n    return tags;\n  }\n  /**\n   * Provides the filter that will return matching events for this event.\n   *\n   * @example\n   *    event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *    event.filter(); // { \"#a\": [\"30000:pubkey:d-code\"] }\n   * @example\n   *    event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *    event.filter(); // { \"#e\": [\"eventid\"] }\n   *\n   * @returns The filter that will return matching events for this event\n   */\n  filter() {\n    if (this.isParamReplaceable()) {\n      return { \"#a\": [this.tagId()] };\n    }\n    return { \"#e\": [this.tagId()] };\n  }\n  nip22Filter() {\n    if (this.isParamReplaceable()) {\n      return { \"#A\": [this.tagId()] };\n    }\n    return { \"#E\": [this.tagId()] };\n  }\n  /**\n   * Generates a deletion event of the current event\n   *\n   * @param reason The reason for the deletion\n   * @param publish Whether to publish the deletion event automatically\n   * @returns The deletion event\n   */\n  async delete(reason, publish = true) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const e = new _NDKEvent(this.ndk, {\n      kind: 5 /* EventDeletion */,\n      content: reason || \"\"\n    });\n    e.tag(this, void 0, true);\n    e.tags.push([\"k\", this.kind?.toString()]);\n    if (publish) {\n      this.emit(\"deleted\");\n      await e.publish();\n    }\n    return e;\n  }\n  /**\n   * Establishes whether this is a NIP-70-protectede event.\n   * @@satisfies NIP-70\n   */\n  set isProtected(val) {\n    this.removeTag(\"-\");\n    if (val) this.tags.push([\"-\"]);\n  }\n  /**\n   * Whether this is a NIP-70-protected event.\n   * @@satisfies NIP-70\n   */\n  get isProtected() {\n    return this.hasTag(\"-\");\n  }\n  /**\n   * Fetch an event tagged with the given tag following relay hints if provided.\n   * @param tag The tag to search for\n   * @param marker The marker to use in the tag (e.g. \"root\")\n   * @returns The fetched event or null if no event was found, undefined if no matching tag was found in the event\n   * * @example\n   * const replyEvent = await ndk.fetchEvent(\"nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd\")\n   * const originalEvent = await replyEvent.fetchTaggedEvent(\"e\", \"reply\");\n   * console.log(replyEvent.encode() + \" is a reply to event \" + originalEvent?.encode());\n   */\n  fetchTaggedEvent = fetchTaggedEvent.bind(this);\n  /**\n   * Fetch the root event of the current event.\n   * @returns The fetched root event or null if no event was found\n   * @example\n   * const replyEvent = await ndk.fetchEvent(\"nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd\")\n   * const rootEvent = await replyEvent.fetchRootEvent();\n   * console.log(replyEvent.encode() + \" is a reply in the thread \" + rootEvent?.encode());\n   */\n  fetchRootEvent = fetchRootEvent.bind(this);\n  /**\n   * Fetch the event the current event is replying to.\n   * @returns The fetched reply event or null if no event was found\n   */\n  fetchReplyEvent = fetchReplyEvent.bind(this);\n  /**\n   * NIP-18 reposting event.\n   *\n   * @param publish Whether to publish the reposted event automatically @default true\n   * @param signer The signer to use for signing the reposted event\n   * @returns The reposted event\n   *\n   * @function\n   */\n  repost = repost.bind(this);\n  /**\n   * React to an existing event\n   *\n   * @param content The content of the reaction\n   */\n  async react(content, publish = true) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const e = new _NDKEvent(this.ndk, {\n      kind: 7 /* Reaction */,\n      content\n    });\n    e.tag(this);\n    if (this.kind !== 1 /* Text */) {\n      e.tags.push([\"k\", `${this.kind}`]);\n    }\n    if (publish) await e.publish();\n    return e;\n  }\n  /**\n   * Checks whether the event is valid per underlying NIPs.\n   *\n   * This method is meant to be overridden by subclasses that implement specific NIPs\n   * to allow the enforcement of NIP-specific validation rules.\n   *\n   * Otherwise, it will only check for basic event properties.\n   *\n   */\n  get isValid() {\n    return this.validate();\n  }\n  get inspect() {\n    return JSON.stringify(this.rawEvent(), null, 4);\n  }\n  /**\n   * Dump the event to console for debugging purposes.\n   * Prints a JSON stringified version of rawEvent() with indentation\n   * and also lists all relay URLs for onRelays.\n   */\n  dump() {\n    console.debug(JSON.stringify(this.rawEvent(), null, 4));\n    console.debug(\"Event on relays:\", this.onRelays.map((relay) => relay.url).join(\", \"));\n  }\n  /**\n   * Creates a reply event for the current event.\n   *\n   * This function will use NIP-22 when appropriate (i.e. replies to non-kind:1 events).\n   * This function does not have side-effects; it will just return an event with the appropriate tags\n   * to generate the reply event; the caller is responsible for publishing the event.\n   *\n   * @param forceNip22 - Optional flag to force NIP-22 style replies (kind 1111) regardless of the original event's kind\n   */\n  reply(forceNip22) {\n    const reply = new _NDKEvent(this.ndk);\n    if (this.kind === 1 && !forceNip22) {\n      reply.kind = 1;\n      const opHasETag = this.hasTag(\"e\");\n      if (opHasETag) {\n        reply.tags = [\n          ...reply.tags,\n          ...this.getMatchingTags(\"e\"),\n          ...this.getMatchingTags(\"p\"),\n          ...this.getMatchingTags(\"a\"),\n          ...this.referenceTags(\"reply\")\n        ];\n      } else {\n        reply.tag(this, \"root\");\n      }\n    } else {\n      reply.kind = 1111 /* GenericReply */;\n      const carryOverTags = [\"A\", \"E\", \"I\", \"P\"];\n      const rootTags = this.tags.filter((tag) => carryOverTags.includes(tag[0]));\n      if (rootTags.length > 0) {\n        const rootKind = this.tagValue(\"K\");\n        reply.tags.push(...rootTags);\n        if (rootKind) reply.tags.push([\"K\", rootKind]);\n        const [type, id, _, ...extra] = this.tagReference();\n        const tag = [type, id, ...extra];\n        reply.tags.push(tag);\n      } else {\n        const [type, id, _, relayHint] = this.tagReference();\n        const tag = [type, id, relayHint ?? \"\"];\n        if (type === \"e\") tag.push(this.pubkey);\n        reply.tags.push(tag);\n        const uppercaseTag = [...tag];\n        uppercaseTag[0] = uppercaseTag[0].toUpperCase();\n        reply.tags.push(uppercaseTag);\n        reply.tags.push([\"K\", this.kind?.toString()]);\n        reply.tags.push([\"P\", this.pubkey]);\n      }\n      reply.tags.push([\"k\", this.kind?.toString()]);\n      reply.tags.push(...this.getMatchingTags(\"p\"));\n      reply.tags.push([\"p\", this.pubkey]);\n    }\n    return reply;\n  }\n};\nvar untrackedUnpublishedEvents = /* @__PURE__ */ new Set([\n  24133 /* NostrConnect */,\n  13194 /* NostrWaletConnectInfo */,\n  23194 /* NostrWalletConnectReq */,\n  23195 /* NostrWalletConnectRes */\n]);\nfunction shouldTrackUnpublishedEvent(event) {\n  return !untrackedUnpublishedEvents.has(event.kind);\n}\n\n// src/relay/pool/index.ts\n\nvar NDKPool = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  // TODO: This should probably be an LRU cache\n  _relays = /* @__PURE__ */ new Map();\n  status = \"idle\";\n  autoConnectRelays = /* @__PURE__ */ new Set();\n  poolBlacklistRelayUrls = /* @__PURE__ */ new Set();\n  debug;\n  temporaryRelayTimers = /* @__PURE__ */ new Map();\n  flappingRelays = /* @__PURE__ */ new Set();\n  // A map to store timeouts for each flapping relay.\n  backoffTimes = /* @__PURE__ */ new Map();\n  ndk;\n  get blacklistRelayUrls() {\n    const val = new Set(this.ndk.blacklistRelayUrls);\n    this.poolBlacklistRelayUrls.forEach((url) => val.add(url));\n    return val;\n  }\n  /**\n   * @param relayUrls - The URLs of the relays to connect to.\n   * @param blacklistedRelayUrls - URLs to blacklist for this pool IN ADDITION to those blacklisted at the ndk-level\n   * @param ndk - The NDK instance.\n   * @param opts - Options for the pool.\n   */\n  constructor(relayUrls, blacklistedRelayUrls, ndk, {\n    debug: debug9,\n    name\n  } = {}) {\n    super();\n    this.debug = debug9 ?? ndk.debug.extend(\"pool\");\n    if (name) this._name = name;\n    this.ndk = ndk;\n    this.relayUrls = relayUrls;\n    this.poolBlacklistRelayUrls = new Set(blacklistedRelayUrls);\n    this.ndk.pools.push(this);\n  }\n  get relays() {\n    return this._relays;\n  }\n  set relayUrls(urls) {\n    this._relays.clear();\n    for (const relayUrl of urls) {\n      const relay = new NDKRelay(relayUrl, void 0, this.ndk);\n      relay.connectivity.netDebug = this.ndk.netDebug;\n      this.addRelay(relay);\n    }\n  }\n  _name = \"unnamed\";\n  get name() {\n    return this._name;\n  }\n  set name(name) {\n    this._name = name;\n    this.debug = this.debug.extend(name);\n  }\n  /**\n   * Adds a relay to the pool, and sets a timer to remove it if it is not used within the specified time.\n   * @param relay - The relay to add to the pool.\n   * @param removeIfUnusedAfter - The time in milliseconds to wait before removing the relay from the pool after it is no longer used.\n   */\n  useTemporaryRelay(relay, removeIfUnusedAfter = 3e4, filters) {\n    const relayAlreadyInPool = this.relays.has(relay.url);\n    if (!relayAlreadyInPool) {\n      this.addRelay(relay);\n      this.debug(\"Adding temporary relay %s for filters %o\", relay.url, filters);\n    }\n    const existingTimer = this.temporaryRelayTimers.get(relay.url);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n    }\n    if (!relayAlreadyInPool || existingTimer) {\n      const timer = setTimeout(() => {\n        if (this.ndk.explicitRelayUrls?.includes(relay.url)) return;\n        this.removeRelay(relay.url);\n      }, removeIfUnusedAfter);\n      this.temporaryRelayTimers.set(relay.url, timer);\n    }\n  }\n  /**\n   * Adds a relay to the pool.\n   *\n   * @param relay - The relay to add to the pool.\n   * @param connect - Whether or not to connect to the relay.\n   */\n  addRelay(relay, connect = true) {\n    const isAlreadyInPool = this.relays.has(relay.url);\n    const isBlacklisted = this.blacklistRelayUrls?.has(relay.url);\n    const isCustomRelayUrl = relay.url.includes(\"/npub1\");\n    let reconnect = true;\n    const relayUrl = relay.url;\n    if (isAlreadyInPool) return;\n    if (isBlacklisted) {\n      this.debug(`Refusing to add relay ${relayUrl}: blacklisted`);\n      return;\n    }\n    if (isCustomRelayUrl) {\n      this.debug(`Refusing to add relay ${relayUrl}: is a filter relay`);\n      return;\n    }\n    if (this.ndk.cacheAdapter?.getRelayStatus) {\n      const info = this.ndk.cacheAdapter.getRelayStatus(relayUrl);\n      if (info?.dontConnectBefore) {\n        if (info.dontConnectBefore > Date.now()) {\n          const delay = info.dontConnectBefore - Date.now();\n          this.debug(`Refusing to add relay ${relayUrl}: delayed connect for ${delay}ms`);\n          setTimeout(() => {\n            this.addRelay(relay, connect);\n          }, delay);\n          return;\n        }\n        reconnect = false;\n      }\n    }\n    const noticeHandler = (notice) => this.emit(\"notice\", relay, notice);\n    const connectHandler = () => this.handleRelayConnect(relayUrl);\n    const readyHandler = () => this.handleRelayReady(relay);\n    const disconnectHandler = () => this.emit(\"relay:disconnect\", relay);\n    const flappingHandler = () => this.handleFlapping(relay);\n    const authHandler = (challenge) => this.emit(\"relay:auth\", relay, challenge);\n    const authedHandler = () => this.emit(\"relay:authed\", relay);\n    relay.off(\"notice\", noticeHandler);\n    relay.off(\"connect\", connectHandler);\n    relay.off(\"ready\", readyHandler);\n    relay.off(\"disconnect\", disconnectHandler);\n    relay.off(\"flapping\", flappingHandler);\n    relay.off(\"auth\", authHandler);\n    relay.off(\"authed\", authedHandler);\n    relay.on(\"notice\", noticeHandler);\n    relay.on(\"connect\", connectHandler);\n    relay.on(\"ready\", readyHandler);\n    relay.on(\"disconnect\", disconnectHandler);\n    relay.on(\"flapping\", flappingHandler);\n    relay.on(\"auth\", authHandler);\n    relay.on(\"authed\", authedHandler);\n    relay.on(\"delayed-connect\", (delay) => {\n      if (this.ndk.cacheAdapter?.updateRelayStatus) {\n        this.ndk.cacheAdapter.updateRelayStatus(relay.url, {\n          dontConnectBefore: Date.now() + delay\n        });\n      }\n    });\n    this._relays.set(relayUrl, relay);\n    if (connect) this.autoConnectRelays.add(relayUrl);\n    if (connect && this.status === \"active\") {\n      this.emit(\"relay:connecting\", relay);\n      relay.connect(void 0, reconnect).catch((e) => {\n        this.debug(`Failed to connect to relay ${relayUrl}`, e);\n      });\n    }\n  }\n  /**\n   * Removes a relay from the pool.\n   * @param relayUrl - The URL of the relay to remove.\n   * @returns {boolean} True if the relay was removed, false if it was not found.\n   */\n  removeRelay(relayUrl) {\n    const relay = this.relays.get(relayUrl);\n    if (relay) {\n      relay.disconnect();\n      this.relays.delete(relayUrl);\n      this.autoConnectRelays.delete(relayUrl);\n      this.emit(\"relay:disconnect\", relay);\n      return true;\n    }\n    const existingTimer = this.temporaryRelayTimers.get(relayUrl);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n      this.temporaryRelayTimers.delete(relayUrl);\n    }\n    return false;\n  }\n  /**\n   * Checks whether a relay is already connected in the pool.\n   */\n  isRelayConnected(url) {\n    const normalizedUrl = normalizeRelayUrl(url);\n    const relay = this.relays.get(normalizedUrl);\n    if (!relay) return false;\n    return relay.status === 5 /* CONNECTED */;\n  }\n  /**\n   * Fetches a relay from the pool, or creates a new one if it does not exist.\n   *\n   * New relays will be attempted to be connected.\n   */\n  getRelay(url, connect = true, temporary = false, filters) {\n    let relay = this.relays.get(normalizeRelayUrl(url));\n    if (!relay) {\n      relay = new NDKRelay(url, void 0, this.ndk);\n      relay.connectivity.netDebug = this.ndk.netDebug;\n      if (temporary) {\n        this.useTemporaryRelay(relay, 3e4, filters);\n      } else {\n        this.addRelay(relay, connect);\n      }\n    }\n    return relay;\n  }\n  handleRelayConnect(relayUrl) {\n    const relay = this.relays.get(relayUrl);\n    if (!relay) {\n      console.error(\"NDK BUG: relay not found in pool\", { relayUrl });\n      return;\n    }\n    this.emit(\"relay:connect\", relay);\n    if (this.stats().connected === this.relays.size) {\n      this.emit(\"connect\");\n    }\n  }\n  handleRelayReady(relay) {\n    this.emit(\"relay:ready\", relay);\n  }\n  /**\n   * Attempts to establish a connection to each relay in the pool.\n   *\n   * @async\n   * @param {number} [timeoutMs] - Optional timeout in milliseconds for each connection attempt.\n   * @returns {Promise<void>} A promise that resolves when all connection attempts have completed.\n   * @throws {Error} If any of the connection attempts result in an error or timeout.\n   */\n  async connect(timeoutMs) {\n    this.status = \"active\";\n    this.debug(`Connecting to ${this.relays.size} relays${timeoutMs ? `, timeout ${timeoutMs}ms` : \"\"}...`);\n    const relaysToConnect = Array.from(this.autoConnectRelays.keys()).map((url) => this.relays.get(url)).filter((relay) => !!relay);\n    for (const relay of relaysToConnect) {\n      if (relay.status !== 5 /* CONNECTED */ && relay.status !== 4 /* CONNECTING */) {\n        this.emit(\"relay:connecting\", relay);\n        relay.connect().catch((e) => {\n          this.debug(`Failed to connect to relay ${relay.url}: ${e ?? \"No reason specified\"}`);\n        });\n      }\n    }\n    const allConnected = () => relaysToConnect.every((r) => r.status === 5 /* CONNECTED */);\n    const allConnectedPromise = new Promise((resolve) => {\n      if (allConnected()) {\n        resolve();\n        return;\n      }\n      const listeners = [];\n      for (const relay of relaysToConnect) {\n        const handler = () => {\n          if (allConnected()) {\n            for (let i = 0; i < relaysToConnect.length; i++) {\n              relaysToConnect[i].off(\"connect\", listeners[i]);\n            }\n            resolve();\n          }\n        };\n        listeners.push(handler);\n        relay.on(\"connect\", handler);\n      }\n    });\n    const timeoutPromise = typeof timeoutMs === \"number\" ? new Promise((resolve) => setTimeout(resolve, timeoutMs)) : new Promise(() => {\n    });\n    await Promise.race([allConnectedPromise, timeoutPromise]);\n  }\n  checkOnFlappingRelays() {\n    const flappingRelaysCount = this.flappingRelays.size;\n    const totalRelays = this.relays.size;\n    if (flappingRelaysCount / totalRelays >= 0.8) {\n      for (const relayUrl of this.flappingRelays) {\n        this.backoffTimes.set(relayUrl, 0);\n      }\n    }\n  }\n  handleFlapping(relay) {\n    this.debug(`Relay ${relay.url} is flapping`);\n    let currentBackoff = this.backoffTimes.get(relay.url) || 5e3;\n    currentBackoff = currentBackoff * 2;\n    this.backoffTimes.set(relay.url, currentBackoff);\n    this.debug(`Backoff time for ${relay.url} is ${currentBackoff}ms`);\n    setTimeout(() => {\n      this.debug(`Attempting to reconnect to ${relay.url}`);\n      this.emit(\"relay:connecting\", relay);\n      relay.connect();\n      this.checkOnFlappingRelays();\n    }, currentBackoff);\n    relay.disconnect();\n    this.emit(\"flapping\", relay);\n  }\n  size() {\n    return this.relays.size;\n  }\n  /**\n   * Returns the status of each relay in the pool.\n   * @returns {NDKPoolStats} An object containing the number of relays in each status.\n   */\n  stats() {\n    const stats = {\n      total: 0,\n      connected: 0,\n      disconnected: 0,\n      connecting: 0\n    };\n    for (const relay of this.relays.values()) {\n      stats.total++;\n      if (relay.status === 5 /* CONNECTED */) {\n        stats.connected++;\n      } else if (relay.status === 1 /* DISCONNECTED */) {\n        stats.disconnected++;\n      } else if (relay.status === 4 /* CONNECTING */) {\n        stats.connecting++;\n      }\n    }\n    return stats;\n  }\n  connectedRelays() {\n    return Array.from(this.relays.values()).filter((relay) => relay.status >= 5 /* CONNECTED */);\n  }\n  permanentAndConnectedRelays() {\n    return Array.from(this.relays.values()).filter(\n      (relay) => relay.status >= 5 /* CONNECTED */ && !this.temporaryRelayTimers.has(relay.url)\n    );\n  }\n  /**\n   * Get a list of all relay urls in the pool.\n   */\n  urls() {\n    return Array.from(this.relays.keys());\n  }\n};\n\n// src/user/index.ts\n\n\n// src/events/kinds/nutzap/mint-list.ts\nvar NDKCashuMintList = class _NDKCashuMintList extends NDKEvent {\n  static kind = 10019 /* CashuMintList */;\n  static kinds = [10019 /* CashuMintList */];\n  _p2pk;\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 10019 /* CashuMintList */;\n  }\n  static from(event) {\n    return new _NDKCashuMintList(event.ndk, event);\n  }\n  set relays(urls) {\n    this.tags = this.tags.filter((t) => t[0] !== \"relay\");\n    for (const url of urls) {\n      this.tags.push([\"relay\", url]);\n    }\n  }\n  get relays() {\n    const r = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"relay\") {\n        r.push(tag[1]);\n      }\n    }\n    return r;\n  }\n  set mints(urls) {\n    this.tags = this.tags.filter((t) => t[0] !== \"mint\");\n    for (const url of urls) {\n      this.tags.push([\"mint\", url]);\n    }\n  }\n  get mints() {\n    const r = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"mint\") {\n        r.push(tag[1]);\n      }\n    }\n    return Array.from(new Set(r));\n  }\n  get p2pk() {\n    if (this._p2pk) {\n      return this._p2pk;\n    }\n    this._p2pk = this.tagValue(\"pubkey\") ?? this.pubkey;\n    return this._p2pk;\n  }\n  set p2pk(pubkey) {\n    this._p2pk = pubkey;\n    this.removeTag(\"pubkey\");\n    if (pubkey) {\n      this.tags.push([\"pubkey\", pubkey]);\n    }\n  }\n  get relaySet() {\n    return NDKRelaySet.fromRelayUrls(this.relays, this.ndk);\n  }\n};\n\n// src/subscription/index.ts\n\n\n// src/events/kinds/article.ts\nvar NDKArticle = class _NDKArticle extends NDKEvent {\n  static kind = 30023 /* Article */;\n  static kinds = [30023 /* Article */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30023 /* Article */;\n  }\n  /**\n   * Creates a NDKArticle from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKArticle from.\n   * @returns NDKArticle\n   */\n  static from(event) {\n    return new _NDKArticle(event.ndk, event);\n  }\n  /**\n   * Getter for the article title.\n   *\n   * @returns {string | undefined} - The article title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the article title.\n   *\n   * @param {string | undefined} title - The title to set for the article.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the article image.\n   *\n   * @returns {string | undefined} - The article image if available, otherwise undefined.\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Setter for the article image.\n   *\n   * @param {string | undefined} image - The image to set for the article.\n   */\n  set image(image) {\n    this.removeTag(\"image\");\n    if (image) this.tags.push([\"image\", image]);\n  }\n  get summary() {\n    return this.tagValue(\"summary\");\n  }\n  set summary(summary) {\n    this.removeTag(\"summary\");\n    if (summary) this.tags.push([\"summary\", summary]);\n  }\n  /**\n   * Getter for the article's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      let val = Number.parseInt(tag);\n      if (val > 1e12) {\n        val = Math.floor(val / 1e3);\n      }\n      return val;\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the article's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the article's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Generates content tags for the article.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n  /**\n   * Getter for the article's URL.\n   *\n   * @returns {string | undefined} - The article's URL if available, otherwise undefined.\n   */\n  get url() {\n    return this.tagValue(\"url\");\n  }\n  /**\n   * Setter for the article's URL.\n   *\n   * @param {string | undefined} url - The URL to set for the article.\n   */\n  set url(url) {\n    if (url) {\n      this.tags.push([\"url\", url]);\n    } else {\n      this.removeTag(\"url\");\n    }\n  }\n};\n\n// src/events/kinds/cashu/token.ts\nfunction proofsTotalBalance(proofs) {\n  return proofs.reduce((acc, proof) => {\n    if (proof.amount < 0) {\n      throw new Error(\"proof amount is negative\");\n    }\n    return acc + proof.amount;\n  }, 0);\n}\nvar NDKCashuToken = class _NDKCashuToken extends NDKEvent {\n  _proofs = [];\n  _mint;\n  static kind = 7375 /* CashuToken */;\n  static kinds = [7375 /* CashuToken */];\n  /**\n   * Tokens that this token superseeds\n   */\n  _deletes = [];\n  original;\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7375 /* CashuToken */;\n  }\n  static async from(event) {\n    const token = new _NDKCashuToken(event.ndk, event);\n    token.original = event;\n    try {\n      await token.decrypt();\n    } catch {\n      token.content = token.original.content;\n    }\n    try {\n      const content = JSON.parse(token.content);\n      token.proofs = content.proofs;\n      token.mint = content.mint ?? token.tagValue(\"mint\");\n      token.deletedTokens = content.del ?? [];\n      if (!Array.isArray(token.proofs)) return;\n    } catch (_e) {\n      return;\n    }\n    return token;\n  }\n  get proofs() {\n    return this._proofs;\n  }\n  set proofs(proofs) {\n    const cs = /* @__PURE__ */ new Set();\n    this._proofs = proofs.filter((proof) => {\n      if (cs.has(proof.C)) {\n        console.warn(\"Passed in proofs had duplicates, ignoring\", proof.C);\n        return false;\n      }\n      if (proof.amount < 0) {\n        console.warn(\"Invalid proof with negative amount\", proof);\n        return false;\n      }\n      cs.add(proof.C);\n      return true;\n    }).map(this.cleanProof);\n  }\n  /**\n   * Returns a minimal proof object with only essential properties\n   */\n  cleanProof(proof) {\n    return {\n      id: proof.id,\n      amount: proof.amount,\n      C: proof.C,\n      secret: proof.secret\n    };\n  }\n  async toNostrEvent(pubkey) {\n    if (!this.ndk) throw new Error(\"no ndk\");\n    if (!this.ndk.signer) throw new Error(\"no signer\");\n    const payload = {\n      proofs: this.proofs.map(this.cleanProof),\n      mint: this.mint,\n      del: this.deletedTokens ?? []\n    };\n    this.content = JSON.stringify(payload);\n    const user = await this.ndk.signer.user();\n    await this.encrypt(user, void 0, \"nip44\");\n    return super.toNostrEvent(pubkey);\n  }\n  set mint(mint) {\n    this._mint = mint;\n  }\n  get mint() {\n    return this._mint;\n  }\n  /**\n   * Tokens that were deleted by the creation of this token.\n   */\n  get deletedTokens() {\n    return this._deletes;\n  }\n  /**\n   * Marks tokens that were deleted by the creation of this token.\n   */\n  set deletedTokens(tokenIds) {\n    this._deletes = tokenIds;\n  }\n  get amount() {\n    return proofsTotalBalance(this.proofs);\n  }\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    if (this.original) {\n      return this.original.publish(relaySet, timeoutMs, requiredRelayCount);\n    }\n    return super.publish(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/events/kinds/highlight.ts\n\nvar NDKHighlight = class _NDKHighlight extends NDKEvent {\n  _article;\n  static kind = 9802 /* Highlight */;\n  static kinds = [9802 /* Highlight */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 9802 /* Highlight */;\n  }\n  static from(event) {\n    return new _NDKHighlight(event.ndk, event);\n  }\n  get url() {\n    return this.tagValue(\"r\");\n  }\n  /**\n   * Context tag.\n   */\n  set context(context) {\n    if (context === void 0) {\n      this.tags = this.tags.filter(([tag, _value]) => tag !== \"context\");\n    } else {\n      this.tags = this.tags.filter(([tag, _value]) => tag !== \"context\");\n      this.tags.push([\"context\", context]);\n    }\n  }\n  get context() {\n    return this.tags.find(([tag, _value]) => tag === \"context\")?.[1] ?? void 0;\n  }\n  /**\n   * Will return the article URL or NDKEvent if they have already been\n   * set (it won't attempt to load remote events)\n   */\n  get article() {\n    return this._article;\n  }\n  /**\n   * Article the highlight is coming from.\n   *\n   * @param article Article URL or NDKEvent.\n   */\n  set article(article) {\n    this._article = article;\n    if (typeof article === \"string\") {\n      this.tags.push([\"r\", article]);\n    } else {\n      this.tag(article);\n    }\n  }\n  getArticleTag() {\n    return this.getMatchingTags(\"a\")[0] || this.getMatchingTags(\"e\")[0] || this.getMatchingTags(\"r\")[0];\n  }\n  async getArticle() {\n    if (this._article !== void 0) return this._article;\n    let taggedBech32;\n    const articleTag = this.getArticleTag();\n    if (!articleTag) return void 0;\n    switch (articleTag[0]) {\n      case \"a\": {\n        const [kind, pubkey, identifier] = articleTag[1].split(\":\");\n        taggedBech32 = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.naddrEncode({\n          kind: Number.parseInt(kind),\n          pubkey,\n          identifier\n        });\n        break;\n      }\n      case \"e\":\n        taggedBech32 = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.noteEncode(articleTag[1]);\n        break;\n      case \"r\":\n        this._article = articleTag[1];\n        break;\n    }\n    if (taggedBech32) {\n      let a = await this.ndk?.fetchEvent(taggedBech32);\n      if (a) {\n        if (a.kind === 30023 /* Article */) {\n          a = NDKArticle.from(a);\n        }\n        this._article = a;\n      }\n    }\n    return this._article;\n  }\n};\n\n// src/utils/imeta.ts\nfunction mapImetaTag(tag) {\n  const data = {};\n  if (tag.length === 2) {\n    const parts = tag[1].split(\" \");\n    for (let i = 0; i < parts.length; i += 2) {\n      const key = parts[i];\n      const value = parts[i + 1];\n      if (key === \"fallback\") {\n        if (!data.fallback) data.fallback = [];\n        data.fallback.push(value);\n      } else {\n        data[key] = value;\n      }\n    }\n    return data;\n  }\n  const tags = tag.slice(1);\n  for (const val of tags) {\n    const parts = val.split(\" \");\n    const key = parts[0];\n    const value = parts.slice(1).join(\" \");\n    if (key === \"fallback\") {\n      if (!data.fallback) data.fallback = [];\n      data.fallback.push(value);\n    } else {\n      data[key] = value;\n    }\n  }\n  return data;\n}\nfunction imetaTagToTag(imeta) {\n  const tag = [\"imeta\"];\n  for (const [key, value] of Object.entries(imeta)) {\n    if (Array.isArray(value)) {\n      for (const v of value) {\n        tag.push(`${key} ${v}`);\n      }\n    } else if (value) {\n      tag.push(`${key} ${value}`);\n    }\n  }\n  return tag;\n}\n\n// src/events/kinds/image.ts\nvar NDKImage = class _NDKImage extends NDKEvent {\n  static kind = 20 /* Image */;\n  static kinds = [20 /* Image */];\n  _imetas;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 20 /* Image */;\n  }\n  /**\n   * Creates a NDKImage from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKImage from.\n   * @returns NDKImage\n   */\n  static from(event) {\n    return new _NDKImage(event.ndk, event.rawEvent());\n  }\n  get isValid() {\n    return this.imetas.length > 0;\n  }\n  get imetas() {\n    if (this._imetas) return this._imetas;\n    this._imetas = this.tags.filter((tag) => tag[0] === \"imeta\").map(mapImetaTag).filter((imeta) => !!imeta.url);\n    return this._imetas;\n  }\n  set imetas(tags) {\n    this._imetas = tags;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"imeta\");\n    this.tags.push(...tags.map(imetaTagToTag));\n  }\n};\n\n// src/events/kinds/lists/index.ts\nvar NDKList = class _NDKList extends NDKEvent {\n  _encryptedTags;\n  static kinds = [\n    10063 /* BlossomList */,\n    30001 /* CategorizedBookmarkList */,\n    10004 /* CommunityList */,\n    10050 /* DirectMessageReceiveRelayList */,\n    10030 /* EmojiList */,\n    10015 /* InterestList */,\n    10001 /* PinList */,\n    10002 /* RelayList */,\n    10007 /* SearchRelayList */,\n    10006 /* BlockRelayList */,\n    10003 /* BookmarkList */\n  ];\n  /**\n   * Stores the number of bytes the content was before decryption\n   * to expire the cache when the content changes.\n   */\n  encryptedTagsLength;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30001 /* CategorizedBookmarkList */;\n  }\n  /**\n   * Wrap a NDKEvent into a NDKList\n   */\n  static from(ndkEvent) {\n    return new _NDKList(ndkEvent.ndk, ndkEvent);\n  }\n  /**\n   * Returns the title of the list. Falls back on fetching the name tag value.\n   */\n  get title() {\n    const titleTag = this.tagValue(\"title\") || this.tagValue(\"name\");\n    if (titleTag) return titleTag;\n    if (this.kind === 3 /* Contacts */) {\n      return \"Contacts\";\n    }\n    if (this.kind === 1e4 /* MuteList */) {\n      return \"Mute\";\n    }\n    if (this.kind === 10001 /* PinList */) {\n      return \"Pinned Notes\";\n    }\n    if (this.kind === 10002 /* RelayList */) {\n      return \"Relay Metadata\";\n    }\n    if (this.kind === 10003 /* BookmarkList */) {\n      return \"Bookmarks\";\n    }\n    if (this.kind === 10004 /* CommunityList */) {\n      return \"Communities\";\n    }\n    if (this.kind === 10005 /* PublicChatList */) {\n      return \"Public Chats\";\n    }\n    if (this.kind === 10006 /* BlockRelayList */) {\n      return \"Blocked Relays\";\n    }\n    if (this.kind === 10007 /* SearchRelayList */) {\n      return \"Search Relays\";\n    }\n    if (this.kind === 10050 /* DirectMessageReceiveRelayList */) {\n      return \"Direct Message Receive Relays\";\n    }\n    if (this.kind === 10015 /* InterestList */) {\n      return \"Interests\";\n    }\n    if (this.kind === 10030 /* EmojiList */) {\n      return \"Emojis\";\n    }\n    return this.tagValue(\"d\");\n  }\n  /**\n   * Sets the title of the list.\n   */\n  set title(title) {\n    this.removeTag([\"title\", \"name\"]);\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Returns the name of the list.\n   * @deprecated Please use \"title\" instead.\n   */\n  get name() {\n    return this.title;\n  }\n  /**\n   * Sets the name of the list.\n   * @deprecated Please use \"title\" instead. This method will use the `title` tag instead.\n   */\n  set name(name) {\n    this.title = name;\n  }\n  /**\n   * Returns the description of the list.\n   */\n  get description() {\n    return this.tagValue(\"description\");\n  }\n  /**\n   * Sets the description of the list.\n   */\n  set description(name) {\n    this.removeTag(\"description\");\n    if (name) this.tags.push([\"description\", name]);\n  }\n  /**\n   * Returns the image of the list.\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Sets the image of the list.\n   */\n  set image(name) {\n    this.removeTag(\"image\");\n    if (name) this.tags.push([\"image\", name]);\n  }\n  isEncryptedTagsCacheValid() {\n    return !!(this._encryptedTags && this.encryptedTagsLength === this.content.length);\n  }\n  /**\n   * Returns the decrypted content of the list.\n   */\n  async encryptedTags(useCache = true) {\n    if (useCache && this.isEncryptedTagsCacheValid()) return this._encryptedTags;\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    const user = await this.ndk.signer.user();\n    try {\n      if (this.content.length > 0) {\n        try {\n          const decryptedContent = await this.ndk.signer.decrypt(user, this.content);\n          const a = JSON.parse(decryptedContent);\n          if (a?.[0]) {\n            this.encryptedTagsLength = this.content.length;\n            return this._encryptedTags = a;\n          }\n          this.encryptedTagsLength = this.content.length;\n          return this._encryptedTags = [];\n        } catch (_e) {\n        }\n      }\n    } catch (_e) {\n    }\n    return [];\n  }\n  /**\n   * This method can be overriden to validate that a tag is valid for this list.\n   *\n   * (i.e. the NDKPersonList can validate that items are NDKUser instances)\n   */\n  validateTag(_tagValue) {\n    return true;\n  }\n  getItems(type) {\n    return this.tags.filter((tag) => tag[0] === type);\n  }\n  /**\n   * Returns the unecrypted items in this list.\n   */\n  get items() {\n    return this.tags.filter((t) => {\n      return ![\n        \"d\",\n        \"L\",\n        \"l\",\n        \"title\",\n        \"name\",\n        \"description\",\n        \"published_at\",\n        \"summary\",\n        \"image\",\n        \"thumb\",\n        \"alt\",\n        \"expiration\",\n        \"subject\",\n        \"client\"\n      ].includes(t[0]);\n    });\n  }\n  /**\n   * Adds a new item to the list.\n   * @param relay Relay to add\n   * @param mark Optional mark to add to the item\n   * @param encrypted Whether to encrypt the item\n   * @param position Where to add the item in the list (top or bottom)\n   */\n  async addItem(item, mark = void 0, encrypted = false, position = \"bottom\") {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    let tags;\n    if (item instanceof NDKEvent) {\n      tags = [item.tagReference(mark)];\n    } else if (item instanceof NDKUser) {\n      tags = item.referenceTags();\n    } else if (item instanceof NDKRelay) {\n      tags = item.referenceTags();\n    } else if (Array.isArray(item)) {\n      tags = [item];\n    } else {\n      throw new Error(\"Invalid object type\");\n    }\n    if (mark) tags[0].push(mark);\n    if (encrypted) {\n      const user = await this.ndk.signer.user();\n      const currentList = await this.encryptedTags();\n      if (position === \"top\") currentList.unshift(...tags);\n      else currentList.push(...tags);\n      this._encryptedTags = currentList;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(currentList);\n      await this.encrypt(user);\n    } else {\n      if (position === \"top\") this.tags.unshift(...tags);\n      else this.tags.push(...tags);\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n  }\n  /**\n   * Removes an item from the list from both the encrypted and unencrypted lists.\n   * @param value value of item to remove from the list\n   * @param publish whether to publish the change\n   * @returns\n   */\n  async removeItemByValue(value, publish = true) {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    const index = this.tags.findIndex((tag) => tag[1] === value);\n    if (index >= 0) {\n      this.tags.splice(index, 1);\n    }\n    const user = await this.ndk.signer.user();\n    const encryptedTags = await this.encryptedTags();\n    const encryptedIndex = encryptedTags.findIndex((tag) => tag[1] === value);\n    if (encryptedIndex >= 0) {\n      encryptedTags.splice(encryptedIndex, 1);\n      this._encryptedTags = encryptedTags;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(encryptedTags);\n      await this.encrypt(user);\n    }\n    if (publish) {\n      return this.publishReplaceable();\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n  }\n  /**\n   * Removes an item from the list.\n   *\n   * @param index The index of the item to remove.\n   * @param encrypted Whether to remove from the encrypted list or not.\n   */\n  async removeItem(index, encrypted) {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    if (encrypted) {\n      const user = await this.ndk.signer.user();\n      const currentList = await this.encryptedTags();\n      currentList.splice(index, 1);\n      this._encryptedTags = currentList;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(currentList);\n      await this.encrypt(user);\n    } else {\n      this.tags.splice(index, 1);\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n    return this;\n  }\n  has(item) {\n    return this.items.some((tag) => tag[1] === item);\n  }\n  /**\n   * Creates a filter that will result in fetching\n   * the items of this list\n   * @example\n   * const list = new NDKList(...);\n   * const filters = list.filterForItems();\n   * const events = await ndk.fetchEvents(filters);\n   */\n  filterForItems() {\n    const ids = /* @__PURE__ */ new Set();\n    const nip33Queries = /* @__PURE__ */ new Map();\n    const filters = [];\n    for (const tag of this.items) {\n      if (tag[0] === \"e\" && tag[1]) {\n        ids.add(tag[1]);\n      } else if (tag[0] === \"a\" && tag[1]) {\n        const [kind, pubkey, dTag] = tag[1].split(\":\");\n        if (!kind || !pubkey) continue;\n        const key = `${kind}:${pubkey}`;\n        const item = nip33Queries.get(key) || [];\n        item.push(dTag || \"\");\n        nip33Queries.set(key, item);\n      }\n    }\n    if (ids.size > 0) {\n      filters.push({ ids: Array.from(ids) });\n    }\n    if (nip33Queries.size > 0) {\n      for (const [key, values] of nip33Queries.entries()) {\n        const [kind, pubkey] = key.split(\":\");\n        filters.push({\n          kinds: [Number.parseInt(kind)],\n          authors: [pubkey],\n          \"#d\": values\n        });\n      }\n    }\n    return filters;\n  }\n};\nvar lists_default = NDKList;\n\n// src/events/kinds/nutzap/index.ts\n\nvar NDKNutzap = class _NDKNutzap extends NDKEvent {\n  debug;\n  _proofs = [];\n  static kind = 9321 /* Nutzap */;\n  static kinds = [_NDKNutzap.kind];\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 9321 /* Nutzap */;\n    this.debug = ndk?.debug.extend(\"nutzap\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:nutzap\");\n    if (!this.alt) this.alt = \"This is a nutzap\";\n    try {\n      const proofTags = this.getMatchingTags(\"proof\");\n      if (proofTags.length) {\n        this._proofs = proofTags.map((tag) => JSON.parse(tag[1]));\n      } else {\n        this._proofs = JSON.parse(this.content);\n      }\n    } catch {\n      return;\n    }\n  }\n  static from(event) {\n    const e = new _NDKNutzap(event.ndk, event);\n    if (!e._proofs || !e._proofs.length) return;\n    return e;\n  }\n  set comment(comment) {\n    this.content = comment ?? \"\";\n  }\n  get comment() {\n    const c = this.tagValue(\"comment\");\n    if (c) return c;\n    return this.content;\n  }\n  set proofs(proofs) {\n    this._proofs = proofs;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"proof\");\n    for (const proof of proofs) {\n      this.tags.push([\"proof\", JSON.stringify(proof)]);\n    }\n  }\n  get proofs() {\n    return this._proofs;\n  }\n  get rawP2pk() {\n    const firstProof = this.proofs[0];\n    try {\n      const secret = JSON.parse(firstProof.secret);\n      let payload;\n      if (typeof secret === \"string\") {\n        payload = JSON.parse(secret);\n        this.debug(\"stringified payload\", firstProof.secret);\n      } else if (typeof secret === \"object\") {\n        payload = secret;\n      }\n      if (Array.isArray(payload) && payload[0] === \"P2PK\" && payload.length > 1 && typeof payload[1] === \"object\" && payload[1] !== null) {\n        return payload[1].data;\n      }\n      if (typeof payload === \"object\" && payload !== null && typeof payload[1]?.data === \"string\") {\n        return payload[1].data;\n      }\n    } catch (e) {\n      this.debug(\"error parsing p2pk pubkey\", e, this.proofs[0]);\n    }\n    return void 0;\n  }\n  /**\n   * Gets the p2pk pubkey that is embedded in the first proof.\n   *\n   * Note that this returns a nostr pubkey, not a cashu pubkey (no \"02\" prefix)\n   */\n  get p2pk() {\n    const rawP2pk = this.rawP2pk;\n    if (!rawP2pk) return;\n    return rawP2pk.startsWith(\"02\") ? rawP2pk.slice(2) : rawP2pk;\n  }\n  /**\n   * Get the mint where this nutzap proofs exist\n   */\n  get mint() {\n    return this.tagValue(\"u\");\n  }\n  set mint(value) {\n    this.replaceTag([\"u\", value]);\n  }\n  get unit() {\n    let _unit = this.tagValue(\"unit\") ?? \"sat\";\n    if (_unit?.startsWith(\"msat\")) _unit = \"sat\";\n    return _unit;\n  }\n  set unit(value) {\n    this.removeTag(\"unit\");\n    if (value?.startsWith(\"msat\")) throw new Error(\"msat is not allowed, use sat denomination instead\");\n    if (value) this.tag([\"unit\", value]);\n  }\n  get amount() {\n    const amount = this.proofs.reduce((total, proof) => total + proof.amount, 0);\n    return amount;\n  }\n  sender = this.author;\n  /**\n   * Set the target of the nutzap\n   * @param target The target of the nutzap (a user or an event)\n   */\n  set target(target) {\n    this.tags = this.tags.filter((t) => t[0] !== \"p\");\n    if (target instanceof NDKEvent) {\n      this.tags.push(target.tagReference());\n    }\n  }\n  set recipientPubkey(pubkey) {\n    this.removeTag(\"p\");\n    this.tag([\"p\", pubkey]);\n  }\n  get recipientPubkey() {\n    return this.tagValue(\"p\");\n  }\n  get recipient() {\n    const pubkey = this.recipientPubkey;\n    if (this.ndk) return this.ndk.getUser({ pubkey });\n    return new NDKUser({ pubkey });\n  }\n  async toNostrEvent() {\n    if (this.unit === \"msat\") {\n      this.unit = \"sat\";\n    }\n    this.removeTag(\"amount\");\n    this.tags.push([\"amount\", this.amount.toString()]);\n    const event = await super.toNostrEvent();\n    event.content = this.comment;\n    return event;\n  }\n  /**\n   * Validates that the nutzap conforms to NIP-61\n   */\n  get isValid() {\n    let eTagCount = 0;\n    let pTagCount = 0;\n    let mintTagCount = 0;\n    for (const tag of this.tags) {\n      if (tag[0] === \"e\") eTagCount++;\n      if (tag[0] === \"p\") pTagCount++;\n      if (tag[0] === \"u\") mintTagCount++;\n    }\n    return (\n      // exactly one recipient and mint\n      pTagCount === 1 && mintTagCount === 1 && // must have at most one e tag\n      eTagCount <= 1 && // must have at least one proof\n      this.proofs.length > 0\n    );\n  }\n};\nfunction proofP2pk(proof) {\n  try {\n    const secret = JSON.parse(proof.secret);\n    let payload = {};\n    if (typeof secret === \"string\") {\n      payload = JSON.parse(secret);\n    } else if (typeof secret === \"object\") {\n      payload = secret;\n    }\n    const isP2PKLocked = payload[0] === \"P2PK\" && payload[1]?.data;\n    if (isP2PKLocked) {\n      return payload[1].data;\n    }\n  } catch (e) {\n    console.error(\"error parsing p2pk pubkey\", e, proof);\n  }\n}\nfunction proofP2pkNostr(proof) {\n  const p2pk = proofP2pk(proof);\n  if (!p2pk) return;\n  if (p2pk.startsWith(\"02\") && p2pk.length === 66) return p2pk.slice(2);\n  return p2pk;\n}\nfunction cashuPubkeyToNostrPubkey(cashuPubkey) {\n  if (cashuPubkey.startsWith(\"02\") && cashuPubkey.length === 66) return cashuPubkey.slice(2);\n  return void 0;\n}\n\n// src/events/kinds/simple-group/member-list.ts\nvar NDKSimpleGroupMemberList = class _NDKSimpleGroupMemberList extends NDKEvent {\n  relaySet;\n  memberSet = /* @__PURE__ */ new Set();\n  static kind = 39002 /* GroupMembers */;\n  static kinds = [39002 /* GroupMembers */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 39002 /* GroupMembers */;\n    this.memberSet = new Set(this.members);\n  }\n  static from(event) {\n    return new _NDKSimpleGroupMemberList(event.ndk, event);\n  }\n  get members() {\n    return this.getMatchingTags(\"p\").map((tag) => tag[1]);\n  }\n  hasMember(member) {\n    return this.memberSet.has(member);\n  }\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    relaySet ??= this.relaySet;\n    return super.publishReplaceable(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/events/kinds/simple-group/metadata.ts\nvar NDKSimpleGroupMetadata = class _NDKSimpleGroupMetadata extends NDKEvent {\n  static kind = 39e3 /* GroupMetadata */;\n  static kinds = [39e3 /* GroupMetadata */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 39e3 /* GroupMetadata */;\n  }\n  static from(event) {\n    return new _NDKSimpleGroupMetadata(event.ndk, event);\n  }\n  get name() {\n    return this.tagValue(\"name\");\n  }\n  get picture() {\n    return this.tagValue(\"picture\");\n  }\n  get about() {\n    return this.tagValue(\"about\");\n  }\n  get scope() {\n    if (this.getMatchingTags(\"public\").length > 0) return \"public\";\n    if (this.getMatchingTags(\"public\").length > 0) return \"private\";\n    return void 0;\n  }\n  set scope(scope) {\n    this.removeTag(\"public\");\n    this.removeTag(\"private\");\n    if (scope === \"public\") {\n      this.tags.push([\"public\", \"\"]);\n    } else if (scope === \"private\") {\n      this.tags.push([\"private\", \"\"]);\n    }\n  }\n  get access() {\n    if (this.getMatchingTags(\"open\").length > 0) return \"open\";\n    if (this.getMatchingTags(\"closed\").length > 0) return \"closed\";\n    return void 0;\n  }\n  set access(access) {\n    this.removeTag(\"open\");\n    this.removeTag(\"closed\");\n    if (access === \"open\") {\n      this.tags.push([\"open\", \"\"]);\n    } else if (access === \"closed\") {\n      this.tags.push([\"closed\", \"\"]);\n    }\n  }\n};\n\n// src/events/kinds/story.ts\nvar NDKStoryStickerType = /* @__PURE__ */ ((NDKStoryStickerType2) => {\n  NDKStoryStickerType2[\"Pubkey\"] = \"pubkey\";\n  NDKStoryStickerType2[\"Event\"] = \"event\";\n  NDKStoryStickerType2[\"Prompt\"] = \"prompt\";\n  NDKStoryStickerType2[\"Text\"] = \"text\";\n  NDKStoryStickerType2[\"Countdown\"] = \"countdown\";\n  return NDKStoryStickerType2;\n})(NDKStoryStickerType || {});\nfunction strToPosition(positionStr) {\n  const [x, y] = positionStr.split(\",\").map(Number);\n  return { x, y };\n}\nfunction strToDimension(dimensionStr) {\n  const [width, height] = dimensionStr.split(\"x\").map(Number);\n  return { width, height };\n}\nvar NDKStorySticker = class _NDKStorySticker {\n  static Text = \"text\" /* Text */;\n  static Pubkey = \"pubkey\" /* Pubkey */;\n  static Event = \"event\" /* Event */;\n  static Prompt = \"prompt\" /* Prompt */;\n  static Countdown = \"countdown\" /* Countdown */;\n  type;\n  value;\n  position;\n  dimension;\n  properties;\n  constructor(arg) {\n    if (Array.isArray(arg)) {\n      const tag = arg;\n      if (tag[0] !== \"sticker\" || tag.length < 5) {\n        throw new Error(\"Invalid sticker tag\");\n      }\n      this.type = tag[1];\n      this.value = tag[2];\n      this.position = strToPosition(tag[3]);\n      this.dimension = strToDimension(tag[4]);\n      const props = {};\n      for (let i = 5; i < tag.length; i++) {\n        const [key, ...rest] = tag[i].split(\" \");\n        props[key] = rest.join(\" \");\n      }\n      if (Object.keys(props).length > 0) {\n        this.properties = props;\n      }\n    } else {\n      this.type = arg;\n      this.value = void 0;\n      this.position = { x: 0, y: 0 };\n      this.dimension = { width: 0, height: 0 };\n    }\n  }\n  static fromTag(tag) {\n    try {\n      return new _NDKStorySticker(tag);\n    } catch {\n      return null;\n    }\n  }\n  get style() {\n    return this.properties?.style;\n  }\n  set style(style) {\n    if (style) this.properties = { ...this.properties, style };\n    else delete this.properties?.style;\n  }\n  get rotation() {\n    return this.properties?.rot ? Number.parseFloat(this.properties.rot) : void 0;\n  }\n  set rotation(rotation) {\n    if (rotation !== void 0) {\n      this.properties = { ...this.properties, rot: rotation.toString() };\n    } else {\n      delete this.properties?.rot;\n    }\n  }\n  /**\n   * Checks if the sticker is valid.\n   *\n   * @returns {boolean} - True if the sticker is valid, false otherwise.\n   */\n  get isValid() {\n    return this.hasValidDimensions() && this.hasValidPosition();\n  }\n  hasValidDimensions = () => {\n    return typeof this.dimension.width === \"number\" && typeof this.dimension.height === \"number\" && !Number.isNaN(this.dimension.width) && !Number.isNaN(this.dimension.height);\n  };\n  hasValidPosition = () => {\n    return typeof this.position.x === \"number\" && typeof this.position.y === \"number\" && !Number.isNaN(this.position.x) && !Number.isNaN(this.position.y);\n  };\n  toTag() {\n    if (!this.isValid) {\n      const errors = [\n        !this.hasValidDimensions() ? \"dimensions is invalid\" : void 0,\n        !this.hasValidPosition() ? \"position is invalid\" : void 0\n      ].filter(Boolean);\n      throw new Error(`Invalid sticker: ${errors.join(\", \")}`);\n    }\n    let value;\n    switch (this.type) {\n      case \"event\" /* Event */:\n        value = this.value.tagId();\n        break;\n      case \"pubkey\" /* Pubkey */:\n        value = this.value.pubkey;\n        break;\n      default:\n        value = this.value;\n    }\n    const tag = [\"sticker\", this.type, value, coordinates(this.position), dimension(this.dimension)];\n    if (this.properties) {\n      for (const [key, propValue] of Object.entries(this.properties)) {\n        tag.push(`${key} ${propValue}`);\n      }\n    }\n    return tag;\n  }\n};\nvar NDKStory = class _NDKStory extends NDKEvent {\n  static kind = 23 /* Story */;\n  static kinds = [23 /* Story */];\n  _imeta;\n  _dimensions;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 23 /* Story */;\n    if (rawEvent) {\n      for (const tag of rawEvent.tags) {\n        switch (tag[0]) {\n          case \"imeta\":\n            this._imeta = mapImetaTag(tag);\n            break;\n          case \"dim\":\n            this.dimensions = strToDimension(tag[1]);\n            break;\n        }\n      }\n    }\n  }\n  /**\n   * Creates a NDKStory from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKStory from.\n   * @returns NDKStory\n   */\n  static from(event) {\n    return new _NDKStory(event.ndk, event);\n  }\n  /**\n   * Checks if the story is valid (has exactly one imeta tag).\n   */\n  get isValid() {\n    return !!this.imeta;\n  }\n  /**\n   * Gets the first imeta tag (there should only be one).\n   */\n  get imeta() {\n    return this._imeta;\n  }\n  /**\n   * Sets a single imeta tag, replacing any existing ones.\n   */\n  set imeta(tag) {\n    this._imeta = tag;\n    this.tags = this.tags.filter((t) => t[0] !== \"imeta\");\n    if (tag) {\n      this.tags.push(imetaTagToTag(tag));\n    }\n  }\n  /**\n   * Getter for the story dimensions.\n   *\n   * @returns {NDKStoryDimension | undefined} - The story dimensions if available, otherwise undefined.\n   */\n  get dimensions() {\n    const dimTag = this.tagValue(\"dim\");\n    if (!dimTag) return void 0;\n    return strToDimension(dimTag);\n  }\n  /**\n   * Setter for the story dimensions.\n   *\n   * @param {NDKStoryDimension | undefined} dimensions - The dimensions to set for the story.\n   */\n  set dimensions(dimensions) {\n    this.removeTag(\"dim\");\n    if (dimensions) {\n      this.tags.push([\"dim\", `${dimensions.width}x${dimensions.height}`]);\n    }\n  }\n  /**\n   * Getter for the story duration.\n   *\n   * @returns {number | undefined} - The story duration in seconds if available, otherwise undefined.\n   */\n  get duration() {\n    const durTag = this.tagValue(\"dur\");\n    if (!durTag) return void 0;\n    return Number.parseInt(durTag);\n  }\n  /**\n   * Setter for the story duration.\n   *\n   * @param {number | undefined} duration - The duration in seconds to set for the story.\n   */\n  set duration(duration) {\n    this.removeTag(\"dur\");\n    if (duration !== void 0) {\n      this.tags.push([\"dur\", duration.toString()]);\n    }\n  }\n  /**\n   * Gets all stickers from the story.\n   *\n   * @returns {NDKStorySticker[]} - Array of stickers in the story.\n   */\n  get stickers() {\n    const stickers = [];\n    for (const tag of this.tags) {\n      if (tag[0] !== \"sticker\" || tag.length < 5) continue;\n      const sticker = NDKStorySticker.fromTag(tag);\n      if (sticker) stickers.push(sticker);\n    }\n    return stickers;\n  }\n  /**\n   * Adds a sticker to the story.\n   *\n   * @param {NDKStorySticker|StorySticker} sticker - The sticker to add.\n   */\n  addSticker(sticker) {\n    let stickerToAdd;\n    if (sticker instanceof NDKStorySticker) {\n      stickerToAdd = sticker;\n    } else {\n      const tag = [\n        \"sticker\",\n        sticker.type,\n        typeof sticker.value === \"string\" ? sticker.value : \"\",\n        coordinates(sticker.position),\n        dimension(sticker.dimension)\n      ];\n      if (sticker.properties) {\n        for (const [key, value] of Object.entries(sticker.properties)) {\n          tag.push(`${key} ${value}`);\n        }\n      }\n      stickerToAdd = new NDKStorySticker(tag);\n      stickerToAdd.value = sticker.value;\n    }\n    if (stickerToAdd.type === \"pubkey\" /* Pubkey */) {\n      this.tag(stickerToAdd.value);\n    } else if (stickerToAdd.type === \"event\" /* Event */) {\n      this.tag(stickerToAdd.value);\n    }\n    this.tags.push(stickerToAdd.toTag());\n  }\n  /**\n   * Removes a sticker from the story.\n   *\n   * @param {number} index - The index of the sticker to remove.\n   */\n  removeSticker(index) {\n    const stickers = this.stickers;\n    if (index < 0 || index >= stickers.length) return;\n    let stickerCount = 0;\n    for (let i = 0; i < this.tags.length; i++) {\n      if (this.tags[i][0] === \"sticker\") {\n        if (stickerCount === index) {\n          this.tags.splice(i, 1);\n          break;\n        }\n        stickerCount++;\n      }\n    }\n  }\n};\nvar coordinates = (position) => `${position.x},${position.y}`;\nvar dimension = (dimension2) => `${dimension2.width}x${dimension2.height}`;\n\n// src/events/kinds/subscriptions/amount.ts\nvar possibleIntervalFrequencies = [\n  \"daily\",\n  \"weekly\",\n  \"monthly\",\n  \"quarterly\",\n  \"yearly\"\n];\nfunction calculateTermDurationInSeconds(term) {\n  switch (term) {\n    case \"daily\":\n      return 24 * 60 * 60;\n    case \"weekly\":\n      return 7 * 24 * 60 * 60;\n    case \"monthly\":\n      return 30 * 24 * 60 * 60;\n    case \"quarterly\":\n      return 3 * 30 * 24 * 60 * 60;\n    case \"yearly\":\n      return 365 * 24 * 60 * 60;\n  }\n}\nfunction newAmount(amount, currency, term) {\n  return [\"amount\", amount.toString(), currency, term];\n}\nfunction parseTagToSubscriptionAmount(tag) {\n  const amount = Number.parseInt(tag[1]);\n  if (Number.isNaN(amount) || amount === void 0 || amount === null || amount <= 0) return void 0;\n  const currency = tag[2];\n  if (currency === void 0 || currency === \"\") return void 0;\n  const term = tag[3];\n  if (term === void 0) return void 0;\n  if (!possibleIntervalFrequencies.includes(term)) return void 0;\n  return {\n    amount,\n    currency,\n    term\n  };\n}\n\n// src/events/kinds/subscriptions/tier.ts\nvar NDKSubscriptionTier = class _NDKSubscriptionTier extends NDKArticle {\n  static kind = 37001 /* SubscriptionTier */;\n  static kinds = [37001 /* SubscriptionTier */];\n  constructor(ndk, rawEvent) {\n    const k = rawEvent?.kind ?? 37001 /* SubscriptionTier */;\n    super(ndk, rawEvent);\n    this.kind = k;\n  }\n  /**\n   * Creates a new NDKSubscriptionTier from an event\n   * @param event\n   * @returns NDKSubscriptionTier\n   */\n  static from(event) {\n    return new _NDKSubscriptionTier(event.ndk, event);\n  }\n  /**\n   * Returns perks for this tier\n   */\n  get perks() {\n    return this.getMatchingTags(\"perk\").map((tag) => tag[1]).filter((perk) => perk !== void 0);\n  }\n  /**\n   * Adds a perk to this tier\n   */\n  addPerk(perk) {\n    this.tags.push([\"perk\", perk]);\n  }\n  /**\n   * Returns the amount for this tier\n   */\n  get amounts() {\n    return this.getMatchingTags(\"amount\").map((tag) => parseTagToSubscriptionAmount(tag)).filter((a) => a !== void 0);\n  }\n  /**\n   * Adds an amount to this tier\n   * @param amount Amount in the smallest unit of the currency (e.g. cents, msats)\n   * @param currency Currency code. Use msat for millisatoshis\n   * @param term One of daily, weekly, monthly, quarterly, yearly\n   */\n  addAmount(amount, currency, term) {\n    this.tags.push(newAmount(amount, currency, term));\n  }\n  /**\n   * Sets a relay where content related to this tier can be found\n   * @param relayUrl URL of the relay\n   */\n  set relayUrl(relayUrl) {\n    this.tags.push([\"r\", relayUrl]);\n  }\n  /**\n   * Returns the relay URLs for this tier\n   */\n  get relayUrls() {\n    return this.getMatchingTags(\"r\").map((tag) => tag[1]).filter((relay) => relay !== void 0);\n  }\n  /**\n   * Gets the verifier pubkey for this tier. This is the pubkey that will generate\n   * subscription payment receipts\n   */\n  get verifierPubkey() {\n    return this.tagValue(\"p\");\n  }\n  /**\n   * Sets the verifier pubkey for this tier.\n   */\n  set verifierPubkey(pubkey) {\n    this.removeTag(\"p\");\n    if (pubkey) this.tags.push([\"p\", pubkey]);\n  }\n  /**\n   * Checks if this tier is valid\n   */\n  get isValid() {\n    return this.title !== void 0 && // Must have a title\n    this.amounts.length > 0;\n  }\n};\n\n// src/events/kinds/video.ts\nvar NDKVideo = class _NDKVideo extends NDKEvent {\n  static kind = 21 /* Video */;\n  static kinds = [34235 /* HorizontalVideo */, 34236 /* VerticalVideo */, 22 /* ShortVideo */, 21 /* Video */];\n  _imetas;\n  /**\n   * Creates a NDKArticle from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKArticle from.\n   * @returns NDKArticle\n   */\n  static from(event) {\n    return new _NDKVideo(event.ndk, event.rawEvent());\n  }\n  /**\n   * Getter for the article title.\n   *\n   * @returns {string | undefined} - The article title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the article title.\n   *\n   * @param {string | undefined} title - The title to set for the article.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the article thumbnail.\n   *\n   * @returns {string | undefined} - The article thumbnail if available, otherwise undefined.\n   */\n  get thumbnail() {\n    let thumbnail;\n    if (this.imetas && this.imetas.length > 0) {\n      thumbnail = this.imetas[0].image?.[0];\n    }\n    return thumbnail ?? this.tagValue(\"thumb\");\n  }\n  get imetas() {\n    if (this._imetas) return this._imetas;\n    this._imetas = this.tags.filter((tag) => tag[0] === \"imeta\").map(mapImetaTag);\n    return this._imetas;\n  }\n  set imetas(tags) {\n    this._imetas = tags;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"imeta\");\n    this.tags.push(...tags.map(imetaTagToTag));\n  }\n  get url() {\n    if (this.imetas && this.imetas.length > 0) {\n      return this.imetas[0].url;\n    }\n    return this.tagValue(\"url\");\n  }\n  /**\n   * Getter for the article's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      return Number.parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Generates content tags for the article.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.kind) {\n      if (this.imetas?.[0]?.dim) {\n        const [width, height] = this.imetas[0].dim.split(\"x\");\n        const isPortrait = width && height && Number.parseInt(width) < Number.parseInt(height);\n        const isShort = this.duration && this.duration < 120;\n        if (isShort && isPortrait) this.kind = 22 /* ShortVideo */;\n        else this.kind = 21 /* Video */;\n      }\n    }\n    return super.generateTags();\n  }\n  get duration() {\n    const tag = this.tagValue(\"duration\");\n    if (tag) {\n      return Number.parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the video's duration\n   *\n   * @param {number | undefined} duration - The duration to set for the video (in seconds)\n   */\n  set duration(dur) {\n    this.removeTag(\"duration\");\n    if (dur !== void 0) {\n      this.tags.push([\"duration\", Math.floor(dur).toString()]);\n    }\n  }\n};\n\n// src/events/kinds/wiki.ts\nvar NDKWiki = class _NDKWiki extends NDKArticle {\n  static kind = 30818 /* Wiki */;\n  static kinds = [30818 /* Wiki */];\n  static from(event) {\n    return new _NDKWiki(event.ndk, event.rawEvent());\n  }\n  get isDefered() {\n    return this.hasTag(\"a\", \"defer\");\n  }\n  get deferedId() {\n    return this.tagValue(\"a\", \"defer\");\n  }\n  /**\n   * Defers the author's wiki event to another wiki event.\n   *\n   * Wiki-events can tag other wiki-events with a `defer` marker to indicate that it considers someone else's entry as a \"better\" version of itself. If using a `defer` marker both `a` and `e` tags SHOULD be used.\n   *\n   * @example\n   * myWiki.defer = betterWikiEntryOnTheSameTopic;\n   * myWiki.publishReplaceable()\n   */\n  set defer(deferedTo) {\n    this.removeTag(\"a\", \"defer\");\n    this.tag(deferedTo, \"defer\");\n  }\n};\nvar NDKWikiMergeRequest = class _NDKWikiMergeRequest extends NDKEvent {\n  static kind = 818 /* WikiMergeRequest */;\n  static kinds = [818 /* WikiMergeRequest */];\n  static from(event) {\n    return new _NDKWikiMergeRequest(event.ndk, event.rawEvent());\n  }\n  /**\n   * The target ID (<kind:pubkey:d-tag>) of the wiki event to merge into.\n   */\n  get targetId() {\n    return this.tagValue(\"a\");\n  }\n  /**\n   * Sets the target ID (<kind:pubkey:d-tag>) of the wiki event to merge into.\n   */\n  set target(targetEvent) {\n    this.tags = this.tags.filter((tag) => {\n      if (tag[0] === \"a\") return true;\n      if (tag[0] === \"e\" && tag[3] !== \"source\") return true;\n    });\n    this.tag(targetEvent);\n  }\n  /**\n   * The source ID of the wiki event to merge from.\n   */\n  get sourceId() {\n    return this.tagValue(\"e\", \"source\");\n  }\n  /**\n   * Sets the event we are asking to get merged into the target.\n   */\n  set source(sourceEvent) {\n    this.removeTag(\"e\", \"source\");\n    this.tag(sourceEvent, \"source\", false, \"e\");\n  }\n};\n\n// src/events/kinds/blossom-list.ts\nvar NDKBlossomList = class _NDKBlossomList extends NDKEvent {\n  static kinds = [10063 /* BlossomList */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 10063 /* BlossomList */;\n  }\n  static from(ndkEvent) {\n    return new _NDKBlossomList(ndkEvent.ndk, ndkEvent.rawEvent());\n  }\n  /**\n   * Returns all Blossom servers in the list\n   */\n  get servers() {\n    return this.tags.filter((tag) => tag[0] === \"server\").map((tag) => tag[1]);\n  }\n  /**\n   * Sets the list of Blossom servers\n   */\n  set servers(servers) {\n    this.tags = this.tags.filter((tag) => tag[0] !== \"server\");\n    for (const server of servers) {\n      this.tags.push([\"server\", server]);\n    }\n  }\n  /**\n   * Returns the default Blossom server (first in the list)\n   */\n  get default() {\n    const servers = this.servers;\n    return servers.length > 0 ? servers[0] : void 0;\n  }\n  /**\n   * Sets the default Blossom server by moving it to the beginning of the list\n   */\n  set default(server) {\n    if (!server) return;\n    const currentServers = this.servers;\n    const filteredServers = currentServers.filter((s) => s !== server);\n    this.servers = [server, ...filteredServers];\n  }\n  /**\n   * Adds a server to the list if it doesn't already exist\n   */\n  addServer(server) {\n    if (!server) return;\n    const currentServers = this.servers;\n    if (!currentServers.includes(server)) {\n      this.servers = [...currentServers, server];\n    }\n  }\n  /**\n   * Removes a server from the list\n   */\n  removeServer(server) {\n    if (!server) return;\n    const currentServers = this.servers;\n    this.servers = currentServers.filter((s) => s !== server);\n  }\n};\n\n// src/events/kinds/follow-pack.ts\nvar NDKFollowPack = class _NDKFollowPack extends NDKEvent {\n  static kind = 39089 /* FollowPack */;\n  static kinds = [39089 /* FollowPack */, 39092 /* MediaFollowPack */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 39089 /* FollowPack */;\n  }\n  /**\n   * Converts a generic NDKEvent to an NDKFollowPack.\n   */\n  static from(ndkEvent) {\n    return new _NDKFollowPack(ndkEvent.ndk, ndkEvent);\n  }\n  /**\n   * Gets the title from the tags.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Sets the title tag.\n   */\n  set title(value) {\n    this.removeTag(\"title\");\n    if (value) this.tags.push([\"title\", value]);\n  }\n  /**\n   * Gets the image URL from the tags.\n   */\n  /**\n   * Gets the image URL from the tags.\n   * Looks for an imeta tag first (returns its url), then falls back to the image tag.\n   */\n  get image() {\n    const imetaTag = this.tags.find((tag) => tag[0] === \"imeta\");\n    if (imetaTag) {\n      const imeta = mapImetaTag(imetaTag);\n      if (imeta.url) return imeta.url;\n    }\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Sets the image URL tag.\n   */\n  /**\n   * Sets the image tag.\n   * Accepts a string (URL) or an NDKImetaTag.\n   * If given an NDKImetaTag, sets both the imeta tag and the image tag (using the url).\n   * If undefined, removes both tags.\n   */\n  set image(value) {\n    this.tags = this.tags.filter((tag) => tag[0] !== \"imeta\" && tag[0] !== \"image\");\n    if (typeof value === \"string\") {\n      if (value !== void 0) {\n        this.tags.push([\"image\", value]);\n      }\n    } else if (value && typeof value === \"object\") {\n      this.tags.push(imetaTagToTag(value));\n      if (value.url) {\n        this.tags.push([\"image\", value.url]);\n      }\n    }\n  }\n  /**\n   * Gets all pubkeys from p tags.\n   */\n  get pubkeys() {\n    return Array.from(new Set(this.tags.filter((tag) => tag[0] === \"p\").map((tag) => tag[1])));\n  }\n  /**\n   * Sets the pubkeys (replaces all p tags).\n   */\n  set pubkeys(pubkeys) {\n    this.tags = this.tags.filter((tag) => tag[0] !== \"p\");\n    for (const pubkey of pubkeys) {\n      this.tags.push([\"p\", pubkey]);\n    }\n  }\n  /**\n   * Gets the description from the tags.\n   */\n  get description() {\n    return this.tagValue(\"description\");\n  }\n  /**\n   * Sets the description tag.\n   */\n  set description(value) {\n    this.removeTag(\"description\");\n    if (value) this.tags.push([\"description\", value]);\n  }\n};\n\n// src/events/wrap.ts\nfunction wrapEvent(event) {\n  const eventWrappingMap = /* @__PURE__ */ new Map();\n  for (const klass2 of [\n    NDKImage,\n    NDKVideo,\n    NDKCashuMintList,\n    NDKArticle,\n    NDKHighlight,\n    NDKDraft,\n    NDKWiki,\n    NDKNutzap,\n    NDKSimpleGroupMemberList,\n    NDKSimpleGroupMetadata,\n    NDKSubscriptionTier,\n    NDKCashuToken,\n    NDKList,\n    NDKStory,\n    NDKBlossomList,\n    NDKFollowPack\n  ]) {\n    for (const kind of klass2.kinds) {\n      eventWrappingMap.set(kind, klass2);\n    }\n  }\n  const klass = eventWrappingMap.get(event.kind);\n  if (klass) return klass.from(event);\n  return event;\n}\n\n// src/subscription/utils.ts\n\nvar MAX_SUBID_LENGTH = 20;\nfunction queryFullyFilled(subscription) {\n  if (filterIncludesIds(subscription.filter)) {\n    if (resultHasAllRequestedIds(subscription)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction compareFilter(filter1, filter2) {\n  if (Object.keys(filter1).length !== Object.keys(filter2).length) return false;\n  for (const [key, value] of Object.entries(filter1)) {\n    const valuesInFilter2 = filter2[key];\n    if (!valuesInFilter2) return false;\n    if (Array.isArray(value) && Array.isArray(valuesInFilter2)) {\n      const v = value;\n      for (const valueInFilter2 of valuesInFilter2) {\n        const val = valueInFilter2;\n        if (!v.includes(val)) {\n          return false;\n        }\n      }\n    } else {\n      if (valuesInFilter2 !== value) return false;\n    }\n  }\n  return true;\n}\nfunction filterIncludesIds(filter) {\n  return !!filter.ids;\n}\nfunction resultHasAllRequestedIds(subscription) {\n  const ids = subscription.filter.ids;\n  return !!ids && ids.length === subscription.eventFirstSeen.size;\n}\nfunction generateSubId(subscriptions, filters) {\n  const subIds = subscriptions.map((sub) => sub.subId).filter(Boolean);\n  const subIdParts = [];\n  const filterNonKindKeys = /* @__PURE__ */ new Set();\n  const filterKinds = /* @__PURE__ */ new Set();\n  if (subIds.length > 0) {\n    subIdParts.push(Array.from(new Set(subIds)).join(\",\"));\n  } else {\n    for (const filter of filters) {\n      for (const key of Object.keys(filter)) {\n        if (key === \"kinds\") {\n          filter.kinds?.forEach((k) => filterKinds.add(k));\n        } else {\n          filterNonKindKeys.add(key);\n        }\n      }\n    }\n    if (filterKinds.size > 0) {\n      subIdParts.push(`kinds:${Array.from(filterKinds).join(\",\")}`);\n    }\n    if (filterNonKindKeys.size > 0) {\n      subIdParts.push(Array.from(filterNonKindKeys).join(\",\"));\n    }\n  }\n  let subId = subIdParts.join(\"-\");\n  if (subId.length > MAX_SUBID_LENGTH) subId = subId.substring(0, MAX_SUBID_LENGTH);\n  subId += `-${Math.floor(Math.random() * 999).toString()}`;\n  return subId;\n}\nfunction filterForEventsTaggingId(id) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(id);\n    switch (decoded.type) {\n      case \"naddr\":\n        return {\n          \"#a\": [`${decoded.data.kind}:${decoded.data.pubkey}:${decoded.data.identifier}`]\n        };\n      case \"nevent\":\n        return { \"#e\": [decoded.data.id] };\n      case \"note\":\n        return { \"#e\": [decoded.data] };\n      case \"nprofile\":\n        return { \"#p\": [decoded.data.pubkey] };\n      case \"npub\":\n        return { \"#p\": [decoded.data] };\n    }\n  } catch {\n  }\n}\nfunction filterAndRelaySetFromBech32(beche2, ndk) {\n  const filter = filterFromId(beche2);\n  const relays = relaysFromBech32(beche2, ndk);\n  if (relays.length === 0) return { filter };\n  return {\n    filter,\n    relaySet: new NDKRelaySet(new Set(relays), ndk)\n  };\n}\nfunction filterFromId(id) {\n  let decoded;\n  if (id.match(NIP33_A_REGEX)) {\n    const [kind, pubkey, identifier] = id.split(\":\");\n    const filter = {\n      authors: [pubkey],\n      kinds: [Number.parseInt(kind)]\n    };\n    if (identifier) {\n      filter[\"#d\"] = [identifier];\n    }\n    return filter;\n  }\n  if (id.match(BECH32_REGEX)) {\n    try {\n      decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(id);\n      switch (decoded.type) {\n        case \"nevent\": {\n          const filter = { ids: [decoded.data.id] };\n          if (decoded.data.author) filter.authors = [decoded.data.author];\n          if (decoded.data.kind) filter.kinds = [decoded.data.kind];\n          return filter;\n        }\n        case \"note\":\n          return { ids: [decoded.data] };\n        case \"naddr\": {\n          const filter = {\n            authors: [decoded.data.pubkey],\n            kinds: [decoded.data.kind]\n          };\n          if (decoded.data.identifier) filter[\"#d\"] = [decoded.data.identifier];\n          return filter;\n        }\n      }\n    } catch (e) {\n      console.error(\"Error decoding\", id, e);\n    }\n  }\n  return { ids: [id] };\n}\nfunction isNip33AValue(value) {\n  return value.match(NIP33_A_REGEX) !== null;\n}\nvar NIP33_A_REGEX = /^(\\d+):([0-9A-Fa-f]+)(?::(.*))?$/;\nvar BECH32_REGEX = /^n(event|ote|profile|pub|addr)1[\\d\\w]+$/;\nfunction relaysFromBech32(bech322, ndk) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(bech322);\n    if ([\"naddr\", \"nevent\"].includes(decoded?.type)) {\n      const data = decoded.data;\n      if (data?.relays) {\n        return data.relays.map((r) => new NDKRelay(r, ndk.relayAuthDefaultPolicy, ndk));\n      }\n    }\n  } catch (_e) {\n  }\n  return [];\n}\n\n// src/subscription/index.ts\nvar NDKSubscriptionCacheUsage = /* @__PURE__ */ ((NDKSubscriptionCacheUsage2) => {\n  NDKSubscriptionCacheUsage2[\"ONLY_CACHE\"] = \"ONLY_CACHE\";\n  NDKSubscriptionCacheUsage2[\"CACHE_FIRST\"] = \"CACHE_FIRST\";\n  NDKSubscriptionCacheUsage2[\"PARALLEL\"] = \"PARALLEL\";\n  NDKSubscriptionCacheUsage2[\"ONLY_RELAY\"] = \"ONLY_RELAY\";\n  return NDKSubscriptionCacheUsage2;\n})(NDKSubscriptionCacheUsage || {});\nvar defaultOpts = {\n  closeOnEose: false,\n  cacheUsage: \"CACHE_FIRST\" /* CACHE_FIRST */,\n  dontSaveToCache: false,\n  groupable: true,\n  groupableDelay: 100,\n  groupableDelayType: \"at-most\",\n  cacheUnconstrainFilter: [\"limit\", \"since\", \"until\"]\n};\nvar NDKSubscription = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  subId;\n  filters;\n  opts;\n  pool;\n  skipVerification = false;\n  skipValidation = false;\n  /**\n   * Tracks the filters as they are executed on each relay\n   */\n  relayFilters;\n  relaySet;\n  ndk;\n  debug;\n  /**\n   * Events that have been seen by the subscription, with the time they were first seen.\n   */\n  eventFirstSeen = /* @__PURE__ */ new Map();\n  /**\n   * Relays that have sent an EOSE.\n   */\n  eosesSeen = /* @__PURE__ */ new Set();\n  /**\n   * The time the last event was received by the subscription.\n   * This is used to calculate when EOSE should be emitted.\n   */\n  lastEventReceivedAt;\n  /**\n   * The most recent event timestamp from cache results.\n   * This is used for addSinceFromCache functionality.\n   */\n  mostRecentCacheEventTimestamp;\n  internalId;\n  /**\n   * Whether the subscription should close when all relays have reached the end of the event stream.\n   */\n  closeOnEose;\n  /**\n   * Pool monitor callback\n   */\n  poolMonitor;\n  skipOptimisticPublishEvent = false;\n  /**\n   * Filters to remove when querying the cache.\n   */\n  cacheUnconstrainFilter;\n  constructor(ndk, filters, opts, subId) {\n    super();\n    this.ndk = ndk;\n    this.opts = { ...defaultOpts, ...opts || {} };\n    this.pool = this.opts.pool || ndk.pool;\n    this.filters = Array.isArray(filters) ? filters : [filters];\n    this.subId = subId || this.opts.subId;\n    this.internalId = Math.random().toString(36).substring(7);\n    this.debug = ndk.debug.extend(`subscription[${this.opts.subId ?? this.internalId}]`);\n    if (this.opts.relaySet) {\n      this.relaySet = this.opts.relaySet;\n    } else if (this.opts.relayUrls) {\n      this.relaySet = NDKRelaySet.fromRelayUrls(this.opts.relayUrls, this.ndk);\n    }\n    this.skipVerification = this.opts.skipVerification || false;\n    this.skipValidation = this.opts.skipValidation || false;\n    this.closeOnEose = this.opts.closeOnEose || false;\n    this.skipOptimisticPublishEvent = this.opts.skipOptimisticPublishEvent || false;\n    this.cacheUnconstrainFilter = this.opts.cacheUnconstrainFilter;\n  }\n  /**\n   * Returns the relays that have not yet sent an EOSE.\n   */\n  relaysMissingEose() {\n    if (!this.relayFilters) return [];\n    const relaysMissingEose = Array.from(this.relayFilters?.keys()).filter(\n      (url) => !this.eosesSeen.has(this.pool.getRelay(url, false, false))\n    );\n    return relaysMissingEose;\n  }\n  /**\n   * Provides access to the first filter of the subscription for\n   * backwards compatibility.\n   */\n  get filter() {\n    return this.filters[0];\n  }\n  get groupableDelay() {\n    if (!this.isGroupable()) return void 0;\n    return this.opts?.groupableDelay;\n  }\n  get groupableDelayType() {\n    return this.opts?.groupableDelayType || \"at-most\";\n  }\n  isGroupable() {\n    return this.opts?.groupable || false;\n  }\n  shouldQueryCache() {\n    if (this.opts.addSinceFromCache) return true;\n    if (this.opts?.cacheUsage === \"ONLY_RELAY\" /* ONLY_RELAY */) return false;\n    const hasNonEphemeralKind = this.filters.some((f) => f.kinds?.some((k) => kindIsEphemeral(k)));\n    if (hasNonEphemeralKind) return true;\n    return true;\n  }\n  shouldQueryRelays() {\n    return this.opts?.cacheUsage !== \"ONLY_CACHE\" /* ONLY_CACHE */;\n  }\n  shouldWaitForCache() {\n    if (this.opts.addSinceFromCache) return true;\n    return (\n      // Must want to close on EOSE; subscriptions\n      // that want to receive further updates must\n      // always hit the relay\n      !!this.opts.closeOnEose && // Cache adapter must claim to be fast\n      !!this.ndk.cacheAdapter?.locking && // If explicitly told to run in parallel, then\n      // we should not wait for the cache\n      this.opts.cacheUsage !== \"PARALLEL\" /* PARALLEL */\n    );\n  }\n  /**\n   * Start the subscription. This is the main method that should be called\n   * after creating a subscription.\n   *\n   * @param emitCachedEvents - Whether to emit events coming from a synchronous cache\n   *\n   * When using a synchronous cache, the events will be returned immediately\n   * by this function. If you will use those returned events, you should\n   * set emitCachedEvents to false to prevent seeing them as duplicate events.\n   */\n  start(emitCachedEvents = true) {\n    let cacheResult;\n    const updateStateFromCacheResults = (events) => {\n      if (emitCachedEvents) {\n        for (const event of events) {\n          if (!this.mostRecentCacheEventTimestamp || event.created_at > this.mostRecentCacheEventTimestamp) {\n            this.mostRecentCacheEventTimestamp = event.created_at;\n          }\n          this.eventReceived(event, void 0, true, false);\n        }\n      } else {\n        cacheResult = [];\n        for (const event of events) {\n          if (!this.mostRecentCacheEventTimestamp || event.created_at > this.mostRecentCacheEventTimestamp) {\n            this.mostRecentCacheEventTimestamp = event.created_at;\n          }\n          event.ndk = this.ndk;\n          const e = this.opts.wrap ? wrapEvent(event) : event;\n          if (!e) break;\n          if (e instanceof Promise) {\n            e.then((wrappedEvent) => {\n              this.emitEvent(false, wrappedEvent, void 0, true, false);\n            });\n            break;\n          }\n          this.eventFirstSeen.set(e.id, Date.now());\n          cacheResult.push(e);\n        }\n      }\n    };\n    const loadFromRelays = () => {\n      if (this.shouldQueryRelays()) {\n        this.startWithRelays();\n        this.startPoolMonitor();\n      } else {\n        this.emit(\"eose\", this);\n      }\n    };\n    if (this.shouldQueryCache()) {\n      cacheResult = this.startWithCache();\n      if (cacheResult instanceof Promise) {\n        if (this.shouldWaitForCache()) {\n          cacheResult.then((events) => {\n            updateStateFromCacheResults(events);\n            if (queryFullyFilled(this)) {\n              this.emit(\"eose\", this);\n              return;\n            }\n            loadFromRelays();\n          });\n          return null;\n        }\n        cacheResult.then((events) => {\n          updateStateFromCacheResults(events);\n        });\n        loadFromRelays();\n        return null;\n      }\n      updateStateFromCacheResults(cacheResult);\n      if (queryFullyFilled(this)) {\n        this.emit(\"eose\", this);\n      } else {\n        loadFromRelays();\n      }\n      return cacheResult;\n    }\n    loadFromRelays();\n    return null;\n  }\n  /**\n   * We want to monitor for new relays that are coming online, in case\n   * they should be part of this subscription.\n   */\n  startPoolMonitor() {\n    const _d = this.debug.extend(\"pool-monitor\");\n    this.poolMonitor = (relay) => {\n      if (this.relayFilters?.has(relay.url)) return;\n      const calc = calculateRelaySetsFromFilters(this.ndk, this.filters, this.pool);\n      if (calc.get(relay.url)) {\n        this.relayFilters?.set(relay.url, this.filters);\n        relay.subscribe(this, this.filters);\n      }\n    };\n    this.pool.on(\"relay:connect\", this.poolMonitor);\n  }\n  onStopped;\n  stop() {\n    this.emit(\"close\", this);\n    this.poolMonitor && this.pool.off(\"relay:connect\", this.poolMonitor);\n    this.onStopped?.();\n  }\n  /**\n   * @returns Whether the subscription has an authors filter.\n   */\n  hasAuthorsFilter() {\n    return this.filters.some((f) => f.authors?.length);\n  }\n  startWithCache() {\n    if (this.ndk.cacheAdapter?.query) {\n      return this.ndk.cacheAdapter.query(this);\n    }\n    return [];\n  }\n  /**\n   * Find available relays that should be part of this subscription and execute in them.\n   *\n   * Note that this is executed in addition to using the pool monitor, so even if the relay set\n   * that is computed (i.e. we don't have any relays available), when relays come online, we will\n   * check if we need to execute in them.\n   */\n  startWithRelays() {\n    let filters = this.filters;\n    if (this.opts.addSinceFromCache && this.mostRecentCacheEventTimestamp) {\n      const sinceTimestamp = this.mostRecentCacheEventTimestamp + 1;\n      filters = filters.map((filter) => ({\n        ...filter,\n        since: Math.max(filter.since || 0, sinceTimestamp)\n      }));\n    }\n    if (!this.relaySet || this.relaySet.relays.size === 0) {\n      this.relayFilters = calculateRelaySetsFromFilters(this.ndk, filters, this.pool);\n    } else {\n      this.relayFilters = /* @__PURE__ */ new Map();\n      for (const relay of this.relaySet.relays) {\n        this.relayFilters.set(relay.url, filters);\n      }\n    }\n    for (const [relayUrl, filters2] of this.relayFilters) {\n      const relay = this.pool.getRelay(relayUrl, true, true, filters2);\n      relay.subscribe(this, filters2);\n    }\n  }\n  // EVENT handling\n  /**\n   * Called when an event is received from a relay or the cache\n   * @param event\n   * @param relay\n   * @param fromCache Whether the event was received from the cache\n   * @param optimisticPublish Whether this event is coming from an optimistic publish\n   */\n  eventReceived(event, relay, fromCache = false, optimisticPublish = false) {\n    const eventId = event.id;\n    const eventAlreadySeen = this.eventFirstSeen.has(eventId);\n    let ndkEvent;\n    if (event instanceof NDKEvent) ndkEvent = event;\n    if (!eventAlreadySeen) {\n      ndkEvent ??= new NDKEvent(this.ndk, event);\n      ndkEvent.ndk = this.ndk;\n      ndkEvent.relay = relay;\n      if (!fromCache && !optimisticPublish) {\n        if (!this.skipValidation) {\n          if (!ndkEvent.isValid) {\n            this.debug(\"Event failed validation %s from relay %s\", eventId, relay?.url);\n            return;\n          }\n        }\n        if (relay) {\n          const shouldVerify = relay.shouldValidateEvent();\n          if (shouldVerify && !this.skipVerification) {\n            ndkEvent.relay = relay;\n            if (!this.ndk.asyncSigVerification) {\n              if (!ndkEvent.verifySignature(true)) {\n                this.debug(\"Event failed signature validation\", event);\n                this.ndk.reportInvalidSignature(ndkEvent, relay);\n                return;\n              }\n              relay.addValidatedEvent();\n            }\n          } else {\n            relay.addNonValidatedEvent();\n          }\n        }\n        if (this.ndk.cacheAdapter && !this.opts.dontSaveToCache) {\n          this.ndk.cacheAdapter.setEvent(ndkEvent, this.filters, relay);\n        }\n      }\n      if (!optimisticPublish || this.skipOptimisticPublishEvent !== true) {\n        this.emitEvent(this.opts?.wrap ?? false, ndkEvent, relay, fromCache, optimisticPublish);\n        this.eventFirstSeen.set(eventId, Date.now());\n      }\n    } else {\n      const timeSinceFirstSeen = Date.now() - (this.eventFirstSeen.get(eventId) || 0);\n      this.emit(\"event:dup\", event, relay, timeSinceFirstSeen, this, fromCache, optimisticPublish);\n      if (relay) {\n        const signature = verifiedSignatures.get(eventId);\n        if (signature && typeof signature === \"string\") {\n          if (event.sig === signature) {\n            relay.addValidatedEvent();\n          } else {\n            const eventToReport = event instanceof NDKEvent ? event : new NDKEvent(this.ndk, event);\n            this.ndk.reportInvalidSignature(eventToReport, relay);\n          }\n        }\n      }\n    }\n    this.lastEventReceivedAt = Date.now();\n  }\n  /**\n   * Optionally wraps, sync or async, and emits the event (if one comes back from the wrapper)\n   */\n  emitEvent(wrap, evt, relay, fromCache, optimisticPublish) {\n    const wrapped = wrap ? wrapEvent(evt) : evt;\n    if (wrapped instanceof Promise) {\n      wrapped.then((e) => this.emitEvent(false, e, relay, fromCache, optimisticPublish));\n    } else if (wrapped) {\n      this.emit(\"event\", wrapped, relay, this, fromCache, optimisticPublish);\n    }\n  }\n  closedReceived(relay, reason) {\n    this.emit(\"closed\", relay, reason);\n  }\n  // EOSE handling\n  eoseTimeout;\n  eosed = false;\n  eoseReceived(relay) {\n    this.debug(\"EOSE received from %s\", relay.url);\n    this.eosesSeen.add(relay);\n    let lastEventSeen = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;\n    const hasSeenAllEoses = this.eosesSeen.size === this.relayFilters?.size;\n    const queryFilled = queryFullyFilled(this);\n    const performEose = (reason) => {\n      this.debug(\"Performing EOSE: %s %d\", reason, this.eosed);\n      if (this.eosed) return;\n      if (this.eoseTimeout) clearTimeout(this.eoseTimeout);\n      this.emit(\"eose\", this);\n      this.eosed = true;\n      if (this.opts?.closeOnEose) this.stop();\n    };\n    if (queryFilled || hasSeenAllEoses) {\n      performEose(\"query filled or seen all\");\n    } else if (this.relayFilters) {\n      let timeToWaitForNextEose = 1e3;\n      const connectedRelays = new Set(this.pool.connectedRelays().map((r) => r.url));\n      const connectedRelaysWithFilters = Array.from(this.relayFilters.keys()).filter(\n        (url) => connectedRelays.has(url)\n      );\n      if (connectedRelaysWithFilters.length === 0) {\n        this.debug(\n          \"No connected relays, waiting for all relays to connect\",\n          Array.from(this.relayFilters.keys()).join(\", \")\n        );\n        return;\n      }\n      const percentageOfRelaysThatHaveSentEose = this.eosesSeen.size / connectedRelaysWithFilters.length;\n      this.debug(\"Percentage of relays that have sent EOSE\", {\n        subId: this.subId,\n        percentageOfRelaysThatHaveSentEose,\n        seen: this.eosesSeen.size,\n        total: connectedRelaysWithFilters.length\n      });\n      if (this.eosesSeen.size >= 2 && percentageOfRelaysThatHaveSentEose >= 0.5) {\n        timeToWaitForNextEose = timeToWaitForNextEose * (1 - percentageOfRelaysThatHaveSentEose);\n        if (timeToWaitForNextEose === 0) {\n          performEose(\"time to wait was 0\");\n          return;\n        }\n        if (this.eoseTimeout) clearTimeout(this.eoseTimeout);\n        const sendEoseTimeout = () => {\n          lastEventSeen = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;\n          if (lastEventSeen !== void 0 && lastEventSeen < 20) {\n            this.eoseTimeout = setTimeout(sendEoseTimeout, timeToWaitForNextEose);\n          } else {\n            performEose(`send eose timeout: ${timeToWaitForNextEose}`);\n          }\n        };\n        this.eoseTimeout = setTimeout(sendEoseTimeout, timeToWaitForNextEose);\n      }\n    }\n  }\n};\nvar kindIsEphemeral = (kind) => kind >= 2e4 && kind < 3e4;\n\n// src/user/follows.ts\nasync function follows(opts, outbox, kind = 3 /* Contacts */) {\n  if (!this.ndk) throw new Error(\"NDK not set\");\n  const contactListEvent = await this.ndk.fetchEvent(\n    { kinds: [kind], authors: [this.pubkey] },\n    opts || { groupable: false }\n  );\n  if (contactListEvent) {\n    const pubkeys = /* @__PURE__ */ new Set();\n    contactListEvent.tags.forEach((tag) => {\n      if (tag[0] === \"p\") pubkeys.add(tag[1]);\n    });\n    if (outbox) {\n      this.ndk?.outboxTracker?.trackUsers(Array.from(pubkeys));\n    }\n    return [...pubkeys].reduce((acc, pubkey) => {\n      const user = new NDKUser({ pubkey });\n      user.ndk = this.ndk;\n      acc.add(user);\n      return acc;\n    }, /* @__PURE__ */ new Set());\n  }\n  return /* @__PURE__ */ new Set();\n}\n\n// src/user/nip05.ts\nvar NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w.-]+)$/;\nasync function getNip05For(ndk, fullname, _fetch = fetch, fetchOpts = {}) {\n  return await ndk.queuesNip05.add({\n    id: fullname,\n    func: async () => {\n      if (ndk.cacheAdapter?.loadNip05) {\n        const profile = await ndk.cacheAdapter.loadNip05(fullname);\n        if (profile !== \"missing\") {\n          if (profile) {\n            const user = new NDKUser({\n              pubkey: profile.pubkey,\n              relayUrls: profile.relays,\n              nip46Urls: profile.nip46\n            });\n            user.ndk = ndk;\n            return user;\n          }\n          if (fetchOpts.cache !== \"no-cache\") {\n            return null;\n          }\n        }\n      }\n      const match = fullname.match(NIP05_REGEX);\n      if (!match) return null;\n      const [_, name = \"_\", domain] = match;\n      try {\n        const res = await _fetch(`https://${domain}/.well-known/nostr.json?name=${name}`, fetchOpts);\n        const { names, relays, nip46 } = parseNIP05Result(await res.json());\n        const pubkey = names[name.toLowerCase()];\n        let profile = null;\n        if (pubkey) {\n          profile = { pubkey, relays: relays?.[pubkey], nip46: nip46?.[pubkey] };\n        }\n        if (ndk?.cacheAdapter?.saveNip05) {\n          ndk.cacheAdapter.saveNip05(fullname, profile);\n        }\n        return profile;\n      } catch (_e) {\n        if (ndk?.cacheAdapter?.saveNip05) {\n          ndk?.cacheAdapter.saveNip05(fullname, null);\n        }\n        console.error(\"Failed to fetch NIP05 for\", fullname, _e);\n        return null;\n      }\n    }\n  });\n}\nfunction parseNIP05Result(json) {\n  const result = {\n    names: {}\n  };\n  for (const [name, pubkey] of Object.entries(json.names)) {\n    if (typeof name === \"string\" && typeof pubkey === \"string\") {\n      result.names[name.toLowerCase()] = pubkey;\n    }\n  }\n  if (json.relays) {\n    result.relays = {};\n    for (const [pubkey, relays] of Object.entries(json.relays)) {\n      if (typeof pubkey === \"string\" && Array.isArray(relays)) {\n        result.relays[pubkey] = relays.filter((relay) => typeof relay === \"string\");\n      }\n    }\n  }\n  if (json.nip46) {\n    result.nip46 = {};\n    for (const [pubkey, nip46] of Object.entries(json.nip46)) {\n      if (typeof pubkey === \"string\" && Array.isArray(nip46)) {\n        result.nip46[pubkey] = nip46.filter((relay) => typeof relay === \"string\");\n      }\n    }\n  }\n  return result;\n}\n\n// src/user/profile.ts\nfunction profileFromEvent(event) {\n  const profile = {};\n  let payload;\n  try {\n    payload = JSON.parse(event.content);\n  } catch (error) {\n    throw new Error(`Failed to parse profile event: ${error}`);\n  }\n  profile.profileEvent = JSON.stringify(event.rawEvent());\n  for (const key of Object.keys(payload)) {\n    switch (key) {\n      case \"name\":\n        profile.name = payload.name;\n        break;\n      case \"display_name\":\n        profile.displayName = payload.display_name;\n        break;\n      case \"image\":\n      case \"picture\":\n        profile.picture = payload.picture || payload.image;\n        profile.image = profile.picture;\n        break;\n      case \"banner\":\n        profile.banner = payload.banner;\n        break;\n      case \"bio\":\n        profile.bio = payload.bio;\n        break;\n      case \"nip05\":\n        profile.nip05 = payload.nip05;\n        break;\n      case \"lud06\":\n        profile.lud06 = payload.lud06;\n        break;\n      case \"lud16\":\n        profile.lud16 = payload.lud16;\n        break;\n      case \"about\":\n        profile.about = payload.about;\n        break;\n      case \"website\":\n        profile.website = payload.website;\n        break;\n      default:\n        profile[key] = payload[key];\n        break;\n    }\n  }\n  profile.created_at = event.created_at;\n  return profile;\n}\nfunction serializeProfile(profile) {\n  const payload = {};\n  for (const [key, val] of Object.entries(profile)) {\n    switch (key) {\n      case \"username\":\n      case \"name\":\n        payload.name = val;\n        break;\n      case \"displayName\":\n        payload.display_name = val;\n        break;\n      case \"image\":\n      case \"picture\":\n        payload.picture = val;\n        break;\n      case \"bio\":\n      case \"about\":\n        payload.about = val;\n        break;\n      default:\n        payload[key] = val;\n        break;\n    }\n  }\n  return JSON.stringify(payload);\n}\n\n// src/user/index.ts\nvar NDKUser = class _NDKUser {\n  ndk;\n  profile;\n  profileEvent;\n  _npub;\n  _pubkey;\n  relayUrls = [];\n  nip46Urls = [];\n  constructor(opts) {\n    if (opts.npub) this._npub = opts.npub;\n    if (opts.hexpubkey) this._pubkey = opts.hexpubkey;\n    if (opts.pubkey) this._pubkey = opts.pubkey;\n    if (opts.relayUrls) this.relayUrls = opts.relayUrls;\n    if (opts.nip46Urls) this.nip46Urls = opts.nip46Urls;\n    if (opts.nprofile) {\n      try {\n        const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(opts.nprofile);\n        if (decoded.type === \"nprofile\") {\n          this._pubkey = decoded.data.pubkey;\n          if (decoded.data.relays && decoded.data.relays.length > 0) {\n            this.relayUrls.push(...decoded.data.relays);\n          }\n        }\n      } catch (e) {\n        console.error(\"Failed to decode nprofile\", e);\n      }\n    }\n  }\n  get npub() {\n    if (!this._npub) {\n      if (!this._pubkey) throw new Error(\"pubkey not set\");\n      this._npub = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.npubEncode(this.pubkey);\n    }\n    return this._npub;\n  }\n  get nprofile() {\n    const relays = this.profileEvent?.onRelays?.map((r) => r.url);\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.nprofileEncode({\n      pubkey: this.pubkey,\n      relays\n    });\n  }\n  set npub(npub2) {\n    this._npub = npub2;\n  }\n  /**\n   * Get the user's pubkey\n   * @returns {string} The user's pubkey\n   */\n  get pubkey() {\n    if (!this._pubkey) {\n      if (!this._npub) throw new Error(\"npub not set\");\n      this._pubkey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(this.npub).data;\n    }\n    return this._pubkey;\n  }\n  /**\n   * Set the user's pubkey\n   * @param pubkey {string} The user's pubkey\n   */\n  set pubkey(pubkey) {\n    this._pubkey = pubkey;\n  }\n  /**\n   * Equivalent to NDKEvent.filters().\n   * @returns {NDKFilter}\n   */\n  filter() {\n    return { \"#p\": [this.pubkey] };\n  }\n  /**\n   * Gets NIP-57 and NIP-61 information that this user has signaled\n   *\n   * @param getAll {boolean} Whether to get all zap info or just the first one\n   */\n  async getZapInfo(timeoutMs) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const promiseWithTimeout = async (promise) => {\n      if (!timeoutMs) return promise;\n      let timeoutId;\n      const timeoutPromise = new Promise((_, reject) => {\n        timeoutId = setTimeout(() => reject(new Error(\"Timeout\")), timeoutMs);\n      });\n      try {\n        const result = await Promise.race([promise, timeoutPromise]);\n        if (timeoutId) clearTimeout(timeoutId);\n        return result;\n      } catch (e) {\n        if (e instanceof Error && e.message === \"Timeout\") {\n          try {\n            const result = await promise;\n            return result;\n          } catch (_originalError) {\n            return void 0;\n          }\n        }\n        return void 0;\n      }\n    };\n    const [userProfile, mintListEvent] = await Promise.all([\n      promiseWithTimeout(this.fetchProfile()),\n      promiseWithTimeout(this.ndk.fetchEvent({ kinds: [10019 /* CashuMintList */], authors: [this.pubkey] }))\n    ]);\n    const res = /* @__PURE__ */ new Map();\n    if (mintListEvent) {\n      const mintList = NDKCashuMintList.from(mintListEvent);\n      if (mintList.mints.length > 0) {\n        res.set(\"nip61\", {\n          mints: mintList.mints,\n          relays: mintList.relays,\n          p2pk: mintList.p2pk\n        });\n      }\n    }\n    if (userProfile) {\n      const { lud06, lud16 } = userProfile;\n      res.set(\"nip57\", { lud06, lud16 });\n    }\n    return res;\n  }\n  /**\n   * Instantiate an NDKUser from a NIP-05 string\n   * @param nip05Id {string} The user's NIP-05\n   * @param ndk {NDK} An NDK instance\n   * @param skipCache {boolean} Whether to skip the cache or not\n   * @returns {NDKUser | undefined} An NDKUser if one is found for the given NIP-05, undefined otherwise.\n   */\n  static async fromNip05(nip05Id, ndk, skipCache = false) {\n    if (!ndk) throw new Error(\"No NDK instance found\");\n    const opts = {};\n    if (skipCache) opts.cache = \"no-cache\";\n    const profile = await getNip05For(ndk, nip05Id, ndk?.httpFetch, opts);\n    if (profile) {\n      const user = new _NDKUser({\n        pubkey: profile.pubkey,\n        relayUrls: profile.relays,\n        nip46Urls: profile.nip46\n      });\n      user.ndk = ndk;\n      return user;\n    }\n  }\n  /**\n   * Fetch a user's profile\n   * @param opts {NDKSubscriptionOptions} A set of NDKSubscriptionOptions\n   * @param storeProfileEvent {boolean} Whether to store the profile event or not\n   * @returns User Profile\n   */\n  async fetchProfile(opts, storeProfileEvent = false) {\n    if (!this.ndk) throw new Error(\"NDK not set\");\n    let setMetadataEvent = null;\n    if (this.ndk.cacheAdapter && (this.ndk.cacheAdapter.fetchProfile || this.ndk.cacheAdapter.fetchProfileSync) && opts?.cacheUsage !== \"ONLY_RELAY\" /* ONLY_RELAY */) {\n      let profile = null;\n      if (this.ndk.cacheAdapter.fetchProfileSync) {\n        profile = this.ndk.cacheAdapter.fetchProfileSync(this.pubkey);\n      } else if (this.ndk.cacheAdapter.fetchProfile) {\n        profile = await this.ndk.cacheAdapter.fetchProfile(this.pubkey);\n      }\n      if (profile) {\n        this.profile = profile;\n        return profile;\n      }\n    }\n    opts ??= {};\n    opts.cacheUsage ??= \"ONLY_RELAY\" /* ONLY_RELAY */;\n    opts.closeOnEose ??= true;\n    opts.groupable ??= true;\n    opts.groupableDelay ??= 250;\n    if (!setMetadataEvent) {\n      setMetadataEvent = await this.ndk.fetchEvent({ kinds: [0], authors: [this.pubkey] }, opts);\n    }\n    if (!setMetadataEvent) return null;\n    this.profile = profileFromEvent(setMetadataEvent);\n    if (storeProfileEvent && this.profile && this.ndk.cacheAdapter && this.ndk.cacheAdapter.saveProfile) {\n      this.ndk.cacheAdapter.saveProfile(this.pubkey, this.profile);\n    }\n    return this.profile;\n  }\n  /**\n   * Returns a set of users that this user follows.\n   *\n   * @deprecated Use followSet instead\n   */\n  follows = follows.bind(this);\n  /**\n   * Returns a set of pubkeys that this user follows.\n   *\n   * @param opts - NDKSubscriptionOptions\n   * @param outbox - boolean\n   * @param kind - number\n   */\n  async followSet(opts, outbox, kind = 3 /* Contacts */) {\n    const follows2 = await this.follows(opts, outbox, kind);\n    return new Set(Array.from(follows2).map((f) => f.pubkey));\n  }\n  /** @deprecated Use referenceTags instead. */\n  /**\n   * Get the tag that can be used to reference this user in an event\n   * @returns {NDKTag} an NDKTag\n   */\n  tagReference() {\n    return [\"p\", this.pubkey];\n  }\n  /**\n   * Get the tags that can be used to reference this user in an event\n   * @returns {NDKTag[]} an array of NDKTag\n   */\n  referenceTags(marker) {\n    const tag = [[\"p\", this.pubkey]];\n    if (!marker) return tag;\n    tag[0].push(\"\", marker);\n    return tag;\n  }\n  /**\n   * Publishes the current profile.\n   */\n  async publish() {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    if (!this.profile) throw new Error(\"No profile available\");\n    this.ndk.assertSigner();\n    const event = new NDKEvent(this.ndk, {\n      kind: 0,\n      content: serializeProfile(this.profile)\n    });\n    await event.publish();\n  }\n  /**\n   * Add a follow to this user's contact list\n   *\n   * @param newFollow {NDKUser} The user to follow\n   * @param currentFollowList {Set<NDKUser>} The current follow list\n   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)\n   * @returns {Promise<boolean>} True if the follow was added, false if the follow already exists\n   */\n  async follow(newFollow, currentFollowList, kind = 3 /* Contacts */) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    if (!currentFollowList) {\n      currentFollowList = await this.follows(void 0, void 0, kind);\n    }\n    if (currentFollowList.has(newFollow)) {\n      return false;\n    }\n    currentFollowList.add(newFollow);\n    const event = new NDKEvent(this.ndk, { kind });\n    for (const follow of currentFollowList) {\n      event.tag(follow);\n    }\n    await event.publish();\n    return true;\n  }\n  /**\n   * Remove a follow from this user's contact list\n   *\n   * @param user {NDKUser} The user to unfollow\n   * @param currentFollowList {Set<NDKUser>} The current follow list\n   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)\n   * @returns The relays were the follow list was published or false if the user wasn't found\n   */\n  async unfollow(user, currentFollowList, kind = 3 /* Contacts */) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    if (!currentFollowList) {\n      currentFollowList = await this.follows(void 0, void 0, kind);\n    }\n    const newUserFollowList = /* @__PURE__ */ new Set();\n    let foundUser = false;\n    for (const follow of currentFollowList) {\n      if (follow.pubkey !== user.pubkey) {\n        newUserFollowList.add(follow);\n      } else {\n        foundUser = true;\n      }\n    }\n    if (!foundUser) return false;\n    const event = new NDKEvent(this.ndk, { kind });\n    for (const follow of newUserFollowList) {\n      event.tag(follow);\n    }\n    return await event.publish();\n  }\n  /**\n   * Validate a user's NIP-05 identifier (usually fetched from their kind:0 profile data)\n   *\n   * @param nip05Id The NIP-05 string to validate\n   * @returns {Promise<boolean | null>} True if the NIP-05 is found and matches this user's pubkey,\n   * False if the NIP-05 is found but doesn't match this user's pubkey,\n   * null if the NIP-05 isn't found on the domain or we're unable to verify (because of network issues, etc.)\n   */\n  async validateNip05(nip05Id) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const profilePointer = await getNip05For(this.ndk, nip05Id);\n    if (profilePointer === null) return null;\n    return profilePointer.pubkey === this.pubkey;\n  }\n};\n\n// src/user/pin.ts\nasync function pinEvent(user, event, pinEvent2, publish) {\n  const kind = 10001 /* PinList */;\n  if (!user.ndk) throw new Error(\"No NDK instance found\");\n  user.ndk.assertSigner();\n  if (!pinEvent2) {\n    const events = await user.ndk.fetchEvents(\n      { kinds: [kind], authors: [user.pubkey] },\n      { cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */ }\n    );\n    if (events.size > 0) {\n      pinEvent2 = lists_default.from(Array.from(events)[0]);\n    } else {\n      pinEvent2 = new NDKEvent(user.ndk, {\n        kind\n      });\n    }\n  }\n  pinEvent2.tag(event);\n  if (publish) {\n    await pinEvent2.publish();\n  }\n  return pinEvent2;\n}\n\n// src/events/kinds/classified.ts\nvar NDKClassified = class _NDKClassified extends NDKEvent {\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30402 /* Classified */;\n  }\n  /**\n   * Creates a NDKClassified from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKClassified from.\n   * @returns NDKClassified\n   */\n  static from(event) {\n    return new _NDKClassified(event.ndk, event);\n  }\n  /**\n   * Getter for the classified title.\n   *\n   * @returns {string | undefined} - The classified title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the classified title.\n   *\n   * @param {string | undefined} title - The title to set for the classified.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the classified summary.\n   *\n   * @returns {string | undefined} - The classified summary if available, otherwise undefined.\n   */\n  get summary() {\n    return this.tagValue(\"summary\");\n  }\n  /**\n   * Setter for the classified summary.\n   *\n   * @param {string | undefined} summary - The summary to set for the classified.\n   */\n  set summary(summary) {\n    this.removeTag(\"summary\");\n    if (summary) this.tags.push([\"summary\", summary]);\n  }\n  /**\n   * Getter for the classified's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the classified was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      return Number.parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the classified's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the classified's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Getter for the classified location.\n   *\n   * @returns {string | undefined} - The classified location if available, otherwise undefined.\n   */\n  get location() {\n    return this.tagValue(\"location\");\n  }\n  /**\n   * Setter for the classified location.\n   *\n   * @param {string | undefined} location - The location to set for the classified.\n   */\n  set location(location) {\n    this.removeTag(\"location\");\n    if (location) this.tags.push([\"location\", location]);\n  }\n  /**\n   * Getter for the classified price.\n   *\n   * @returns {NDKClassifiedPriceTag | undefined} - The classified price if available, otherwise undefined.\n   */\n  get price() {\n    const priceTag = this.tags.find((tag) => tag[0] === \"price\");\n    if (priceTag) {\n      return {\n        amount: Number.parseFloat(priceTag[1]),\n        currency: priceTag[2],\n        frequency: priceTag[3]\n      };\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the classified price.\n   *\n   * @param price - The price to set for the classified.\n   */\n  set price(priceTag) {\n    if (typeof priceTag === \"string\") {\n      priceTag = {\n        amount: Number.parseFloat(priceTag)\n      };\n    }\n    if (priceTag?.amount) {\n      const tag = [\"price\", priceTag.amount.toString()];\n      if (priceTag.currency) tag.push(priceTag.currency);\n      if (priceTag.frequency) tag.push(priceTag.frequency);\n      this.tags.push(tag);\n    } else {\n      this.removeTag(\"price\");\n    }\n  }\n  /**\n   * Generates content tags for the classified.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n};\n\n// src/events/kinds/drafts.ts\nvar NDKDraft = class _NDKDraft extends NDKEvent {\n  _event;\n  static kind = 31234 /* Draft */;\n  static kinds = [31234 /* Draft */, 1234 /* DraftCheckpoint */];\n  /**\n   * Can be used to include a different pubkey as part of the draft.\n   * This is useful when we want to make the draft a proposal for a different user to publish.\n   */\n  counterparty;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 31234 /* Draft */;\n  }\n  static from(event) {\n    return new _NDKDraft(event.ndk, event);\n  }\n  /**\n   * Sets an identifier (i.e. d-tag)\n   */\n  set identifier(id) {\n    this.removeTag(\"d\");\n    this.tags.push([\"d\", id]);\n  }\n  get identifier() {\n    return this.dTag;\n  }\n  /**\n   * Event that is to be saved.\n   */\n  set event(e) {\n    if (!(e instanceof NDKEvent)) this._event = new NDKEvent(void 0, e);\n    else this._event = e;\n    this.prepareEvent();\n  }\n  /**\n   * Marks the event as a checkpoint for another draft event.\n   */\n  set checkpoint(parent) {\n    if (parent) {\n      this.tags.push(parent.tagReference());\n      this.kind = 1234 /* DraftCheckpoint */;\n    } else {\n      this.removeTag(\"a\");\n      this.kind = 31234 /* Draft */;\n    }\n  }\n  get isCheckpoint() {\n    return this.kind === 1234 /* DraftCheckpoint */;\n  }\n  get isProposal() {\n    const pTag = this.tagValue(\"p\");\n    return !!pTag && pTag !== this.pubkey;\n  }\n  /**\n   * Gets the event.\n   * @param param0\n   * @returns NDKEvent of the draft event or null if the draft event has been deleted (emptied).\n   */\n  async getEvent(signer) {\n    if (this._event) return this._event;\n    signer ??= this.ndk?.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    if (this.content && this.content.length > 0) {\n      try {\n        const ownPubkey = signer.pubkey;\n        const pubkeys = [this.tagValue(\"p\"), this.pubkey].filter(Boolean);\n        const counterpartyPubkey = pubkeys.find((pubkey) => pubkey !== ownPubkey);\n        let user;\n        user = new NDKUser({ pubkey: counterpartyPubkey ?? ownPubkey });\n        await this.decrypt(user, signer);\n        const payload = JSON.parse(this.content);\n        this._event = await wrapEvent(new NDKEvent(this.ndk, payload));\n        return this._event;\n      } catch (e) {\n        console.error(e);\n        return void 0;\n      }\n    } else {\n      return null;\n    }\n  }\n  prepareEvent() {\n    if (!this._event) throw new Error(\"No event has been provided\");\n    this.removeTag(\"k\");\n    if (this._event.kind) this.tags.push([\"k\", this._event.kind.toString()]);\n    this.content = JSON.stringify(this._event.rawEvent());\n  }\n  /**\n   * Generates draft event.\n   *\n   * @param signer: Optional signer to encrypt with\n   * @param publish: Whether to publish, optionally specifying relaySet to publish to\n   */\n  async save({ signer, publish, relaySet }) {\n    signer ??= this.ndk?.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = this.counterparty || await signer.user();\n    await this.encrypt(user, signer);\n    if (this.counterparty) {\n      const pubkey = this.counterparty.pubkey;\n      this.removeTag(\"p\");\n      this.tags.push([\"p\", pubkey]);\n    }\n    if (publish === false) return;\n    return this.publishReplaceable(relaySet);\n  }\n};\n\n// src/events/kinds/dvm/feedback.ts\nvar NDKDvmJobFeedbackStatus = /* @__PURE__ */ ((NDKDvmJobFeedbackStatus2) => {\n  NDKDvmJobFeedbackStatus2[\"Processing\"] = \"processing\";\n  NDKDvmJobFeedbackStatus2[\"Success\"] = \"success\";\n  NDKDvmJobFeedbackStatus2[\"Scheduled\"] = \"scheduled\";\n  NDKDvmJobFeedbackStatus2[\"PayReq\"] = \"payment_required\";\n  return NDKDvmJobFeedbackStatus2;\n})(NDKDvmJobFeedbackStatus || {});\nvar NDKDVMJobFeedback = class _NDKDVMJobFeedback extends NDKEvent {\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7e3 /* DVMJobFeedback */;\n  }\n  static async from(event) {\n    const e = new _NDKDVMJobFeedback(event.ndk, event.rawEvent());\n    if (e.encrypted) await e.dvmDecrypt();\n    return e;\n  }\n  get status() {\n    return this.tagValue(\"status\");\n  }\n  set status(status) {\n    this.removeTag(\"status\");\n    if (status !== void 0) {\n      this.tags.push([\"status\", status]);\n    }\n  }\n  get encrypted() {\n    return !!this.getMatchingTags(\"encrypted\")[0];\n  }\n  async dvmDecrypt() {\n    await this.decrypt();\n    const decryptedContent = JSON.parse(this.content);\n    this.tags.push(...decryptedContent);\n  }\n};\n\n// src/events/kinds/dvm/request.ts\nvar NDKDVMRequest = class _NDKDVMRequest extends NDKEvent {\n  static from(event) {\n    return new _NDKDVMRequest(event.ndk, event.rawEvent());\n  }\n  set bid(msatAmount) {\n    if (msatAmount === void 0) {\n      this.removeTag(\"bid\");\n    } else {\n      this.tags.push([\"bid\", msatAmount.toString()]);\n    }\n  }\n  get bid() {\n    const v = this.tagValue(\"bid\");\n    if (v === void 0) return void 0;\n    return Number.parseInt(v);\n  }\n  /**\n   * Adds a new input to the job\n   * @param args The arguments to the input\n   */\n  addInput(...args) {\n    this.tags.push([\"i\", ...args]);\n  }\n  /**\n   * Adds a new parameter to the job\n   */\n  addParam(...args) {\n    this.tags.push([\"param\", ...args]);\n  }\n  set output(output) {\n    if (output === void 0) {\n      this.removeTag(\"output\");\n    } else {\n      if (typeof output === \"string\") output = [output];\n      this.tags.push([\"output\", ...output]);\n    }\n  }\n  get output() {\n    const outputTag = this.getMatchingTags(\"output\")[0];\n    return outputTag ? outputTag.slice(1) : void 0;\n  }\n  get params() {\n    const paramTags = this.getMatchingTags(\"param\");\n    return paramTags.map((t) => t.slice(1));\n  }\n  getParam(name) {\n    const paramTag = this.getMatchingTags(\"param\").find((t) => t[1] === name);\n    return paramTag ? paramTag[2] : void 0;\n  }\n  createFeedback(status) {\n    const feedback = new NDKDVMJobFeedback(this.ndk);\n    feedback.tag(this, \"job\");\n    feedback.status = status;\n    return feedback;\n  }\n  /**\n   * Enables job encryption for this event\n   * @param dvm DVM that will receive the event\n   * @param signer Signer to use for encryption\n   */\n  async encryption(dvm, signer) {\n    const dvmTags = [\"i\", \"param\", \"output\", \"relays\", \"bid\"];\n    const tags = this.tags.filter((t) => dvmTags.includes(t[0]));\n    this.tags = this.tags.filter((t) => !dvmTags.includes(t[0]));\n    this.content = JSON.stringify(tags);\n    this.tag(dvm);\n    this.tags.push([\"encrypted\"]);\n    await this.encrypt(dvm, signer);\n  }\n  /**\n   * Sets the DVM that will receive the event\n   */\n  set dvm(dvm) {\n    this.removeTag(\"p\");\n    if (dvm) this.tag(dvm);\n  }\n};\n\n// src/events/kinds/dvm/NDKTranscriptionDVM.ts\nvar NDKTranscriptionDVM = class _NDKTranscriptionDVM extends NDKDVMRequest {\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind = 5e3 /* DVMReqTextExtraction */;\n  }\n  static from(event) {\n    return new _NDKTranscriptionDVM(event.ndk, event.rawEvent());\n  }\n  /**\n   * Returns the original source of the transcription\n   */\n  get url() {\n    const inputTags = this.getMatchingTags(\"i\");\n    if (inputTags.length !== 1) {\n      return void 0;\n    }\n    return inputTags[0][1];\n  }\n  /**\n   * Getter for the title tag\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the title tag\n   */\n  set title(value) {\n    this.removeTag(\"title\");\n    if (value) {\n      this.tags.push([\"title\", value]);\n    }\n  }\n  /**\n   * Getter for the image tag\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Setter for the image tag\n   */\n  set image(value) {\n    this.removeTag(\"image\");\n    if (value) {\n      this.tags.push([\"image\", value]);\n    }\n  }\n};\n\n// src/events/kinds/dvm/result.ts\nvar NDKDVMJobResult = class _NDKDVMJobResult extends NDKEvent {\n  static from(event) {\n    return new _NDKDVMJobResult(event.ndk, event.rawEvent());\n  }\n  setAmount(msat, invoice) {\n    this.removeTag(\"amount\");\n    const tag = [\"amount\", msat.toString()];\n    if (invoice) tag.push(invoice);\n    this.tags.push(tag);\n  }\n  set result(result) {\n    if (result === void 0) {\n      this.content = \"\";\n    } else {\n      this.content = result;\n    }\n  }\n  get result() {\n    if (this.content === \"\") {\n      return void 0;\n    }\n    return this.content;\n  }\n  set status(status) {\n    this.removeTag(\"status\");\n    if (status !== void 0) {\n      this.tags.push([\"status\", status]);\n    }\n  }\n  get status() {\n    return this.tagValue(\"status\");\n  }\n  get jobRequestId() {\n    for (const eTag of this.getMatchingTags(\"e\")) {\n      if (eTag[2] === \"job\") return eTag[1];\n    }\n    if (this.jobRequest) return this.jobRequest.id;\n    return this.tagValue(\"e\");\n  }\n  set jobRequest(event) {\n    this.removeTag(\"request\");\n    if (event) {\n      this.kind = event.kind + 1e3;\n      this.tags.push([\"request\", JSON.stringify(event.rawEvent())]);\n      this.tag(event);\n    }\n  }\n  get jobRequest() {\n    const tag = this.tagValue(\"request\");\n    if (tag === void 0) {\n      return void 0;\n    }\n    return new NDKEvent(this.ndk, JSON.parse(tag));\n  }\n};\n\n// src/events/kinds/cashu/tx.ts\nvar MARKERS = {\n  REDEEMED: \"redeemed\",\n  CREATED: \"created\",\n  DESTROYED: \"destroyed\",\n  RESERVED: \"reserved\"\n};\nvar NDKCashuWalletTx = class _NDKCashuWalletTx extends NDKEvent {\n  static MARKERS = MARKERS;\n  static kind = 7376 /* CashuWalletTx */;\n  static kinds = [7376 /* CashuWalletTx */];\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7376 /* CashuWalletTx */;\n  }\n  static async from(event) {\n    const walletChange = new _NDKCashuWalletTx(event.ndk, event);\n    const prevContent = walletChange.content;\n    try {\n      await walletChange.decrypt();\n    } catch (_e) {\n      walletChange.content ??= prevContent;\n    }\n    try {\n      const contentTags = JSON.parse(walletChange.content);\n      walletChange.tags = [...contentTags, ...walletChange.tags];\n    } catch (_e) {\n      return;\n    }\n    return walletChange;\n  }\n  set direction(direction) {\n    this.removeTag(\"direction\");\n    if (direction) this.tags.push([\"direction\", direction]);\n  }\n  get direction() {\n    return this.tagValue(\"direction\");\n  }\n  set amount(amount) {\n    this.removeTag(\"amount\");\n    this.tags.push([\"amount\", amount.toString()]);\n  }\n  get amount() {\n    const val = this.tagValue(\"amount\");\n    if (val === void 0) return void 0;\n    return Number(val);\n  }\n  set fee(fee) {\n    this.removeTag(\"fee\");\n    this.tags.push([\"fee\", fee.toString()]);\n  }\n  get fee() {\n    const val = this.tagValue(\"fee\");\n    if (val === void 0) return void 0;\n    return Number(val);\n  }\n  set unit(unit) {\n    this.removeTag(\"unit\");\n    if (unit) this.tags.push([\"unit\", unit.toString()]);\n  }\n  get unit() {\n    return this.tagValue(\"unit\");\n  }\n  set description(description) {\n    this.removeTag(\"description\");\n    if (description) this.tags.push([\"description\", description.toString()]);\n  }\n  get description() {\n    return this.tagValue(\"description\");\n  }\n  set mint(mint) {\n    this.removeTag(\"mint\");\n    if (mint) this.tags.push([\"mint\", mint.toString()]);\n  }\n  get mint() {\n    return this.tagValue(\"mint\");\n  }\n  /**\n   * Tags tokens that were created in this history event\n   */\n  set destroyedTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.DESTROYED));\n    }\n  }\n  set destroyedTokenIds(ids) {\n    for (const id of ids) {\n      this.tags.push([\"e\", id, \"\", MARKERS.DESTROYED]);\n    }\n  }\n  /**\n   * Tags tokens that were created in this history event\n   */\n  set createdTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.CREATED));\n    }\n  }\n  set reservedTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.RESERVED));\n    }\n  }\n  addRedeemedNutzap(event) {\n    this.tag(event, MARKERS.REDEEMED);\n  }\n  async toNostrEvent(pubkey) {\n    const encryptedTags = [];\n    const unencryptedTags = [];\n    for (const tag of this.tags) {\n      if (!this.shouldEncryptTag(tag)) {\n        unencryptedTags.push(tag);\n      } else {\n        encryptedTags.push(tag);\n      }\n    }\n    this.tags = unencryptedTags.filter((t) => t[0] !== \"client\");\n    this.content = JSON.stringify(encryptedTags);\n    const user = await this.ndk?.signer?.user();\n    if (user) {\n      const ownPubkey = user.pubkey;\n      this.tags = this.tags.filter((t) => t[0] !== \"p\" || t[1] !== ownPubkey);\n    }\n    await this.encrypt(user, void 0, \"nip44\");\n    return super.toNostrEvent(pubkey);\n  }\n  /**\n   * Whether this entry includes a redemption of a Nutzap\n   */\n  get hasNutzapRedemption() {\n    return this.getMatchingTags(\"e\", MARKERS.REDEEMED).length > 0;\n  }\n  shouldEncryptTag(tag) {\n    const unencryptedTagNames = [\"client\"];\n    if (unencryptedTagNames.includes(tag[0])) {\n      return false;\n    }\n    if (tag[0] === \"e\" && tag[3] === MARKERS.REDEEMED) {\n      return false;\n    }\n    if (tag[0] === \"p\") return false;\n    return true;\n  }\n};\n\n// src/events/kinds/NDKRelayList.ts\nvar READ_MARKER = \"read\";\nvar WRITE_MARKER = \"write\";\nvar NDKRelayList = class _NDKRelayList extends NDKEvent {\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 10002 /* RelayList */;\n  }\n  static from(ndkEvent) {\n    return new _NDKRelayList(ndkEvent.ndk, ndkEvent.rawEvent());\n  }\n  get readRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2] || tag[2] && tag[2] === READ_MARKER).map((tag) => tryNormalizeRelayUrl(tag[1])).filter((url) => !!url);\n  }\n  set readRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay, READ_MARKER]);\n    }\n  }\n  get writeRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2] || tag[2] && tag[2] === WRITE_MARKER).map((tag) => tryNormalizeRelayUrl(tag[1])).filter((url) => !!url);\n  }\n  set writeRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay, WRITE_MARKER]);\n    }\n  }\n  get bothRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2]).map((tag) => tag[1]);\n  }\n  set bothRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay]);\n    }\n  }\n  get relays() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").map((tag) => tag[1]);\n  }\n  /**\n   * Provides a relaySet for the relays in this list.\n   */\n  get relaySet() {\n    if (!this.ndk) throw new Error(\"NDKRelayList has no NDK instance\");\n    return new NDKRelaySet(\n      new Set(this.relays.map((u) => this.ndk?.pool.getRelay(u)).filter((r) => !!r)),\n      this.ndk\n    );\n  }\n};\nfunction relayListFromKind3(ndk, contactList) {\n  try {\n    const content = JSON.parse(contactList.content);\n    const relayList = new NDKRelayList(ndk);\n    const readRelays = /* @__PURE__ */ new Set();\n    const writeRelays = /* @__PURE__ */ new Set();\n    for (let [key, config] of Object.entries(content)) {\n      try {\n        key = normalizeRelayUrl(key);\n      } catch {\n        continue;\n      }\n      if (!config) {\n        readRelays.add(key);\n        writeRelays.add(key);\n      } else {\n        const relayConfig = config;\n        if (relayConfig.write) writeRelays.add(key);\n        if (relayConfig.read) readRelays.add(key);\n      }\n    }\n    relayList.readRelayUrls = Array.from(readRelays);\n    relayList.writeRelayUrls = Array.from(writeRelays);\n    return relayList;\n  } catch {\n  }\n  return void 0;\n}\n\n// src/events/kinds/nip89/app-handler.ts\nvar NDKAppHandlerEvent = class _NDKAppHandlerEvent extends NDKEvent {\n  profile;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 31990 /* AppHandler */;\n  }\n  static from(ndkEvent) {\n    const event = new _NDKAppHandlerEvent(ndkEvent.ndk, ndkEvent.rawEvent());\n    if (event.isValid) {\n      return event;\n    }\n    return null;\n  }\n  get isValid() {\n    const combinations = /* @__PURE__ */ new Map();\n    const combinationFromTag = (tag) => [tag[0], tag[2]].join(\":\").toLowerCase();\n    const tagsToInspect = [\"web\", \"android\", \"ios\"];\n    for (const tag of this.tags) {\n      if (tagsToInspect.includes(tag[0])) {\n        const combination = combinationFromTag(tag);\n        if (combinations.has(combination)) {\n          if (combinations.get(combination) !== tag[1].toLowerCase()) {\n            return false;\n          }\n        }\n        combinations.set(combination, tag[1].toLowerCase());\n      }\n    }\n    return true;\n  }\n  /**\n   * Fetches app handler information\n   * If no app information is available on the kind:31990,\n   * we fetch the event's author's profile and return that instead.\n   */\n  async fetchProfile() {\n    if (this.profile === void 0 && this.content.length > 0) {\n      try {\n        const profile = JSON.parse(this.content);\n        if (profile?.name) {\n          return profile;\n        }\n        this.profile = null;\n      } catch (_e) {\n        this.profile = null;\n      }\n    }\n    return new Promise((resolve, reject) => {\n      const author = this.author;\n      author.fetchProfile().then(() => {\n        resolve(author.profile);\n      }).catch(reject);\n    });\n  }\n};\n\n// src/events/kinds/repost.ts\nvar NDKRepost = class _NDKRepost extends NDKEvent {\n  _repostedEvents;\n  static from(event) {\n    return new _NDKRepost(event.ndk, event.rawEvent());\n  }\n  /**\n   * Returns all reposted events by the current event.\n   *\n   * @param klass Optional class to convert the events to.\n   * @returns\n   */\n  async repostedEvents(klass, opts) {\n    const items = [];\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (this._repostedEvents !== void 0) return this._repostedEvents;\n    for (const eventId of this.repostedEventIds()) {\n      const filter = filterForId(eventId);\n      const event = await this.ndk.fetchEvent(filter, opts);\n      if (event) {\n        items.push(klass ? klass.from(event) : event);\n      }\n    }\n    return items;\n  }\n  /**\n   * Returns the reposted event IDs.\n   */\n  repostedEventIds() {\n    return this.tags.filter((t) => t[0] === \"e\" || t[0] === \"a\").map((t) => t[1]);\n  }\n};\nfunction filterForId(id) {\n  if (id.match(/:/)) {\n    const [kind, pubkey, identifier] = id.split(\":\");\n    return {\n      kinds: [Number.parseInt(kind)],\n      authors: [pubkey],\n      \"#d\": [identifier]\n    };\n  }\n  return { ids: [id] };\n}\n\n// src/events/kinds/subscriptions/receipt.ts\n\nvar NDKSubscriptionReceipt = class _NDKSubscriptionReceipt extends NDKEvent {\n  debug;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 7003 /* SubscriptionReceipt */;\n    this.debug = ndk?.debug.extend(\"subscription-start\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:subscription-start\");\n  }\n  static from(event) {\n    return new _NDKSubscriptionReceipt(event.ndk, event.rawEvent());\n  }\n  /**\n   * This is the person being subscribed to\n   */\n  get recipient() {\n    const pTag = this.getMatchingTags(\"p\")?.[0];\n    if (!pTag) return void 0;\n    const user = new NDKUser({ pubkey: pTag[1] });\n    return user;\n  }\n  set recipient(user) {\n    this.removeTag(\"p\");\n    if (!user) return;\n    this.tags.push([\"p\", user.pubkey]);\n  }\n  /**\n   * This is the person subscribing\n   */\n  get subscriber() {\n    const PTag = this.getMatchingTags(\"P\")?.[0];\n    if (!PTag) return void 0;\n    const user = new NDKUser({ pubkey: PTag[1] });\n    return user;\n  }\n  set subscriber(user) {\n    this.removeTag(\"P\");\n    if (!user) return;\n    this.tags.push([\"P\", user.pubkey]);\n  }\n  set subscriptionStart(event) {\n    this.debug(`before setting subscription start: ${this.rawEvent}`);\n    this.removeTag(\"e\");\n    this.tag(event, \"subscription\", true);\n    this.debug(`after setting subscription start: ${this.rawEvent}`);\n  }\n  get tierName() {\n    const tag = this.getMatchingTags(\"tier\")?.[0];\n    return tag?.[1];\n  }\n  get isValid() {\n    const period = this.validPeriod;\n    if (!period) {\n      return false;\n    }\n    if (period.start > period.end) {\n      return false;\n    }\n    const pTags = this.getMatchingTags(\"p\");\n    const PTags = this.getMatchingTags(\"P\");\n    if (pTags.length !== 1 || PTags.length !== 1) {\n      return false;\n    }\n    return true;\n  }\n  get validPeriod() {\n    const tag = this.getMatchingTags(\"valid\")?.[0];\n    if (!tag) return void 0;\n    try {\n      return {\n        start: new Date(Number.parseInt(tag[1]) * 1e3),\n        end: new Date(Number.parseInt(tag[2]) * 1e3)\n      };\n    } catch {\n      return void 0;\n    }\n  }\n  set validPeriod(period) {\n    this.removeTag(\"valid\");\n    if (!period) return;\n    this.tags.push([\n      \"valid\",\n      Math.floor(period.start.getTime() / 1e3).toString(),\n      Math.floor(period.end.getTime() / 1e3).toString()\n    ]);\n  }\n  get startPeriod() {\n    return this.validPeriod?.start;\n  }\n  get endPeriod() {\n    return this.validPeriod?.end;\n  }\n  /**\n   * Whether the subscription is currently active\n   */\n  isActive(time) {\n    time ??= /* @__PURE__ */ new Date();\n    const period = this.validPeriod;\n    if (!period) return false;\n    if (time < period.start) return false;\n    if (time > period.end) return false;\n    return true;\n  }\n};\n\n// src/events/kinds/subscriptions/subscription-start.ts\n\nvar NDKSubscriptionStart = class _NDKSubscriptionStart extends NDKEvent {\n  debug;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 7001 /* Subscribe */;\n    this.debug = ndk?.debug.extend(\"subscription-start\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:subscription-start\");\n  }\n  static from(event) {\n    return new _NDKSubscriptionStart(event.ndk, event.rawEvent());\n  }\n  /**\n   * Recipient of the subscription. I.e. The author of this event subscribes to this user.\n   */\n  get recipient() {\n    const pTag = this.getMatchingTags(\"p\")?.[0];\n    if (!pTag) return void 0;\n    const user = new NDKUser({ pubkey: pTag[1] });\n    return user;\n  }\n  set recipient(user) {\n    this.removeTag(\"p\");\n    if (!user) return;\n    this.tags.push([\"p\", user.pubkey]);\n  }\n  /**\n   * The amount of the subscription.\n   */\n  get amount() {\n    const amountTag = this.getMatchingTags(\"amount\")?.[0];\n    if (!amountTag) return void 0;\n    return parseTagToSubscriptionAmount(amountTag);\n  }\n  set amount(amount) {\n    this.removeTag(\"amount\");\n    if (!amount) return;\n    this.tags.push(newAmount(amount.amount, amount.currency, amount.term));\n  }\n  /**\n   * The event id or NIP-33 tag id of the tier that the user is subscribing to.\n   */\n  get tierId() {\n    const eTag = this.getMatchingTags(\"e\")?.[0];\n    const aTag = this.getMatchingTags(\"a\")?.[0];\n    if (!eTag || !aTag) return void 0;\n    return eTag[1] ?? aTag[1];\n  }\n  set tier(tier) {\n    this.removeTag(\"e\");\n    this.removeTag(\"a\");\n    this.removeTag(\"event\");\n    if (!tier) return;\n    this.tag(tier);\n    this.removeTag(\"p\");\n    this.tags.push([\"p\", tier.pubkey]);\n    this.tags.push([\"event\", JSON.stringify(tier.rawEvent())]);\n  }\n  /**\n   * Fetches the tier that the user is subscribing to.\n   */\n  async fetchTier() {\n    const eventTag = this.tagValue(\"event\");\n    if (eventTag) {\n      try {\n        const parsedEvent = JSON.parse(eventTag);\n        return new NDKSubscriptionTier(this.ndk, parsedEvent);\n      } catch {\n        this.debug(\"Failed to parse event tag\");\n      }\n    }\n    const tierId = this.tierId;\n    if (!tierId) return void 0;\n    const e = await this.ndk?.fetchEvent(tierId);\n    if (!e) return void 0;\n    return NDKSubscriptionTier.from(e);\n  }\n  get isValid() {\n    if (this.getMatchingTags(\"amount\").length !== 1) {\n      this.debug(\"Invalid # of amount tag\");\n      return false;\n    }\n    if (!this.amount) {\n      this.debug(\"Invalid amount tag\");\n      return false;\n    }\n    if (this.getMatchingTags(\"p\").length !== 1) {\n      this.debug(\"Invalid # of p tag\");\n      return false;\n    }\n    if (!this.recipient) {\n      this.debug(\"Invalid p tag\");\n      return false;\n    }\n    return true;\n  }\n};\n\n// src/events/gift-wrapping.ts\n\n\n// src/signers/private-key/index.ts\n\n\n\n\n// src/signers/registry.ts\nvar signerRegistry = /* @__PURE__ */ new Map();\nfunction registerSigner(type, signerClass) {\n  signerRegistry.set(type, signerClass);\n}\n\n// src/signers/private-key/index.ts\nvar NDKPrivateKeySigner = class _NDKPrivateKeySigner {\n  _user;\n  _privateKey;\n  _pubkey;\n  /**\n   * Create a new signer from a private key.\n   * @param privateKey - The private key to use in hex form or nsec.\n   * @param ndk - The NDK instance to use.\n   */\n  constructor(privateKeyOrNsec, ndk) {\n    if (typeof privateKeyOrNsec === \"string\") {\n      if (privateKeyOrNsec.startsWith(\"nsec1\")) {\n        const { type, data } = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(privateKeyOrNsec);\n        if (type === \"nsec\") this._privateKey = data;\n        else throw new Error(\"Invalid private key provided.\");\n      } else if (privateKeyOrNsec.length === 64) {\n        this._privateKey = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(privateKeyOrNsec);\n      } else {\n        throw new Error(\"Invalid private key provided.\");\n      }\n    } else {\n      this._privateKey = privateKeyOrNsec;\n    }\n    this._pubkey = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.getPublicKey)(this._privateKey);\n    if (ndk) this._user = ndk.getUser({ pubkey: this._pubkey });\n    this._user ??= new NDKUser({ pubkey: this._pubkey });\n  }\n  /**\n   * Get the private key in hex form.\n   */\n  get privateKey() {\n    if (!this._privateKey) throw new Error(\"Not ready\");\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(this._privateKey);\n  }\n  /**\n   * Get the public key in hex form.\n   */\n  get pubkey() {\n    if (!this._pubkey) throw new Error(\"Not ready\");\n    return this._pubkey;\n  }\n  /**\n   * Get the private key in nsec form.\n   */\n  get nsec() {\n    if (!this._privateKey) throw new Error(\"Not ready\");\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.nsecEncode(this._privateKey);\n  }\n  /**\n   * Get the public key in npub form.\n   */\n  get npub() {\n    if (!this._pubkey) throw new Error(\"Not ready\");\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.npubEncode(this._pubkey);\n  }\n  /**\n   * Generate a new private key.\n   */\n  static generate() {\n    const privateKey = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.generateSecretKey)();\n    return new _NDKPrivateKeySigner(privateKey);\n  }\n  /**\n   * Noop in NDKPrivateKeySigner.\n   */\n  async blockUntilReady() {\n    return this._user;\n  }\n  /**\n   * Get the user.\n   */\n  async user() {\n    return this._user;\n  }\n  /**\n   * Get the user.\n   */\n  get userSync() {\n    return this._user;\n  }\n  async sign(event) {\n    if (!this._privateKey) {\n      throw Error(\"Attempted to sign without a private key\");\n    }\n    return (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(event, this._privateKey).sig;\n  }\n  async encryptionEnabled(scheme) {\n    const enabled = [];\n    if (!scheme || scheme === \"nip04\") enabled.push(\"nip04\");\n    if (!scheme || scheme === \"nip44\") enabled.push(\"nip44\");\n    return enabled;\n  }\n  async encrypt(recipient, value, scheme) {\n    if (!this._privateKey || !this.privateKey) {\n      throw Error(\"Attempted to encrypt without a private key\");\n    }\n    const recipientHexPubKey = recipient.pubkey;\n    if (scheme === \"nip44\") {\n      const conversationKey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.utils.getConversationKey(this._privateKey, recipientHexPubKey);\n      return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.encrypt(value, conversationKey);\n    }\n    return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip04.encrypt(this._privateKey, recipientHexPubKey, value);\n  }\n  async decrypt(sender, value, scheme) {\n    if (!this._privateKey || !this.privateKey) {\n      throw Error(\"Attempted to decrypt without a private key\");\n    }\n    const senderHexPubKey = sender.pubkey;\n    if (scheme === \"nip44\") {\n      const conversationKey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.utils.getConversationKey(this._privateKey, senderHexPubKey);\n      return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.decrypt(value, conversationKey);\n    }\n    return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip04.decrypt(this._privateKey, senderHexPubKey, value);\n  }\n  /**\n   * Serializes the signer's private key into a storable format.\n   * @returns A JSON string containing the type and the hex private key.\n   */\n  toPayload() {\n    if (!this._privateKey) throw new Error(\"Private key not available\");\n    const payload = {\n      type: \"private-key\",\n      payload: this.privateKey\n      // Use the hex private key\n    };\n    return JSON.stringify(payload);\n  }\n  /**\n   * Deserializes the signer from a payload string.\n   * @param payloadString The JSON string obtained from toPayload().\n   * @param ndk Optional NDK instance.\n   * @returns An instance of NDKPrivateKeySigner.\n   */\n  static async fromPayload(payloadString, ndk) {\n    const payload = JSON.parse(payloadString);\n    if (payload.type !== \"private-key\") {\n      throw new Error(`Invalid payload type: expected 'private-key', got ${payload.type}`);\n    }\n    if (!payload.payload || typeof payload.payload !== \"string\") {\n      throw new Error(\"Invalid payload content for private-key signer\");\n    }\n    return new _NDKPrivateKeySigner(payload.payload, ndk);\n  }\n};\nregisterSigner(\"private-key\", NDKPrivateKeySigner);\n\n// src/events/gift-wrapping.ts\nasync function giftWrap(event, recipient, signer, params = {}) {\n  let _signer = signer;\n  params.scheme ??= \"nip44\";\n  if (!_signer) {\n    if (!event.ndk) throw new Error(\"no signer available for giftWrap\");\n    _signer = event.ndk.signer;\n  }\n  if (!_signer) throw new Error(\"no signer\");\n  if (!_signer.encryptionEnabled || !_signer.encryptionEnabled(params.scheme))\n    throw new Error(\"signer is not able to giftWrap\");\n  const rumor = getRumorEvent(event, params?.rumorKind);\n  const seal = await getSealEvent(rumor, recipient, _signer, params.scheme);\n  const wrap = await getWrapEvent(seal, recipient, params);\n  return new NDKEvent(event.ndk, wrap);\n}\nasync function giftUnwrap(event, sender, signer, scheme = \"nip44\") {\n  const _sender = sender || new NDKUser({ pubkey: event.pubkey });\n  let _signer = signer;\n  if (!_signer) {\n    if (!event.ndk) throw new Error(\"no signer available for giftUnwrap\");\n    _signer = event.ndk.signer;\n  }\n  if (!signer) throw new Error(\"no signer\");\n  try {\n    const seal = JSON.parse(await signer.decrypt(_sender, event.content, scheme));\n    if (!seal) throw new Error(\"Failed to decrypt wrapper\");\n    if (!new NDKEvent(void 0, seal).verifySignature(false))\n      throw new Error(\"GiftSeal signature verification failed!\");\n    const rumorSender = new NDKUser({ pubkey: seal.pubkey });\n    const rumor = JSON.parse(await signer.decrypt(rumorSender, seal.content, scheme));\n    if (!rumor) throw new Error(\"Failed to decrypt seal\");\n    if (rumor.pubkey !== seal.pubkey) throw new Error(\"Invalid GiftWrap, sender validation failed!\");\n    return new NDKEvent(event.ndk, rumor);\n  } catch (_e) {\n    return Promise.reject(\"Got error unwrapping event! See console log.\");\n  }\n}\nfunction getRumorEvent(event, kind) {\n  const rumor = event.rawEvent();\n  rumor.kind = kind || rumor.kind || 14 /* PrivateDirectMessage */;\n  rumor.sig = void 0;\n  rumor.id = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.getEventHash)(rumor);\n  return new NDKEvent(event.ndk, rumor);\n}\nasync function getSealEvent(rumor, recipient, signer, scheme = \"nip44\") {\n  const seal = new NDKEvent(rumor.ndk);\n  seal.kind = 13 /* GiftWrapSeal */;\n  seal.created_at = approximateNow(5);\n  seal.content = JSON.stringify(rumor.rawEvent());\n  await seal.encrypt(recipient, signer, scheme);\n  await seal.sign(signer);\n  return seal;\n}\nasync function getWrapEvent(sealed, recipient, params, scheme = \"nip44\") {\n  const signer = NDKPrivateKeySigner.generate();\n  const wrap = new NDKEvent(sealed.ndk);\n  wrap.kind = 1059 /* GiftWrap */;\n  wrap.created_at = approximateNow(5);\n  if (params?.wrapTags) wrap.tags = params.wrapTags;\n  wrap.tag(recipient);\n  wrap.content = JSON.stringify(sealed.rawEvent());\n  await wrap.encrypt(recipient, signer, scheme);\n  await wrap.sign(signer);\n  return wrap;\n}\nfunction approximateNow(drift = 0) {\n  return Math.round(Date.now() / 1e3 - Math.random() * 10 ** drift);\n}\n\n// src/events/kinds/simple-group/index.ts\nvar NDKSimpleGroup = class _NDKSimpleGroup {\n  ndk;\n  groupId;\n  relaySet;\n  fetchingMetadata;\n  metadata;\n  memberList;\n  adminList;\n  constructor(ndk, relaySet, groupId) {\n    this.ndk = ndk;\n    this.groupId = groupId ?? randomId(24);\n    this.relaySet = relaySet;\n  }\n  get id() {\n    return this.groupId;\n  }\n  relayUrls() {\n    return this.relaySet?.relayUrls;\n  }\n  get name() {\n    return this.metadata?.name;\n  }\n  get about() {\n    return this.metadata?.about;\n  }\n  get picture() {\n    return this.metadata?.picture;\n  }\n  get members() {\n    return this.memberList?.members ?? [];\n  }\n  get admins() {\n    return this.adminList?.members ?? [];\n  }\n  async getMetadata() {\n    await this.ensureMetadataEvent();\n    return this.metadata;\n  }\n  /**\n   * Creates the group by publishing a kind:9007 event.\n   * @param signer\n   * @returns\n   */\n  async createGroup(signer) {\n    signer ??= this.ndk.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    if (!user) throw new Error(\"No user available\");\n    const event = new NDKEvent(this.ndk);\n    event.kind = 9007 /* GroupAdminCreateGroup */;\n    event.tags.push([\"h\", this.groupId]);\n    await event.sign(signer);\n    return event.publish(this.relaySet);\n  }\n  async setMetadata({ name, about, picture }) {\n    const event = new NDKEvent(this.ndk);\n    event.kind = 9002 /* GroupAdminEditMetadata */;\n    event.tags.push([\"h\", this.groupId]);\n    if (name) event.tags.push([\"name\", name]);\n    if (about) event.tags.push([\"about\", about]);\n    if (picture) event.tags.push([\"picture\", picture]);\n    await event.sign();\n    return event.publish(this.relaySet);\n  }\n  /**\n   * Adds a user to the group using a kind:9000 event\n   * @param user user to add\n   * @param opts options\n   */\n  async addUser(user) {\n    const addUserEvent = _NDKSimpleGroup.generateAddUserEvent(user.pubkey, this.groupId);\n    addUserEvent.ndk = this.ndk;\n    return addUserEvent;\n  }\n  async getMemberListEvent() {\n    const memberList = await this.ndk.fetchEvent(\n      {\n        kinds: [39002 /* GroupMembers */],\n        \"#d\": [this.groupId]\n      },\n      void 0,\n      this.relaySet\n    );\n    if (!memberList) return null;\n    return NDKSimpleGroupMemberList.from(memberList);\n  }\n  /**\n   * Gets a list of users that belong to this group\n   */\n  async getMembers() {\n    const members = [];\n    const memberPubkeys = /* @__PURE__ */ new Set();\n    const memberListEvent = await this.getMemberListEvent();\n    if (!memberListEvent) return [];\n    for (const pTag of memberListEvent.getMatchingTags(\"p\")) {\n      const pubkey = pTag[1];\n      if (memberPubkeys.has(pubkey)) continue;\n      memberPubkeys.add(pubkey);\n      try {\n        members.push(this.ndk.getUser({ pubkey }));\n      } catch {\n      }\n    }\n    return members;\n  }\n  /**\n   * Generates an event that lists the members of a group.\n   * @param groupId\n   * @returns\n   */\n  static generateUserListEvent(groupId) {\n    const event = new NDKEvent(void 0, {\n      kind: 39002 /* GroupMembers */,\n      tags: [\n        [\"h\", groupId],\n        [\"alt\", \"Group Member List\"]\n      ]\n    });\n    return event;\n  }\n  /**\n   * Generates an event that adds a user to a group.\n   * @param userPubkey pubkey of the user to add\n   * @param groupId group to add the user to\n   * @returns\n   */\n  static generateAddUserEvent(userPubkey, groupId) {\n    const event = new NDKEvent(void 0, {\n      kind: 9e3 /* GroupAdminAddUser */,\n      tags: [[\"h\", groupId]]\n    });\n    event.tags.push([\"p\", userPubkey]);\n    return event;\n  }\n  async requestToJoin(_pubkey, content) {\n    const event = new NDKEvent(this.ndk, {\n      kind: 9021 /* GroupAdminRequestJoin */,\n      content: content ?? \"\",\n      tags: [[\"h\", this.groupId]]\n    });\n    return event.publish(this.relaySet);\n  }\n  /**\n   * Makes sure that a metadata event exists locally\n   */\n  async ensureMetadataEvent() {\n    if (this.metadata) return;\n    if (this.fetchingMetadata) return this.fetchingMetadata;\n    this.fetchingMetadata = this.ndk.fetchEvent(\n      {\n        kinds: [39e3 /* GroupMetadata */],\n        \"#d\": [this.groupId]\n      },\n      void 0,\n      this.relaySet\n    ).then((event) => {\n      if (event) {\n        this.metadata = NDKSimpleGroupMetadata.from(event);\n      } else {\n        this.metadata = new NDKSimpleGroupMetadata(this.ndk);\n        this.metadata.dTag = this.groupId;\n      }\n    }).finally(() => {\n      this.fetchingMetadata = void 0;\n    }).catch(() => {\n      throw new Error(`Failed to fetch metadata for group ${this.groupId}`);\n    });\n    return this.fetchingMetadata;\n  }\n};\nfunction randomId(length) {\n  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  const charsLength = chars.length;\n  let result = \"\";\n  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * charsLength));\n  }\n  return result;\n}\n\n// src/app-settings/index.ts\nvar NDKAppSettings = class _NDKAppSettings extends NDKEvent {\n  appName;\n  settings = {};\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30078 /* AppSpecificData */;\n    this.dTag ??= this.appName;\n    if (this.content.length > 0) {\n      try {\n        this.settings = JSON.parse(this.content);\n      } catch (error) {\n        console.error(\"Error parsing app settings\", error);\n      }\n    }\n  }\n  static from(event) {\n    return new _NDKAppSettings(event.ndk, event);\n  }\n  /**\n   * Set a value for a given key.\n   *\n   * @param key\n   * @param value\n   */\n  set(key, value) {\n    this.settings[key] = value;\n  }\n  /**\n   * Get a value for a given key.\n   *\n   * @param key\n   * @returns\n   */\n  get(key) {\n    return this.settings[key];\n  }\n  async publishReplaceable(relaySet, timeoutMs, requiredRelayCount) {\n    this.content = JSON.stringify(this.settings);\n    return super.publishReplaceable(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/relay/auth-policies.ts\n\nfunction disconnect(pool, debug9) {\n  debug9 ??= debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:relay:auth-policies:disconnect\");\n  return async (relay) => {\n    debug9?.(`Relay ${relay.url} requested authentication, disconnecting`);\n    pool.removeRelay(relay.url);\n  };\n}\nasync function signAndAuth(event, relay, signer, debug9, resolve, reject) {\n  try {\n    await event.sign(signer);\n    resolve(event);\n  } catch (e) {\n    debug9?.(`Failed to publish auth event to relay ${relay.url}`, e);\n    reject(event);\n  }\n}\nfunction signIn({ ndk, signer, debug: debug9 } = {}) {\n  debug9 ??= debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:auth-policies:signIn\");\n  return async (relay, challenge) => {\n    debug9?.(`Relay ${relay.url} requested authentication, signing in`);\n    const event = new NDKEvent(ndk);\n    event.kind = 22242 /* ClientAuth */;\n    event.tags = [\n      [\"relay\", relay.url],\n      [\"challenge\", challenge]\n    ];\n    signer ??= ndk?.signer;\n    return new Promise(async (resolve, reject) => {\n      if (signer) {\n        await signAndAuth(event, relay, signer, debug9, resolve, reject);\n      } else {\n        ndk?.once(\"signer:ready\", async (signer2) => {\n          await signAndAuth(event, relay, signer2, debug9, resolve, reject);\n        });\n      }\n    });\n  };\n}\nvar NDKRelayAuthPolicies = {\n  disconnect,\n  signIn\n};\n\n// src/signers/nip07/index.ts\n\nvar NDKNip07Signer = class _NDKNip07Signer {\n  _userPromise;\n  encryptionQueue = [];\n  encryptionProcessing = false;\n  debug;\n  waitTimeout;\n  _pubkey;\n  ndk;\n  _user;\n  /**\n   * @param waitTimeout - The timeout in milliseconds to wait for the NIP-07 to become available\n   */\n  constructor(waitTimeout = 1e3, ndk) {\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:nip07\");\n    this.waitTimeout = waitTimeout;\n    this.ndk = ndk;\n  }\n  get pubkey() {\n    if (!this._pubkey) throw new Error(\"Not ready\");\n    return this._pubkey;\n  }\n  async blockUntilReady() {\n    await this.waitForExtension();\n    const pubkey = await window.nostr?.getPublicKey();\n    if (!pubkey) {\n      throw new Error(\"User rejected access\");\n    }\n    this._pubkey = pubkey;\n    let user;\n    if (this.ndk) user = this.ndk.getUser({ pubkey });\n    else user = new NDKUser({ pubkey });\n    this._user = user;\n    return user;\n  }\n  /**\n   * Getter for the user property.\n   * @returns The NDKUser instance.\n   */\n  async user() {\n    if (!this._userPromise) {\n      this._userPromise = this.blockUntilReady();\n    }\n    return this._userPromise;\n  }\n  get userSync() {\n    if (!this._user) throw new Error(\"User not ready\");\n    return this._user;\n  }\n  /**\n   * Signs the given Nostr event.\n   * @param event - The Nostr event to be signed.\n   * @returns The signature of the signed event.\n   * @throws Error if the NIP-07 is not available on the window object.\n   */\n  async sign(event) {\n    await this.waitForExtension();\n    const signedEvent = await window.nostr?.signEvent(event);\n    if (!signedEvent) throw new Error(\"Failed to sign event\");\n    return signedEvent.sig;\n  }\n  async relays(ndk) {\n    await this.waitForExtension();\n    const relays = await window.nostr?.getRelays?.() || {};\n    const activeRelays = [];\n    for (const url of Object.keys(relays)) {\n      if (relays[url].read && relays[url].write) {\n        activeRelays.push(url);\n      }\n    }\n    return activeRelays.map((url) => new NDKRelay(url, ndk?.relayAuthDefaultPolicy, ndk));\n  }\n  async encryptionEnabled(nip) {\n    const enabled = [];\n    if ((!nip || nip === \"nip04\") && Boolean(window.nostr?.nip04)) enabled.push(\"nip04\");\n    if ((!nip || nip === \"nip44\") && Boolean(window.nostr?.nip44)) enabled.push(\"nip44\");\n    return enabled;\n  }\n  async encrypt(recipient, value, nip = \"nip04\") {\n    if (!await this.encryptionEnabled(nip))\n      throw new Error(`${nip}encryption is not available from your browser extension`);\n    await this.waitForExtension();\n    const recipientHexPubKey = recipient.pubkey;\n    return this.queueEncryption(nip, \"encrypt\", recipientHexPubKey, value);\n  }\n  async decrypt(sender, value, nip = \"nip04\") {\n    if (!await this.encryptionEnabled(nip))\n      throw new Error(`${nip}encryption is not available from your browser extension`);\n    await this.waitForExtension();\n    const senderHexPubKey = sender.pubkey;\n    return this.queueEncryption(nip, \"decrypt\", senderHexPubKey, value);\n  }\n  async queueEncryption(scheme, method, counterpartyHexpubkey, value) {\n    return new Promise((resolve, reject) => {\n      this.encryptionQueue.push({\n        scheme,\n        method,\n        counterpartyHexpubkey,\n        value,\n        resolve,\n        reject\n      });\n      if (!this.encryptionProcessing) {\n        this.processEncryptionQueue();\n      }\n    });\n  }\n  async processEncryptionQueue(item, retries = 0) {\n    if (!item && this.encryptionQueue.length === 0) {\n      this.encryptionProcessing = false;\n      return;\n    }\n    this.encryptionProcessing = true;\n    const currentItem = item || this.encryptionQueue.shift();\n    if (!currentItem) {\n      this.encryptionProcessing = false;\n      return;\n    }\n    const { scheme, method, counterpartyHexpubkey, value, resolve, reject } = currentItem;\n    this.debug(\"Processing encryption queue item\", {\n      method,\n      counterpartyHexpubkey,\n      value\n    });\n    try {\n      const result = await window.nostr?.[scheme]?.[method](counterpartyHexpubkey, value);\n      if (!result) throw new Error(\"Failed to encrypt/decrypt\");\n      resolve(result);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      if (errorMessage.includes(\"call already executing\") && retries < 5) {\n        this.debug(\"Retrying encryption queue item\", {\n          method,\n          counterpartyHexpubkey,\n          value,\n          retries\n        });\n        setTimeout(() => {\n          this.processEncryptionQueue(currentItem, retries + 1);\n        }, 50 * retries);\n        return;\n      }\n      reject(error instanceof Error ? error : new Error(errorMessage));\n    }\n    this.processEncryptionQueue();\n  }\n  waitForExtension() {\n    return new Promise((resolve, reject) => {\n      if (window.nostr) {\n        resolve();\n        return;\n      }\n      let timerId;\n      const intervalId = setInterval(() => {\n        if (window.nostr) {\n          clearTimeout(timerId);\n          clearInterval(intervalId);\n          resolve();\n        }\n      }, 100);\n      timerId = setTimeout(() => {\n        clearInterval(intervalId);\n        reject(new Error(\"NIP-07 extension not available\"));\n      }, this.waitTimeout);\n    });\n  }\n  /**\n   * Serializes the signer type into a storable format.\n   * NIP-07 signers don't have persistent state to serialize beyond their type.\n   * @returns A JSON string containing the type.\n   */\n  toPayload() {\n    const payload = {\n      type: \"nip07\",\n      payload: \"\"\n      // No specific payload needed for NIP-07\n    };\n    return JSON.stringify(payload);\n  }\n  /**\n   * Deserializes the signer from a payload string.\n   * Creates a new NDKNip07Signer instance.\n   * @param payloadString The JSON string obtained from toPayload().\n   * @param ndk Optional NDK instance.\n   * @returns An instance of NDKNip07Signer.\n   */\n  static async fromPayload(payloadString, ndk) {\n    const payload = JSON.parse(payloadString);\n    if (payload.type !== \"nip07\") {\n      throw new Error(`Invalid payload type: expected 'nip07', got ${payload.type}`);\n    }\n    return new _NDKNip07Signer(void 0, ndk);\n  }\n};\nregisterSigner(\"nip07\", NDKNip07Signer);\n\n// src/signers/nip46/backend/index.ts\n\n\n// src/signers/nip46/rpc.ts\n\nvar NDKNostrRpc = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  signer;\n  relaySet;\n  debug;\n  encryptionType = \"nip04\";\n  pool;\n  constructor(ndk, signer, debug9, relayUrls) {\n    super();\n    this.ndk = ndk;\n    this.signer = signer;\n    if (relayUrls) {\n      this.pool = new NDKPool(relayUrls, [], ndk, {\n        debug: debug9.extend(\"rpc-pool\"),\n        name: \"Nostr RPC\"\n      });\n      this.relaySet = new NDKRelaySet(/* @__PURE__ */ new Set(), ndk, this.pool);\n      for (const url of relayUrls) {\n        const relay = this.pool.getRelay(url, false, false);\n        relay.authPolicy = NDKRelayAuthPolicies.signIn({ ndk, signer, debug: debug9 });\n        this.relaySet.addRelay(relay);\n        relay.connect();\n      }\n    }\n    this.debug = debug9.extend(\"rpc\");\n  }\n  /**\n   * Subscribe to a filter. This function will resolve once the subscription is ready.\n   */\n  subscribe(filter) {\n    const sub = this.ndk.subscribe(\n      filter,\n      {\n        closeOnEose: false,\n        groupable: false,\n        cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */,\n        pool: this.pool,\n        relaySet: this.relaySet\n      },\n      false\n    );\n    sub.on(\"event\", async (event) => {\n      try {\n        const parsedEvent = await this.parseEvent(event);\n        if (parsedEvent.method) {\n          this.emit(\"request\", parsedEvent);\n        } else {\n          this.emit(`response-${parsedEvent.id}`, parsedEvent);\n          this.emit(\"response\", parsedEvent);\n        }\n      } catch (e) {\n        this.debug(\"error parsing event\", e, event.rawEvent());\n      }\n    });\n    return new Promise((resolve) => {\n      sub.on(\"eose\", () => {\n        this.debug(\"eosed\");\n        resolve(sub);\n      });\n      sub.start();\n    });\n  }\n  async parseEvent(event) {\n    if (this.encryptionType === \"nip44\" && event.content.includes(\"?iv=\")) {\n      this.encryptionType = \"nip04\";\n    } else if (this.encryptionType === \"nip04\" && !event.content.includes(\"?iv=\")) {\n      this.encryptionType = \"nip44\";\n    }\n    const remoteUser = this.ndk.getUser({ pubkey: event.pubkey });\n    remoteUser.ndk = this.ndk;\n    let decryptedContent;\n    try {\n      decryptedContent = await this.signer.decrypt(remoteUser, event.content, this.encryptionType);\n    } catch (_e) {\n      const otherEncryptionType = this.encryptionType === \"nip04\" ? \"nip44\" : \"nip04\";\n      decryptedContent = await this.signer.decrypt(remoteUser, event.content, otherEncryptionType);\n      this.encryptionType = otherEncryptionType;\n    }\n    const parsedContent = JSON.parse(decryptedContent);\n    const { id, method, params, result, error } = parsedContent;\n    if (method) {\n      return { id, pubkey: event.pubkey, method, params, event };\n    }\n    return { id, result, error, event };\n  }\n  async sendResponse(id, remotePubkey, result, kind = 24133 /* NostrConnect */, error) {\n    const res = { id, result };\n    if (error) {\n      res.error = error;\n    }\n    const localUser = await this.signer.user();\n    const remoteUser = this.ndk.getUser({ pubkey: remotePubkey });\n    const event = new NDKEvent(this.ndk, {\n      kind,\n      content: JSON.stringify(res),\n      tags: [[\"p\", remotePubkey]],\n      pubkey: localUser.pubkey\n    });\n    event.content = await this.signer.encrypt(remoteUser, event.content, this.encryptionType);\n    await event.sign(this.signer);\n    await event.publish(this.relaySet);\n  }\n  /**\n   * Sends a request.\n   * @param remotePubkey\n   * @param method\n   * @param params\n   * @param kind\n   * @param id\n   */\n  async sendRequest(remotePubkey, method, params = [], kind = 24133, cb) {\n    const id = Math.random().toString(36).substring(7);\n    const localUser = await this.signer.user();\n    const remoteUser = this.ndk.getUser({ pubkey: remotePubkey });\n    const request = { id, method, params };\n    const promise = new Promise(() => {\n      const responseHandler = (response) => {\n        if (response.result === \"auth_url\") {\n          this.once(`response-${id}`, responseHandler);\n          this.emit(\"authUrl\", response.error);\n        } else if (cb) {\n          cb(response);\n        }\n      };\n      this.once(`response-${id}`, responseHandler);\n    });\n    const event = new NDKEvent(this.ndk, {\n      kind,\n      content: JSON.stringify(request),\n      tags: [[\"p\", remotePubkey]],\n      pubkey: localUser.pubkey\n    });\n    event.content = await this.signer.encrypt(remoteUser, event.content, this.encryptionType);\n    await event.sign(this.signer);\n    await event.publish(this.relaySet);\n    return promise;\n  }\n};\n\n// src/signers/nip46/backend/connect.ts\nvar ConnectEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [_, token] = params;\n    const debug9 = backend.debug.extend(\"connect\");\n    debug9(`connection request from ${remotePubkey}`);\n    if (token && backend.applyToken) {\n      debug9(\"applying token\");\n      await backend.applyToken(remotePubkey, token);\n    }\n    if (await backend.pubkeyAllowed({\n      id,\n      pubkey: remotePubkey,\n      method: \"connect\",\n      params: token\n    })) {\n      debug9(`connection request from ${remotePubkey} allowed`);\n      return \"ack\";\n    }\n    debug9(`connection request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n};\n\n// src/signers/nip46/backend/get-public-key.ts\nvar GetPublicKeyHandlingStrategy = class {\n  async handle(backend, _id, _remotePubkey, _params) {\n    return backend.localUser?.pubkey;\n  }\n};\n\n// src/signers/nip46/backend/nip04-decrypt.ts\nvar Nip04DecryptHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [senderPubkey, payload] = params;\n    const senderUser = new NDKUser({ pubkey: senderPubkey });\n    const decryptedPayload = await decrypt2(backend, id, remotePubkey, senderUser, payload);\n    return decryptedPayload;\n  }\n};\nasync function decrypt2(backend, id, remotePubkey, senderUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip04_decrypt\",\n    params: payload\n  })) {\n    backend.debug(`decrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.decrypt(senderUser, payload, \"nip04\");\n}\n\n// src/signers/nip46/backend/nip04-encrypt.ts\nvar Nip04EncryptHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [recipientPubkey, payload] = params;\n    const recipientUser = new NDKUser({ pubkey: recipientPubkey });\n    const encryptedPayload = await encrypt2(backend, id, remotePubkey, recipientUser, payload);\n    return encryptedPayload;\n  }\n};\nasync function encrypt2(backend, id, remotePubkey, recipientUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip04_encrypt\",\n    params: payload\n  })) {\n    backend.debug(`encrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.encrypt(recipientUser, payload, \"nip04\");\n}\n\n// src/signers/nip46/backend/nip44-decrypt.ts\nvar Nip04DecryptHandlingStrategy2 = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [senderPubkey, payload] = params;\n    const senderUser = new NDKUser({ pubkey: senderPubkey });\n    const decryptedPayload = await decrypt3(backend, id, remotePubkey, senderUser, payload);\n    return decryptedPayload;\n  }\n};\nasync function decrypt3(backend, id, remotePubkey, senderUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip44_decrypt\",\n    params: payload\n  })) {\n    backend.debug(`decrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.decrypt(senderUser, payload, \"nip44\");\n}\n\n// src/signers/nip46/backend/nip44-encrypt.ts\nvar Nip04EncryptHandlingStrategy2 = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [recipientPubkey, payload] = params;\n    const recipientUser = new NDKUser({ pubkey: recipientPubkey });\n    const encryptedPayload = await encrypt3(backend, id, remotePubkey, recipientUser, payload);\n    return encryptedPayload;\n  }\n};\nasync function encrypt3(backend, id, remotePubkey, recipientUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip44_encrypt\",\n    params: payload\n  })) {\n    backend.debug(`encrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.encrypt(recipientUser, payload, \"nip44\");\n}\n\n// src/signers/nip46/backend/ping.ts\nvar PingEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, _params) {\n    const debug9 = backend.debug.extend(\"ping\");\n    debug9(`ping request from ${remotePubkey}`);\n    if (await backend.pubkeyAllowed({ id, pubkey: remotePubkey, method: \"ping\" })) {\n      debug9(`connection request from ${remotePubkey} allowed`);\n      return \"pong\";\n    }\n    debug9(`connection request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n};\n\n// src/signers/nip46/backend/sign-event.ts\nvar SignEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const event = await signEvent(backend, id, remotePubkey, params);\n    if (!event) return void 0;\n    return JSON.stringify(await event.toNostrEvent());\n  }\n};\nasync function signEvent(backend, id, remotePubkey, params) {\n  const [eventString] = params;\n  backend.debug(`sign event request from ${remotePubkey}`);\n  const event = new NDKEvent(backend.ndk, JSON.parse(eventString));\n  backend.debug(\"event to sign\", event.rawEvent());\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"sign_event\",\n    params: event\n  })) {\n    backend.debug(`sign event request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  backend.debug(`sign event request from ${remotePubkey} allowed`);\n  await event.sign(backend.signer);\n  return event;\n}\n\n// src/signers/nip46/backend/index.ts\nvar NDKNip46Backend = class {\n  ndk;\n  signer;\n  localUser;\n  debug;\n  rpc;\n  permitCallback;\n  relayUrls;\n  /**\n   * @param ndk The NDK instance to use\n   * @param privateKeyOrSigner The private key or signer of the npub that wants to be published as\n   * @param permitCallback Callback executed when permission is requested\n   */\n  constructor(ndk, privateKeyOrSigner, permitCallback, relayUrls) {\n    this.ndk = ndk;\n    if (privateKeyOrSigner instanceof Uint8Array) {\n      this.signer = new NDKPrivateKeySigner(privateKeyOrSigner);\n    } else if (privateKeyOrSigner instanceof String) {\n      this.signer = new NDKPrivateKeySigner((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(privateKeyOrSigner));\n    } else if (privateKeyOrSigner instanceof NDKPrivateKeySigner) {\n      this.signer = privateKeyOrSigner;\n    } else {\n      throw new Error(\"Invalid signer\");\n    }\n    this.debug = ndk.debug.extend(\"nip46:backend\");\n    this.relayUrls = relayUrls ?? Array.from(ndk.pool.relays.keys());\n    this.rpc = new NDKNostrRpc(ndk, this.signer, this.debug, this.relayUrls);\n    this.permitCallback = permitCallback;\n  }\n  /**\n   * This method starts the backend, which will start listening for incoming\n   * requests.\n   */\n  async start() {\n    this.localUser = await this.signer.user();\n    const sub = this.ndk.subscribe(\n      {\n        kinds: [24133],\n        \"#p\": [this.localUser.pubkey]\n      },\n      { closeOnEose: false }\n    );\n    sub.on(\"event\", (e) => this.handleIncomingEvent(e));\n  }\n  handlers = {\n    connect: new ConnectEventHandlingStrategy(),\n    sign_event: new SignEventHandlingStrategy(),\n    nip04_encrypt: new Nip04EncryptHandlingStrategy(),\n    nip04_decrypt: new Nip04DecryptHandlingStrategy(),\n    nip44_encrypt: new Nip04EncryptHandlingStrategy2(),\n    nip44_decrypt: new Nip04DecryptHandlingStrategy2(),\n    get_public_key: new GetPublicKeyHandlingStrategy(),\n    ping: new PingEventHandlingStrategy()\n  };\n  /**\n   * Enables the user to set a custom strategy for handling incoming events.\n   * @param method - The method to set the strategy for\n   * @param strategy - The strategy to set\n   */\n  setStrategy(method, strategy) {\n    this.handlers[method] = strategy;\n  }\n  /**\n   * Overload this method to apply tokens, which can\n   * wrap permission sets to be applied to a pubkey.\n   * @param pubkey public key to apply token to\n   * @param token token to apply\n   */\n  async applyToken(_pubkey, _token) {\n    throw new Error(\"connection token not supported\");\n  }\n  async handleIncomingEvent(event) {\n    const { id, method, params } = await this.rpc.parseEvent(event);\n    const remotePubkey = event.pubkey;\n    let response;\n    this.debug(\"incoming event\", { id, method, params });\n    if (!event.verifySignature(false)) {\n      this.debug(\"invalid signature\", event.rawEvent());\n      return;\n    }\n    const strategy = this.handlers[method];\n    if (strategy) {\n      try {\n        response = await strategy.handle(this, id, remotePubkey, params);\n      } catch (e) {\n        this.debug(\"error handling event\", e, { id, method, params });\n        this.rpc.sendResponse(id, remotePubkey, \"error\", void 0, e.message);\n      }\n    } else {\n      this.debug(\"unsupported method\", { method, params });\n    }\n    if (response) {\n      this.debug(`sending response to ${remotePubkey}`, response);\n      this.rpc.sendResponse(id, remotePubkey, response);\n    } else {\n      this.rpc.sendResponse(id, remotePubkey, \"error\", void 0, \"Not authorized\");\n    }\n  }\n  /**\n   * This method should be overriden by the user to allow or reject incoming\n   * connections.\n   */\n  async pubkeyAllowed(params) {\n    return this.permitCallback(params);\n  }\n};\n\n// src/signers/nip46/index.ts\n\n\n// src/signers/deserialization.ts\nasync function ndkSignerFromPayload(payloadString, ndk) {\n  let parsed;\n  try {\n    parsed = JSON.parse(payloadString);\n  } catch (e) {\n    console.error(\"Failed to parse signer payload string\", payloadString, e);\n    return void 0;\n  }\n  if (!parsed || typeof parsed.type !== \"string\") {\n    console.error(\"Failed to parse signer payload string\", payloadString, new Error(\"Missing type field\"));\n    return void 0;\n  }\n  const SignerClass = signerRegistry.get(parsed.type);\n  if (!SignerClass) {\n    throw new Error(`Unknown signer type: ${parsed.type}`);\n  }\n  try {\n    return await SignerClass.fromPayload(payloadString, ndk);\n  } catch (e) {\n    const errorMsg = e instanceof Error ? e.message : String(e);\n    throw new Error(`Failed to deserialize signer type ${parsed.type}: ${errorMsg}`);\n  }\n}\n\n// src/signers/nip46/nostrconnect.ts\nfunction nostrConnectGenerateSecret() {\n  return Math.random().toString(36).substring(2, 15);\n}\nfunction generateNostrConnectUri(pubkey, secret, relay, options) {\n  const meta = {\n    name: options?.name ? encodeURIComponent(options.name) : \"\",\n    url: options?.url ? encodeURIComponent(options.url) : \"\",\n    image: options?.image ? encodeURIComponent(options.image) : \"\",\n    perms: options?.perms ? encodeURIComponent(options.perms) : \"\"\n  };\n  let uri = `nostrconnect://${pubkey}?image=${meta.image}&url=${meta.url}&name=${meta.name}&perms=${meta.perms}&secret=${encodeURIComponent(secret)}`;\n  if (relay) {\n    uri += `&relay=${encodeURIComponent(relay)}`;\n  }\n  return uri;\n}\n\n// src/signers/nip46/index.ts\nvar NDKNip46Signer = class _NDKNip46Signer extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  _user;\n  /**\n   * The pubkey of the bunker that will be providing signatures\n   */\n  bunkerPubkey;\n  /**\n   * The pubkey of the user that events will be published as\n   */\n  userPubkey;\n  get pubkey() {\n    if (!this.userPubkey) throw new Error(\"Not ready\");\n    return this.userPubkey;\n  }\n  /**\n   * An optional secret value provided to connect to the bunker\n   */\n  secret;\n  localSigner;\n  nip05;\n  rpc;\n  debug;\n  relayUrls;\n  subscription;\n  /**\n   * If using nostrconnect://, stores the nostrConnectURI\n   */\n  nostrConnectUri;\n  /**\n   * The random secret used for nostrconnect:// flows.\n   */\n  nostrConnectSecret;\n  /**\n   *\n   * Don't instantiate this directly. Use the static methods instead.\n   *\n   * @example:\n   * // for bunker:// flow\n   * const signer = NDKNip46Signer.bunker(ndk, \"bunker://<connection-token>\")\n   * const signer = NDKNip46Signer.bunker(ndk, \"<your-nip05>\"); // with nip05 flow\n   * // for nostrconnect:// flow\n   * const signer = NDKNip46Signer.nostrconnect(ndk, \"wss://relay.example.com\")\n   *\n   * @param ndk - The NDK instance to use\n   * @param userOrConnectionToken - The public key, or a connection token, of the npub that wants to be published as\n   * @param localSigner - The signer that will be used to request events to be signed\n   */\n  constructor(ndk, userOrConnectionToken, localSigner, relayUrls, nostrConnectOptions) {\n    super();\n    this.ndk = ndk;\n    this.debug = ndk.debug.extend(\"nip46:signer\");\n    this.relayUrls = relayUrls;\n    if (!localSigner) {\n      this.localSigner = NDKPrivateKeySigner.generate();\n    } else {\n      if (typeof localSigner === \"string\") {\n        this.localSigner = new NDKPrivateKeySigner(localSigner);\n      } else {\n        this.localSigner = localSigner;\n      }\n    }\n    if (userOrConnectionToken === false) {\n    } else if (!userOrConnectionToken) {\n      this.nostrconnectFlowInit(nostrConnectOptions);\n    } else if (userOrConnectionToken.startsWith(\"bunker://\")) {\n      this.bunkerFlowInit(userOrConnectionToken);\n    } else {\n      this.nip05Init(userOrConnectionToken);\n    }\n    this.rpc = new NDKNostrRpc(this.ndk, this.localSigner, this.debug, this.relayUrls);\n  }\n  /**\n   * Connnect with a bunker:// flow\n   * @param ndk\n   * @param userOrConnectionToken bunker:// connection string\n   * @param localSigner If you have previously authenticated with this signer, you can restore the session by providing the previously authenticated key\n   */\n  static bunker(ndk, userOrConnectionToken, localSigner) {\n    return new _NDKNip46Signer(ndk, userOrConnectionToken, localSigner);\n  }\n  /**\n   * Connect with a nostrconnect:// flow\n   * @param ndk\n   * @param relay - Relay used to connect with the signer\n   * @param localSigner If you have previously authenticated with this signer, you can restore the session by providing the previously authenticated key\n   */\n  static nostrconnect(ndk, relay, localSigner, nostrConnectOptions) {\n    return new _NDKNip46Signer(ndk, void 0, localSigner, [relay], nostrConnectOptions);\n  }\n  nostrconnectFlowInit(nostrConnectOptions) {\n    this.nostrConnectSecret = nostrConnectGenerateSecret();\n    const pubkey = this.localSigner.pubkey;\n    this.nostrConnectUri = generateNostrConnectUri(\n      pubkey,\n      this.nostrConnectSecret,\n      this.relayUrls?.[0],\n      nostrConnectOptions\n    );\n  }\n  bunkerFlowInit(connectionToken) {\n    const bunkerUrl = new URL(connectionToken);\n    const bunkerPubkey = bunkerUrl.hostname || bunkerUrl.pathname.replace(/^\\/\\//, \"\");\n    const userPubkey = bunkerUrl.searchParams.get(\"pubkey\");\n    const relayUrls = bunkerUrl.searchParams.getAll(\"relay\");\n    const secret = bunkerUrl.searchParams.get(\"secret\");\n    this.bunkerPubkey = bunkerPubkey;\n    this.userPubkey = userPubkey;\n    this.relayUrls = relayUrls;\n    this.secret = secret;\n  }\n  nip05Init(nip05) {\n    this.nip05 = nip05;\n  }\n  /**\n   * We start listening for events from the bunker\n   */\n  async startListening() {\n    if (this.subscription) return;\n    const localUser = await this.localSigner.user();\n    if (!localUser) throw new Error(\"Local signer not ready\");\n    this.subscription = await this.rpc.subscribe({\n      kinds: [24133 /* NostrConnect */],\n      \"#p\": [localUser.pubkey]\n    });\n  }\n  /**\n   * Get the user that is being published as\n   */\n  async user() {\n    if (this._user) return this._user;\n    return this.blockUntilReady();\n  }\n  get userSync() {\n    if (!this._user) throw new Error(\"Remote user not ready synchronously\");\n    return this._user;\n  }\n  async blockUntilReadyNostrConnect() {\n    return new Promise((resolve, reject) => {\n      const connect = (response) => {\n        if (response.result === this.nostrConnectSecret) {\n          this._user = response.event.author;\n          this.userPubkey = response.event.pubkey;\n          this.bunkerPubkey = response.event.pubkey;\n          this.rpc.off(\"response\", connect);\n          resolve(this._user);\n        }\n      };\n      this.startListening();\n      this.rpc.on(\"response\", connect);\n    });\n  }\n  async blockUntilReady() {\n    if (!this.bunkerPubkey && !this.nostrConnectSecret && !this.nip05) {\n      throw new Error(\"Bunker pubkey not set\");\n    }\n    if (this.nostrConnectSecret) return this.blockUntilReadyNostrConnect();\n    if (this.nip05 && !this.userPubkey) {\n      const user = await NDKUser.fromNip05(this.nip05, this.ndk);\n      if (user) {\n        this._user = user;\n        this.userPubkey = user.pubkey;\n        this.relayUrls = user.nip46Urls;\n        this.rpc = new NDKNostrRpc(this.ndk, this.localSigner, this.debug, this.relayUrls);\n      }\n    }\n    if (!this.bunkerPubkey && this.userPubkey) {\n      this.bunkerPubkey = this.userPubkey;\n    } else if (!this.bunkerPubkey) {\n      throw new Error(\"Bunker pubkey not set\");\n    }\n    await this.startListening();\n    this.rpc.on(\"authUrl\", (...props) => {\n      this.emit(\"authUrl\", ...props);\n    });\n    return new Promise((resolve, reject) => {\n      const connectParams = [this.userPubkey ?? \"\"];\n      if (this.secret) connectParams.push(this.secret);\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(this.bunkerPubkey, \"connect\", connectParams, 24133, (response) => {\n        if (response.result === \"ack\") {\n          this.getPublicKey().then((pubkey) => {\n            this.userPubkey = pubkey;\n            this._user = this.ndk.getUser({ pubkey });\n            resolve(this._user);\n          });\n        } else {\n          reject(response.error);\n        }\n      });\n    });\n  }\n  stop() {\n    this.subscription?.stop();\n    this.subscription = void 0;\n  }\n  async getPublicKey() {\n    if (this.userPubkey) return this.userPubkey;\n    return new Promise((resolve, _reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(this.bunkerPubkey, \"get_public_key\", [], 24133, (response) => {\n        resolve(response.result);\n      });\n    });\n  }\n  async encryptionEnabled(scheme) {\n    if (scheme) return [scheme];\n    return Promise.resolve([\"nip04\", \"nip44\"]);\n  }\n  async encrypt(recipient, value, scheme = \"nip04\") {\n    return this.encryption(recipient, value, scheme, \"encrypt\");\n  }\n  async decrypt(sender, value, scheme = \"nip04\") {\n    return this.encryption(sender, value, scheme, \"decrypt\");\n  }\n  async encryption(peer, value, scheme, method) {\n    const promise = new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        `${scheme}_${method}`,\n        [peer.pubkey, value],\n        24133,\n        (response) => {\n          if (!response.error) {\n            resolve(response.result);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n    return promise;\n  }\n  async sign(event) {\n    const promise = new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"sign_event\",\n        [JSON.stringify(event)],\n        24133,\n        (response) => {\n          if (!response.error) {\n            const json = JSON.parse(response.result);\n            resolve(json.sig);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n    return promise;\n  }\n  /**\n   * Allows creating a new account on the remote server.\n   * @param username Desired username for the NIP-05\n   * @param domain Desired domain for the NIP-05\n   * @param email Email address to associate with this account -- Remote servers may use this for recovery\n   * @returns The public key of the newly created account\n   */\n  async createAccount(username, domain, email) {\n    await this.startListening();\n    const req = [];\n    if (username) req.push(username);\n    if (domain) req.push(domain);\n    if (email) req.push(email);\n    return new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"create_account\",\n        req,\n        24133 /* NostrConnect */,\n        (response) => {\n          if (!response.error) {\n            const pubkey = response.result;\n            resolve(pubkey);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n  }\n  /**\n   * Serializes the signer's connection details and local signer state.\n   * @returns A JSON string containing the type, connection info, and local signer payload.\n   */\n  toPayload() {\n    if (!this.bunkerPubkey || !this.userPubkey) {\n      throw new Error(\"NIP-46 signer is not fully initialized for serialization\");\n    }\n    const payload = {\n      type: \"nip46\",\n      payload: {\n        bunkerPubkey: this.bunkerPubkey,\n        userPubkey: this.userPubkey,\n        relayUrls: this.relayUrls,\n        secret: this.secret,\n        localSignerPayload: this.localSigner.toPayload(),\n        // Store nip05 if it was used for initialization, otherwise null\n        nip05: this.nip05 || null\n      }\n    };\n    return JSON.stringify(payload);\n  }\n  /**\n   * Deserializes the signer from a payload string.\n   * @param payloadString The JSON string obtained from toPayload().\n   * @param ndk The NDK instance, required for NIP-46.\n   * @returns An instance of NDKNip46Signer.\n   */\n  static async fromPayload(payloadString, ndk) {\n    if (!ndk) {\n      throw new Error(\"NDK instance is required to deserialize NIP-46 signer\");\n    }\n    const parsed = JSON.parse(payloadString);\n    if (parsed.type !== \"nip46\") {\n      throw new Error(`Invalid payload type: expected 'nip46', got ${parsed.type}`);\n    }\n    const payload = parsed.payload;\n    if (!payload || typeof payload !== \"object\" || !payload.localSignerPayload) {\n      throw new Error(\"Invalid payload content for nip46 signer\");\n    }\n    const localSigner = await ndkSignerFromPayload(payload.localSignerPayload, ndk);\n    if (!localSigner) {\n      throw new Error(\"Failed to deserialize local signer for NIP-46\");\n    }\n    if (!(localSigner instanceof NDKPrivateKeySigner)) {\n      throw new Error(\"Local signer must be an instance of NDKPrivateKeySigner\");\n    }\n    let signer;\n    signer = new _NDKNip46Signer(ndk, false, localSigner, payload.relayUrls);\n    signer.userPubkey = payload.userPubkey;\n    signer.bunkerPubkey = payload.bunkerPubkey;\n    signer.relayUrls = payload.relayUrls;\n    signer.secret = payload.secret;\n    if (payload.userPubkey) {\n      signer._user = new NDKUser({ pubkey: payload.userPubkey });\n      if (signer._user) signer._user.ndk = ndk;\n    }\n    return signer;\n  }\n};\nregisterSigner(\"nip46\", NDKNip46Signer);\n\n// src/dvm/schedule.ts\nfunction addRelays(event, relays) {\n  const tags = [];\n  if (!relays || relays.length === 0) {\n    const poolRelays = event.ndk?.pool.relays;\n    relays = poolRelays ? Object.keys(poolRelays) : void 0;\n  }\n  if (relays && relays.length > 0) tags.push([\"relays\", ...relays]);\n  return tags;\n}\nasync function dvmSchedule(events, dvm, relays, encrypted = true, waitForConfirmationForMs) {\n  if (!Array.isArray(events)) {\n    events = [events];\n  }\n  const ndk = events[0].ndk;\n  if (!ndk) throw new Error(\"NDK not set\");\n  for (const event of events) {\n    if (!event.sig) throw new Error(\"Event not signed\");\n    if (!event.created_at) throw new Error(\"Event has no date\");\n    if (!dvm) throw new Error(\"No DVM specified\");\n    if (event.created_at <= Date.now() / 1e3) throw new Error(\"Event needs to be in the future\");\n  }\n  const scheduleEvent = new NDKDVMRequest(ndk, {\n    kind: 5905 /* DVMEventSchedule */\n  });\n  for (const event of events) {\n    scheduleEvent.addInput(JSON.stringify(event.rawEvent()), \"text\");\n  }\n  scheduleEvent.tags.push(...addRelays(events[0], relays));\n  if (encrypted) {\n    await scheduleEvent.encryption(dvm);\n  } else {\n    scheduleEvent.dvm = dvm;\n  }\n  await scheduleEvent.sign();\n  let res;\n  if (waitForConfirmationForMs) {\n    res = ndk.subscribe(\n      {\n        kinds: [5905 /* DVMEventSchedule */ + 1e3, 7e3 /* DVMJobFeedback */],\n        ...scheduleEvent.filter()\n      },\n      { groupable: false, closeOnEose: false }\n    );\n  }\n  const timeoutPromise = new Promise((reject) => {\n    setTimeout(() => {\n      res?.stop();\n      reject(\"Timeout waiting for an answer from the DVM\");\n    }, waitForConfirmationForMs);\n  });\n  const schedulePromise = new Promise((resolve, reject) => {\n    if (waitForConfirmationForMs) {\n      res?.on(\"event\", async (e) => {\n        res?.stop();\n        if (e.kind === 7e3 /* DVMJobFeedback */) {\n          const feedback = await NDKDVMJobFeedback.from(e);\n          if (feedback.status === \"error\") {\n            const statusTag = feedback.getMatchingTags(\"status\");\n            reject(statusTag?.[2] ?? feedback);\n          } else {\n            resolve(feedback);\n          }\n        }\n        resolve(e);\n      });\n    }\n    scheduleEvent.publish().then(() => {\n      if (!waitForConfirmationForMs) resolve(void 0);\n    });\n  });\n  return new Promise((resolve, reject) => {\n    if (waitForConfirmationForMs) {\n      Promise.race([timeoutPromise, schedulePromise]).then((e) => {\n        resolve(e);\n      }).catch(reject);\n    } else {\n      schedulePromise.then(resolve);\n    }\n  });\n}\n\n// src/ndk/index.ts\n\n\n\n// src/events/dedup.ts\nfunction dedup(event1, event2) {\n  if (event1.created_at > event2.created_at) {\n    return event1;\n  }\n  return event2;\n}\n\n// src/outbox/tracker.ts\n\n\n\n// src/utils/get-users-relay-list.ts\nasync function getRelayListForUser(pubkey, ndk) {\n  const list = await getRelayListForUsers([pubkey], ndk);\n  return list.get(pubkey);\n}\nasync function getRelayListForUsers(pubkeys, ndk, skipCache = false, timeout = 1e3) {\n  const pool = ndk.outboxPool || ndk.pool;\n  const set = /* @__PURE__ */ new Set();\n  for (const relay of pool.relays.values()) set.add(relay);\n  const relayLists = /* @__PURE__ */ new Map();\n  const fromContactList = /* @__PURE__ */ new Map();\n  const relaySet = new NDKRelaySet(set, ndk);\n  if (ndk.cacheAdapter?.locking && !skipCache) {\n    const cachedList = await ndk.fetchEvents(\n      { kinds: [3, 10002], authors: Array.from(new Set(pubkeys)) },\n      { cacheUsage: \"ONLY_CACHE\" /* ONLY_CACHE */, subId: \"ndk-relay-list-fetch\" }\n    );\n    for (const relayList of cachedList) {\n      if (relayList.kind === 10002) relayLists.set(relayList.pubkey, NDKRelayList.from(relayList));\n    }\n    for (const relayList of cachedList) {\n      if (relayList.kind === 3) {\n        if (relayLists.has(relayList.pubkey)) continue;\n        const list = relayListFromKind3(ndk, relayList);\n        if (list) fromContactList.set(relayList.pubkey, list);\n      }\n    }\n    pubkeys = pubkeys.filter((pubkey) => !relayLists.has(pubkey) && !fromContactList.has(pubkey));\n  }\n  if (pubkeys.length === 0) return relayLists;\n  const relayListEvents = /* @__PURE__ */ new Map();\n  const contactListEvents = /* @__PURE__ */ new Map();\n  return new Promise((resolve) => {\n    const handleSubscription = async () => {\n      const subscribeOpts = {\n        closeOnEose: true,\n        pool,\n        groupable: true,\n        subId: \"ndk-relay-list-fetch\",\n        addSinceFromCache: true,\n        relaySet\n      };\n      if (relaySet) subscribeOpts.relaySet = relaySet;\n      ndk.subscribe({ kinds: [3, 10002], authors: pubkeys }, subscribeOpts, {\n        onEvent: (event) => {\n          if (event.kind === 10002 /* RelayList */) {\n            const existingEvent = relayListEvents.get(event.pubkey);\n            if (existingEvent && existingEvent.created_at > event.created_at) return;\n            relayListEvents.set(event.pubkey, event);\n          } else if (event.kind === 3 /* Contacts */) {\n            const existingEvent = contactListEvents.get(event.pubkey);\n            if (existingEvent && existingEvent.created_at > event.created_at) return;\n            contactListEvents.set(event.pubkey, event);\n          }\n        },\n        onEose: () => {\n          for (const event of relayListEvents.values()) {\n            relayLists.set(event.pubkey, NDKRelayList.from(event));\n          }\n          for (const pubkey of pubkeys) {\n            if (relayLists.has(pubkey)) continue;\n            const contactList = contactListEvents.get(pubkey);\n            if (!contactList) continue;\n            const list = relayListFromKind3(ndk, contactList);\n            if (list) relayLists.set(pubkey, list);\n          }\n          resolve(relayLists);\n        }\n      });\n      setTimeout(() => {\n        resolve(relayLists);\n      }, timeout);\n    };\n    handleSubscription();\n  });\n}\n\n// src/outbox/tracker.ts\nvar OutboxItem = class {\n  /**\n   * Type of item\n   */\n  type;\n  /**\n   * The relay URLs that are of interest to this item\n   */\n  relayUrlScores;\n  readRelays;\n  writeRelays;\n  constructor(type) {\n    this.type = type;\n    this.relayUrlScores = /* @__PURE__ */ new Map();\n    this.readRelays = /* @__PURE__ */ new Set();\n    this.writeRelays = /* @__PURE__ */ new Set();\n  }\n};\nvar OutboxTracker = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  data;\n  ndk;\n  debug;\n  constructor(ndk) {\n    super();\n    this.ndk = ndk;\n    this.debug = ndk.debug.extend(\"outbox-tracker\");\n    this.data = new typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({\n      maxSize: 1e5,\n      entryExpirationTimeInMS: 2 * 60 * 1e3\n    });\n  }\n  /**\n   * Adds a list of users to the tracker.\n   * @param items\n   * @param skipCache\n   */\n  async trackUsers(items, skipCache = false) {\n    const promises = [];\n    for (let i = 0; i < items.length; i += 400) {\n      const slice = items.slice(i, i + 400);\n      const pubkeys = slice.map((item) => getKeyFromItem(item)).filter((pubkey) => !this.data.has(pubkey));\n      if (pubkeys.length === 0) continue;\n      for (const pubkey of pubkeys) {\n        this.data.set(pubkey, new OutboxItem(\"user\"));\n      }\n      promises.push(\n        new Promise((resolve) => {\n          getRelayListForUsers(pubkeys, this.ndk, skipCache).then((relayLists) => {\n            for (const [pubkey, relayList] of relayLists) {\n              let outboxItem = this.data.get(pubkey);\n              outboxItem ??= new OutboxItem(\"user\");\n              if (relayList) {\n                outboxItem.readRelays = new Set(normalize(relayList.readRelayUrls));\n                outboxItem.writeRelays = new Set(normalize(relayList.writeRelayUrls));\n                for (const relayUrl of outboxItem.readRelays) {\n                  if (this.ndk.pool.blacklistRelayUrls.has(relayUrl)) {\n                    outboxItem.readRelays.delete(relayUrl);\n                  }\n                }\n                for (const relayUrl of outboxItem.writeRelays) {\n                  if (this.ndk.pool.blacklistRelayUrls.has(relayUrl)) {\n                    outboxItem.writeRelays.delete(relayUrl);\n                  }\n                }\n                this.data.set(pubkey, outboxItem);\n              }\n            }\n          }).finally(resolve);\n        })\n      );\n    }\n    return Promise.all(promises);\n  }\n  /**\n   *\n   * @param key\n   * @param score\n   */\n  track(item, type, _skipCache = true) {\n    const key = getKeyFromItem(item);\n    type ??= getTypeFromItem(item);\n    let outboxItem = this.data.get(key);\n    if (!outboxItem) {\n      outboxItem = new OutboxItem(type);\n      if (item instanceof NDKUser) {\n        this.trackUsers([item]);\n      }\n    }\n    return outboxItem;\n  }\n};\nfunction getKeyFromItem(item) {\n  if (item instanceof NDKUser) {\n    return item.pubkey;\n  }\n  return item;\n}\nfunction getTypeFromItem(item) {\n  if (item instanceof NDKUser) {\n    return \"user\";\n  }\n  return \"kind\";\n}\n\n// src/relay/sets/utils.ts\nfunction correctRelaySet(relaySet, pool) {\n  const connectedRelays = pool.connectedRelays();\n  const includesConnectedRelay = Array.from(relaySet.relays).some((relay) => {\n    return connectedRelays.map((r) => r.url).includes(relay.url);\n  });\n  if (!includesConnectedRelay) {\n    for (const relay of connectedRelays) {\n      relaySet.addRelay(relay);\n    }\n  }\n  if (connectedRelays.length === 0) {\n    for (const relay of pool.relays.values()) {\n      relaySet.addRelay(relay);\n    }\n  }\n  return relaySet;\n}\n\n// src/subscription/manager.ts\n\nvar NDKSubscriptionManager = class {\n  subscriptions;\n  seenEvents = /* @__PURE__ */ new Map();\n  constructor() {\n    this.subscriptions = /* @__PURE__ */ new Map();\n  }\n  add(sub) {\n    this.subscriptions.set(sub.internalId, sub);\n    if (sub.onStopped) {\n    }\n    sub.onStopped = () => {\n      this.subscriptions.delete(sub.internalId);\n    };\n    sub.on(\"close\", () => {\n      this.subscriptions.delete(sub.internalId);\n    });\n  }\n  seenEvent(eventId, relay) {\n    const current = this.seenEvents.get(eventId) || [];\n    current.push(relay);\n    this.seenEvents.set(eventId, current);\n  }\n  /**\n   * Whenever an event comes in, this function is called.\n   * This function matches the received event against all the\n   * known (i.e. active) NDKSubscriptions, and if it matches,\n   * it sends the event to the subscription.\n   *\n   * This is the single place in the codebase that matches\n   * incoming events with parties interested in the event.\n   *\n   * This is also what allows for reactivity in NDK apps, such that\n   * whenever an active subscription receives an event that some\n   * other active subscription would want to receive, both receive it.\n   *\n   * TODO This also allows for subscriptions that overlap in meaning\n   * to be collapsed into one.\n   *\n   * I.e. if a subscription with filter: kinds: [1], authors: [alice]\n   * is created and EOSEs, and then a subsequent subscription with\n   * kinds: [1], authors: [alice] is created, once the second subscription\n   * EOSEs we can safely close it, increment its refCount and close it,\n   * and when the first subscription receives a new event from Alice this\n   * code will make the second subscription receive the event even though\n   * it has no active subscription on a relay.\n   * @param event Raw event received from a relay\n   * @param relay Relay that sent the event\n   * @param optimisticPublish Whether the event is coming from an optimistic publish\n   */\n  dispatchEvent(event, relay, optimisticPublish = false) {\n    if (relay) this.seenEvent(event.id, relay);\n    const subscriptions = this.subscriptions.values();\n    const matchingSubs = [];\n    for (const sub of subscriptions) {\n      if ((0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.matchFilters)(sub.filters, event)) {\n        matchingSubs.push(sub);\n      }\n    }\n    for (const sub of matchingSubs) {\n      sub.eventReceived(event, relay, false, optimisticPublish);\n    }\n  }\n};\n\n// src/ndk/active-user.ts\n\nvar debug7 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:active-user\");\nasync function getUserRelayList(user) {\n  if (!this.autoConnectUserRelays) return;\n  const userRelays = await getRelayListForUser(user.pubkey, this);\n  if (!userRelays) return;\n  for (const url of userRelays.relays) {\n    let relay = this.pool.relays.get(url);\n    if (!relay) {\n      relay = new NDKRelay(url, this.relayAuthDefaultPolicy, this);\n      this.pool.addRelay(relay);\n    }\n  }\n  return userRelays;\n}\nasync function setActiveUser(user) {\n  const pool = this.outboxPool || this.pool;\n  if (pool.connectedRelays.length > 0) {\n    setActiveUserConnected.call(this, user);\n  } else {\n    pool.once(\"connect\", () => {\n      setActiveUserConnected.call(this, user);\n    });\n  }\n}\nasync function setActiveUserConnected(user) {\n  const userRelays = await getUserRelayList.call(this, user);\n  const filters = [\n    {\n      kinds: [10006 /* BlockRelayList */],\n      authors: [user.pubkey]\n    }\n  ];\n  if (this.autoFetchUserMutelist) {\n    filters[0].kinds?.push(1e4 /* MuteList */);\n  }\n  const events = /* @__PURE__ */ new Map();\n  const relaySet = userRelays ? userRelays.relaySet : void 0;\n  this.subscribe(\n    filters,\n    { subId: \"active-user-settings\", closeOnEose: true, relaySet },\n    {\n      onEvent: (event) => {\n        const prevEvent = events.get(event.kind);\n        if (prevEvent && prevEvent.created_at >= event.created_at) return;\n        events.set(event.kind, event);\n      },\n      onEose: () => {\n        for (const event of events.values()) {\n          processEvent.call(this, event);\n        }\n      }\n    }\n  );\n}\nasync function processEvent(event) {\n  if (event.kind === 10006 /* BlockRelayList */) {\n    processBlockRelayList.call(this, event);\n  } else if (event.kind === 1e4 /* MuteList */) {\n    processMuteList.call(this, event);\n  }\n}\nfunction processBlockRelayList(event) {\n  const list = lists_default.from(event);\n  for (const item of list.items) {\n    this.pool.blacklistRelayUrls.add(item[0]);\n  }\n  debug7(\"Added %d relays to relay blacklist\", list.items.length);\n}\nfunction processMuteList(muteList) {\n  const list = lists_default.from(muteList);\n  for (const item of list.items) {\n    this.mutedIds.set(item[1], item[0]);\n  }\n  debug7(\"Added %d users to mute list\", list.items.length);\n}\n\n// src/ndk/entity.ts\n\nfunction getEntity(entity) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(entity);\n    if (decoded.type === \"npub\") return npub(this, decoded.data);\n    if (decoded.type === \"nprofile\") return nprofile(this, decoded.data);\n    return decoded;\n  } catch (_e) {\n    return null;\n  }\n}\nfunction npub(ndk, pubkey) {\n  return ndk.getUser({ pubkey });\n}\nfunction nprofile(ndk, profile) {\n  const user = ndk.getUser({ pubkey: profile.pubkey });\n  if (profile.relays) user.relayUrls = profile.relays;\n  return user;\n}\n\n// src/ndk/fetch-event-from-tag.ts\nfunction isValidHint(hint) {\n  if (!hint || hint === \"\") return false;\n  try {\n    new URL(hint);\n    return true;\n  } catch (_e) {\n    return false;\n  }\n}\nasync function fetchEventFromTag(tag, originalEvent, subOpts, fallback = {\n  type: \"timeout\"\n}) {\n  const d4 = this.debug.extend(\"fetch-event-from-tag\");\n  const [_, id, hint] = tag;\n  subOpts = {};\n  d4(\"fetching event from tag\", tag, subOpts, fallback);\n  const authorRelays = getRelaysForSync(this, originalEvent.pubkey);\n  if (authorRelays && authorRelays.size > 0) {\n    d4(\"fetching event from author relays %o\", Array.from(authorRelays));\n    const relaySet2 = NDKRelaySet.fromRelayUrls(Array.from(authorRelays), this);\n    const event2 = await this.fetchEvent(id, subOpts, relaySet2);\n    if (event2) return event2;\n  } else {\n    d4(\"no author relays found for %s\", originalEvent.pubkey, originalEvent);\n  }\n  const relaySet = calculateRelaySetsFromFilters(this, [{ ids: [id] }], this.pool);\n  d4(\"fetching event without relay hint\", relaySet);\n  const event = await this.fetchEvent(id, subOpts);\n  if (event) return event;\n  if (hint && hint !== \"\") {\n    const event2 = await this.fetchEvent(id, subOpts, this.pool.getRelay(hint, true, true, [{ ids: [id] }]));\n    if (event2) return event2;\n  }\n  let result = void 0;\n  const relay = isValidHint(hint) ? this.pool.getRelay(hint, false, true, [{ ids: [id] }]) : void 0;\n  const fetchMaybeWithRelayHint = new Promise((resolve) => {\n    this.fetchEvent(id, subOpts, relay).then(resolve);\n  });\n  if (!isValidHint(hint) || fallback.type === \"none\") {\n    return fetchMaybeWithRelayHint;\n  }\n  const fallbackFetchPromise = new Promise(async (resolve) => {\n    const fallbackRelaySet = fallback.relaySet;\n    const timeout = fallback.timeout ?? 1500;\n    const timeoutPromise = new Promise((resolve2) => setTimeout(resolve2, timeout));\n    if (fallback.type === \"timeout\") await timeoutPromise;\n    if (result) {\n      resolve(result);\n    } else {\n      d4(\"fallback fetch triggered\");\n      const fallbackEvent = await this.fetchEvent(id, subOpts, fallbackRelaySet);\n      resolve(fallbackEvent);\n    }\n  });\n  switch (fallback.type) {\n    case \"timeout\":\n      return Promise.race([fetchMaybeWithRelayHint, fallbackFetchPromise]);\n    case \"eose\":\n      result = await fetchMaybeWithRelayHint;\n      if (result) return result;\n      return fallbackFetchPromise;\n  }\n}\n\n// src/ndk/queue/index.ts\nvar Queue = class {\n  queue = [];\n  maxConcurrency;\n  processing = /* @__PURE__ */ new Set();\n  promises = /* @__PURE__ */ new Map();\n  constructor(_name, maxConcurrency) {\n    this.maxConcurrency = maxConcurrency;\n  }\n  add(item) {\n    if (this.promises.has(item.id)) {\n      return this.promises.get(item.id);\n    }\n    const promise = new Promise((resolve, reject) => {\n      this.queue.push({\n        ...item,\n        func: () => item.func().then(\n          (result) => {\n            resolve(result);\n            return result;\n          },\n          (error) => {\n            reject(error);\n            throw error;\n          }\n        )\n      });\n      this.process();\n    });\n    this.promises.set(item.id, promise);\n    promise.finally(() => {\n      this.promises.delete(item.id);\n      this.processing.delete(item.id);\n      this.process();\n    });\n    return promise;\n  }\n  process() {\n    if (this.processing.size >= this.maxConcurrency || this.queue.length === 0) {\n      return;\n    }\n    const item = this.queue.shift();\n    if (!item || this.processing.has(item.id)) {\n      return;\n    }\n    this.processing.add(item.id);\n    item.func();\n  }\n  clear() {\n    this.queue = [];\n  }\n  clearProcessing() {\n    this.processing.clear();\n  }\n  clearAll() {\n    this.clear();\n    this.clearProcessing();\n  }\n  length() {\n    return this.queue.length;\n  }\n};\n\n// src/ndk/index.ts\nvar DEFAULT_OUTBOX_RELAYS = [\"wss://purplepag.es/\", \"wss://nos.lol/\"];\nvar DEFAULT_BLACKLISTED_RELAYS = [\n  \"wss://brb.io/\",\n  // BRB\n  \"wss://nostr.mutinywallet.com/\"\n  // Don't try to read from this relay since it's a write-only relay\n  // \"wss://purplepag.es/\", // This is a hack, since this is a mostly read-only relay, but not fully. Once we have relay routing this can be removed so it only receives the supported kinds\n];\nvar NDK = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  _explicitRelayUrls;\n  blacklistRelayUrls;\n  pool;\n  outboxPool;\n  _signer;\n  _activeUser;\n  cacheAdapter;\n  debug;\n  devWriteRelaySet;\n  outboxTracker;\n  mutedIds;\n  clientName;\n  clientNip89;\n  queuesZapConfig;\n  queuesNip05;\n  asyncSigVerification = false;\n  initialValidationRatio = 1;\n  lowestValidationRatio = 0.1;\n  validationRatioFn;\n  autoBlacklistInvalidRelays = false;\n  subManager;\n  /**\n   * Private storage for the signature verification function\n   */\n  _signatureVerificationFunction;\n  /**\n   * Private storage for the signature verification worker\n   */\n  _signatureVerificationWorker;\n  /**\n   * Rolling total of time spent (in ms) performing signature verifications.\n   * Users can read this to monitor or display aggregate verification cost.\n   */\n  signatureVerificationTimeMs = 0;\n  publishingFailureHandled = false;\n  pools = [];\n  /**\n   * Default relay-auth policy that will be used when a relay requests authentication,\n   * if no other policy is specified for that relay.\n   *\n   * @example Disconnect from relays that request authentication:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.disconnect(ndk.pool);\n   * ```\n   *\n   * @example Sign in to relays that request authentication:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.signIn({ndk})\n   * ```\n   *\n   * @example Sign in to relays that request authentication, asking the user for confirmation:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = (relay: NDKRelay) => {\n   *     const signIn = NDKAuthPolicies.signIn({ndk});\n   *     if (confirm(`Relay ${relay.url} is requesting authentication, do you want to sign in?`)) {\n   *        signIn(relay);\n   *     }\n   * }\n   * ```\n   */\n  relayAuthDefaultPolicy;\n  /**\n   * Fetch function to use for HTTP requests.\n   *\n   * @example\n   * ```typescript\n   * import fetch from \"node-fetch\";\n   *\n   * ndk.httpFetch = fetch;\n   * ```\n   */\n  httpFetch;\n  /**\n   * Provide a caller function to receive all networking traffic from relays\n   */\n  netDebug;\n  autoConnectUserRelays = true;\n  autoFetchUserMutelist = true;\n  walletConfig;\n  constructor(opts = {}) {\n    super();\n    this.debug = opts.debug || debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk\");\n    this.netDebug = opts.netDebug;\n    this._explicitRelayUrls = opts.explicitRelayUrls || [];\n    this.blacklistRelayUrls = opts.blacklistRelayUrls || DEFAULT_BLACKLISTED_RELAYS;\n    this.subManager = new NDKSubscriptionManager();\n    this.pool = new NDKPool(opts.explicitRelayUrls || [], [], this);\n    this.pool.name = \"Main\";\n    this.pool.on(\"relay:auth\", async (relay, challenge) => {\n      if (this.relayAuthDefaultPolicy) {\n        await this.relayAuthDefaultPolicy(relay, challenge);\n      }\n    });\n    this.autoConnectUserRelays = opts.autoConnectUserRelays ?? true;\n    this.autoFetchUserMutelist = opts.autoFetchUserMutelist ?? true;\n    this.clientName = opts.clientName;\n    this.clientNip89 = opts.clientNip89;\n    this.relayAuthDefaultPolicy = opts.relayAuthDefaultPolicy;\n    if (opts.enableOutboxModel) {\n      this.outboxPool = new NDKPool(opts.outboxRelayUrls || DEFAULT_OUTBOX_RELAYS, [], this, {\n        debug: this.debug.extend(\"outbox-pool\"),\n        name: \"Outbox Pool\"\n      });\n      this.outboxTracker = new OutboxTracker(this);\n    }\n    this.signer = opts.signer;\n    this.cacheAdapter = opts.cacheAdapter;\n    this.mutedIds = opts.mutedIds || /* @__PURE__ */ new Map();\n    if (opts.devWriteRelayUrls) {\n      this.devWriteRelaySet = NDKRelaySet.fromRelayUrls(opts.devWriteRelayUrls, this);\n    }\n    this.queuesZapConfig = new Queue(\"zaps\", 3);\n    this.queuesNip05 = new Queue(\"nip05\", 10);\n    if (opts.signatureVerificationWorker) {\n      this.signatureVerificationWorker = opts.signatureVerificationWorker;\n    }\n    if (opts.signatureVerificationFunction) {\n      this.signatureVerificationFunction = opts.signatureVerificationFunction;\n    }\n    this.initialValidationRatio = opts.initialValidationRatio || 1;\n    this.lowestValidationRatio = opts.lowestValidationRatio || 0.1;\n    this.autoBlacklistInvalidRelays = opts.autoBlacklistInvalidRelays || false;\n    this.validationRatioFn = opts.validationRatioFn || this.defaultValidationRatioFn;\n    try {\n      this.httpFetch = fetch;\n    } catch {\n    }\n  }\n  set explicitRelayUrls(urls) {\n    this._explicitRelayUrls = urls.map(normalizeRelayUrl);\n    this.pool.relayUrls = urls;\n  }\n  get explicitRelayUrls() {\n    return this._explicitRelayUrls || [];\n  }\n  /**\n   * Set a Web Worker for signature verification.\n   *\n   * This method initializes the worker and sets the asyncSigVerification flag.\n   * The actual verification is handled by the verifySignatureAsync function in signature.ts,\n   * which will use the worker if available.\n   */\n  set signatureVerificationWorker(worker2) {\n    this._signatureVerificationWorker = worker2;\n    if (worker2) {\n      signatureVerificationInit(worker2);\n      this.asyncSigVerification = true;\n    } else {\n      this.asyncSigVerification = false;\n    }\n  }\n  /**\n   * Set a custom signature verification function.\n   *\n   * This method is particularly useful for platforms that don't support Web Workers,\n   * such as React Native.\n   *\n   * When a function is provided, it will be used for signature verification\n   * instead of the default worker-based verification. This enables signature\n   * verification on platforms where Web Workers are not available.\n   *\n   * @example\n   * ```typescript\n   * import { verifySignatureAsync } from \"@nostr-dev-kit/ndk-mobile\";\n   *\n   * ndk.signatureVerificationFunction = verifySignatureAsync;\n   * ```\n   */\n  set signatureVerificationFunction(fn) {\n    this._signatureVerificationFunction = fn;\n    this.asyncSigVerification = !!fn;\n  }\n  /**\n   * Get the custom signature verification function\n   */\n  get signatureVerificationFunction() {\n    return this._signatureVerificationFunction;\n  }\n  /**\n   * Adds an explicit relay to the pool.\n   * @param url\n   * @param relayAuthPolicy Authentication policy to use if different from the default\n   * @param connect Whether to connect to the relay automatically\n   * @returns\n   */\n  addExplicitRelay(urlOrRelay, relayAuthPolicy, connect = true) {\n    let relay;\n    if (typeof urlOrRelay === \"string\") {\n      relay = new NDKRelay(urlOrRelay, relayAuthPolicy, this);\n    } else {\n      relay = urlOrRelay;\n    }\n    this.pool.addRelay(relay, connect);\n    this.explicitRelayUrls?.push(relay.url);\n    return relay;\n  }\n  toJSON() {\n    return { relayCount: this.pool.relays.size }.toString();\n  }\n  get activeUser() {\n    return this._activeUser;\n  }\n  /**\n   * Sets the active user for this NDK instance, typically this will be\n   * called when assigning a signer to the NDK instance.\n   *\n   * This function will automatically connect to the user's relays if\n   * `autoConnectUserRelays` is set to true.\n   *\n   * It will also fetch the user's mutelist if `autoFetchUserMutelist` is set to true.\n   */\n  set activeUser(user) {\n    const differentUser = this._activeUser?.pubkey !== user?.pubkey;\n    this._activeUser = user;\n    if (user && differentUser) {\n      setActiveUser.call(this, user);\n    } else if (!user) {\n      this.mutedIds = /* @__PURE__ */ new Map();\n    }\n  }\n  get signer() {\n    return this._signer;\n  }\n  set signer(newSigner) {\n    this._signer = newSigner;\n    if (newSigner) this.emit(\"signer:ready\", newSigner);\n    newSigner?.user().then((user) => {\n      user.ndk = this;\n      this.activeUser = user;\n    });\n  }\n  /**\n   * Connect to relays with optional timeout.\n   * If the timeout is reached, the connection will be continued to be established in the background.\n   */\n  async connect(timeoutMs) {\n    if (this._signer && this.autoConnectUserRelays) {\n      this.debug(\n        \"Attempting to connect to user relays specified by signer %o\",\n        await this._signer.relays?.(this)\n      );\n      if (this._signer.relays) {\n        const relays = await this._signer.relays(this);\n        relays.forEach((relay) => this.pool.addRelay(relay));\n      }\n    }\n    const connections = [this.pool.connect(timeoutMs)];\n    if (this.outboxPool) {\n      connections.push(this.outboxPool.connect(timeoutMs));\n    }\n    return Promise.allSettled(connections).then(() => {\n    });\n  }\n  /**\n   * Centralized method to report an invalid signature, identifying the relay that provided it.\n   * A single invalid signature means the relay is considered malicious.\n   * All invalid signature detections (synchronous or asynchronous) should delegate to this method.\n   *\n   * @param event The event with an invalid signature\n   * @param relay The relay that provided the invalid signature\n   */\n  reportInvalidSignature(event, relay) {\n    this.debug(`Invalid signature detected for event ${event.id}${relay ? ` from relay ${relay.url}` : \"\"}`);\n    this.emit(\"event:invalid-sig\", event, relay);\n    if (this.autoBlacklistInvalidRelays && relay) {\n      this.blacklistRelay(relay.url);\n    }\n  }\n  /**\n   * Add a relay URL to the blacklist as it has been identified as malicious\n   */\n  blacklistRelay(url) {\n    if (!this.blacklistRelayUrls) {\n      this.blacklistRelayUrls = [];\n    }\n    if (!this.blacklistRelayUrls.includes(url)) {\n      this.blacklistRelayUrls.push(url);\n      this.debug(`Added relay to blacklist: ${url}`);\n      const relay = this.pool.getRelay(url, false, false);\n      if (relay) {\n        relay.disconnect();\n        this.debug(`Disconnected from blacklisted relay: ${url}`);\n      }\n    }\n  }\n  /**\n   * Default function to calculate validation ratio based on historical validation results.\n   * The more events validated successfully, the lower the ratio goes (down to the minimum).\n   */\n  defaultValidationRatioFn(relay, validatedCount, nonValidatedCount) {\n    if (validatedCount < 10) return this.initialValidationRatio;\n    const trustFactor = Math.min(validatedCount / 100, 1);\n    const calculatedRatio = this.initialValidationRatio * (1 - trustFactor) + this.lowestValidationRatio * trustFactor;\n    return Math.max(calculatedRatio, this.lowestValidationRatio);\n  }\n  /**\n   * Get a NDKUser object\n   *\n   * @param opts\n   * @returns\n   */\n  getUser(opts) {\n    const user = new NDKUser(opts);\n    user.ndk = this;\n    return user;\n  }\n  /**\n   * Get a NDKUser from a NIP05\n   * @param nip05 NIP-05 ID\n   * @param skipCache Skip cache\n   * @returns\n   */\n  async getUserFromNip05(nip05, skipCache = false) {\n    return NDKUser.fromNip05(nip05, this, skipCache);\n  }\n  /**\n   * Creates and starts a new subscription.\n   *\n   * Subscriptions automatically start unless `autoStart` is set to `false`.\n   * You can control automatic closing on EOSE via `opts.closeOnEose`.\n   *\n   * @param filters - A single NDKFilter object or an array of filters.\n   * @param opts - Optional NDKSubscriptionOptions to customize behavior (e.g., caching, grouping).\n   * @param handlers - Optional handlers for subscription events. Passing handlers is the preferred method of using ndk.subscribe.\n   *   - `onEvent`: Called for each event received.\n   *  - `onEvents`: Called once with an array of events when the subscription starts (from the cache).\n   *  - `onEose`: Called when the subscription receives EOSE.\n   *  For backwards compatibility, this third parameter also accepts a relaySet, the relaySet should be passed via `opts.relaySet`.\n   *\n   * @param _autoStart - For backwards compatibility, this can be a boolean indicating whether to start the subscription immediately.\n   *  This parameter is deprecated and will be removed in a future version.\n   *   - `false`: Creates the subscription but does not start it (call `subscription.start()` manually).\n   * @returns The created NDKSubscription instance.\n   *\n   * @example Basic subscription\n   * ```typescript\n   * const sub = ndk.subscribe({ kinds: [1], authors: [pubkey] });\n   * sub.on(\"event\", (event) => console.log(\"Kind 1 event:\", event.content));\n   * ```\n   *\n   * @example Subscription with options and direct handlers\n   * ```typescript\n   * const sub = ndk.subscribe(\n   *   { kinds: [0], authors: [pubkey] },\n   *   { closeOnEose: true, cacheUsage: NDKSubscriptionCacheUsage.PARALLEL },\n   *   undefined, // Use default relay set calculation\n   *   {\n   *     onEvents: (events) => { // Renamed parameter\n   *       if (events.length > 0) {\n   *         console.log(`Got ${events.length} profile events from cache:`, events[0].content);\n   *       }\n   *     },\n   *     onEvent: (event) => { // Renamed parameter\n   *       console.log(\"Got profile update from relay:\", event.content); // Clarified source\n   *     },\n   *     onEose: () => console.log(\"Profile subscription finished.\")\n   *   }\n   * );\n   * ```\n   *\n   * @since 2.13.0 `relaySet` parameter removed; pass `relaySet` or `relayUrls` via `opts`.\n   */\n  subscribe(filters, opts, autoStartOrRelaySet = true, _autoStart = true) {\n    let _relaySet = opts?.relaySet;\n    let autoStart = _autoStart;\n    if (autoStartOrRelaySet instanceof NDKRelaySet) {\n      console.warn(\"relaySet is deprecated, use opts.relaySet instead. This will be removed in version v2.14.0\");\n      _relaySet = autoStartOrRelaySet;\n      autoStart = _autoStart;\n    } else if (typeof autoStartOrRelaySet === \"boolean\" || typeof autoStartOrRelaySet === \"object\") {\n      autoStart = autoStartOrRelaySet;\n    }\n    const subscription = new NDKSubscription(this, filters, { relaySet: _relaySet, ...opts });\n    this.subManager.add(subscription);\n    const pool = subscription.pool;\n    if (subscription.relaySet) {\n      for (const relay of subscription.relaySet.relays) {\n        pool.useTemporaryRelay(relay, void 0, subscription.filters);\n      }\n    }\n    if (this.outboxPool && subscription.hasAuthorsFilter()) {\n      const authors = subscription.filters.filter((filter) => filter.authors && filter.authors?.length > 0).flatMap((filter) => filter.authors);\n      this.outboxTracker?.trackUsers(authors);\n    }\n    if (autoStart) {\n      let eventsHandler;\n      if (typeof autoStart === \"object\") {\n        if (autoStart.onEvent) subscription.on(\"event\", autoStart.onEvent);\n        if (autoStart.onEose) subscription.on(\"eose\", autoStart.onEose);\n        if (autoStart.onEvents) eventsHandler = autoStart.onEvents;\n      }\n      setTimeout(() => {\n        const cachedEvents = subscription.start(!eventsHandler);\n        if (cachedEvents && cachedEvents.length > 0 && !!eventsHandler) eventsHandler(cachedEvents);\n      }, 0);\n    }\n    return subscription;\n  }\n  /**\n   * Attempts to fetch an event from a tag, following relay hints and\n   * other best practices.\n   * @param tag Tag to fetch the event from\n   * @param originalEvent Event where the tag came from\n   * @param subOpts Subscription options to use when fetching the event\n   * @param fallback Fallback options to use when the hint relay doesn't respond\n   * @returns\n   */\n  fetchEventFromTag = fetchEventFromTag.bind(this);\n  /**\n   * Fetch an event from the cache synchronously.\n   * @param idOrFilter event id in bech32 format or filter\n   * @returns events from the cache or null if the cache is empty\n   */\n  fetchEventSync(idOrFilter) {\n    if (!this.cacheAdapter) throw new Error(\"Cache adapter not set\");\n    let filters;\n    if (typeof idOrFilter === \"string\") filters = [filterFromId(idOrFilter)];\n    else filters = idOrFilter;\n    const sub = new NDKSubscription(this, filters);\n    const events = this.cacheAdapter.query(sub);\n    if (events instanceof Promise) throw new Error(\"Cache adapter is async\");\n    return events.map((e) => {\n      e.ndk = this;\n      return e;\n    });\n  }\n  /**\n   * Fetch a single event.\n   *\n   * @param idOrFilter event id in bech32 format or filter\n   * @param opts subscription options\n   * @param relaySetOrRelay explicit relay set to use\n   */\n  async fetchEvent(idOrFilter, opts, relaySetOrRelay) {\n    let filters;\n    let relaySet;\n    if (relaySetOrRelay instanceof NDKRelay) {\n      relaySet = new NDKRelaySet(/* @__PURE__ */ new Set([relaySetOrRelay]), this);\n    } else if (relaySetOrRelay instanceof NDKRelaySet) {\n      relaySet = relaySetOrRelay;\n    }\n    if (!relaySetOrRelay && typeof idOrFilter === \"string\") {\n      if (!isNip33AValue(idOrFilter)) {\n        const relays = relaysFromBech32(idOrFilter, this);\n        if (relays.length > 0) {\n          relaySet = new NDKRelaySet(new Set(relays), this);\n          relaySet = correctRelaySet(relaySet, this.pool);\n        }\n      }\n    }\n    if (typeof idOrFilter === \"string\") {\n      filters = [filterFromId(idOrFilter)];\n    } else if (Array.isArray(idOrFilter)) {\n      filters = idOrFilter;\n    } else {\n      filters = [idOrFilter];\n    }\n    if (filters.length === 0) {\n      throw new Error(`Invalid filter: ${JSON.stringify(idOrFilter)}`);\n    }\n    return new Promise((resolve) => {\n      let fetchedEvent = null;\n      const subscribeOpts = {\n        ...opts || {},\n        closeOnEose: true\n      };\n      if (relaySet) subscribeOpts.relaySet = relaySet;\n      const s = this.subscribe(\n        filters,\n        subscribeOpts,\n        // relaySet, // Removed: Passed via opts\n        false\n        // autoStart = false\n      );\n      const t2 = setTimeout(() => {\n        s.stop();\n        resolve(fetchedEvent);\n      }, 1e4);\n      s.on(\"event\", (event) => {\n        event.ndk = this;\n        if (!event.isReplaceable()) {\n          clearTimeout(t2);\n          resolve(event);\n        } else if (!fetchedEvent || fetchedEvent.created_at < event.created_at) {\n          fetchedEvent = event;\n        }\n      });\n      s.on(\"eose\", () => {\n        clearTimeout(t2);\n        resolve(fetchedEvent);\n      });\n      s.start();\n    });\n  }\n  /**\n   * Fetch events\n   */\n  async fetchEvents(filters, opts, relaySet) {\n    return new Promise((resolve) => {\n      const events = /* @__PURE__ */ new Map();\n      const subscribeOpts = {\n        ...opts || {},\n        closeOnEose: true\n      };\n      if (relaySet) subscribeOpts.relaySet = relaySet;\n      const relaySetSubscription = this.subscribe(\n        filters,\n        subscribeOpts,\n        // relaySet, // Removed: Passed via opts\n        false\n        // autoStart = false\n      );\n      const onEvent = (event) => {\n        let _event;\n        if (!(event instanceof NDKEvent)) _event = new NDKEvent(void 0, event);\n        else _event = event;\n        const dedupKey = _event.deduplicationKey();\n        const existingEvent = events.get(dedupKey);\n        if (existingEvent) {\n          _event = dedup(existingEvent, _event);\n        }\n        _event.ndk = this;\n        events.set(dedupKey, _event);\n      };\n      relaySetSubscription.on(\"event\", onEvent);\n      relaySetSubscription.on(\"eose\", () => {\n        resolve(new Set(events.values()));\n      });\n      relaySetSubscription.start();\n    });\n  }\n  /**\n   * Ensures that a signer is available to sign an event.\n   */\n  assertSigner() {\n    if (!this.signer) {\n      this.emit(\"signer:required\");\n      throw new Error(\"Signer required\");\n    }\n  }\n  getEntity = getEntity.bind(this);\n  set wallet(wallet) {\n    if (!wallet) {\n      this.walletConfig = void 0;\n      return;\n    }\n    this.walletConfig ??= {};\n    this.walletConfig.lnPay = wallet?.lnPay?.bind(wallet);\n    this.walletConfig.cashuPay = wallet?.cashuPay?.bind(wallet);\n  }\n};\n\n// src/zap/invoice.ts\n\nfunction zapInvoiceFromEvent(event) {\n  const description = event.getMatchingTags(\"description\")[0];\n  const bolt11 = event.getMatchingTags(\"bolt11\")[0];\n  let decodedInvoice;\n  let zapRequest;\n  if (!description || !bolt11 || !bolt11[1]) {\n    return null;\n  }\n  try {\n    let zapRequestPayload = description[1];\n    if (zapRequestPayload.startsWith(\"%\")) {\n      zapRequestPayload = decodeURIComponent(zapRequestPayload);\n    }\n    if (zapRequestPayload === \"\") {\n      return null;\n    }\n    zapRequest = JSON.parse(zapRequestPayload);\n    decodedInvoice = (0,light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_7__.decode)(bolt11[1]);\n  } catch (_e) {\n    return null;\n  }\n  const amountSection = decodedInvoice.sections.find((s) => s.name === \"amount\");\n  if (!amountSection) {\n    return null;\n  }\n  const amount = Number.parseInt(amountSection.value);\n  if (!amount) {\n    return null;\n  }\n  const content = zapRequest.content;\n  const sender = zapRequest.pubkey;\n  const recipientTag = event.getMatchingTags(\"p\")[0];\n  const recipient = recipientTag[1];\n  let zappedEvent = event.getMatchingTags(\"e\")[0];\n  if (!zappedEvent) {\n    zappedEvent = event.getMatchingTags(\"a\")[0];\n  }\n  const zappedEventId = zappedEvent ? zappedEvent[1] : void 0;\n  const zapInvoice = {\n    id: event.id,\n    zapper: event.pubkey,\n    zappee: sender,\n    zapped: recipient,\n    zappedEvent: zappedEventId,\n    amount,\n    comment: content\n  };\n  return zapInvoice;\n}\n\n// src/zapper/index.ts\n\n\n\n// src/zapper/ln.ts\n\n\nvar d2 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:zapper:ln\");\nasync function getNip57ZapSpecFromLud({ lud06, lud16 }, ndk) {\n  let zapEndpoint;\n  if (lud16 && !lud16.startsWith(\"LNURL\")) {\n    const [name, domain] = lud16.split(\"@\");\n    zapEndpoint = `https://${domain}/.well-known/lnurlp/${name}`;\n  } else if (lud06) {\n    const { words } = _scure_base__WEBPACK_IMPORTED_MODULE_8__.bech32.decode(lud06, 1e3);\n    const data = _scure_base__WEBPACK_IMPORTED_MODULE_8__.bech32.fromWords(words);\n    const utf8Decoder = new TextDecoder(\"utf-8\");\n    zapEndpoint = utf8Decoder.decode(data);\n  }\n  if (!zapEndpoint) {\n    d2(\"No zap endpoint found %o\", { lud06, lud16 });\n    throw new Error(\"No zap endpoint found\");\n  }\n  try {\n    const _fetch = ndk.httpFetch || fetch;\n    const response = await _fetch(zapEndpoint);\n    if (response.status !== 200) {\n      const text = await response.text();\n      throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${text}`);\n    }\n    return await response.json();\n  } catch (e) {\n    throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${e}`);\n  }\n}\n\n// src/zapper/nip57.ts\n\nasync function generateZapRequest(target, ndk, data, pubkey, amount, relays, comment, tags, signer) {\n  const zapEndpoint = data.callback;\n  const zapRequest = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip57.makeZapRequest({\n    profile: pubkey,\n    // set the event to null since nostr-tools doesn't support nip-33 zaps\n    event: null,\n    amount,\n    comment: comment || \"\",\n    relays: relays.slice(0, 4)\n  });\n  if (target instanceof NDKEvent) {\n    const tags2 = target.referenceTags();\n    const nonPTags = tags2.filter((tag) => tag[0] !== \"p\");\n    zapRequest.tags.push(...nonPTags);\n  }\n  zapRequest.tags.push([\"lnurl\", zapEndpoint]);\n  const event = new NDKEvent(ndk, zapRequest);\n  if (tags) {\n    event.tags = event.tags.concat(tags);\n  }\n  const eTaggedEvents = /* @__PURE__ */ new Set();\n  const aTaggedEvents = /* @__PURE__ */ new Set();\n  for (const tag of event.tags) {\n    if (tag[0] === \"e\") {\n      eTaggedEvents.add(tag[1]);\n    } else if (tag[0] === \"a\") {\n      aTaggedEvents.add(tag[1]);\n    }\n  }\n  if (eTaggedEvents.size > 1) throw new Error(\"Only one e-tag is allowed\");\n  if (aTaggedEvents.size > 1) throw new Error(\"Only one a-tag is allowed\");\n  event.tags = event.tags.filter((tag) => tag[0] !== \"p\");\n  event.tags.push([\"p\", pubkey]);\n  await event.sign(signer);\n  return event;\n}\n\n// src/zapper/index.ts\nvar d3 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:zapper\");\nvar NDKZapper = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  target;\n  ndk;\n  comment;\n  amount;\n  unit;\n  tags;\n  signer;\n  zapMethod;\n  nutzapAsFallback;\n  lnPay;\n  /**\n   * Called when a cashu payment is to be made.\n   * This function should swap/mint proofs for the required amount, in the required unit,\n   * in any of the provided mints and return the proofs and mint used.\n   */\n  cashuPay;\n  onComplete;\n  maxRelays = 3;\n  /**\n   *\n   * @param target The target of the zap\n   * @param amount The amount to send indicated in the unit\n   * @param unit The unit of the amount\n   * @param opts Options for the zap\n   */\n  constructor(target, amount, unit = \"msat\", opts = {}) {\n    super();\n    this.target = target;\n    this.ndk = opts.ndk || target.ndk;\n    if (!this.ndk) {\n      throw new Error(\"No NDK instance provided\");\n    }\n    this.amount = amount;\n    this.comment = opts.comment;\n    this.unit = unit;\n    this.tags = opts.tags;\n    this.signer = opts.signer;\n    this.nutzapAsFallback = opts.nutzapAsFallback ?? false;\n    this.lnPay = opts.lnPay || this.ndk.walletConfig?.lnPay;\n    this.cashuPay = opts.cashuPay || this.ndk.walletConfig?.cashuPay;\n    this.onComplete = opts.onComplete || this.ndk.walletConfig?.onPaymentComplete;\n  }\n  /**\n   * Initiate zapping process\n   *\n   * This function will calculate the splits for this zap and initiate each zap split.\n   */\n  async zap(methods) {\n    const splits = this.getZapSplits();\n    const results = /* @__PURE__ */ new Map();\n    await Promise.all(\n      splits.map(async (split) => {\n        let result;\n        try {\n          result = await this.zapSplit(split, methods);\n        } catch (e) {\n          result = new Error(e.message);\n        }\n        this.emit(\"split:complete\", split, result);\n        results.set(split, result);\n      })\n    );\n    this.emit(\"complete\", results);\n    if (this.onComplete) this.onComplete(results);\n    return results;\n  }\n  async zapNip57(split, data) {\n    if (!this.lnPay) throw new Error(\"No lnPay function available\");\n    const zapSpec = await getNip57ZapSpecFromLud(data, this.ndk);\n    if (!zapSpec) throw new Error(\"No zap spec available for recipient\");\n    const relays = await this.relays(split.pubkey);\n    const zapRequest = await generateZapRequest(\n      this.target,\n      this.ndk,\n      zapSpec,\n      split.pubkey,\n      split.amount,\n      relays,\n      this.comment,\n      this.tags,\n      this.signer\n    );\n    if (!zapRequest) {\n      d3(\"Unable to generate zap request\");\n      throw new Error(\"Unable to generate zap request\");\n    }\n    const pr = await this.getLnInvoice(zapRequest, split.amount, zapSpec);\n    if (!pr) {\n      d3(\"Unable to get payment request\");\n      throw new Error(\"Unable to get payment request\");\n    }\n    this.emit(\"ln_invoice\", {\n      amount: split.amount,\n      recipientPubkey: split.pubkey,\n      unit: this.unit,\n      nip57ZapRequest: zapRequest,\n      pr,\n      type: \"nip57\"\n    });\n    const res = await this.lnPay({\n      target: this.target,\n      recipientPubkey: split.pubkey,\n      paymentDescription: \"NIP-57 Zap\",\n      pr,\n      amount: split.amount,\n      unit: this.unit,\n      nip57ZapRequest: zapRequest\n    });\n    if (res?.preimage) {\n      this.emit(\"ln_payment\", {\n        preimage: res.preimage,\n        amount: split.amount,\n        recipientPubkey: split.pubkey,\n        pr,\n        unit: this.unit,\n        nip57ZapRequest: zapRequest,\n        type: \"nip57\"\n      });\n    }\n    return res;\n  }\n  /**\n   * Fetches information about a NIP-61 zap and asks the caller to create cashu proofs for the zap.\n   *\n   * (note that the cashuPay function can use any method to create the proofs, including using lightning\n   * to mint proofs in the specified mint, the responsibility of minting the proofs is delegated to the caller (e.g. ndk-wallet))\n   */\n  async zapNip61(split, data) {\n    if (!this.cashuPay) throw new Error(\"No cashuPay function available\");\n    let ret;\n    ret = await this.cashuPay(\n      {\n        target: this.target,\n        recipientPubkey: split.pubkey,\n        paymentDescription: \"NIP-61 Zap\",\n        amount: split.amount,\n        unit: this.unit,\n        ...data ?? {}\n      },\n      (pr) => {\n        this.emit(\"ln_invoice\", {\n          pr,\n          amount: split.amount,\n          recipientPubkey: split.pubkey,\n          unit: this.unit,\n          type: \"nip61\"\n        });\n      }\n    );\n    d3(\"NIP-61 Zap result: %o\", ret);\n    if (ret instanceof Error) {\n      return ret;\n    }\n    if (ret) {\n      const { proofs, mint } = ret;\n      if (!proofs || !mint) throw new Error(`Invalid zap confirmation: missing proofs or mint: ${ret}`);\n      const relays = await this.relays(split.pubkey);\n      const relaySet = NDKRelaySet.fromRelayUrls(relays, this.ndk);\n      const nutzap = new NDKNutzap(this.ndk);\n      nutzap.tags = [...nutzap.tags, ...this.tags || []];\n      nutzap.proofs = proofs;\n      nutzap.mint = mint;\n      nutzap.target = this.target;\n      nutzap.comment = this.comment;\n      nutzap.unit = \"sat\";\n      nutzap.recipientPubkey = split.pubkey;\n      await nutzap.sign(this.signer);\n      nutzap.publish(relaySet);\n      return nutzap;\n    }\n  }\n  /**\n   * Get the zap methods available for the recipient and initiates the zap\n   * in the desired method.\n   * @param split\n   * @param methods - The methods to try, if not provided, all methods will be tried.\n   * @returns\n   */\n  async zapSplit(split, methods) {\n    const recipient = this.ndk.getUser({ pubkey: split.pubkey });\n    const zapMethods = await recipient.getZapInfo(2500);\n    let retVal;\n    const canFallbackToNip61 = this.nutzapAsFallback && this.cashuPay;\n    if (zapMethods.size === 0 && !canFallbackToNip61)\n      throw new Error(\"No zap method available for recipient and NIP-61 fallback is disabled\");\n    const nip61Fallback = async () => {\n      if (!this.nutzapAsFallback) return;\n      const relayLists = await getRelayListForUsers([split.pubkey], this.ndk);\n      let relayUrls = relayLists.get(split.pubkey)?.readRelayUrls;\n      relayUrls = this.ndk.pool.connectedRelays().map((r) => r.url);\n      return await this.zapNip61(split, {\n        // use the user's relay list\n        relays: relayUrls,\n        // lock to the user's actual pubkey\n        p2pk: split.pubkey,\n        // allow intramint fallback\n        allowIntramintFallback: !!canFallbackToNip61\n      });\n    };\n    const canUseNip61 = !methods || methods.includes(\"nip61\");\n    const canUseNip57 = !methods || methods.includes(\"nip57\");\n    const nip61Method = zapMethods.get(\"nip61\");\n    if (nip61Method && canUseNip61) {\n      try {\n        retVal = await this.zapNip61(split, nip61Method);\n        if (retVal instanceof NDKNutzap) return retVal;\n      } catch (e) {\n        this.emit(\"notice\", `NIP-61 attempt failed: ${e.message}`);\n      }\n    }\n    const nip57Method = zapMethods.get(\"nip57\");\n    if (nip57Method && canUseNip57) {\n      try {\n        retVal = await this.zapNip57(split, nip57Method);\n        if (!(retVal instanceof Error)) return retVal;\n      } catch (e) {\n        this.emit(\"notice\", `NIP-57 attempt failed: ${e.message}`);\n      }\n    }\n    if (canFallbackToNip61) {\n      retVal = await nip61Fallback();\n      if (retVal instanceof Error) throw retVal;\n      return retVal;\n    }\n    this.emit(\"notice\", \"Zap methods exhausted and there was no fallback to NIP-61\");\n    if (retVal instanceof Error) throw retVal;\n    return retVal;\n  }\n  /**\n   * Gets a bolt11 for a nip57 zap\n   * @param event\n   * @param amount\n   * @param zapEndpoint\n   * @returns\n   */\n  async getLnInvoice(zapRequest, amount, data) {\n    const zapEndpoint = data.callback;\n    const eventPayload = JSON.stringify(zapRequest.rawEvent());\n    d3(\n      `Fetching invoice from ${zapEndpoint}?${new URLSearchParams({\n        amount: amount.toString(),\n        nostr: eventPayload\n      })}`\n    );\n    const url = new URL(zapEndpoint);\n    url.searchParams.append(\"amount\", amount.toString());\n    url.searchParams.append(\"nostr\", eventPayload);\n    d3(`Fetching invoice from ${url.toString()}`);\n    const response = await fetch(url.toString());\n    d3(`Got response from zap endpoint: ${zapEndpoint}`, { status: response.status });\n    if (response.status !== 200) {\n      d3(`Received non-200 status from zap endpoint: ${zapEndpoint}`, {\n        status: response.status,\n        amount,\n        nostr: eventPayload\n      });\n      const text = await response.text();\n      throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${text}`);\n    }\n    const body = await response.json();\n    return body.pr;\n  }\n  getZapSplits() {\n    if (this.target instanceof NDKUser) {\n      return [\n        {\n          pubkey: this.target.pubkey,\n          amount: this.amount\n        }\n      ];\n    }\n    const zapTags = this.target.getMatchingTags(\"zap\");\n    if (zapTags.length === 0) {\n      return [\n        {\n          pubkey: this.target.pubkey,\n          amount: this.amount\n        }\n      ];\n    }\n    const splits = [];\n    const total = zapTags.reduce((acc, tag) => acc + Number.parseInt(tag[2]), 0);\n    for (const tag of zapTags) {\n      const pubkey = tag[1];\n      const amount = Math.floor(Number.parseInt(tag[2]) / total * this.amount);\n      splits.push({ pubkey, amount });\n    }\n    return splits;\n  }\n  /**\n   * Gets the zap method that should be used to zap a pubbkey\n   * @param ndk\n   * @param pubkey\n   * @returns\n   */\n  async getZapMethods(ndk, recipient, timeout = 2500) {\n    const user = ndk.getUser({ pubkey: recipient });\n    return await user.getZapInfo(timeout);\n  }\n  /**\n   * @returns the relays to use for the zap request\n   */\n  async relays(pubkey) {\n    let r = [];\n    if (this.ndk?.activeUser) {\n      const relayLists = await getRelayListForUsers([this.ndk.activeUser.pubkey, pubkey], this.ndk);\n      const relayScores = /* @__PURE__ */ new Map();\n      for (const relayList of relayLists.values()) {\n        for (const url of relayList.readRelayUrls) {\n          const score = relayScores.get(url) || 0;\n          relayScores.set(url, score + 1);\n        }\n      }\n      r = Array.from(relayScores.entries()).sort((a, b) => b[1] - a[1]).map(([url]) => url).slice(0, this.maxRelays);\n    }\n    if (this.ndk?.pool?.permanentAndConnectedRelays().length) {\n      r = this.ndk.pool.permanentAndConnectedRelays().map((relay) => relay.url);\n    }\n    if (!r.length) {\n      r = [];\n    }\n    return r;\n  }\n};\n\n// src/utils/filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    return false;\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {\n    return false;\n  }\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    return false;\n  }\n  for (const f in filter) {\n    if (f[0] === \"#\") {\n      const tagName = f.slice(1);\n      if (tagName === \"t\") {\n        const values = filter[`#${tagName}`]?.map((v) => v.toLowerCase());\n        if (values && !event.tags.find(([t, v]) => t === tagName && values?.indexOf(v.toLowerCase()) !== -1))\n          return false;\n      } else {\n        const values = filter[`#${tagName}`];\n        if (values && !event.tags.find(([t, v]) => t === tagName && values?.indexOf(v) !== -1)) return false;\n      }\n    }\n  }\n  if (filter.since && event.created_at < filter.since) return false;\n  if (filter.until && event.created_at > filter.until) return false;\n  return true;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vc3RyLWRldi1raXQrbmRrQDIuMTQuMjRfbm9zdHItdG9vbHNAMi4xNC4yX3R5cGVzY3JpcHRANS44LjNfL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUI7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0Esa0NBQWtDLEdBQUc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSyxhQUFhLEtBQUs7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMyQjtBQUNVOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxLQUFLO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUNBQXlDLGtCQUFrQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQkFBa0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsR0FBRztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLCtDQUErQyxrQkFBa0IsSUFBSSxjQUFjO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFDQUFxQyxtQkFBbUIsNEJBQTRCLFFBQVE7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQSxLQUFLO0FBQ0wseUJBQXlCLGlDQUFpQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLFVBQVU7QUFDaEc7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0EsS0FBSztBQUNMLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBLHVDQUF1QyxpQkFBaUI7QUFDeEQsS0FBSztBQUNMLDJCQUEyQixHQUFHLElBQUkscUNBQXFDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixNQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8scUJBQXFCLGVBQWUsSUFBSSxxREFBcUQsR0FBRztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFVBQVU7QUFDL0MsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxrQkFBa0IsSUFBSSxHQUFHLE9BQU87QUFDaEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw4Q0FBOEMsdUJBQXVCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMERBQTBELG1CQUFtQixFQUFFLFVBQVU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx1QkFBdUIsMkNBQTJDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtDQUFNLGNBQWMsSUFBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVUsSUFBSSxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsdUZBQXVGLFVBQVU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxVQUFVO0FBQzdFO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0NBQWtDLG1DQUFtQztBQUNyRTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQ0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELElBQUk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLEVBQUUsOENBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QixNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsOENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsU0FBUyw4Q0FBTTtBQUNmOztBQUVBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3NEO0FBQ3RELDRCQUE0QiwrQ0FBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLLEVBQUUsRUFBRTtBQUM3QjtBQUNBLE1BQU07QUFDTixrQkFBa0IsS0FBSyxFQUFFLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsdUJBQXVCLEtBQUssR0FBRyxPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxrQ0FBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRCx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LGtCQUFrQjs7QUFFekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQ0FBa0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJDQUEyQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4Q0FBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCLEdBQUcsb0JBQW9CLEdBQUcsd0JBQXdCO0FBQ3hGO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUFNO0FBQ3RCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOENBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUNBQWlDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrQ0FBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsbUNBQW1DO0FBQ3JGO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUNBQW1DO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseUNBQXlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsK0JBQStCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0Esc0NBQXNDLHFCQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseURBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCw0REFBNEQsYUFBYTtBQUN6RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNpQztBQUNqQztBQUNBLGFBQWEsa0NBQVk7QUFDekI7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixzREFBc0QsVUFBVTtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkJBQTZCLElBQUk7QUFDbkQsYUFBYSxrQ0FBWTtBQUN6QjtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtDQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BELDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdFQUFnRTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU8sR0FBRyxPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsWUFBWTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw0QkFBNEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQzJCO0FBQzJCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNzRDtBQUNPOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBMEQ7QUFDbEUsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQ0FBcUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsK0NBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQVM7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlEQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDaUM7QUFDakMsYUFBYSxrQ0FBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXlIRSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhYmxvZmVybmFuZGV6L3Rlc3QxMjMvVEVORVgtcGZrbWM5L21haW4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bub3N0ci1kZXYta2l0K25ka0AyLjE0LjI0X25vc3RyLXRvb2xzQDIuMTQuMl90eXBlc2NyaXB0QDUuOC4zXy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy90eXBlcy50c1xudmFyIE5ka051dHphcFN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ka051dHphcFN0YXR1czIpID0+IHtcbiAgTmRrTnV0emFwU3RhdHVzMltcIklOSVRJQUxcIl0gPSBcImluaXRpYWxcIjtcbiAgTmRrTnV0emFwU3RhdHVzMltcIlBST0NFU1NJTkdcIl0gPSBcInByb2Nlc3NpbmdcIjtcbiAgTmRrTnV0emFwU3RhdHVzMltcIlJFREVFTUVEXCJdID0gXCJyZWRlZW1lZFwiO1xuICBOZGtOdXR6YXBTdGF0dXMyW1wiU1BFTlRcIl0gPSBcInNwZW50XCI7XG4gIE5ka051dHphcFN0YXR1czJbXCJNSVNTSU5HX1BSSVZLRVlcIl0gPSBcIm1pc3NpbmdfcHJpdmtleVwiO1xuICBOZGtOdXR6YXBTdGF0dXMyW1wiVEVNUE9SQVJZX0VSUk9SXCJdID0gXCJ0ZW1wb3JhcnlfZXJyb3JcIjtcbiAgTmRrTnV0emFwU3RhdHVzMltcIlBFUk1BTkVOVF9FUlJPUlwiXSA9IFwicGVybWFuZW50X2Vycm9yXCI7XG4gIE5ka051dHphcFN0YXR1czJbXCJJTlZBTElEX05VVFpBUFwiXSA9IFwiaW52YWxpZF9udXR6YXBcIjtcbiAgcmV0dXJuIE5ka051dHphcFN0YXR1czI7XG59KShOZGtOdXR6YXBTdGF0dXMgfHwge30pO1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2luZGV4LnRzXG52YXIgTkRLS2luZCA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ES0tpbmQyKSA9PiB7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTWV0YWRhdGFcIl0gPSAwXSA9IFwiTWV0YWRhdGFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJUZXh0XCJdID0gMV0gPSBcIlRleHRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJSZWNvbW1lbmRSZWxheVwiXSA9IDJdID0gXCJSZWNvbW1lbmRSZWxheVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNvbnRhY3RzXCJdID0gM10gPSBcIkNvbnRhY3RzXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRW5jcnlwdGVkRGlyZWN0TWVzc2FnZVwiXSA9IDRdID0gXCJFbmNyeXB0ZWREaXJlY3RNZXNzYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRXZlbnREZWxldGlvblwiXSA9IDVdID0gXCJFdmVudERlbGV0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUmVwb3N0XCJdID0gNl0gPSBcIlJlcG9zdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlJlYWN0aW9uXCJdID0gN10gPSBcIlJlYWN0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQmFkZ2VBd2FyZFwiXSA9IDhdID0gXCJCYWRnZUF3YXJkXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBDaGF0XCJdID0gOV0gPSBcIkdyb3VwQ2hhdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwTm90ZVwiXSA9IDExXSA9IFwiR3JvdXBOb3RlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBSZXBseVwiXSA9IDEyXSA9IFwiR3JvdXBSZXBseVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdpZnRXcmFwU2VhbFwiXSA9IDEzXSA9IFwiR2lmdFdyYXBTZWFsXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUHJpdmF0ZURpcmVjdE1lc3NhZ2VcIl0gPSAxNF0gPSBcIlByaXZhdGVEaXJlY3RNZXNzYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSW1hZ2VcIl0gPSAyMF0gPSBcIkltYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiVmlkZW9cIl0gPSAyMV0gPSBcIlZpZGVvXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU2hvcnRWaWRlb1wiXSA9IDIyXSA9IFwiU2hvcnRWaWRlb1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlN0b3J5XCJdID0gMjNdID0gXCJTdG9yeVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlZhbmlzaFwiXSA9IDYyXSA9IFwiVmFuaXNoXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVXYWxsZXRCYWNrdXBcIl0gPSAzNzVdID0gXCJDYXNodVdhbGxldEJhY2t1cFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdpZnRXcmFwXCJdID0gMTA1OV0gPSBcIkdpZnRXcmFwXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR2VuZXJpY1JlcG9zdFwiXSA9IDE2XSA9IFwiR2VuZXJpY1JlcG9zdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNoYW5uZWxDcmVhdGlvblwiXSA9IDQwXSA9IFwiQ2hhbm5lbENyZWF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2hhbm5lbE1ldGFkYXRhXCJdID0gNDFdID0gXCJDaGFubmVsTWV0YWRhdGFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDaGFubmVsTWVzc2FnZVwiXSA9IDQyXSA9IFwiQ2hhbm5lbE1lc3NhZ2VcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDaGFubmVsSGlkZU1lc3NhZ2VcIl0gPSA0M10gPSBcIkNoYW5uZWxIaWRlTWVzc2FnZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNoYW5uZWxNdXRlVXNlclwiXSA9IDQ0XSA9IFwiQ2hhbm5lbE11dGVVc2VyXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiV2lraU1lcmdlUmVxdWVzdFwiXSA9IDgxOF0gPSBcIldpa2lNZXJnZVJlcXVlc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHZW5lcmljUmVwbHlcIl0gPSAxMTExXSA9IFwiR2VuZXJpY1JlcGx5XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTWVkaWFcIl0gPSAxMDYzXSA9IFwiTWVkaWFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEcmFmdENoZWNrcG9pbnRcIl0gPSAxMjM0XSA9IFwiRHJhZnRDaGVja3BvaW50XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUmVwb3J0XCJdID0gMTk4NF0gPSBcIlJlcG9ydFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkxhYmVsXCJdID0gMTk4NV0gPSBcIkxhYmVsXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxVGV4dEV4dHJhY3Rpb25cIl0gPSA1ZTNdID0gXCJEVk1SZXFUZXh0RXh0cmFjdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcVRleHRTdW1tYXJpemF0aW9uXCJdID0gNTAwMV0gPSBcIkRWTVJlcVRleHRTdW1tYXJpemF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxVGV4dFRyYW5zbGF0aW9uXCJdID0gNTAwMl0gPSBcIkRWTVJlcVRleHRUcmFuc2xhdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcVRleHRHZW5lcmF0aW9uXCJdID0gNTA1MF0gPSBcIkRWTVJlcVRleHRHZW5lcmF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxSW1hZ2VHZW5lcmF0aW9uXCJdID0gNTEwMF0gPSBcIkRWTVJlcUltYWdlR2VuZXJhdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcVRleHRUb1NwZWVjaFwiXSA9IDUyNTBdID0gXCJEVk1SZXFUZXh0VG9TcGVlY2hcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFEaXNjb3ZlcnlOb3N0ckNvbnRlbnRcIl0gPSA1MzAwXSA9IFwiRFZNUmVxRGlzY292ZXJ5Tm9zdHJDb250ZW50XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxRGlzY292ZXJ5Tm9zdHJQZW9wbGVcIl0gPSA1MzAxXSA9IFwiRFZNUmVxRGlzY292ZXJ5Tm9zdHJQZW9wbGVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFUaW1lc3RhbXBpbmdcIl0gPSA1OTAwXSA9IFwiRFZNUmVxVGltZXN0YW1waW5nXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNRXZlbnRTY2hlZHVsZVwiXSA9IDU5MDVdID0gXCJEVk1FdmVudFNjaGVkdWxlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNSm9iRmVlZGJhY2tcIl0gPSA3ZTNdID0gXCJEVk1Kb2JGZWVkYmFja1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlN1YnNjcmliZVwiXSA9IDcwMDFdID0gXCJTdWJzY3JpYmVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJVbnN1YnNjcmliZVwiXSA9IDcwMDJdID0gXCJVbnN1YnNjcmliZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlN1YnNjcmlwdGlvblJlY2VpcHRcIl0gPSA3MDAzXSA9IFwiU3Vic2NyaXB0aW9uUmVjZWlwdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhc2h1UmVzZXJ2ZVwiXSA9IDczNzNdID0gXCJDYXNodVJlc2VydmVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXNodVF1b3RlXCJdID0gNzM3NF0gPSBcIkNhc2h1UXVvdGVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXNodVRva2VuXCJdID0gNzM3NV0gPSBcIkNhc2h1VG9rZW5cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXNodVdhbGxldFR4XCJdID0gNzM3Nl0gPSBcIkNhc2h1V2FsbGV0VHhcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cEFkbWluQWRkVXNlclwiXSA9IDllM10gPSBcIkdyb3VwQWRtaW5BZGRVc2VyXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pblJlbW92ZVVzZXJcIl0gPSA5MDAxXSA9IFwiR3JvdXBBZG1pblJlbW92ZVVzZXJcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cEFkbWluRWRpdE1ldGFkYXRhXCJdID0gOTAwMl0gPSBcIkdyb3VwQWRtaW5FZGl0TWV0YWRhdGFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cEFkbWluRWRpdFN0YXR1c1wiXSA9IDkwMDZdID0gXCJHcm91cEFkbWluRWRpdFN0YXR1c1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5DcmVhdGVHcm91cFwiXSA9IDkwMDddID0gXCJHcm91cEFkbWluQ3JlYXRlR3JvdXBcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cEFkbWluUmVxdWVzdEpvaW5cIl0gPSA5MDIxXSA9IFwiR3JvdXBBZG1pblJlcXVlc3RKb2luXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTXV0ZUxpc3RcIl0gPSAxZTRdID0gXCJNdXRlTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlBpbkxpc3RcIl0gPSAxMDAwMV0gPSBcIlBpbkxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJSZWxheUxpc3RcIl0gPSAxMDAwMl0gPSBcIlJlbGF5TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkJvb2ttYXJrTGlzdFwiXSA9IDEwMDAzXSA9IFwiQm9va21hcmtMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ29tbXVuaXR5TGlzdFwiXSA9IDEwMDA0XSA9IFwiQ29tbXVuaXR5TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlB1YmxpY0NoYXRMaXN0XCJdID0gMTAwMDVdID0gXCJQdWJsaWNDaGF0TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkJsb2NrUmVsYXlMaXN0XCJdID0gMTAwMDZdID0gXCJCbG9ja1JlbGF5TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlNlYXJjaFJlbGF5TGlzdFwiXSA9IDEwMDA3XSA9IFwiU2VhcmNoUmVsYXlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU2ltcGxlR3JvdXBMaXN0XCJdID0gMTAwMDldID0gXCJTaW1wbGVHcm91cExpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJJbnRlcmVzdExpc3RcIl0gPSAxMDAxNV0gPSBcIkludGVyZXN0TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhc2h1TWludExpc3RcIl0gPSAxMDAxOV0gPSBcIkNhc2h1TWludExpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJFbW9qaUxpc3RcIl0gPSAxMDAzMF0gPSBcIkVtb2ppTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRpcmVjdE1lc3NhZ2VSZWNlaXZlUmVsYXlMaXN0XCJdID0gMTAwNTBdID0gXCJEaXJlY3RNZXNzYWdlUmVjZWl2ZVJlbGF5TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkJsb3Nzb21MaXN0XCJdID0gMTAwNjNdID0gXCJCbG9zc29tTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk5vc3RyV2FsZXRDb25uZWN0SW5mb1wiXSA9IDEzMTk0XSA9IFwiTm9zdHJXYWxldENvbm5lY3RJbmZvXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiVGllckxpc3RcIl0gPSAxN2UzXSA9IFwiVGllckxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXNodVdhbGxldFwiXSA9IDE3Mzc1XSA9IFwiQ2FzaHVXYWxsZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJGb2xsb3dTZXRcIl0gPSAzZTRdID0gXCJGb2xsb3dTZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXRlZ29yaXplZFBlb3BsZUxpc3RcIl0gPSAzZTQgLyogRm9sbG93U2V0ICovXSA9IFwiQ2F0ZWdvcml6ZWRQZW9wbGVMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2F0ZWdvcml6ZWRCb29rbWFya0xpc3RcIl0gPSAzMDAwMV0gPSBcIkNhdGVnb3JpemVkQm9va21hcmtMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUmVsYXlTZXRcIl0gPSAzMDAwMl0gPSBcIlJlbGF5U2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2F0ZWdvcml6ZWRSZWxheUxpc3RcIl0gPSAzMDAwMiAvKiBSZWxheVNldCAqL10gPSBcIkNhdGVnb3JpemVkUmVsYXlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQm9va21hcmtTZXRcIl0gPSAzMDAwM10gPSBcIkJvb2ttYXJrU2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ3VyYXRpb25TZXRcIl0gPSAzMDAwNF0gPSBcIkN1cmF0aW9uU2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQXJ0aWNsZUN1cmF0aW9uU2V0XCJdID0gMzAwMDRdID0gXCJBcnRpY2xlQ3VyYXRpb25TZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJWaWRlb0N1cmF0aW9uU2V0XCJdID0gMzAwMDVdID0gXCJWaWRlb0N1cmF0aW9uU2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSW1hZ2VDdXJhdGlvblNldFwiXSA9IDMwMDA2XSA9IFwiSW1hZ2VDdXJhdGlvblNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkludGVyZXN0U2V0XCJdID0gMzAwMTVdID0gXCJJbnRlcmVzdFNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkludGVyZXN0c0xpc3RcIl0gPSAzMDAxNSAvKiBJbnRlcmVzdFNldCAqL10gPSBcIkludGVyZXN0c0xpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJFbW9qaVNldFwiXSA9IDMwMDMwXSA9IFwiRW1vamlTZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNb2R1bGFyQXJ0aWNsZVwiXSA9IDMwMDQwXSA9IFwiTW9kdWxhckFydGljbGVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNb2R1bGFyQXJ0aWNsZUl0ZW1cIl0gPSAzMDA0MV0gPSBcIk1vZHVsYXJBcnRpY2xlSXRlbVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIldpa2lcIl0gPSAzMDgxOF0gPSBcIldpa2lcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEcmFmdFwiXSA9IDMxMjM0XSA9IFwiRHJhZnRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJTdWJzY3JpcHRpb25UaWVyXCJdID0gMzcwMDFdID0gXCJTdWJzY3JpcHRpb25UaWVyXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRWNhc2hNaW50UmVjb21tZW5kYXRpb25cIl0gPSAzOGUzXSA9IFwiRWNhc2hNaW50UmVjb21tZW5kYXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJIaWdobGlnaHRTZXRcIl0gPSAzOTgwMl0gPSBcIkhpZ2hsaWdodFNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhdGVnb3JpemVkSGlnaGxpZ2h0TGlzdFwiXSA9IDM5ODAyIC8qIEhpZ2hsaWdodFNldCAqL10gPSBcIkNhdGVnb3JpemVkSGlnaGxpZ2h0TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk51dHphcFwiXSA9IDkzMjFdID0gXCJOdXR6YXBcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJaYXBSZXF1ZXN0XCJdID0gOTczNF0gPSBcIlphcFJlcXVlc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJaYXBcIl0gPSA5NzM1XSA9IFwiWmFwXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSGlnaGxpZ2h0XCJdID0gOTgwMl0gPSBcIkhpZ2hsaWdodFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNsaWVudEF1dGhcIl0gPSAyMjI0Ml0gPSBcIkNsaWVudEF1dGhcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJOb3N0cldhbGxldENvbm5lY3RSZXFcIl0gPSAyMzE5NF0gPSBcIk5vc3RyV2FsbGV0Q29ubmVjdFJlcVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk5vc3RyV2FsbGV0Q29ubmVjdFJlc1wiXSA9IDIzMTk1XSA9IFwiTm9zdHJXYWxsZXRDb25uZWN0UmVzXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTm9zdHJDb25uZWN0XCJdID0gMjQxMzNdID0gXCJOb3N0ckNvbm5lY3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCbG9zc29tVXBsb2FkXCJdID0gMjQyNDJdID0gXCJCbG9zc29tVXBsb2FkXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSHR0cEF1dGhcIl0gPSAyNzIzNV0gPSBcIkh0dHBBdXRoXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUHJvZmlsZUJhZGdlXCJdID0gMzAwMDhdID0gXCJQcm9maWxlQmFkZ2VcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCYWRnZURlZmluaXRpb25cIl0gPSAzMDAwOV0gPSBcIkJhZGdlRGVmaW5pdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk1hcmtldFN0YWxsXCJdID0gMzAwMTddID0gXCJNYXJrZXRTdGFsbFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk1hcmtldFByb2R1Y3RcIl0gPSAzMDAxOF0gPSBcIk1hcmtldFByb2R1Y3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJBcnRpY2xlXCJdID0gMzAwMjNdID0gXCJBcnRpY2xlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQXBwU3BlY2lmaWNEYXRhXCJdID0gMzAwNzhdID0gXCJBcHBTcGVjaWZpY0RhdGFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDbGFzc2lmaWVkXCJdID0gMzA0MDJdID0gXCJDbGFzc2lmaWVkXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSG9yaXpvbnRhbFZpZGVvXCJdID0gMzQyMzVdID0gXCJIb3Jpem9udGFsVmlkZW9cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJWZXJ0aWNhbFZpZGVvXCJdID0gMzQyMzZdID0gXCJWZXJ0aWNhbFZpZGVvXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTGVnYWN5Q2FzaHVXYWxsZXRcIl0gPSAzNzM3NV0gPSBcIkxlZ2FjeUNhc2h1V2FsbGV0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBNZXRhZGF0YVwiXSA9IDM5ZTNdID0gXCJHcm91cE1ldGFkYXRhXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pbnNcIl0gPSAzOTAwMV0gPSBcIkdyb3VwQWRtaW5zXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBNZW1iZXJzXCJdID0gMzkwMDJdID0gXCJHcm91cE1lbWJlcnNcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJGb2xsb3dQYWNrXCJdID0gMzkwODldID0gXCJGb2xsb3dQYWNrXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTWVkaWFGb2xsb3dQYWNrXCJdID0gMzkwOTJdID0gXCJNZWRpYUZvbGxvd1BhY2tcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJBcHBSZWNvbW1lbmRhdGlvblwiXSA9IDMxOTg5XSA9IFwiQXBwUmVjb21tZW5kYXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJBcHBIYW5kbGVyXCJdID0gMzE5OTBdID0gXCJBcHBIYW5kbGVyXCI7XG4gIHJldHVybiBOREtLaW5kMjtcbn0pKE5ES0tpbmQgfHwge30pO1xudmFyIE5ES0xpc3RLaW5kcyA9IFtcbiAgMWU0IC8qIE11dGVMaXN0ICovLFxuICAxMDAwMSAvKiBQaW5MaXN0ICovLFxuICAxMDAwMiAvKiBSZWxheUxpc3QgKi8sXG4gIDEwMDAzIC8qIEJvb2ttYXJrTGlzdCAqLyxcbiAgMTAwMDQgLyogQ29tbXVuaXR5TGlzdCAqLyxcbiAgMTAwMDUgLyogUHVibGljQ2hhdExpc3QgKi8sXG4gIDEwMDA2IC8qIEJsb2NrUmVsYXlMaXN0ICovLFxuICAxMDAwNyAvKiBTZWFyY2hSZWxheUxpc3QgKi8sXG4gIDEwMDE1IC8qIEludGVyZXN0TGlzdCAqLyxcbiAgMTAwMzAgLyogRW1vamlMaXN0ICovLFxuICAxMDA1MCAvKiBEaXJlY3RNZXNzYWdlUmVjZWl2ZVJlbGF5TGlzdCAqLyxcbiAgM2U0IC8qIEZvbGxvd1NldCAqLyxcbiAgMzAwMDMgLyogQm9va21hcmtTZXQgKi8sXG4gIDMwMDAxIC8qIENhdGVnb3JpemVkQm9va21hcmtMaXN0ICovLFxuICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAzMDAwMiAvKiBSZWxheVNldCAqLyxcbiAgMzAwMDQgLyogQXJ0aWNsZUN1cmF0aW9uU2V0ICovLFxuICAzMDAwNSAvKiBWaWRlb0N1cmF0aW9uU2V0ICovLFxuICAzMDAxNSAvKiBJbnRlcmVzdFNldCAqLyxcbiAgMzAwMzAgLyogRW1vamlTZXQgKi8sXG4gIDM5ODAyIC8qIEhpZ2hsaWdodFNldCAqL1xuXTtcblxuLy8gc3JjL2V2ZW50cy9pbmRleC50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjIgfSBmcm9tIFwidHNlZXBcIjtcblxuLy8gc3JjL3JlbGF5L3NldHMvY2FsY3VsYXRlLnRzXG5pbXBvcnQgY3JlYXRlRGVidWcgZnJvbSBcImRlYnVnXCI7XG5cbi8vIHNyYy9vdXRib3gvd3JpdGUudHNcbmZ1bmN0aW9uIGdldFJlbGF5c0ZvclN5bmMobmRrLCBhdXRob3IsIHR5cGUgPSBcIndyaXRlXCIpIHtcbiAgaWYgKCFuZGsub3V0Ym94VHJhY2tlcikgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgaXRlbSA9IG5kay5vdXRib3hUcmFja2VyLmRhdGEuZ2V0KGF1dGhvcik7XG4gIGlmICghaXRlbSkgcmV0dXJuIHZvaWQgMDtcbiAgaWYgKHR5cGUgPT09IFwid3JpdGVcIikge1xuICAgIHJldHVybiBpdGVtLndyaXRlUmVsYXlzO1xuICB9XG4gIHJldHVybiBpdGVtLnJlYWRSZWxheXM7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRXcml0ZVJlbGF5c0ZvcihuZGssIGF1dGhvciwgdHlwZSA9IFwid3JpdGVcIikge1xuICBpZiAoIW5kay5vdXRib3hUcmFja2VyKSByZXR1cm4gdm9pZCAwO1xuICBpZiAoIW5kay5vdXRib3hUcmFja2VyLmRhdGEuaGFzKGF1dGhvcikpIHtcbiAgICBhd2FpdCBuZGsub3V0Ym94VHJhY2tlci50cmFja1VzZXJzKFthdXRob3JdKTtcbiAgfVxuICByZXR1cm4gZ2V0UmVsYXlzRm9yU3luYyhuZGssIGF1dGhvciwgdHlwZSk7XG59XG5cbi8vIHNyYy9vdXRib3gvcmVsYXktcmFua2luZy50c1xuZnVuY3Rpb24gZ2V0VG9wUmVsYXlzRm9yQXV0aG9ycyhuZGssIGF1dGhvcnMpIHtcbiAgY29uc3QgcmVsYXlzV2l0aENvdW50ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgYXV0aG9ycy5mb3JFYWNoKChhdXRob3IpID0+IHtcbiAgICBjb25zdCB3cml0ZVJlbGF5cyA9IGdldFJlbGF5c0ZvclN5bmMobmRrLCBhdXRob3IpO1xuICAgIGlmICh3cml0ZVJlbGF5cykge1xuICAgICAgd3JpdGVSZWxheXMuZm9yRWFjaCgocmVsYXkpID0+IHtcbiAgICAgICAgY29uc3QgY291bnQgPSByZWxheXNXaXRoQ291bnQuZ2V0KHJlbGF5KSB8fCAwO1xuICAgICAgICByZWxheXNXaXRoQ291bnQuc2V0KHJlbGF5LCBjb3VudCArIDEpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgc29ydGVkUmVsYXlzID0gQXJyYXkuZnJvbShyZWxheXNXaXRoQ291bnQuZW50cmllcygpKS5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSk7XG4gIHJldHVybiBzb3J0ZWRSZWxheXMubWFwKChlbnRyeSkgPT4gZW50cnlbMF0pO1xufVxuXG4vLyBzcmMvb3V0Ym94L2luZGV4LnRzXG5mdW5jdGlvbiBnZXRBbGxSZWxheXNGb3JBbGxQdWJrZXlzKG5kaywgcHVia2V5cywgdHlwZSA9IFwicmVhZFwiKSB7XG4gIGNvbnN0IHB1YmtleXNUb1JlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGF1dGhvcnNNaXNzaW5nUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcHVia2V5cy5mb3JFYWNoKChwdWJrZXkpID0+IHtcbiAgICBjb25zdCByZWxheXMgPSBnZXRSZWxheXNGb3JTeW5jKG5kaywgcHVia2V5LCB0eXBlKTtcbiAgICBpZiAocmVsYXlzICYmIHJlbGF5cy5zaXplID4gMCkge1xuICAgICAgcmVsYXlzLmZvckVhY2goKHJlbGF5KSA9PiB7XG4gICAgICAgIGNvbnN0IHB1YmtleXNJblJlbGF5ID0gcHVia2V5c1RvUmVsYXlzLmdldChyZWxheSkgfHwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgcHVia2V5c0luUmVsYXkuYWRkKHB1YmtleSk7XG4gICAgICB9KTtcbiAgICAgIHB1YmtleXNUb1JlbGF5cy5zZXQocHVia2V5LCByZWxheXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdXRob3JzTWlzc2luZ1JlbGF5cy5hZGQocHVia2V5KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4geyBwdWJrZXlzVG9SZWxheXMsIGF1dGhvcnNNaXNzaW5nUmVsYXlzIH07XG59XG5mdW5jdGlvbiBjaG9vc2VSZWxheUNvbWJpbmF0aW9uRm9yUHVia2V5cyhuZGssIHB1YmtleXMsIHR5cGUsIHsgY291bnQsIHByZWZlcnJlZFJlbGF5cyB9ID0ge30pIHtcbiAgY291bnQgPz89IDI7XG4gIHByZWZlcnJlZFJlbGF5cyA/Pz0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgcG9vbCA9IG5kay5wb29sO1xuICBjb25zdCBjb25uZWN0ZWRSZWxheXMgPSBwb29sLmNvbm5lY3RlZFJlbGF5cygpO1xuICBjb25uZWN0ZWRSZWxheXMuZm9yRWFjaCgocmVsYXkpID0+IHtcbiAgICBwcmVmZXJyZWRSZWxheXM/LmFkZChyZWxheS51cmwpO1xuICB9KTtcbiAgY29uc3QgcmVsYXlUb0F1dGhvcnNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB7IHB1YmtleXNUb1JlbGF5cywgYXV0aG9yc01pc3NpbmdSZWxheXMgfSA9IGdldEFsbFJlbGF5c0ZvckFsbFB1YmtleXMobmRrLCBwdWJrZXlzLCB0eXBlKTtcbiAgY29uc3Qgc29ydGVkUmVsYXlzID0gZ2V0VG9wUmVsYXlzRm9yQXV0aG9ycyhuZGssIHB1YmtleXMpO1xuICBjb25zdCBhZGRBdXRob3JUb1JlbGF5ID0gKGF1dGhvciwgcmVsYXkpID0+IHtcbiAgICBjb25zdCBhdXRob3JzSW5SZWxheSA9IHJlbGF5VG9BdXRob3JzTWFwLmdldChyZWxheSkgfHwgW107XG4gICAgYXV0aG9yc0luUmVsYXkucHVzaChhdXRob3IpO1xuICAgIHJlbGF5VG9BdXRob3JzTWFwLnNldChyZWxheSwgYXV0aG9yc0luUmVsYXkpO1xuICB9O1xuICBmb3IgKGNvbnN0IFthdXRob3IsIGF1dGhvclJlbGF5c10gb2YgcHVia2V5c1RvUmVsYXlzLmVudHJpZXMoKSkge1xuICAgIGxldCBtaXNzaW5nUmVsYXlDb3VudCA9IGNvdW50O1xuICAgIGZvciAoY29uc3QgcmVsYXkgb2YgY29ubmVjdGVkUmVsYXlzKSB7XG4gICAgICBpZiAoYXV0aG9yUmVsYXlzLmhhcyhyZWxheS51cmwpKSB7XG4gICAgICAgIGFkZEF1dGhvclRvUmVsYXkoYXV0aG9yLCByZWxheS51cmwpO1xuICAgICAgICBtaXNzaW5nUmVsYXlDb3VudC0tO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGF1dGhvclJlbGF5IG9mIGF1dGhvclJlbGF5cykge1xuICAgICAgaWYgKHJlbGF5VG9BdXRob3JzTWFwLmhhcyhhdXRob3JSZWxheSkpIHtcbiAgICAgICAgYWRkQXV0aG9yVG9SZWxheShhdXRob3IsIGF1dGhvclJlbGF5KTtcbiAgICAgICAgbWlzc2luZ1JlbGF5Q291bnQtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pc3NpbmdSZWxheUNvdW50IDw9IDApIGNvbnRpbnVlO1xuICAgIGZvciAoY29uc3QgcmVsYXkgb2Ygc29ydGVkUmVsYXlzKSB7XG4gICAgICBpZiAobWlzc2luZ1JlbGF5Q291bnQgPD0gMCkgYnJlYWs7XG4gICAgICBpZiAoYXV0aG9yUmVsYXlzLmhhcyhyZWxheSkpIHtcbiAgICAgICAgYWRkQXV0aG9yVG9SZWxheShhdXRob3IsIHJlbGF5KTtcbiAgICAgICAgbWlzc2luZ1JlbGF5Q291bnQtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBhdXRob3Igb2YgYXV0aG9yc01pc3NpbmdSZWxheXMpIHtcbiAgICBwb29sLnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLmZvckVhY2goKHJlbGF5KSA9PiB7XG4gICAgICBjb25zdCBhdXRob3JzSW5SZWxheSA9IHJlbGF5VG9BdXRob3JzTWFwLmdldChyZWxheS51cmwpIHx8IFtdO1xuICAgICAgYXV0aG9yc0luUmVsYXkucHVzaChhdXRob3IpO1xuICAgICAgcmVsYXlUb0F1dGhvcnNNYXAuc2V0KHJlbGF5LnVybCwgYXV0aG9yc0luUmVsYXkpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByZWxheVRvQXV0aG9yc01hcDtcbn1cblxuLy8gc3JjL291dGJveC9yZWFkL3dpdGgtYXV0aG9ycy50c1xuZnVuY3Rpb24gZ2V0UmVsYXlzRm9yRmlsdGVyV2l0aEF1dGhvcnMobmRrLCBhdXRob3JzLCByZWxheUdvYWxQZXJBdXRob3IgPSAyKSB7XG4gIHJldHVybiBjaG9vc2VSZWxheUNvbWJpbmF0aW9uRm9yUHVia2V5cyhuZGssIGF1dGhvcnMsIFwid3JpdGVcIiwgeyBjb3VudDogcmVsYXlHb2FsUGVyQXV0aG9yIH0pO1xufVxuXG4vLyBzcmMvdXRpbHMvbm9ybWFsaXplLXVybC50c1xuZnVuY3Rpb24gdHJ5Tm9ybWFsaXplUmVsYXlVcmwodXJsKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVJlbGF5VXJsKHVybCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlbGF5VXJsKHVybCkge1xuICBsZXQgciA9IG5vcm1hbGl6ZVVybCh1cmwsIHtcbiAgICBzdHJpcEF1dGhlbnRpY2F0aW9uOiBmYWxzZSxcbiAgICBzdHJpcFdXVzogZmFsc2UsXG4gICAgc3RyaXBIYXNoOiB0cnVlXG4gIH0pO1xuICBpZiAoIXIuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgciArPSBcIi9cIjtcbiAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZSh1cmxzKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHVybCBvZiB1cmxzKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5vcm1hbGl6ZWQuYWRkKG5vcm1hbGl6ZVJlbGF5VXJsKHVybCkpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShub3JtYWxpemVkKTtcbn1cbnZhciBEQVRBX1VSTF9ERUZBVUxUX01JTUVfVFlQRSA9IFwidGV4dC9wbGFpblwiO1xudmFyIERBVEFfVVJMX0RFRkFVTFRfQ0hBUlNFVCA9IFwidXMtYXNjaWlcIjtcbnZhciB0ZXN0UGFyYW1ldGVyID0gKG5hbWUsIGZpbHRlcnMpID0+IGZpbHRlcnMuc29tZSgoZmlsdGVyKSA9PiBmaWx0ZXIgaW5zdGFuY2VvZiBSZWdFeHAgPyBmaWx0ZXIudGVzdChuYW1lKSA6IGZpbHRlciA9PT0gbmFtZSk7XG52YXIgc3VwcG9ydGVkUHJvdG9jb2xzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiaHR0cHM6XCIsIFwiaHR0cDpcIiwgXCJmaWxlOlwiXSk7XG52YXIgaGFzQ3VzdG9tUHJvdG9jb2wgPSAodXJsU3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBwcm90b2NvbCB9ID0gbmV3IFVSTCh1cmxTdHJpbmcpO1xuICAgIHJldHVybiBwcm90b2NvbC5lbmRzV2l0aChcIjpcIikgJiYgIXByb3RvY29sLmluY2x1ZGVzKFwiLlwiKSAmJiAhc3VwcG9ydGVkUHJvdG9jb2xzLmhhcyhwcm90b2NvbCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciBub3JtYWxpemVEYXRhVVJMID0gKHVybFN0cmluZywgeyBzdHJpcEhhc2ggfSkgPT4ge1xuICBjb25zdCBtYXRjaCA9IC9eZGF0YTooPzx0eXBlPlteLF0qPyksKD88ZGF0YT5bXiNdKj8pKD86Iyg/PGhhc2g+LiopKT8kLy5leGVjKHVybFN0cmluZyk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgVVJMOiAke3VybFN0cmluZ31gKTtcbiAgfVxuICBjb25zdCB0eXBlID0gbWF0Y2guZ3JvdXBzPy50eXBlID8/IFwiXCI7XG4gIGNvbnN0IGRhdGEgPSBtYXRjaC5ncm91cHM/LmRhdGEgPz8gXCJcIjtcbiAgbGV0IGhhc2ggPSBtYXRjaC5ncm91cHM/Lmhhc2ggPz8gXCJcIjtcbiAgY29uc3QgbWVkaWFUeXBlID0gdHlwZS5zcGxpdChcIjtcIik7XG4gIGhhc2ggPSBzdHJpcEhhc2ggPyBcIlwiIDogaGFzaDtcbiAgbGV0IGlzQmFzZTY0ID0gZmFsc2U7XG4gIGlmIChtZWRpYVR5cGVbbWVkaWFUeXBlLmxlbmd0aCAtIDFdID09PSBcImJhc2U2NFwiKSB7XG4gICAgbWVkaWFUeXBlLnBvcCgpO1xuICAgIGlzQmFzZTY0ID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBtaW1lVHlwZSA9IG1lZGlhVHlwZS5zaGlmdCgpPy50b0xvd2VyQ2FzZSgpID8/IFwiXCI7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBtZWRpYVR5cGUubWFwKChhdHRyaWJ1dGUpID0+IHtcbiAgICBsZXQgW2tleSwgdmFsdWUgPSBcIlwiXSA9IGF0dHJpYnV0ZS5zcGxpdChcIj1cIikubWFwKChzdHJpbmcpID0+IHN0cmluZy50cmltKCkpO1xuICAgIGlmIChrZXkgPT09IFwiY2hhcnNldFwiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodmFsdWUgPT09IERBVEFfVVJMX0RFRkFVTFRfQ0hBUlNFVCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGAke2tleX0ke3ZhbHVlID8gYD0ke3ZhbHVlfWAgOiBcIlwifWA7XG4gIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3Qgbm9ybWFsaXplZE1lZGlhVHlwZSA9IFsuLi5hdHRyaWJ1dGVzXTtcbiAgaWYgKGlzQmFzZTY0KSB7XG4gICAgbm9ybWFsaXplZE1lZGlhVHlwZS5wdXNoKFwiYmFzZTY0XCIpO1xuICB9XG4gIGlmIChub3JtYWxpemVkTWVkaWFUeXBlLmxlbmd0aCA+IDAgfHwgbWltZVR5cGUgJiYgbWltZVR5cGUgIT09IERBVEFfVVJMX0RFRkFVTFRfTUlNRV9UWVBFKSB7XG4gICAgbm9ybWFsaXplZE1lZGlhVHlwZS51bnNoaWZ0KG1pbWVUeXBlKTtcbiAgfVxuICByZXR1cm4gYGRhdGE6JHtub3JtYWxpemVkTWVkaWFUeXBlLmpvaW4oXCI7XCIpfSwke2lzQmFzZTY0ID8gZGF0YS50cmltKCkgOiBkYXRhfSR7aGFzaCA/IGAjJHtoYXNofWAgOiBcIlwifWA7XG59O1xuZnVuY3Rpb24gbm9ybWFsaXplVXJsKHVybFN0cmluZywgb3B0aW9ucyA9IHt9KSB7XG4gIG9wdGlvbnMgPSB7XG4gICAgZGVmYXVsdFByb3RvY29sOiBcImh0dHBcIixcbiAgICBub3JtYWxpemVQcm90b2NvbDogdHJ1ZSxcbiAgICBmb3JjZUh0dHA6IGZhbHNlLFxuICAgIGZvcmNlSHR0cHM6IGZhbHNlLFxuICAgIHN0cmlwQXV0aGVudGljYXRpb246IHRydWUsXG4gICAgc3RyaXBIYXNoOiBmYWxzZSxcbiAgICBzdHJpcFRleHRGcmFnbWVudDogdHJ1ZSxcbiAgICBzdHJpcFdXVzogdHJ1ZSxcbiAgICByZW1vdmVRdWVyeVBhcmFtZXRlcnM6IFsvXnV0bV9cXHcrL2ldLFxuICAgIHJlbW92ZVRyYWlsaW5nU2xhc2g6IHRydWUsXG4gICAgcmVtb3ZlU2luZ2xlU2xhc2g6IHRydWUsXG4gICAgcmVtb3ZlRGlyZWN0b3J5SW5kZXg6IGZhbHNlLFxuICAgIHJlbW92ZUV4cGxpY2l0UG9ydDogZmFsc2UsXG4gICAgc29ydFF1ZXJ5UGFyYW1ldGVyczogdHJ1ZSxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wgPT09IFwic3RyaW5nXCIgJiYgIW9wdGlvbnMuZGVmYXVsdFByb3RvY29sLmVuZHNXaXRoKFwiOlwiKSkge1xuICAgIG9wdGlvbnMuZGVmYXVsdFByb3RvY29sID0gYCR7b3B0aW9ucy5kZWZhdWx0UHJvdG9jb2x9OmA7XG4gIH1cbiAgdXJsU3RyaW5nID0gdXJsU3RyaW5nLnRyaW0oKTtcbiAgaWYgKC9eZGF0YTovaS50ZXN0KHVybFN0cmluZykpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplRGF0YVVSTCh1cmxTdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChoYXNDdXN0b21Qcm90b2NvbCh1cmxTdHJpbmcpKSB7XG4gICAgcmV0dXJuIHVybFN0cmluZztcbiAgfVxuICBjb25zdCBoYXNSZWxhdGl2ZVByb3RvY29sID0gdXJsU3RyaW5nLnN0YXJ0c1dpdGgoXCIvL1wiKTtcbiAgY29uc3QgaXNSZWxhdGl2ZVVybCA9ICFoYXNSZWxhdGl2ZVByb3RvY29sICYmIC9eXFwuKlxcLy8udGVzdCh1cmxTdHJpbmcpO1xuICBpZiAoIWlzUmVsYXRpdmVVcmwpIHtcbiAgICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXig/ISg/Olxcdys6KT9cXC9cXC8pfF5cXC9cXC8vLCBvcHRpb25zLmRlZmF1bHRQcm90b2NvbCk7XG4gIH1cbiAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTCh1cmxTdHJpbmcpO1xuICB1cmxPYmplY3QuaG9zdG5hbWUgPSB1cmxPYmplY3QuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKG9wdGlvbnMuZm9yY2VIdHRwICYmIG9wdGlvbnMuZm9yY2VIdHRwcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgZm9yY2VIdHRwYCBhbmQgYGZvcmNlSHR0cHNgIG9wdGlvbnMgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXJcIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZm9yY2VIdHRwICYmIHVybE9iamVjdC5wcm90b2NvbCA9PT0gXCJodHRwczpcIikge1xuICAgIHVybE9iamVjdC5wcm90b2NvbCA9IFwiaHR0cDpcIjtcbiAgfVxuICBpZiAob3B0aW9ucy5mb3JjZUh0dHBzICYmIHVybE9iamVjdC5wcm90b2NvbCA9PT0gXCJodHRwOlwiKSB7XG4gICAgdXJsT2JqZWN0LnByb3RvY29sID0gXCJodHRwczpcIjtcbiAgfVxuICBpZiAob3B0aW9ucy5zdHJpcEF1dGhlbnRpY2F0aW9uKSB7XG4gICAgdXJsT2JqZWN0LnVzZXJuYW1lID0gXCJcIjtcbiAgICB1cmxPYmplY3QucGFzc3dvcmQgPSBcIlwiO1xuICB9XG4gIGlmIChvcHRpb25zLnN0cmlwSGFzaCkge1xuICAgIHVybE9iamVjdC5oYXNoID0gXCJcIjtcbiAgfSBlbHNlIGlmIChvcHRpb25zLnN0cmlwVGV4dEZyYWdtZW50KSB7XG4gICAgdXJsT2JqZWN0Lmhhc2ggPSB1cmxPYmplY3QuaGFzaC5yZXBsYWNlKC8jPzp+OnRleHQuKj8kL2ksIFwiXCIpO1xuICB9XG4gIGlmICh1cmxPYmplY3QucGF0aG5hbWUpIHtcbiAgICBjb25zdCBwcm90b2NvbFJlZ2V4ID0gL1xcYlthLXpdW2EtelxcZCtcXC0uXXsxLDUwfTpcXC9cXC8vZztcbiAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gcHJvdG9jb2xSZWdleC5leGVjKHVybE9iamVjdC5wYXRobmFtZSk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvdG9jb2wgPSBtYXRjaFswXTtcbiAgICAgIGNvbnN0IHByb3RvY29sQXRJbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgY29uc3QgaW50ZXJtZWRpYXRlID0gdXJsT2JqZWN0LnBhdGhuYW1lLnNsaWNlKGxhc3RJbmRleCwgcHJvdG9jb2xBdEluZGV4KTtcbiAgICAgIHJlc3VsdCArPSBpbnRlcm1lZGlhdGUucmVwbGFjZSgvXFwvezIsfS9nLCBcIi9cIik7XG4gICAgICByZXN1bHQgKz0gcHJvdG9jb2w7XG4gICAgICBsYXN0SW5kZXggPSBwcm90b2NvbEF0SW5kZXggKyBwcm90b2NvbC5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlbW5hbnQgPSB1cmxPYmplY3QucGF0aG5hbWUuc2xpY2UobGFzdEluZGV4LCB1cmxPYmplY3QucGF0aG5hbWUubGVuZ3RoKTtcbiAgICByZXN1bHQgKz0gcmVtbmFudC5yZXBsYWNlKC9cXC97Mix9L2csIFwiL1wiKTtcbiAgICB1cmxPYmplY3QucGF0aG5hbWUgPSByZXN1bHQ7XG4gIH1cbiAgaWYgKHVybE9iamVjdC5wYXRobmFtZSkge1xuICAgIHRyeSB7XG4gICAgICB1cmxPYmplY3QucGF0aG5hbWUgPSBkZWNvZGVVUkkodXJsT2JqZWN0LnBhdGhuYW1lKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVtb3ZlRGlyZWN0b3J5SW5kZXggPT09IHRydWUpIHtcbiAgICBvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4ID0gWy9eaW5kZXhcXC5bYS16XSskL107XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5yZW1vdmVEaXJlY3RvcnlJbmRleCkgJiYgb3B0aW9ucy5yZW1vdmVEaXJlY3RvcnlJbmRleC5sZW5ndGggPiAwKSB7XG4gICAgbGV0IHBhdGhDb21wb25lbnRzID0gdXJsT2JqZWN0LnBhdGhuYW1lLnNwbGl0KFwiL1wiKTtcbiAgICBjb25zdCBsYXN0Q29tcG9uZW50ID0gcGF0aENvbXBvbmVudHNbcGF0aENvbXBvbmVudHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHRlc3RQYXJhbWV0ZXIobGFzdENvbXBvbmVudCwgb3B0aW9ucy5yZW1vdmVEaXJlY3RvcnlJbmRleCkpIHtcbiAgICAgIHBhdGhDb21wb25lbnRzID0gcGF0aENvbXBvbmVudHMuc2xpY2UoMCwgLTEpO1xuICAgICAgdXJsT2JqZWN0LnBhdGhuYW1lID0gYCR7cGF0aENvbXBvbmVudHMuc2xpY2UoMSkuam9pbihcIi9cIil9L2A7XG4gICAgfVxuICB9XG4gIGlmICh1cmxPYmplY3QuaG9zdG5hbWUpIHtcbiAgICB1cmxPYmplY3QuaG9zdG5hbWUgPSB1cmxPYmplY3QuaG9zdG5hbWUucmVwbGFjZSgvXFwuJC8sIFwiXCIpO1xuICAgIGlmIChvcHRpb25zLnN0cmlwV1dXICYmIC9ed3d3XFwuKD8hd3d3XFwuKVthLXpcXC1cXGRdezEsNjN9XFwuW2Etei5cXC1cXGRdezIsNjN9JC8udGVzdCh1cmxPYmplY3QuaG9zdG5hbWUpKSB7XG4gICAgICB1cmxPYmplY3QuaG9zdG5hbWUgPSB1cmxPYmplY3QuaG9zdG5hbWUucmVwbGFjZSgvXnd3d1xcLi8sIFwiXCIpO1xuICAgIH1cbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnJlbW92ZVF1ZXJ5UGFyYW1ldGVycykpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBbLi4udXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5rZXlzKCldKSB7XG4gICAgICBpZiAodGVzdFBhcmFtZXRlcihrZXksIG9wdGlvbnMucmVtb3ZlUXVlcnlQYXJhbWV0ZXJzKSkge1xuICAgICAgICB1cmxPYmplY3Quc2VhcmNoUGFyYW1zLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5rZWVwUXVlcnlQYXJhbWV0ZXJzKSAmJiBvcHRpb25zLnJlbW92ZVF1ZXJ5UGFyYW1ldGVycyA9PT0gdHJ1ZSkge1xuICAgIHVybE9iamVjdC5zZWFyY2ggPSBcIlwiO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMua2VlcFF1ZXJ5UGFyYW1ldGVycykgJiYgb3B0aW9ucy5rZWVwUXVlcnlQYXJhbWV0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBbLi4udXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5rZXlzKCldKSB7XG4gICAgICBpZiAoIXRlc3RQYXJhbWV0ZXIoa2V5LCBvcHRpb25zLmtlZXBRdWVyeVBhcmFtZXRlcnMpKSB7XG4gICAgICAgIHVybE9iamVjdC5zZWFyY2hQYXJhbXMuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLnNvcnRRdWVyeVBhcmFtZXRlcnMpIHtcbiAgICB1cmxPYmplY3Quc2VhcmNoUGFyYW1zLnNvcnQoKTtcbiAgICB0cnkge1xuICAgICAgdXJsT2JqZWN0LnNlYXJjaCA9IGRlY29kZVVSSUNvbXBvbmVudCh1cmxPYmplY3Quc2VhcmNoKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVtb3ZlVHJhaWxpbmdTbGFzaCkge1xuICAgIHVybE9iamVjdC5wYXRobmFtZSA9IHVybE9iamVjdC5wYXRobmFtZS5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVtb3ZlRXhwbGljaXRQb3J0ICYmIHVybE9iamVjdC5wb3J0KSB7XG4gICAgdXJsT2JqZWN0LnBvcnQgPSBcIlwiO1xuICB9XG4gIGNvbnN0IG9sZFVybFN0cmluZyA9IHVybFN0cmluZztcbiAgdXJsU3RyaW5nID0gdXJsT2JqZWN0LnRvU3RyaW5nKCk7XG4gIGlmICghb3B0aW9ucy5yZW1vdmVTaW5nbGVTbGFzaCAmJiB1cmxPYmplY3QucGF0aG5hbWUgPT09IFwiL1wiICYmICFvbGRVcmxTdHJpbmcuZW5kc1dpdGgoXCIvXCIpICYmIHVybE9iamVjdC5oYXNoID09PSBcIlwiKSB7XG4gICAgdXJsU3RyaW5nID0gdXJsU3RyaW5nLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgfVxuICBpZiAoKG9wdGlvbnMucmVtb3ZlVHJhaWxpbmdTbGFzaCB8fCB1cmxPYmplY3QucGF0aG5hbWUgPT09IFwiL1wiKSAmJiB1cmxPYmplY3QuaGFzaCA9PT0gXCJcIiAmJiBvcHRpb25zLnJlbW92ZVNpbmdsZVNsYXNoKSB7XG4gICAgdXJsU3RyaW5nID0gdXJsU3RyaW5nLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgfVxuICBpZiAoaGFzUmVsYXRpdmVQcm90b2NvbCAmJiAhb3B0aW9ucy5ub3JtYWxpemVQcm90b2NvbCkge1xuICAgIHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9eaHR0cDpcXC9cXC8vLCBcIi8vXCIpO1xuICB9XG4gIGlmIChvcHRpb25zLnN0cmlwUHJvdG9jb2wpIHtcbiAgICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXig/Omh0dHBzPzopP1xcL1xcLy8sIFwiXCIpO1xuICB9XG4gIHJldHVybiB1cmxTdHJpbmc7XG59XG5cbi8vIHNyYy9yZWxheS9pbmRleC50c1xuaW1wb3J0IGRlYnVnMiBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gXCJ0c2VlcFwiO1xuXG4vLyBzcmMvcmVsYXkvY29ubmVjdGl2aXR5LnRzXG52YXIgTUFYX1JFQ09OTkVDVF9BVFRFTVBUUyA9IDU7XG52YXIgRkxBUFBJTkdfVEhSRVNIT0xEX01TID0gMWUzO1xudmFyIE5ES1JlbGF5Q29ubmVjdGl2aXR5ID0gY2xhc3Mge1xuICBuZGtSZWxheTtcbiAgd3M7XG4gIF9zdGF0dXM7XG4gIHRpbWVvdXRNcztcbiAgY29ubmVjdGVkQXQ7XG4gIF9jb25uZWN0aW9uU3RhdHMgPSB7XG4gICAgYXR0ZW1wdHM6IDAsXG4gICAgc3VjY2VzczogMCxcbiAgICBkdXJhdGlvbnM6IFtdXG4gIH07XG4gIGRlYnVnO1xuICBuZXREZWJ1ZztcbiAgY29ubmVjdFRpbWVvdXQ7XG4gIHJlY29ubmVjdFRpbWVvdXQ7XG4gIG5kaztcbiAgb3BlblN1YnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBvcGVuQ291bnRSZXF1ZXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIG9wZW5FdmVudFB1Ymxpc2hlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHNlcmlhbCA9IDA7XG4gIGJhc2VFb3NlVGltZW91dCA9IDQ0MDA7XG4gIGNvbnN0cnVjdG9yKG5ka1JlbGF5LCBuZGspIHtcbiAgICB0aGlzLm5ka1JlbGF5ID0gbmRrUmVsYXk7XG4gICAgdGhpcy5fc3RhdHVzID0gMSAvKiBESVNDT05ORUNURUQgKi87XG4gICAgY29uc3QgcmFuZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlMyk7XG4gICAgdGhpcy5kZWJ1ZyA9IHRoaXMubmRrUmVsYXkuZGVidWcuZXh0ZW5kKGBjb25uZWN0aXZpdHkke3JhbmR9YCk7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIHRoZSBOREsgcmVsYXkgYW5kIGhhbmRsZXMgdGhlIGNvbm5lY3Rpb24gbGlmZWN5Y2xlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBhdHRlbXB0cyB0byBlc3RhYmxpc2ggYSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgTkRLIHJlbGF5IHNwZWNpZmllZCBpbiB0aGUgYG5ka1JlbGF5YCBvYmplY3QuXG4gICAqIElmIHRoZSBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWwsIGl0IHVwZGF0ZXMgdGhlIGNvbm5lY3Rpb24gc3RhdGlzdGljcywgc2V0cyB0aGUgY29ubmVjdGlvbiBzdGF0dXMgdG8gYENPTk5FQ1RFRGAsXG4gICAqIGFuZCBlbWl0cyBgY29ubmVjdGAgYW5kIGByZWFkeWAgZXZlbnRzIG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdC5cbiAgICpcbiAgICogSWYgdGhlIGNvbm5lY3Rpb24gYXR0ZW1wdCBmYWlscywgaXQgaGFuZGxlcyB0aGUgZXJyb3IgYnkgZWl0aGVyIGluaXRpYXRpbmcgYSByZWNvbm5lY3Rpb24gYXR0ZW1wdCBvciBlbWl0dGluZyBhXG4gICAqIGBkZWxheWVkLWNvbm5lY3RgIGV2ZW50IG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdCwgZGVwZW5kaW5nIG9uIHRoZSBgcmVjb25uZWN0YCBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB0aW1lb3V0TXMgLSBUaGUgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQuIElmIG5vdCBwcm92aWRlZCwgdGhlIGRlZmF1bHQgdGltZW91dCBmcm9tIHRoZSBgbmRrUmVsYXlgIG9iamVjdCBpcyB1c2VkLlxuICAgKiBAcGFyYW0gcmVjb25uZWN0IC0gSW5kaWNhdGVzIHdoZXRoZXIgYSByZWNvbm5lY3Rpb24gc2hvdWxkIGJlIGF0dGVtcHRlZCBpZiB0aGUgY29ubmVjdGlvbiBmYWlscy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLCBvciByZWplY3RzIGlmIHRoZSBjb25uZWN0aW9uIGZhaWxzLlxuICAgKi9cbiAgYXN5bmMgY29ubmVjdCh0aW1lb3V0TXMsIHJlY29ubmVjdCA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5fc3RhdHVzICE9PSAyIC8qIFJFQ09OTkVDVElORyAqLyAmJiB0aGlzLl9zdGF0dXMgIT09IDEgLyogRElTQ09OTkVDVEVEICovIHx8IHRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgdGhpcy5kZWJ1ZyhcbiAgICAgICAgXCJSZWxheSByZXF1ZXN0ZWQgdG8gYmUgY29ubmVjdGVkIGJ1dCB3YXMgaW4gc3RhdGUgJXMgb3IgaXQgaGFkIGEgcmVjb25uZWN0IHRpbWVvdXRcIixcbiAgICAgICAgdGhpcy5fc3RhdHVzXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lb3V0KTtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0KTtcbiAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIHRpbWVvdXRNcyA/Pz0gdGhpcy50aW1lb3V0TXM7XG4gICAgaWYgKCF0aGlzLnRpbWVvdXRNcyAmJiB0aW1lb3V0TXMpIHRoaXMudGltZW91dE1zID0gdGltZW91dE1zO1xuICAgIGlmICh0aGlzLnRpbWVvdXRNcykgdGhpcy5jb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5vbkNvbm5lY3Rpb25FcnJvcihyZWNvbm5lY3QpLCB0aGlzLnRpbWVvdXRNcyk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvblN0YXRzLmF0dGVtcHQoKTtcbiAgICAgIGlmICh0aGlzLl9zdGF0dXMgPT09IDEgLyogRElTQ09OTkVDVEVEICovKSB0aGlzLl9zdGF0dXMgPSA0IC8qIENPTk5FQ1RJTkcgKi87XG4gICAgICBlbHNlIHRoaXMuX3N0YXR1cyA9IDIgLyogUkVDT05ORUNUSU5HICovO1xuICAgICAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQodGhpcy5uZGtSZWxheS51cmwpO1xuICAgICAgdGhpcy53cy5vbm9wZW4gPSB0aGlzLm9uQ29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy53cy5vbmNsb3NlID0gdGhpcy5vbkRpc2Nvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gdGhpcy5vbk1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMud3Mub25lcnJvciA9IHRoaXMub25FcnJvci5iaW5kKHRoaXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZGVidWcoYEZhaWxlZCB0byBjb25uZWN0IHRvICR7dGhpcy5uZGtSZWxheS51cmx9YCwgZSk7XG4gICAgICB0aGlzLl9zdGF0dXMgPSAxIC8qIERJU0NPTk5FQ1RFRCAqLztcbiAgICAgIGlmIChyZWNvbm5lY3QpIHRoaXMuaGFuZGxlUmVjb25uZWN0aW9uKCk7XG4gICAgICBlbHNlIHRoaXMubmRrUmVsYXkuZW1pdChcImRlbGF5ZWQtY29ubmVjdFwiLCAyICogMjQgKiA2MCAqIDYwICogMWUzKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIE5ESyByZWxheS5cbiAgICogVGhpcyBtZXRob2Qgc2V0cyB0aGUgY29ubmVjdGlvbiBzdGF0dXMgdG8gYE5ES1JlbGF5U3RhdHVzLkRJU0NPTk5FQ1RJTkdgLFxuICAgKiBhdHRlbXB0cyB0byBjbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24sIGFuZCBzZXRzIHRoZSBzdGF0dXMgdG9cbiAgICogYE5ES1JlbGF5U3RhdHVzLkRJU0NPTk5FQ1RFRGAgaWYgdGhlIGRpc2Nvbm5lY3Qgb3BlcmF0aW9uIGZhaWxzLlxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLl9zdGF0dXMgPSAwIC8qIERJU0NPTk5FQ1RJTkcgKi87XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMud3M/LmNsb3NlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5kZWJ1ZyhcIkZhaWxlZCB0byBkaXNjb25uZWN0XCIsIGUpO1xuICAgICAgdGhpcy5fc3RhdHVzID0gMSAvKiBESVNDT05ORUNURUQgKi87XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBlcnJvciB0aGF0IG9jY3VycmVkIHdoZW4gYXR0ZW1wdGluZyB0byBjb25uZWN0IHRvIHRoZSBOREsgcmVsYXkuXG4gICAqIElmIGByZWNvbm5lY3RgIGlzIGB0cnVlYCwgdGhpcyBtZXRob2Qgd2lsbCBpbml0aWF0ZSBhIHJlY29ubmVjdGlvbiBhdHRlbXB0LlxuICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgZW1pdCBhIGBkZWxheWVkLWNvbm5lY3RgIGV2ZW50IG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdCxcbiAgICogaW5kaWNhdGluZyB0aGF0IGEgcmVjb25uZWN0aW9uIHNob3VsZCBiZSBhdHRlbXB0ZWQgYWZ0ZXIgYSBkZWxheS5cbiAgICpcbiAgICogQHBhcmFtIHJlY29ubmVjdCAtIEluZGljYXRlcyB3aGV0aGVyIGEgcmVjb25uZWN0aW9uIHNob3VsZCBiZSBhdHRlbXB0ZWQuXG4gICAqL1xuICBvbkNvbm5lY3Rpb25FcnJvcihyZWNvbm5lY3QpIHtcbiAgICB0aGlzLmRlYnVnKGBFcnJvciBjb25uZWN0aW5nIHRvICR7dGhpcy5uZGtSZWxheS51cmx9YCwgdGhpcy50aW1lb3V0TXMpO1xuICAgIGlmIChyZWNvbm5lY3QgJiYgIXRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgdGhpcy5oYW5kbGVSZWNvbm5lY3Rpb24oKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGNvbm5lY3Rpb24gZXZlbnQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsbHkgb3BlbmVkLlxuICAgKiBJdCBjbGVhcnMgYW55IGV4aXN0aW5nIGNvbm5lY3Rpb24gYW5kIHJlY29ubmVjdGlvbiB0aW1lb3V0cywgdXBkYXRlcyB0aGUgY29ubmVjdGlvbiBzdGF0aXN0aWNzLFxuICAgKiBzZXRzIHRoZSBjb25uZWN0aW9uIHN0YXR1cyB0byBgQ09OTkVDVEVEYCwgYW5kIGVtaXRzIGBjb25uZWN0YCBhbmQgYHJlYWR5YCBldmVudHMgb24gdGhlIGBuZGtSZWxheWAgb2JqZWN0LlxuICAgKi9cbiAgb25Db25uZWN0KCkge1xuICAgIHRoaXMubmV0RGVidWc/LihcImNvbm5lY3RlZFwiLCB0aGlzLm5ka1JlbGF5KTtcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lb3V0KTtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0KTtcbiAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvblN0YXRzLmNvbm5lY3RlZCgpO1xuICAgIHRoaXMuX3N0YXR1cyA9IDUgLyogQ09OTkVDVEVEICovO1xuICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImNvbm5lY3RcIik7XG4gICAgdGhpcy5uZGtSZWxheS5lbWl0KFwicmVhZHlcIik7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGRpc2Nvbm5lY3Rpb24gZXZlbnQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgY2xvc2VkLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bGx5IGNsb3NlZC5cbiAgICogSXQgdXBkYXRlcyB0aGUgY29ubmVjdGlvbiBzdGF0aXN0aWNzLCBzZXRzIHRoZSBjb25uZWN0aW9uIHN0YXR1cyB0byBgRElTQ09OTkVDVEVEYCxcbiAgICogaW5pdGlhdGVzIGEgcmVjb25uZWN0aW9uIGF0dGVtcHQgaWYgd2UgZGlkbid0IGRpc2Nvbm5lY3Qgb3Vyc2VsdmVzLFxuICAgKiBhbmQgZW1pdHMgYSBgZGlzY29ubmVjdGAgZXZlbnQgb24gdGhlIGBuZGtSZWxheWAgb2JqZWN0LlxuICAgKi9cbiAgb25EaXNjb25uZWN0KCkge1xuICAgIHRoaXMubmV0RGVidWc/LihcImRpc2Nvbm5lY3RlZFwiLCB0aGlzLm5ka1JlbGF5KTtcbiAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25TdGF0cy5kaXNjb25uZWN0ZWQoKTtcbiAgICBpZiAodGhpcy5fc3RhdHVzID09PSA1IC8qIENPTk5FQ1RFRCAqLykge1xuICAgICAgdGhpcy5oYW5kbGVSZWNvbm5lY3Rpb24oKTtcbiAgICB9XG4gICAgdGhpcy5fc3RhdHVzID0gMSAvKiBESVNDT05ORUNURUQgKi87XG4gICAgdGhpcy5uZGtSZWxheS5lbWl0KFwiZGlzY29ubmVjdFwiKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBpbmNvbWluZyBtZXNzYWdlcyBmcm9tIHRoZSBOREsgcmVsYXkgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuZXZlciBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgcmVsYXkuXG4gICAqIEl0IHBhcnNlcyB0aGUgbWVzc2FnZSBkYXRhIGFuZCBkaXNwYXRjaGVzIHRoZSBhcHByb3ByaWF0ZSBoYW5kbGluZyBsb2dpYyBiYXNlZCBvbiB0aGUgbWVzc2FnZSB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgTWVzc2FnZUV2ZW50IGNvbnRhaW5pbmcgdGhlIHJlY2VpdmVkIG1lc3NhZ2UgZGF0YS5cbiAgICovXG4gIG9uTWVzc2FnZShldmVudCkge1xuICAgIHRoaXMubmV0RGVidWc/LihldmVudC5kYXRhLCB0aGlzLm5ka1JlbGF5LCBcInJlY3ZcIik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgY29uc3QgW2NtZCwgaWQsIC4uLl9yZXN0XSA9IGRhdGE7XG4gICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICBjYXNlIFwiRVZFTlRcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoaWQpO1xuICAgICAgICAgIGNvbnN0IGV2ZW50MiA9IGRhdGFbMl07XG4gICAgICAgICAgaWYgKCFzbykge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhgUmVjZWl2ZWQgZXZlbnQgZm9yIHVua25vd24gc3Vic2NyaXB0aW9uICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvLm9uZXZlbnQoZXZlbnQyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkNPVU5UXCI6IHtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YVsyXTtcbiAgICAgICAgICBjb25zdCBjciA9IHRoaXMub3BlbkNvdW50UmVxdWVzdHMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoY3IpIHtcbiAgICAgICAgICAgIGNyLnJlc29sdmUocGF5bG9hZC5jb3VudCk7XG4gICAgICAgICAgICB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiRU9TRVwiOiB7XG4gICAgICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChpZCk7XG4gICAgICAgICAgaWYgKCFzbykgcmV0dXJuO1xuICAgICAgICAgIHNvLm9uZW9zZShpZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPS1wiOiB7XG4gICAgICAgICAgY29uc3Qgb2sgPSBkYXRhWzJdO1xuICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGRhdGFbM107XG4gICAgICAgICAgY29uc3QgZXAgPSB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5nZXQoaWQpO1xuICAgICAgICAgIGNvbnN0IGZpcnN0RXAgPSBlcD8ucG9wKCk7XG4gICAgICAgICAgaWYgKCFlcCB8fCAhZmlyc3RFcCkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIlJlY2VpdmVkIE9LIGZvciB1bmtub3duIGV2ZW50IHB1Ymxpc2hcIiwgaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2spIGZpcnN0RXAucmVzb2x2ZShyZWFzb24pO1xuICAgICAgICAgIGVsc2UgZmlyc3RFcC5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgICAgICAgIGlmIChlcC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChpZCwgZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkNMT1NFRFwiOiB7XG4gICAgICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChpZCk7XG4gICAgICAgICAgaWYgKCFzbykgcmV0dXJuO1xuICAgICAgICAgIHNvLm9uY2xvc2VkKGRhdGFbMl0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiTk9USUNFXCI6XG4gICAgICAgICAgdGhpcy5vbk5vdGljZShkYXRhWzFdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJBVVRIXCI6IHtcbiAgICAgICAgICB0aGlzLm9uQXV0aFJlcXVlc3RlZChkYXRhWzFdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5kZWJ1ZyhgRXJyb3IgcGFyc2luZyBtZXNzYWdlIGZyb20gJHt0aGlzLm5ka1JlbGF5LnVybH06ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcj8uc3RhY2spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBhbiBhdXRoZW50aWNhdGlvbiByZXF1ZXN0IGZyb20gdGhlIE5ESyByZWxheS5cbiAgICpcbiAgICogSWYgYW4gYXV0aGVudGljYXRpb24gcG9saWN5IGlzIGNvbmZpZ3VyZWQsIGl0IHdpbGwgYmUgdXNlZCB0byBhdXRoZW50aWNhdGUgdGhlIGNvbm5lY3Rpb24uXG4gICAqIE90aGVyd2lzZSwgdGhlIGBhdXRoYCBldmVudCB3aWxsIGJlIGVtaXR0ZWQgdG8gYWxsb3cgdGhlIGFwcGxpY2F0aW9uIHRvIGhhbmRsZSB0aGUgYXV0aGVudGljYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBjaGFsbGVuZ2UgLSBUaGUgYXV0aGVudGljYXRpb24gY2hhbGxlbmdlIHByb3ZpZGVkIGJ5IHRoZSBOREsgcmVsYXkuXG4gICAqL1xuICBhc3luYyBvbkF1dGhSZXF1ZXN0ZWQoY2hhbGxlbmdlKSB7XG4gICAgY29uc3QgYXV0aFBvbGljeSA9IHRoaXMubmRrUmVsYXkuYXV0aFBvbGljeSA/PyB0aGlzLm5kaz8ucmVsYXlBdXRoRGVmYXVsdFBvbGljeTtcbiAgICB0aGlzLmRlYnVnKFwiUmVsYXkgcmVxdWVzdGVkIGF1dGhlbnRpY2F0aW9uXCIsIHtcbiAgICAgIGhhdmVQb2xpY3k6ICEhYXV0aFBvbGljeVxuICAgIH0pO1xuICAgIGlmICh0aGlzLl9zdGF0dXMgPT09IDcgLyogQVVUSEVOVElDQVRJTkcgKi8pIHtcbiAgICAgIHRoaXMuZGVidWcoXCJBbHJlYWR5IGF1dGhlbnRpY2F0aW5nLCBpZ25vcmluZ1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc3RhdHVzID0gNiAvKiBBVVRIX1JFUVVFU1RFRCAqLztcbiAgICBpZiAoYXV0aFBvbGljeSkge1xuICAgICAgaWYgKHRoaXMuX3N0YXR1cyA+PSA1IC8qIENPTk5FQ1RFRCAqLykge1xuICAgICAgICB0aGlzLl9zdGF0dXMgPSA3IC8qIEFVVEhFTlRJQ0FUSU5HICovO1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcyA9IGF3YWl0IGF1dGhQb2xpY3kodGhpcy5uZGtSZWxheSwgY2hhbGxlbmdlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMuZGVidWcoXCJBdXRoZW50aWNhdGlvbiBwb2xpY3kgdGhyZXcgYW4gZXJyb3JcIiwgZSk7XG4gICAgICAgICAgcmVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJ1ZyhcIkF1dGhlbnRpY2F0aW9uIHBvbGljeSByZXR1cm5lZFwiLCAhIXJlcyk7XG4gICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBOREtFdmVudCB8fCByZXMgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXV0aChyZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhdXRoZW50aWNhdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovICYmIHRoaXMuX3N0YXR1cyA8IDggLyogQVVUSEVOVElDQVRFRCAqLykge1xuICAgICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kayk7XG4gICAgICAgICAgICAgIGV2ZW50LmtpbmQgPSAyMjI0MiAvKiBDbGllbnRBdXRoICovO1xuICAgICAgICAgICAgICBldmVudC50YWdzID0gW1xuICAgICAgICAgICAgICAgIFtcInJlbGF5XCIsIHRoaXMubmRrUmVsYXkudXJsXSxcbiAgICAgICAgICAgICAgICBbXCJjaGFsbGVuZ2VcIiwgY2hhbGxlbmdlXVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICBhd2FpdCBldmVudC5zaWduKCk7XG4gICAgICAgICAgICAgIHRoaXMuYXV0aChldmVudCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gOCAvKiBBVVRIRU5USUNBVEVEICovO1xuICAgICAgICAgICAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImF1dGhlZFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKFwiQXV0aGVudGljYXRpb24gc3VjY2Vzc2Z1bFwiKTtcbiAgICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSA2IC8qIEFVVEhfUkVRVUVTVEVEICovO1xuICAgICAgICAgICAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImF1dGg6ZmFpbGVkXCIsIGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoXCJBdXRoZW50aWNhdGlvbiBmYWlsZWRcIiwgZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIkF1dGhlbnRpY2F0aW9uIGZhaWxlZCwgaXQgY2hhbmdlZCBzdGF0dXMsIHN0YXR1cyBpcyAlZFwiLCB0aGlzLl9zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHJlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5kaz8uc2lnbmVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVidWcoXCJObyBzaWduZXIgYXZhaWxhYmxlIGZvciBhdXRoZW50aWNhdGlvbiBsb2NhbGhvc3RcIik7XG4gICAgICAgICAgICAgIHRoaXMubmRrPy5vbmNlKFwic2lnbmVyOnJlYWR5XCIsIGF1dGhlbnRpY2F0ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhdXRoZW50aWNhdGUoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhdXRoZW50aWNhdGluZ1wiLCBlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IDUgLyogQ09OTkVDVEVEICovO1xuICAgICAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImF1dGhlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJhdXRoXCIsIGNoYWxsZW5nZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGVycm9ycyB0aGF0IG9jY3VyIG9uIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgcmVsYXkuXG4gICAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciBvciBldmVudCB0aGF0IG9jY3VycmVkLlxuICAgKi9cbiAgb25FcnJvcihlcnJvcikge1xuICAgIHRoaXMuZGVidWcoYFdlYlNvY2tldCBlcnJvciBvbiAke3RoaXMubmRrUmVsYXkudXJsfTpgLCBlcnJvcik7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBOREsgcmVsYXkgY29ubmVjdGlvbi5cbiAgICogQHJldHVybnMge05ES1JlbGF5U3RhdHVzfSBUaGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIE5ESyByZWxheSBjb25uZWN0aW9uLlxuICAgKi9cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIE5ESyByZWxheSBjb25uZWN0aW9uIGlzIGN1cnJlbnRseSBhdmFpbGFibGUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHJlbGF5IGNvbm5lY3Rpb24gaXMgaW4gdGhlIGBDT05ORUNURURgIHN0YXR1cywgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqL1xuICBpc0F2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzID09PSA1IC8qIENPTk5FQ1RFRCAqLztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBOREsgcmVsYXkgY29ubmVjdGlvbiBpcyBmbGFwcGluZywgd2hpY2ggbWVhbnMgdGhlIGNvbm5lY3Rpb24gaXMgcmFwaWRseVxuICAgKiBkaXNjb25uZWN0aW5nIGFuZCByZWNvbm5lY3RpbmcuIFRoaXMgaXMgZGV0ZXJtaW5lZCBieSBhbmFseXppbmcgdGhlIGR1cmF0aW9ucyBvZiB0aGVcbiAgICogbGFzdCB0aHJlZSBjb25uZWN0aW9uIGF0dGVtcHRzLiBJZiB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSBkdXJhdGlvbnMgaXMgbGVzc1xuICAgKiB0aGFuIDEwMDAgbWlsbGlzZWNvbmRzLCB0aGUgY29ubmVjdGlvbiBpcyBjb25zaWRlcmVkIHRvIGJlIGZsYXBwaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBjb25uZWN0aW9uIGlzIGZsYXBwaW5nLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICovXG4gIGlzRmxhcHBpbmcoKSB7XG4gICAgY29uc3QgZHVyYXRpb25zID0gdGhpcy5fY29ubmVjdGlvblN0YXRzLmR1cmF0aW9ucztcbiAgICBpZiAoZHVyYXRpb25zLmxlbmd0aCAlIDMgIT09IDApIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBzdW0gPSBkdXJhdGlvbnMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gICAgY29uc3QgYXZnID0gc3VtIC8gZHVyYXRpb25zLmxlbmd0aDtcbiAgICBjb25zdCB2YXJpYW5jZSA9IGR1cmF0aW9ucy5tYXAoKHgpID0+ICh4IC0gYXZnKSAqKiAyKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIGR1cmF0aW9ucy5sZW5ndGg7XG4gICAgY29uc3Qgc3RkRGV2ID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcbiAgICBjb25zdCBpc0ZsYXBwaW5nID0gc3RkRGV2IDwgRkxBUFBJTkdfVEhSRVNIT0xEX01TO1xuICAgIHJldHVybiBpc0ZsYXBwaW5nO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgbm90aWNlIHJlY2VpdmVkIGZyb20gdGhlIE5ESyByZWxheS5cbiAgICogSWYgdGhlIG5vdGljZSBpbmRpY2F0ZXMgdGhlIHJlbGF5IGlzIGNvbXBsYWluaW5nIChlLmcuIFwidG9vIG1hbnlcIiBvciBcIm1heGltdW1cIiksXG4gICAqIHRoZSBtZXRob2QgZGlzY29ubmVjdHMgZnJvbSB0aGUgcmVsYXkgYW5kIGF0dGVtcHRzIHRvIHJlY29ubmVjdCBhZnRlciBhIDItc2Vjb25kIGRlbGF5LlxuICAgKiBBIGRlYnVnIG1lc3NhZ2UgaXMgbG9nZ2VkIHdpdGggdGhlIHJlbGF5IFVSTCBhbmQgdGhlIG5vdGljZSB0ZXh0LlxuICAgKiBUaGUgXCJub3RpY2VcIiBldmVudCBpcyBlbWl0dGVkIG9uIHRoZSBuZGtSZWxheSBpbnN0YW5jZSB3aXRoIHRoZSBub3RpY2UgdGV4dC5cbiAgICpcbiAgICogQHBhcmFtIG5vdGljZSAtIFRoZSBub3RpY2UgdGV4dCByZWNlaXZlZCBmcm9tIHRoZSBOREsgcmVsYXkuXG4gICAqL1xuICBhc3luYyBvbk5vdGljZShub3RpY2UpIHtcbiAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJub3RpY2VcIiwgbm90aWNlKTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gcmVjb25uZWN0IHRvIHRoZSBOREsgcmVsYXkgYWZ0ZXIgYSBjb25uZWN0aW9uIGlzIGxvc3QuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHJlY3Vyc2l2ZWx5IHRvIGhhbmRsZSBtdWx0aXBsZSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMuXG4gICAqIEl0IGNoZWNrcyBpZiB0aGUgcmVsYXkgaXMgZmxhcHBpbmcgYW5kIGVtaXRzIGEgXCJmbGFwcGluZ1wiIGV2ZW50IGlmIHNvLlxuICAgKiBJdCB0aGVuIGNhbGN1bGF0ZXMgYSBkZWxheSBiZWZvcmUgdGhlIG5leHQgcmVjb25uZWN0aW9uIGF0dGVtcHQgYmFzZWQgb24gdGhlIG51bWJlciBvZiBwcmV2aW91cyBhdHRlbXB0cy5cbiAgICogVGhlIGZ1bmN0aW9uIHNldHMgYSB0aW1lb3V0IHRvIGV4ZWN1dGUgdGhlIG5leHQgcmVjb25uZWN0aW9uIGF0dGVtcHQgYWZ0ZXIgdGhlIGNhbGN1bGF0ZWQgZGVsYXkuXG4gICAqIElmIHRoZSBtYXhpbXVtIG51bWJlciBvZiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgaXMgcmVhY2hlZCwgYSBkZWJ1ZyBtZXNzYWdlIGlzIGxvZ2dlZC5cbiAgICpcbiAgICogQHBhcmFtIGF0dGVtcHQgLSBUaGUgY3VycmVudCBhdHRlbXB0IG51bWJlciAoZGVmYXVsdCBpcyAwKS5cbiAgICovXG4gIGhhbmRsZVJlY29ubmVjdGlvbihhdHRlbXB0ID0gMCkge1xuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHJldHVybjtcbiAgICBpZiAodGhpcy5pc0ZsYXBwaW5nKCkpIHtcbiAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImZsYXBwaW5nXCIsIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cyk7XG4gICAgICB0aGlzLl9zdGF0dXMgPSAzIC8qIEZMQVBQSU5HICovO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWNvbm5lY3REZWxheSA9IHRoaXMuY29ubmVjdGVkQXQgPyBNYXRoLm1heCgwLCA2ZTQgLSAoRGF0ZS5ub3coKSAtIHRoaXMuY29ubmVjdGVkQXQpKSA6IDVlMyAqICh0aGlzLl9jb25uZWN0aW9uU3RhdHMuYXR0ZW1wdHMgKyAxKTtcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IDIgLyogUkVDT05ORUNUSU5HICovO1xuICAgICAgdGhpcy5jb25uZWN0KCkuY2F0Y2goKF9lcnIpID0+IHtcbiAgICAgICAgaWYgKGF0dGVtcHQgPCBNQVhfUkVDT05ORUNUX0FUVEVNUFRTKSB7XG4gICAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZWNvbm5lY3Rpb24oYXR0ZW1wdCArIDEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDFlMyAqIChhdHRlbXB0ICsgMSkgXiA0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRlYnVnKFwiUmVjb25uZWN0IGZhaWxlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgcmVjb25uZWN0RGVsYXkpO1xuICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImRlbGF5ZWQtY29ubmVjdFwiLCByZWNvbm5lY3REZWxheSk7XG4gICAgdGhpcy5kZWJ1ZyhcIlJlY29ubmVjdGluZyBpblwiLCByZWNvbm5lY3REZWxheSk7XG4gICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLm5leHRSZWNvbm5lY3RBdCA9IERhdGUubm93KCkgKyByZWNvbm5lY3REZWxheTtcbiAgfVxuICAvKipcbiAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBOREsgcmVsYXkgaWYgdGhlIGNvbm5lY3Rpb24gaXMgaW4gdGhlIENPTk5FQ1RFRCBzdGF0ZSBhbmQgdGhlIFdlYlNvY2tldCBpcyBvcGVuLlxuICAgKiBJZiB0aGUgY29ubmVjdGlvbiBpcyBub3QgaW4gdGhlIENPTk5FQ1RFRCBzdGF0ZSBvciB0aGUgV2ViU29ja2V0IGlzIG5vdCBvcGVuLCBsb2dzIGEgZGVidWcgbWVzc2FnZSBhbmQgdGhyb3dzIGFuIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIHNlbmQgdG8gdGhlIE5ESyByZWxheS5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIGF0dGVtcHRpbmcgdG8gc2VuZCBvbiBhIGNsb3NlZCByZWxheSBjb25uZWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgc2VuZChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuX3N0YXR1cyA+PSA1IC8qIENPTk5FQ1RFRCAqLyAmJiB0aGlzLndzPy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgdGhpcy53cz8uc2VuZChtZXNzYWdlKTtcbiAgICAgIHRoaXMubmV0RGVidWc/LihtZXNzYWdlLCB0aGlzLm5ka1JlbGF5LCBcInNlbmRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVidWcoYE5vdCBjb25uZWN0ZWQgdG8gJHt0aGlzLm5ka1JlbGF5LnVybH0gKCVkKSwgbm90IHNlbmRpbmcgbWVzc2FnZSAke21lc3NhZ2V9YCwgdGhpcy5fc3RhdHVzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEF1dGhlbnRpY2F0ZXMgdGhlIE5ESyBldmVudCBieSBzZW5kaW5nIGl0IHRvIHRoZSBOREsgcmVsYXkgYW5kIHJldHVybmluZyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBOREsgZXZlbnQgdG8gYXV0aGVudGljYXRlLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBhdXRoZW50aWNhdGlvbiByZXN1bHQuXG4gICAqL1xuICBhc3luYyBhdXRoKGV2ZW50KSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdmFsID0gdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZ2V0KGV2ZW50LmlkKSA/PyBbXTtcbiAgICAgIHZhbC5wdXNoKHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuc2V0KGV2ZW50LmlkLCB2YWwpO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZChgW1wiQVVUSFwiLCR7SlNPTi5zdHJpbmdpZnkoZXZlbnQucmF3RXZlbnQoKSl9XWApO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2hlcyBhbiBOREsgZXZlbnQgdG8gdGhlIHJlbGF5IGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIE5ESyBldmVudCB0byBwdWJsaXNoLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIGV2ZW50IHB1YmxpY2F0aW9uLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYXR0ZW1wdGluZyB0byBwdWJsaXNoIG9uIGEgY2xvc2VkIHJlbGF5IGNvbm5lY3Rpb24uXG4gICAqL1xuICBhc3luYyBwdWJsaXNoKGV2ZW50KSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdmFsID0gdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZ2V0KGV2ZW50LmlkKSA/PyBbXTtcbiAgICAgIGlmICh2YWwubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYER1cGxpY2F0ZSBldmVudCBwdWJsaXNoaW5nIGRldGVjdGVkLCB5b3UgYXJlIHB1Ymxpc2hpbmcgZXZlbnQgJHtldmVudC5pZH0gdHdpY2VgKTtcbiAgICAgIH1cbiAgICAgIHZhbC5wdXNoKHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuc2V0KGV2ZW50LmlkLCB2YWwpO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZChgW1wiRVZFTlRcIiwke0pTT04uc3RyaW5naWZ5KGV2ZW50KX1dYCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAvKipcbiAgICogQ291bnRzIHRoZSBudW1iZXIgb2YgZXZlbnRzIHRoYXQgbWF0Y2ggdGhlIHByb3ZpZGVkIGZpbHRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSBmaWx0ZXJzIC0gVGhlIGZpbHRlcnMgdG8gYXBwbHkgdG8gdGhlIGNvdW50IHJlcXVlc3QuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBBbiBvcHRpb25hbCBvYmplY3QgY29udGFpbmluZyBhIGN1c3RvbSBpZCBmb3IgdGhlIGNvdW50IHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG51bWJlciBvZiBtYXRjaGluZyBldmVudHMuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhdHRlbXB0aW5nIHRvIHNlbmQgdGhlIGNvdW50IHJlcXVlc3Qgb24gYSBjbG9zZWQgcmVsYXkgY29ubmVjdGlvbi5cbiAgICovXG4gIGFzeW5jIGNvdW50KGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHRoaXMuc2VyaWFsKys7XG4gICAgY29uc3QgaWQgPSBwYXJhbXM/LmlkIHx8IGBjb3VudDoke3RoaXMuc2VyaWFsfWA7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5zZXQoaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZChgW1wiQ09VTlRcIixcIiR7aWR9XCIsJHtKU09OLnN0cmluZ2lmeShmaWx0ZXJzKS5zdWJzdHJpbmcoMSl9YCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBjbG9zZShzdWJJZCwgcmVhc29uKSB7XG4gICAgdGhpcy5zZW5kKGBbXCJDTE9TRVwiLFwiJHtzdWJJZH1cIl1gKTtcbiAgICBjb25zdCBzdWIgPSB0aGlzLm9wZW5TdWJzLmdldChzdWJJZCk7XG4gICAgdGhpcy5vcGVuU3Vicy5kZWxldGUoc3ViSWQpO1xuICAgIGlmIChzdWIpIHN1Yi5vbmNsb3NlKHJlYXNvbik7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZXMgdG8gdGhlIE5ESyByZWxheSB3aXRoIHRoZSBwcm92aWRlZCBmaWx0ZXJzIGFuZCBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gZmlsdGVycyAtIFRoZSBmaWx0ZXJzIHRvIGFwcGx5IHRvIHRoZSBzdWJzY3JpcHRpb24uXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgc3Vic2NyaXB0aW9uIHBhcmFtZXRlcnMsIGluY2x1ZGluZyBhbiBvcHRpb25hbCBjdXN0b20gaWQuXG4gICAqIEByZXR1cm5zIEEgbmV3IE5ES1JlbGF5U3Vic2NyaXB0aW9uIGluc3RhbmNlLlxuICAgKi9cbiAgcmVxKHJlbGF5U3ViKSB7XG4gICAgYCR7dGhpcy5zZW5kKGBbXCJSRVFcIixcIiR7cmVsYXlTdWIuc3ViSWR9XCIsJHtKU09OLnN0cmluZ2lmeShyZWxheVN1Yi5leGVjdXRlRmlsdGVycykuc3Vic3RyaW5nKDEpfWApfV1gO1xuICAgIHRoaXMub3BlblN1YnMuc2V0KHJlbGF5U3ViLnN1YklkLCByZWxheVN1Yik7XG4gIH1cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHVwZGF0ZSB0aGUgY29ubmVjdGlvbiBzdGF0cy5cbiAgICovXG4gIHVwZGF0ZUNvbm5lY3Rpb25TdGF0cyA9IHtcbiAgICBjb25uZWN0ZWQ6ICgpID0+IHtcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5zdWNjZXNzKys7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuY29ubmVjdGVkQXQgPSBEYXRlLm5vdygpO1xuICAgIH0sXG4gICAgZGlzY29ubmVjdGVkOiAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fY29ubmVjdGlvblN0YXRzLmNvbm5lY3RlZEF0KSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5kdXJhdGlvbnMucHVzaChEYXRlLm5vdygpIC0gdGhpcy5fY29ubmVjdGlvblN0YXRzLmNvbm5lY3RlZEF0KTtcbiAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5kdXJhdGlvbnMubGVuZ3RoID4gMTAwKSB7XG4gICAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmR1cmF0aW9ucy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuY29ubmVjdGVkQXQgPSB2b2lkIDA7XG4gICAgfSxcbiAgICBhdHRlbXB0OiAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuYXR0ZW1wdHMrKztcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgfVxuICB9O1xuICAvKiogUmV0dXJucyB0aGUgY29ubmVjdGlvbiBzdGF0cy4gKi9cbiAgZ2V0IGNvbm5lY3Rpb25TdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblN0YXRzO1xuICB9XG4gIC8qKiBSZXR1cm5zIHRoZSByZWxheSBVUkwgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5uZGtSZWxheS51cmw7XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovICYmIHRoaXMud3M/LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOO1xuICB9XG59O1xuXG4vLyBzcmMvcmVsYXkvcHVibGlzaGVyLnRzXG52YXIgTkRLUmVsYXlQdWJsaXNoZXIgPSBjbGFzcyB7XG4gIG5ka1JlbGF5O1xuICBkZWJ1ZztcbiAgY29uc3RydWN0b3IobmRrUmVsYXkpIHtcbiAgICB0aGlzLm5ka1JlbGF5ID0gbmRrUmVsYXk7XG4gICAgdGhpcy5kZWJ1ZyA9IG5ka1JlbGF5LmRlYnVnLmV4dGVuZChcInB1Ymxpc2hlclwiKTtcbiAgfVxuICAvKipcbiAgICogUHVibGlzaGVkIGFuIGV2ZW50IHRvIHRoZSByZWxheTsgaWYgdGhlIHJlbGF5IGlzIG5vdCBjb25uZWN0ZWQsIGl0IHdpbGxcbiAgICogd2FpdCBmb3IgdGhlIHJlbGF5IHRvIGNvbm5lY3QgYmVmb3JlIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBJZiB0aGUgcmVsYXkgZG9lcyBub3QgY29ubmVjdCB3aXRoaW4gdGhlIHRpbWVvdXQsIHRoZSBwdWJsaXNoIG9wZXJhdGlvblxuICAgKiB3aWxsIGZhaWwuXG4gICAqIEBwYXJhbSBldmVudCAgVGhlIGV2ZW50IHRvIHB1Ymxpc2hcbiAgICogQHBhcmFtIHRpbWVvdXRNcyAgVGhlIHRpbWVvdXQgZm9yIHRoZSBwdWJsaXNoIG9wZXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgZXZlbnQgaGFzIGJlZW4gcHVibGlzaGVkIG9yIHJlamVjdHMgaWYgdGhlIG9wZXJhdGlvbiB0aW1lcyBvdXRcbiAgICovXG4gIGFzeW5jIHB1Ymxpc2goZXZlbnQsIHRpbWVvdXRNcyA9IDI1MDApIHtcbiAgICBsZXQgdGltZW91dDtcbiAgICBjb25zdCBwdWJsaXNoQ29ubmVjdGVkID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnB1Ymxpc2hFdmVudChldmVudCkudGhlbigoX3Jlc3VsdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uZGtSZWxheS5lbWl0KFwicHVibGlzaGVkXCIsIGV2ZW50KTtcbiAgICAgICAgICAgIGV2ZW50LmVtaXQoXCJyZWxheTpwdWJsaXNoZWRcIiwgdGhpcy5uZGtSZWxheSk7XG4gICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aW1lb3V0ID0gdm9pZCAwO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGBUaW1lb3V0OiAke3RpbWVvdXRNc31tc2ApKTtcbiAgICAgIH0sIHRpbWVvdXRNcyk7XG4gICAgfSk7XG4gICAgY29uc3Qgb25Db25uZWN0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHB1Ymxpc2hDb25uZWN0ZWQoKS50aGVuKChyZXN1bHQpID0+IGNvbm5lY3RSZXNvbHZlKHJlc3VsdCkpLmNhdGNoKChlcnIpID0+IGNvbm5lY3RSZWplY3QoZXJyKSk7XG4gICAgfTtcbiAgICBsZXQgY29ubmVjdFJlc29sdmU7XG4gICAgbGV0IGNvbm5lY3RSZWplY3Q7XG4gICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgIHRoaXMubmRrUmVsYXkuZGVidWcoXCJQdWJsaXNoIGZhaWxlZFwiLCBlcnIsIGV2ZW50LmlkKTtcbiAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcInB1Ymxpc2g6ZmFpbGVkXCIsIGV2ZW50LCBlcnIpO1xuICAgICAgZXZlbnQuZW1pdChcInJlbGF5OnB1Ymxpc2g6ZmFpbGVkXCIsIHRoaXMubmRrUmVsYXksIGVycik7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfTtcbiAgICBjb25zdCBvbkZpbmFsbHkgPSAoKSA9PiB7XG4gICAgICBpZiAodGltZW91dCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGhpcy5uZGtSZWxheS5yZW1vdmVMaXN0ZW5lcihcImNvbm5lY3RcIiwgb25Db25uZWN0SGFuZGxlcik7XG4gICAgfTtcbiAgICBpZiAodGhpcy5uZGtSZWxheS5zdGF0dXMgPj0gNSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW3B1Ymxpc2hDb25uZWN0ZWQoKSwgdGltZW91dFByb21pc2VdKS5jYXRjaChvbkVycm9yKS5maW5hbGx5KG9uRmluYWxseSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm5ka1JlbGF5LnN0YXR1cyA8PSAxIC8qIERJU0NPTk5FQ1RFRCAqLykge1xuICAgICAgY29uc29sZS53YXJuKFwiUmVsYXkgaXMgZGlzY29ubmVjdGVkLCB0cnlpbmcgdG8gY29ubmVjdCB0byBwdWJsaXNoIGFuIGV2ZW50XCIsIHRoaXMubmRrUmVsYXkudXJsKTtcbiAgICAgIHRoaXMubmRrUmVsYXkuY29ubmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJSZWxheSBub3QgY29ubmVjdGVkLCB3YWl0aW5nIGZvciBjb25uZWN0aW9uIHRvIHB1Ymxpc2ggYW4gZXZlbnRcIiwgdGhpcy5uZGtSZWxheS51cmwpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29ubmVjdFJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICBjb25uZWN0UmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB0aGlzLm5ka1JlbGF5Lm9uKFwiY29ubmVjdFwiLCBvbkNvbm5lY3RIYW5kbGVyKTtcbiAgICAgIH0pLFxuICAgICAgdGltZW91dFByb21pc2VcbiAgICBdKS5jYXRjaChvbkVycm9yKS5maW5hbGx5KG9uRmluYWxseSk7XG4gIH1cbiAgYXN5bmMgcHVibGlzaEV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMubmRrUmVsYXkuY29ubmVjdGl2aXR5LnB1Ymxpc2goZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9zdWJzY3JpcHRpb24vZ3JvdXBpbmcudHNcbmZ1bmN0aW9uIGZpbHRlckZpbmdlcnByaW50KGZpbHRlcnMsIGNsb3NlT25Fb3NlKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gW107XG4gIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlcnMpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmVudHJpZXMoZmlsdGVyIHx8IHt9KS5tYXAoKFtrZXksIHZhbHVlc10pID0+IHtcbiAgICAgIGlmIChbXCJzaW5jZVwiLCBcInVudGlsXCJdLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGAke2tleX06JHt2YWx1ZXN9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXk7XG4gICAgfSkuc29ydCgpLmpvaW4oXCItXCIpO1xuICAgIGVsZW1lbnRzLnB1c2goa2V5cyk7XG4gIH1cbiAgbGV0IGlkID0gY2xvc2VPbkVvc2UgPyBcIitcIiA6IFwiXCI7XG4gIGlkICs9IGVsZW1lbnRzLmpvaW4oXCJ8XCIpO1xuICByZXR1cm4gaWQ7XG59XG5mdW5jdGlvbiBtZXJnZUZpbHRlcnMoZmlsdGVycykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgbGFzdFJlc3VsdCA9IHt9O1xuICBmaWx0ZXJzLmZpbHRlcigoZikgPT4gISFmLmxpbWl0KS5mb3JFYWNoKChmaWx0ZXJXaXRoTGltaXQpID0+IHJlc3VsdC5wdXNoKGZpbHRlcldpdGhMaW1pdCkpO1xuICBmaWx0ZXJzID0gZmlsdGVycy5maWx0ZXIoKGYpID0+ICFmLmxpbWl0KTtcbiAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzdWx0O1xuICBmaWx0ZXJzLmZvckVhY2goKGZpbHRlcikgPT4ge1xuICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGxhc3RSZXN1bHRba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgbGFzdFJlc3VsdFtrZXldID0gWy4uLnZhbHVlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0UmVzdWx0W2tleV0gPSBBcnJheS5mcm9tKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi5sYXN0UmVzdWx0W2tleV0sIC4uLnZhbHVlXSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0UmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBbLi4ucmVzdWx0LCBsYXN0UmVzdWx0XTtcbn1cblxuLy8gc3JjL3JlbGF5L3N1YnNjcmlwdGlvbi50c1xudmFyIE5ES1JlbGF5U3Vic2NyaXB0aW9uID0gY2xhc3Mge1xuICBmaW5nZXJwcmludDtcbiAgaXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB0b3BTdWJNYW5hZ2VyO1xuICBkZWJ1ZztcbiAgLyoqXG4gICAqIFRyYWNrcyB0aGUgc3RhdHVzIG9mIHRoaXMgUkVRLlxuICAgKi9cbiAgc3RhdHVzID0gMCAvKiBJTklUSUFMICovO1xuICBvbkNsb3NlO1xuICByZWxheTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBzdWJzY3JpcHRpb24gaGFzIHJlYWNoZWQgRU9TRS5cbiAgICovXG4gIGVvc2VkID0gZmFsc2U7XG4gIC8qKlxuICAgKiBUaW1lb3V0IGF0IHdoaWNoIHRoaXMgc3Vic2NyaXB0aW9uIHdpbGxcbiAgICogc3RhcnQgZXhlY3V0aW5nLlxuICAgKi9cbiAgZXhlY3V0aW9uVGltZXI7XG4gIC8qKlxuICAgKiBUcmFjayB0aGUgdGltZSBhdCB3aGljaCB0aGlzIHN1YnNjcmlwdGlvbiB3aWxsIGZpcmUuXG4gICAqL1xuICBmaXJlVGltZTtcbiAgLyoqXG4gICAqIFRoZSBkZWxheSB0eXBlIHRoYXQgdGhlIGN1cnJlbnQgZmlyZVRpbWUgd2FzIGNhbGN1bGF0ZWQgd2l0aC5cbiAgICovXG4gIGRlbGF5VHlwZTtcbiAgLyoqXG4gICAqIFRoZSBmaWx0ZXJzIHRoYXQgaGF2ZSBiZWVuIGV4ZWN1dGVkLlxuICAgKi9cbiAgZXhlY3V0ZUZpbHRlcnM7XG4gIGlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpO1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGZpbmdlcnByaW50IFRoZSBmaW5nZXJwcmludCBvZiB0aGlzIHN1YnNjcmlwdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbGF5LCBmaW5nZXJwcmludCwgdG9wU3ViTWFuYWdlcikge1xuICAgIHRoaXMucmVsYXkgPSByZWxheTtcbiAgICB0aGlzLnRvcFN1Yk1hbmFnZXIgPSB0b3BTdWJNYW5hZ2VyO1xuICAgIHRoaXMuZGVidWcgPSByZWxheS5kZWJ1Zy5leHRlbmQoYHN1Ylske3RoaXMuaWR9XWApO1xuICAgIHRoaXMuZmluZ2VycHJpbnQgPSBmaW5nZXJwcmludCB8fCBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyk7XG4gIH1cbiAgX3N1YklkO1xuICBnZXQgc3ViSWQoKSB7XG4gICAgaWYgKHRoaXMuX3N1YklkKSByZXR1cm4gdGhpcy5fc3ViSWQ7XG4gICAgdGhpcy5fc3ViSWQgPSB0aGlzLmZpbmdlcnByaW50LnNsaWNlKDAsIDE1KTtcbiAgICByZXR1cm4gdGhpcy5fc3ViSWQ7XG4gIH1cbiAgc3ViSWRQYXJ0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGFkZFN1YklkUGFydChwYXJ0KSB7XG4gICAgdGhpcy5zdWJJZFBhcnRzLmFkZChwYXJ0KTtcbiAgfVxuICBhZGRJdGVtKHN1YnNjcmlwdGlvbiwgZmlsdGVycykge1xuICAgIHRoaXMuZGVidWcoXCJBZGRpbmcgaXRlbVwiLCB7XG4gICAgICBmaWx0ZXJzLFxuICAgICAgaW50ZXJuYWxJZDogc3Vic2NyaXB0aW9uLmludGVybmFsSWQsXG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgZmluZ2VycHJpbnQ6IHRoaXMuZmluZ2VycHJpbnQsXG4gICAgICBpZDogdGhpcy5zdWJJZCxcbiAgICAgIGl0ZW1zOiB0aGlzLml0ZW1zLFxuICAgICAgaXRlbXNTaXplOiB0aGlzLml0ZW1zLnNpemVcbiAgICB9KTtcbiAgICBpZiAodGhpcy5pdGVtcy5oYXMoc3Vic2NyaXB0aW9uLmludGVybmFsSWQpKSByZXR1cm47XG4gICAgc3Vic2NyaXB0aW9uLm9uKFwiY2xvc2VcIiwgdGhpcy5yZW1vdmVJdGVtLmJpbmQodGhpcywgc3Vic2NyaXB0aW9uKSk7XG4gICAgdGhpcy5pdGVtcy5zZXQoc3Vic2NyaXB0aW9uLmludGVybmFsSWQsIHsgc3Vic2NyaXB0aW9uLCBmaWx0ZXJzIH0pO1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gMyAvKiBSVU5OSU5HICovKSB7XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uLnN1YklkICYmICghdGhpcy5fc3ViSWQgfHwgdGhpcy5fc3ViSWQubGVuZ3RoIDwgNDgpKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMCAvKiBJTklUSUFMICovIHx8IHRoaXMuc3RhdHVzID09PSAxIC8qIFBFTkRJTkcgKi8pIHtcbiAgICAgICAgICB0aGlzLmFkZFN1YklkUGFydChzdWJzY3JpcHRpb24uc3ViSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5zdGF0dXMpIHtcbiAgICAgIGNhc2UgMCAvKiBJTklUSUFMICovOlxuICAgICAgICB0aGlzLmV2YWx1YXRlRXhlY3V0aW9uUGxhbihzdWJzY3JpcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMyAvKiBSVU5OSU5HICovOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMSAvKiBQRU5ESU5HICovOlxuICAgICAgICB0aGlzLmV2YWx1YXRlRXhlY3V0aW9uUGxhbihzdWJzY3JpcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNCAvKiBDTE9TRUQgKi86XG4gICAgICAgIHRoaXMuZGVidWcoXCJTdWJzY3JpcHRpb24gaXMgY2xvc2VkLCBjYW5ub3QgYWRkIG5ldyBpdGVtcyAlbyAoJW8pXCIsIHN1YnNjcmlwdGlvbiwgZmlsdGVycyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgbmV3IGl0ZW1zIHRvIGEgY2xvc2VkIHN1YnNjcmlwdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEEgc3Vic2NyaXB0aW9uIGhhcyBiZWVuIGNsb3NlZCwgcmVtb3ZlIGl0IGZyb20gdGhlIGxpc3Qgb2YgaXRlbXMuXG4gICAqIEBwYXJhbSBzdWJzY3JpcHRpb25cbiAgICovXG4gIHJlbW92ZUl0ZW0oc3Vic2NyaXB0aW9uKSB7XG4gICAgdGhpcy5pdGVtcy5kZWxldGUoc3Vic2NyaXB0aW9uLmludGVybmFsSWQpO1xuICAgIGlmICh0aGlzLml0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIGlmICghdGhpcy5lb3NlZCkgcmV0dXJuO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfVxuICB9XG4gIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gNCAvKiBDTE9TRUQgKi8pIHJldHVybjtcbiAgICBjb25zdCBwcmV2U3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gICAgdGhpcy5zdGF0dXMgPSA0IC8qIENMT1NFRCAqLztcbiAgICBpZiAocHJldlN0YXR1cyA9PT0gMyAvKiBSVU5OSU5HICovKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnJlbGF5LmNsb3NlKHRoaXMuc3ViSWQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiRXJyb3IgY2xvc2luZyBzdWJzY3JpcHRpb25cIiwgZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVidWcoXCJTdWJzY3JpcHRpb24gd2FudGVkIHRvIGNsb3NlIGJ1dCBpdCB3YXNuJ3QgcnVubmluZywgdGhpcyBpcyBwcm9iYWJseSBva1wiLCB7XG4gICAgICAgIHN1YklkOiB0aGlzLnN1YklkLFxuICAgICAgICBwcmV2U3RhdHVzLFxuICAgICAgICBzdWI6IHRoaXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLmV4ZWN1dGlvblRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5leGVjdXRpb25UaW1lcik7XG4gICAgdGhpcy5yZWxheS5vZmYoXCJyZWFkeVwiLCB0aGlzLmV4ZWN1dGVPblJlbGF5UmVhZHkpO1xuICAgIHRoaXMucmVsYXkub2ZmKFwiYXV0aGVkXCIsIHRoaXMucmVFeGVjdXRlQWZ0ZXJBdXRoKTtcbiAgICBpZiAodGhpcy5vbkNsb3NlKSB0aGlzLm9uQ2xvc2UodGhpcyk7XG4gIH1cbiAgZXZhbHVhdGVFeGVjdXRpb25QbGFuKHN1YnNjcmlwdGlvbikge1xuICAgIGlmICghc3Vic2NyaXB0aW9uLmlzR3JvdXBhYmxlKCkpIHtcbiAgICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgICAgdGhpcy5leGVjdXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdWJzY3JpcHRpb24uZmlsdGVycy5maW5kKChmaWx0ZXIpID0+ICEhZmlsdGVyLmxpbWl0KSkge1xuICAgICAgdGhpcy5leGVjdXRlRmlsdGVycyA9IHRoaXMuY29tcGlsZUZpbHRlcnMoKTtcbiAgICAgIGlmICh0aGlzLmV4ZWN1dGVGaWx0ZXJzLmxlbmd0aCA+PSAxMCkge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IDEgLyogUEVORElORyAqLztcbiAgICAgICAgdGhpcy5leGVjdXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVsYXkgPSBzdWJzY3JpcHRpb24uZ3JvdXBhYmxlRGVsYXk7XG4gICAgY29uc3QgZGVsYXlUeXBlID0gc3Vic2NyaXB0aW9uLmdyb3VwYWJsZURlbGF5VHlwZTtcbiAgICBpZiAoIWRlbGF5KSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ3JvdXAgYSBzdWJzY3JpcHRpb24gd2l0aG91dCBhIGRlbGF5XCIpO1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMCAvKiBJTklUSUFMICovKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlKGRlbGF5LCBkZWxheVR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBleGlzdGluZ0RlbGF5VHlwZSA9IHRoaXMuZGVsYXlUeXBlO1xuICAgICAgY29uc3QgdGltZVVudGlsRmlyZSA9IHRoaXMuZmlyZVRpbWUgLSBEYXRlLm5vdygpO1xuICAgICAgaWYgKGV4aXN0aW5nRGVsYXlUeXBlID09PSBcImF0LWxlYXN0XCIgJiYgZGVsYXlUeXBlID09PSBcImF0LWxlYXN0XCIpIHtcbiAgICAgICAgaWYgKHRpbWVVbnRpbEZpcmUgPCBkZWxheSkge1xuICAgICAgICAgIGlmICh0aGlzLmV4ZWN1dGlvblRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5leGVjdXRpb25UaW1lcik7XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZShkZWxheSwgZGVsYXlUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleGlzdGluZ0RlbGF5VHlwZSA9PT0gXCJhdC1sZWFzdFwiICYmIGRlbGF5VHlwZSA9PT0gXCJhdC1tb3N0XCIpIHtcbiAgICAgICAgaWYgKHRpbWVVbnRpbEZpcmUgPiBkZWxheSkge1xuICAgICAgICAgIGlmICh0aGlzLmV4ZWN1dGlvblRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5leGVjdXRpb25UaW1lcik7XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZShkZWxheSwgZGVsYXlUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleGlzdGluZ0RlbGF5VHlwZSA9PT0gXCJhdC1tb3N0XCIgJiYgZGVsYXlUeXBlID09PSBcImF0LW1vc3RcIikge1xuICAgICAgICBpZiAodGltZVVudGlsRmlyZSA+IGRlbGF5KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmV4ZWN1dGlvblRpbWVyKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlKGRlbGF5LCBkZWxheVR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nRGVsYXlUeXBlID09PSBcImF0LW1vc3RcIiAmJiBkZWxheVR5cGUgPT09IFwiYXQtbGVhc3RcIikge1xuICAgICAgICBpZiAodGltZVVudGlsRmlyZSA+IGRlbGF5KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmV4ZWN1dGlvblRpbWVyKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlKGRlbGF5LCBkZWxheVR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGVsYXkgdHlwZSBjb21iaW5hdGlvbiAke2V4aXN0aW5nRGVsYXlUeXBlfSAke2RlbGF5VHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2NoZWR1bGUoZGVsYXksIGRlbGF5VHlwZSkge1xuICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmZpcmVUaW1lID0gY3VycmVudFRpbWUgKyBkZWxheTtcbiAgICB0aGlzLmRlbGF5VHlwZSA9IGRlbGF5VHlwZTtcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQodGhpcy5leGVjdXRlLmJpbmQodGhpcyksIGRlbGF5KTtcbiAgICBpZiAoZGVsYXlUeXBlID09PSBcImF0LWxlYXN0XCIpIHtcbiAgICAgIHRoaXMuZXhlY3V0aW9uVGltZXIgPSB0aW1lcjtcbiAgICB9XG4gIH1cbiAgZXhlY3V0ZU9uUmVsYXlSZWFkeSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IDIgLyogV0FJVElORyAqLykgcmV0dXJuO1xuICAgIGlmICh0aGlzLml0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuZGVidWcoXCJObyBpdGVtcyB0byBleGVjdXRlOyB0aGlzIHJlbGF5IHdhcyBwcm9iYWJseSB0b28gc2xvdyB0byByZXNwb25kIGFuZCB0aGUgY2FsbGVyIGdhdmUgdXBcIiwge1xuICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICBmaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCxcbiAgICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICAgIGl0ZW1zU2l6ZTogdGhpcy5pdGVtcy5zaXplLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgc3ViSWQ6IHRoaXMuc3ViSWRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGVidWcoXCJFeGVjdXRpbmcgb24gcmVsYXkgcmVhZHlcIiwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIGZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LFxuICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICBpdGVtc1NpemU6IHRoaXMuaXRlbXMuc2l6ZVxuICAgIH0pO1xuICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgIHRoaXMuZXhlY3V0ZSgpO1xuICB9O1xuICBmaW5hbGl6ZVN1YklkKCkge1xuICAgIGlmICh0aGlzLnN1YklkUGFydHMuc2l6ZSA+IDApIHtcbiAgICAgIHRoaXMuX3N1YklkID0gQXJyYXkuZnJvbSh0aGlzLnN1YklkUGFydHMpLmpvaW4oXCItXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdWJJZCA9IHRoaXMuZmluZ2VycHJpbnQuc2xpY2UoMCwgMTUpO1xuICAgIH1cbiAgICB0aGlzLl9zdWJJZCArPSBgLSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDcpfWA7XG4gIH1cbiAgLy8gd2UgZG8gaXQgdGhpcyB3YXkgc28gdGhhdCB3ZSBjYW4gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuICByZUV4ZWN1dGVBZnRlckF1dGggPSAoKCkgPT4ge1xuICAgIGNvbnN0IG9sZFN1YklkID0gdGhpcy5zdWJJZDtcbiAgICB0aGlzLmRlYnVnKFwiUmUtZXhlY3V0aW5nIGFmdGVyIGF1dGhcIiwgdGhpcy5pdGVtcy5zaXplKTtcbiAgICBpZiAodGhpcy5lb3NlZCkge1xuICAgICAgdGhpcy5yZWxheS5jbG9zZSh0aGlzLnN1YklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWJ1ZyhcIldlIGFyZSBhYmFuZG9uaW5nIGFuIG9wZW5lZCBzdWJzY3JpcHRpb24sIG9uY2UgaXQgRU9TRSdzLCB0aGUgaGFuZGxlciB3aWxsIGNsb3NlIGl0XCIsIHtcbiAgICAgICAgb2xkU3ViSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9zdWJJZCA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXR1cyA9IDEgLyogUEVORElORyAqLztcbiAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICB0aGlzLmRlYnVnKFwiUmUtZXhlY3V0ZWQgYWZ0ZXIgYXV0aCAlcyBcXHV7MUY0NDl9ICVzXCIsIG9sZFN1YklkLCB0aGlzLnN1YklkKTtcbiAgfSkuYmluZCh0aGlzKTtcbiAgZXhlY3V0ZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IDEgLyogUEVORElORyAqLykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVsYXkuY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IDIgLyogV0FJVElORyAqLztcbiAgICAgIHRoaXMuZGVidWcoXCJXYWl0aW5nIGZvciByZWxheSB0byBiZSByZWFkeVwiLCB7XG4gICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgIGlkOiB0aGlzLnN1YklkLFxuICAgICAgICBmaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCxcbiAgICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICAgIGl0ZW1zU2l6ZTogdGhpcy5pdGVtcy5zaXplXG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVsYXkub25jZShcInJlYWR5XCIsIHRoaXMuZXhlY3V0ZU9uUmVsYXlSZWFkeSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnJlbGF5LnN0YXR1cyA8IDggLyogQVVUSEVOVElDQVRFRCAqLykge1xuICAgICAgdGhpcy5yZWxheS5vbmNlKFwiYXV0aGVkXCIsIHRoaXMucmVFeGVjdXRlQWZ0ZXJBdXRoKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0dXMgPSAzIC8qIFJVTk5JTkcgKi87XG4gICAgdGhpcy5maW5hbGl6ZVN1YklkKCk7XG4gICAgdGhpcy5leGVjdXRlRmlsdGVycyA9IHRoaXMuY29tcGlsZUZpbHRlcnMoKTtcbiAgICB0aGlzLnJlbGF5LnJlcSh0aGlzKTtcbiAgfVxuICBvbnN0YXJ0KCkge1xuICB9XG4gIG9uZXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLnRvcFN1Yk1hbmFnZXIuZGlzcGF0Y2hFdmVudChldmVudCwgdGhpcy5yZWxheSk7XG4gIH1cbiAgb25lb3NlKHN1YklkKSB7XG4gICAgdGhpcy5lb3NlZCA9IHRydWU7XG4gICAgaWYgKHN1YklkICE9PSB0aGlzLnN1YklkKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiUmVjZWl2ZWQgRU9TRSBmb3IgYW4gYWJhbmRvbmVkIHN1YnNjcmlwdGlvblwiLCBzdWJJZCwgdGhpcy5zdWJJZCk7XG4gICAgICB0aGlzLnJlbGF5LmNsb3NlKHN1YklkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXRlbXMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHsgc3Vic2NyaXB0aW9uIH0gb2YgdGhpcy5pdGVtcy52YWx1ZXMoKSkge1xuICAgICAgc3Vic2NyaXB0aW9uLmVvc2VSZWNlaXZlZCh0aGlzLnJlbGF5KTtcbiAgICAgIGlmIChzdWJzY3JpcHRpb24uY2xvc2VPbkVvc2UpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIlJlbW92aW5nIGl0ZW0gYmVjYXVzZSBvZiBFT1NFXCIsIHtcbiAgICAgICAgICBmaWx0ZXJzOiBzdWJzY3JpcHRpb24uZmlsdGVycyxcbiAgICAgICAgICBpbnRlcm5hbElkOiBzdWJzY3JpcHRpb24uaW50ZXJuYWxJZCxcbiAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgIGZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LFxuICAgICAgICAgIGl0ZW1zOiB0aGlzLml0ZW1zLFxuICAgICAgICAgIGl0ZW1zU2l6ZTogdGhpcy5pdGVtcy5zaXplXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlbW92ZUl0ZW0oc3Vic2NyaXB0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25jbG9zZShfcmVhc29uKSB7XG4gICAgdGhpcy5zdGF0dXMgPSA0IC8qIENMT1NFRCAqLztcbiAgfVxuICBvbmNsb3NlZChyZWFzb24pIHtcbiAgICBpZiAoIXJlYXNvbikgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgeyBzdWJzY3JpcHRpb24gfSBvZiB0aGlzLml0ZW1zLnZhbHVlcygpKSB7XG4gICAgICBzdWJzY3JpcHRpb24uY2xvc2VkUmVjZWl2ZWQodGhpcy5yZWxheSwgcmVhc29uKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdyYWJzIHRoZSBmaWx0ZXJzIGZyb20gYWxsIHRoZSBzdWJzY3JpcHRpb25zXG4gICAqIGFuZCBtZXJnZXMgdGhlbSBpbnRvIGEgc2luZ2xlIGZpbHRlci5cbiAgICovXG4gIGNvbXBpbGVGaWx0ZXJzKCkge1xuICAgIGNvbnN0IG1lcmdlZEZpbHRlcnMgPSBbXTtcbiAgICBjb25zdCBmaWx0ZXJzID0gQXJyYXkuZnJvbSh0aGlzLml0ZW1zLnZhbHVlcygpKS5tYXAoKGl0ZW0pID0+IGl0ZW0uZmlsdGVycyk7XG4gICAgaWYgKCFmaWx0ZXJzWzBdKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiXFx1ezFGNDQwfSBObyBmaWx0ZXJzIHRvIG1lcmdlXCIsIHRoaXMuaXRlbXMpO1xuICAgICAgY29uc29sZS5lcnJvcihcIkJVRzogTm8gZmlsdGVycyB0byBtZXJnZSFcIiwgdGhpcy5pdGVtcyk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlckNvdW50ID0gZmlsdGVyc1swXS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhbGxGaWx0ZXJzQXRJbmRleCA9IGZpbHRlcnMubWFwKChmaWx0ZXIpID0+IGZpbHRlcltpXSk7XG4gICAgICBtZXJnZWRGaWx0ZXJzLnB1c2goLi4ubWVyZ2VGaWx0ZXJzKGFsbEZpbHRlcnNBdEluZGV4KSk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWRGaWx0ZXJzO1xuICB9XG59O1xuXG4vLyBzcmMvcmVsYXkvc3ViLW1hbmFnZXIudHNcbnZhciBOREtSZWxheVN1YnNjcmlwdGlvbk1hbmFnZXIgPSBjbGFzcyB7XG4gIHJlbGF5O1xuICBzdWJzY3JpcHRpb25zO1xuICBnZW5lcmFsU3ViTWFuYWdlcjtcbiAgLyoqXG4gICAqIEBwYXJhbSByZWxheSAtIFRoZSByZWxheSBpbnN0YW5jZS5cbiAgICogQHBhcmFtIGdlbmVyYWxTdWJNYW5hZ2VyIC0gVGhlIHN1YnNjcmlwdGlvbiBtYW5hZ2VyIGluc3RhbmNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVsYXksIGdlbmVyYWxTdWJNYW5hZ2VyKSB7XG4gICAgdGhpcy5yZWxheSA9IHJlbGF5O1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5nZW5lcmFsU3ViTWFuYWdlciA9IGdlbmVyYWxTdWJNYW5hZ2VyO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgc3Vic2NyaXB0aW9uIHRvIHRoZSBtYW5hZ2VyLlxuICAgKi9cbiAgYWRkU3Vic2NyaXB0aW9uKHN1YiwgZmlsdGVycykge1xuICAgIGxldCByZWxheVN1YjtcbiAgICBpZiAoIXN1Yi5pc0dyb3VwYWJsZSgpKSB7XG4gICAgICByZWxheVN1YiA9IHRoaXMuY3JlYXRlU3Vic2NyaXB0aW9uKHN1YiwgZmlsdGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpbHRlckZwID0gZmlsdGVyRmluZ2VycHJpbnQoZmlsdGVycywgc3ViLmNsb3NlT25Fb3NlKTtcbiAgICAgIGlmIChmaWx0ZXJGcCkge1xuICAgICAgICBjb25zdCBleGlzdGluZ1N1YnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KGZpbHRlckZwKTtcbiAgICAgICAgcmVsYXlTdWIgPSAoZXhpc3RpbmdTdWJzIHx8IFtdKS5maW5kKChzdWIyKSA9PiBzdWIyLnN0YXR1cyA8IDMgLyogUlVOTklORyAqLyk7XG4gICAgICB9XG4gICAgICByZWxheVN1YiA/Pz0gdGhpcy5jcmVhdGVTdWJzY3JpcHRpb24oc3ViLCBmaWx0ZXJzLCBmaWx0ZXJGcCk7XG4gICAgfVxuICAgIHJlbGF5U3ViLmFkZEl0ZW0oc3ViLCBmaWx0ZXJzKTtcbiAgfVxuICBjcmVhdGVTdWJzY3JpcHRpb24oX3N1YiwgX2ZpbHRlcnMsIGZpbmdlcnByaW50KSB7XG4gICAgY29uc3QgcmVsYXlTdWIgPSBuZXcgTkRLUmVsYXlTdWJzY3JpcHRpb24odGhpcy5yZWxheSwgZmluZ2VycHJpbnQgfHwgbnVsbCwgdGhpcy5nZW5lcmFsU3ViTWFuYWdlcik7XG4gICAgcmVsYXlTdWIub25DbG9zZSA9IHRoaXMub25SZWxheVN1YnNjcmlwdGlvbkNsb3NlLmJpbmQodGhpcyk7XG4gICAgY29uc3QgY3VycmVudFZhbCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQocmVsYXlTdWIuZmluZ2VycHJpbnQpID8/IFtdO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQocmVsYXlTdWIuZmluZ2VycHJpbnQsIFsuLi5jdXJyZW50VmFsLCByZWxheVN1Yl0pO1xuICAgIHJldHVybiByZWxheVN1YjtcbiAgfVxuICBvblJlbGF5U3Vic2NyaXB0aW9uQ2xvc2Uoc3ViKSB7XG4gICAgbGV0IGN1cnJlbnRWYWwgPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KHN1Yi5maW5nZXJwcmludCkgPz8gW107XG4gICAgaWYgKCFjdXJyZW50VmFsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJVbmV4cGVjdGVkbHkgZGlkIG5vdCBmaW5kIGEgc3Vic2NyaXB0aW9uIHdpdGggZmluZ2VycHJpbnRcIiwgc3ViLmZpbmdlcnByaW50KTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRWYWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1Yi5maW5nZXJwcmludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRWYWwgPSBjdXJyZW50VmFsLmZpbHRlcigocykgPT4gcy5pZCAhPT0gc3ViLmlkKTtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQoc3ViLmZpbmdlcnByaW50LCBjdXJyZW50VmFsKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9yZWxheS9zaWduYXR1cmUtdmVyaWZpY2F0aW9uLXN0YXRzLnRzXG5pbXBvcnQgZGVidWcgZnJvbSBcImRlYnVnXCI7XG52YXIgU2lnbmF0dXJlVmVyaWZpY2F0aW9uU3RhdHMgPSBjbGFzcyB7XG4gIG5kaztcbiAgZGVidWc7XG4gIGludGVydmFsSWQgPSBudWxsO1xuICBpbnRlcnZhbE1zO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTaWduYXR1cmVWZXJpZmljYXRpb25TdGF0cyBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0gbmRrIC0gVGhlIE5ESyBpbnN0YW5jZSB0byB0cmFjayBzdGF0cyBmb3JcbiAgICogQHBhcmFtIGludGVydmFsTXMgLSBIb3cgb2Z0ZW4gdG8gcHJpbnQgc3RhdHMgKGluIG1pbGxpc2Vjb25kcylcbiAgICovXG4gIGNvbnN0cnVjdG9yKG5kaywgaW50ZXJ2YWxNcyA9IDFlNCkge1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMuZGVidWcgPSBkZWJ1ZyhcIm5kazpzaWduYXR1cmUtdmVyaWZpY2F0aW9uLXN0YXRzXCIpO1xuICAgIHRoaXMuaW50ZXJ2YWxNcyA9IGludGVydmFsTXM7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IHRyYWNraW5nIGFuZCByZXBvcnRpbmcgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBzdGF0aXN0aWNzXG4gICAqL1xuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy5pbnRlcnZhbElkKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiU3RhdHMgdHJhY2tpbmcgYWxyZWFkeSBzdGFydGVkXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRlYnVnKGBTdGFydGluZyBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIHN0YXRzIHJlcG9ydGluZyBldmVyeSAke3RoaXMuaW50ZXJ2YWxNc31tc2ApO1xuICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMucmVwb3J0U3RhdHMoKTtcbiAgICB9LCB0aGlzLmludGVydmFsTXMpO1xuICB9XG4gIC8qKlxuICAgKiBTdG9wIHRyYWNraW5nIGFuZCByZXBvcnRpbmcgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBzdGF0aXN0aWNzXG4gICAqL1xuICBzdG9wKCkge1xuICAgIGlmICghdGhpcy5pbnRlcnZhbElkKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiU3RhdHMgdHJhY2tpbmcgbm90IHN0YXJ0ZWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICB0aGlzLmludGVydmFsSWQgPSBudWxsO1xuICAgIHRoaXMuZGVidWcoXCJTdG9wcGVkIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gc3RhdHMgcmVwb3J0aW5nXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZXBvcnQgY3VycmVudCBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIHN0YXRpc3RpY3MgZm9yIGFsbCByZWxheXNcbiAgICovXG4gIHJlcG9ydFN0YXRzKCkge1xuICAgIGNvbnN0IHN0YXRzID0gdGhpcy5jb2xsZWN0U3RhdHMoKTtcbiAgICBjb25zb2xlLmxvZyhcIlxcbj09PSBTaWduYXR1cmUgVmVyaWZpY2F0aW9uIFNhbXBsaW5nIFN0YXRzID09PVwiKTtcbiAgICBjb25zb2xlLmxvZyhgVGltZXN0YW1wOiAkeygvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudG9JU09TdHJpbmcoKX1gKTtcbiAgICBjb25zb2xlLmxvZyhgVG90YWwgUmVsYXlzOiAke3N0YXRzLnRvdGFsUmVsYXlzfWApO1xuICAgIGNvbnNvbGUubG9nKGBDb25uZWN0ZWQgUmVsYXlzOiAke3N0YXRzLmNvbm5lY3RlZFJlbGF5c31gKTtcbiAgICBpZiAoc3RhdHMucmVsYXlTdGF0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiTm8gcmVsYXkgc3RhdGlzdGljcyBhdmFpbGFibGVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiXFxuUmVsYXkgU3RhdGlzdGljczpcIik7XG4gICAgICBzdGF0cy5yZWxheVN0YXRzLnNvcnQoKGEsIGIpID0+IGEudXJsLmxvY2FsZUNvbXBhcmUoYi51cmwpKTtcbiAgICAgIHN0YXRzLnJlbGF5U3RhdHMuZm9yRWFjaCgocmVsYXlTdGF0KSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBcbiAgJHtyZWxheVN0YXQudXJsfSAke3JlbGF5U3RhdC5jb25uZWN0ZWQgPyBcIihjb25uZWN0ZWQpXCIgOiBcIihkaXNjb25uZWN0ZWQpXCJ9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgICAgVmFsaWRhdGVkIEV2ZW50czogJHtyZWxheVN0YXQudmFsaWRhdGVkQ291bnR9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgICAgTm9uLXZhbGlkYXRlZCBFdmVudHM6ICR7cmVsYXlTdGF0Lm5vblZhbGlkYXRlZENvdW50fWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgICAgIFRvdGFsIEV2ZW50czogJHtyZWxheVN0YXQudG90YWxFdmVudHN9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGAgICAgQ3VycmVudCBWYWxpZGF0aW9uIFJhdGlvOiAke3JlbGF5U3RhdC52YWxpZGF0aW9uUmF0aW8udG9GaXhlZCg0KX0gKCR7KHJlbGF5U3RhdC52YWxpZGF0aW9uUmF0aW8gKiAxMDApLnRvRml4ZWQoMil9JSlgXG4gICAgICAgICk7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGAgICAgVGFyZ2V0IFZhbGlkYXRpb24gUmF0aW86ICR7cmVsYXlTdGF0LnRhcmdldFZhbGlkYXRpb25SYXRpbz8udG9GaXhlZCg0KSB8fCBcIk4vQVwifSAoJHtyZWxheVN0YXQudGFyZ2V0VmFsaWRhdGlvblJhdGlvID8gKHJlbGF5U3RhdC50YXJnZXRWYWxpZGF0aW9uUmF0aW8gKiAxMDApLnRvRml4ZWQoMikgKyBcIiVcIiA6IFwiTi9BXCJ9KWBcbiAgICAgICAgKTtcbiAgICAgICAgY29uc29sZS5sb2coYCAgICBUcnVzdGVkOiAke3JlbGF5U3RhdC50cnVzdGVkID8gXCJZZXNcIiA6IFwiTm9cIn1gKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhcIlxcbkdsb2JhbCBTZXR0aW5nczpcIik7XG4gICAgY29uc29sZS5sb2coXG4gICAgICBgICBJbml0aWFsIFZhbGlkYXRpb24gUmF0aW86ICR7c3RhdHMuaW5pdGlhbFZhbGlkYXRpb25SYXRpby50b0ZpeGVkKDQpfSAoJHsoc3RhdHMuaW5pdGlhbFZhbGlkYXRpb25SYXRpbyAqIDEwMCkudG9GaXhlZCgyKX0lKWBcbiAgICApO1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYCAgTG93ZXN0IFZhbGlkYXRpb24gUmF0aW86ICR7c3RhdHMubG93ZXN0VmFsaWRhdGlvblJhdGlvLnRvRml4ZWQoNCl9ICgkeyhzdGF0cy5sb3dlc3RWYWxpZGF0aW9uUmF0aW8gKiAxMDApLnRvRml4ZWQoMil9JSlgXG4gICAgKTtcbiAgICBjb25zb2xlLmxvZyhgICBBdXRvLWJsYWNrbGlzdCBJbnZhbGlkIFJlbGF5czogJHtzdGF0cy5hdXRvQmxhY2tsaXN0SW52YWxpZFJlbGF5cyA/IFwiWWVzXCIgOiBcIk5vXCJ9YCk7XG4gICAgY29uc29sZS5sb2coYCAgQmxhY2tsaXN0ZWQgUmVsYXlzOiAke3N0YXRzLmJsYWNrbGlzdGVkUmVsYXlDb3VudH1gKTtcbiAgICBjb25zb2xlLmxvZyhcIj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG5cIik7XG4gIH1cbiAgLyoqXG4gICAqIENvbGxlY3Qgc3RhdGlzdGljcyBmcm9tIGFsbCByZWxheXNcbiAgICovXG4gIGNvbGxlY3RTdGF0cygpIHtcbiAgICBjb25zdCByZWxheVN0YXRzID0gW107XG4gICAgZm9yIChjb25zdCByZWxheSBvZiB0aGlzLm5kay5wb29sLnJlbGF5cy52YWx1ZXMoKSkge1xuICAgICAgcmVsYXlTdGF0cy5wdXNoKHtcbiAgICAgICAgdXJsOiByZWxheS51cmwsXG4gICAgICAgIGNvbm5lY3RlZDogcmVsYXkuY29ubmVjdGVkLFxuICAgICAgICB2YWxpZGF0ZWRDb3VudDogcmVsYXkudmFsaWRhdGVkRXZlbnRDb3VudCxcbiAgICAgICAgbm9uVmFsaWRhdGVkQ291bnQ6IHJlbGF5Lm5vblZhbGlkYXRlZEV2ZW50Q291bnQsXG4gICAgICAgIHRvdGFsRXZlbnRzOiByZWxheS52YWxpZGF0ZWRFdmVudENvdW50ICsgcmVsYXkubm9uVmFsaWRhdGVkRXZlbnRDb3VudCxcbiAgICAgICAgdmFsaWRhdGlvblJhdGlvOiByZWxheS52YWxpZGF0aW9uUmF0aW8sXG4gICAgICAgIHRhcmdldFZhbGlkYXRpb25SYXRpbzogcmVsYXkudGFyZ2V0VmFsaWRhdGlvblJhdGlvLFxuICAgICAgICB0cnVzdGVkOiByZWxheS50cnVzdGVkXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsUmVsYXlzOiB0aGlzLm5kay5wb29sLnJlbGF5cy5zaXplLFxuICAgICAgY29ubmVjdGVkUmVsYXlzOiB0aGlzLm5kay5wb29sLmNvbm5lY3RlZFJlbGF5cygpLmxlbmd0aCxcbiAgICAgIHJlbGF5U3RhdHMsXG4gICAgICBpbml0aWFsVmFsaWRhdGlvblJhdGlvOiB0aGlzLm5kay5pbml0aWFsVmFsaWRhdGlvblJhdGlvLFxuICAgICAgbG93ZXN0VmFsaWRhdGlvblJhdGlvOiB0aGlzLm5kay5sb3dlc3RWYWxpZGF0aW9uUmF0aW8sXG4gICAgICBhdXRvQmxhY2tsaXN0SW52YWxpZFJlbGF5czogdGhpcy5uZGsuYXV0b0JsYWNrbGlzdEludmFsaWRSZWxheXMsXG4gICAgICBibGFja2xpc3RlZFJlbGF5Q291bnQ6IHRoaXMubmRrLmJsYWNrbGlzdFJlbGF5VXJscz8ubGVuZ3RoIHx8IDBcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gc3RhcnRTaWduYXR1cmVWZXJpZmljYXRpb25TdGF0cyhuZGssIGludGVydmFsTXMgPSAxZTQpIHtcbiAgY29uc3Qgc3RhdHMgPSBuZXcgU2lnbmF0dXJlVmVyaWZpY2F0aW9uU3RhdHMobmRrLCBpbnRlcnZhbE1zKTtcbiAgc3RhdHMuc3RhcnQoKTtcbiAgcmV0dXJuIHN0YXRzO1xufVxuXG4vLyBzcmMvcmVsYXkvaW5kZXgudHNcbnZhciBOREtSZWxheVN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ES1JlbGF5U3RhdHVzMikgPT4ge1xuICBOREtSZWxheVN0YXR1czJbTkRLUmVsYXlTdGF0dXMyW1wiRElTQ09OTkVDVElOR1wiXSA9IDBdID0gXCJESVNDT05ORUNUSU5HXCI7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJESVNDT05ORUNURURcIl0gPSAxXSA9IFwiRElTQ09OTkVDVEVEXCI7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJSRUNPTk5FQ1RJTkdcIl0gPSAyXSA9IFwiUkVDT05ORUNUSU5HXCI7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJGTEFQUElOR1wiXSA9IDNdID0gXCJGTEFQUElOR1wiO1xuICBOREtSZWxheVN0YXR1czJbTkRLUmVsYXlTdGF0dXMyW1wiQ09OTkVDVElOR1wiXSA9IDRdID0gXCJDT05ORUNUSU5HXCI7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJDT05ORUNURURcIl0gPSA1XSA9IFwiQ09OTkVDVEVEXCI7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJBVVRIX1JFUVVFU1RFRFwiXSA9IDZdID0gXCJBVVRIX1JFUVVFU1RFRFwiO1xuICBOREtSZWxheVN0YXR1czJbTkRLUmVsYXlTdGF0dXMyW1wiQVVUSEVOVElDQVRJTkdcIl0gPSA3XSA9IFwiQVVUSEVOVElDQVRJTkdcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkFVVEhFTlRJQ0FURURcIl0gPSA4XSA9IFwiQVVUSEVOVElDQVRFRFwiO1xuICByZXR1cm4gTkRLUmVsYXlTdGF0dXMyO1xufSkoTkRLUmVsYXlTdGF0dXMgfHwge30pO1xudmFyIE5ES1JlbGF5ID0gY2xhc3MgX05ES1JlbGF5IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgdXJsO1xuICBzY29yZXM7XG4gIGNvbm5lY3Rpdml0eTtcbiAgc3VicztcbiAgcHVibGlzaGVyO1xuICBhdXRoUG9saWN5O1xuICAvKipcbiAgICogVGhlIGxvd2VzdCB2YWxpZGF0aW9uIHJhdGlvIHRoaXMgcmVsYXkgY2FuIHJlYWNoLlxuICAgKi9cbiAgbG93ZXN0VmFsaWRhdGlvblJhdGlvO1xuICAvKipcbiAgICogQ3VycmVudCB2YWxpZGF0aW9uIHJhdGlvIHRoaXMgcmVsYXkgaXMgdGFyZ2V0aW5nLlxuICAgKi9cbiAgdGFyZ2V0VmFsaWRhdGlvblJhdGlvO1xuICB2YWxpZGF0aW9uUmF0aW9GbjtcbiAgLyoqXG4gICAqIFRoaXMgdHJhY2tzIGV2ZW50cyB0aGF0IGhhdmUgYmVlbiBzZWVuIGJ5IHRoaXMgcmVsYXlcbiAgICogd2l0aCBhIHZhbGlkIHNpZ25hdHVyZS5cbiAgICovXG4gIHZhbGlkYXRlZEV2ZW50Q291bnQgPSAwO1xuICAvKipcbiAgICogVGhpcyB0cmFja3MgZXZlbnRzIHRoYXQgaGF2ZSBiZWVuIHNlZW4gYnkgdGhpcyByZWxheVxuICAgKiBidXQgaGF2ZSBub3QgYmVlbiB2YWxpZGF0ZWQuXG4gICAqL1xuICBub25WYWxpZGF0ZWRFdmVudENvdW50ID0gMDtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyByZWxheSBpcyB0cnVzdGVkLlxuICAgKlxuICAgKiBUcnVzdGVkIHJlbGF5J3MgZXZlbnRzIGRvIG5vdCBnZXQgdGhlaXIgc2lnbmF0dXJlIHZlcmlmaWVkLlxuICAgKi9cbiAgdHJ1c3RlZCA9IGZhbHNlO1xuICBjb21wbGFpbmluZyA9IGZhbHNlO1xuICBkZWJ1ZztcbiAgc3RhdGljIGRlZmF1bHRWYWxpZGF0aW9uUmF0aW9VcGRhdGVGbiA9IChyZWxheSwgdmFsaWRhdGVkQ291bnQsIF9ub25WYWxpZGF0ZWRDb3VudCkgPT4ge1xuICAgIGlmIChyZWxheS5sb3dlc3RWYWxpZGF0aW9uUmF0aW8gPT09IHZvaWQgMCB8fCByZWxheS50YXJnZXRWYWxpZGF0aW9uUmF0aW8gPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgbGV0IG5ld1JhdGlvID0gcmVsYXkudmFsaWRhdGlvblJhdGlvO1xuICAgIGlmIChyZWxheS52YWxpZGF0aW9uUmF0aW8gPiByZWxheS50YXJnZXRWYWxpZGF0aW9uUmF0aW8pIHtcbiAgICAgIGNvbnN0IGZhY3RvciA9IHZhbGlkYXRlZENvdW50IC8gMTAwO1xuICAgICAgbmV3UmF0aW8gPSBNYXRoLm1heChyZWxheS5sb3dlc3RWYWxpZGF0aW9uUmF0aW8sIHJlbGF5LnZhbGlkYXRpb25SYXRpbyAtIGZhY3Rvcik7XG4gICAgfVxuICAgIGlmIChuZXdSYXRpbyA8IHJlbGF5LnZhbGlkYXRpb25SYXRpbykge1xuICAgICAgcmV0dXJuIG5ld1JhdGlvO1xuICAgIH1cbiAgICByZXR1cm4gcmVsYXkudmFsaWRhdGlvblJhdGlvO1xuICB9O1xuICBjb25zdHJ1Y3Rvcih1cmwsIGF1dGhQb2xpY3ksIG5kaykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy51cmwgPSBub3JtYWxpemVSZWxheVVybCh1cmwpO1xuICAgIHRoaXMuc2NvcmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlYnVnID0gZGVidWcyKGBuZGs6cmVsYXk6JHt1cmx9YCk7XG4gICAgdGhpcy5jb25uZWN0aXZpdHkgPSBuZXcgTkRLUmVsYXlDb25uZWN0aXZpdHkodGhpcywgbmRrKTtcbiAgICB0aGlzLmNvbm5lY3Rpdml0eS5uZXREZWJ1ZyA9IG5kaz8ubmV0RGVidWc7XG4gICAgdGhpcy5yZXEgPSB0aGlzLmNvbm5lY3Rpdml0eS5yZXEuYmluZCh0aGlzLmNvbm5lY3Rpdml0eSk7XG4gICAgdGhpcy5jbG9zZSA9IHRoaXMuY29ubmVjdGl2aXR5LmNsb3NlLmJpbmQodGhpcy5jb25uZWN0aXZpdHkpO1xuICAgIHRoaXMuc3VicyA9IG5ldyBOREtSZWxheVN1YnNjcmlwdGlvbk1hbmFnZXIodGhpcywgbmRrLnN1Yk1hbmFnZXIpO1xuICAgIHRoaXMucHVibGlzaGVyID0gbmV3IE5ES1JlbGF5UHVibGlzaGVyKHRoaXMpO1xuICAgIHRoaXMuYXV0aFBvbGljeSA9IGF1dGhQb2xpY3k7XG4gICAgdGhpcy50YXJnZXRWYWxpZGF0aW9uUmF0aW8gPSBuZGs/LmluaXRpYWxWYWxpZGF0aW9uUmF0aW87XG4gICAgdGhpcy5sb3dlc3RWYWxpZGF0aW9uUmF0aW8gPSBuZGs/Lmxvd2VzdFZhbGlkYXRpb25SYXRpbztcbiAgICB0aGlzLnZhbGlkYXRpb25SYXRpb0ZuID0gKG5kaz8udmFsaWRhdGlvblJhdGlvRm4gPz8gX05ES1JlbGF5LmRlZmF1bHRWYWxpZGF0aW9uUmF0aW9VcGRhdGVGbikuYmluZCh0aGlzKTtcbiAgICB0aGlzLnVwZGF0ZVZhbGlkYXRpb25SYXRpbygpO1xuICAgIGlmICghbmRrKSB7XG4gICAgICBjb25zb2xlLnRyYWNlKFwicmVsYXkgY3JlYXRlZCB3aXRob3V0IG5ka1wiKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlVmFsaWRhdGlvblJhdGlvKCkge1xuICAgIGlmICh0aGlzLnZhbGlkYXRpb25SYXRpb0ZuICYmIHRoaXMudmFsaWRhdGVkRXZlbnRDb3VudCA+IDApIHtcbiAgICAgIGNvbnN0IG5ld1JhdGlvID0gdGhpcy52YWxpZGF0aW9uUmF0aW9Gbih0aGlzLCB0aGlzLnZhbGlkYXRlZEV2ZW50Q291bnQsIHRoaXMubm9uVmFsaWRhdGVkRXZlbnRDb3VudCk7XG4gICAgICB0aGlzLnRhcmdldFZhbGlkYXRpb25SYXRpbyA9IG5ld1JhdGlvO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlVmFsaWRhdGlvblJhdGlvKCk7XG4gICAgfSwgM2U0KTtcbiAgfVxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eS5zdGF0dXM7XG4gIH1cbiAgZ2V0IGNvbm5lY3Rpb25TdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aXZpdHkuY29ubmVjdGlvblN0YXRzO1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byB0aGUgcmVsYXkuXG4gICAqL1xuICBhc3luYyBjb25uZWN0KHRpbWVvdXRNcywgcmVjb25uZWN0ID0gdHJ1ZSkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eS5jb25uZWN0KHRpbWVvdXRNcywgcmVjb25uZWN0KTtcbiAgfVxuICAvKipcbiAgICogRGlzY29ubmVjdHMgZnJvbSB0aGUgcmVsYXkuXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMSAvKiBESVNDT05ORUNURUQgKi8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0aXZpdHkuZGlzY29ubmVjdCgpO1xuICB9XG4gIC8qKlxuICAgKiBRdWV1ZXMgb3IgZXhlY3V0ZXMgdGhlIHN1YnNjcmlwdGlvbiBvZiBhIHNwZWNpZmljIHNldCBvZiBmaWx0ZXJzXG4gICAqIHdpdGhpbiB0aGlzIHJlbGF5LlxuICAgKlxuICAgKiBAcGFyYW0gc3Vic2NyaXB0aW9uIE5ES1N1YnNjcmlwdGlvbiB0aGlzIGZpbHRlcnMgYmVsb25nIHRvLlxuICAgKiBAcGFyYW0gZmlsdGVycyBGaWx0ZXJzIHRvIGV4ZWN1dGVcbiAgICovXG4gIHN1YnNjcmliZShzdWJzY3JpcHRpb24sIGZpbHRlcnMpIHtcbiAgICB0aGlzLnN1YnMuYWRkU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbiwgZmlsdGVycyk7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2hlcyBhbiBldmVudCB0byB0aGUgcmVsYXkgd2l0aCBhbiBvcHRpb25hbCB0aW1lb3V0LlxuICAgKlxuICAgKiBJZiB0aGUgcmVsYXkgaXMgbm90IGNvbm5lY3RlZCwgdGhlIGV2ZW50IHdpbGwgYmUgcHVibGlzaGVkIHdoZW4gdGhlIHJlbGF5IGNvbm5lY3RzLFxuICAgKiB1bmxlc3MgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZCBiZWZvcmUgdGhlIHJlbGF5IGNvbm5lY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHB1Ymxpc2hcbiAgICogQHBhcmFtIHRpbWVvdXRNcyBUaGUgdGltZW91dCBmb3IgdGhlIHB1Ymxpc2ggb3BlcmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBldmVudCBoYXMgYmVlbiBwdWJsaXNoZWQgb3IgcmVqZWN0cyBpZiB0aGUgb3BlcmF0aW9uIHRpbWVzIG91dFxuICAgKi9cbiAgYXN5bmMgcHVibGlzaChldmVudCwgdGltZW91dE1zID0gMjUwMCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5wdWJsaXNoKGV2ZW50LCB0aW1lb3V0TXMpO1xuICB9XG4gIHJlZmVyZW5jZVRhZ3MoKSB7XG4gICAgcmV0dXJuIFtbXCJyXCIsIHRoaXMudXJsXV07XG4gIH1cbiAgYWRkVmFsaWRhdGVkRXZlbnQoKSB7XG4gICAgdGhpcy52YWxpZGF0ZWRFdmVudENvdW50Kys7XG4gIH1cbiAgYWRkTm9uVmFsaWRhdGVkRXZlbnQoKSB7XG4gICAgdGhpcy5ub25WYWxpZGF0ZWRFdmVudENvdW50Kys7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHZhbGlkYXRpb24gcmF0aW8gdGhpcyByZWxheSBoYXMgYWNoaWV2ZWQuXG4gICAqL1xuICBnZXQgdmFsaWRhdGlvblJhdGlvKCkge1xuICAgIGlmICh0aGlzLm5vblZhbGlkYXRlZEV2ZW50Q291bnQgPT09IDApIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZWRFdmVudENvdW50IC8gKHRoaXMudmFsaWRhdGVkRXZlbnRDb3VudCArIHRoaXMubm9uVmFsaWRhdGVkRXZlbnRDb3VudCk7XG4gIH1cbiAgc2hvdWxkVmFsaWRhdGVFdmVudCgpIHtcbiAgICBpZiAodGhpcy50cnVzdGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnRhcmdldFZhbGlkYXRpb25SYXRpbyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGFyZ2V0VmFsaWRhdGlvblJhdGlvID49IDEpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpIDwgdGhpcy50YXJnZXRWYWxpZGF0aW9uUmF0aW87XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aXZpdHkuY29ubmVjdGVkO1xuICB9XG4gIHJlcTtcbiAgY2xvc2U7XG59O1xuXG4vLyBzcmMvcmVsYXkvc2V0cy9pbmRleC50c1xudmFyIE5ES1B1Ymxpc2hFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBlcnJvcnM7XG4gIHB1Ymxpc2hlZFRvUmVsYXlzO1xuICAvKipcbiAgICogSW50ZW5kZWQgcmVsYXkgc2V0IHdoZXJlIHRoZSBwdWJsaXNoaW5nIHdhcyBpbnRlbmRlZCB0byBoYXBwZW4uXG4gICAqL1xuICBpbnRlbmRlZFJlbGF5U2V0O1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvcnMsIHB1Ymxpc2hlZFRvUmVsYXlzLCBpbnRlbmRlZFJlbGF5U2V0KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5wdWJsaXNoZWRUb1JlbGF5cyA9IHB1Ymxpc2hlZFRvUmVsYXlzO1xuICAgIHRoaXMuaW50ZW5kZWRSZWxheVNldCA9IGludGVuZGVkUmVsYXlTZXQ7XG4gIH1cbiAgZ2V0IHJlbGF5RXJyb3JzKCkge1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgW3JlbGF5LCBlcnJdIG9mIHRoaXMuZXJyb3JzKSB7XG4gICAgICBlcnJvcnMucHVzaChgJHtyZWxheS51cmx9OiAke2Vycn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycy5qb2luKFwiXFxuXCIpO1xuICB9XG59O1xudmFyIE5ES1JlbGF5U2V0ID0gY2xhc3MgX05ES1JlbGF5U2V0IHtcbiAgcmVsYXlzO1xuICBkZWJ1ZztcbiAgbmRrO1xuICBwb29sO1xuICBjb25zdHJ1Y3RvcihyZWxheXMsIG5kaywgcG9vbCkge1xuICAgIHRoaXMucmVsYXlzID0gcmVsYXlzO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMucG9vbCA9IHBvb2wgPz8gbmRrLnBvb2w7XG4gICAgdGhpcy5kZWJ1ZyA9IG5kay5kZWJ1Zy5leHRlbmQoXCJyZWxheXNldFwiKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHJlbGF5IHRvIHRoaXMgc2V0LlxuICAgKi9cbiAgYWRkUmVsYXkocmVsYXkpIHtcbiAgICB0aGlzLnJlbGF5cy5hZGQocmVsYXkpO1xuICB9XG4gIGdldCByZWxheVVybHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWxheXMpLm1hcCgocikgPT4gci51cmwpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVsYXkgc2V0IGZyb20gYSBsaXN0IG9mIHJlbGF5IFVSTHMuXG4gICAqXG4gICAqIElmIG5vIGNvbm5lY3Rpb24gdG8gdGhlIHJlbGF5IGlzIGZvdW5kIGluIHRoZSBwb29sIGl0IHdpbGwgdGVtcG9yYXJpbHlcbiAgICogY29ubmVjdCB0byBpdC5cbiAgICpcbiAgICogQHBhcmFtIHJlbGF5VXJscyAtIGxpc3Qgb2YgcmVsYXkgVVJMcyB0byBpbmNsdWRlIGluIHRoaXMgc2V0XG4gICAqIEBwYXJhbSBuZGtcbiAgICogQHBhcmFtIGNvbm5lY3QgLSB3aGV0aGVyIHRvIGNvbm5lY3QgdG8gdGhlIHJlbGF5IGltbWVkaWF0ZWx5IGlmIGl0IHdhcyBhbHJlYWR5IGluIHRoZSBwb29sIGJ1dCBub3QgY29ubmVjdGVkXG4gICAqIEByZXR1cm5zIE5ES1JlbGF5U2V0XG4gICAqL1xuICBzdGF0aWMgZnJvbVJlbGF5VXJscyhyZWxheVVybHMsIG5kaywgY29ubmVjdCA9IHRydWUsIHBvb2wpIHtcbiAgICBwb29sID0gcG9vbCA/PyBuZGsucG9vbDtcbiAgICBpZiAoIXBvb2wpIHRocm93IG5ldyBFcnJvcihcIk5vIHBvb2wgcHJvdmlkZWRcIik7XG4gICAgY29uc3QgcmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHVybCBvZiByZWxheVVybHMpIHtcbiAgICAgIGNvbnN0IHJlbGF5ID0gcG9vbC5yZWxheXMuZ2V0KG5vcm1hbGl6ZVJlbGF5VXJsKHVybCkpO1xuICAgICAgaWYgKHJlbGF5KSB7XG4gICAgICAgIGlmIChyZWxheS5zdGF0dXMgPCA1IC8qIENPTk5FQ1RFRCAqLyAmJiBjb25uZWN0KSB7XG4gICAgICAgICAgcmVsYXkuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlbGF5cy5hZGQocmVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGVtcG9yYXJ5UmVsYXkgPSBuZXcgTkRLUmVsYXkobm9ybWFsaXplUmVsYXlVcmwodXJsKSwgbmRrPy5yZWxheUF1dGhEZWZhdWx0UG9saWN5LCBuZGspO1xuICAgICAgICBwb29sLnVzZVRlbXBvcmFyeVJlbGF5KHRlbXBvcmFyeVJlbGF5LCB2b2lkIDAsIGByZXF1ZXN0ZWQgZnJvbSBmcm9tUmVsYXlVcmxzICR7cmVsYXlVcmxzfWApO1xuICAgICAgICByZWxheXMuYWRkKHRlbXBvcmFyeVJlbGF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfTkRLUmVsYXlTZXQobmV3IFNldChyZWxheXMpLCBuZGssIHBvb2wpO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoIGFuIGV2ZW50IHRvIGFsbCByZWxheXMgaW4gdGhpcyByZWxheSBzZXQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgYSByb2J1c3QgbWVjaGFuaXNtIGZvciBwdWJsaXNoaW5nIGV2ZW50cyB0byBtdWx0aXBsZSByZWxheXMgd2l0aFxuICAgKiBidWlsdC1pbiBoYW5kbGluZyBmb3IgcmFjZSBjb25kaXRpb25zLCB0aW1lb3V0cywgYW5kIHBhcnRpYWwgZmFpbHVyZXMuIFRoZSBpbXBsZW1lbnRhdGlvblxuICAgKiB1c2VzIGEgZHVhbC10cmFja2luZyBtZWNoYW5pc20gdG8gZW5zdXJlIGFjY3VyYXRlIHJlcG9ydGluZyBvZiB3aGljaCByZWxheXMgc3VjY2Vzc2Z1bGx5XG4gICAqIHJlY2VpdmVkIGFuIGV2ZW50LlxuICAgKlxuICAgKiBLZXkgYXNwZWN0cyBvZiB0aGlzIGltcGxlbWVudGF0aW9uOlxuICAgKlxuICAgKiAxLiBEVUFMLVRSQUNLSU5HIE1FQ0hBTklTTTpcbiAgICogICAgLSBQcm9taXNlLWJhc2VkIHRyYWNraW5nOiBSZWNvcmRzIHN1Y2Nlc3Nlcy9mYWlsdXJlcyBmcm9tIHRoZSBwcm9taXNlcyByZXR1cm5lZCBieSByZWxheS5wdWJsaXNoKClcbiAgICogICAgLSBFdmVudC1iYXNlZCB0cmFja2luZzogTGlzdGVucyBmb3IgJ3JlbGF5OnB1Ymxpc2hlZCcgZXZlbnRzIHRoYXQgaW5kaWNhdGUgc3VjY2Vzc2Z1bCBwdWJsaXNoaW5nXG4gICAqICAgIFRoaXMgYXBwcm9hY2ggZW5zdXJlcyB3ZSBkb24ndCBtaXNzIHN1Y2Nlc3NmdWwgcHVibGlzaGVzIGV2ZW4gaWYgdGhlcmUgYXJlIHN1YnNlcXVlbnQgZXJyb3JzIGluXG4gICAqICAgIHRoZSBwcm9taXNlIGNoYWluLlxuICAgKlxuICAgKiAyLiBSQUNFIENPTkRJVElPTiBIQU5ETElORzpcbiAgICogICAgLSBJZiBhIHJlbGF5IGVtaXRzIGEgc3VjY2VzcyBldmVudCBidXQgbGF0ZXIgZmFpbHMgaW4gdGhlIHByb21pc2UgY2hhaW4sIHdlIHN0aWxsIGNvdW50IGl0IGFzIGEgc3VjY2Vzc1xuICAgKiAgICAtIElmIGEgcmVsYXkgdGltZXMgb3V0IGFmdGVyIHN1Y2Nlc3NmdWxseSBwdWJsaXNoaW5nLCB3ZSBzdGlsbCBjb3VudCBpdCBhcyBhIHN1Y2Nlc3NcbiAgICogICAgLSBBbGwgcmVsYXkgb3BlcmF0aW9ucyBoYXBwZW4gaW4gcGFyYWxsZWwsIHdpdGggcHJvcGVyIHRyYWNraW5nIHJlZ2FyZGxlc3Mgb2YgY29tcGxldGlvbiBvcmRlclxuICAgKlxuICAgKiAzLiBUSU1FT1VUIE1BTkFHRU1FTlQ6XG4gICAqICAgIC0gSW5kaXZpZHVhbCB0aW1lb3V0cyBmb3IgZWFjaCByZWxheSBvcGVyYXRpb25cbiAgICogICAgLSBQcm9wZXIgY2xlYW51cCBvZiB0aW1lb3V0cyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgKiAgICAtIENsZWFyIHRpbWVvdXQgZXJyb3IgcmVwb3J0aW5nXG4gICAqXG4gICAqIDQuIEVSUk9SIEhBTkRMSU5HOlxuICAgKiAgICAtIERldGFpbGVkIHRyYWNraW5nIG9mIHNwZWNpZmljIGVycm9ycyBmb3IgZWFjaCBmYWlsZWQgcmVsYXlcbiAgICogICAgLSBTcGVjaWFsIGhhbmRsaW5nIGZvciBlcGhlbWVyYWwgZXZlbnRzICh3aGljaCBkb24ndCBleHBlY3QgYWNrbm93bGVkZ2VtZW50KVxuICAgKiAgICAtIFJlcXVpcmVkUmVsYXlDb3VudCBwYXJhbWV0ZXIgdG8gY29udHJvbCB0aGUgbWluaW11bSBzdWNjZXNzIHRocmVzaG9sZFxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgRXZlbnQgdG8gcHVibGlzaFxuICAgKiBAcGFyYW0gdGltZW91dE1zIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciBlYWNoIHJlbGF5IHB1Ymxpc2ggb3BlcmF0aW9uXG4gICAqIEBwYXJhbSByZXF1aXJlZFJlbGF5Q291bnQgVGhlIG1pbmltdW0gbnVtYmVyIG9mIHJlbGF5cyB3ZSBleHBlY3QgdGhlIGV2ZW50IHRvIGJlIHB1Ymxpc2hlZCB0b1xuICAgKiBAcmV0dXJucyBBIHNldCBvZiByZWxheXMgdGhlIGV2ZW50IHdhcyBwdWJsaXNoZWQgdG9cbiAgICogQHRocm93cyB7TkRLUHVibGlzaEVycm9yfSBJZiB0aGUgZXZlbnQgY291bGQgbm90IGJlIHB1Ymxpc2hlZCB0byBhdCBsZWFzdCBgcmVxdWlyZWRSZWxheUNvdW50YCByZWxheXNcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZWxheVNldCA9IG5ldyBOREtSZWxheVNldChuZXcgU2V0KFtyZWxheTEsIHJlbGF5Ml0pLCBuZGspO1xuICAgKiBjb25zdCBwdWJsaXNoZWRUb1JlbGF5cyA9IGF3YWl0IHJlbGF5U2V0LnB1Ymxpc2goZXZlbnQpO1xuICAgKiAvLyBwdWJsaXNoZWRUb1JlbGF5cyBjYW4gY29udGFpbiByZWxheTEsIHJlbGF5MiwgYm90aCwgb3Igbm9uZVxuICAgKiAvLyBkZXBlbmRpbmcgb24gd2hpY2ggcmVsYXlzIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZCB0b1xuICAgKiBpZiAocHVibGlzaGVkVG9SZWxheXMuc2l6ZSA+IDApIHtcbiAgICogICBjb25zb2xlLmxvZyhcIkV2ZW50IHB1Ymxpc2hlZCB0byBhdCBsZWFzdCBvbmUgcmVsYXlcIik7XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBwdWJsaXNoKGV2ZW50LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCA9IDEpIHtcbiAgICBjb25zdCBwdWJsaXNoZWRUb1JlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgZXJyb3JzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBpc0VwaGVtZXJhbDIgPSBldmVudC5pc0VwaGVtZXJhbCgpO1xuICAgIGV2ZW50LnB1Ymxpc2hTdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICBjb25zdCByZWxheVB1Ymxpc2hlZEhhbmRsZXIgPSAocmVsYXkpID0+IHtcbiAgICAgIHB1Ymxpc2hlZFRvUmVsYXlzLmFkZChyZWxheSk7XG4gICAgfTtcbiAgICBldmVudC5vbihcInJlbGF5OnB1Ymxpc2hlZFwiLCByZWxheVB1Ymxpc2hlZEhhbmRsZXIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IEFycmF5LmZyb20odGhpcy5yZWxheXMpLm1hcCgocmVsYXkpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGltZW91dElkID0gdGltZW91dE1zID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXB1Ymxpc2hlZFRvUmVsYXlzLmhhcyhyZWxheSkpIHtcbiAgICAgICAgICAgICAgZXJyb3JzLnNldChyZWxheSwgbmV3IEVycm9yKGBQdWJsaXNoIHRpbWVvdXQgYWZ0ZXIgJHt0aW1lb3V0TXN9bXNgKSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRpbWVvdXRNcykgOiBudWxsO1xuICAgICAgICAgIHJlbGF5LnB1Ymxpc2goZXZlbnQsIHRpbWVvdXRNcykudGhlbigoc3VjY2VzcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXRJZCkgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICBwdWJsaXNoZWRUb1JlbGF5cy5hZGQocmVsYXkpO1xuICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXRJZCkgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICBpZiAoIWlzRXBoZW1lcmFsMikge1xuICAgICAgICAgICAgICBlcnJvcnMuc2V0KHJlbGF5LCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICBpZiAocHVibGlzaGVkVG9SZWxheXMuc2l6ZSA8IHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgICAgICBpZiAoIWlzRXBoZW1lcmFsMikge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IE5ES1B1Ymxpc2hFcnJvcihcbiAgICAgICAgICAgIFwiTm90IGVub3VnaCByZWxheXMgcmVjZWl2ZWQgdGhlIGV2ZW50IChcIiArIHB1Ymxpc2hlZFRvUmVsYXlzLnNpemUgKyBcIiBwdWJsaXNoZWQsIFwiICsgcmVxdWlyZWRSZWxheUNvdW50ICsgXCIgcmVxdWlyZWQpXCIsXG4gICAgICAgICAgICBlcnJvcnMsXG4gICAgICAgICAgICBwdWJsaXNoZWRUb1JlbGF5cyxcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICApO1xuICAgICAgICAgIGV2ZW50LnB1Ymxpc2hTdGF0dXMgPSBcImVycm9yXCI7XG4gICAgICAgICAgZXZlbnQucHVibGlzaEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgdGhpcy5uZGs/LmVtaXQoXCJldmVudDpwdWJsaXNoLWZhaWxlZFwiLCBldmVudCwgZXJyb3IsIHRoaXMucmVsYXlVcmxzKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZlbnQucHVibGlzaFN0YXR1cyA9IFwic3VjY2Vzc1wiO1xuICAgICAgICBldmVudC5lbWl0KFwicHVibGlzaGVkXCIsIHsgcmVsYXlTZXQ6IHRoaXMsIHB1Ymxpc2hlZFRvUmVsYXlzIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHB1Ymxpc2hlZFRvUmVsYXlzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBldmVudC5vZmYoXCJyZWxheTpwdWJsaXNoZWRcIiwgcmVsYXlQdWJsaXNoZWRIYW5kbGVyKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXlzLnNpemU7XG4gIH1cbn07XG5cbi8vIHNyYy9yZWxheS9zZXRzL2NhbGN1bGF0ZS50c1xudmFyIGQgPSBjcmVhdGVEZWJ1ZyhcIm5kazpvdXRib3g6Y2FsY3VsYXRlXCIpO1xuYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXlTZXRGcm9tRXZlbnQobmRrLCBldmVudCwgcmVxdWlyZWRSZWxheUNvdW50KSB7XG4gIGNvbnN0IHJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGF1dGhvcldyaXRlUmVsYXlzID0gYXdhaXQgZ2V0V3JpdGVSZWxheXNGb3IobmRrLCBldmVudC5wdWJrZXkpO1xuICBpZiAoYXV0aG9yV3JpdGVSZWxheXMpIHtcbiAgICBhdXRob3JXcml0ZVJlbGF5cy5mb3JFYWNoKChyZWxheVVybCkgPT4ge1xuICAgICAgY29uc3QgcmVsYXkgPSBuZGsucG9vbD8uZ2V0UmVsYXkocmVsYXlVcmwpO1xuICAgICAgaWYgKHJlbGF5KSByZWxheXMuYWRkKHJlbGF5KTtcbiAgICB9KTtcbiAgfVxuICBsZXQgcmVsYXlIaW50cyA9IGV2ZW50LnRhZ3MuZmlsdGVyKCh0YWcpID0+IFtcImFcIiwgXCJlXCJdLmluY2x1ZGVzKHRhZ1swXSkpLm1hcCgodGFnKSA9PiB0YWdbMl0pLmZpbHRlcigodXJsKSA9PiB1cmw/LnN0YXJ0c1dpdGgoXCJ3c3M6Ly9cIikpLmZpbHRlcigodXJsKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBVUkwodXJsKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSkubWFwKCh1cmwpID0+IG5vcm1hbGl6ZVJlbGF5VXJsKHVybCkpO1xuICByZWxheUhpbnRzID0gQXJyYXkuZnJvbShuZXcgU2V0KHJlbGF5SGludHMpKS5zbGljZSgwLCA1KTtcbiAgcmVsYXlIaW50cy5mb3JFYWNoKChyZWxheVVybCkgPT4ge1xuICAgIGNvbnN0IHJlbGF5ID0gbmRrLnBvb2w/LmdldFJlbGF5KHJlbGF5VXJsLCB0cnVlLCB0cnVlKTtcbiAgICBpZiAocmVsYXkpIHtcbiAgICAgIGQoXCJBZGRpbmcgcmVsYXkgaGludCAlc1wiLCByZWxheVVybCk7XG4gICAgICByZWxheXMuYWRkKHJlbGF5KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBwVGFncyA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcInBcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gIGlmIChwVGFncy5sZW5ndGggPCA1KSB7XG4gICAgY29uc3QgcFRhZ2dlZFJlbGF5cyA9IEFycmF5LmZyb20oXG4gICAgICBjaG9vc2VSZWxheUNvbWJpbmF0aW9uRm9yUHVia2V5cyhuZGssIHBUYWdzLCBcInJlYWRcIiwge1xuICAgICAgICBwcmVmZXJyZWRSZWxheXM6IG5ldyBTZXQoYXV0aG9yV3JpdGVSZWxheXMpXG4gICAgICB9KS5rZXlzKClcbiAgICApO1xuICAgIHBUYWdnZWRSZWxheXMuZm9yRWFjaCgocmVsYXlVcmwpID0+IHtcbiAgICAgIGNvbnN0IHJlbGF5ID0gbmRrLnBvb2w/LmdldFJlbGF5KHJlbGF5VXJsLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICBpZiAocmVsYXkpIHtcbiAgICAgICAgZChcIkFkZGluZyBwLXRhZ2dlZCByZWxheSAlc1wiLCByZWxheVVybCk7XG4gICAgICAgIHJlbGF5cy5hZGQocmVsYXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGQoXCJUb28gbWFueSBwLXRhZ3MgdG8gY29uc2lkZXIgJWRcIiwgcFRhZ3MubGVuZ3RoKTtcbiAgfVxuICBuZGsucG9vbD8ucGVybWFuZW50QW5kQ29ubmVjdGVkUmVsYXlzKCkuZm9yRWFjaCgocmVsYXkpID0+IHJlbGF5cy5hZGQocmVsYXkpKTtcbiAgaWYgKHJlcXVpcmVkUmVsYXlDb3VudCAmJiByZWxheXMuc2l6ZSA8IHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgIGNvbnN0IGV4cGxpY2l0UmVsYXlzID0gbmRrLmV4cGxpY2l0UmVsYXlVcmxzPy5maWx0ZXIoKHVybCkgPT4gIUFycmF5LmZyb20ocmVsYXlzKS5zb21lKChyKSA9PiByLnVybCA9PT0gdXJsKSkuc2xpY2UoMCwgcmVxdWlyZWRSZWxheUNvdW50IC0gcmVsYXlzLnNpemUpO1xuICAgIGV4cGxpY2l0UmVsYXlzPy5mb3JFYWNoKCh1cmwpID0+IHtcbiAgICAgIGNvbnN0IHJlbGF5ID0gbmRrLnBvb2w/LmdldFJlbGF5KHVybCwgZmFsc2UsIHRydWUpO1xuICAgICAgaWYgKHJlbGF5KSB7XG4gICAgICAgIGQoXCJBZGRpbmcgZXhwbGljaXQgcmVsYXkgJXNcIiwgdXJsKTtcbiAgICAgICAgcmVsYXlzLmFkZChyZWxheSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBOREtSZWxheVNldChyZWxheXMsIG5kayk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVSZWxheVNldHNGcm9tRmlsdGVyKG5kaywgZmlsdGVycywgcG9vbCkge1xuICBjb25zdCByZXN1bHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBhdXRob3JzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZmlsdGVycy5mb3JFYWNoKChmaWx0ZXIpID0+IHtcbiAgICBpZiAoZmlsdGVyLmF1dGhvcnMpIHtcbiAgICAgIGZpbHRlci5hdXRob3JzLmZvckVhY2goKGF1dGhvcikgPT4gYXV0aG9ycy5hZGQoYXV0aG9yKSk7XG4gICAgfVxuICB9KTtcbiAgaWYgKGF1dGhvcnMuc2l6ZSA+IDApIHtcbiAgICBjb25zdCBhdXRob3JUb1JlbGF5c01hcCA9IGdldFJlbGF5c0ZvckZpbHRlcldpdGhBdXRob3JzKG5kaywgQXJyYXkuZnJvbShhdXRob3JzKSk7XG4gICAgZm9yIChjb25zdCByZWxheVVybCBvZiBhdXRob3JUb1JlbGF5c01hcC5rZXlzKCkpIHtcbiAgICAgIHJlc3VsdC5zZXQocmVsYXlVcmwsIFtdKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgZmlsdGVycykge1xuICAgICAgaWYgKGZpbHRlci5hdXRob3JzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW3JlbGF5VXJsLCBhdXRob3JzMl0gb2YgYXV0aG9yVG9SZWxheXNNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgY29uc3QgYXV0aG9yRmlsdGVyQW5kUmVsYXlQdWJrZXlJbnRlcnNlY3Rpb24gPSBmaWx0ZXIuYXV0aG9ycy5maWx0ZXIoXG4gICAgICAgICAgICAoYXV0aG9yKSA9PiBhdXRob3JzMi5pbmNsdWRlcyhhdXRob3IpXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bHQuc2V0KHJlbGF5VXJsLCBbXG4gICAgICAgICAgICAuLi5yZXN1bHQuZ2V0KHJlbGF5VXJsKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4uZmlsdGVyLFxuICAgICAgICAgICAgICAvLyBPdmVyd3JpdGUgYXV0aG9ycyBzZW50IHRvIHRoaXMgcmVsYXkgd2l0aCB0aGUgYXV0aG9ycyB0aGF0IHdlcmVcbiAgICAgICAgICAgICAgLy8gcHJlc2VudCBpbiB0aGUgZmlsdGVyIGFuZCBhcmUgYWxzbyBwcmVzZW50IGluIHRoZSByZWxheVxuICAgICAgICAgICAgICBhdXRob3JzOiBhdXRob3JGaWx0ZXJBbmRSZWxheVB1YmtleUludGVyc2VjdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIGF1dGhvclRvUmVsYXlzTWFwLmtleXMoKSkge1xuICAgICAgICAgIHJlc3VsdC5zZXQocmVsYXlVcmwsIFsuLi5yZXN1bHQuZ2V0KHJlbGF5VXJsKSwgZmlsdGVyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG5kay5leHBsaWNpdFJlbGF5VXJscykge1xuICAgICAgbmRrLmV4cGxpY2l0UmVsYXlVcmxzLmZvckVhY2goKHJlbGF5VXJsKSA9PiB7XG4gICAgICAgIHJlc3VsdC5zZXQocmVsYXlVcmwsIGZpbHRlcnMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChyZXN1bHQuc2l6ZSA9PT0gMCkge1xuICAgIHBvb2wucGVybWFuZW50QW5kQ29ubmVjdGVkUmVsYXlzKCkuc2xpY2UoMCwgNSkuZm9yRWFjaCgocmVsYXkpID0+IHtcbiAgICAgIHJlc3VsdC5zZXQocmVsYXkudXJsLCBmaWx0ZXJzKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXlTZXRzRnJvbUZpbHRlcnMobmRrLCBmaWx0ZXJzLCBwb29sKSB7XG4gIGNvbnN0IGEgPSBjYWxjdWxhdGVSZWxheVNldHNGcm9tRmlsdGVyKG5kaywgZmlsdGVycywgcG9vbCk7XG4gIHJldHVybiBhO1xufVxuXG4vLyBzcmMvZXZlbnRzL2NvbnRlbnQtdGFnZ2VyLnRzXG5pbXBvcnQgeyBuaXAxOSB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuZnVuY3Rpb24gbWVyZ2VUYWdzKHRhZ3MxLCB0YWdzMikge1xuICBjb25zdCB0YWdNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBnZW5lcmF0ZUtleSA9ICh0YWcpID0+IHRhZy5qb2luKFwiLFwiKTtcbiAgY29uc3QgaXNDb250YWluZWQgPSAoc21hbGxlciwgbGFyZ2VyKSA9PiB7XG4gICAgcmV0dXJuIHNtYWxsZXIuZXZlcnkoKHZhbHVlLCBpbmRleCkgPT4gdmFsdWUgPT09IGxhcmdlcltpbmRleF0pO1xuICB9O1xuICBjb25zdCBwcm9jZXNzVGFnID0gKHRhZykgPT4ge1xuICAgIGZvciAoY29uc3QgW2tleSwgZXhpc3RpbmdUYWddIG9mIHRhZ01hcCkge1xuICAgICAgaWYgKGlzQ29udGFpbmVkKGV4aXN0aW5nVGFnLCB0YWcpIHx8IGlzQ29udGFpbmVkKHRhZywgZXhpc3RpbmdUYWcpKSB7XG4gICAgICAgIGlmICh0YWcubGVuZ3RoID49IGV4aXN0aW5nVGFnLmxlbmd0aCkge1xuICAgICAgICAgIHRhZ01hcC5zZXQoa2V5LCB0YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGFnTWFwLnNldChnZW5lcmF0ZUtleSh0YWcpLCB0YWcpO1xuICB9O1xuICB0YWdzMS5jb25jYXQodGFnczIpLmZvckVhY2gocHJvY2Vzc1RhZyk7XG4gIHJldHVybiBBcnJheS5mcm9tKHRhZ01hcC52YWx1ZXMoKSk7XG59XG5mdW5jdGlvbiB1bmlxdWVUYWcoYSwgYikge1xuICBjb25zdCBhTGVuZ3RoID0gYS5sZW5ndGg7XG4gIGNvbnN0IGJMZW5ndGggPSBiLmxlbmd0aDtcbiAgY29uc3Qgc2FtZUxlbmd0aCA9IGFMZW5ndGggPT09IGJMZW5ndGg7XG4gIGlmIChzYW1lTGVuZ3RoKSB7XG4gICAgaWYgKGEuZXZlcnkoKHYsIGkpID0+IHYgPT09IGJbaV0pKSB7XG4gICAgICByZXR1cm4gW2FdO1xuICAgIH1cbiAgICByZXR1cm4gW2EsIGJdO1xuICB9XG4gIGlmIChhTGVuZ3RoID4gYkxlbmd0aCAmJiBhLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBiW2ldKSkge1xuICAgIHJldHVybiBbYV07XG4gIH1cbiAgaWYgKGJMZW5ndGggPiBhTGVuZ3RoICYmIGIuZXZlcnkoKHYsIGkpID0+IHYgPT09IGFbaV0pKSB7XG4gICAgcmV0dXJuIFtiXTtcbiAgfVxuICByZXR1cm4gW2EsIGJdO1xufVxudmFyIGhhc2h0YWdSZWdleCA9IC8oPzw9XFxzfF4pKCNbXlxccyFAIyQlXiYqKCk9Ky4vLFt7XFxdfTs6J1wiPz48XSspL2c7XG5mdW5jdGlvbiBnZW5lcmF0ZUhhc2h0YWdzKGNvbnRlbnQpIHtcbiAgY29uc3QgaGFzaHRhZ3MgPSBjb250ZW50Lm1hdGNoKGhhc2h0YWdSZWdleCk7XG4gIGNvbnN0IHRhZ0lkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHRhZyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGlmIChoYXNodGFncykge1xuICAgIGZvciAoY29uc3QgaGFzaHRhZyBvZiBoYXNodGFncykge1xuICAgICAgaWYgKHRhZ0lkcy5oYXMoaGFzaHRhZy5zbGljZSgxKSkpIGNvbnRpbnVlO1xuICAgICAgdGFnLmFkZChoYXNodGFnLnNsaWNlKDEpKTtcbiAgICAgIHRhZ0lkcy5hZGQoaGFzaHRhZy5zbGljZSgxKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHRhZyk7XG59XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRUYWdzKGNvbnRlbnQsIHRhZ3MgPSBbXSkge1xuICBjb25zdCB0YWdSZWdleCA9IC8oQHxub3N0cjopKG5wdWJ8bnByb2ZpbGV8bm90ZXxuZXZlbnR8bmFkZHIpW2EtekEtWjAtOV0rL2c7XG4gIGNvbnN0IHByb21pc2VzID0gW107XG4gIGNvbnN0IGFkZFRhZ0lmTmV3ID0gKHQpID0+IHtcbiAgICBpZiAoIXRhZ3MuZmluZCgodDIpID0+IFtcInFcIiwgdFswXV0uaW5jbHVkZXModDJbMF0pICYmIHQyWzFdID09PSB0WzFdKSkge1xuICAgICAgdGFncy5wdXNoKHQpO1xuICAgIH1cbiAgfTtcbiAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSh0YWdSZWdleCwgKHRhZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSB0YWcuc3BsaXQoLyhAfG5vc3RyOikvKVsyXTtcbiAgICAgIGNvbnN0IHsgdHlwZSwgZGF0YSB9ID0gbmlwMTkuZGVjb2RlKGVudGl0eSk7XG4gICAgICBsZXQgdDtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwibnB1YlwiOlxuICAgICAgICAgIHQgPSBbXCJwXCIsIGRhdGFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnByb2ZpbGVcIjpcbiAgICAgICAgICB0ID0gW1wicFwiLCBkYXRhLnB1YmtleV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgIGFkZFRhZ0lmTmV3KFtcInFcIiwgZGF0YSwgYXdhaXQgbWF5YmVHZXRFdmVudFJlbGF5VXJsKGVudGl0eSldKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibmV2ZW50XCI6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgaWQsIGF1dGhvciB9ID0gZGF0YTtcbiAgICAgICAgICAgICAgbGV0IHsgcmVsYXlzIH0gPSBkYXRhO1xuICAgICAgICAgICAgICBpZiAoIXJlbGF5cyB8fCByZWxheXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVsYXlzID0gW2F3YWl0IG1heWJlR2V0RXZlbnRSZWxheVVybChlbnRpdHkpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhZGRUYWdJZk5ldyhbXCJxXCIsIGlkLCByZWxheXNbMF1dKTtcbiAgICAgICAgICAgICAgaWYgKGF1dGhvcikgYWRkVGFnSWZOZXcoW1wicFwiLCBhdXRob3JdKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibmFkZHJcIjpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgaWQgPSBbZGF0YS5raW5kLCBkYXRhLnB1YmtleSwgZGF0YS5pZGVudGlmaWVyXS5qb2luKFwiOlwiKTtcbiAgICAgICAgICAgICAgbGV0IHJlbGF5cyA9IGRhdGEucmVsYXlzID8/IFtdO1xuICAgICAgICAgICAgICBpZiAocmVsYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlbGF5cyA9IFthd2FpdCBtYXliZUdldEV2ZW50UmVsYXlVcmwoZW50aXR5KV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYWRkVGFnSWZOZXcoW1wicVwiLCBpZCwgcmVsYXlzWzBdXSk7XG4gICAgICAgICAgICAgIGFkZFRhZ0lmTmV3KFtcInBcIiwgZGF0YS5wdWJrZXldKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICB9XG4gICAgICBpZiAodCkgYWRkVGFnSWZOZXcodCk7XG4gICAgICByZXR1cm4gYG5vc3RyOiR7ZW50aXR5fWA7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgfSk7XG4gIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgY29uc3QgbmV3VGFncyA9IGdlbmVyYXRlSGFzaHRhZ3MoY29udGVudCkubWFwKChoYXNodGFnKSA9PiBbXCJ0XCIsIGhhc2h0YWddKTtcbiAgdGFncyA9IG1lcmdlVGFncyh0YWdzLCBuZXdUYWdzKTtcbiAgcmV0dXJuIHsgY29udGVudCwgdGFncyB9O1xufVxuYXN5bmMgZnVuY3Rpb24gbWF5YmVHZXRFdmVudFJlbGF5VXJsKF9uaXAxOUlkKSB7XG4gIHJldHVybiBcIlwiO1xufVxuXG4vLyBzcmMvZXZlbnRzL2VuY3J5cHRpb24udHNcbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHQocmVjaXBpZW50LCBzaWduZXIsIHNjaGVtZSA9IFwibmlwNDRcIikge1xuICBsZXQgZW5jcnlwdGVkO1xuICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmQhXCIpO1xuICBsZXQgY3VycmVudFNpZ25lciA9IHNpZ25lcjtcbiAgaWYgKCFjdXJyZW50U2lnbmVyKSB7XG4gICAgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCk7XG4gICAgY3VycmVudFNpZ25lciA9IHRoaXMubmRrLnNpZ25lcjtcbiAgfVxuICBpZiAoIWN1cnJlbnRTaWduZXIpIHRocm93IG5ldyBFcnJvcihcIm5vIE5ESyBzaWduZXJcIik7XG4gIGNvbnN0IGN1cnJlbnRSZWNpcGllbnQgPSByZWNpcGllbnQgfHwgKCgpID0+IHtcbiAgICBjb25zdCBwVGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKTtcbiAgICBpZiAocFRhZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZWNpcGllbnQgY291bGQgYmUgZGV0ZXJtaW5lZCBhbmQgbm8gZXhwbGljaXQgcmVjaXBpZW50IHdhcyBwcm92aWRlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXk6IHBUYWdzWzBdWzFdIH0pO1xuICB9KSgpO1xuICBpZiAoc2NoZW1lID09PSBcIm5pcDQ0XCIgJiYgYXdhaXQgaXNFbmNyeXB0aW9uRW5hYmxlZChjdXJyZW50U2lnbmVyLCBcIm5pcDQ0XCIpKSB7XG4gICAgZW5jcnlwdGVkID0gYXdhaXQgY3VycmVudFNpZ25lci5lbmNyeXB0KGN1cnJlbnRSZWNpcGllbnQsIHRoaXMuY29udGVudCwgXCJuaXA0NFwiKTtcbiAgfVxuICBpZiAoKCFlbmNyeXB0ZWQgfHwgc2NoZW1lID09PSBcIm5pcDA0XCIpICYmIGF3YWl0IGlzRW5jcnlwdGlvbkVuYWJsZWQoY3VycmVudFNpZ25lciwgXCJuaXAwNFwiKSkge1xuICAgIGVuY3J5cHRlZCA9IGF3YWl0IGN1cnJlbnRTaWduZXIuZW5jcnlwdChjdXJyZW50UmVjaXBpZW50LCB0aGlzLmNvbnRlbnQsIFwibmlwMDRcIik7XG4gIH1cbiAgaWYgKCFlbmNyeXB0ZWQpIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBlbmNyeXB0IGV2ZW50LlwiKTtcbiAgdGhpcy5jb250ZW50ID0gZW5jcnlwdGVkO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdChzZW5kZXIsIHNpZ25lciwgc2NoZW1lKSB7XG4gIGlmICh0aGlzLm5kaz8uY2FjaGVBZGFwdGVyPy5nZXREZWNyeXB0ZWRFdmVudCkge1xuICAgIGxldCBjYWNoZWRFdmVudCA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZ2V0RGVjcnlwdGVkRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2FjaGVkRXZlbnQgPSB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZ2V0RGVjcnlwdGVkRXZlbnQodGhpcy5pZCk7XG4gICAgfVxuICAgIGlmIChjYWNoZWRFdmVudCkge1xuICAgICAgdGhpcy5jb250ZW50ID0gY2FjaGVkRXZlbnQuY29udGVudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbGV0IGRlY3J5cHRlZDtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kIVwiKTtcbiAgbGV0IGN1cnJlbnRTaWduZXIgPSBzaWduZXI7XG4gIGlmICghY3VycmVudFNpZ25lcikge1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGN1cnJlbnRTaWduZXIgPSB0aGlzLm5kay5zaWduZXI7XG4gIH1cbiAgaWYgKCFjdXJyZW50U2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBOREsgc2lnbmVyXCIpO1xuICBjb25zdCBjdXJyZW50U2VuZGVyID0gc2VuZGVyIHx8IHRoaXMuYXV0aG9yO1xuICBpZiAoIWN1cnJlbnRTZW5kZXIpIHRocm93IG5ldyBFcnJvcihcIk5vIHNlbmRlciBwcm92aWRlZCBhbmQgbm8gYXV0aG9yIGF2YWlsYWJsZVwiKTtcbiAgY29uc3QgY3VycmVudFNjaGVtZSA9IHNjaGVtZSB8fCAodGhpcy5jb250ZW50Lm1hdGNoKC9cXFxcP2l2PS8pID8gXCJuaXAwNFwiIDogXCJuaXA0NFwiKTtcbiAgaWYgKChjdXJyZW50U2NoZW1lID09PSBcIm5pcDA0XCIgfHwgdGhpcy5raW5kID09PSA0KSAmJiBhd2FpdCBpc0VuY3J5cHRpb25FbmFibGVkKGN1cnJlbnRTaWduZXIsIFwibmlwMDRcIikgJiYgdGhpcy5jb250ZW50LnNlYXJjaChcIlxcXFw/aXY9XCIpKSB7XG4gICAgZGVjcnlwdGVkID0gYXdhaXQgY3VycmVudFNpZ25lci5kZWNyeXB0KGN1cnJlbnRTZW5kZXIsIHRoaXMuY29udGVudCwgXCJuaXAwNFwiKTtcbiAgfVxuICBpZiAoIWRlY3J5cHRlZCAmJiBjdXJyZW50U2NoZW1lID09PSBcIm5pcDQ0XCIgJiYgYXdhaXQgaXNFbmNyeXB0aW9uRW5hYmxlZChjdXJyZW50U2lnbmVyLCBcIm5pcDQ0XCIpKSB7XG4gICAgZGVjcnlwdGVkID0gYXdhaXQgY3VycmVudFNpZ25lci5kZWNyeXB0KGN1cnJlbnRTZW5kZXIsIHRoaXMuY29udGVudCwgXCJuaXA0NFwiKTtcbiAgfVxuICBpZiAoIWRlY3J5cHRlZCkgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY3J5cHQgZXZlbnQuXCIpO1xuICB0aGlzLmNvbnRlbnQgPSBkZWNyeXB0ZWQ7XG4gIGlmICh0aGlzLm5kaz8uY2FjaGVBZGFwdGVyPy5hZGREZWNyeXB0ZWRFdmVudCkge1xuICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5hZGREZWNyeXB0ZWRFdmVudCh0aGlzKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaXNFbmNyeXB0aW9uRW5hYmxlZChzaWduZXIsIHNjaGVtZSkge1xuICBpZiAoIXNpZ25lci5lbmNyeXB0aW9uRW5hYmxlZCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIXNjaGVtZSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBCb29sZWFuKGF3YWl0IHNpZ25lci5lbmNyeXB0aW9uRW5hYmxlZChzY2hlbWUpKTtcbn1cblxuLy8gc3JjL3RocmVhZC9pbmRleC50c1xuZnVuY3Rpb24gZXZlbnRzQnlTYW1lQXV0aG9yKG9wLCBldmVudHMpIHtcbiAgY29uc3QgZXZlbnRzQnlBdXRob3IgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBldmVudHNCeUF1dGhvci5zZXQob3AuaWQsIG9wKTtcbiAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LnB1YmtleSA9PT0gb3AucHVia2V5KSB7XG4gICAgICBldmVudHNCeUF1dGhvci5zZXQoZXZlbnQuaWQsIGV2ZW50KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZXZlbnRzQnlBdXRob3I7XG59XG52YXIgaGFzTWFya2VycyA9IChldmVudCwgdGFnVHlwZSkgPT4ge1xuICByZXR1cm4gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKHRhZ1R5cGUpLnNvbWUoKHRhZykgPT4gdGFnWzNdICYmIHRhZ1szXSAhPT0gXCJcIik7XG59O1xuZnVuY3Rpb24gZXZlbnRJc1JlcGx5KG9wLCBldmVudCwgdGhyZWFkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgdGFnVHlwZSkge1xuICB0YWdUeXBlID8/PSBvcC50YWdUeXBlKCk7XG4gIGNvbnN0IHRhZ3MgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3ModGFnVHlwZSk7XG4gIHRocmVhZElkcy5hZGQob3AudGFnSWQoKSk7XG4gIGlmICh0aHJlYWRJZHMuaGFzKGV2ZW50LnRhZ0lkKCkpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGhlZWRFeHBsaWNpdFJlcGx5TWFya2VyID0gKCkgPT4ge1xuICAgIGxldCBldmVudElzVGFnZ2VkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGFncykge1xuICAgICAgaWYgKHRhZ1szXSA9PT0gXCJyZXBseVwiKSByZXR1cm4gdGhyZWFkSWRzLmhhcyh0YWdbMV0pO1xuICAgICAgY29uc3QgbWFya2VySXNFbXB0eSA9IHRhZ1szXSA9PT0gXCJcIiB8fCB0YWdbM10gPT09IHZvaWQgMDtcbiAgICAgIGNvbnN0IG1hcmtlcklzUm9vdCA9IHRhZ1szXSA9PT0gXCJyb290XCI7XG4gICAgICBpZiAodGFnWzFdID09PSBvcC50YWdJZCgpICYmIChtYXJrZXJJc0VtcHR5IHx8IG1hcmtlcklzUm9vdCkpIHtcbiAgICAgICAgZXZlbnRJc1RhZ2dlZCA9IG1hcmtlcklzUm9vdCA/IFwicm9vdFwiIDogdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFldmVudElzVGFnZ2VkKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGV2ZW50SXNUYWdnZWQgPT09IFwicm9vdFwiKSByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgY29uc3QgZXhwbGljaXRSZXBseU1hcmtlciA9IGhlZWRFeHBsaWNpdFJlcGx5TWFya2VyKCk7XG4gIGlmIChleHBsaWNpdFJlcGx5TWFya2VyICE9PSB2b2lkIDApIHJldHVybiBleHBsaWNpdFJlcGx5TWFya2VyO1xuICBpZiAoaGFzTWFya2VycyhldmVudCwgdGFnVHlwZSkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgZXhwZWN0ZWRUYWdzID0gb3AuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKS5tYXAoKHRhZykgPT4gdGFnWzFdKTtcbiAgZXhwZWN0ZWRUYWdzLnB1c2gob3AuaWQpO1xuICByZXR1cm4gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKS5ldmVyeSgodGFnKSA9PiBleHBlY3RlZFRhZ3MuaW5jbHVkZXModGFnWzFdKSk7XG59XG5mdW5jdGlvbiBldmVudFRocmVhZHMob3AsIGV2ZW50cykge1xuICBjb25zdCBldmVudHNCeUF1dGhvciA9IGV2ZW50c0J5U2FtZUF1dGhvcihvcCwgZXZlbnRzKTtcbiAgY29uc3QgdGhyZWFkRXZlbnRzID0gZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IGV2ZW50SXNQYXJ0T2ZUaHJlYWQob3AsIGV2ZW50LCBldmVudHNCeUF1dGhvcikpO1xuICByZXR1cm4gdGhyZWFkRXZlbnRzLnNvcnQoKGEsIGIpID0+IGEuY3JlYXRlZF9hdCAtIGIuY3JlYXRlZF9hdCk7XG59XG5mdW5jdGlvbiBnZXRFdmVudFJlcGx5SWQoZXZlbnQpIHtcbiAgY29uc3QgcmVwbHlUYWcgPSBnZXRSZXBseVRhZyhldmVudCk7XG4gIGlmIChyZXBseVRhZykgcmV0dXJuIHJlcGx5VGFnWzFdO1xuICBjb25zdCByb290VGFnID0gZ2V0Um9vdFRhZyhldmVudCk7XG4gIGlmIChyb290VGFnKSByZXR1cm4gcm9vdFRhZ1sxXTtcbn1cbmZ1bmN0aW9uIGlzRXZlbnRPcmlnaW5hbFBvc3QoZXZlbnQpIHtcbiAgcmV0dXJuIGdldEV2ZW50UmVwbHlJZChldmVudCkgPT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGV2ZW50VGhyZWFkSWRzKG9wLCBldmVudHMpIHtcbiAgY29uc3QgdGhyZWFkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgdGhyZWFkRXZlbnRzID0gZXZlbnRUaHJlYWRzKG9wLCBldmVudHMpO1xuICB0aHJlYWRFdmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHRocmVhZElkcy5zZXQoZXZlbnQuaWQsIGV2ZW50KSk7XG4gIHJldHVybiB0aHJlYWRJZHM7XG59XG5mdW5jdGlvbiBldmVudFJlcGxpZXMob3AsIGV2ZW50cywgdGhyZWFkRXZlbnRJZHMpIHtcbiAgdGhyZWFkRXZlbnRJZHMgPz89IG5ldyBTZXQoZXZlbnRUaHJlYWRJZHMob3AsIGV2ZW50cykua2V5cygpKTtcbiAgcmV0dXJuIGV2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiBldmVudElzUmVwbHkob3AsIGV2ZW50LCB0aHJlYWRFdmVudElkcykpO1xufVxuZnVuY3Rpb24gZXZlbnRJc1BhcnRPZlRocmVhZChvcCwgZXZlbnQsIGV2ZW50c0J5QXV0aG9yKSB7XG4gIGlmIChvcC5wdWJrZXkgIT09IGV2ZW50LnB1YmtleSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCB0YWdnZWRFdmVudElkcyA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gIGNvbnN0IGFsbFRhZ2dlZEV2ZW50c0FyZUJ5T3JpZ2luYWxBdXRob3IgPSB0YWdnZWRFdmVudElkcy5ldmVyeSgoaWQpID0+IGV2ZW50c0J5QXV0aG9yLmhhcyhpZCkpO1xuICByZXR1cm4gYWxsVGFnZ2VkRXZlbnRzQXJlQnlPcmlnaW5hbEF1dGhvcjtcbn1cbmZ1bmN0aW9uIGV2ZW50SGFzRVRhZ01hcmtlcnMoZXZlbnQpIHtcbiAgZm9yIChjb25zdCB0YWcgb2YgZXZlbnQudGFncykge1xuICAgIGlmICh0YWdbMF0gPT09IFwiZVwiICYmICh0YWdbM10gPz8gXCJcIikubGVuZ3RoID4gMCkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0Um9vdEV2ZW50SWQoZXZlbnQsIHNlYXJjaFRhZykge1xuICBzZWFyY2hUYWcgPz89IGV2ZW50LnRhZ1R5cGUoKTtcbiAgY29uc3Qgcm9vdEV2ZW50VGFnID0gZ2V0Um9vdFRhZyhldmVudCwgc2VhcmNoVGFnKTtcbiAgaWYgKHJvb3RFdmVudFRhZykgcmV0dXJuIHJvb3RFdmVudFRhZ1sxXTtcbiAgY29uc3QgcmVwbHlUYWcgPSBnZXRSZXBseVRhZyhldmVudCwgc2VhcmNoVGFnKTtcbiAgcmV0dXJuIHJlcGx5VGFnPy5bMV07XG59XG5mdW5jdGlvbiBnZXRSb290VGFnKGV2ZW50LCBzZWFyY2hUYWcpIHtcbiAgc2VhcmNoVGFnID8/PSBldmVudC50YWdUeXBlKCk7XG4gIGNvbnN0IHJvb3RFdmVudFRhZyA9IGV2ZW50LnRhZ3MuZmluZChpc1RhZ1Jvb3RUYWcpO1xuICBpZiAoIXJvb3RFdmVudFRhZykge1xuICAgIGlmIChldmVudEhhc0VUYWdNYXJrZXJzKGV2ZW50KSkgcmV0dXJuO1xuICAgIGNvbnN0IG1hdGNoaW5nVGFncyA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhzZWFyY2hUYWcpO1xuICAgIGlmIChtYXRjaGluZ1RhZ3MubGVuZ3RoIDwgMykgcmV0dXJuIG1hdGNoaW5nVGFnc1swXTtcbiAgfVxuICByZXR1cm4gcm9vdEV2ZW50VGFnO1xufVxudmFyIG5pcDIyUm9vdFRhZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJBXCIsIFwiRVwiLCBcIklcIl0pO1xudmFyIG5pcDIyUmVwbHlUYWdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiYVwiLCBcImVcIiwgXCJpXCJdKTtcbmZ1bmN0aW9uIGdldFJlcGx5VGFnKGV2ZW50LCBzZWFyY2hUYWcpIHtcbiAgaWYgKGV2ZW50LmtpbmQgPT09IDExMTEgLyogR2VuZXJpY1JlcGx5ICovKSB7XG4gICAgbGV0IHJlcGx5VGFnMjtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiBldmVudC50YWdzKSB7XG4gICAgICBpZiAobmlwMjJSb290VGFncy5oYXModGFnWzBdKSkgcmVwbHlUYWcyID0gdGFnO1xuICAgICAgZWxzZSBpZiAobmlwMjJSZXBseVRhZ3MuaGFzKHRhZ1swXSkpIHtcbiAgICAgICAgcmVwbHlUYWcyID0gdGFnO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcGx5VGFnMjtcbiAgfVxuICBzZWFyY2hUYWcgPz89IGV2ZW50LnRhZ1R5cGUoKTtcbiAgbGV0IGhhc01hcmtlcnMyID0gZmFsc2U7XG4gIGxldCByZXBseVRhZztcbiAgZm9yIChjb25zdCB0YWcgb2YgZXZlbnQudGFncykge1xuICAgIGlmICh0YWdbMF0gIT09IHNlYXJjaFRhZykgY29udGludWU7XG4gICAgaWYgKCh0YWdbM10gPz8gXCJcIikubGVuZ3RoID4gMCkgaGFzTWFya2VyczIgPSB0cnVlO1xuICAgIGlmIChoYXNNYXJrZXJzMiAmJiB0YWdbM10gPT09IFwicmVwbHlcIikgcmV0dXJuIHRhZztcbiAgICBpZiAoaGFzTWFya2VyczIgJiYgdGFnWzNdID09PSBcInJvb3RcIikgcmVwbHlUYWcgPSB0YWc7XG4gICAgaWYgKCFoYXNNYXJrZXJzMikgcmVwbHlUYWcgPSB0YWc7XG4gIH1cbiAgcmV0dXJuIHJlcGx5VGFnO1xufVxuZnVuY3Rpb24gaXNUYWdSb290VGFnKHRhZykge1xuICByZXR1cm4gdGFnWzBdID09PSBcIkVcIiB8fCB0YWdbM10gPT09IFwicm9vdFwiO1xufVxuXG4vLyBzcmMvZXZlbnRzL2ZldGNoLXRhZ2dlZC1ldmVudC50c1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hUYWdnZWRFdmVudCh0YWcsIG1hcmtlcikge1xuICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IGZvdW5kXCIpO1xuICBjb25zdCB0ID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3ModGFnLCBtYXJrZXIpO1xuICBpZiAodC5sZW5ndGggPT09IDApIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IFtfLCBpZCwgaGludF0gPSB0WzBdO1xuICBsZXQgcmVsYXkgPSBoaW50ICE9PSBcIlwiID8gdGhpcy5uZGsucG9vbC5nZXRSZWxheShoaW50KSA6IHZvaWQgMDtcbiAgY29uc3QgZXZlbnQgPSBhd2FpdCB0aGlzLm5kay5mZXRjaEV2ZW50KGlkLCB7fSwgcmVsYXkpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFJvb3RFdmVudChzdWJPcHRzKSB7XG4gIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3QgZm91bmRcIik7XG4gIGNvbnN0IHJvb3RUYWcgPSBnZXRSb290VGFnKHRoaXMpO1xuICBpZiAoIXJvb3RUYWcpIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiB0aGlzLm5kay5mZXRjaEV2ZW50RnJvbVRhZyhyb290VGFnLCB0aGlzLCBzdWJPcHRzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoUmVwbHlFdmVudChzdWJPcHRzKSB7XG4gIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3QgZm91bmRcIik7XG4gIGNvbnN0IHJlcGx5VGFnID0gZ2V0UmVwbHlUYWcodGhpcyk7XG4gIGlmICghcmVwbHlUYWcpIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiB0aGlzLm5kay5mZXRjaEV2ZW50RnJvbVRhZyhyZXBseVRhZywgdGhpcywgc3ViT3B0cyk7XG59XG5cbi8vIHNyYy9ldmVudHMva2luZC50c1xuZnVuY3Rpb24gaXNSZXBsYWNlYWJsZSgpIHtcbiAgaWYgKHRoaXMua2luZCA9PT0gdm9pZCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJLaW5kIG5vdCBzZXRcIik7XG4gIHJldHVybiBbMCwgM10uaW5jbHVkZXModGhpcy5raW5kKSB8fCB0aGlzLmtpbmQgPj0gMWU0ICYmIHRoaXMua2luZCA8IDJlNCB8fCB0aGlzLmtpbmQgPj0gM2U0ICYmIHRoaXMua2luZCA8IDRlNDtcbn1cbmZ1bmN0aW9uIGlzRXBoZW1lcmFsKCkge1xuICBpZiAodGhpcy5raW5kID09PSB2b2lkIDApIHRocm93IG5ldyBFcnJvcihcIktpbmQgbm90IHNldFwiKTtcbiAgcmV0dXJuIHRoaXMua2luZCA+PSAyZTQgJiYgdGhpcy5raW5kIDwgM2U0O1xufVxuZnVuY3Rpb24gaXNQYXJhbVJlcGxhY2VhYmxlKCkge1xuICBpZiAodGhpcy5raW5kID09PSB2b2lkIDApIHRocm93IG5ldyBFcnJvcihcIktpbmQgbm90IHNldFwiKTtcbiAgcmV0dXJuIHRoaXMua2luZCA+PSAzZTQgJiYgdGhpcy5raW5kIDwgNGU0O1xufVxuXG4vLyBzcmMvZXZlbnRzL25pcDE5LnRzXG5pbXBvcnQgeyBuaXAxOSBhcyBuaXAxOTIgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbnZhciBERUZBVUxUX1JFTEFZX0NPVU5UID0gMjtcbmZ1bmN0aW9uIGVuY29kZShtYXhSZWxheUNvdW50ID0gREVGQVVMVF9SRUxBWV9DT1VOVCkge1xuICBsZXQgcmVsYXlzID0gW107XG4gIGlmICh0aGlzLm9uUmVsYXlzLmxlbmd0aCA+IDApIHtcbiAgICByZWxheXMgPSB0aGlzLm9uUmVsYXlzLm1hcCgocmVsYXkpID0+IHJlbGF5LnVybCk7XG4gIH0gZWxzZSBpZiAodGhpcy5yZWxheSkge1xuICAgIHJlbGF5cyA9IFt0aGlzLnJlbGF5LnVybF07XG4gIH1cbiAgaWYgKHJlbGF5cy5sZW5ndGggPiBtYXhSZWxheUNvdW50KSB7XG4gICAgcmVsYXlzID0gcmVsYXlzLnNsaWNlKDAsIG1heFJlbGF5Q291bnQpO1xuICB9XG4gIGlmICh0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSB7XG4gICAgcmV0dXJuIG5pcDE5Mi5uYWRkckVuY29kZSh7XG4gICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICBwdWJrZXk6IHRoaXMucHVia2V5LFxuICAgICAgaWRlbnRpZmllcjogdGhpcy5yZXBsYWNlYWJsZURUYWcoKSxcbiAgICAgIHJlbGF5c1xuICAgIH0pO1xuICB9XG4gIGlmIChyZWxheXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBuaXAxOTIubmV2ZW50RW5jb2RlKHtcbiAgICAgIGlkOiB0aGlzLnRhZ0lkKCksXG4gICAgICByZWxheXMsXG4gICAgICBhdXRob3I6IHRoaXMucHVia2V5XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5pcDE5Mi5ub3RlRW5jb2RlKHRoaXMudGFnSWQoKSk7XG59XG5cbi8vIHNyYy9ldmVudHMvcmVwb3N0LnRzXG5hc3luYyBmdW5jdGlvbiByZXBvc3QocHVibGlzaCA9IHRydWUsIHNpZ25lcikge1xuICBpZiAoIXNpZ25lciAmJiBwdWJsaXNoKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIHNpZ25lciA9IHRoaXMubmRrLnNpZ25lcjtcbiAgfVxuICBjb25zdCBlID0gbmV3IE5ES0V2ZW50KHRoaXMubmRrLCB7XG4gICAga2luZDogZ2V0S2luZCh0aGlzKVxuICB9KTtcbiAgaWYgKCF0aGlzLmlzUHJvdGVjdGVkKSBlLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnJhd0V2ZW50KCkpO1xuICBlLnRhZyh0aGlzKTtcbiAgaWYgKHRoaXMua2luZCAhPT0gMSAvKiBUZXh0ICovKSB7XG4gICAgZS50YWdzLnB1c2goW1wia1wiLCBgJHt0aGlzLmtpbmR9YF0pO1xuICB9XG4gIGlmIChzaWduZXIpIGF3YWl0IGUuc2lnbihzaWduZXIpO1xuICBpZiAocHVibGlzaCkgYXdhaXQgZS5wdWJsaXNoKCk7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gZ2V0S2luZChldmVudCkge1xuICBpZiAoZXZlbnQua2luZCA9PT0gMSkge1xuICAgIHJldHVybiA2IC8qIFJlcG9zdCAqLztcbiAgfVxuICByZXR1cm4gMTYgLyogR2VuZXJpY1JlcG9zdCAqLztcbn1cblxuLy8gc3JjL2V2ZW50cy9zZXJpYWxpemVyLnRzXG5mdW5jdGlvbiBzZXJpYWxpemUoaW5jbHVkZVNpZyA9IGZhbHNlLCBpbmNsdWRlSWQgPSBmYWxzZSkge1xuICBjb25zdCBwYXlsb2FkID0gWzAsIHRoaXMucHVia2V5LCB0aGlzLmNyZWF0ZWRfYXQsIHRoaXMua2luZCwgdGhpcy50YWdzLCB0aGlzLmNvbnRlbnRdO1xuICBpZiAoaW5jbHVkZVNpZykgcGF5bG9hZC5wdXNoKHRoaXMuc2lnKTtcbiAgaWYgKGluY2x1ZGVJZCkgcGF5bG9hZC5wdXNoKHRoaXMuaWQpO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShzZXJpYWxpemVkRXZlbnQpIHtcbiAgY29uc3QgZXZlbnRBcnJheSA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZEV2ZW50KTtcbiAgY29uc3QgcmV0ID0ge1xuICAgIHB1YmtleTogZXZlbnRBcnJheVsxXSxcbiAgICBjcmVhdGVkX2F0OiBldmVudEFycmF5WzJdLFxuICAgIGtpbmQ6IGV2ZW50QXJyYXlbM10sXG4gICAgdGFnczogZXZlbnRBcnJheVs0XSxcbiAgICBjb250ZW50OiBldmVudEFycmF5WzVdXG4gIH07XG4gIGlmIChldmVudEFycmF5Lmxlbmd0aCA+PSA3KSB7XG4gICAgY29uc3QgZmlyc3QgPSBldmVudEFycmF5WzZdO1xuICAgIGNvbnN0IHNlY29uZCA9IGV2ZW50QXJyYXlbN107XG4gICAgaWYgKGZpcnN0ICYmIGZpcnN0Lmxlbmd0aCA9PT0gMTI4KSB7XG4gICAgICByZXQuc2lnID0gZmlyc3Q7XG4gICAgICBpZiAoc2Vjb25kICYmIHNlY29uZC5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgIHJldC5pZCA9IHNlY29uZDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZpcnN0ICYmIGZpcnN0Lmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgIHJldC5pZCA9IGZpcnN0O1xuICAgICAgaWYgKHNlY29uZCAmJiBzZWNvbmQubGVuZ3RoID09PSAxMjgpIHtcbiAgICAgICAgcmV0LnNpZyA9IHNlY29uZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gc3JjL2V2ZW50cy92YWxpZGF0aW9uLnRzXG5pbXBvcnQgeyBzY2hub3JyIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIjtcbmltcG9ydCB7IGJ5dGVzVG9IZXggfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuaW1wb3J0IHsgTFJVQ2FjaGUgfSBmcm9tIFwidHlwZXNjcmlwdC1scnUtY2FjaGVcIjtcblxuLy8gc3JjL2V2ZW50cy9zaWduYXR1cmUudHNcbnZhciB3b3JrZXI7XG52YXIgcHJvY2Vzc2luZ1F1ZXVlID0ge307XG5mdW5jdGlvbiBzaWduYXR1cmVWZXJpZmljYXRpb25Jbml0KHcpIHtcbiAgd29ya2VyID0gdztcbiAgd29ya2VyLm9ubWVzc2FnZSA9IChtc2cpID0+IHtcbiAgICBjb25zdCBbZXZlbnRJZCwgcmVzdWx0XSA9IG1zZy5kYXRhO1xuICAgIGNvbnN0IHJlY29yZCA9IHByb2Nlc3NpbmdRdWV1ZVtldmVudElkXTtcbiAgICBpZiAoIXJlY29yZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIk5vIHJlY29yZCBmb3VuZCBmb3IgZXZlbnRcIiwgZXZlbnRJZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBwcm9jZXNzaW5nUXVldWVbZXZlbnRJZF07XG4gICAgZm9yIChjb25zdCByZXNvbHZlIG9mIHJlY29yZC5yZXNvbHZlcykge1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZUFzeW5jKGV2ZW50LCBfcGVyc2lzdCwgcmVsYXkpIHtcbiAgY29uc3QgbmRrSW5zdGFuY2UgPSBldmVudC5uZGs7XG4gIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKG5ka0luc3RhbmNlLnNpZ25hdHVyZVZlcmlmaWNhdGlvbkZ1bmN0aW9uKSB7XG4gICAgY29uc29sZS5sb2coXCJbTkRLLUNPUkVdIFVzaW5nIGN1c3RvbSBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZ1bmN0aW9uIGFzeW5jXCIpO1xuICAgIHJlc3VsdCA9IGF3YWl0IG5ka0luc3RhbmNlLnNpZ25hdHVyZVZlcmlmaWNhdGlvbkZ1bmN0aW9uKGV2ZW50KTtcbiAgICBjb25zb2xlLmxvZyhcIkN1c3RvbSBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIHJlc3VsdFwiLCBldmVudC5pZCwgeyByZXN1bHQgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2coXCJVc2luZyB3b3JrZXItYmFzZWQgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBhc3luY1wiKTtcbiAgICByZXN1bHQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IGV2ZW50LnNlcmlhbGl6ZSgpO1xuICAgICAgbGV0IGVucXVldWUgPSBmYWxzZTtcbiAgICAgIGlmICghcHJvY2Vzc2luZ1F1ZXVlW2V2ZW50LmlkXSkge1xuICAgICAgICBwcm9jZXNzaW5nUXVldWVbZXZlbnQuaWRdID0geyBldmVudCwgcmVzb2x2ZXM6IFtdLCByZWxheSB9O1xuICAgICAgICBlbnF1ZXVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3NpbmdRdWV1ZVtldmVudC5pZF0ucmVzb2x2ZXMucHVzaChyZXNvbHZlKTtcbiAgICAgIGlmICghZW5xdWV1ZSkgcmV0dXJuO1xuICAgICAgd29ya2VyPy5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNlcmlhbGl6ZWQsXG4gICAgICAgIGlkOiBldmVudC5pZCxcbiAgICAgICAgc2lnOiBldmVudC5zaWcsXG4gICAgICAgIHB1YmtleTogZXZlbnQucHVia2V5XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBuZGtJbnN0YW5jZS5zaWduYXR1cmVWZXJpZmljYXRpb25UaW1lTXMgKz0gRGF0ZS5ub3coKSAtIHN0YXJ0O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvZXZlbnRzL3ZhbGlkYXRpb24udHNcbnZhciBQVUJLRVlfUkVHRVggPSAvXlthLWYwLTldezY0fSQvO1xuZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIGlmICh0eXBlb2YgdGhpcy5raW5kICE9PSBcIm51bWJlclwiKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgdGhpcy5jb250ZW50ICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgdGhpcy5jcmVhdGVkX2F0ICE9PSBcIm51bWJlclwiKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgdGhpcy5wdWJrZXkgIT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcbiAgaWYgKCF0aGlzLnB1YmtleS5tYXRjaChQVUJLRVlfUkVHRVgpKSByZXR1cm4gZmFsc2U7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLnRhZ3MpKSByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdzW2ldO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWcpKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YWcubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnW2pdID09PSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxudmFyIHZlcmlmaWVkU2lnbmF0dXJlcyA9IG5ldyBMUlVDYWNoZSh7XG4gIG1heFNpemU6IDFlMyxcbiAgZW50cnlFeHBpcmF0aW9uVGltZUluTVM6IDZlNFxufSk7XG5mdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmUocGVyc2lzdCkge1xuICBpZiAodHlwZW9mIHRoaXMuc2lnbmF0dXJlVmVyaWZpZWQgPT09IFwiYm9vbGVhblwiKSByZXR1cm4gdGhpcy5zaWduYXR1cmVWZXJpZmllZDtcbiAgY29uc3QgcHJldlZlcmlmaWNhdGlvbiA9IHZlcmlmaWVkU2lnbmF0dXJlcy5nZXQodGhpcy5pZCk7XG4gIGlmIChwcmV2VmVyaWZpY2F0aW9uICE9PSBudWxsKSB7XG4gICAgdGhpcy5zaWduYXR1cmVWZXJpZmllZCA9ICEhcHJldlZlcmlmaWNhdGlvbjtcbiAgICByZXR1cm4gdGhpcy5zaWduYXR1cmVWZXJpZmllZDtcbiAgfVxuICB0cnkge1xuICAgIGlmICh0aGlzLm5kaz8uYXN5bmNTaWdWZXJpZmljYXRpb24pIHtcbiAgICAgIHZlcmlmeVNpZ25hdHVyZUFzeW5jKHRoaXMsIHBlcnNpc3QsIHRoaXMucmVsYXkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAocGVyc2lzdCkge1xuICAgICAgICAgIHRoaXMuc2lnbmF0dXJlVmVyaWZpZWQgPSByZXN1bHQ7XG4gICAgICAgICAgaWYgKHJlc3VsdCkgdmVyaWZpZWRTaWduYXR1cmVzLnNldCh0aGlzLmlkLCB0aGlzLnNpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICBpZiAodGhpcy5yZWxheSkge1xuICAgICAgICAgICAgdGhpcy5uZGs/LnJlcG9ydEludmFsaWRTaWduYXR1cmUodGhpcywgdGhpcy5yZWxheSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmRrPy5yZXBvcnRJbnZhbGlkU2lnbmF0dXJlKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2ZXJpZmllZFNpZ25hdHVyZXMuc2V0KHRoaXMuaWQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwic2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBlcnJvclwiLCB0aGlzLmlkLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhhc2ggPSBzaGEyNTYobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHRoaXMuc2VyaWFsaXplKCkpKTtcbiAgICAgIGNvbnN0IHJlcyA9IHNjaG5vcnIudmVyaWZ5KHRoaXMuc2lnLCBoYXNoLCB0aGlzLnB1YmtleSk7XG4gICAgICBpZiAocmVzKSB2ZXJpZmllZFNpZ25hdHVyZXMuc2V0KHRoaXMuaWQsIHRoaXMuc2lnKTtcbiAgICAgIGVsc2UgdmVyaWZpZWRTaWduYXR1cmVzLnNldCh0aGlzLmlkLCBmYWxzZSk7XG4gICAgICB0aGlzLnNpZ25hdHVyZVZlcmlmaWVkID0gcmVzO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICB0aGlzLnNpZ25hdHVyZVZlcmlmaWVkID0gZmFsc2U7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRFdmVudEhhc2goKSB7XG4gIHJldHVybiBnZXRFdmVudEhhc2hGcm9tU2VyaWFsaXplZEV2ZW50KHRoaXMuc2VyaWFsaXplKCkpO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRIYXNoRnJvbVNlcmlhbGl6ZWRFdmVudChzZXJpYWxpemVkRXZlbnQpIHtcbiAgY29uc3QgZXZlbnRIYXNoID0gc2hhMjU2KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzZXJpYWxpemVkRXZlbnQpKTtcbiAgcmV0dXJuIGJ5dGVzVG9IZXgoZXZlbnRIYXNoKTtcbn1cblxuLy8gc3JjL2V2ZW50cy9pbmRleC50c1xudmFyIHNraXBDbGllbnRUYWdPbktpbmRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAwIC8qIE1ldGFkYXRhICovLFxuICA0IC8qIEVuY3J5cHRlZERpcmVjdE1lc3NhZ2UgKi8sXG4gIDEwNTkgLyogR2lmdFdyYXAgKi8sXG4gIDEzIC8qIEdpZnRXcmFwU2VhbCAqLyxcbiAgMyAvKiBDb250YWN0cyAqLyxcbiAgOTczNCAvKiBaYXBSZXF1ZXN0ICovLFxuICA1IC8qIEV2ZW50RGVsZXRpb24gKi9cbl0pO1xudmFyIE5ES0V2ZW50ID0gY2xhc3MgX05ES0V2ZW50IGV4dGVuZHMgRXZlbnRFbWl0dGVyMiB7XG4gIG5kaztcbiAgY3JlYXRlZF9hdDtcbiAgY29udGVudCA9IFwiXCI7XG4gIHRhZ3MgPSBbXTtcbiAga2luZDtcbiAgaWQgPSBcIlwiO1xuICBzaWc7XG4gIHB1YmtleSA9IFwiXCI7XG4gIHNpZ25hdHVyZVZlcmlmaWVkO1xuICBfYXV0aG9yID0gdm9pZCAwO1xuICAvKipcbiAgICogVGhlIHJlbGF5IHRoYXQgdGhpcyBldmVudCB3YXMgZmlyc3QgcmVjZWl2ZWQgZnJvbS5cbiAgICovXG4gIHJlbGF5O1xuICAvKipcbiAgICogVGhlIHJlbGF5cyB0aGF0IHRoaXMgZXZlbnQgd2FzIHJlY2VpdmVkIGZyb20gYW5kL29yIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQgdG8uXG4gICAqL1xuICBnZXQgb25SZWxheXMoKSB7XG4gICAgbGV0IHJlcyA9IFtdO1xuICAgIGlmICghdGhpcy5uZGspIHtcbiAgICAgIGlmICh0aGlzLnJlbGF5KSByZXMucHVzaCh0aGlzLnJlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0gdGhpcy5uZGsuc3ViTWFuYWdlci5zZWVuRXZlbnRzLmdldCh0aGlzLmlkKSB8fCBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICAvKipcbiAgICogVGhlIHN0YXR1cyBvZiB0aGUgcHVibGlzaCBvcGVyYXRpb24uXG4gICAqL1xuICBwdWJsaXNoU3RhdHVzID0gXCJzdWNjZXNzXCI7XG4gIHB1Ymxpc2hFcnJvcjtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgdGhpcy5jcmVhdGVkX2F0ID0gZXZlbnQ/LmNyZWF0ZWRfYXQ7XG4gICAgdGhpcy5jb250ZW50ID0gZXZlbnQ/LmNvbnRlbnQgfHwgXCJcIjtcbiAgICB0aGlzLnRhZ3MgPSBldmVudD8udGFncyB8fCBbXTtcbiAgICB0aGlzLmlkID0gZXZlbnQ/LmlkIHx8IFwiXCI7XG4gICAgdGhpcy5zaWcgPSBldmVudD8uc2lnO1xuICAgIHRoaXMucHVia2V5ID0gZXZlbnQ/LnB1YmtleSB8fCBcIlwiO1xuICAgIHRoaXMua2luZCA9IGV2ZW50Py5raW5kO1xuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIF9OREtFdmVudCkge1xuICAgICAgaWYgKHRoaXMucmVsYXkpIHtcbiAgICAgICAgdGhpcy5yZWxheSA9IGV2ZW50LnJlbGF5O1xuICAgICAgICB0aGlzLm5kaz8uc3ViTWFuYWdlci5zZWVuRXZlbnQoZXZlbnQuaWQsIHRoaXMucmVsYXkpO1xuICAgICAgfVxuICAgICAgdGhpcy5wdWJsaXNoU3RhdHVzID0gZXZlbnQucHVibGlzaFN0YXR1cztcbiAgICAgIHRoaXMucHVibGlzaEVycm9yID0gZXZlbnQucHVibGlzaEVycm9yO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVzZXJpYWxpemUgYW4gTkRLRXZlbnQgZnJvbSBhIHNlcmlhbGl6ZWQgcGF5bG9hZC5cbiAgICogQHBhcmFtIG5ka1xuICAgKiBAcGFyYW0gZXZlbnRcbiAgICogQHJldHVybnNcbiAgICovXG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShuZGssIGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLRXZlbnQobmRrLCBkZXNlcmlhbGl6ZShldmVudCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBldmVudCBhcyBpcy5cbiAgICovXG4gIHJhd0V2ZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVkX2F0OiB0aGlzLmNyZWF0ZWRfYXQsXG4gICAgICBjb250ZW50OiB0aGlzLmNvbnRlbnQsXG4gICAgICB0YWdzOiB0aGlzLnRhZ3MsXG4gICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICBwdWJrZXk6IHRoaXMucHVia2V5LFxuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBzaWc6IHRoaXMuc2lnXG4gICAgfTtcbiAgfVxuICBzZXQgYXV0aG9yKHVzZXIpIHtcbiAgICB0aGlzLnB1YmtleSA9IHVzZXIucHVia2V5O1xuICAgIHRoaXMuX2F1dGhvciA9IHVzZXI7XG4gICAgdGhpcy5fYXV0aG9yLm5kayA/Pz0gdGhpcy5uZGs7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gTkRLVXNlciBmb3IgdGhlIGF1dGhvciBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBnZXQgYXV0aG9yKCkge1xuICAgIGlmICh0aGlzLl9hdXRob3IpIHJldHVybiB0aGlzLl9hdXRob3I7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIGNvbnN0IHVzZXIgPSB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5OiB0aGlzLnB1YmtleSB9KTtcbiAgICB0aGlzLl9hdXRob3IgPSB1c2VyO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIC8qKlxuICAgKiBOSVAtNzMgdGFnZ2luZyBvZiBleHRlcm5hbCBlbnRpdGllc1xuICAgKiBAcGFyYW0gZW50aXR5IHRvIGJlIHRhZ2dlZFxuICAgKiBAcGFyYW0gdHlwZSBvZiB0aGUgZW50aXR5XG4gICAqIEBwYXJhbSBtYXJrZXJVcmwgdG8gYmUgdXNlZCBhcyB0aGUgbWFya2VyIFVSTFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGV2ZW50LnRhZ0V4dGVybmFsKFwiaHR0cHM6Ly9leGFtcGxlLmNvbS9hcnRpY2xlLzEyMyNub3N0clwiLCBcInVybFwiKTtcbiAgICogZXZlbnQudGFncyA9PiBbW1wiaVwiLCBcImh0dHBzOi8vZXhhbXBsZS5jb20vMTIzXCJdLCBbXCJrXCIsIFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiXV1cbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlIHRhZyBhIHBvZGNhc3Q6aXRlbTpndWlkXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogZXZlbnQudGFnRXh0ZXJuYWwoXCJlMzJiNDg5MC1iOWVhLTRhZWYtYTBiZi01NGI3ODc4MzNkYzVcIiwgXCJwb2RjYXN0Oml0ZW06Z3VpZFwiKTtcbiAgICogZXZlbnQudGFncyA9PiBbW1wiaVwiLCBcInBvZGNhc3Q6aXRlbTpndWlkOmUzMmI0ODkwLWI5ZWEtNGFlZi1hMGJmLTU0Yjc4NzgzM2RjNVwiXSwgW1wia1wiLCBcInBvZGNhc3Q6aXRlbTpndWlkXCJdXVxuICAgKiBgYGBcbiAgICpcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci83My5tZFxuICAgKi9cbiAgdGFnRXh0ZXJuYWwoZW50aXR5LCB0eXBlLCBtYXJrZXJVcmwpIHtcbiAgICBjb25zdCBpVGFnID0gW1wiaVwiXTtcbiAgICBjb25zdCBrVGFnID0gW1wia1wiXTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJ1cmxcIjoge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGVudGl0eSk7XG4gICAgICAgIHVybC5oYXNoID0gXCJcIjtcbiAgICAgICAgaVRhZy5wdXNoKHVybC50b1N0cmluZygpKTtcbiAgICAgICAga1RhZy5wdXNoKGAke3VybC5wcm90b2NvbH0vLyR7dXJsLmhvc3R9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImhhc2h0YWdcIjpcbiAgICAgICAgaVRhZy5wdXNoKGAjJHtlbnRpdHkudG9Mb3dlckNhc2UoKX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwiI1wiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZ2VvaGFzaFwiOlxuICAgICAgICBpVGFnLnB1c2goYGdlbzoke2VudGl0eS50b0xvd2VyQ2FzZSgpfWApO1xuICAgICAgICBrVGFnLnB1c2goXCJnZW9cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlzYm5cIjpcbiAgICAgICAgaVRhZy5wdXNoKGBpc2JuOiR7ZW50aXR5LnJlcGxhY2UoLy0vZywgXCJcIil9YCk7XG4gICAgICAgIGtUYWcucHVzaChcImlzYm5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvZGNhc3Q6Z3VpZFwiOlxuICAgICAgICBpVGFnLnB1c2goYHBvZGNhc3Q6Z3VpZDoke2VudGl0eX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwicG9kY2FzdDpndWlkXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb2RjYXN0Oml0ZW06Z3VpZFwiOlxuICAgICAgICBpVGFnLnB1c2goYHBvZGNhc3Q6aXRlbTpndWlkOiR7ZW50aXR5fWApO1xuICAgICAgICBrVGFnLnB1c2goXCJwb2RjYXN0Oml0ZW06Z3VpZFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicG9kY2FzdDpwdWJsaXNoZXI6Z3VpZFwiOlxuICAgICAgICBpVGFnLnB1c2goYHBvZGNhc3Q6cHVibGlzaGVyOmd1aWQ6JHtlbnRpdHl9YCk7XG4gICAgICAgIGtUYWcucHVzaChcInBvZGNhc3Q6cHVibGlzaGVyOmd1aWRcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlzYW5cIjpcbiAgICAgICAgaVRhZy5wdXNoKGBpc2FuOiR7ZW50aXR5LnNwbGl0KFwiLVwiKS5zbGljZSgwLCA0KS5qb2luKFwiLVwiKX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwiaXNhblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZG9pXCI6XG4gICAgICAgIGlUYWcucHVzaChgZG9pOiR7ZW50aXR5LnRvTG93ZXJDYXNlKCl9YCk7XG4gICAgICAgIGtUYWcucHVzaChcImRvaVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE5JUC03MyBlbnRpdHkgdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbiAgICBpZiAobWFya2VyVXJsKSB7XG4gICAgICBpVGFnLnB1c2gobWFya2VyVXJsKTtcbiAgICB9XG4gICAgdGhpcy50YWdzLnB1c2goaVRhZyk7XG4gICAgdGhpcy50YWdzLnB1c2goa1RhZyk7XG4gIH1cbiAgLyoqXG4gICAqIFRhZyBhIHVzZXIgd2l0aCBhbiBvcHRpb25hbCBtYXJrZXIuXG4gICAqIEBwYXJhbSB0YXJnZXQgV2hhdCBpcyB0byBiZSB0YWdnZWQuIENhbiBiZSBhbiBOREtVc2VyLCBOREtFdmVudCwgb3IgYW4gTkRLVGFnLlxuICAgKiBAcGFyYW0gbWFya2VyIFRoZSBtYXJrZXIgdG8gdXNlIGluIHRoZSB0YWcuXG4gICAqIEBwYXJhbSBza2lwQXV0aG9yVGFnIFdoZXRoZXIgdG8gZXhwbGljaXRseSBza2lwIGFkZGluZyB0aGUgYXV0aG9yIHRhZyBvZiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSBmb3JjZVRhZyBGb3JjZSBhIHNwZWNpZmljIHRhZyB0byBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgXCJlXCIgb3IgXCJhXCIgdGFnLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIHJlcGx5LnRhZyhvcEV2ZW50LCBcInJlcGx5XCIpO1xuICAgKiAvLyByZXBseS50YWdzID0+IFtbXCJlXCIsIDxpZD4sIDxyZWxheT4sIFwicmVwbHlcIl1dXG4gICAqIGBgYFxuICAgKi9cbiAgdGFnKHRhcmdldCwgbWFya2VyLCBza2lwQXV0aG9yVGFnLCBmb3JjZVRhZykge1xuICAgIGxldCB0YWdzID0gW107XG4gICAgY29uc3QgaXNOREtVc2VyID0gdGFyZ2V0LmZldGNoUHJvZmlsZSAhPT0gdm9pZCAwO1xuICAgIGlmIChpc05ES1VzZXIpIHtcbiAgICAgIGZvcmNlVGFnID8/PSBcInBcIjtcbiAgICAgIGNvbnN0IHRhZyA9IFtmb3JjZVRhZywgdGFyZ2V0LnB1YmtleV07XG4gICAgICBpZiAobWFya2VyKSB0YWcucHVzaCguLi5bXCJcIiwgbWFya2VyXSk7XG4gICAgICB0YWdzLnB1c2godGFnKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIF9OREtFdmVudCkge1xuICAgICAgY29uc3QgZXZlbnQgPSB0YXJnZXQ7XG4gICAgICBza2lwQXV0aG9yVGFnID8/PSBldmVudD8ucHVia2V5ID09PSB0aGlzLnB1YmtleTtcbiAgICAgIHRhZ3MgPSBldmVudC5yZWZlcmVuY2VUYWdzKG1hcmtlciwgc2tpcEF1dGhvclRhZywgZm9yY2VUYWcpO1xuICAgICAgZm9yIChjb25zdCBwVGFnIG9mIGV2ZW50LmdldE1hdGNoaW5nVGFncyhcInBcIikpIHtcbiAgICAgICAgaWYgKHBUYWdbMV0gPT09IHRoaXMucHVia2V5KSBjb250aW51ZTtcbiAgICAgICAgaWYgKHRoaXMudGFncy5maW5kKCh0KSA9PiB0WzBdID09PSBcInBcIiAmJiB0WzFdID09PSBwVGFnWzFdKSkgY29udGludWU7XG4gICAgICAgIHRoaXMudGFncy5wdXNoKFtcInBcIiwgcFRhZ1sxXV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICB0YWdzID0gW3RhcmdldF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIiwgdGFyZ2V0KTtcbiAgICB9XG4gICAgdGhpcy50YWdzID0gbWVyZ2VUYWdzKHRoaXMudGFncywgdGFncyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIE5vc3RyRXZlbnQgb2JqZWN0LCB0cnlpbmcgdG8gZmlsbCBpbiBtaXNzaW5nIGZpZWxkc1xuICAgKiB3aGVuIHBvc3NpYmxlLCBhZGRpbmcgdGFncyB3aGVuIG5lY2Vzc2FyeS5cbiAgICogQHBhcmFtIHB1YmtleSB7c3RyaW5nfSBUaGUgcHVia2V5IG9mIHRoZSB1c2VyIHdobyB0aGUgZXZlbnQgYmVsb25ncyB0by5cbiAgICogQHJldHVybnMge1Byb21pc2U8Tm9zdHJFdmVudD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgTm9zdHJFdmVudC5cbiAgICovXG4gIGFzeW5jIHRvTm9zdHJFdmVudChwdWJrZXkpIHtcbiAgICBpZiAoIXB1YmtleSAmJiB0aGlzLnB1YmtleSA9PT0gXCJcIikge1xuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubmRrPy5zaWduZXI/LnVzZXIoKTtcbiAgICAgIHRoaXMucHVia2V5ID0gdXNlcj8ucHVia2V5IHx8IFwiXCI7XG4gICAgfVxuICAgIGlmICghdGhpcy5jcmVhdGVkX2F0KSB7XG4gICAgICB0aGlzLmNyZWF0ZWRfYXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRlbnQsIHRhZ3MgfSA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVUYWdzKCk7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudCB8fCBcIlwiO1xuICAgIHRoaXMudGFncyA9IHRhZ3M7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLmdldEV2ZW50SGFzaCgpO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJhd0V2ZW50KCk7XG4gIH1cbiAgc2VyaWFsaXplID0gc2VyaWFsaXplLmJpbmQodGhpcyk7XG4gIGdldEV2ZW50SGFzaCA9IGdldEV2ZW50SGFzaC5iaW5kKHRoaXMpO1xuICB2YWxpZGF0ZSA9IHZhbGlkYXRlLmJpbmQodGhpcyk7XG4gIHZlcmlmeVNpZ25hdHVyZSA9IHZlcmlmeVNpZ25hdHVyZS5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogSXMgdGhpcyBldmVudCByZXBsYWNlYWJsZSAod2hldGhlciBwYXJhbWV0ZXJpemVkIG9yIG5vdCk/XG4gICAqXG4gICAqIFRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBmb3Iga2luZCAwLCAzLCAxMGstMjBrIGFuZCAzMGstNDBrXG4gICAqL1xuICBpc1JlcGxhY2VhYmxlID0gaXNSZXBsYWNlYWJsZS5iaW5kKHRoaXMpO1xuICBpc0VwaGVtZXJhbCA9IGlzRXBoZW1lcmFsLmJpbmQodGhpcyk7XG4gIGlzRHZtID0gKCkgPT4gdGhpcy5raW5kICYmIHRoaXMua2luZCA+PSA1ZTMgJiYgdGhpcy5raW5kIDw9IDdlMztcbiAgLyoqXG4gICAqIElzIHRoaXMgZXZlbnQgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZT9cbiAgICpcbiAgICogVGhpcyB3aWxsIHJldHVybiB0cnVlIGZvciBraW5kIDMway00MGtcbiAgICovXG4gIGlzUGFyYW1SZXBsYWNlYWJsZSA9IGlzUGFyYW1SZXBsYWNlYWJsZS5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogRW5jb2RlcyBhIGJlY2gzMiBpZC5cbiAgICpcbiAgICogQHBhcmFtIHJlbGF5cyB7c3RyaW5nW119IFRoZSByZWxheXMgdG8gZW5jb2RlIGluIHRoZSBpZFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIEVuY29kZWQgbmFkZHIsIG5vdGUgb3IgbmV2ZW50LlxuICAgKi9cbiAgZW5jb2RlID0gZW5jb2RlLmJpbmQodGhpcyk7XG4gIGVuY3J5cHQgPSBlbmNyeXB0LmJpbmQodGhpcyk7XG4gIGRlY3J5cHQgPSBkZWNyeXB0LmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBHZXQgYWxsIHRhZ3Mgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKiBAcGFyYW0gdGFnTmFtZSB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgdGFnIHRvIHNlYXJjaCBmb3JcbiAgICogQHJldHVybnMge05ES1RhZ1tdfSBBbiBhcnJheSBvZiB0aGUgbWF0Y2hpbmcgdGFnc1xuICAgKi9cbiAgZ2V0TWF0Y2hpbmdUYWdzKHRhZ05hbWUsIG1hcmtlcikge1xuICAgIGNvbnN0IHQgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gdGFnTmFtZSk7XG4gICAgaWYgKG1hcmtlciA9PT0gdm9pZCAwKSByZXR1cm4gdDtcbiAgICByZXR1cm4gdC5maWx0ZXIoKHRhZykgPT4gdGFnWzNdID09PSBtYXJrZXIpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZXZlbnQgaGFzIGEgdGFnIHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICogQHBhcmFtIHRhZ05hbWVcbiAgICogQHBhcmFtIG1hcmtlclxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgaGFzVGFnKHRhZ05hbWUsIG1hcmtlcikge1xuICAgIHJldHVybiB0aGlzLnRhZ3Muc29tZSgodGFnKSA9PiB0YWdbMF0gPT09IHRhZ05hbWUgJiYgKCFtYXJrZXIgfHwgdGFnWzNdID09PSBtYXJrZXIpKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBmaXJzdCB0YWcgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKiBAcGFyYW0gdGFnTmFtZSBUYWcgbmFtZSB0byBzZWFyY2ggZm9yXG4gICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgdGFnIHdpdGggdGhlIGdpdmVuIG5hbWUsIG9yIHVuZGVmaW5lZCBpZiBubyBzdWNoIHRhZyBleGlzdHNcbiAgICovXG4gIHRhZ1ZhbHVlKHRhZ05hbWUsIG1hcmtlcikge1xuICAgIGNvbnN0IHRhZ3MgPSB0aGlzLmdldE1hdGNoaW5nVGFncyh0YWdOYW1lLCBtYXJrZXIpO1xuICAgIGlmICh0YWdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gdGFnc1swXVsxXTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgTklQLTMxIFwiYWx0XCIgdGFnIG9mIHRoZSBldmVudC5cbiAgICovXG4gIGdldCBhbHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJhbHRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIE5JUC0zMSBcImFsdFwiIHRhZyBvZiB0aGUgZXZlbnQuIFVzZSB0aGlzIHRvIHNldCBhbiBhbHQgdGFnIHNvXG4gICAqIGNsaWVudHMgdGhhdCBkb24ndCBoYW5kbGUgYSBwYXJ0aWN1bGFyIGV2ZW50IGtpbmQgY2FuIGRpc3BsYXkgc29tZXRoaW5nXG4gICAqIHVzZWZ1bCBmb3IgdXNlcnMuXG4gICAqL1xuICBzZXQgYWx0KGFsdCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiYWx0XCIpO1xuICAgIGlmIChhbHQpIHRoaXMudGFncy5wdXNoKFtcImFsdFwiLCBhbHRdKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgTklQLTMzIFwiZFwiIHRhZyBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBnZXQgZFRhZygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIE5JUC0zMyBcImRcIiB0YWcgb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgc2V0IGRUYWcodmFsdWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImRcIik7XG4gICAgaWYgKHZhbHVlKSB0aGlzLnRhZ3MucHVzaChbXCJkXCIsIHZhbHVlXSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgdGFncyB3aXRoIHRoZSBnaXZlbiBuYW1lIChlLmcuIFwiZFwiLCBcImFcIiwgXCJwXCIpXG4gICAqIEBwYXJhbSB0YWdOYW1lIFRhZyBuYW1lKHMpIHRvIHNlYXJjaCBmb3IgYW5kIHJlbW92ZVxuICAgKiBAcGFyYW0gbWFya2VyIE9wdGlvbmFsIG1hcmtlciB0byBjaGVjayBmb3IgdG9vXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIFJlbW92ZSBhIHRhZ3Mgd2l0aCBhIFwiZGVmZXJcIiBtYXJrZXJcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBldmVudC50YWdzID0gW1xuICAgKiAgIFtcImFcIiwgXCIuLi4uXCIsIFwiZGVmZXJcIl0sXG4gICAqICAgW1wiYVwiLCBcIi4uLi5cIiwgXCJuby1kZWZlclwiXSxcbiAgICogXVxuICAgKlxuICAgKiBldmVudC5yZW1vdmVUYWcoXCJhXCIsIFwiZGVmZXJcIik7XG4gICAqXG4gICAqIC8vIGV2ZW50LnRhZ3MgPT4gW1tcImFcIiwgXCIuLi4uXCIsIFwibm8tZGVmZXJcIl1dXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcmVtb3ZlVGFnKHRhZ05hbWUsIG1hcmtlcikge1xuICAgIGNvbnN0IHRhZ05hbWVzID0gQXJyYXkuaXNBcnJheSh0YWdOYW1lKSA/IHRhZ05hbWUgOiBbdGFnTmFtZV07XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB7XG4gICAgICBjb25zdCBpbmNsdWRlID0gdGFnTmFtZXMuaW5jbHVkZXModGFnWzBdKTtcbiAgICAgIGNvbnN0IGhhc01hcmtlciA9IG1hcmtlciA/IHRhZ1szXSA9PT0gbWFya2VyIDogdHJ1ZTtcbiAgICAgIHJldHVybiAhKGluY2x1ZGUgJiYgaGFzTWFya2VyKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZSBhIHRhZyB3aXRoIGEgbmV3IHZhbHVlLiBJZiBub3QgZm91bmQsIGl0IHdpbGwgYmUgYWRkZWQuXG4gICAqIEBwYXJhbSB0YWcgVGhlIHRhZyB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHRhZy5cbiAgICovXG4gIHJlcGxhY2VUYWcodGFnKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcodGFnWzBdKTtcbiAgICB0aGlzLnRhZ3MucHVzaCh0YWcpO1xuICB9XG4gIC8qKlxuICAgKiBTaWduIHRoZSBldmVudCBpZiBhIHNpZ25lciBpcyBwcmVzZW50LlxuICAgKlxuICAgKiBJdCB3aWxsIGdlbmVyYXRlIHRhZ3MuXG4gICAqIFJlcGxlYWNhYmxlIGV2ZW50cyB3aWxsIGhhdmUgdGhlaXIgY3JlYXRlZF9hdCBmaWVsZCBzZXQgdG8gdGhlIGN1cnJlbnQgdGltZS5cbiAgICogQHBhcmFtIHNpZ25lciB7TkRLU2lnbmVyfSBUaGUgTkRLU2lnbmVyIHRvIHVzZSB0byBzaWduIHRoZSBldmVudFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgc2lnbmF0dXJlIG9mIHRoZSBzaWduZWQgZXZlbnQuXG4gICAqL1xuICBhc3luYyBzaWduKHNpZ25lcikge1xuICAgIGlmICghc2lnbmVyKSB7XG4gICAgICB0aGlzLm5kaz8uYXNzZXJ0U2lnbmVyKCk7XG4gICAgICBzaWduZXIgPSB0aGlzLm5kaz8uc2lnbmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmF1dGhvciA9IGF3YWl0IHNpZ25lci51c2VyKCk7XG4gICAgfVxuICAgIGNvbnN0IG5vc3RyRXZlbnQgPSBhd2FpdCB0aGlzLnRvTm9zdHJFdmVudCgpO1xuICAgIHRoaXMuc2lnID0gYXdhaXQgc2lnbmVyLnNpZ24obm9zdHJFdmVudCk7XG4gICAgcmV0dXJuIHRoaXMuc2lnO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gcmVsYXlTZXRcbiAgICogQHBhcmFtIHRpbWVvdXRNc1xuICAgKiBAcGFyYW0gcmVxdWlyZWRSZWxheUNvdW50XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBwdWJsaXNoUmVwbGFjZWFibGUocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KSB7XG4gICAgdGhpcy5pZCA9IFwiXCI7XG4gICAgdGhpcy5jcmVhdGVkX2F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgICB0aGlzLnNpZyA9IFwiXCI7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaChyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIHNpZ24gYW5kIHRoZW4gcHVibGlzaCBhbiBOREtFdmVudCB0byBhIGdpdmVuIHJlbGF5U2V0LlxuICAgKiBJZiBubyByZWxheVNldCBpcyBwcm92aWRlZCwgdGhlIHJlbGF5U2V0IHdpbGwgYmUgY2FsY3VsYXRlZCBieSBOREsuXG4gICAqIEBwYXJhbSByZWxheVNldCB7TkRLUmVsYXlTZXR9IFRoZSByZWxheVNldCB0byBwdWJsaXNoIHRoZSBldmVuIHRvLlxuICAgKiBAcGFyYW0gdGltZW91dE0ge251bWJlcn0gVGhlIHRpbWVvdXQgZm9yIHRoZSBwdWJsaXNoIG9wZXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSByZXF1aXJlZFJlbGF5Q291bnQgVGhlIG51bWJlciBvZiByZWxheXMgdGhhdCBtdXN0IHJlY2VpdmUgdGhlIGV2ZW50IGZvciB0aGUgcHVibGlzaCB0byBiZSBjb25zaWRlcmVkIHN1Y2Nlc3NmdWwuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZWxheXMgdGhlIGV2ZW50IHdhcyBwdWJsaXNoZWQgdG8uXG4gICAqL1xuICBhc3luYyBwdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgIGlmICghcmVxdWlyZWRSZWxheUNvdW50KSByZXF1aXJlZFJlbGF5Q291bnQgPSAxO1xuICAgIGlmICghdGhpcy5zaWcpIGF3YWl0IHRoaXMuc2lnbigpO1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ES0V2ZW50IG11c3QgYmUgYXNzb2NpYXRlZCB3aXRoIGFuIE5ESyBpbnN0YW5jZSB0byBwdWJsaXNoXCIpO1xuICAgIGlmICghcmVsYXlTZXQgfHwgcmVsYXlTZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgcmVsYXlTZXQgPSB0aGlzLm5kay5kZXZXcml0ZVJlbGF5U2V0IHx8IGF3YWl0IGNhbGN1bGF0ZVJlbGF5U2V0RnJvbUV2ZW50KHRoaXMubmRrLCB0aGlzLCByZXF1aXJlZFJlbGF5Q291bnQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSA1IC8qIEV2ZW50RGVsZXRpb24gKi8gJiYgdGhpcy5uZGsuY2FjaGVBZGFwdGVyPy5kZWxldGVFdmVudElkcykge1xuICAgICAgY29uc3QgZVRhZ3MgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gICAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZGVsZXRlRXZlbnRJZHMoZVRhZ3MpO1xuICAgIH1cbiAgICBjb25zdCByYXdFdmVudCA9IHRoaXMucmF3RXZlbnQoKTtcbiAgICBpZiAodGhpcy5uZGsuY2FjaGVBZGFwdGVyPy5hZGRVbnB1Ymxpc2hlZEV2ZW50ICYmIHNob3VsZFRyYWNrVW5wdWJsaXNoZWRFdmVudCh0aGlzKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmFkZFVucHVibGlzaGVkRXZlbnQodGhpcywgcmVsYXlTZXQucmVsYXlVcmxzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFkZGluZyB1bnB1Ymxpc2hlZCBldmVudCB0byBjYWNoZVwiLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gNSAvKiBFdmVudERlbGV0aW9uICovICYmIHRoaXMubmRrLmNhY2hlQWRhcHRlcj8uZGVsZXRlRXZlbnRJZHMpIHtcbiAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5kZWxldGVFdmVudElkcyh0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSkpO1xuICAgIH1cbiAgICB0aGlzLm5kay5zdWJNYW5hZ2VyLmRpc3BhdGNoRXZlbnQocmF3RXZlbnQsIHZvaWQgMCwgdHJ1ZSk7XG4gICAgY29uc3QgcmVsYXlzID0gYXdhaXQgcmVsYXlTZXQucHVibGlzaCh0aGlzLCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gICAgcmVsYXlzLmZvckVhY2goKHJlbGF5KSA9PiB0aGlzLm5kaz8uc3ViTWFuYWdlci5zZWVuRXZlbnQodGhpcy5pZCwgcmVsYXkpKTtcbiAgICByZXR1cm4gcmVsYXlzO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGFncyBmb3IgdXNlcnMsIG5vdGVzLCBhbmQgb3RoZXIgZXZlbnRzIHRhZ2dlZCBpbiBjb250ZW50LlxuICAgKiBXaWxsIGFsc28gZ2VuZXJhdGUgcmFuZG9tIFwiZFwiIHRhZyBmb3IgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZSBldmVudHMgd2hlcmUgbmVlZGVkLlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gVGhlIHRhZ3MgYW5kIGNvbnRlbnQgb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVUYWdzKCkge1xuICAgIGxldCB0YWdzID0gW107XG4gICAgY29uc3QgZyA9IGF3YWl0IGdlbmVyYXRlQ29udGVudFRhZ3ModGhpcy5jb250ZW50LCB0aGlzLnRhZ3MpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBnLmNvbnRlbnQ7XG4gICAgdGFncyA9IGcudGFncztcbiAgICBpZiAodGhpcy5raW5kICYmIHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIGNvbnN0IGRUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImRcIilbMF07XG4gICAgICBpZiAoIWRUYWcpIHtcbiAgICAgICAgY29uc3QgdGl0bGUgPSB0aGlzLnRhZ1ZhbHVlKFwidGl0bGVcIik7XG4gICAgICAgIGNvbnN0IHJhbmRMZW5ndGggPSB0aXRsZSA/IDYgOiAxNjtcbiAgICAgICAgbGV0IHN0ciA9IFsuLi5BcnJheShyYW5kTGVuZ3RoKV0ubWFwKCgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpWzJdKS5qb2luKFwiXCIpO1xuICAgICAgICBpZiAodGl0bGUgJiYgdGl0bGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0ciA9IGAke3RpdGxlLnJlcGxhY2UoL1teYS16MC05XSsvZ2ksIFwiLVwiKS5yZXBsYWNlKC9eLXwtJC9nLCBcIlwiKX0tJHtzdHJ9YDtcbiAgICAgICAgfVxuICAgICAgICB0YWdzLnB1c2goW1wiZFwiLCBzdHJdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc2hvdWxkQWRkQ2xpZW50VGFnKSB7XG4gICAgICBjb25zdCBjbGllbnRUYWcgPSBbXCJjbGllbnRcIiwgdGhpcy5uZGs/LmNsaWVudE5hbWUgPz8gXCJcIl07XG4gICAgICBpZiAodGhpcy5uZGs/LmNsaWVudE5pcDg5KSBjbGllbnRUYWcucHVzaCh0aGlzLm5kaz8uY2xpZW50TmlwODkpO1xuICAgICAgdGFncy5wdXNoKGNsaWVudFRhZyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNob3VsZFN0cmlwQ2xpZW50VGFnKSB7XG4gICAgICB0YWdzID0gdGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcImNsaWVudFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29udGVudDogY29udGVudCB8fCBcIlwiLCB0YWdzIH07XG4gIH1cbiAgZ2V0IHNob3VsZEFkZENsaWVudFRhZygpIHtcbiAgICBpZiAoIXRoaXMubmRrPy5jbGllbnROYW1lICYmICF0aGlzLm5kaz8uY2xpZW50TmlwODkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoc2tpcENsaWVudFRhZ09uS2luZHMuaGFzKHRoaXMua2luZCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy5pc0VwaGVtZXJhbCgpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuaXNSZXBsYWNlYWJsZSgpICYmICF0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuaXNEdm0oKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aGlzLmhhc1RhZyhcImNsaWVudFwiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCBzaG91bGRTdHJpcENsaWVudFRhZygpIHtcbiAgICByZXR1cm4gc2tpcENsaWVudFRhZ09uS2luZHMuaGFzKHRoaXMua2luZCk7XG4gIH1cbiAgbXV0ZWQoKSB7XG4gICAgY29uc3QgYXV0aG9yTXV0ZWRFbnRyeSA9IHRoaXMubmRrPy5tdXRlZElkcy5nZXQodGhpcy5wdWJrZXkpO1xuICAgIGlmIChhdXRob3JNdXRlZEVudHJ5ICYmIGF1dGhvck11dGVkRW50cnkgPT09IFwicFwiKSByZXR1cm4gXCJhdXRob3JcIjtcbiAgICBjb25zdCBldmVudFRhZ1JlZmVyZW5jZSA9IHRoaXMudGFnUmVmZXJlbmNlKCk7XG4gICAgY29uc3QgZXZlbnRNdXRlZEVudHJ5ID0gdGhpcy5uZGs/Lm11dGVkSWRzLmdldChldmVudFRhZ1JlZmVyZW5jZVsxXSk7XG4gICAgaWYgKGV2ZW50TXV0ZWRFbnRyeSAmJiBldmVudE11dGVkRW50cnkgPT09IGV2ZW50VGFnUmVmZXJlbmNlWzBdKSByZXR1cm4gXCJldmVudFwiO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBcImRcIiB0YWcgb2YgYSBwYXJhbWV0ZXJpemVkIHJlcGxhY2VhYmxlIGV2ZW50IG9yIHRocm93cyBhbiBlcnJvciBpZiB0aGUgZXZlbnQgaXNuJ3RcbiAgICogYSBwYXJhbWV0ZXJpemVkIHJlcGxhY2VhYmxlIGV2ZW50LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgXCJkXCIgdGFnIG9mIHRoZSBldmVudC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBkVGFnYCBpbnN0ZWFkLlxuICAgKi9cbiAgcmVwbGFjZWFibGVEVGFnKCkge1xuICAgIGlmICh0aGlzLmtpbmQgJiYgdGhpcy5raW5kID49IDNlNCAmJiB0aGlzLmtpbmQgPD0gNGU0KSB7XG4gICAgICBjb25zdCBkVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJkXCIpWzBdO1xuICAgICAgY29uc3QgZFRhZ0lkID0gZFRhZyA/IGRUYWdbMV0gOiBcIlwiO1xuICAgICAgcmV0dXJuIGRUYWdJZDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgaXMgbm90IGEgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZSBldmVudFwiKTtcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgYSBkZWR1cGxpY2F0aW9uIGtleSBmb3IgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBGb3Iga2luZHMgMCwgMywgMTBrLTIwayB0aGlzIHdpbGwgYmUgdGhlIGV2ZW50IDxraW5kPjo8cHVia2V5PlxuICAgKiBGb3Iga2luZHMgMzBrLTQwayB0aGlzIHdpbGwgYmUgdGhlIGV2ZW50IDxraW5kPjo8cHVia2V5Pjo8ZC10YWc+XG4gICAqIEZvciBhbGwgb3RoZXIga2luZHMgdGhpcyB3aWxsIGJlIHRoZSBldmVudCBpZFxuICAgKi9cbiAgZGVkdXBsaWNhdGlvbktleSgpIHtcbiAgICBpZiAodGhpcy5raW5kID09PSAwIHx8IHRoaXMua2luZCA9PT0gMyB8fCB0aGlzLmtpbmQgJiYgdGhpcy5raW5kID49IDFlNCAmJiB0aGlzLmtpbmQgPCAyZTQpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLmtpbmR9OiR7dGhpcy5wdWJrZXl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGFnSWQoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaWQgb2YgdGhlIGV2ZW50IG9yLCBpZiBpdCdzIGEgcGFyYW1ldGVyaXplZCBldmVudCwgdGhlIGdlbmVyYXRlZCBpZCBvZiB0aGUgZXZlbnQgdXNpbmcgXCJkXCIgdGFnLCBwdWJrZXksIGFuZCBraW5kLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgaWRcbiAgICovXG4gIHRhZ0lkKCkge1xuICAgIGlmICh0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWdBZGRyZXNzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlkO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RhYmxlIHJlZmVyZW5jZSB2YWx1ZSBmb3IgYSByZXBsYWNlYWJsZSBldmVudC5cbiAgICpcbiAgICogUGFyYW0gcmVwbGFjZWFibGUgZXZlbnRzIGFyZSByZXR1cm5lZCBpbiB0aGUgZXhwZWN0ZWQgZm9ybWF0IG9mIGA8a2luZD46PHB1YmtleT46PGQtdGFnPmAuXG4gICAqIEtpbmQtcmVwbGFjZWFibGUgZXZlbnRzIGFyZSByZXR1cm5lZCBpbiB0aGUgZm9ybWF0IG9mIGA8a2luZD46PHB1YmtleT46YC5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gQSBzdGFibGUgcmVmZXJlbmNlIHZhbHVlIGZvciByZXBsYWNlYWJsZSBldmVudHNcbiAgICovXG4gIHRhZ0FkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIGNvbnN0IGRUYWdJZCA9IHRoaXMuZFRhZyA/PyBcIlwiO1xuICAgICAgcmV0dXJuIGAke3RoaXMua2luZH06JHt0aGlzLnB1YmtleX06JHtkVGFnSWR9YDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNSZXBsYWNlYWJsZSgpKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5raW5kfToke3RoaXMucHVia2V5fTpgO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBpcyBub3QgYSByZXBsYWNlYWJsZSBldmVudFwiKTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgdHlwZSBvZiB0YWcgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyBldmVudCBmcm9tIGFub3RoZXIgZXZlbnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0YWcgdHlwZVxuICAgKiBAZXhhbXBsZVxuICAgKiBldmVudCA9IG5ldyBOREtFdmVudChuZGssIHsga2luZDogMzAwMDAsIHB1YmtleTogJ3B1YmtleScsIHRhZ3M6IFsgW1wiZFwiLCBcImQtY29kZVwiXSBdIH0pO1xuICAgKiBldmVudC50YWdUeXBlKCk7IC8vIFwiYVwiXG4gICAqL1xuICB0YWdUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpID8gXCJhXCIgOiBcImVcIjtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB0YWcgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyBldmVudCBmcm9tIGFub3RoZXIgZXZlbnQuXG4gICAqXG4gICAqIENvbnNpZGVyIHVzaW5nIHJlZmVyZW5jZVRhZ3MoKSBpbnN0ZWFkICh1bmxlc3MgeW91IGhhdmUgYSBnb29kIHJlYXNvbiB0byB1c2UgdGhpcylcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAzMDAwMCwgcHVia2V5OiAncHVia2V5JywgdGFnczogWyBbXCJkXCIsIFwiZC1jb2RlXCJdIF0gfSk7XG4gICAqICAgICBldmVudC50YWdSZWZlcmVuY2UoKTsgLy8gW1wiYVwiLCBcIjMwMDAwOnB1YmtleTpkLWNvZGVcIl1cbiAgICpcbiAgICogICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAxLCBwdWJrZXk6ICdwdWJrZXknLCBpZDogXCJldmVudGlkXCIgfSk7XG4gICAqICAgICBldmVudC50YWdSZWZlcmVuY2UoKTsgLy8gW1wiZVwiLCBcImV2ZW50aWRcIl1cbiAgICogQHJldHVybnMge05ES1RhZ30gVGhlIE5ES1RhZyBvYmplY3QgcmVmZXJlbmNpbmcgdGhpcyBldmVudFxuICAgKi9cbiAgdGFnUmVmZXJlbmNlKG1hcmtlcikge1xuICAgIGxldCB0YWc7XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHRhZyA9IFtcImFcIiwgdGhpcy50YWdBZGRyZXNzKCldO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWcgPSBbXCJlXCIsIHRoaXMudGFnSWQoKV07XG4gICAgfVxuICAgIGlmICh0aGlzLnJlbGF5KSB7XG4gICAgICB0YWcucHVzaCh0aGlzLnJlbGF5LnVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZy5wdXNoKFwiXCIpO1xuICAgIH1cbiAgICB0YWcucHVzaChtYXJrZXIgPz8gXCJcIik7XG4gICAgaWYgKCF0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSB7XG4gICAgICB0YWcucHVzaCh0aGlzLnB1YmtleSk7XG4gICAgfVxuICAgIHJldHVybiB0YWc7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdGFncyB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGlzIGV2ZW50IGZyb20gYW5vdGhlciBldmVudFxuICAgKiBAcGFyYW0gbWFya2VyIFRoZSBtYXJrZXIgdG8gdXNlIGluIHRoZSB0YWdcbiAgICogQHBhcmFtIHNraXBBdXRob3JUYWcgV2hldGhlciB0byBleHBsaWNpdGx5IHNraXAgYWRkaW5nIHRoZSBhdXRob3IgdGFnIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0gZm9yY2VUYWcgRm9yY2UgYSBzcGVjaWZpYyB0YWcgdG8gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IFwiZVwiIG9yIFwiYVwiIHRhZ1xuICAgKiBAZXhhbXBsZVxuICAgKiAgICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDMwMDAwLCBwdWJrZXk6ICdwdWJrZXknLCB0YWdzOiBbIFtcImRcIiwgXCJkLWNvZGVcIl0gXSB9KTtcbiAgICogICAgIGV2ZW50LnJlZmVyZW5jZVRhZ3MoKTsgLy8gW1tcImFcIiwgXCIzMDAwMDpwdWJrZXk6ZC1jb2RlXCJdLCBbXCJlXCIsIFwicGFyZW50LWlkXCJdXVxuICAgKlxuICAgKiAgICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDEsIHB1YmtleTogJ3B1YmtleScsIGlkOiBcImV2ZW50aWRcIiB9KTtcbiAgICogICAgIGV2ZW50LnJlZmVyZW5jZVRhZ3MoKTsgLy8gW1tcImVcIiwgXCJwYXJlbnQtaWRcIl1dXG4gICAqIEByZXR1cm5zIHtOREtUYWd9IFRoZSBOREtUYWcgb2JqZWN0IHJlZmVyZW5jaW5nIHRoaXMgZXZlbnRcbiAgICovXG4gIHJlZmVyZW5jZVRhZ3MobWFya2VyLCBza2lwQXV0aG9yVGFnLCBmb3JjZVRhZykge1xuICAgIGxldCB0YWdzID0gW107XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHRhZ3MgPSBbXG4gICAgICAgIFtmb3JjZVRhZyA/PyBcImFcIiwgdGhpcy50YWdBZGRyZXNzKCldLFxuICAgICAgICBbZm9yY2VUYWcgPz8gXCJlXCIsIHRoaXMuaWRdXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWdzID0gW1tmb3JjZVRhZyA/PyBcImVcIiwgdGhpcy5pZF1dO1xuICAgIH1cbiAgICB0YWdzID0gdGFncy5tYXAoKHRhZykgPT4ge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgfHwgbWFya2VyKSB7XG4gICAgICAgIHRhZy5wdXNoKHRoaXMucmVsYXk/LnVybCA/PyBcIlwiKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZWxheT8udXJsKSB7XG4gICAgICAgIHRhZy5wdXNoKHRoaXMucmVsYXk/LnVybCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH0pO1xuICAgIHRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIikge1xuICAgICAgICB0YWcucHVzaChtYXJrZXIgPz8gXCJcIik7XG4gICAgICAgIHRhZy5wdXNoKHRoaXMucHVia2V5KTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyKSB7XG4gICAgICAgIHRhZy5wdXNoKG1hcmtlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFncyA9IFsuLi50YWdzLCAuLi50aGlzLmdldE1hdGNoaW5nVGFncyhcImhcIildO1xuICAgIGlmICghc2tpcEF1dGhvclRhZykgdGFncy5wdXNoKC4uLnRoaXMuYXV0aG9yLnJlZmVyZW5jZVRhZ3MoKSk7XG4gICAgcmV0dXJuIHRhZ3M7XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIHRoZSBmaWx0ZXIgdGhhdCB3aWxsIHJldHVybiBtYXRjaGluZyBldmVudHMgZm9yIHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAzMDAwMCwgcHVia2V5OiAncHVia2V5JywgdGFnczogWyBbXCJkXCIsIFwiZC1jb2RlXCJdIF0gfSk7XG4gICAqICAgIGV2ZW50LmZpbHRlcigpOyAvLyB7IFwiI2FcIjogW1wiMzAwMDA6cHVia2V5OmQtY29kZVwiXSB9XG4gICAqIEBleGFtcGxlXG4gICAqICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAxLCBwdWJrZXk6ICdwdWJrZXknLCBpZDogXCJldmVudGlkXCIgfSk7XG4gICAqICAgIGV2ZW50LmZpbHRlcigpOyAvLyB7IFwiI2VcIjogW1wiZXZlbnRpZFwiXSB9XG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBmaWx0ZXIgdGhhdCB3aWxsIHJldHVybiBtYXRjaGluZyBldmVudHMgZm9yIHRoaXMgZXZlbnRcbiAgICovXG4gIGZpbHRlcigpIHtcbiAgICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgICAgcmV0dXJuIHsgXCIjYVwiOiBbdGhpcy50YWdJZCgpXSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBcIiNlXCI6IFt0aGlzLnRhZ0lkKCldIH07XG4gIH1cbiAgbmlwMjJGaWx0ZXIoKSB7XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHJldHVybiB7IFwiI0FcIjogW3RoaXMudGFnSWQoKV0gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgXCIjRVwiOiBbdGhpcy50YWdJZCgpXSB9O1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBkZWxldGlvbiBldmVudCBvZiB0aGUgY3VycmVudCBldmVudFxuICAgKlxuICAgKiBAcGFyYW0gcmVhc29uIFRoZSByZWFzb24gZm9yIHRoZSBkZWxldGlvblxuICAgKiBAcGFyYW0gcHVibGlzaCBXaGV0aGVyIHRvIHB1Ymxpc2ggdGhlIGRlbGV0aW9uIGV2ZW50IGF1dG9tYXRpY2FsbHlcbiAgICogQHJldHVybnMgVGhlIGRlbGV0aW9uIGV2ZW50XG4gICAqL1xuICBhc3luYyBkZWxldGUocmVhc29uLCBwdWJsaXNoID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBjb25zdCBlID0gbmV3IF9OREtFdmVudCh0aGlzLm5kaywge1xuICAgICAga2luZDogNSAvKiBFdmVudERlbGV0aW9uICovLFxuICAgICAgY29udGVudDogcmVhc29uIHx8IFwiXCJcbiAgICB9KTtcbiAgICBlLnRhZyh0aGlzLCB2b2lkIDAsIHRydWUpO1xuICAgIGUudGFncy5wdXNoKFtcImtcIiwgdGhpcy5raW5kPy50b1N0cmluZygpXSk7XG4gICAgaWYgKHB1Ymxpc2gpIHtcbiAgICAgIHRoaXMuZW1pdChcImRlbGV0ZWRcIik7XG4gICAgICBhd2FpdCBlLnB1Ymxpc2goKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgLyoqXG4gICAqIEVzdGFibGlzaGVzIHdoZXRoZXIgdGhpcyBpcyBhIE5JUC03MC1wcm90ZWN0ZWRlIGV2ZW50LlxuICAgKiBAQHNhdGlzZmllcyBOSVAtNzBcbiAgICovXG4gIHNldCBpc1Byb3RlY3RlZCh2YWwpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcIi1cIik7XG4gICAgaWYgKHZhbCkgdGhpcy50YWdzLnB1c2goW1wiLVwiXSk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBpcyBhIE5JUC03MC1wcm90ZWN0ZWQgZXZlbnQuXG4gICAqIEBAc2F0aXNmaWVzIE5JUC03MFxuICAgKi9cbiAgZ2V0IGlzUHJvdGVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc1RhZyhcIi1cIik7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGFuIGV2ZW50IHRhZ2dlZCB3aXRoIHRoZSBnaXZlbiB0YWcgZm9sbG93aW5nIHJlbGF5IGhpbnRzIGlmIHByb3ZpZGVkLlxuICAgKiBAcGFyYW0gdGFnIFRoZSB0YWcgdG8gc2VhcmNoIGZvclxuICAgKiBAcGFyYW0gbWFya2VyIFRoZSBtYXJrZXIgdG8gdXNlIGluIHRoZSB0YWcgKGUuZy4gXCJyb290XCIpXG4gICAqIEByZXR1cm5zIFRoZSBmZXRjaGVkIGV2ZW50IG9yIG51bGwgaWYgbm8gZXZlbnQgd2FzIGZvdW5kLCB1bmRlZmluZWQgaWYgbm8gbWF0Y2hpbmcgdGFnIHdhcyBmb3VuZCBpbiB0aGUgZXZlbnRcbiAgICogKiBAZXhhbXBsZVxuICAgKiBjb25zdCByZXBseUV2ZW50ID0gYXdhaXQgbmRrLmZldGNoRXZlbnQoXCJuZXZlbnQxcXFzOHg4dm55Y3loYTczZ3J2MzgwZ212bHVyeTR3dG14MG5yOWE1ZHMyZG5ncXdndTg3d242Z3B6ZW1oeHVlNjl1aGh5ZXR2djl1anV1cmpkOWtrem1wd2RlamhncTNxbDJ2eWg0N21rMnAwcWxza3U3aGcwdm4yOWZhZWh5OWh5MzR5Z2FjbHBuNjZ1a3FwM2FmcXo0Y3dqZFwiKVxuICAgKiBjb25zdCBvcmlnaW5hbEV2ZW50ID0gYXdhaXQgcmVwbHlFdmVudC5mZXRjaFRhZ2dlZEV2ZW50KFwiZVwiLCBcInJlcGx5XCIpO1xuICAgKiBjb25zb2xlLmxvZyhyZXBseUV2ZW50LmVuY29kZSgpICsgXCIgaXMgYSByZXBseSB0byBldmVudCBcIiArIG9yaWdpbmFsRXZlbnQ/LmVuY29kZSgpKTtcbiAgICovXG4gIGZldGNoVGFnZ2VkRXZlbnQgPSBmZXRjaFRhZ2dlZEV2ZW50LmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgcm9vdCBldmVudCBvZiB0aGUgY3VycmVudCBldmVudC5cbiAgICogQHJldHVybnMgVGhlIGZldGNoZWQgcm9vdCBldmVudCBvciBudWxsIGlmIG5vIGV2ZW50IHdhcyBmb3VuZFxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByZXBseUV2ZW50ID0gYXdhaXQgbmRrLmZldGNoRXZlbnQoXCJuZXZlbnQxcXFzOHg4dm55Y3loYTczZ3J2MzgwZ212bHVyeTR3dG14MG5yOWE1ZHMyZG5ncXdndTg3d242Z3B6ZW1oeHVlNjl1aGh5ZXR2djl1anV1cmpkOWtrem1wd2RlamhncTNxbDJ2eWg0N21rMnAwcWxza3U3aGcwdm4yOWZhZWh5OWh5MzR5Z2FjbHBuNjZ1a3FwM2FmcXo0Y3dqZFwiKVxuICAgKiBjb25zdCByb290RXZlbnQgPSBhd2FpdCByZXBseUV2ZW50LmZldGNoUm9vdEV2ZW50KCk7XG4gICAqIGNvbnNvbGUubG9nKHJlcGx5RXZlbnQuZW5jb2RlKCkgKyBcIiBpcyBhIHJlcGx5IGluIHRoZSB0aHJlYWQgXCIgKyByb290RXZlbnQ/LmVuY29kZSgpKTtcbiAgICovXG4gIGZldGNoUm9vdEV2ZW50ID0gZmV0Y2hSb290RXZlbnQuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIEZldGNoIHRoZSBldmVudCB0aGUgY3VycmVudCBldmVudCBpcyByZXBseWluZyB0by5cbiAgICogQHJldHVybnMgVGhlIGZldGNoZWQgcmVwbHkgZXZlbnQgb3IgbnVsbCBpZiBubyBldmVudCB3YXMgZm91bmRcbiAgICovXG4gIGZldGNoUmVwbHlFdmVudCA9IGZldGNoUmVwbHlFdmVudC5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogTklQLTE4IHJlcG9zdGluZyBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHB1Ymxpc2ggV2hldGhlciB0byBwdWJsaXNoIHRoZSByZXBvc3RlZCBldmVudCBhdXRvbWF0aWNhbGx5IEBkZWZhdWx0IHRydWVcbiAgICogQHBhcmFtIHNpZ25lciBUaGUgc2lnbmVyIHRvIHVzZSBmb3Igc2lnbmluZyB0aGUgcmVwb3N0ZWQgZXZlbnRcbiAgICogQHJldHVybnMgVGhlIHJlcG9zdGVkIGV2ZW50XG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgcmVwb3N0ID0gcmVwb3N0LmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBSZWFjdCB0byBhbiBleGlzdGluZyBldmVudFxuICAgKlxuICAgKiBAcGFyYW0gY29udGVudCBUaGUgY29udGVudCBvZiB0aGUgcmVhY3Rpb25cbiAgICovXG4gIGFzeW5jIHJlYWN0KGNvbnRlbnQsIHB1Ymxpc2ggPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGNvbnN0IGUgPSBuZXcgX05ES0V2ZW50KHRoaXMubmRrLCB7XG4gICAgICBraW5kOiA3IC8qIFJlYWN0aW9uICovLFxuICAgICAgY29udGVudFxuICAgIH0pO1xuICAgIGUudGFnKHRoaXMpO1xuICAgIGlmICh0aGlzLmtpbmQgIT09IDEgLyogVGV4dCAqLykge1xuICAgICAgZS50YWdzLnB1c2goW1wia1wiLCBgJHt0aGlzLmtpbmR9YF0pO1xuICAgIH1cbiAgICBpZiAocHVibGlzaCkgYXdhaXQgZS5wdWJsaXNoKCk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBldmVudCBpcyB2YWxpZCBwZXIgdW5kZXJseWluZyBOSVBzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzZXMgdGhhdCBpbXBsZW1lbnQgc3BlY2lmaWMgTklQc1xuICAgKiB0byBhbGxvdyB0aGUgZW5mb3JjZW1lbnQgb2YgTklQLXNwZWNpZmljIHZhbGlkYXRpb24gcnVsZXMuXG4gICAqXG4gICAqIE90aGVyd2lzZSwgaXQgd2lsbCBvbmx5IGNoZWNrIGZvciBiYXNpYyBldmVudCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGUoKTtcbiAgfVxuICBnZXQgaW5zcGVjdCgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5yYXdFdmVudCgpLCBudWxsLCA0KTtcbiAgfVxuICAvKipcbiAgICogRHVtcCB0aGUgZXZlbnQgdG8gY29uc29sZSBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICAgKiBQcmludHMgYSBKU09OIHN0cmluZ2lmaWVkIHZlcnNpb24gb2YgcmF3RXZlbnQoKSB3aXRoIGluZGVudGF0aW9uXG4gICAqIGFuZCBhbHNvIGxpc3RzIGFsbCByZWxheSBVUkxzIGZvciBvblJlbGF5cy5cbiAgICovXG4gIGR1bXAoKSB7XG4gICAgY29uc29sZS5kZWJ1ZyhKU09OLnN0cmluZ2lmeSh0aGlzLnJhd0V2ZW50KCksIG51bGwsIDQpKTtcbiAgICBjb25zb2xlLmRlYnVnKFwiRXZlbnQgb24gcmVsYXlzOlwiLCB0aGlzLm9uUmVsYXlzLm1hcCgocmVsYXkpID0+IHJlbGF5LnVybCkuam9pbihcIiwgXCIpKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIHJlcGx5IGV2ZW50IGZvciB0aGUgY3VycmVudCBldmVudC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHVzZSBOSVAtMjIgd2hlbiBhcHByb3ByaWF0ZSAoaS5lLiByZXBsaWVzIHRvIG5vbi1raW5kOjEgZXZlbnRzKS5cbiAgICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBoYXZlIHNpZGUtZWZmZWN0czsgaXQgd2lsbCBqdXN0IHJldHVybiBhbiBldmVudCB3aXRoIHRoZSBhcHByb3ByaWF0ZSB0YWdzXG4gICAqIHRvIGdlbmVyYXRlIHRoZSByZXBseSBldmVudDsgdGhlIGNhbGxlciBpcyByZXNwb25zaWJsZSBmb3IgcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBmb3JjZU5pcDIyIC0gT3B0aW9uYWwgZmxhZyB0byBmb3JjZSBOSVAtMjIgc3R5bGUgcmVwbGllcyAoa2luZCAxMTExKSByZWdhcmRsZXNzIG9mIHRoZSBvcmlnaW5hbCBldmVudCdzIGtpbmRcbiAgICovXG4gIHJlcGx5KGZvcmNlTmlwMjIpIHtcbiAgICBjb25zdCByZXBseSA9IG5ldyBfTkRLRXZlbnQodGhpcy5uZGspO1xuICAgIGlmICh0aGlzLmtpbmQgPT09IDEgJiYgIWZvcmNlTmlwMjIpIHtcbiAgICAgIHJlcGx5LmtpbmQgPSAxO1xuICAgICAgY29uc3Qgb3BIYXNFVGFnID0gdGhpcy5oYXNUYWcoXCJlXCIpO1xuICAgICAgaWYgKG9wSGFzRVRhZykge1xuICAgICAgICByZXBseS50YWdzID0gW1xuICAgICAgICAgIC4uLnJlcGx5LnRhZ3MsXG4gICAgICAgICAgLi4udGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJlXCIpLFxuICAgICAgICAgIC4uLnRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKSxcbiAgICAgICAgICAuLi50aGlzLmdldE1hdGNoaW5nVGFncyhcImFcIiksXG4gICAgICAgICAgLi4udGhpcy5yZWZlcmVuY2VUYWdzKFwicmVwbHlcIilcbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcGx5LnRhZyh0aGlzLCBcInJvb3RcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcGx5LmtpbmQgPSAxMTExIC8qIEdlbmVyaWNSZXBseSAqLztcbiAgICAgIGNvbnN0IGNhcnJ5T3ZlclRhZ3MgPSBbXCJBXCIsIFwiRVwiLCBcIklcIiwgXCJQXCJdO1xuICAgICAgY29uc3Qgcm9vdFRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IGNhcnJ5T3ZlclRhZ3MuaW5jbHVkZXModGFnWzBdKSk7XG4gICAgICBpZiAocm9vdFRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCByb290S2luZCA9IHRoaXMudGFnVmFsdWUoXCJLXCIpO1xuICAgICAgICByZXBseS50YWdzLnB1c2goLi4ucm9vdFRhZ3MpO1xuICAgICAgICBpZiAocm9vdEtpbmQpIHJlcGx5LnRhZ3MucHVzaChbXCJLXCIsIHJvb3RLaW5kXSk7XG4gICAgICAgIGNvbnN0IFt0eXBlLCBpZCwgXywgLi4uZXh0cmFdID0gdGhpcy50YWdSZWZlcmVuY2UoKTtcbiAgICAgICAgY29uc3QgdGFnID0gW3R5cGUsIGlkLCAuLi5leHRyYV07XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaCh0YWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgW3R5cGUsIGlkLCBfLCByZWxheUhpbnRdID0gdGhpcy50YWdSZWZlcmVuY2UoKTtcbiAgICAgICAgY29uc3QgdGFnID0gW3R5cGUsIGlkLCByZWxheUhpbnQgPz8gXCJcIl07XG4gICAgICAgIGlmICh0eXBlID09PSBcImVcIikgdGFnLnB1c2godGhpcy5wdWJrZXkpO1xuICAgICAgICByZXBseS50YWdzLnB1c2godGFnKTtcbiAgICAgICAgY29uc3QgdXBwZXJjYXNlVGFnID0gWy4uLnRhZ107XG4gICAgICAgIHVwcGVyY2FzZVRhZ1swXSA9IHVwcGVyY2FzZVRhZ1swXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICByZXBseS50YWdzLnB1c2godXBwZXJjYXNlVGFnKTtcbiAgICAgICAgcmVwbHkudGFncy5wdXNoKFtcIktcIiwgdGhpcy5raW5kPy50b1N0cmluZygpXSk7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaChbXCJQXCIsIHRoaXMucHVia2V5XSk7XG4gICAgICB9XG4gICAgICByZXBseS50YWdzLnB1c2goW1wia1wiLCB0aGlzLmtpbmQ/LnRvU3RyaW5nKCldKTtcbiAgICAgIHJlcGx5LnRhZ3MucHVzaCguLi50aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIikpO1xuICAgICAgcmVwbHkudGFncy5wdXNoKFtcInBcIiwgdGhpcy5wdWJrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcGx5O1xuICB9XG59O1xudmFyIHVudHJhY2tlZFVucHVibGlzaGVkRXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAyNDEzMyAvKiBOb3N0ckNvbm5lY3QgKi8sXG4gIDEzMTk0IC8qIE5vc3RyV2FsZXRDb25uZWN0SW5mbyAqLyxcbiAgMjMxOTQgLyogTm9zdHJXYWxsZXRDb25uZWN0UmVxICovLFxuICAyMzE5NSAvKiBOb3N0cldhbGxldENvbm5lY3RSZXMgKi9cbl0pO1xuZnVuY3Rpb24gc2hvdWxkVHJhY2tVbnB1Ymxpc2hlZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhdW50cmFja2VkVW5wdWJsaXNoZWRFdmVudHMuaGFzKGV2ZW50LmtpbmQpO1xufVxuXG4vLyBzcmMvcmVsYXkvcG9vbC9pbmRleC50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjMgfSBmcm9tIFwidHNlZXBcIjtcbnZhciBOREtQb29sID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXIzIHtcbiAgLy8gVE9ETzogVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgYW4gTFJVIGNhY2hlXG4gIF9yZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgYXV0b0Nvbm5lY3RSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBwb29sQmxhY2tsaXN0UmVsYXlVcmxzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZGVidWc7XG4gIHRlbXBvcmFyeVJlbGF5VGltZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZmxhcHBpbmdSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAvLyBBIG1hcCB0byBzdG9yZSB0aW1lb3V0cyBmb3IgZWFjaCBmbGFwcGluZyByZWxheS5cbiAgYmFja29mZlRpbWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbmRrO1xuICBnZXQgYmxhY2tsaXN0UmVsYXlVcmxzKCkge1xuICAgIGNvbnN0IHZhbCA9IG5ldyBTZXQodGhpcy5uZGsuYmxhY2tsaXN0UmVsYXlVcmxzKTtcbiAgICB0aGlzLnBvb2xCbGFja2xpc3RSZWxheVVybHMuZm9yRWFjaCgodXJsKSA9PiB2YWwuYWRkKHVybCkpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSByZWxheVVybHMgLSBUaGUgVVJMcyBvZiB0aGUgcmVsYXlzIHRvIGNvbm5lY3QgdG8uXG4gICAqIEBwYXJhbSBibGFja2xpc3RlZFJlbGF5VXJscyAtIFVSTHMgdG8gYmxhY2tsaXN0IGZvciB0aGlzIHBvb2wgSU4gQURESVRJT04gdG8gdGhvc2UgYmxhY2tsaXN0ZWQgYXQgdGhlIG5kay1sZXZlbFxuICAgKiBAcGFyYW0gbmRrIC0gVGhlIE5ESyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIGZvciB0aGUgcG9vbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbGF5VXJscywgYmxhY2tsaXN0ZWRSZWxheVVybHMsIG5kaywge1xuICAgIGRlYnVnOiBkZWJ1ZzksXG4gICAgbmFtZVxuICB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGVidWcgPSBkZWJ1ZzkgPz8gbmRrLmRlYnVnLmV4dGVuZChcInBvb2xcIik7XG4gICAgaWYgKG5hbWUpIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMucmVsYXlVcmxzID0gcmVsYXlVcmxzO1xuICAgIHRoaXMucG9vbEJsYWNrbGlzdFJlbGF5VXJscyA9IG5ldyBTZXQoYmxhY2tsaXN0ZWRSZWxheVVybHMpO1xuICAgIHRoaXMubmRrLnBvb2xzLnB1c2godGhpcyk7XG4gIH1cbiAgZ2V0IHJlbGF5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVsYXlzO1xuICB9XG4gIHNldCByZWxheVVybHModXJscykge1xuICAgIHRoaXMuX3JlbGF5cy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2YgdXJscykge1xuICAgICAgY29uc3QgcmVsYXkgPSBuZXcgTkRLUmVsYXkocmVsYXlVcmwsIHZvaWQgMCwgdGhpcy5uZGspO1xuICAgICAgcmVsYXkuY29ubmVjdGl2aXR5Lm5ldERlYnVnID0gdGhpcy5uZGsubmV0RGVidWc7XG4gICAgICB0aGlzLmFkZFJlbGF5KHJlbGF5KTtcbiAgICB9XG4gIH1cbiAgX25hbWUgPSBcInVubmFtZWRcIjtcbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH1cbiAgc2V0IG5hbWUobmFtZSkge1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHRoaXMuZGVidWcgPSB0aGlzLmRlYnVnLmV4dGVuZChuYW1lKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHJlbGF5IHRvIHRoZSBwb29sLCBhbmQgc2V0cyBhIHRpbWVyIHRvIHJlbW92ZSBpdCBpZiBpdCBpcyBub3QgdXNlZCB3aXRoaW4gdGhlIHNwZWNpZmllZCB0aW1lLlxuICAgKiBAcGFyYW0gcmVsYXkgLSBUaGUgcmVsYXkgdG8gYWRkIHRvIHRoZSBwb29sLlxuICAgKiBAcGFyYW0gcmVtb3ZlSWZVbnVzZWRBZnRlciAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSByZW1vdmluZyB0aGUgcmVsYXkgZnJvbSB0aGUgcG9vbCBhZnRlciBpdCBpcyBubyBsb25nZXIgdXNlZC5cbiAgICovXG4gIHVzZVRlbXBvcmFyeVJlbGF5KHJlbGF5LCByZW1vdmVJZlVudXNlZEFmdGVyID0gM2U0LCBmaWx0ZXJzKSB7XG4gICAgY29uc3QgcmVsYXlBbHJlYWR5SW5Qb29sID0gdGhpcy5yZWxheXMuaGFzKHJlbGF5LnVybCk7XG4gICAgaWYgKCFyZWxheUFscmVhZHlJblBvb2wpIHtcbiAgICAgIHRoaXMuYWRkUmVsYXkocmVsYXkpO1xuICAgICAgdGhpcy5kZWJ1ZyhcIkFkZGluZyB0ZW1wb3JhcnkgcmVsYXkgJXMgZm9yIGZpbHRlcnMgJW9cIiwgcmVsYXkudXJsLCBmaWx0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdUaW1lciA9IHRoaXMudGVtcG9yYXJ5UmVsYXlUaW1lcnMuZ2V0KHJlbGF5LnVybCk7XG4gICAgaWYgKGV4aXN0aW5nVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChleGlzdGluZ1RpbWVyKTtcbiAgICB9XG4gICAgaWYgKCFyZWxheUFscmVhZHlJblBvb2wgfHwgZXhpc3RpbmdUaW1lcikge1xuICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMubmRrLmV4cGxpY2l0UmVsYXlVcmxzPy5pbmNsdWRlcyhyZWxheS51cmwpKSByZXR1cm47XG4gICAgICAgIHRoaXMucmVtb3ZlUmVsYXkocmVsYXkudXJsKTtcbiAgICAgIH0sIHJlbW92ZUlmVW51c2VkQWZ0ZXIpO1xuICAgICAgdGhpcy50ZW1wb3JhcnlSZWxheVRpbWVycy5zZXQocmVsYXkudXJsLCB0aW1lcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcmVsYXkgdG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEBwYXJhbSByZWxheSAtIFRoZSByZWxheSB0byBhZGQgdG8gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSBjb25uZWN0IC0gV2hldGhlciBvciBub3QgdG8gY29ubmVjdCB0byB0aGUgcmVsYXkuXG4gICAqL1xuICBhZGRSZWxheShyZWxheSwgY29ubmVjdCA9IHRydWUpIHtcbiAgICBjb25zdCBpc0FscmVhZHlJblBvb2wgPSB0aGlzLnJlbGF5cy5oYXMocmVsYXkudXJsKTtcbiAgICBjb25zdCBpc0JsYWNrbGlzdGVkID0gdGhpcy5ibGFja2xpc3RSZWxheVVybHM/LmhhcyhyZWxheS51cmwpO1xuICAgIGNvbnN0IGlzQ3VzdG9tUmVsYXlVcmwgPSByZWxheS51cmwuaW5jbHVkZXMoXCIvbnB1YjFcIik7XG4gICAgbGV0IHJlY29ubmVjdCA9IHRydWU7XG4gICAgY29uc3QgcmVsYXlVcmwgPSByZWxheS51cmw7XG4gICAgaWYgKGlzQWxyZWFkeUluUG9vbCkgcmV0dXJuO1xuICAgIGlmIChpc0JsYWNrbGlzdGVkKSB7XG4gICAgICB0aGlzLmRlYnVnKGBSZWZ1c2luZyB0byBhZGQgcmVsYXkgJHtyZWxheVVybH06IGJsYWNrbGlzdGVkYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0N1c3RvbVJlbGF5VXJsKSB7XG4gICAgICB0aGlzLmRlYnVnKGBSZWZ1c2luZyB0byBhZGQgcmVsYXkgJHtyZWxheVVybH06IGlzIGEgZmlsdGVyIHJlbGF5YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXI/LmdldFJlbGF5U3RhdHVzKSB7XG4gICAgICBjb25zdCBpbmZvID0gdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmdldFJlbGF5U3RhdHVzKHJlbGF5VXJsKTtcbiAgICAgIGlmIChpbmZvPy5kb250Q29ubmVjdEJlZm9yZSkge1xuICAgICAgICBpZiAoaW5mby5kb250Q29ubmVjdEJlZm9yZSA+IERhdGUubm93KCkpIHtcbiAgICAgICAgICBjb25zdCBkZWxheSA9IGluZm8uZG9udENvbm5lY3RCZWZvcmUgLSBEYXRlLm5vdygpO1xuICAgICAgICAgIHRoaXMuZGVidWcoYFJlZnVzaW5nIHRvIGFkZCByZWxheSAke3JlbGF5VXJsfTogZGVsYXllZCBjb25uZWN0IGZvciAke2RlbGF5fW1zYCk7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZFJlbGF5KHJlbGF5LCBjb25uZWN0KTtcbiAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub3RpY2VIYW5kbGVyID0gKG5vdGljZSkgPT4gdGhpcy5lbWl0KFwibm90aWNlXCIsIHJlbGF5LCBub3RpY2UpO1xuICAgIGNvbnN0IGNvbm5lY3RIYW5kbGVyID0gKCkgPT4gdGhpcy5oYW5kbGVSZWxheUNvbm5lY3QocmVsYXlVcmwpO1xuICAgIGNvbnN0IHJlYWR5SGFuZGxlciA9ICgpID0+IHRoaXMuaGFuZGxlUmVsYXlSZWFkeShyZWxheSk7XG4gICAgY29uc3QgZGlzY29ubmVjdEhhbmRsZXIgPSAoKSA9PiB0aGlzLmVtaXQoXCJyZWxheTpkaXNjb25uZWN0XCIsIHJlbGF5KTtcbiAgICBjb25zdCBmbGFwcGluZ0hhbmRsZXIgPSAoKSA9PiB0aGlzLmhhbmRsZUZsYXBwaW5nKHJlbGF5KTtcbiAgICBjb25zdCBhdXRoSGFuZGxlciA9IChjaGFsbGVuZ2UpID0+IHRoaXMuZW1pdChcInJlbGF5OmF1dGhcIiwgcmVsYXksIGNoYWxsZW5nZSk7XG4gICAgY29uc3QgYXV0aGVkSGFuZGxlciA9ICgpID0+IHRoaXMuZW1pdChcInJlbGF5OmF1dGhlZFwiLCByZWxheSk7XG4gICAgcmVsYXkub2ZmKFwibm90aWNlXCIsIG5vdGljZUhhbmRsZXIpO1xuICAgIHJlbGF5Lm9mZihcImNvbm5lY3RcIiwgY29ubmVjdEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9mZihcInJlYWR5XCIsIHJlYWR5SGFuZGxlcik7XG4gICAgcmVsYXkub2ZmKFwiZGlzY29ubmVjdFwiLCBkaXNjb25uZWN0SGFuZGxlcik7XG4gICAgcmVsYXkub2ZmKFwiZmxhcHBpbmdcIiwgZmxhcHBpbmdIYW5kbGVyKTtcbiAgICByZWxheS5vZmYoXCJhdXRoXCIsIGF1dGhIYW5kbGVyKTtcbiAgICByZWxheS5vZmYoXCJhdXRoZWRcIiwgYXV0aGVkSGFuZGxlcik7XG4gICAgcmVsYXkub24oXCJub3RpY2VcIiwgbm90aWNlSGFuZGxlcik7XG4gICAgcmVsYXkub24oXCJjb25uZWN0XCIsIGNvbm5lY3RIYW5kbGVyKTtcbiAgICByZWxheS5vbihcInJlYWR5XCIsIHJlYWR5SGFuZGxlcik7XG4gICAgcmVsYXkub24oXCJkaXNjb25uZWN0XCIsIGRpc2Nvbm5lY3RIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImZsYXBwaW5nXCIsIGZsYXBwaW5nSGFuZGxlcik7XG4gICAgcmVsYXkub24oXCJhdXRoXCIsIGF1dGhIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImF1dGhlZFwiLCBhdXRoZWRIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImRlbGF5ZWQtY29ubmVjdFwiLCAoZGVsYXkpID0+IHtcbiAgICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXI/LnVwZGF0ZVJlbGF5U3RhdHVzKSB7XG4gICAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci51cGRhdGVSZWxheVN0YXR1cyhyZWxheS51cmwsIHtcbiAgICAgICAgICBkb250Q29ubmVjdEJlZm9yZTogRGF0ZS5ub3coKSArIGRlbGF5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX3JlbGF5cy5zZXQocmVsYXlVcmwsIHJlbGF5KTtcbiAgICBpZiAoY29ubmVjdCkgdGhpcy5hdXRvQ29ubmVjdFJlbGF5cy5hZGQocmVsYXlVcmwpO1xuICAgIGlmIChjb25uZWN0ICYmIHRoaXMuc3RhdHVzID09PSBcImFjdGl2ZVwiKSB7XG4gICAgICB0aGlzLmVtaXQoXCJyZWxheTpjb25uZWN0aW5nXCIsIHJlbGF5KTtcbiAgICAgIHJlbGF5LmNvbm5lY3Qodm9pZCAwLCByZWNvbm5lY3QpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHRoaXMuZGVidWcoYEZhaWxlZCB0byBjb25uZWN0IHRvIHJlbGF5ICR7cmVsYXlVcmx9YCwgZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSByZWxheSBmcm9tIHRoZSBwb29sLlxuICAgKiBAcGFyYW0gcmVsYXlVcmwgLSBUaGUgVVJMIG9mIHRoZSByZWxheSB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSByZWxheSB3YXMgcmVtb3ZlZCwgZmFsc2UgaWYgaXQgd2FzIG5vdCBmb3VuZC5cbiAgICovXG4gIHJlbW92ZVJlbGF5KHJlbGF5VXJsKSB7XG4gICAgY29uc3QgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQocmVsYXlVcmwpO1xuICAgIGlmIChyZWxheSkge1xuICAgICAgcmVsYXkuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5yZWxheXMuZGVsZXRlKHJlbGF5VXJsKTtcbiAgICAgIHRoaXMuYXV0b0Nvbm5lY3RSZWxheXMuZGVsZXRlKHJlbGF5VXJsKTtcbiAgICAgIHRoaXMuZW1pdChcInJlbGF5OmRpc2Nvbm5lY3RcIiwgcmVsYXkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nVGltZXIgPSB0aGlzLnRlbXBvcmFyeVJlbGF5VGltZXJzLmdldChyZWxheVVybCk7XG4gICAgaWYgKGV4aXN0aW5nVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChleGlzdGluZ1RpbWVyKTtcbiAgICAgIHRoaXMudGVtcG9yYXJ5UmVsYXlUaW1lcnMuZGVsZXRlKHJlbGF5VXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHJlbGF5IGlzIGFscmVhZHkgY29ubmVjdGVkIGluIHRoZSBwb29sLlxuICAgKi9cbiAgaXNSZWxheUNvbm5lY3RlZCh1cmwpIHtcbiAgICBjb25zdCBub3JtYWxpemVkVXJsID0gbm9ybWFsaXplUmVsYXlVcmwodXJsKTtcbiAgICBjb25zdCByZWxheSA9IHRoaXMucmVsYXlzLmdldChub3JtYWxpemVkVXJsKTtcbiAgICBpZiAoIXJlbGF5KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHJlbGF5LnN0YXR1cyA9PT0gNSAvKiBDT05ORUNURUQgKi87XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoZXMgYSByZWxheSBmcm9tIHRoZSBwb29sLCBvciBjcmVhdGVzIGEgbmV3IG9uZSBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogTmV3IHJlbGF5cyB3aWxsIGJlIGF0dGVtcHRlZCB0byBiZSBjb25uZWN0ZWQuXG4gICAqL1xuICBnZXRSZWxheSh1cmwsIGNvbm5lY3QgPSB0cnVlLCB0ZW1wb3JhcnkgPSBmYWxzZSwgZmlsdGVycykge1xuICAgIGxldCByZWxheSA9IHRoaXMucmVsYXlzLmdldChub3JtYWxpemVSZWxheVVybCh1cmwpKTtcbiAgICBpZiAoIXJlbGF5KSB7XG4gICAgICByZWxheSA9IG5ldyBOREtSZWxheSh1cmwsIHZvaWQgMCwgdGhpcy5uZGspO1xuICAgICAgcmVsYXkuY29ubmVjdGl2aXR5Lm5ldERlYnVnID0gdGhpcy5uZGsubmV0RGVidWc7XG4gICAgICBpZiAodGVtcG9yYXJ5KSB7XG4gICAgICAgIHRoaXMudXNlVGVtcG9yYXJ5UmVsYXkocmVsYXksIDNlNCwgZmlsdGVycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZFJlbGF5KHJlbGF5LCBjb25uZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG4gIGhhbmRsZVJlbGF5Q29ubmVjdChyZWxheVVybCkge1xuICAgIGNvbnN0IHJlbGF5ID0gdGhpcy5yZWxheXMuZ2V0KHJlbGF5VXJsKTtcbiAgICBpZiAoIXJlbGF5KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiTkRLIEJVRzogcmVsYXkgbm90IGZvdW5kIGluIHBvb2xcIiwgeyByZWxheVVybCB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwicmVsYXk6Y29ubmVjdFwiLCByZWxheSk7XG4gICAgaWYgKHRoaXMuc3RhdHMoKS5jb25uZWN0ZWQgPT09IHRoaXMucmVsYXlzLnNpemUpIHtcbiAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIik7XG4gICAgfVxuICB9XG4gIGhhbmRsZVJlbGF5UmVhZHkocmVsYXkpIHtcbiAgICB0aGlzLmVtaXQoXCJyZWxheTpyZWFkeVwiLCByZWxheSk7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gdG8gZWFjaCByZWxheSBpbiB0aGUgcG9vbC5cbiAgICpcbiAgICogQGFzeW5jXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dE1zXSAtIE9wdGlvbmFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciBlYWNoIGNvbm5lY3Rpb24gYXR0ZW1wdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIGNvbm5lY3Rpb24gYXR0ZW1wdHMgaGF2ZSBjb21wbGV0ZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbnkgb2YgdGhlIGNvbm5lY3Rpb24gYXR0ZW1wdHMgcmVzdWx0IGluIGFuIGVycm9yIG9yIHRpbWVvdXQuXG4gICAqL1xuICBhc3luYyBjb25uZWN0KHRpbWVvdXRNcykge1xuICAgIHRoaXMuc3RhdHVzID0gXCJhY3RpdmVcIjtcbiAgICB0aGlzLmRlYnVnKGBDb25uZWN0aW5nIHRvICR7dGhpcy5yZWxheXMuc2l6ZX0gcmVsYXlzJHt0aW1lb3V0TXMgPyBgLCB0aW1lb3V0ICR7dGltZW91dE1zfW1zYCA6IFwiXCJ9Li4uYCk7XG4gICAgY29uc3QgcmVsYXlzVG9Db25uZWN0ID0gQXJyYXkuZnJvbSh0aGlzLmF1dG9Db25uZWN0UmVsYXlzLmtleXMoKSkubWFwKCh1cmwpID0+IHRoaXMucmVsYXlzLmdldCh1cmwpKS5maWx0ZXIoKHJlbGF5KSA9PiAhIXJlbGF5KTtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHJlbGF5c1RvQ29ubmVjdCkge1xuICAgICAgaWYgKHJlbGF5LnN0YXR1cyAhPT0gNSAvKiBDT05ORUNURUQgKi8gJiYgcmVsYXkuc3RhdHVzICE9PSA0IC8qIENPTk5FQ1RJTkcgKi8pIHtcbiAgICAgICAgdGhpcy5lbWl0KFwicmVsYXk6Y29ubmVjdGluZ1wiLCByZWxheSk7XG4gICAgICAgIHJlbGF5LmNvbm5lY3QoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIHRoaXMuZGVidWcoYEZhaWxlZCB0byBjb25uZWN0IHRvIHJlbGF5ICR7cmVsYXkudXJsfTogJHtlID8/IFwiTm8gcmVhc29uIHNwZWNpZmllZFwifWApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYWxsQ29ubmVjdGVkID0gKCkgPT4gcmVsYXlzVG9Db25uZWN0LmV2ZXJ5KChyKSA9PiByLnN0YXR1cyA9PT0gNSAvKiBDT05ORUNURUQgKi8pO1xuICAgIGNvbnN0IGFsbENvbm5lY3RlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgaWYgKGFsbENvbm5lY3RlZCgpKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbGlzdGVuZXJzID0gW107XG4gICAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHJlbGF5c1RvQ29ubmVjdCkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChhbGxDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWxheXNUb0Nvbm5lY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgcmVsYXlzVG9Db25uZWN0W2ldLm9mZihcImNvbm5lY3RcIiwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICByZWxheS5vbihcImNvbm5lY3RcIiwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgdGltZW91dFByb21pc2UgPSB0eXBlb2YgdGltZW91dE1zID09PSBcIm51bWJlclwiID8gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dE1zKSkgOiBuZXcgUHJvbWlzZSgoKSA9PiB7XG4gICAgfSk7XG4gICAgYXdhaXQgUHJvbWlzZS5yYWNlKFthbGxDb25uZWN0ZWRQcm9taXNlLCB0aW1lb3V0UHJvbWlzZV0pO1xuICB9XG4gIGNoZWNrT25GbGFwcGluZ1JlbGF5cygpIHtcbiAgICBjb25zdCBmbGFwcGluZ1JlbGF5c0NvdW50ID0gdGhpcy5mbGFwcGluZ1JlbGF5cy5zaXplO1xuICAgIGNvbnN0IHRvdGFsUmVsYXlzID0gdGhpcy5yZWxheXMuc2l6ZTtcbiAgICBpZiAoZmxhcHBpbmdSZWxheXNDb3VudCAvIHRvdGFsUmVsYXlzID49IDAuOCkge1xuICAgICAgZm9yIChjb25zdCByZWxheVVybCBvZiB0aGlzLmZsYXBwaW5nUmVsYXlzKSB7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVzLnNldChyZWxheVVybCwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhbmRsZUZsYXBwaW5nKHJlbGF5KSB7XG4gICAgdGhpcy5kZWJ1ZyhgUmVsYXkgJHtyZWxheS51cmx9IGlzIGZsYXBwaW5nYCk7XG4gICAgbGV0IGN1cnJlbnRCYWNrb2ZmID0gdGhpcy5iYWNrb2ZmVGltZXMuZ2V0KHJlbGF5LnVybCkgfHwgNWUzO1xuICAgIGN1cnJlbnRCYWNrb2ZmID0gY3VycmVudEJhY2tvZmYgKiAyO1xuICAgIHRoaXMuYmFja29mZlRpbWVzLnNldChyZWxheS51cmwsIGN1cnJlbnRCYWNrb2ZmKTtcbiAgICB0aGlzLmRlYnVnKGBCYWNrb2ZmIHRpbWUgZm9yICR7cmVsYXkudXJsfSBpcyAke2N1cnJlbnRCYWNrb2ZmfW1zYCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmRlYnVnKGBBdHRlbXB0aW5nIHRvIHJlY29ubmVjdCB0byAke3JlbGF5LnVybH1gKTtcbiAgICAgIHRoaXMuZW1pdChcInJlbGF5OmNvbm5lY3RpbmdcIiwgcmVsYXkpO1xuICAgICAgcmVsYXkuY29ubmVjdCgpO1xuICAgICAgdGhpcy5jaGVja09uRmxhcHBpbmdSZWxheXMoKTtcbiAgICB9LCBjdXJyZW50QmFja29mZik7XG4gICAgcmVsYXkuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuZW1pdChcImZsYXBwaW5nXCIsIHJlbGF5KTtcbiAgfVxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLnJlbGF5cy5zaXplO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGF0dXMgb2YgZWFjaCByZWxheSBpbiB0aGUgcG9vbC5cbiAgICogQHJldHVybnMge05ES1Bvb2xTdGF0c30gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG51bWJlciBvZiByZWxheXMgaW4gZWFjaCBzdGF0dXMuXG4gICAqL1xuICBzdGF0cygpIHtcbiAgICBjb25zdCBzdGF0cyA9IHtcbiAgICAgIHRvdGFsOiAwLFxuICAgICAgY29ubmVjdGVkOiAwLFxuICAgICAgZGlzY29ubmVjdGVkOiAwLFxuICAgICAgY29ubmVjdGluZzogMFxuICAgIH07XG4gICAgZm9yIChjb25zdCByZWxheSBvZiB0aGlzLnJlbGF5cy52YWx1ZXMoKSkge1xuICAgICAgc3RhdHMudG90YWwrKztcbiAgICAgIGlmIChyZWxheS5zdGF0dXMgPT09IDUgLyogQ09OTkVDVEVEICovKSB7XG4gICAgICAgIHN0YXRzLmNvbm5lY3RlZCsrO1xuICAgICAgfSBlbHNlIGlmIChyZWxheS5zdGF0dXMgPT09IDEgLyogRElTQ09OTkVDVEVEICovKSB7XG4gICAgICAgIHN0YXRzLmRpc2Nvbm5lY3RlZCsrO1xuICAgICAgfSBlbHNlIGlmIChyZWxheS5zdGF0dXMgPT09IDQgLyogQ09OTkVDVElORyAqLykge1xuICAgICAgICBzdGF0cy5jb25uZWN0aW5nKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGF0cztcbiAgfVxuICBjb25uZWN0ZWRSZWxheXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWxheXMudmFsdWVzKCkpLmZpbHRlcigocmVsYXkpID0+IHJlbGF5LnN0YXR1cyA+PSA1IC8qIENPTk5FQ1RFRCAqLyk7XG4gIH1cbiAgcGVybWFuZW50QW5kQ29ubmVjdGVkUmVsYXlzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucmVsYXlzLnZhbHVlcygpKS5maWx0ZXIoXG4gICAgICAocmVsYXkpID0+IHJlbGF5LnN0YXR1cyA+PSA1IC8qIENPTk5FQ1RFRCAqLyAmJiAhdGhpcy50ZW1wb3JhcnlSZWxheVRpbWVycy5oYXMocmVsYXkudXJsKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgYWxsIHJlbGF5IHVybHMgaW4gdGhlIHBvb2wuXG4gICAqL1xuICB1cmxzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucmVsYXlzLmtleXMoKSk7XG4gIH1cbn07XG5cbi8vIHNyYy91c2VyL2luZGV4LnRzXG5pbXBvcnQgeyBuaXAxOSBhcyBuaXAxOTUgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9udXR6YXAvbWludC1saXN0LnRzXG52YXIgTkRLQ2FzaHVNaW50TGlzdCA9IGNsYXNzIF9OREtDYXNodU1pbnRMaXN0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBzdGF0aWMga2luZCA9IDEwMDE5IC8qIENhc2h1TWludExpc3QgKi87XG4gIHN0YXRpYyBraW5kcyA9IFsxMDAxOSAvKiBDYXNodU1pbnRMaXN0ICovXTtcbiAgX3AycGs7XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcihuZGssIGV2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDEwMDE5IC8qIENhc2h1TWludExpc3QgKi87XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtDYXNodU1pbnRMaXN0KGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIHNldCByZWxheXModXJscykge1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+IHRbMF0gIT09IFwicmVsYXlcIik7XG4gICAgZm9yIChjb25zdCB1cmwgb2YgdXJscykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicmVsYXlcIiwgdXJsXSk7XG4gICAgfVxuICB9XG4gIGdldCByZWxheXMoKSB7XG4gICAgY29uc3QgciA9IFtdO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJyZWxheVwiKSB7XG4gICAgICAgIHIucHVzaCh0YWdbMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICBzZXQgbWludHModXJscykge1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+IHRbMF0gIT09IFwibWludFwiKTtcbiAgICBmb3IgKGNvbnN0IHVybCBvZiB1cmxzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJtaW50XCIsIHVybF0pO1xuICAgIH1cbiAgfVxuICBnZXQgbWludHMoKSB7XG4gICAgY29uc3QgciA9IFtdO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJtaW50XCIpIHtcbiAgICAgICAgci5wdXNoKHRhZ1sxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQocikpO1xuICB9XG4gIGdldCBwMnBrKCkge1xuICAgIGlmICh0aGlzLl9wMnBrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcDJwaztcbiAgICB9XG4gICAgdGhpcy5fcDJwayA9IHRoaXMudGFnVmFsdWUoXCJwdWJrZXlcIikgPz8gdGhpcy5wdWJrZXk7XG4gICAgcmV0dXJuIHRoaXMuX3AycGs7XG4gIH1cbiAgc2V0IHAycGsocHVia2V5KSB7XG4gICAgdGhpcy5fcDJwayA9IHB1YmtleTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInB1YmtleVwiKTtcbiAgICBpZiAocHVia2V5KSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwdWJrZXlcIiwgcHVia2V5XSk7XG4gICAgfVxuICB9XG4gIGdldCByZWxheVNldCgpIHtcbiAgICByZXR1cm4gTkRLUmVsYXlTZXQuZnJvbVJlbGF5VXJscyh0aGlzLnJlbGF5cywgdGhpcy5uZGspO1xuICB9XG59O1xuXG4vLyBzcmMvc3Vic2NyaXB0aW9uL2luZGV4LnRzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgYXMgRXZlbnRFbWl0dGVyNCB9IGZyb20gXCJ0c2VlcFwiO1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2FydGljbGUudHNcbnZhciBOREtBcnRpY2xlID0gY2xhc3MgX05ES0FydGljbGUgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMzAwMjMgLyogQXJ0aWNsZSAqLztcbiAgc3RhdGljIGtpbmRzID0gWzMwMDIzIC8qIEFydGljbGUgKi9dO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzMDAyMyAvKiBBcnRpY2xlICovO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTkRLQXJ0aWNsZSBmcm9tIGFuIGV4aXN0aW5nIE5ES0V2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgTkRLRXZlbnQgdG8gY3JlYXRlIHRoZSBOREtBcnRpY2xlIGZyb20uXG4gICAqIEByZXR1cm5zIE5ES0FydGljbGVcbiAgICovXG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLQXJ0aWNsZShldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYXJ0aWNsZSB0aXRsZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gLSBUaGUgYXJ0aWNsZSB0aXRsZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgdGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ0aXRsZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYXJ0aWNsZSB0aXRsZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHRpdGxlIC0gVGhlIHRpdGxlIHRvIHNldCBmb3IgdGhlIGFydGljbGUuXG4gICAqL1xuICBzZXQgdGl0bGUodGl0bGUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInRpdGxlXCIpO1xuICAgIGlmICh0aXRsZSkgdGhpcy50YWdzLnB1c2goW1widGl0bGVcIiwgdGl0bGVdKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYXJ0aWNsZSBpbWFnZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gLSBUaGUgYXJ0aWNsZSBpbWFnZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgaW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJpbWFnZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYXJ0aWNsZSBpbWFnZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGltYWdlIC0gVGhlIGltYWdlIHRvIHNldCBmb3IgdGhlIGFydGljbGUuXG4gICAqL1xuICBzZXQgaW1hZ2UoaW1hZ2UpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImltYWdlXCIpO1xuICAgIGlmIChpbWFnZSkgdGhpcy50YWdzLnB1c2goW1wiaW1hZ2VcIiwgaW1hZ2VdKTtcbiAgfVxuICBnZXQgc3VtbWFyeSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInN1bW1hcnlcIik7XG4gIH1cbiAgc2V0IHN1bW1hcnkoc3VtbWFyeSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwic3VtbWFyeVwiKTtcbiAgICBpZiAoc3VtbWFyeSkgdGhpcy50YWdzLnB1c2goW1wic3VtbWFyeVwiLCBzdW1tYXJ5XSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGFydGljbGUncyBwdWJsaWNhdGlvbiB0aW1lc3RhbXAuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9IC0gVGhlIFVuaXggdGltZXN0YW1wIG9mIHdoZW4gdGhlIGFydGljbGUgd2FzIHB1Ymxpc2hlZCBvciB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgcHVibGlzaGVkX2F0KCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnVmFsdWUoXCJwdWJsaXNoZWRfYXRcIik7XG4gICAgaWYgKHRhZykge1xuICAgICAgbGV0IHZhbCA9IE51bWJlci5wYXJzZUludCh0YWcpO1xuICAgICAgaWYgKHZhbCA+IDFlMTIpIHtcbiAgICAgICAgdmFsID0gTWF0aC5mbG9vcih2YWwgLyAxZTMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYXJ0aWNsZSdzIHB1YmxpY2F0aW9uIHRpbWVzdGFtcC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IHRpbWVzdGFtcCAtIFRoZSBVbml4IHRpbWVzdGFtcCB0byBzZXQgZm9yIHRoZSBhcnRpY2xlJ3MgcHVibGljYXRpb24gZGF0ZS5cbiAgICovXG4gIHNldCBwdWJsaXNoZWRfYXQodGltZXN0YW1wKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwdWJsaXNoZWRfYXRcIik7XG4gICAgaWYgKHRpbWVzdGFtcCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwdWJsaXNoZWRfYXRcIiwgdGltZXN0YW1wLnRvU3RyaW5nKCldKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBjb250ZW50IHRhZ3MgZm9yIHRoZSBhcnRpY2xlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBmaXJzdCBjaGVja3MgYW5kIHNldHMgdGhlIHB1YmxpY2F0aW9uIGRhdGUgaWYgbm90IGF2YWlsYWJsZSxcbiAgICogYW5kIHRoZW4gZ2VuZXJhdGVzIGNvbnRlbnQgdGFncyBiYXNlZCBvbiB0aGUgYmFzZSBOREtFdmVudCBjbGFzcy5cbiAgICpcbiAgICogQHJldHVybnMge0NvbnRlbnRUYWd9IC0gVGhlIGdlbmVyYXRlZCBjb250ZW50IHRhZ3MuXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZVRhZ3MoKSB7XG4gICAgc3VwZXIuZ2VuZXJhdGVUYWdzKCk7XG4gICAgaWYgKCF0aGlzLnB1Ymxpc2hlZF9hdCkge1xuICAgICAgdGhpcy5wdWJsaXNoZWRfYXQgPSB0aGlzLmNyZWF0ZWRfYXQ7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5nZW5lcmF0ZVRhZ3MoKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYXJ0aWNsZSdzIFVSTC5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gLSBUaGUgYXJ0aWNsZSdzIFVSTCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwidXJsXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlJ3MgVVJMLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gdXJsIC0gVGhlIFVSTCB0byBzZXQgZm9yIHRoZSBhcnRpY2xlLlxuICAgKi9cbiAgc2V0IHVybCh1cmwpIHtcbiAgICBpZiAodXJsKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJ1cmxcIiwgdXJsXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlVGFnKFwidXJsXCIpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9jYXNodS90b2tlbi50c1xuZnVuY3Rpb24gcHJvb2ZzVG90YWxCYWxhbmNlKHByb29mcykge1xuICByZXR1cm4gcHJvb2ZzLnJlZHVjZSgoYWNjLCBwcm9vZikgPT4ge1xuICAgIGlmIChwcm9vZi5hbW91bnQgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9vZiBhbW91bnQgaXMgbmVnYXRpdmVcIik7XG4gICAgfVxuICAgIHJldHVybiBhY2MgKyBwcm9vZi5hbW91bnQ7XG4gIH0sIDApO1xufVxudmFyIE5ES0Nhc2h1VG9rZW4gPSBjbGFzcyBfTkRLQ2FzaHVUb2tlbiBleHRlbmRzIE5ES0V2ZW50IHtcbiAgX3Byb29mcyA9IFtdO1xuICBfbWludDtcbiAgc3RhdGljIGtpbmQgPSA3Mzc1IC8qIENhc2h1VG9rZW4gKi87XG4gIHN0YXRpYyBraW5kcyA9IFs3Mzc1IC8qIENhc2h1VG9rZW4gKi9dO1xuICAvKipcbiAgICogVG9rZW5zIHRoYXQgdGhpcyB0b2tlbiBzdXBlcnNlZWRzXG4gICAqL1xuICBfZGVsZXRlcyA9IFtdO1xuICBvcmlnaW5hbDtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gNzM3NSAvKiBDYXNodVRva2VuICovO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tKGV2ZW50KSB7XG4gICAgY29uc3QgdG9rZW4gPSBuZXcgX05ES0Nhc2h1VG9rZW4oZXZlbnQubmRrLCBldmVudCk7XG4gICAgdG9rZW4ub3JpZ2luYWwgPSBldmVudDtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdG9rZW4uZGVjcnlwdCgpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdG9rZW4uY29udGVudCA9IHRva2VuLm9yaWdpbmFsLmNvbnRlbnQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gSlNPTi5wYXJzZSh0b2tlbi5jb250ZW50KTtcbiAgICAgIHRva2VuLnByb29mcyA9IGNvbnRlbnQucHJvb2ZzO1xuICAgICAgdG9rZW4ubWludCA9IGNvbnRlbnQubWludCA/PyB0b2tlbi50YWdWYWx1ZShcIm1pbnRcIik7XG4gICAgICB0b2tlbi5kZWxldGVkVG9rZW5zID0gY29udGVudC5kZWwgPz8gW107XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodG9rZW4ucHJvb2ZzKSkgcmV0dXJuO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuICBnZXQgcHJvb2ZzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9vZnM7XG4gIH1cbiAgc2V0IHByb29mcyhwcm9vZnMpIHtcbiAgICBjb25zdCBjcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5fcHJvb2ZzID0gcHJvb2ZzLmZpbHRlcigocHJvb2YpID0+IHtcbiAgICAgIGlmIChjcy5oYXMocHJvb2YuQykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiUGFzc2VkIGluIHByb29mcyBoYWQgZHVwbGljYXRlcywgaWdub3JpbmdcIiwgcHJvb2YuQyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9vZi5hbW91bnQgPCAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcHJvb2Ygd2l0aCBuZWdhdGl2ZSBhbW91bnRcIiwgcHJvb2YpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjcy5hZGQocHJvb2YuQyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KS5tYXAodGhpcy5jbGVhblByb29mKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG1pbmltYWwgcHJvb2Ygb2JqZWN0IHdpdGggb25seSBlc3NlbnRpYWwgcHJvcGVydGllc1xuICAgKi9cbiAgY2xlYW5Qcm9vZihwcm9vZikge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogcHJvb2YuaWQsXG4gICAgICBhbW91bnQ6IHByb29mLmFtb3VudCxcbiAgICAgIEM6IHByb29mLkMsXG4gICAgICBzZWNyZXQ6IHByb29mLnNlY3JldFxuICAgIH07XG4gIH1cbiAgYXN5bmMgdG9Ob3N0ckV2ZW50KHB1YmtleSkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIm5vIG5ka1wiKTtcbiAgICBpZiAoIXRoaXMubmRrLnNpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwibm8gc2lnbmVyXCIpO1xuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICBwcm9vZnM6IHRoaXMucHJvb2ZzLm1hcCh0aGlzLmNsZWFuUHJvb2YpLFxuICAgICAgbWludDogdGhpcy5taW50LFxuICAgICAgZGVsOiB0aGlzLmRlbGV0ZWRUb2tlbnMgPz8gW11cbiAgICB9O1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5kay5zaWduZXIudXNlcigpO1xuICAgIGF3YWl0IHRoaXMuZW5jcnlwdCh1c2VyLCB2b2lkIDAsIFwibmlwNDRcIik7XG4gICAgcmV0dXJuIHN1cGVyLnRvTm9zdHJFdmVudChwdWJrZXkpO1xuICB9XG4gIHNldCBtaW50KG1pbnQpIHtcbiAgICB0aGlzLl9taW50ID0gbWludDtcbiAgfVxuICBnZXQgbWludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWludDtcbiAgfVxuICAvKipcbiAgICogVG9rZW5zIHRoYXQgd2VyZSBkZWxldGVkIGJ5IHRoZSBjcmVhdGlvbiBvZiB0aGlzIHRva2VuLlxuICAgKi9cbiAgZ2V0IGRlbGV0ZWRUb2tlbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlbGV0ZXM7XG4gIH1cbiAgLyoqXG4gICAqIE1hcmtzIHRva2VucyB0aGF0IHdlcmUgZGVsZXRlZCBieSB0aGUgY3JlYXRpb24gb2YgdGhpcyB0b2tlbi5cbiAgICovXG4gIHNldCBkZWxldGVkVG9rZW5zKHRva2VuSWRzKSB7XG4gICAgdGhpcy5fZGVsZXRlcyA9IHRva2VuSWRzO1xuICB9XG4gIGdldCBhbW91bnQoKSB7XG4gICAgcmV0dXJuIHByb29mc1RvdGFsQmFsYW5jZSh0aGlzLnByb29mcyk7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpIHtcbiAgICBpZiAodGhpcy5vcmlnaW5hbCkge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWwucHVibGlzaChyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucHVibGlzaChyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2hpZ2hsaWdodC50c1xuaW1wb3J0IHsgbmlwMTkgYXMgbmlwMTkzIH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG52YXIgTkRLSGlnaGxpZ2h0ID0gY2xhc3MgX05ES0hpZ2hsaWdodCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgX2FydGljbGU7XG4gIHN0YXRpYyBraW5kID0gOTgwMiAvKiBIaWdobGlnaHQgKi87XG4gIHN0YXRpYyBraW5kcyA9IFs5ODAyIC8qIEhpZ2hsaWdodCAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDk4MDIgLyogSGlnaGxpZ2h0ICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLSGlnaGxpZ2h0KGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJyXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDb250ZXh0IHRhZy5cbiAgICovXG4gIHNldCBjb250ZXh0KGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKChbdGFnLCBfdmFsdWVdKSA9PiB0YWcgIT09IFwiY29udGV4dFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigoW3RhZywgX3ZhbHVlXSkgPT4gdGFnICE9PSBcImNvbnRleHRcIik7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJjb250ZXh0XCIsIGNvbnRleHRdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFncy5maW5kKChbdGFnLCBfdmFsdWVdKSA9PiB0YWcgPT09IFwiY29udGV4dFwiKT8uWzFdID8/IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogV2lsbCByZXR1cm4gdGhlIGFydGljbGUgVVJMIG9yIE5ES0V2ZW50IGlmIHRoZXkgaGF2ZSBhbHJlYWR5IGJlZW5cbiAgICogc2V0IChpdCB3b24ndCBhdHRlbXB0IHRvIGxvYWQgcmVtb3RlIGV2ZW50cylcbiAgICovXG4gIGdldCBhcnRpY2xlKCkge1xuICAgIHJldHVybiB0aGlzLl9hcnRpY2xlO1xuICB9XG4gIC8qKlxuICAgKiBBcnRpY2xlIHRoZSBoaWdobGlnaHQgaXMgY29taW5nIGZyb20uXG4gICAqXG4gICAqIEBwYXJhbSBhcnRpY2xlIEFydGljbGUgVVJMIG9yIE5ES0V2ZW50LlxuICAgKi9cbiAgc2V0IGFydGljbGUoYXJ0aWNsZSkge1xuICAgIHRoaXMuX2FydGljbGUgPSBhcnRpY2xlO1xuICAgIGlmICh0eXBlb2YgYXJ0aWNsZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiclwiLCBhcnRpY2xlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFnKGFydGljbGUpO1xuICAgIH1cbiAgfVxuICBnZXRBcnRpY2xlVGFnKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVGFncyhcImFcIilbMF0gfHwgdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJlXCIpWzBdIHx8IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiclwiKVswXTtcbiAgfVxuICBhc3luYyBnZXRBcnRpY2xlKCkge1xuICAgIGlmICh0aGlzLl9hcnRpY2xlICE9PSB2b2lkIDApIHJldHVybiB0aGlzLl9hcnRpY2xlO1xuICAgIGxldCB0YWdnZWRCZWNoMzI7XG4gICAgY29uc3QgYXJ0aWNsZVRhZyA9IHRoaXMuZ2V0QXJ0aWNsZVRhZygpO1xuICAgIGlmICghYXJ0aWNsZVRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICBzd2l0Y2ggKGFydGljbGVUYWdbMF0pIHtcbiAgICAgIGNhc2UgXCJhXCI6IHtcbiAgICAgICAgY29uc3QgW2tpbmQsIHB1YmtleSwgaWRlbnRpZmllcl0gPSBhcnRpY2xlVGFnWzFdLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgdGFnZ2VkQmVjaDMyID0gbmlwMTkzLm5hZGRyRW5jb2RlKHtcbiAgICAgICAgICBraW5kOiBOdW1iZXIucGFyc2VJbnQoa2luZCksXG4gICAgICAgICAgcHVia2V5LFxuICAgICAgICAgIGlkZW50aWZpZXJcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImVcIjpcbiAgICAgICAgdGFnZ2VkQmVjaDMyID0gbmlwMTkzLm5vdGVFbmNvZGUoYXJ0aWNsZVRhZ1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJcIjpcbiAgICAgICAgdGhpcy5fYXJ0aWNsZSA9IGFydGljbGVUYWdbMV07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGFnZ2VkQmVjaDMyKSB7XG4gICAgICBsZXQgYSA9IGF3YWl0IHRoaXMubmRrPy5mZXRjaEV2ZW50KHRhZ2dlZEJlY2gzMik7XG4gICAgICBpZiAoYSkge1xuICAgICAgICBpZiAoYS5raW5kID09PSAzMDAyMyAvKiBBcnRpY2xlICovKSB7XG4gICAgICAgICAgYSA9IE5ES0FydGljbGUuZnJvbShhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hcnRpY2xlID0gYTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FydGljbGU7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9pbWV0YS50c1xuZnVuY3Rpb24gbWFwSW1ldGFUYWcodGFnKSB7XG4gIGNvbnN0IGRhdGEgPSB7fTtcbiAgaWYgKHRhZy5sZW5ndGggPT09IDIpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHRhZ1sxXS5zcGxpdChcIiBcIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3Qga2V5ID0gcGFydHNbaV07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgIGlmIChrZXkgPT09IFwiZmFsbGJhY2tcIikge1xuICAgICAgICBpZiAoIWRhdGEuZmFsbGJhY2spIGRhdGEuZmFsbGJhY2sgPSBbXTtcbiAgICAgICAgZGF0YS5mYWxsYmFjay5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBjb25zdCB0YWdzID0gdGFnLnNsaWNlKDEpO1xuICBmb3IgKGNvbnN0IHZhbCBvZiB0YWdzKSB7XG4gICAgY29uc3QgcGFydHMgPSB2YWwuc3BsaXQoXCIgXCIpO1xuICAgIGNvbnN0IGtleSA9IHBhcnRzWzBdO1xuICAgIGNvbnN0IHZhbHVlID0gcGFydHMuc2xpY2UoMSkuam9pbihcIiBcIik7XG4gICAgaWYgKGtleSA9PT0gXCJmYWxsYmFja1wiKSB7XG4gICAgICBpZiAoIWRhdGEuZmFsbGJhY2spIGRhdGEuZmFsbGJhY2sgPSBbXTtcbiAgICAgIGRhdGEuZmFsbGJhY2sucHVzaCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGltZXRhVGFnVG9UYWcoaW1ldGEpIHtcbiAgY29uc3QgdGFnID0gW1wiaW1ldGFcIl07XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGltZXRhKSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgIHRhZy5wdXNoKGAke2tleX0gJHt2fWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHRhZy5wdXNoKGAke2tleX0gJHt2YWx1ZX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhZztcbn1cblxuLy8gc3JjL2V2ZW50cy9raW5kcy9pbWFnZS50c1xudmFyIE5ES0ltYWdlID0gY2xhc3MgX05ES0ltYWdlIGV4dGVuZHMgTkRLRXZlbnQge1xuICBzdGF0aWMga2luZCA9IDIwIC8qIEltYWdlICovO1xuICBzdGF0aWMga2luZHMgPSBbMjAgLyogSW1hZ2UgKi9dO1xuICBfaW1ldGFzO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAyMCAvKiBJbWFnZSAqLztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIE5ES0ltYWdlIGZyb20gYW4gZXhpc3RpbmcgTkRLRXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBOREtFdmVudCB0byBjcmVhdGUgdGhlIE5ES0ltYWdlIGZyb20uXG4gICAqIEByZXR1cm5zIE5ES0ltYWdlXG4gICAqL1xuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0ltYWdlKGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1ldGFzLmxlbmd0aCA+IDA7XG4gIH1cbiAgZ2V0IGltZXRhcygpIHtcbiAgICBpZiAodGhpcy5faW1ldGFzKSByZXR1cm4gdGhpcy5faW1ldGFzO1xuICAgIHRoaXMuX2ltZXRhcyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdID09PSBcImltZXRhXCIpLm1hcChtYXBJbWV0YVRhZykuZmlsdGVyKChpbWV0YSkgPT4gISFpbWV0YS51cmwpO1xuICAgIHJldHVybiB0aGlzLl9pbWV0YXM7XG4gIH1cbiAgc2V0IGltZXRhcyh0YWdzKSB7XG4gICAgdGhpcy5faW1ldGFzID0gdGFncztcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSAhPT0gXCJpbWV0YVwiKTtcbiAgICB0aGlzLnRhZ3MucHVzaCguLi50YWdzLm1hcChpbWV0YVRhZ1RvVGFnKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvbGlzdHMvaW5kZXgudHNcbnZhciBOREtMaXN0ID0gY2xhc3MgX05ES0xpc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIF9lbmNyeXB0ZWRUYWdzO1xuICBzdGF0aWMga2luZHMgPSBbXG4gICAgMTAwNjMgLyogQmxvc3NvbUxpc3QgKi8sXG4gICAgMzAwMDEgLyogQ2F0ZWdvcml6ZWRCb29rbWFya0xpc3QgKi8sXG4gICAgMTAwMDQgLyogQ29tbXVuaXR5TGlzdCAqLyxcbiAgICAxMDA1MCAvKiBEaXJlY3RNZXNzYWdlUmVjZWl2ZVJlbGF5TGlzdCAqLyxcbiAgICAxMDAzMCAvKiBFbW9qaUxpc3QgKi8sXG4gICAgMTAwMTUgLyogSW50ZXJlc3RMaXN0ICovLFxuICAgIDEwMDAxIC8qIFBpbkxpc3QgKi8sXG4gICAgMTAwMDIgLyogUmVsYXlMaXN0ICovLFxuICAgIDEwMDA3IC8qIFNlYXJjaFJlbGF5TGlzdCAqLyxcbiAgICAxMDAwNiAvKiBCbG9ja1JlbGF5TGlzdCAqLyxcbiAgICAxMDAwMyAvKiBCb29rbWFya0xpc3QgKi9cbiAgXTtcbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBjb250ZW50IHdhcyBiZWZvcmUgZGVjcnlwdGlvblxuICAgKiB0byBleHBpcmUgdGhlIGNhY2hlIHdoZW4gdGhlIGNvbnRlbnQgY2hhbmdlcy5cbiAgICovXG4gIGVuY3J5cHRlZFRhZ3NMZW5ndGg7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMwMDAxIC8qIENhdGVnb3JpemVkQm9va21hcmtMaXN0ICovO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwIGEgTkRLRXZlbnQgaW50byBhIE5ES0xpc3RcbiAgICovXG4gIHN0YXRpYyBmcm9tKG5ka0V2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLTGlzdChuZGtFdmVudC5uZGssIG5ka0V2ZW50KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGl0bGUgb2YgdGhlIGxpc3QuIEZhbGxzIGJhY2sgb24gZmV0Y2hpbmcgdGhlIG5hbWUgdGFnIHZhbHVlLlxuICAgKi9cbiAgZ2V0IHRpdGxlKCkge1xuICAgIGNvbnN0IHRpdGxlVGFnID0gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpIHx8IHRoaXMudGFnVmFsdWUoXCJuYW1lXCIpO1xuICAgIGlmICh0aXRsZVRhZykgcmV0dXJuIHRpdGxlVGFnO1xuICAgIGlmICh0aGlzLmtpbmQgPT09IDMgLyogQ29udGFjdHMgKi8pIHtcbiAgICAgIHJldHVybiBcIkNvbnRhY3RzXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDFlNCAvKiBNdXRlTGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiTXV0ZVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSAxMDAwMSAvKiBQaW5MaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJQaW5uZWQgTm90ZXNcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMTAwMDIgLyogUmVsYXlMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJSZWxheSBNZXRhZGF0YVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSAxMDAwMyAvKiBCb29rbWFya0xpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIkJvb2ttYXJrc1wiO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSAxMDAwNCAvKiBDb21tdW5pdHlMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJDb21tdW5pdGllc1wiO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSAxMDAwNSAvKiBQdWJsaWNDaGF0TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiUHVibGljIENoYXRzXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDA2IC8qIEJsb2NrUmVsYXlMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJCbG9ja2VkIFJlbGF5c1wiO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSAxMDAwNyAvKiBTZWFyY2hSZWxheUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIlNlYXJjaCBSZWxheXNcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMTAwNTAgLyogRGlyZWN0TWVzc2FnZVJlY2VpdmVSZWxheUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIkRpcmVjdCBNZXNzYWdlIFJlY2VpdmUgUmVsYXlzXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDE1IC8qIEludGVyZXN0TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiSW50ZXJlc3RzXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDMwIC8qIEVtb2ppTGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiRW1vamlzXCI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZFwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGl0bGUgb2YgdGhlIGxpc3QuXG4gICAqL1xuICBzZXQgdGl0bGUodGl0bGUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhbXCJ0aXRsZVwiLCBcIm5hbWVcIl0pO1xuICAgIGlmICh0aXRsZSkgdGhpcy50YWdzLnB1c2goW1widGl0bGVcIiwgdGl0bGVdKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgbGlzdC5cbiAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBcInRpdGxlXCIgaW5zdGVhZC5cbiAgICovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnRpdGxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBuYW1lIG9mIHRoZSBsaXN0LlxuICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIFwidGl0bGVcIiBpbnN0ZWFkLiBUaGlzIG1ldGhvZCB3aWxsIHVzZSB0aGUgYHRpdGxlYCB0YWcgaW5zdGVhZC5cbiAgICovXG4gIHNldCBuYW1lKG5hbWUpIHtcbiAgICB0aGlzLnRpdGxlID0gbmFtZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGxpc3QuXG4gICAqL1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJkZXNjcmlwdGlvblwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGxpc3QuXG4gICAqL1xuICBzZXQgZGVzY3JpcHRpb24obmFtZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZGVzY3JpcHRpb25cIik7XG4gICAgaWYgKG5hbWUpIHRoaXMudGFncy5wdXNoKFtcImRlc2NyaXB0aW9uXCIsIG5hbWVdKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW1hZ2Ugb2YgdGhlIGxpc3QuXG4gICAqL1xuICBnZXQgaW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJpbWFnZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgaW1hZ2Ugb2YgdGhlIGxpc3QuXG4gICAqL1xuICBzZXQgaW1hZ2UobmFtZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiaW1hZ2VcIik7XG4gICAgaWYgKG5hbWUpIHRoaXMudGFncy5wdXNoKFtcImltYWdlXCIsIG5hbWVdKTtcbiAgfVxuICBpc0VuY3J5cHRlZFRhZ3NDYWNoZVZhbGlkKCkge1xuICAgIHJldHVybiAhISh0aGlzLl9lbmNyeXB0ZWRUYWdzICYmIHRoaXMuZW5jcnlwdGVkVGFnc0xlbmd0aCA9PT0gdGhpcy5jb250ZW50Lmxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlY3J5cHRlZCBjb250ZW50IG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgYXN5bmMgZW5jcnlwdGVkVGFncyh1c2VDYWNoZSA9IHRydWUpIHtcbiAgICBpZiAodXNlQ2FjaGUgJiYgdGhpcy5pc0VuY3J5cHRlZFRhZ3NDYWNoZVZhbGlkKCkpIHJldHVybiB0aGlzLl9lbmNyeXB0ZWRUYWdzO1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3Qgc2V0XCIpO1xuICAgIGlmICghdGhpcy5uZGsuc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgc2lnbmVyIG5vdCBzZXRcIik7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci51c2VyKCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGRlY3J5cHRlZENvbnRlbnQgPSBhd2FpdCB0aGlzLm5kay5zaWduZXIuZGVjcnlwdCh1c2VyLCB0aGlzLmNvbnRlbnQpO1xuICAgICAgICAgIGNvbnN0IGEgPSBKU09OLnBhcnNlKGRlY3J5cHRlZENvbnRlbnQpO1xuICAgICAgICAgIGlmIChhPy5bMF0pIHtcbiAgICAgICAgICAgIHRoaXMuZW5jcnlwdGVkVGFnc0xlbmd0aCA9IHRoaXMuY29udGVudC5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZW5jcnlwdGVkVGFncyA9IGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZW5jcnlwdGVkVGFnc0xlbmd0aCA9IHRoaXMuY29udGVudC5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2VuY3J5cHRlZFRhZ3MgPSBbXTtcbiAgICAgICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRlbiB0byB2YWxpZGF0ZSB0aGF0IGEgdGFnIGlzIHZhbGlkIGZvciB0aGlzIGxpc3QuXG4gICAqXG4gICAqIChpLmUuIHRoZSBOREtQZXJzb25MaXN0IGNhbiB2YWxpZGF0ZSB0aGF0IGl0ZW1zIGFyZSBOREtVc2VyIGluc3RhbmNlcylcbiAgICovXG4gIHZhbGlkYXRlVGFnKF90YWdWYWx1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldEl0ZW1zKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IHR5cGUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1bmVjcnlwdGVkIGl0ZW1zIGluIHRoaXMgbGlzdC5cbiAgICovXG4gIGdldCBpdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbHRlcigodCkgPT4ge1xuICAgICAgcmV0dXJuICFbXG4gICAgICAgIFwiZFwiLFxuICAgICAgICBcIkxcIixcbiAgICAgICAgXCJsXCIsXG4gICAgICAgIFwidGl0bGVcIixcbiAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgIFwiZGVzY3JpcHRpb25cIixcbiAgICAgICAgXCJwdWJsaXNoZWRfYXRcIixcbiAgICAgICAgXCJzdW1tYXJ5XCIsXG4gICAgICAgIFwiaW1hZ2VcIixcbiAgICAgICAgXCJ0aHVtYlwiLFxuICAgICAgICBcImFsdFwiLFxuICAgICAgICBcImV4cGlyYXRpb25cIixcbiAgICAgICAgXCJzdWJqZWN0XCIsXG4gICAgICAgIFwiY2xpZW50XCJcbiAgICAgIF0uaW5jbHVkZXModFswXSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgaXRlbSB0byB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHJlbGF5IFJlbGF5IHRvIGFkZFxuICAgKiBAcGFyYW0gbWFyayBPcHRpb25hbCBtYXJrIHRvIGFkZCB0byB0aGUgaXRlbVxuICAgKiBAcGFyYW0gZW5jcnlwdGVkIFdoZXRoZXIgdG8gZW5jcnlwdCB0aGUgaXRlbVxuICAgKiBAcGFyYW0gcG9zaXRpb24gV2hlcmUgdG8gYWRkIHRoZSBpdGVtIGluIHRoZSBsaXN0ICh0b3Agb3IgYm90dG9tKVxuICAgKi9cbiAgYXN5bmMgYWRkSXRlbShpdGVtLCBtYXJrID0gdm9pZCAwLCBlbmNyeXB0ZWQgPSBmYWxzZSwgcG9zaXRpb24gPSBcImJvdHRvbVwiKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBzZXRcIik7XG4gICAgaWYgKCF0aGlzLm5kay5zaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5ESyBzaWduZXIgbm90IHNldFwiKTtcbiAgICBsZXQgdGFncztcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES0V2ZW50KSB7XG4gICAgICB0YWdzID0gW2l0ZW0udGFnUmVmZXJlbmNlKG1hcmspXTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtVc2VyKSB7XG4gICAgICB0YWdzID0gaXRlbS5yZWZlcmVuY2VUYWdzKCk7XG4gICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgTkRLUmVsYXkpIHtcbiAgICAgIHRhZ3MgPSBpdGVtLnJlZmVyZW5jZVRhZ3MoKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgIHRhZ3MgPSBbaXRlbV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb2JqZWN0IHR5cGVcIik7XG4gICAgfVxuICAgIGlmIChtYXJrKSB0YWdzWzBdLnB1c2gobWFyayk7XG4gICAgaWYgKGVuY3J5cHRlZCkge1xuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci51c2VyKCk7XG4gICAgICBjb25zdCBjdXJyZW50TGlzdCA9IGF3YWl0IHRoaXMuZW5jcnlwdGVkVGFncygpO1xuICAgICAgaWYgKHBvc2l0aW9uID09PSBcInRvcFwiKSBjdXJyZW50TGlzdC51bnNoaWZ0KC4uLnRhZ3MpO1xuICAgICAgZWxzZSBjdXJyZW50TGlzdC5wdXNoKC4uLnRhZ3MpO1xuICAgICAgdGhpcy5fZW5jcnlwdGVkVGFncyA9IGN1cnJlbnRMaXN0O1xuICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRMaXN0KTtcbiAgICAgIGF3YWl0IHRoaXMuZW5jcnlwdCh1c2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSBcInRvcFwiKSB0aGlzLnRhZ3MudW5zaGlmdCguLi50YWdzKTtcbiAgICAgIGVsc2UgdGhpcy50YWdzLnB1c2goLi4udGFncyk7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlZF9hdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgbGlzdCBmcm9tIGJvdGggdGhlIGVuY3J5cHRlZCBhbmQgdW5lbmNyeXB0ZWQgbGlzdHMuXG4gICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSBvZiBpdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBsaXN0XG4gICAqIEBwYXJhbSBwdWJsaXNoIHdoZXRoZXIgdG8gcHVibGlzaCB0aGUgY2hhbmdlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyByZW1vdmVJdGVtQnlWYWx1ZSh2YWx1ZSwgcHVibGlzaCA9IHRydWUpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IHNldFwiKTtcbiAgICBpZiAoIXRoaXMubmRrLnNpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwiTkRLIHNpZ25lciBub3Qgc2V0XCIpO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy50YWdzLmZpbmRJbmRleCgodGFnKSA9PiB0YWdbMV0gPT09IHZhbHVlKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGhpcy50YWdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5kay5zaWduZXIudXNlcigpO1xuICAgIGNvbnN0IGVuY3J5cHRlZFRhZ3MgPSBhd2FpdCB0aGlzLmVuY3J5cHRlZFRhZ3MoKTtcbiAgICBjb25zdCBlbmNyeXB0ZWRJbmRleCA9IGVuY3J5cHRlZFRhZ3MuZmluZEluZGV4KCh0YWcpID0+IHRhZ1sxXSA9PT0gdmFsdWUpO1xuICAgIGlmIChlbmNyeXB0ZWRJbmRleCA+PSAwKSB7XG4gICAgICBlbmNyeXB0ZWRUYWdzLnNwbGljZShlbmNyeXB0ZWRJbmRleCwgMSk7XG4gICAgICB0aGlzLl9lbmNyeXB0ZWRUYWdzID0gZW5jcnlwdGVkVGFncztcbiAgICAgIHRoaXMuZW5jcnlwdGVkVGFnc0xlbmd0aCA9IHRoaXMuY29udGVudC5sZW5ndGg7XG4gICAgICB0aGlzLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShlbmNyeXB0ZWRUYWdzKTtcbiAgICAgIGF3YWl0IHRoaXMuZW5jcnlwdCh1c2VyKTtcbiAgICB9XG4gICAgaWYgKHB1Ymxpc2gpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1Ymxpc2hSZXBsYWNlYWJsZSgpO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZWRfYXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpO1xuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0gZW5jcnlwdGVkIFdoZXRoZXIgdG8gcmVtb3ZlIGZyb20gdGhlIGVuY3J5cHRlZCBsaXN0IG9yIG5vdC5cbiAgICovXG4gIGFzeW5jIHJlbW92ZUl0ZW0oaW5kZXgsIGVuY3J5cHRlZCkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3Qgc2V0XCIpO1xuICAgIGlmICghdGhpcy5uZGsuc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgc2lnbmVyIG5vdCBzZXRcIik7XG4gICAgaWYgKGVuY3J5cHRlZCkge1xuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci51c2VyKCk7XG4gICAgICBjb25zdCBjdXJyZW50TGlzdCA9IGF3YWl0IHRoaXMuZW5jcnlwdGVkVGFncygpO1xuICAgICAgY3VycmVudExpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHRoaXMuX2VuY3J5cHRlZFRhZ3MgPSBjdXJyZW50TGlzdDtcbiAgICAgIHRoaXMuZW5jcnlwdGVkVGFnc0xlbmd0aCA9IHRoaXMuY29udGVudC5sZW5ndGg7XG4gICAgICB0aGlzLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShjdXJyZW50TGlzdCk7XG4gICAgICBhd2FpdCB0aGlzLmVuY3J5cHQodXNlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZWRfYXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpO1xuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBoYXMoaXRlbSkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLnNvbWUoKHRhZykgPT4gdGFnWzFdID09PSBpdGVtKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZpbHRlciB0aGF0IHdpbGwgcmVzdWx0IGluIGZldGNoaW5nXG4gICAqIHRoZSBpdGVtcyBvZiB0aGlzIGxpc3RcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgbGlzdCA9IG5ldyBOREtMaXN0KC4uLik7XG4gICAqIGNvbnN0IGZpbHRlcnMgPSBsaXN0LmZpbHRlckZvckl0ZW1zKCk7XG4gICAqIGNvbnN0IGV2ZW50cyA9IGF3YWl0IG5kay5mZXRjaEV2ZW50cyhmaWx0ZXJzKTtcbiAgICovXG4gIGZpbHRlckZvckl0ZW1zKCkge1xuICAgIGNvbnN0IGlkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgbmlwMzNRdWVyaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBmaWx0ZXJzID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy5pdGVtcykge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgJiYgdGFnWzFdKSB7XG4gICAgICAgIGlkcy5hZGQodGFnWzFdKTtcbiAgICAgIH0gZWxzZSBpZiAodGFnWzBdID09PSBcImFcIiAmJiB0YWdbMV0pIHtcbiAgICAgICAgY29uc3QgW2tpbmQsIHB1YmtleSwgZFRhZ10gPSB0YWdbMV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICBpZiAoIWtpbmQgfHwgIXB1YmtleSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IGtleSA9IGAke2tpbmR9OiR7cHVia2V5fWA7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBuaXAzM1F1ZXJpZXMuZ2V0KGtleSkgfHwgW107XG4gICAgICAgIGl0ZW0ucHVzaChkVGFnIHx8IFwiXCIpO1xuICAgICAgICBuaXAzM1F1ZXJpZXMuc2V0KGtleSwgaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpZHMuc2l6ZSA+IDApIHtcbiAgICAgIGZpbHRlcnMucHVzaCh7IGlkczogQXJyYXkuZnJvbShpZHMpIH0pO1xuICAgIH1cbiAgICBpZiAobmlwMzNRdWVyaWVzLnNpemUgPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgbmlwMzNRdWVyaWVzLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBba2luZCwgcHVia2V5XSA9IGtleS5zcGxpdChcIjpcIik7XG4gICAgICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICAgICAga2luZHM6IFtOdW1iZXIucGFyc2VJbnQoa2luZCldLFxuICAgICAgICAgIGF1dGhvcnM6IFtwdWJrZXldLFxuICAgICAgICAgIFwiI2RcIjogdmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlsdGVycztcbiAgfVxufTtcbnZhciBsaXN0c19kZWZhdWx0ID0gTkRLTGlzdDtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9udXR6YXAvaW5kZXgudHNcbmltcG9ydCBkZWJ1ZzMgZnJvbSBcImRlYnVnXCI7XG52YXIgTkRLTnV0emFwID0gY2xhc3MgX05ES051dHphcCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgZGVidWc7XG4gIF9wcm9vZnMgPSBbXTtcbiAgc3RhdGljIGtpbmQgPSA5MzIxIC8qIE51dHphcCAqLztcbiAgc3RhdGljIGtpbmRzID0gW19OREtOdXR6YXAua2luZF07XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcihuZGssIGV2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDkzMjEgLyogTnV0emFwICovO1xuICAgIHRoaXMuZGVidWcgPSBuZGs/LmRlYnVnLmV4dGVuZChcIm51dHphcFwiKSA/PyBkZWJ1ZzMoXCJuZGs6bnV0emFwXCIpO1xuICAgIGlmICghdGhpcy5hbHQpIHRoaXMuYWx0ID0gXCJUaGlzIGlzIGEgbnV0emFwXCI7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb29mVGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicHJvb2ZcIik7XG4gICAgICBpZiAocHJvb2ZUYWdzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9wcm9vZnMgPSBwcm9vZlRhZ3MubWFwKCh0YWcpID0+IEpTT04ucGFyc2UodGFnWzFdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wcm9vZnMgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgY29uc3QgZSA9IG5ldyBfTkRLTnV0emFwKGV2ZW50Lm5kaywgZXZlbnQpO1xuICAgIGlmICghZS5fcHJvb2ZzIHx8ICFlLl9wcm9vZnMubGVuZ3RoKSByZXR1cm47XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgc2V0IGNvbW1lbnQoY29tbWVudCkge1xuICAgIHRoaXMuY29udGVudCA9IGNvbW1lbnQgPz8gXCJcIjtcbiAgfVxuICBnZXQgY29tbWVudCgpIHtcbiAgICBjb25zdCBjID0gdGhpcy50YWdWYWx1ZShcImNvbW1lbnRcIik7XG4gICAgaWYgKGMpIHJldHVybiBjO1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gIH1cbiAgc2V0IHByb29mcyhwcm9vZnMpIHtcbiAgICB0aGlzLl9wcm9vZnMgPSBwcm9vZnM7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwicHJvb2ZcIik7XG4gICAgZm9yIChjb25zdCBwcm9vZiBvZiBwcm9vZnMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInByb29mXCIsIEpTT04uc3RyaW5naWZ5KHByb29mKV0pO1xuICAgIH1cbiAgfVxuICBnZXQgcHJvb2ZzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9vZnM7XG4gIH1cbiAgZ2V0IHJhd1AycGsoKSB7XG4gICAgY29uc3QgZmlyc3RQcm9vZiA9IHRoaXMucHJvb2ZzWzBdO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZWNyZXQgPSBKU09OLnBhcnNlKGZpcnN0UHJvb2Yuc2VjcmV0KTtcbiAgICAgIGxldCBwYXlsb2FkO1xuICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2Uoc2VjcmV0KTtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcInN0cmluZ2lmaWVkIHBheWxvYWRcIiwgZmlyc3RQcm9vZi5zZWNyZXQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VjcmV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHBheWxvYWQgPSBzZWNyZXQ7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiBwYXlsb2FkWzBdID09PSBcIlAyUEtcIiAmJiBwYXlsb2FkLmxlbmd0aCA+IDEgJiYgdHlwZW9mIHBheWxvYWRbMV0gPT09IFwib2JqZWN0XCIgJiYgcGF5bG9hZFsxXSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcGF5bG9hZFsxXS5kYXRhO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSBcIm9iamVjdFwiICYmIHBheWxvYWQgIT09IG51bGwgJiYgdHlwZW9mIHBheWxvYWRbMV0/LmRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHBheWxvYWRbMV0uZGF0YTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiZXJyb3IgcGFyc2luZyBwMnBrIHB1YmtleVwiLCBlLCB0aGlzLnByb29mc1swXSk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHAycGsgcHVia2V5IHRoYXQgaXMgZW1iZWRkZWQgaW4gdGhlIGZpcnN0IHByb29mLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIGEgbm9zdHIgcHVia2V5LCBub3QgYSBjYXNodSBwdWJrZXkgKG5vIFwiMDJcIiBwcmVmaXgpXG4gICAqL1xuICBnZXQgcDJwaygpIHtcbiAgICBjb25zdCByYXdQMnBrID0gdGhpcy5yYXdQMnBrO1xuICAgIGlmICghcmF3UDJwaykgcmV0dXJuO1xuICAgIHJldHVybiByYXdQMnBrLnN0YXJ0c1dpdGgoXCIwMlwiKSA/IHJhd1AycGsuc2xpY2UoMikgOiByYXdQMnBrO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbnQgd2hlcmUgdGhpcyBudXR6YXAgcHJvb2ZzIGV4aXN0XG4gICAqL1xuICBnZXQgbWludCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInVcIik7XG4gIH1cbiAgc2V0IG1pbnQodmFsdWUpIHtcbiAgICB0aGlzLnJlcGxhY2VUYWcoW1widVwiLCB2YWx1ZV0pO1xuICB9XG4gIGdldCB1bml0KCkge1xuICAgIGxldCBfdW5pdCA9IHRoaXMudGFnVmFsdWUoXCJ1bml0XCIpID8/IFwic2F0XCI7XG4gICAgaWYgKF91bml0Py5zdGFydHNXaXRoKFwibXNhdFwiKSkgX3VuaXQgPSBcInNhdFwiO1xuICAgIHJldHVybiBfdW5pdDtcbiAgfVxuICBzZXQgdW5pdCh2YWx1ZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidW5pdFwiKTtcbiAgICBpZiAodmFsdWU/LnN0YXJ0c1dpdGgoXCJtc2F0XCIpKSB0aHJvdyBuZXcgRXJyb3IoXCJtc2F0IGlzIG5vdCBhbGxvd2VkLCB1c2Ugc2F0IGRlbm9taW5hdGlvbiBpbnN0ZWFkXCIpO1xuICAgIGlmICh2YWx1ZSkgdGhpcy50YWcoW1widW5pdFwiLCB2YWx1ZV0pO1xuICB9XG4gIGdldCBhbW91bnQoKSB7XG4gICAgY29uc3QgYW1vdW50ID0gdGhpcy5wcm9vZnMucmVkdWNlKCh0b3RhbCwgcHJvb2YpID0+IHRvdGFsICsgcHJvb2YuYW1vdW50LCAwKTtcbiAgICByZXR1cm4gYW1vdW50O1xuICB9XG4gIHNlbmRlciA9IHRoaXMuYXV0aG9yO1xuICAvKipcbiAgICogU2V0IHRoZSB0YXJnZXQgb2YgdGhlIG51dHphcFxuICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2YgdGhlIG51dHphcCAoYSB1c2VyIG9yIGFuIGV2ZW50KVxuICAgKi9cbiAgc2V0IHRhcmdldCh0YXJnZXQpIHtcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0KSA9PiB0WzBdICE9PSBcInBcIik7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIE5ES0V2ZW50KSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaCh0YXJnZXQudGFnUmVmZXJlbmNlKCkpO1xuICAgIH1cbiAgfVxuICBzZXQgcmVjaXBpZW50UHVia2V5KHB1YmtleSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicFwiKTtcbiAgICB0aGlzLnRhZyhbXCJwXCIsIHB1YmtleV0pO1xuICB9XG4gIGdldCByZWNpcGllbnRQdWJrZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJwXCIpO1xuICB9XG4gIGdldCByZWNpcGllbnQoKSB7XG4gICAgY29uc3QgcHVia2V5ID0gdGhpcy5yZWNpcGllbnRQdWJrZXk7XG4gICAgaWYgKHRoaXMubmRrKSByZXR1cm4gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleSB9KTtcbiAgICByZXR1cm4gbmV3IE5ES1VzZXIoeyBwdWJrZXkgfSk7XG4gIH1cbiAgYXN5bmMgdG9Ob3N0ckV2ZW50KCkge1xuICAgIGlmICh0aGlzLnVuaXQgPT09IFwibXNhdFwiKSB7XG4gICAgICB0aGlzLnVuaXQgPSBcInNhdFwiO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZVRhZyhcImFtb3VudFwiKTtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJhbW91bnRcIiwgdGhpcy5hbW91bnQudG9TdHJpbmcoKV0pO1xuICAgIGNvbnN0IGV2ZW50ID0gYXdhaXQgc3VwZXIudG9Ob3N0ckV2ZW50KCk7XG4gICAgZXZlbnQuY29udGVudCA9IHRoaXMuY29tbWVudDtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBudXR6YXAgY29uZm9ybXMgdG8gTklQLTYxXG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICBsZXQgZVRhZ0NvdW50ID0gMDtcbiAgICBsZXQgcFRhZ0NvdW50ID0gMDtcbiAgICBsZXQgbWludFRhZ0NvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLnRhZ3MpIHtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwiZVwiKSBlVGFnQ291bnQrKztcbiAgICAgIGlmICh0YWdbMF0gPT09IFwicFwiKSBwVGFnQ291bnQrKztcbiAgICAgIGlmICh0YWdbMF0gPT09IFwidVwiKSBtaW50VGFnQ291bnQrKztcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIC8vIGV4YWN0bHkgb25lIHJlY2lwaWVudCBhbmQgbWludFxuICAgICAgcFRhZ0NvdW50ID09PSAxICYmIG1pbnRUYWdDb3VudCA9PT0gMSAmJiAvLyBtdXN0IGhhdmUgYXQgbW9zdCBvbmUgZSB0YWdcbiAgICAgIGVUYWdDb3VudCA8PSAxICYmIC8vIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgcHJvb2ZcbiAgICAgIHRoaXMucHJvb2ZzLmxlbmd0aCA+IDBcbiAgICApO1xuICB9XG59O1xuZnVuY3Rpb24gcHJvb2ZQMnBrKHByb29mKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2VjcmV0ID0gSlNPTi5wYXJzZShwcm9vZi5zZWNyZXQpO1xuICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgaWYgKHR5cGVvZiBzZWNyZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKHNlY3JldCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VjcmV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBwYXlsb2FkID0gc2VjcmV0O1xuICAgIH1cbiAgICBjb25zdCBpc1AyUEtMb2NrZWQgPSBwYXlsb2FkWzBdID09PSBcIlAyUEtcIiAmJiBwYXlsb2FkWzFdPy5kYXRhO1xuICAgIGlmIChpc1AyUEtMb2NrZWQpIHtcbiAgICAgIHJldHVybiBwYXlsb2FkWzFdLmRhdGE7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcImVycm9yIHBhcnNpbmcgcDJwayBwdWJrZXlcIiwgZSwgcHJvb2YpO1xuICB9XG59XG5mdW5jdGlvbiBwcm9vZlAycGtOb3N0cihwcm9vZikge1xuICBjb25zdCBwMnBrID0gcHJvb2ZQMnBrKHByb29mKTtcbiAgaWYgKCFwMnBrKSByZXR1cm47XG4gIGlmIChwMnBrLnN0YXJ0c1dpdGgoXCIwMlwiKSAmJiBwMnBrLmxlbmd0aCA9PT0gNjYpIHJldHVybiBwMnBrLnNsaWNlKDIpO1xuICByZXR1cm4gcDJwaztcbn1cbmZ1bmN0aW9uIGNhc2h1UHVia2V5VG9Ob3N0clB1YmtleShjYXNodVB1YmtleSkge1xuICBpZiAoY2FzaHVQdWJrZXkuc3RhcnRzV2l0aChcIjAyXCIpICYmIGNhc2h1UHVia2V5Lmxlbmd0aCA9PT0gNjYpIHJldHVybiBjYXNodVB1YmtleS5zbGljZSgyKTtcbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gc3JjL2V2ZW50cy9raW5kcy9zaW1wbGUtZ3JvdXAvbWVtYmVyLWxpc3QudHNcbnZhciBOREtTaW1wbGVHcm91cE1lbWJlckxpc3QgPSBjbGFzcyBfTkRLU2ltcGxlR3JvdXBNZW1iZXJMaXN0IGV4dGVuZHMgTkRLRXZlbnQge1xuICByZWxheVNldDtcbiAgbWVtYmVyU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgc3RhdGljIGtpbmQgPSAzOTAwMiAvKiBHcm91cE1lbWJlcnMgKi87XG4gIHN0YXRpYyBraW5kcyA9IFszOTAwMiAvKiBHcm91cE1lbWJlcnMgKi9dO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzOTAwMiAvKiBHcm91cE1lbWJlcnMgKi87XG4gICAgdGhpcy5tZW1iZXJTZXQgPSBuZXcgU2V0KHRoaXMubWVtYmVycyk7XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtTaW1wbGVHcm91cE1lbWJlckxpc3QoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgZ2V0IG1lbWJlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKS5tYXAoKHRhZykgPT4gdGFnWzFdKTtcbiAgfVxuICBoYXNNZW1iZXIobWVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMubWVtYmVyU2V0LmhhcyhtZW1iZXIpO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2gocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KSB7XG4gICAgcmVsYXlTZXQgPz89IHRoaXMucmVsYXlTZXQ7XG4gICAgcmV0dXJuIHN1cGVyLnB1Ymxpc2hSZXBsYWNlYWJsZShyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3NpbXBsZS1ncm91cC9tZXRhZGF0YS50c1xudmFyIE5ES1NpbXBsZUdyb3VwTWV0YWRhdGEgPSBjbGFzcyBfTkRLU2ltcGxlR3JvdXBNZXRhZGF0YSBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGtpbmQgPSAzOWUzIC8qIEdyb3VwTWV0YWRhdGEgKi87XG4gIHN0YXRpYyBraW5kcyA9IFszOWUzIC8qIEdyb3VwTWV0YWRhdGEgKi9dO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzOWUzIC8qIEdyb3VwTWV0YWRhdGEgKi87XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtTaW1wbGVHcm91cE1ldGFkYXRhKGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwibmFtZVwiKTtcbiAgfVxuICBnZXQgcGljdHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInBpY3R1cmVcIik7XG4gIH1cbiAgZ2V0IGFib3V0KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiYWJvdXRcIik7XG4gIH1cbiAgZ2V0IHNjb3BlKCkge1xuICAgIGlmICh0aGlzLmdldE1hdGNoaW5nVGFncyhcInB1YmxpY1wiKS5sZW5ndGggPiAwKSByZXR1cm4gXCJwdWJsaWNcIjtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwdWJsaWNcIikubGVuZ3RoID4gMCkgcmV0dXJuIFwicHJpdmF0ZVwiO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgc2V0IHNjb3BlKHNjb3BlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwdWJsaWNcIik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwcml2YXRlXCIpO1xuICAgIGlmIChzY29wZSA9PT0gXCJwdWJsaWNcIikge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicHVibGljXCIsIFwiXCJdKTtcbiAgICB9IGVsc2UgaWYgKHNjb3BlID09PSBcInByaXZhdGVcIikge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicHJpdmF0ZVwiLCBcIlwiXSk7XG4gICAgfVxuICB9XG4gIGdldCBhY2Nlc3MoKSB7XG4gICAgaWYgKHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwib3BlblwiKS5sZW5ndGggPiAwKSByZXR1cm4gXCJvcGVuXCI7XG4gICAgaWYgKHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiY2xvc2VkXCIpLmxlbmd0aCA+IDApIHJldHVybiBcImNsb3NlZFwiO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgc2V0IGFjY2VzcyhhY2Nlc3MpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcIm9wZW5cIik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJjbG9zZWRcIik7XG4gICAgaWYgKGFjY2VzcyA9PT0gXCJvcGVuXCIpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcIm9wZW5cIiwgXCJcIl0pO1xuICAgIH0gZWxzZSBpZiAoYWNjZXNzID09PSBcImNsb3NlZFwiKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJjbG9zZWRcIiwgXCJcIl0pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9zdG9yeS50c1xudmFyIE5ES1N0b3J5U3RpY2tlclR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChOREtTdG9yeVN0aWNrZXJUeXBlMikgPT4ge1xuICBOREtTdG9yeVN0aWNrZXJUeXBlMltcIlB1YmtleVwiXSA9IFwicHVia2V5XCI7XG4gIE5ES1N0b3J5U3RpY2tlclR5cGUyW1wiRXZlbnRcIl0gPSBcImV2ZW50XCI7XG4gIE5ES1N0b3J5U3RpY2tlclR5cGUyW1wiUHJvbXB0XCJdID0gXCJwcm9tcHRcIjtcbiAgTkRLU3RvcnlTdGlja2VyVHlwZTJbXCJUZXh0XCJdID0gXCJ0ZXh0XCI7XG4gIE5ES1N0b3J5U3RpY2tlclR5cGUyW1wiQ291bnRkb3duXCJdID0gXCJjb3VudGRvd25cIjtcbiAgcmV0dXJuIE5ES1N0b3J5U3RpY2tlclR5cGUyO1xufSkoTkRLU3RvcnlTdGlja2VyVHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBzdHJUb1Bvc2l0aW9uKHBvc2l0aW9uU3RyKSB7XG4gIGNvbnN0IFt4LCB5XSA9IHBvc2l0aW9uU3RyLnNwbGl0KFwiLFwiKS5tYXAoTnVtYmVyKTtcbiAgcmV0dXJuIHsgeCwgeSB9O1xufVxuZnVuY3Rpb24gc3RyVG9EaW1lbnNpb24oZGltZW5zaW9uU3RyKSB7XG4gIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IGRpbWVuc2lvblN0ci5zcGxpdChcInhcIikubWFwKE51bWJlcik7XG4gIHJldHVybiB7IHdpZHRoLCBoZWlnaHQgfTtcbn1cbnZhciBOREtTdG9yeVN0aWNrZXIgPSBjbGFzcyBfTkRLU3RvcnlTdGlja2VyIHtcbiAgc3RhdGljIFRleHQgPSBcInRleHRcIiAvKiBUZXh0ICovO1xuICBzdGF0aWMgUHVia2V5ID0gXCJwdWJrZXlcIiAvKiBQdWJrZXkgKi87XG4gIHN0YXRpYyBFdmVudCA9IFwiZXZlbnRcIiAvKiBFdmVudCAqLztcbiAgc3RhdGljIFByb21wdCA9IFwicHJvbXB0XCIgLyogUHJvbXB0ICovO1xuICBzdGF0aWMgQ291bnRkb3duID0gXCJjb3VudGRvd25cIiAvKiBDb3VudGRvd24gKi87XG4gIHR5cGU7XG4gIHZhbHVlO1xuICBwb3NpdGlvbjtcbiAgZGltZW5zaW9uO1xuICBwcm9wZXJ0aWVzO1xuICBjb25zdHJ1Y3RvcihhcmcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICBjb25zdCB0YWcgPSBhcmc7XG4gICAgICBpZiAodGFnWzBdICE9PSBcInN0aWNrZXJcIiB8fCB0YWcubGVuZ3RoIDwgNSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0aWNrZXIgdGFnXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy50eXBlID0gdGFnWzFdO1xuICAgICAgdGhpcy52YWx1ZSA9IHRhZ1syXTtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBzdHJUb1Bvc2l0aW9uKHRhZ1szXSk7XG4gICAgICB0aGlzLmRpbWVuc2lvbiA9IHN0clRvRGltZW5zaW9uKHRhZ1s0XSk7XG4gICAgICBjb25zdCBwcm9wcyA9IHt9O1xuICAgICAgZm9yIChsZXQgaSA9IDU7IGkgPCB0YWcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSB0YWdbaV0uc3BsaXQoXCIgXCIpO1xuICAgICAgICBwcm9wc1trZXldID0gcmVzdC5qb2luKFwiIFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wcztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50eXBlID0gYXJnO1xuICAgICAgdGhpcy52YWx1ZSA9IHZvaWQgMDtcbiAgICAgIHRoaXMucG9zaXRpb24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgIHRoaXMuZGltZW5zaW9uID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmcm9tVGFnKHRhZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IF9OREtTdG9yeVN0aWNrZXIodGFnKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBnZXQgc3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcz8uc3R5bGU7XG4gIH1cbiAgc2V0IHN0eWxlKHN0eWxlKSB7XG4gICAgaWYgKHN0eWxlKSB0aGlzLnByb3BlcnRpZXMgPSB7IC4uLnRoaXMucHJvcGVydGllcywgc3R5bGUgfTtcbiAgICBlbHNlIGRlbGV0ZSB0aGlzLnByb3BlcnRpZXM/LnN0eWxlO1xuICB9XG4gIGdldCByb3RhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzPy5yb3QgPyBOdW1iZXIucGFyc2VGbG9hdCh0aGlzLnByb3BlcnRpZXMucm90KSA6IHZvaWQgMDtcbiAgfVxuICBzZXQgcm90YXRpb24ocm90YXRpb24pIHtcbiAgICBpZiAocm90YXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5wcm9wZXJ0aWVzID0geyAuLi50aGlzLnByb3BlcnRpZXMsIHJvdDogcm90YXRpb24udG9TdHJpbmcoKSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5wcm9wZXJ0aWVzPy5yb3Q7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHN0aWNrZXIgaXMgdmFsaWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgdGhlIHN0aWNrZXIgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc1ZhbGlkRGltZW5zaW9ucygpICYmIHRoaXMuaGFzVmFsaWRQb3NpdGlvbigpO1xuICB9XG4gIGhhc1ZhbGlkRGltZW5zaW9ucyA9ICgpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuZGltZW5zaW9uLndpZHRoID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB0aGlzLmRpbWVuc2lvbi5oZWlnaHQgPT09IFwibnVtYmVyXCIgJiYgIU51bWJlci5pc05hTih0aGlzLmRpbWVuc2lvbi53aWR0aCkgJiYgIU51bWJlci5pc05hTih0aGlzLmRpbWVuc2lvbi5oZWlnaHQpO1xuICB9O1xuICBoYXNWYWxpZFBvc2l0aW9uID0gKCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5wb3NpdGlvbi54ID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB0aGlzLnBvc2l0aW9uLnkgPT09IFwibnVtYmVyXCIgJiYgIU51bWJlci5pc05hTih0aGlzLnBvc2l0aW9uLngpICYmICFOdW1iZXIuaXNOYU4odGhpcy5wb3NpdGlvbi55KTtcbiAgfTtcbiAgdG9UYWcoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHtcbiAgICAgIGNvbnN0IGVycm9ycyA9IFtcbiAgICAgICAgIXRoaXMuaGFzVmFsaWREaW1lbnNpb25zKCkgPyBcImRpbWVuc2lvbnMgaXMgaW52YWxpZFwiIDogdm9pZCAwLFxuICAgICAgICAhdGhpcy5oYXNWYWxpZFBvc2l0aW9uKCkgPyBcInBvc2l0aW9uIGlzIGludmFsaWRcIiA6IHZvaWQgMFxuICAgICAgXS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RpY2tlcjogJHtlcnJvcnMuam9pbihcIiwgXCIpfWApO1xuICAgIH1cbiAgICBsZXQgdmFsdWU7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJldmVudFwiIC8qIEV2ZW50ICovOlxuICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWUudGFnSWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicHVia2V5XCIgLyogUHVia2V5ICovOlxuICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWUucHVia2V5O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgdGFnID0gW1wic3RpY2tlclwiLCB0aGlzLnR5cGUsIHZhbHVlLCBjb29yZGluYXRlcyh0aGlzLnBvc2l0aW9uKSwgZGltZW5zaW9uKHRoaXMuZGltZW5zaW9uKV07XG4gICAgaWYgKHRoaXMucHJvcGVydGllcykge1xuICAgICAgZm9yIChjb25zdCBba2V5LCBwcm9wVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMucHJvcGVydGllcykpIHtcbiAgICAgICAgdGFnLnB1c2goYCR7a2V5fSAke3Byb3BWYWx1ZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhZztcbiAgfVxufTtcbnZhciBOREtTdG9yeSA9IGNsYXNzIF9OREtTdG9yeSBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGtpbmQgPSAyMyAvKiBTdG9yeSAqLztcbiAgc3RhdGljIGtpbmRzID0gWzIzIC8qIFN0b3J5ICovXTtcbiAgX2ltZXRhO1xuICBfZGltZW5zaW9ucztcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMjMgLyogU3RvcnkgKi87XG4gICAgaWYgKHJhd0V2ZW50KSB7XG4gICAgICBmb3IgKGNvbnN0IHRhZyBvZiByYXdFdmVudC50YWdzKSB7XG4gICAgICAgIHN3aXRjaCAodGFnWzBdKSB7XG4gICAgICAgICAgY2FzZSBcImltZXRhXCI6XG4gICAgICAgICAgICB0aGlzLl9pbWV0YSA9IG1hcEltZXRhVGFnKHRhZyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZGltXCI6XG4gICAgICAgICAgICB0aGlzLmRpbWVuc2lvbnMgPSBzdHJUb0RpbWVuc2lvbih0YWdbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOREtTdG9yeSBmcm9tIGFuIGV4aXN0aW5nIE5ES0V2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgTkRLRXZlbnQgdG8gY3JlYXRlIHRoZSBOREtTdG9yeSBmcm9tLlxuICAgKiBAcmV0dXJucyBOREtTdG9yeVxuICAgKi9cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtTdG9yeShldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBzdG9yeSBpcyB2YWxpZCAoaGFzIGV4YWN0bHkgb25lIGltZXRhIHRhZykuXG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmltZXRhO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBmaXJzdCBpbWV0YSB0YWcgKHRoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSkuXG4gICAqL1xuICBnZXQgaW1ldGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ltZXRhO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgc2luZ2xlIGltZXRhIHRhZywgcmVwbGFjaW5nIGFueSBleGlzdGluZyBvbmVzLlxuICAgKi9cbiAgc2V0IGltZXRhKHRhZykge1xuICAgIHRoaXMuX2ltZXRhID0gdGFnO1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+IHRbMF0gIT09IFwiaW1ldGFcIik7XG4gICAgaWYgKHRhZykge1xuICAgICAgdGhpcy50YWdzLnB1c2goaW1ldGFUYWdUb1RhZyh0YWcpKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIHN0b3J5IGRpbWVuc2lvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtOREtTdG9yeURpbWVuc2lvbiB8IHVuZGVmaW5lZH0gLSBUaGUgc3RvcnkgZGltZW5zaW9ucyBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgZGltZW5zaW9ucygpIHtcbiAgICBjb25zdCBkaW1UYWcgPSB0aGlzLnRhZ1ZhbHVlKFwiZGltXCIpO1xuICAgIGlmICghZGltVGFnKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBzdHJUb0RpbWVuc2lvbihkaW1UYWcpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBzdG9yeSBkaW1lbnNpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge05ES1N0b3J5RGltZW5zaW9uIHwgdW5kZWZpbmVkfSBkaW1lbnNpb25zIC0gVGhlIGRpbWVuc2lvbnMgdG8gc2V0IGZvciB0aGUgc3RvcnkuXG4gICAqL1xuICBzZXQgZGltZW5zaW9ucyhkaW1lbnNpb25zKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkaW1cIik7XG4gICAgaWYgKGRpbWVuc2lvbnMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcImRpbVwiLCBgJHtkaW1lbnNpb25zLndpZHRofXgke2RpbWVuc2lvbnMuaGVpZ2h0fWBdKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIHN0b3J5IGR1cmF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfSAtIFRoZSBzdG9yeSBkdXJhdGlvbiBpbiBzZWNvbmRzIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBkdXJhdGlvbigpIHtcbiAgICBjb25zdCBkdXJUYWcgPSB0aGlzLnRhZ1ZhbHVlKFwiZHVyXCIpO1xuICAgIGlmICghZHVyVGFnKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQoZHVyVGFnKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgc3RvcnkgZHVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBkdXJhdGlvbiAtIFRoZSBkdXJhdGlvbiBpbiBzZWNvbmRzIHRvIHNldCBmb3IgdGhlIHN0b3J5LlxuICAgKi9cbiAgc2V0IGR1cmF0aW9uKGR1cmF0aW9uKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkdXJcIik7XG4gICAgaWYgKGR1cmF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcImR1clwiLCBkdXJhdGlvbi50b1N0cmluZygpXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXRzIGFsbCBzdGlja2VycyBmcm9tIHRoZSBzdG9yeS5cbiAgICpcbiAgICogQHJldHVybnMge05ES1N0b3J5U3RpY2tlcltdfSAtIEFycmF5IG9mIHN0aWNrZXJzIGluIHRoZSBzdG9yeS5cbiAgICovXG4gIGdldCBzdGlja2VycygpIHtcbiAgICBjb25zdCBzdGlja2VycyA9IFtdO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgaWYgKHRhZ1swXSAhPT0gXCJzdGlja2VyXCIgfHwgdGFnLmxlbmd0aCA8IDUpIGNvbnRpbnVlO1xuICAgICAgY29uc3Qgc3RpY2tlciA9IE5ES1N0b3J5U3RpY2tlci5mcm9tVGFnKHRhZyk7XG4gICAgICBpZiAoc3RpY2tlcikgc3RpY2tlcnMucHVzaChzdGlja2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0aWNrZXJzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgc3RpY2tlciB0byB0aGUgc3RvcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7TkRLU3RvcnlTdGlja2VyfFN0b3J5U3RpY2tlcn0gc3RpY2tlciAtIFRoZSBzdGlja2VyIHRvIGFkZC5cbiAgICovXG4gIGFkZFN0aWNrZXIoc3RpY2tlcikge1xuICAgIGxldCBzdGlja2VyVG9BZGQ7XG4gICAgaWYgKHN0aWNrZXIgaW5zdGFuY2VvZiBOREtTdG9yeVN0aWNrZXIpIHtcbiAgICAgIHN0aWNrZXJUb0FkZCA9IHN0aWNrZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRhZyA9IFtcbiAgICAgICAgXCJzdGlja2VyXCIsXG4gICAgICAgIHN0aWNrZXIudHlwZSxcbiAgICAgICAgdHlwZW9mIHN0aWNrZXIudmFsdWUgPT09IFwic3RyaW5nXCIgPyBzdGlja2VyLnZhbHVlIDogXCJcIixcbiAgICAgICAgY29vcmRpbmF0ZXMoc3RpY2tlci5wb3NpdGlvbiksXG4gICAgICAgIGRpbWVuc2lvbihzdGlja2VyLmRpbWVuc2lvbilcbiAgICAgIF07XG4gICAgICBpZiAoc3RpY2tlci5wcm9wZXJ0aWVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHN0aWNrZXIucHJvcGVydGllcykpIHtcbiAgICAgICAgICB0YWcucHVzaChgJHtrZXl9ICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0aWNrZXJUb0FkZCA9IG5ldyBOREtTdG9yeVN0aWNrZXIodGFnKTtcbiAgICAgIHN0aWNrZXJUb0FkZC52YWx1ZSA9IHN0aWNrZXIudmFsdWU7XG4gICAgfVxuICAgIGlmIChzdGlja2VyVG9BZGQudHlwZSA9PT0gXCJwdWJrZXlcIiAvKiBQdWJrZXkgKi8pIHtcbiAgICAgIHRoaXMudGFnKHN0aWNrZXJUb0FkZC52YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChzdGlja2VyVG9BZGQudHlwZSA9PT0gXCJldmVudFwiIC8qIEV2ZW50ICovKSB7XG4gICAgICB0aGlzLnRhZyhzdGlja2VyVG9BZGQudmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLnRhZ3MucHVzaChzdGlja2VyVG9BZGQudG9UYWcoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBzdGlja2VyIGZyb20gdGhlIHN0b3J5LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHN0aWNrZXIgdG8gcmVtb3ZlLlxuICAgKi9cbiAgcmVtb3ZlU3RpY2tlcihpbmRleCkge1xuICAgIGNvbnN0IHN0aWNrZXJzID0gdGhpcy5zdGlja2VycztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHN0aWNrZXJzLmxlbmd0aCkgcmV0dXJuO1xuICAgIGxldCBzdGlja2VyQ291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy50YWdzW2ldWzBdID09PSBcInN0aWNrZXJcIikge1xuICAgICAgICBpZiAoc3RpY2tlckNvdW50ID09PSBpbmRleCkge1xuICAgICAgICAgIHRoaXMudGFncy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RpY2tlckNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIGNvb3JkaW5hdGVzID0gKHBvc2l0aW9uKSA9PiBgJHtwb3NpdGlvbi54fSwke3Bvc2l0aW9uLnl9YDtcbnZhciBkaW1lbnNpb24gPSAoZGltZW5zaW9uMikgPT4gYCR7ZGltZW5zaW9uMi53aWR0aH14JHtkaW1lbnNpb24yLmhlaWdodH1gO1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3N1YnNjcmlwdGlvbnMvYW1vdW50LnRzXG52YXIgcG9zc2libGVJbnRlcnZhbEZyZXF1ZW5jaWVzID0gW1xuICBcImRhaWx5XCIsXG4gIFwid2Vla2x5XCIsXG4gIFwibW9udGhseVwiLFxuICBcInF1YXJ0ZXJseVwiLFxuICBcInllYXJseVwiXG5dO1xuZnVuY3Rpb24gY2FsY3VsYXRlVGVybUR1cmF0aW9uSW5TZWNvbmRzKHRlcm0pIHtcbiAgc3dpdGNoICh0ZXJtKSB7XG4gICAgY2FzZSBcImRhaWx5XCI6XG4gICAgICByZXR1cm4gMjQgKiA2MCAqIDYwO1xuICAgIGNhc2UgXCJ3ZWVrbHlcIjpcbiAgICAgIHJldHVybiA3ICogMjQgKiA2MCAqIDYwO1xuICAgIGNhc2UgXCJtb250aGx5XCI6XG4gICAgICByZXR1cm4gMzAgKiAyNCAqIDYwICogNjA7XG4gICAgY2FzZSBcInF1YXJ0ZXJseVwiOlxuICAgICAgcmV0dXJuIDMgKiAzMCAqIDI0ICogNjAgKiA2MDtcbiAgICBjYXNlIFwieWVhcmx5XCI6XG4gICAgICByZXR1cm4gMzY1ICogMjQgKiA2MCAqIDYwO1xuICB9XG59XG5mdW5jdGlvbiBuZXdBbW91bnQoYW1vdW50LCBjdXJyZW5jeSwgdGVybSkge1xuICByZXR1cm4gW1wiYW1vdW50XCIsIGFtb3VudC50b1N0cmluZygpLCBjdXJyZW5jeSwgdGVybV07XG59XG5mdW5jdGlvbiBwYXJzZVRhZ1RvU3Vic2NyaXB0aW9uQW1vdW50KHRhZykge1xuICBjb25zdCBhbW91bnQgPSBOdW1iZXIucGFyc2VJbnQodGFnWzFdKTtcbiAgaWYgKE51bWJlci5pc05hTihhbW91bnQpIHx8IGFtb3VudCA9PT0gdm9pZCAwIHx8IGFtb3VudCA9PT0gbnVsbCB8fCBhbW91bnQgPD0gMCkgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgY3VycmVuY3kgPSB0YWdbMl07XG4gIGlmIChjdXJyZW5jeSA9PT0gdm9pZCAwIHx8IGN1cnJlbmN5ID09PSBcIlwiKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCB0ZXJtID0gdGFnWzNdO1xuICBpZiAodGVybSA9PT0gdm9pZCAwKSByZXR1cm4gdm9pZCAwO1xuICBpZiAoIXBvc3NpYmxlSW50ZXJ2YWxGcmVxdWVuY2llcy5pbmNsdWRlcyh0ZXJtKSkgcmV0dXJuIHZvaWQgMDtcbiAgcmV0dXJuIHtcbiAgICBhbW91bnQsXG4gICAgY3VycmVuY3ksXG4gICAgdGVybVxuICB9O1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3N1YnNjcmlwdGlvbnMvdGllci50c1xudmFyIE5ES1N1YnNjcmlwdGlvblRpZXIgPSBjbGFzcyBfTkRLU3Vic2NyaXB0aW9uVGllciBleHRlbmRzIE5ES0FydGljbGUge1xuICBzdGF0aWMga2luZCA9IDM3MDAxIC8qIFN1YnNjcmlwdGlvblRpZXIgKi87XG4gIHN0YXRpYyBraW5kcyA9IFszNzAwMSAvKiBTdWJzY3JpcHRpb25UaWVyICovXTtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIGNvbnN0IGsgPSByYXdFdmVudD8ua2luZCA/PyAzNzAwMSAvKiBTdWJzY3JpcHRpb25UaWVyICovO1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA9IGs7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgTkRLU3Vic2NyaXB0aW9uVGllciBmcm9tIGFuIGV2ZW50XG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcmV0dXJucyBOREtTdWJzY3JpcHRpb25UaWVyXG4gICAqL1xuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1N1YnNjcmlwdGlvblRpZXIoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgcGVya3MgZm9yIHRoaXMgdGllclxuICAgKi9cbiAgZ2V0IHBlcmtzKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBlcmtcIikubWFwKCh0YWcpID0+IHRhZ1sxXSkuZmlsdGVyKChwZXJrKSA9PiBwZXJrICE9PSB2b2lkIDApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcGVyayB0byB0aGlzIHRpZXJcbiAgICovXG4gIGFkZFBlcmsocGVyaykge1xuICAgIHRoaXMudGFncy5wdXNoKFtcInBlcmtcIiwgcGVya10pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhbW91bnQgZm9yIHRoaXMgdGllclxuICAgKi9cbiAgZ2V0IGFtb3VudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiYW1vdW50XCIpLm1hcCgodGFnKSA9PiBwYXJzZVRhZ1RvU3Vic2NyaXB0aW9uQW1vdW50KHRhZykpLmZpbHRlcigoYSkgPT4gYSAhPT0gdm9pZCAwKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBhbW91bnQgdG8gdGhpcyB0aWVyXG4gICAqIEBwYXJhbSBhbW91bnQgQW1vdW50IGluIHRoZSBzbWFsbGVzdCB1bml0IG9mIHRoZSBjdXJyZW5jeSAoZS5nLiBjZW50cywgbXNhdHMpXG4gICAqIEBwYXJhbSBjdXJyZW5jeSBDdXJyZW5jeSBjb2RlLiBVc2UgbXNhdCBmb3IgbWlsbGlzYXRvc2hpc1xuICAgKiBAcGFyYW0gdGVybSBPbmUgb2YgZGFpbHksIHdlZWtseSwgbW9udGhseSwgcXVhcnRlcmx5LCB5ZWFybHlcbiAgICovXG4gIGFkZEFtb3VudChhbW91bnQsIGN1cnJlbmN5LCB0ZXJtKSB7XG4gICAgdGhpcy50YWdzLnB1c2gobmV3QW1vdW50KGFtb3VudCwgY3VycmVuY3ksIHRlcm0pKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhIHJlbGF5IHdoZXJlIGNvbnRlbnQgcmVsYXRlZCB0byB0aGlzIHRpZXIgY2FuIGJlIGZvdW5kXG4gICAqIEBwYXJhbSByZWxheVVybCBVUkwgb2YgdGhlIHJlbGF5XG4gICAqL1xuICBzZXQgcmVsYXlVcmwocmVsYXlVcmwpIHtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJyXCIsIHJlbGF5VXJsXSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlbGF5IFVSTHMgZm9yIHRoaXMgdGllclxuICAgKi9cbiAgZ2V0IHJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJyXCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pLmZpbHRlcigocmVsYXkpID0+IHJlbGF5ICE9PSB2b2lkIDApO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2ZXJpZmllciBwdWJrZXkgZm9yIHRoaXMgdGllci4gVGhpcyBpcyB0aGUgcHVia2V5IHRoYXQgd2lsbCBnZW5lcmF0ZVxuICAgKiBzdWJzY3JpcHRpb24gcGF5bWVudCByZWNlaXB0c1xuICAgKi9cbiAgZ2V0IHZlcmlmaWVyUHVia2V5KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwicFwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdmVyaWZpZXIgcHVia2V5IGZvciB0aGlzIHRpZXIuXG4gICAqL1xuICBzZXQgdmVyaWZpZXJQdWJrZXkocHVia2V5KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwXCIpO1xuICAgIGlmIChwdWJrZXkpIHRoaXMudGFncy5wdXNoKFtcInBcIiwgcHVia2V5XSk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIHRpZXIgaXMgdmFsaWRcbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLnRpdGxlICE9PSB2b2lkIDAgJiYgLy8gTXVzdCBoYXZlIGEgdGl0bGVcbiAgICB0aGlzLmFtb3VudHMubGVuZ3RoID4gMDtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy92aWRlby50c1xudmFyIE5ES1ZpZGVvID0gY2xhc3MgX05ES1ZpZGVvIGV4dGVuZHMgTkRLRXZlbnQge1xuICBzdGF0aWMga2luZCA9IDIxIC8qIFZpZGVvICovO1xuICBzdGF0aWMga2luZHMgPSBbMzQyMzUgLyogSG9yaXpvbnRhbFZpZGVvICovLCAzNDIzNiAvKiBWZXJ0aWNhbFZpZGVvICovLCAyMiAvKiBTaG9ydFZpZGVvICovLCAyMSAvKiBWaWRlbyAqL107XG4gIF9pbWV0YXM7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTkRLQXJ0aWNsZSBmcm9tIGFuIGV4aXN0aW5nIE5ES0V2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgTkRLRXZlbnQgdG8gY3JlYXRlIHRoZSBOREtBcnRpY2xlIGZyb20uXG4gICAqIEByZXR1cm5zIE5ES0FydGljbGVcbiAgICovXG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLVmlkZW8oZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYXJ0aWNsZSB0aXRsZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gLSBUaGUgYXJ0aWNsZSB0aXRsZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgdGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ0aXRsZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYXJ0aWNsZSB0aXRsZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHRpdGxlIC0gVGhlIHRpdGxlIHRvIHNldCBmb3IgdGhlIGFydGljbGUuXG4gICAqL1xuICBzZXQgdGl0bGUodGl0bGUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInRpdGxlXCIpO1xuICAgIGlmICh0aXRsZSkgdGhpcy50YWdzLnB1c2goW1widGl0bGVcIiwgdGl0bGVdKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYXJ0aWNsZSB0aHVtYm5haWwuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGFydGljbGUgdGh1bWJuYWlsIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCB0aHVtYm5haWwoKSB7XG4gICAgbGV0IHRodW1ibmFpbDtcbiAgICBpZiAodGhpcy5pbWV0YXMgJiYgdGhpcy5pbWV0YXMubGVuZ3RoID4gMCkge1xuICAgICAgdGh1bWJuYWlsID0gdGhpcy5pbWV0YXNbMF0uaW1hZ2U/LlswXTtcbiAgICB9XG4gICAgcmV0dXJuIHRodW1ibmFpbCA/PyB0aGlzLnRhZ1ZhbHVlKFwidGh1bWJcIik7XG4gIH1cbiAgZ2V0IGltZXRhcygpIHtcbiAgICBpZiAodGhpcy5faW1ldGFzKSByZXR1cm4gdGhpcy5faW1ldGFzO1xuICAgIHRoaXMuX2ltZXRhcyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdID09PSBcImltZXRhXCIpLm1hcChtYXBJbWV0YVRhZyk7XG4gICAgcmV0dXJuIHRoaXMuX2ltZXRhcztcbiAgfVxuICBzZXQgaW1ldGFzKHRhZ3MpIHtcbiAgICB0aGlzLl9pbWV0YXMgPSB0YWdzO1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcImltZXRhXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKC4uLnRhZ3MubWFwKGltZXRhVGFnVG9UYWcpKTtcbiAgfVxuICBnZXQgdXJsKCkge1xuICAgIGlmICh0aGlzLmltZXRhcyAmJiB0aGlzLmltZXRhcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWV0YXNbMF0udXJsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInVybFwiKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYXJ0aWNsZSdzIHB1YmxpY2F0aW9uIHRpbWVzdGFtcC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH0gLSBUaGUgVW5peCB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgYXJ0aWNsZSB3YXMgcHVibGlzaGVkIG9yIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBwdWJsaXNoZWRfYXQoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdWYWx1ZShcInB1Ymxpc2hlZF9hdFwiKTtcbiAgICBpZiAodGFnKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHRhZyk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBjb250ZW50IHRhZ3MgZm9yIHRoZSBhcnRpY2xlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBmaXJzdCBjaGVja3MgYW5kIHNldHMgdGhlIHB1YmxpY2F0aW9uIGRhdGUgaWYgbm90IGF2YWlsYWJsZSxcbiAgICogYW5kIHRoZW4gZ2VuZXJhdGVzIGNvbnRlbnQgdGFncyBiYXNlZCBvbiB0aGUgYmFzZSBOREtFdmVudCBjbGFzcy5cbiAgICpcbiAgICogQHJldHVybnMge0NvbnRlbnRUYWd9IC0gVGhlIGdlbmVyYXRlZCBjb250ZW50IHRhZ3MuXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZVRhZ3MoKSB7XG4gICAgc3VwZXIuZ2VuZXJhdGVUYWdzKCk7XG4gICAgaWYgKCF0aGlzLmtpbmQpIHtcbiAgICAgIGlmICh0aGlzLmltZXRhcz8uWzBdPy5kaW0pIHtcbiAgICAgICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdGhpcy5pbWV0YXNbMF0uZGltLnNwbGl0KFwieFwiKTtcbiAgICAgICAgY29uc3QgaXNQb3J0cmFpdCA9IHdpZHRoICYmIGhlaWdodCAmJiBOdW1iZXIucGFyc2VJbnQod2lkdGgpIDwgTnVtYmVyLnBhcnNlSW50KGhlaWdodCk7XG4gICAgICAgIGNvbnN0IGlzU2hvcnQgPSB0aGlzLmR1cmF0aW9uICYmIHRoaXMuZHVyYXRpb24gPCAxMjA7XG4gICAgICAgIGlmIChpc1Nob3J0ICYmIGlzUG9ydHJhaXQpIHRoaXMua2luZCA9IDIyIC8qIFNob3J0VmlkZW8gKi87XG4gICAgICAgIGVsc2UgdGhpcy5raW5kID0gMjEgLyogVmlkZW8gKi87XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5nZW5lcmF0ZVRhZ3MoKTtcbiAgfVxuICBnZXQgZHVyYXRpb24oKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdWYWx1ZShcImR1cmF0aW9uXCIpO1xuICAgIGlmICh0YWcpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQodGFnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgdmlkZW8ncyBkdXJhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gZHVyYXRpb24gLSBUaGUgZHVyYXRpb24gdG8gc2V0IGZvciB0aGUgdmlkZW8gKGluIHNlY29uZHMpXG4gICAqL1xuICBzZXQgZHVyYXRpb24oZHVyKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkdXJhdGlvblwiKTtcbiAgICBpZiAoZHVyICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcImR1cmF0aW9uXCIsIE1hdGguZmxvb3IoZHVyKS50b1N0cmluZygpXSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3dpa2kudHNcbnZhciBOREtXaWtpID0gY2xhc3MgX05ES1dpa2kgZXh0ZW5kcyBOREtBcnRpY2xlIHtcbiAgc3RhdGljIGtpbmQgPSAzMDgxOCAvKiBXaWtpICovO1xuICBzdGF0aWMga2luZHMgPSBbMzA4MTggLyogV2lraSAqL107XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLV2lraShldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIGdldCBpc0RlZmVyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzVGFnKFwiYVwiLCBcImRlZmVyXCIpO1xuICB9XG4gIGdldCBkZWZlcmVkSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJhXCIsIFwiZGVmZXJcIik7XG4gIH1cbiAgLyoqXG4gICAqIERlZmVycyB0aGUgYXV0aG9yJ3Mgd2lraSBldmVudCB0byBhbm90aGVyIHdpa2kgZXZlbnQuXG4gICAqXG4gICAqIFdpa2ktZXZlbnRzIGNhbiB0YWcgb3RoZXIgd2lraS1ldmVudHMgd2l0aCBhIGBkZWZlcmAgbWFya2VyIHRvIGluZGljYXRlIHRoYXQgaXQgY29uc2lkZXJzIHNvbWVvbmUgZWxzZSdzIGVudHJ5IGFzIGEgXCJiZXR0ZXJcIiB2ZXJzaW9uIG9mIGl0c2VsZi4gSWYgdXNpbmcgYSBgZGVmZXJgIG1hcmtlciBib3RoIGBhYCBhbmQgYGVgIHRhZ3MgU0hPVUxEIGJlIHVzZWQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIG15V2lraS5kZWZlciA9IGJldHRlcldpa2lFbnRyeU9uVGhlU2FtZVRvcGljO1xuICAgKiBteVdpa2kucHVibGlzaFJlcGxhY2VhYmxlKClcbiAgICovXG4gIHNldCBkZWZlcihkZWZlcmVkVG8pIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImFcIiwgXCJkZWZlclwiKTtcbiAgICB0aGlzLnRhZyhkZWZlcmVkVG8sIFwiZGVmZXJcIik7XG4gIH1cbn07XG52YXIgTkRLV2lraU1lcmdlUmVxdWVzdCA9IGNsYXNzIF9OREtXaWtpTWVyZ2VSZXF1ZXN0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBzdGF0aWMga2luZCA9IDgxOCAvKiBXaWtpTWVyZ2VSZXF1ZXN0ICovO1xuICBzdGF0aWMga2luZHMgPSBbODE4IC8qIFdpa2lNZXJnZVJlcXVlc3QgKi9dO1xuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1dpa2lNZXJnZVJlcXVlc3QoZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICAvKipcbiAgICogVGhlIHRhcmdldCBJRCAoPGtpbmQ6cHVia2V5OmQtdGFnPikgb2YgdGhlIHdpa2kgZXZlbnQgdG8gbWVyZ2UgaW50by5cbiAgICovXG4gIGdldCB0YXJnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImFcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRhcmdldCBJRCAoPGtpbmQ6cHVia2V5OmQtdGFnPikgb2YgdGhlIHdpa2kgZXZlbnQgdG8gbWVyZ2UgaW50by5cbiAgICovXG4gIHNldCB0YXJnZXQodGFyZ2V0RXZlbnQpIHtcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwiYVwiKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwiZVwiICYmIHRhZ1szXSAhPT0gXCJzb3VyY2VcIikgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgdGhpcy50YWcodGFyZ2V0RXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc291cmNlIElEIG9mIHRoZSB3aWtpIGV2ZW50IHRvIG1lcmdlIGZyb20uXG4gICAqL1xuICBnZXQgc291cmNlSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJlXCIsIFwic291cmNlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBldmVudCB3ZSBhcmUgYXNraW5nIHRvIGdldCBtZXJnZWQgaW50byB0aGUgdGFyZ2V0LlxuICAgKi9cbiAgc2V0IHNvdXJjZShzb3VyY2VFdmVudCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZVwiLCBcInNvdXJjZVwiKTtcbiAgICB0aGlzLnRhZyhzb3VyY2VFdmVudCwgXCJzb3VyY2VcIiwgZmFsc2UsIFwiZVwiKTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9ibG9zc29tLWxpc3QudHNcbnZhciBOREtCbG9zc29tTGlzdCA9IGNsYXNzIF9OREtCbG9zc29tTGlzdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGtpbmRzID0gWzEwMDYzIC8qIEJsb3Nzb21MaXN0ICovXTtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMTAwNjMgLyogQmxvc3NvbUxpc3QgKi87XG4gIH1cbiAgc3RhdGljIGZyb20obmRrRXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtCbG9zc29tTGlzdChuZGtFdmVudC5uZGssIG5ka0V2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBCbG9zc29tIHNlcnZlcnMgaW4gdGhlIGxpc3RcbiAgICovXG4gIGdldCBzZXJ2ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJzZXJ2ZXJcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxpc3Qgb2YgQmxvc3NvbSBzZXJ2ZXJzXG4gICAqL1xuICBzZXQgc2VydmVycyhzZXJ2ZXJzKSB7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwic2VydmVyXCIpO1xuICAgIGZvciAoY29uc3Qgc2VydmVyIG9mIHNlcnZlcnMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInNlcnZlclwiLCBzZXJ2ZXJdKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlZmF1bHQgQmxvc3NvbSBzZXJ2ZXIgKGZpcnN0IGluIHRoZSBsaXN0KVxuICAgKi9cbiAgZ2V0IGRlZmF1bHQoKSB7XG4gICAgY29uc3Qgc2VydmVycyA9IHRoaXMuc2VydmVycztcbiAgICByZXR1cm4gc2VydmVycy5sZW5ndGggPiAwID8gc2VydmVyc1swXSA6IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZGVmYXVsdCBCbG9zc29tIHNlcnZlciBieSBtb3ZpbmcgaXQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuICAgKi9cbiAgc2V0IGRlZmF1bHQoc2VydmVyKSB7XG4gICAgaWYgKCFzZXJ2ZXIpIHJldHVybjtcbiAgICBjb25zdCBjdXJyZW50U2VydmVycyA9IHRoaXMuc2VydmVycztcbiAgICBjb25zdCBmaWx0ZXJlZFNlcnZlcnMgPSBjdXJyZW50U2VydmVycy5maWx0ZXIoKHMpID0+IHMgIT09IHNlcnZlcik7XG4gICAgdGhpcy5zZXJ2ZXJzID0gW3NlcnZlciwgLi4uZmlsdGVyZWRTZXJ2ZXJzXTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHNlcnZlciB0byB0aGUgbGlzdCBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3RcbiAgICovXG4gIGFkZFNlcnZlcihzZXJ2ZXIpIHtcbiAgICBpZiAoIXNlcnZlcikgcmV0dXJuO1xuICAgIGNvbnN0IGN1cnJlbnRTZXJ2ZXJzID0gdGhpcy5zZXJ2ZXJzO1xuICAgIGlmICghY3VycmVudFNlcnZlcnMuaW5jbHVkZXMoc2VydmVyKSkge1xuICAgICAgdGhpcy5zZXJ2ZXJzID0gWy4uLmN1cnJlbnRTZXJ2ZXJzLCBzZXJ2ZXJdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhIHNlcnZlciBmcm9tIHRoZSBsaXN0XG4gICAqL1xuICByZW1vdmVTZXJ2ZXIoc2VydmVyKSB7XG4gICAgaWYgKCFzZXJ2ZXIpIHJldHVybjtcbiAgICBjb25zdCBjdXJyZW50U2VydmVycyA9IHRoaXMuc2VydmVycztcbiAgICB0aGlzLnNlcnZlcnMgPSBjdXJyZW50U2VydmVycy5maWx0ZXIoKHMpID0+IHMgIT09IHNlcnZlcik7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvZm9sbG93LXBhY2sudHNcbnZhciBOREtGb2xsb3dQYWNrID0gY2xhc3MgX05ES0ZvbGxvd1BhY2sgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMzkwODkgLyogRm9sbG93UGFjayAqLztcbiAgc3RhdGljIGtpbmRzID0gWzM5MDg5IC8qIEZvbGxvd1BhY2sgKi8sIDM5MDkyIC8qIE1lZGlhRm9sbG93UGFjayAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDM5MDg5IC8qIEZvbGxvd1BhY2sgKi87XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgZ2VuZXJpYyBOREtFdmVudCB0byBhbiBOREtGb2xsb3dQYWNrLlxuICAgKi9cbiAgc3RhdGljIGZyb20obmRrRXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtGb2xsb3dQYWNrKG5ka0V2ZW50Lm5kaywgbmRrRXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0aXRsZSBmcm9tIHRoZSB0YWdzLlxuICAgKi9cbiAgZ2V0IHRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwidGl0bGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRpdGxlIHRhZy5cbiAgICovXG4gIHNldCB0aXRsZSh2YWx1ZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHZhbHVlKSB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB2YWx1ZV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbWFnZSBVUkwgZnJvbSB0aGUgdGFncy5cbiAgICovXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbWFnZSBVUkwgZnJvbSB0aGUgdGFncy5cbiAgICogTG9va3MgZm9yIGFuIGltZXRhIHRhZyBmaXJzdCAocmV0dXJucyBpdHMgdXJsKSwgdGhlbiBmYWxscyBiYWNrIHRvIHRoZSBpbWFnZSB0YWcuXG4gICAqL1xuICBnZXQgaW1hZ2UoKSB7XG4gICAgY29uc3QgaW1ldGFUYWcgPSB0aGlzLnRhZ3MuZmluZCgodGFnKSA9PiB0YWdbMF0gPT09IFwiaW1ldGFcIik7XG4gICAgaWYgKGltZXRhVGFnKSB7XG4gICAgICBjb25zdCBpbWV0YSA9IG1hcEltZXRhVGFnKGltZXRhVGFnKTtcbiAgICAgIGlmIChpbWV0YS51cmwpIHJldHVybiBpbWV0YS51cmw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiaW1hZ2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGltYWdlIFVSTCB0YWcuXG4gICAqL1xuICAvKipcbiAgICogU2V0cyB0aGUgaW1hZ2UgdGFnLlxuICAgKiBBY2NlcHRzIGEgc3RyaW5nIChVUkwpIG9yIGFuIE5ES0ltZXRhVGFnLlxuICAgKiBJZiBnaXZlbiBhbiBOREtJbWV0YVRhZywgc2V0cyBib3RoIHRoZSBpbWV0YSB0YWcgYW5kIHRoZSBpbWFnZSB0YWcgKHVzaW5nIHRoZSB1cmwpLlxuICAgKiBJZiB1bmRlZmluZWQsIHJlbW92ZXMgYm90aCB0YWdzLlxuICAgKi9cbiAgc2V0IGltYWdlKHZhbHVlKSB7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwiaW1ldGFcIiAmJiB0YWdbMF0gIT09IFwiaW1hZ2VcIik7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy50YWdzLnB1c2goW1wiaW1hZ2VcIiwgdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgdGhpcy50YWdzLnB1c2goaW1ldGFUYWdUb1RhZyh2YWx1ZSkpO1xuICAgICAgaWYgKHZhbHVlLnVybCkge1xuICAgICAgICB0aGlzLnRhZ3MucHVzaChbXCJpbWFnZVwiLCB2YWx1ZS51cmxdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYWxsIHB1YmtleXMgZnJvbSBwIHRhZ3MuXG4gICAqL1xuICBnZXQgcHVia2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdID09PSBcInBcIikubWFwKCh0YWcpID0+IHRhZ1sxXSkpKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcHVia2V5cyAocmVwbGFjZXMgYWxsIHAgdGFncykuXG4gICAqL1xuICBzZXQgcHVia2V5cyhwdWJrZXlzKSB7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwicFwiKTtcbiAgICBmb3IgKGNvbnN0IHB1YmtleSBvZiBwdWJrZXlzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwXCIsIHB1YmtleV0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgZGVzY3JpcHRpb24gZnJvbSB0aGUgdGFncy5cbiAgICovXG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImRlc2NyaXB0aW9uXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXNjcmlwdGlvbiB0YWcuXG4gICAqL1xuICBzZXQgZGVzY3JpcHRpb24odmFsdWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImRlc2NyaXB0aW9uXCIpO1xuICAgIGlmICh2YWx1ZSkgdGhpcy50YWdzLnB1c2goW1wiZGVzY3JpcHRpb25cIiwgdmFsdWVdKTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy93cmFwLnRzXG5mdW5jdGlvbiB3cmFwRXZlbnQoZXZlbnQpIHtcbiAgY29uc3QgZXZlbnRXcmFwcGluZ01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3Qga2xhc3MyIG9mIFtcbiAgICBOREtJbWFnZSxcbiAgICBOREtWaWRlbyxcbiAgICBOREtDYXNodU1pbnRMaXN0LFxuICAgIE5ES0FydGljbGUsXG4gICAgTkRLSGlnaGxpZ2h0LFxuICAgIE5ES0RyYWZ0LFxuICAgIE5ES1dpa2ksXG4gICAgTkRLTnV0emFwLFxuICAgIE5ES1NpbXBsZUdyb3VwTWVtYmVyTGlzdCxcbiAgICBOREtTaW1wbGVHcm91cE1ldGFkYXRhLFxuICAgIE5ES1N1YnNjcmlwdGlvblRpZXIsXG4gICAgTkRLQ2FzaHVUb2tlbixcbiAgICBOREtMaXN0LFxuICAgIE5ES1N0b3J5LFxuICAgIE5ES0Jsb3Nzb21MaXN0LFxuICAgIE5ES0ZvbGxvd1BhY2tcbiAgXSkge1xuICAgIGZvciAoY29uc3Qga2luZCBvZiBrbGFzczIua2luZHMpIHtcbiAgICAgIGV2ZW50V3JhcHBpbmdNYXAuc2V0KGtpbmQsIGtsYXNzMik7XG4gICAgfVxuICB9XG4gIGNvbnN0IGtsYXNzID0gZXZlbnRXcmFwcGluZ01hcC5nZXQoZXZlbnQua2luZCk7XG4gIGlmIChrbGFzcykgcmV0dXJuIGtsYXNzLmZyb20oZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8vIHNyYy9zdWJzY3JpcHRpb24vdXRpbHMudHNcbmltcG9ydCB7IG5pcDE5IGFzIG5pcDE5NCB9IGZyb20gXCJub3N0ci10b29sc1wiO1xudmFyIE1BWF9TVUJJRF9MRU5HVEggPSAyMDtcbmZ1bmN0aW9uIHF1ZXJ5RnVsbHlGaWxsZWQoc3Vic2NyaXB0aW9uKSB7XG4gIGlmIChmaWx0ZXJJbmNsdWRlc0lkcyhzdWJzY3JpcHRpb24uZmlsdGVyKSkge1xuICAgIGlmIChyZXN1bHRIYXNBbGxSZXF1ZXN0ZWRJZHMoc3Vic2NyaXB0aW9uKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVGaWx0ZXIoZmlsdGVyMSwgZmlsdGVyMikge1xuICBpZiAoT2JqZWN0LmtleXMoZmlsdGVyMSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhmaWx0ZXIyKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmlsdGVyMSkpIHtcbiAgICBjb25zdCB2YWx1ZXNJbkZpbHRlcjIgPSBmaWx0ZXIyW2tleV07XG4gICAgaWYgKCF2YWx1ZXNJbkZpbHRlcjIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZXNJbkZpbHRlcjIpKSB7XG4gICAgICBjb25zdCB2ID0gdmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlSW5GaWx0ZXIyIG9mIHZhbHVlc0luRmlsdGVyMikge1xuICAgICAgICBjb25zdCB2YWwgPSB2YWx1ZUluRmlsdGVyMjtcbiAgICAgICAgaWYgKCF2LmluY2x1ZGVzKHZhbCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlc0luRmlsdGVyMiAhPT0gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBmaWx0ZXJJbmNsdWRlc0lkcyhmaWx0ZXIpIHtcbiAgcmV0dXJuICEhZmlsdGVyLmlkcztcbn1cbmZ1bmN0aW9uIHJlc3VsdEhhc0FsbFJlcXVlc3RlZElkcyhzdWJzY3JpcHRpb24pIHtcbiAgY29uc3QgaWRzID0gc3Vic2NyaXB0aW9uLmZpbHRlci5pZHM7XG4gIHJldHVybiAhIWlkcyAmJiBpZHMubGVuZ3RoID09PSBzdWJzY3JpcHRpb24uZXZlbnRGaXJzdFNlZW4uc2l6ZTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU3ViSWQoc3Vic2NyaXB0aW9ucywgZmlsdGVycykge1xuICBjb25zdCBzdWJJZHMgPSBzdWJzY3JpcHRpb25zLm1hcCgoc3ViKSA9PiBzdWIuc3ViSWQpLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3Qgc3ViSWRQYXJ0cyA9IFtdO1xuICBjb25zdCBmaWx0ZXJOb25LaW5kS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGZpbHRlcktpbmRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgaWYgKHN1Yklkcy5sZW5ndGggPiAwKSB7XG4gICAgc3ViSWRQYXJ0cy5wdXNoKEFycmF5LmZyb20obmV3IFNldChzdWJJZHMpKS5qb2luKFwiLFwiKSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgZmlsdGVycykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZmlsdGVyKSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcImtpbmRzXCIpIHtcbiAgICAgICAgICBmaWx0ZXIua2luZHM/LmZvckVhY2goKGspID0+IGZpbHRlcktpbmRzLmFkZChrKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsdGVyTm9uS2luZEtleXMuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpbHRlcktpbmRzLnNpemUgPiAwKSB7XG4gICAgICBzdWJJZFBhcnRzLnB1c2goYGtpbmRzOiR7QXJyYXkuZnJvbShmaWx0ZXJLaW5kcykuam9pbihcIixcIil9YCk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJOb25LaW5kS2V5cy5zaXplID4gMCkge1xuICAgICAgc3ViSWRQYXJ0cy5wdXNoKEFycmF5LmZyb20oZmlsdGVyTm9uS2luZEtleXMpLmpvaW4oXCIsXCIpKTtcbiAgICB9XG4gIH1cbiAgbGV0IHN1YklkID0gc3ViSWRQYXJ0cy5qb2luKFwiLVwiKTtcbiAgaWYgKHN1YklkLmxlbmd0aCA+IE1BWF9TVUJJRF9MRU5HVEgpIHN1YklkID0gc3ViSWQuc3Vic3RyaW5nKDAsIE1BWF9TVUJJRF9MRU5HVEgpO1xuICBzdWJJZCArPSBgLSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogOTk5KS50b1N0cmluZygpfWA7XG4gIHJldHVybiBzdWJJZDtcbn1cbmZ1bmN0aW9uIGZpbHRlckZvckV2ZW50c1RhZ2dpbmdJZChpZCkge1xuICB0cnkge1xuICAgIGNvbnN0IGRlY29kZWQgPSBuaXAxOTQuZGVjb2RlKGlkKTtcbiAgICBzd2l0Y2ggKGRlY29kZWQudHlwZSkge1xuICAgICAgY2FzZSBcIm5hZGRyXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgXCIjYVwiOiBbYCR7ZGVjb2RlZC5kYXRhLmtpbmR9OiR7ZGVjb2RlZC5kYXRhLnB1YmtleX06JHtkZWNvZGVkLmRhdGEuaWRlbnRpZmllcn1gXVxuICAgICAgICB9O1xuICAgICAgY2FzZSBcIm5ldmVudFwiOlxuICAgICAgICByZXR1cm4geyBcIiNlXCI6IFtkZWNvZGVkLmRhdGEuaWRdIH07XG4gICAgICBjYXNlIFwibm90ZVwiOlxuICAgICAgICByZXR1cm4geyBcIiNlXCI6IFtkZWNvZGVkLmRhdGFdIH07XG4gICAgICBjYXNlIFwibnByb2ZpbGVcIjpcbiAgICAgICAgcmV0dXJuIHsgXCIjcFwiOiBbZGVjb2RlZC5kYXRhLnB1YmtleV0gfTtcbiAgICAgIGNhc2UgXCJucHViXCI6XG4gICAgICAgIHJldHVybiB7IFwiI3BcIjogW2RlY29kZWQuZGF0YV0gfTtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICB9XG59XG5mdW5jdGlvbiBmaWx0ZXJBbmRSZWxheVNldEZyb21CZWNoMzIoYmVjaGUyLCBuZGspIHtcbiAgY29uc3QgZmlsdGVyID0gZmlsdGVyRnJvbUlkKGJlY2hlMik7XG4gIGNvbnN0IHJlbGF5cyA9IHJlbGF5c0Zyb21CZWNoMzIoYmVjaGUyLCBuZGspO1xuICBpZiAocmVsYXlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHsgZmlsdGVyIH07XG4gIHJldHVybiB7XG4gICAgZmlsdGVyLFxuICAgIHJlbGF5U2V0OiBuZXcgTkRLUmVsYXlTZXQobmV3IFNldChyZWxheXMpLCBuZGspXG4gIH07XG59XG5mdW5jdGlvbiBmaWx0ZXJGcm9tSWQoaWQpIHtcbiAgbGV0IGRlY29kZWQ7XG4gIGlmIChpZC5tYXRjaChOSVAzM19BX1JFR0VYKSkge1xuICAgIGNvbnN0IFtraW5kLCBwdWJrZXksIGlkZW50aWZpZXJdID0gaWQuc3BsaXQoXCI6XCIpO1xuICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgIGF1dGhvcnM6IFtwdWJrZXldLFxuICAgICAga2luZHM6IFtOdW1iZXIucGFyc2VJbnQoa2luZCldXG4gICAgfTtcbiAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgZmlsdGVyW1wiI2RcIl0gPSBbaWRlbnRpZmllcl07XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXI7XG4gIH1cbiAgaWYgKGlkLm1hdGNoKEJFQ0gzMl9SRUdFWCkpIHtcbiAgICB0cnkge1xuICAgICAgZGVjb2RlZCA9IG5pcDE5NC5kZWNvZGUoaWQpO1xuICAgICAgc3dpdGNoIChkZWNvZGVkLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm5ldmVudFwiOiB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyID0geyBpZHM6IFtkZWNvZGVkLmRhdGEuaWRdIH07XG4gICAgICAgICAgaWYgKGRlY29kZWQuZGF0YS5hdXRob3IpIGZpbHRlci5hdXRob3JzID0gW2RlY29kZWQuZGF0YS5hdXRob3JdO1xuICAgICAgICAgIGlmIChkZWNvZGVkLmRhdGEua2luZCkgZmlsdGVyLmtpbmRzID0gW2RlY29kZWQuZGF0YS5raW5kXTtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICAgICAgcmV0dXJuIHsgaWRzOiBbZGVjb2RlZC5kYXRhXSB9O1xuICAgICAgICBjYXNlIFwibmFkZHJcIjoge1xuICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICAgIGF1dGhvcnM6IFtkZWNvZGVkLmRhdGEucHVia2V5XSxcbiAgICAgICAgICAgIGtpbmRzOiBbZGVjb2RlZC5kYXRhLmtpbmRdXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoZGVjb2RlZC5kYXRhLmlkZW50aWZpZXIpIGZpbHRlcltcIiNkXCJdID0gW2RlY29kZWQuZGF0YS5pZGVudGlmaWVyXTtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRlY29kaW5nXCIsIGlkLCBlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgaWRzOiBbaWRdIH07XG59XG5mdW5jdGlvbiBpc05pcDMzQVZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5tYXRjaChOSVAzM19BX1JFR0VYKSAhPT0gbnVsbDtcbn1cbnZhciBOSVAzM19BX1JFR0VYID0gL14oXFxkKyk6KFswLTlBLUZhLWZdKykoPzo6KC4qKSk/JC87XG52YXIgQkVDSDMyX1JFR0VYID0gL15uKGV2ZW50fG90ZXxwcm9maWxlfHB1YnxhZGRyKTFbXFxkXFx3XSskLztcbmZ1bmN0aW9uIHJlbGF5c0Zyb21CZWNoMzIoYmVjaDMyMiwgbmRrKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IG5pcDE5NC5kZWNvZGUoYmVjaDMyMik7XG4gICAgaWYgKFtcIm5hZGRyXCIsIFwibmV2ZW50XCJdLmluY2x1ZGVzKGRlY29kZWQ/LnR5cGUpKSB7XG4gICAgICBjb25zdCBkYXRhID0gZGVjb2RlZC5kYXRhO1xuICAgICAgaWYgKGRhdGE/LnJlbGF5cykge1xuICAgICAgICByZXR1cm4gZGF0YS5yZWxheXMubWFwKChyKSA9PiBuZXcgTkRLUmVsYXkociwgbmRrLnJlbGF5QXV0aERlZmF1bHRQb2xpY3ksIG5kaykpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoX2UpIHtcbiAgfVxuICByZXR1cm4gW107XG59XG5cbi8vIHNyYy9zdWJzY3JpcHRpb24vaW5kZXgudHNcbnZhciBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlID0gLyogQF9fUFVSRV9fICovICgoTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTIpID0+IHtcbiAgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTJbXCJPTkxZX0NBQ0hFXCJdID0gXCJPTkxZX0NBQ0hFXCI7XG4gIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UyW1wiQ0FDSEVfRklSU1RcIl0gPSBcIkNBQ0hFX0ZJUlNUXCI7XG4gIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UyW1wiUEFSQUxMRUxcIl0gPSBcIlBBUkFMTEVMXCI7XG4gIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UyW1wiT05MWV9SRUxBWVwiXSA9IFwiT05MWV9SRUxBWVwiO1xuICByZXR1cm4gTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTI7XG59KShOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlIHx8IHt9KTtcbnZhciBkZWZhdWx0T3B0cyA9IHtcbiAgY2xvc2VPbkVvc2U6IGZhbHNlLFxuICBjYWNoZVVzYWdlOiBcIkNBQ0hFX0ZJUlNUXCIgLyogQ0FDSEVfRklSU1QgKi8sXG4gIGRvbnRTYXZlVG9DYWNoZTogZmFsc2UsXG4gIGdyb3VwYWJsZTogdHJ1ZSxcbiAgZ3JvdXBhYmxlRGVsYXk6IDEwMCxcbiAgZ3JvdXBhYmxlRGVsYXlUeXBlOiBcImF0LW1vc3RcIixcbiAgY2FjaGVVbmNvbnN0cmFpbkZpbHRlcjogW1wibGltaXRcIiwgXCJzaW5jZVwiLCBcInVudGlsXCJdXG59O1xudmFyIE5ES1N1YnNjcmlwdGlvbiA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyNCB7XG4gIHN1YklkO1xuICBmaWx0ZXJzO1xuICBvcHRzO1xuICBwb29sO1xuICBza2lwVmVyaWZpY2F0aW9uID0gZmFsc2U7XG4gIHNraXBWYWxpZGF0aW9uID0gZmFsc2U7XG4gIC8qKlxuICAgKiBUcmFja3MgdGhlIGZpbHRlcnMgYXMgdGhleSBhcmUgZXhlY3V0ZWQgb24gZWFjaCByZWxheVxuICAgKi9cbiAgcmVsYXlGaWx0ZXJzO1xuICByZWxheVNldDtcbiAgbmRrO1xuICBkZWJ1ZztcbiAgLyoqXG4gICAqIEV2ZW50cyB0aGF0IGhhdmUgYmVlbiBzZWVuIGJ5IHRoZSBzdWJzY3JpcHRpb24sIHdpdGggdGhlIHRpbWUgdGhleSB3ZXJlIGZpcnN0IHNlZW4uXG4gICAqL1xuICBldmVudEZpcnN0U2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8qKlxuICAgKiBSZWxheXMgdGhhdCBoYXZlIHNlbnQgYW4gRU9TRS5cbiAgICovXG4gIGVvc2VzU2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIC8qKlxuICAgKiBUaGUgdGltZSB0aGUgbGFzdCBldmVudCB3YXMgcmVjZWl2ZWQgYnkgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICogVGhpcyBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB3aGVuIEVPU0Ugc2hvdWxkIGJlIGVtaXR0ZWQuXG4gICAqL1xuICBsYXN0RXZlbnRSZWNlaXZlZEF0O1xuICAvKipcbiAgICogVGhlIG1vc3QgcmVjZW50IGV2ZW50IHRpbWVzdGFtcCBmcm9tIGNhY2hlIHJlc3VsdHMuXG4gICAqIFRoaXMgaXMgdXNlZCBmb3IgYWRkU2luY2VGcm9tQ2FjaGUgZnVuY3Rpb25hbGl0eS5cbiAgICovXG4gIG1vc3RSZWNlbnRDYWNoZUV2ZW50VGltZXN0YW1wO1xuICBpbnRlcm5hbElkO1xuICAvKipcbiAgICogV2hldGhlciB0aGUgc3Vic2NyaXB0aW9uIHNob3VsZCBjbG9zZSB3aGVuIGFsbCByZWxheXMgaGF2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGV2ZW50IHN0cmVhbS5cbiAgICovXG4gIGNsb3NlT25Fb3NlO1xuICAvKipcbiAgICogUG9vbCBtb25pdG9yIGNhbGxiYWNrXG4gICAqL1xuICBwb29sTW9uaXRvcjtcbiAgc2tpcE9wdGltaXN0aWNQdWJsaXNoRXZlbnQgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEZpbHRlcnMgdG8gcmVtb3ZlIHdoZW4gcXVlcnlpbmcgdGhlIGNhY2hlLlxuICAgKi9cbiAgY2FjaGVVbmNvbnN0cmFpbkZpbHRlcjtcbiAgY29uc3RydWN0b3IobmRrLCBmaWx0ZXJzLCBvcHRzLCBzdWJJZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0cywgLi4ub3B0cyB8fCB7fSB9O1xuICAgIHRoaXMucG9vbCA9IHRoaXMub3B0cy5wb29sIHx8IG5kay5wb29sO1xuICAgIHRoaXMuZmlsdGVycyA9IEFycmF5LmlzQXJyYXkoZmlsdGVycykgPyBmaWx0ZXJzIDogW2ZpbHRlcnNdO1xuICAgIHRoaXMuc3ViSWQgPSBzdWJJZCB8fCB0aGlzLm9wdHMuc3ViSWQ7XG4gICAgdGhpcy5pbnRlcm5hbElkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpO1xuICAgIHRoaXMuZGVidWcgPSBuZGsuZGVidWcuZXh0ZW5kKGBzdWJzY3JpcHRpb25bJHt0aGlzLm9wdHMuc3ViSWQgPz8gdGhpcy5pbnRlcm5hbElkfV1gKTtcbiAgICBpZiAodGhpcy5vcHRzLnJlbGF5U2V0KSB7XG4gICAgICB0aGlzLnJlbGF5U2V0ID0gdGhpcy5vcHRzLnJlbGF5U2V0O1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLnJlbGF5VXJscykge1xuICAgICAgdGhpcy5yZWxheVNldCA9IE5ES1JlbGF5U2V0LmZyb21SZWxheVVybHModGhpcy5vcHRzLnJlbGF5VXJscywgdGhpcy5uZGspO1xuICAgIH1cbiAgICB0aGlzLnNraXBWZXJpZmljYXRpb24gPSB0aGlzLm9wdHMuc2tpcFZlcmlmaWNhdGlvbiB8fCBmYWxzZTtcbiAgICB0aGlzLnNraXBWYWxpZGF0aW9uID0gdGhpcy5vcHRzLnNraXBWYWxpZGF0aW9uIHx8IGZhbHNlO1xuICAgIHRoaXMuY2xvc2VPbkVvc2UgPSB0aGlzLm9wdHMuY2xvc2VPbkVvc2UgfHwgZmFsc2U7XG4gICAgdGhpcy5za2lwT3B0aW1pc3RpY1B1Ymxpc2hFdmVudCA9IHRoaXMub3B0cy5za2lwT3B0aW1pc3RpY1B1Ymxpc2hFdmVudCB8fCBmYWxzZTtcbiAgICB0aGlzLmNhY2hlVW5jb25zdHJhaW5GaWx0ZXIgPSB0aGlzLm9wdHMuY2FjaGVVbmNvbnN0cmFpbkZpbHRlcjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVsYXlzIHRoYXQgaGF2ZSBub3QgeWV0IHNlbnQgYW4gRU9TRS5cbiAgICovXG4gIHJlbGF5c01pc3NpbmdFb3NlKCkge1xuICAgIGlmICghdGhpcy5yZWxheUZpbHRlcnMpIHJldHVybiBbXTtcbiAgICBjb25zdCByZWxheXNNaXNzaW5nRW9zZSA9IEFycmF5LmZyb20odGhpcy5yZWxheUZpbHRlcnM/LmtleXMoKSkuZmlsdGVyKFxuICAgICAgKHVybCkgPT4gIXRoaXMuZW9zZXNTZWVuLmhhcyh0aGlzLnBvb2wuZ2V0UmVsYXkodXJsLCBmYWxzZSwgZmFsc2UpKVxuICAgICk7XG4gICAgcmV0dXJuIHJlbGF5c01pc3NpbmdFb3NlO1xuICB9XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGZpcnN0IGZpbHRlciBvZiB0aGUgc3Vic2NyaXB0aW9uIGZvclxuICAgKiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICovXG4gIGdldCBmaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyc1swXTtcbiAgfVxuICBnZXQgZ3JvdXBhYmxlRGVsYXkoKSB7XG4gICAgaWYgKCF0aGlzLmlzR3JvdXBhYmxlKCkpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIHRoaXMub3B0cz8uZ3JvdXBhYmxlRGVsYXk7XG4gIH1cbiAgZ2V0IGdyb3VwYWJsZURlbGF5VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRzPy5ncm91cGFibGVEZWxheVR5cGUgfHwgXCJhdC1tb3N0XCI7XG4gIH1cbiAgaXNHcm91cGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0cz8uZ3JvdXBhYmxlIHx8IGZhbHNlO1xuICB9XG4gIHNob3VsZFF1ZXJ5Q2FjaGUoKSB7XG4gICAgaWYgKHRoaXMub3B0cy5hZGRTaW5jZUZyb21DYWNoZSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMub3B0cz8uY2FjaGVVc2FnZSA9PT0gXCJPTkxZX1JFTEFZXCIgLyogT05MWV9SRUxBWSAqLykgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGhhc05vbkVwaGVtZXJhbEtpbmQgPSB0aGlzLmZpbHRlcnMuc29tZSgoZikgPT4gZi5raW5kcz8uc29tZSgoaykgPT4ga2luZElzRXBoZW1lcmFsKGspKSk7XG4gICAgaWYgKGhhc05vbkVwaGVtZXJhbEtpbmQpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNob3VsZFF1ZXJ5UmVsYXlzKCkge1xuICAgIHJldHVybiB0aGlzLm9wdHM/LmNhY2hlVXNhZ2UgIT09IFwiT05MWV9DQUNIRVwiIC8qIE9OTFlfQ0FDSEUgKi87XG4gIH1cbiAgc2hvdWxkV2FpdEZvckNhY2hlKCkge1xuICAgIGlmICh0aGlzLm9wdHMuYWRkU2luY2VGcm9tQ2FjaGUpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiAoXG4gICAgICAvLyBNdXN0IHdhbnQgdG8gY2xvc2Ugb24gRU9TRTsgc3Vic2NyaXB0aW9uc1xuICAgICAgLy8gdGhhdCB3YW50IHRvIHJlY2VpdmUgZnVydGhlciB1cGRhdGVzIG11c3RcbiAgICAgIC8vIGFsd2F5cyBoaXQgdGhlIHJlbGF5XG4gICAgICAhIXRoaXMub3B0cy5jbG9zZU9uRW9zZSAmJiAvLyBDYWNoZSBhZGFwdGVyIG11c3QgY2xhaW0gdG8gYmUgZmFzdFxuICAgICAgISF0aGlzLm5kay5jYWNoZUFkYXB0ZXI/LmxvY2tpbmcgJiYgLy8gSWYgZXhwbGljaXRseSB0b2xkIHRvIHJ1biBpbiBwYXJhbGxlbCwgdGhlblxuICAgICAgLy8gd2Ugc2hvdWxkIG5vdCB3YWl0IGZvciB0aGUgY2FjaGVcbiAgICAgIHRoaXMub3B0cy5jYWNoZVVzYWdlICE9PSBcIlBBUkFMTEVMXCIgLyogUEFSQUxMRUwgKi9cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCB0aGUgc3Vic2NyaXB0aW9uLiBUaGlzIGlzIHRoZSBtYWluIG1ldGhvZCB0aGF0IHNob3VsZCBiZSBjYWxsZWRcbiAgICogYWZ0ZXIgY3JlYXRpbmcgYSBzdWJzY3JpcHRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBlbWl0Q2FjaGVkRXZlbnRzIC0gV2hldGhlciB0byBlbWl0IGV2ZW50cyBjb21pbmcgZnJvbSBhIHN5bmNocm9ub3VzIGNhY2hlXG4gICAqXG4gICAqIFdoZW4gdXNpbmcgYSBzeW5jaHJvbm91cyBjYWNoZSwgdGhlIGV2ZW50cyB3aWxsIGJlIHJldHVybmVkIGltbWVkaWF0ZWx5XG4gICAqIGJ5IHRoaXMgZnVuY3Rpb24uIElmIHlvdSB3aWxsIHVzZSB0aG9zZSByZXR1cm5lZCBldmVudHMsIHlvdSBzaG91bGRcbiAgICogc2V0IGVtaXRDYWNoZWRFdmVudHMgdG8gZmFsc2UgdG8gcHJldmVudCBzZWVpbmcgdGhlbSBhcyBkdXBsaWNhdGUgZXZlbnRzLlxuICAgKi9cbiAgc3RhcnQoZW1pdENhY2hlZEV2ZW50cyA9IHRydWUpIHtcbiAgICBsZXQgY2FjaGVSZXN1bHQ7XG4gICAgY29uc3QgdXBkYXRlU3RhdGVGcm9tQ2FjaGVSZXN1bHRzID0gKGV2ZW50cykgPT4ge1xuICAgICAgaWYgKGVtaXRDYWNoZWRFdmVudHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMubW9zdFJlY2VudENhY2hlRXZlbnRUaW1lc3RhbXAgfHwgZXZlbnQuY3JlYXRlZF9hdCA+IHRoaXMubW9zdFJlY2VudENhY2hlRXZlbnRUaW1lc3RhbXApIHtcbiAgICAgICAgICAgIHRoaXMubW9zdFJlY2VudENhY2hlRXZlbnRUaW1lc3RhbXAgPSBldmVudC5jcmVhdGVkX2F0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmV2ZW50UmVjZWl2ZWQoZXZlbnQsIHZvaWQgMCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICAgIGlmICghdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCB8fCBldmVudC5jcmVhdGVkX2F0ID4gdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCkge1xuICAgICAgICAgICAgdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCA9IGV2ZW50LmNyZWF0ZWRfYXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV2ZW50Lm5kayA9IHRoaXMubmRrO1xuICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLm9wdHMud3JhcCA/IHdyYXBFdmVudChldmVudCkgOiBldmVudDtcbiAgICAgICAgICBpZiAoIWUpIGJyZWFrO1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgZS50aGVuKCh3cmFwcGVkRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoZmFsc2UsIHdyYXBwZWRFdmVudCwgdm9pZCAwLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmV2ZW50Rmlyc3RTZWVuLnNldChlLmlkLCBEYXRlLm5vdygpKTtcbiAgICAgICAgICBjYWNoZVJlc3VsdC5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsb2FkRnJvbVJlbGF5cyA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNob3VsZFF1ZXJ5UmVsYXlzKCkpIHtcbiAgICAgICAgdGhpcy5zdGFydFdpdGhSZWxheXMoKTtcbiAgICAgICAgdGhpcy5zdGFydFBvb2xNb25pdG9yKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoXCJlb3NlXCIsIHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHRoaXMuc2hvdWxkUXVlcnlDYWNoZSgpKSB7XG4gICAgICBjYWNoZVJlc3VsdCA9IHRoaXMuc3RhcnRXaXRoQ2FjaGUoKTtcbiAgICAgIGlmIChjYWNoZVJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkV2FpdEZvckNhY2hlKCkpIHtcbiAgICAgICAgICBjYWNoZVJlc3VsdC50aGVuKChldmVudHMpID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlRnJvbUNhY2hlUmVzdWx0cyhldmVudHMpO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5RnVsbHlGaWxsZWQodGhpcykpIHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZW9zZVwiLCB0aGlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9hZEZyb21SZWxheXMoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZVJlc3VsdC50aGVuKChldmVudHMpID0+IHtcbiAgICAgICAgICB1cGRhdGVTdGF0ZUZyb21DYWNoZVJlc3VsdHMoZXZlbnRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxvYWRGcm9tUmVsYXlzKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdXBkYXRlU3RhdGVGcm9tQ2FjaGVSZXN1bHRzKGNhY2hlUmVzdWx0KTtcbiAgICAgIGlmIChxdWVyeUZ1bGx5RmlsbGVkKHRoaXMpKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImVvc2VcIiwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkRnJvbVJlbGF5cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlUmVzdWx0O1xuICAgIH1cbiAgICBsb2FkRnJvbVJlbGF5cygpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBXZSB3YW50IHRvIG1vbml0b3IgZm9yIG5ldyByZWxheXMgdGhhdCBhcmUgY29taW5nIG9ubGluZSwgaW4gY2FzZVxuICAgKiB0aGV5IHNob3VsZCBiZSBwYXJ0IG9mIHRoaXMgc3Vic2NyaXB0aW9uLlxuICAgKi9cbiAgc3RhcnRQb29sTW9uaXRvcigpIHtcbiAgICBjb25zdCBfZCA9IHRoaXMuZGVidWcuZXh0ZW5kKFwicG9vbC1tb25pdG9yXCIpO1xuICAgIHRoaXMucG9vbE1vbml0b3IgPSAocmVsYXkpID0+IHtcbiAgICAgIGlmICh0aGlzLnJlbGF5RmlsdGVycz8uaGFzKHJlbGF5LnVybCkpIHJldHVybjtcbiAgICAgIGNvbnN0IGNhbGMgPSBjYWxjdWxhdGVSZWxheVNldHNGcm9tRmlsdGVycyh0aGlzLm5kaywgdGhpcy5maWx0ZXJzLCB0aGlzLnBvb2wpO1xuICAgICAgaWYgKGNhbGMuZ2V0KHJlbGF5LnVybCkpIHtcbiAgICAgICAgdGhpcy5yZWxheUZpbHRlcnM/LnNldChyZWxheS51cmwsIHRoaXMuZmlsdGVycyk7XG4gICAgICAgIHJlbGF5LnN1YnNjcmliZSh0aGlzLCB0aGlzLmZpbHRlcnMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5wb29sLm9uKFwicmVsYXk6Y29ubmVjdFwiLCB0aGlzLnBvb2xNb25pdG9yKTtcbiAgfVxuICBvblN0b3BwZWQ7XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5lbWl0KFwiY2xvc2VcIiwgdGhpcyk7XG4gICAgdGhpcy5wb29sTW9uaXRvciAmJiB0aGlzLnBvb2wub2ZmKFwicmVsYXk6Y29ubmVjdFwiLCB0aGlzLnBvb2xNb25pdG9yKTtcbiAgICB0aGlzLm9uU3RvcHBlZD8uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHN1YnNjcmlwdGlvbiBoYXMgYW4gYXV0aG9ycyBmaWx0ZXIuXG4gICAqL1xuICBoYXNBdXRob3JzRmlsdGVyKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcnMuc29tZSgoZikgPT4gZi5hdXRob3JzPy5sZW5ndGgpO1xuICB9XG4gIHN0YXJ0V2l0aENhY2hlKCkge1xuICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXI/LnF1ZXJ5KSB7XG4gICAgICByZXR1cm4gdGhpcy5uZGsuY2FjaGVBZGFwdGVyLnF1ZXJ5KHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgYXZhaWxhYmxlIHJlbGF5cyB0aGF0IHNob3VsZCBiZSBwYXJ0IG9mIHRoaXMgc3Vic2NyaXB0aW9uIGFuZCBleGVjdXRlIGluIHRoZW0uXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIGlzIGV4ZWN1dGVkIGluIGFkZGl0aW9uIHRvIHVzaW5nIHRoZSBwb29sIG1vbml0b3IsIHNvIGV2ZW4gaWYgdGhlIHJlbGF5IHNldFxuICAgKiB0aGF0IGlzIGNvbXB1dGVkIChpLmUuIHdlIGRvbid0IGhhdmUgYW55IHJlbGF5cyBhdmFpbGFibGUpLCB3aGVuIHJlbGF5cyBjb21lIG9ubGluZSwgd2Ugd2lsbFxuICAgKiBjaGVjayBpZiB3ZSBuZWVkIHRvIGV4ZWN1dGUgaW4gdGhlbS5cbiAgICovXG4gIHN0YXJ0V2l0aFJlbGF5cygpIHtcbiAgICBsZXQgZmlsdGVycyA9IHRoaXMuZmlsdGVycztcbiAgICBpZiAodGhpcy5vcHRzLmFkZFNpbmNlRnJvbUNhY2hlICYmIHRoaXMubW9zdFJlY2VudENhY2hlRXZlbnRUaW1lc3RhbXApIHtcbiAgICAgIGNvbnN0IHNpbmNlVGltZXN0YW1wID0gdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCArIDE7XG4gICAgICBmaWx0ZXJzID0gZmlsdGVycy5tYXAoKGZpbHRlcikgPT4gKHtcbiAgICAgICAgLi4uZmlsdGVyLFxuICAgICAgICBzaW5jZTogTWF0aC5tYXgoZmlsdGVyLnNpbmNlIHx8IDAsIHNpbmNlVGltZXN0YW1wKVxuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVsYXlTZXQgfHwgdGhpcy5yZWxheVNldC5yZWxheXMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5yZWxheUZpbHRlcnMgPSBjYWxjdWxhdGVSZWxheVNldHNGcm9tRmlsdGVycyh0aGlzLm5kaywgZmlsdGVycywgdGhpcy5wb29sKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWxheUZpbHRlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCByZWxheSBvZiB0aGlzLnJlbGF5U2V0LnJlbGF5cykge1xuICAgICAgICB0aGlzLnJlbGF5RmlsdGVycy5zZXQocmVsYXkudXJsLCBmaWx0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbcmVsYXlVcmwsIGZpbHRlcnMyXSBvZiB0aGlzLnJlbGF5RmlsdGVycykge1xuICAgICAgY29uc3QgcmVsYXkgPSB0aGlzLnBvb2wuZ2V0UmVsYXkocmVsYXlVcmwsIHRydWUsIHRydWUsIGZpbHRlcnMyKTtcbiAgICAgIHJlbGF5LnN1YnNjcmliZSh0aGlzLCBmaWx0ZXJzMik7XG4gICAgfVxuICB9XG4gIC8vIEVWRU5UIGhhbmRsaW5nXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhbiBldmVudCBpcyByZWNlaXZlZCBmcm9tIGEgcmVsYXkgb3IgdGhlIGNhY2hlXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcGFyYW0gcmVsYXlcbiAgICogQHBhcmFtIGZyb21DYWNoZSBXaGV0aGVyIHRoZSBldmVudCB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgY2FjaGVcbiAgICogQHBhcmFtIG9wdGltaXN0aWNQdWJsaXNoIFdoZXRoZXIgdGhpcyBldmVudCBpcyBjb21pbmcgZnJvbSBhbiBvcHRpbWlzdGljIHB1Ymxpc2hcbiAgICovXG4gIGV2ZW50UmVjZWl2ZWQoZXZlbnQsIHJlbGF5LCBmcm9tQ2FjaGUgPSBmYWxzZSwgb3B0aW1pc3RpY1B1Ymxpc2ggPSBmYWxzZSkge1xuICAgIGNvbnN0IGV2ZW50SWQgPSBldmVudC5pZDtcbiAgICBjb25zdCBldmVudEFscmVhZHlTZWVuID0gdGhpcy5ldmVudEZpcnN0U2Vlbi5oYXMoZXZlbnRJZCk7XG4gICAgbGV0IG5ka0V2ZW50O1xuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIE5ES0V2ZW50KSBuZGtFdmVudCA9IGV2ZW50O1xuICAgIGlmICghZXZlbnRBbHJlYWR5U2Vlbikge1xuICAgICAgbmRrRXZlbnQgPz89IG5ldyBOREtFdmVudCh0aGlzLm5kaywgZXZlbnQpO1xuICAgICAgbmRrRXZlbnQubmRrID0gdGhpcy5uZGs7XG4gICAgICBuZGtFdmVudC5yZWxheSA9IHJlbGF5O1xuICAgICAgaWYgKCFmcm9tQ2FjaGUgJiYgIW9wdGltaXN0aWNQdWJsaXNoKSB7XG4gICAgICAgIGlmICghdGhpcy5za2lwVmFsaWRhdGlvbikge1xuICAgICAgICAgIGlmICghbmRrRXZlbnQuaXNWYWxpZCkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIkV2ZW50IGZhaWxlZCB2YWxpZGF0aW9uICVzIGZyb20gcmVsYXkgJXNcIiwgZXZlbnRJZCwgcmVsYXk/LnVybCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxheSkge1xuICAgICAgICAgIGNvbnN0IHNob3VsZFZlcmlmeSA9IHJlbGF5LnNob3VsZFZhbGlkYXRlRXZlbnQoKTtcbiAgICAgICAgICBpZiAoc2hvdWxkVmVyaWZ5ICYmICF0aGlzLnNraXBWZXJpZmljYXRpb24pIHtcbiAgICAgICAgICAgIG5ka0V2ZW50LnJlbGF5ID0gcmVsYXk7XG4gICAgICAgICAgICBpZiAoIXRoaXMubmRrLmFzeW5jU2lnVmVyaWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAgIGlmICghbmRrRXZlbnQudmVyaWZ5U2lnbmF0dXJlKHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIkV2ZW50IGZhaWxlZCBzaWduYXR1cmUgdmFsaWRhdGlvblwiLCBldmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5uZGsucmVwb3J0SW52YWxpZFNpZ25hdHVyZShuZGtFdmVudCwgcmVsYXkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZWxheS5hZGRWYWxpZGF0ZWRFdmVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWxheS5hZGROb25WYWxpZGF0ZWRFdmVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZGsuY2FjaGVBZGFwdGVyICYmICF0aGlzLm9wdHMuZG9udFNhdmVUb0NhY2hlKSB7XG4gICAgICAgICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLnNldEV2ZW50KG5ka0V2ZW50LCB0aGlzLmZpbHRlcnMsIHJlbGF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFvcHRpbWlzdGljUHVibGlzaCB8fCB0aGlzLnNraXBPcHRpbWlzdGljUHVibGlzaEV2ZW50ICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KHRoaXMub3B0cz8ud3JhcCA/PyBmYWxzZSwgbmRrRXZlbnQsIHJlbGF5LCBmcm9tQ2FjaGUsIG9wdGltaXN0aWNQdWJsaXNoKTtcbiAgICAgICAgdGhpcy5ldmVudEZpcnN0U2Vlbi5zZXQoZXZlbnRJZCwgRGF0ZS5ub3coKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRpbWVTaW5jZUZpcnN0U2VlbiA9IERhdGUubm93KCkgLSAodGhpcy5ldmVudEZpcnN0U2Vlbi5nZXQoZXZlbnRJZCkgfHwgMCk7XG4gICAgICB0aGlzLmVtaXQoXCJldmVudDpkdXBcIiwgZXZlbnQsIHJlbGF5LCB0aW1lU2luY2VGaXJzdFNlZW4sIHRoaXMsIGZyb21DYWNoZSwgb3B0aW1pc3RpY1B1Ymxpc2gpO1xuICAgICAgaWYgKHJlbGF5KSB7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHZlcmlmaWVkU2lnbmF0dXJlcy5nZXQoZXZlbnRJZCk7XG4gICAgICAgIGlmIChzaWduYXR1cmUgJiYgdHlwZW9mIHNpZ25hdHVyZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmIChldmVudC5zaWcgPT09IHNpZ25hdHVyZSkge1xuICAgICAgICAgICAgcmVsYXkuYWRkVmFsaWRhdGVkRXZlbnQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUb1JlcG9ydCA9IGV2ZW50IGluc3RhbmNlb2YgTkRLRXZlbnQgPyBldmVudCA6IG5ldyBOREtFdmVudCh0aGlzLm5kaywgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5uZGsucmVwb3J0SW52YWxpZFNpZ25hdHVyZShldmVudFRvUmVwb3J0LCByZWxheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGFzdEV2ZW50UmVjZWl2ZWRBdCA9IERhdGUubm93KCk7XG4gIH1cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgd3JhcHMsIHN5bmMgb3IgYXN5bmMsIGFuZCBlbWl0cyB0aGUgZXZlbnQgKGlmIG9uZSBjb21lcyBiYWNrIGZyb20gdGhlIHdyYXBwZXIpXG4gICAqL1xuICBlbWl0RXZlbnQod3JhcCwgZXZ0LCByZWxheSwgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCkge1xuICAgIGNvbnN0IHdyYXBwZWQgPSB3cmFwID8gd3JhcEV2ZW50KGV2dCkgOiBldnQ7XG4gICAgaWYgKHdyYXBwZWQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICB3cmFwcGVkLnRoZW4oKGUpID0+IHRoaXMuZW1pdEV2ZW50KGZhbHNlLCBlLCByZWxheSwgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCkpO1xuICAgIH0gZWxzZSBpZiAod3JhcHBlZCkge1xuICAgICAgdGhpcy5lbWl0KFwiZXZlbnRcIiwgd3JhcHBlZCwgcmVsYXksIHRoaXMsIGZyb21DYWNoZSwgb3B0aW1pc3RpY1B1Ymxpc2gpO1xuICAgIH1cbiAgfVxuICBjbG9zZWRSZWNlaXZlZChyZWxheSwgcmVhc29uKSB7XG4gICAgdGhpcy5lbWl0KFwiY2xvc2VkXCIsIHJlbGF5LCByZWFzb24pO1xuICB9XG4gIC8vIEVPU0UgaGFuZGxpbmdcbiAgZW9zZVRpbWVvdXQ7XG4gIGVvc2VkID0gZmFsc2U7XG4gIGVvc2VSZWNlaXZlZChyZWxheSkge1xuICAgIHRoaXMuZGVidWcoXCJFT1NFIHJlY2VpdmVkIGZyb20gJXNcIiwgcmVsYXkudXJsKTtcbiAgICB0aGlzLmVvc2VzU2Vlbi5hZGQocmVsYXkpO1xuICAgIGxldCBsYXN0RXZlbnRTZWVuID0gdGhpcy5sYXN0RXZlbnRSZWNlaXZlZEF0ID8gRGF0ZS5ub3coKSAtIHRoaXMubGFzdEV2ZW50UmVjZWl2ZWRBdCA6IHZvaWQgMDtcbiAgICBjb25zdCBoYXNTZWVuQWxsRW9zZXMgPSB0aGlzLmVvc2VzU2Vlbi5zaXplID09PSB0aGlzLnJlbGF5RmlsdGVycz8uc2l6ZTtcbiAgICBjb25zdCBxdWVyeUZpbGxlZCA9IHF1ZXJ5RnVsbHlGaWxsZWQodGhpcyk7XG4gICAgY29uc3QgcGVyZm9ybUVvc2UgPSAocmVhc29uKSA9PiB7XG4gICAgICB0aGlzLmRlYnVnKFwiUGVyZm9ybWluZyBFT1NFOiAlcyAlZFwiLCByZWFzb24sIHRoaXMuZW9zZWQpO1xuICAgICAgaWYgKHRoaXMuZW9zZWQpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmVvc2VUaW1lb3V0KSBjbGVhclRpbWVvdXQodGhpcy5lb3NlVGltZW91dCk7XG4gICAgICB0aGlzLmVtaXQoXCJlb3NlXCIsIHRoaXMpO1xuICAgICAgdGhpcy5lb3NlZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5vcHRzPy5jbG9zZU9uRW9zZSkgdGhpcy5zdG9wKCk7XG4gICAgfTtcbiAgICBpZiAocXVlcnlGaWxsZWQgfHwgaGFzU2VlbkFsbEVvc2VzKSB7XG4gICAgICBwZXJmb3JtRW9zZShcInF1ZXJ5IGZpbGxlZCBvciBzZWVuIGFsbFwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVsYXlGaWx0ZXJzKSB7XG4gICAgICBsZXQgdGltZVRvV2FpdEZvck5leHRFb3NlID0gMWUzO1xuICAgICAgY29uc3QgY29ubmVjdGVkUmVsYXlzID0gbmV3IFNldCh0aGlzLnBvb2wuY29ubmVjdGVkUmVsYXlzKCkubWFwKChyKSA9PiByLnVybCkpO1xuICAgICAgY29uc3QgY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMgPSBBcnJheS5mcm9tKHRoaXMucmVsYXlGaWx0ZXJzLmtleXMoKSkuZmlsdGVyKFxuICAgICAgICAodXJsKSA9PiBjb25uZWN0ZWRSZWxheXMuaGFzKHVybClcbiAgICAgICk7XG4gICAgICBpZiAoY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgICAgXCJObyBjb25uZWN0ZWQgcmVsYXlzLCB3YWl0aW5nIGZvciBhbGwgcmVsYXlzIHRvIGNvbm5lY3RcIixcbiAgICAgICAgICBBcnJheS5mcm9tKHRoaXMucmVsYXlGaWx0ZXJzLmtleXMoKSkuam9pbihcIiwgXCIpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2VPZlJlbGF5c1RoYXRIYXZlU2VudEVvc2UgPSB0aGlzLmVvc2VzU2Vlbi5zaXplIC8gY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMubGVuZ3RoO1xuICAgICAgdGhpcy5kZWJ1ZyhcIlBlcmNlbnRhZ2Ugb2YgcmVsYXlzIHRoYXQgaGF2ZSBzZW50IEVPU0VcIiwge1xuICAgICAgICBzdWJJZDogdGhpcy5zdWJJZCxcbiAgICAgICAgcGVyY2VudGFnZU9mUmVsYXlzVGhhdEhhdmVTZW50RW9zZSxcbiAgICAgICAgc2VlbjogdGhpcy5lb3Nlc1NlZW4uc2l6ZSxcbiAgICAgICAgdG90YWw6IGNvbm5lY3RlZFJlbGF5c1dpdGhGaWx0ZXJzLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5lb3Nlc1NlZW4uc2l6ZSA+PSAyICYmIHBlcmNlbnRhZ2VPZlJlbGF5c1RoYXRIYXZlU2VudEVvc2UgPj0gMC41KSB7XG4gICAgICAgIHRpbWVUb1dhaXRGb3JOZXh0RW9zZSA9IHRpbWVUb1dhaXRGb3JOZXh0RW9zZSAqICgxIC0gcGVyY2VudGFnZU9mUmVsYXlzVGhhdEhhdmVTZW50RW9zZSk7XG4gICAgICAgIGlmICh0aW1lVG9XYWl0Rm9yTmV4dEVvc2UgPT09IDApIHtcbiAgICAgICAgICBwZXJmb3JtRW9zZShcInRpbWUgdG8gd2FpdCB3YXMgMFwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW9zZVRpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLmVvc2VUaW1lb3V0KTtcbiAgICAgICAgY29uc3Qgc2VuZEVvc2VUaW1lb3V0ID0gKCkgPT4ge1xuICAgICAgICAgIGxhc3RFdmVudFNlZW4gPSB0aGlzLmxhc3RFdmVudFJlY2VpdmVkQXQgPyBEYXRlLm5vdygpIC0gdGhpcy5sYXN0RXZlbnRSZWNlaXZlZEF0IDogdm9pZCAwO1xuICAgICAgICAgIGlmIChsYXN0RXZlbnRTZWVuICE9PSB2b2lkIDAgJiYgbGFzdEV2ZW50U2VlbiA8IDIwKSB7XG4gICAgICAgICAgICB0aGlzLmVvc2VUaW1lb3V0ID0gc2V0VGltZW91dChzZW5kRW9zZVRpbWVvdXQsIHRpbWVUb1dhaXRGb3JOZXh0RW9zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlcmZvcm1Fb3NlKGBzZW5kIGVvc2UgdGltZW91dDogJHt0aW1lVG9XYWl0Rm9yTmV4dEVvc2V9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVvc2VUaW1lb3V0ID0gc2V0VGltZW91dChzZW5kRW9zZVRpbWVvdXQsIHRpbWVUb1dhaXRGb3JOZXh0RW9zZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIGtpbmRJc0VwaGVtZXJhbCA9IChraW5kKSA9PiBraW5kID49IDJlNCAmJiBraW5kIDwgM2U0O1xuXG4vLyBzcmMvdXNlci9mb2xsb3dzLnRzXG5hc3luYyBmdW5jdGlvbiBmb2xsb3dzKG9wdHMsIG91dGJveCwga2luZCA9IDMgLyogQ29udGFjdHMgKi8pIHtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIG5vdCBzZXRcIik7XG4gIGNvbnN0IGNvbnRhY3RMaXN0RXZlbnQgPSBhd2FpdCB0aGlzLm5kay5mZXRjaEV2ZW50KFxuICAgIHsga2luZHM6IFtraW5kXSwgYXV0aG9yczogW3RoaXMucHVia2V5XSB9LFxuICAgIG9wdHMgfHwgeyBncm91cGFibGU6IGZhbHNlIH1cbiAgKTtcbiAgaWYgKGNvbnRhY3RMaXN0RXZlbnQpIHtcbiAgICBjb25zdCBwdWJrZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb250YWN0TGlzdEV2ZW50LnRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICBpZiAodGFnWzBdID09PSBcInBcIikgcHVia2V5cy5hZGQodGFnWzFdKTtcbiAgICB9KTtcbiAgICBpZiAob3V0Ym94KSB7XG4gICAgICB0aGlzLm5kaz8ub3V0Ym94VHJhY2tlcj8udHJhY2tVc2VycyhBcnJheS5mcm9tKHB1YmtleXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIFsuLi5wdWJrZXlzXS5yZWR1Y2UoKGFjYywgcHVia2V5KSA9PiB7XG4gICAgICBjb25zdCB1c2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXkgfSk7XG4gICAgICB1c2VyLm5kayA9IHRoaXMubmRrO1xuICAgICAgYWNjLmFkZCh1c2VyKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG59XG5cbi8vIHNyYy91c2VyL25pcDA1LnRzXG52YXIgTklQMDVfUkVHRVggPSAvXig/OihbXFx3ListXSspQCk/KFtcXHcuLV0rKSQvO1xuYXN5bmMgZnVuY3Rpb24gZ2V0TmlwMDVGb3IobmRrLCBmdWxsbmFtZSwgX2ZldGNoID0gZmV0Y2gsIGZldGNoT3B0cyA9IHt9KSB7XG4gIHJldHVybiBhd2FpdCBuZGsucXVldWVzTmlwMDUuYWRkKHtcbiAgICBpZDogZnVsbG5hbWUsXG4gICAgZnVuYzogYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKG5kay5jYWNoZUFkYXB0ZXI/LmxvYWROaXAwNSkge1xuICAgICAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgbmRrLmNhY2hlQWRhcHRlci5sb2FkTmlwMDUoZnVsbG5hbWUpO1xuICAgICAgICBpZiAocHJvZmlsZSAhPT0gXCJtaXNzaW5nXCIpIHtcbiAgICAgICAgICBpZiAocHJvZmlsZSkge1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHtcbiAgICAgICAgICAgICAgcHVia2V5OiBwcm9maWxlLnB1YmtleSxcbiAgICAgICAgICAgICAgcmVsYXlVcmxzOiBwcm9maWxlLnJlbGF5cyxcbiAgICAgICAgICAgICAgbmlwNDZVcmxzOiBwcm9maWxlLm5pcDQ2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVzZXIubmRrID0gbmRrO1xuICAgICAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmZXRjaE9wdHMuY2FjaGUgIT09IFwibm8tY2FjaGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBtYXRjaCA9IGZ1bGxuYW1lLm1hdGNoKE5JUDA1X1JFR0VYKTtcbiAgICAgIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgW18sIG5hbWUgPSBcIl9cIiwgZG9tYWluXSA9IG1hdGNoO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgX2ZldGNoKGBodHRwczovLyR7ZG9tYWlufS8ud2VsbC1rbm93bi9ub3N0ci5qc29uP25hbWU9JHtuYW1lfWAsIGZldGNoT3B0cyk7XG4gICAgICAgIGNvbnN0IHsgbmFtZXMsIHJlbGF5cywgbmlwNDYgfSA9IHBhcnNlTklQMDVSZXN1bHQoYXdhaXQgcmVzLmpzb24oKSk7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IG5hbWVzW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGxldCBwcm9maWxlID0gbnVsbDtcbiAgICAgICAgaWYgKHB1YmtleSkge1xuICAgICAgICAgIHByb2ZpbGUgPSB7IHB1YmtleSwgcmVsYXlzOiByZWxheXM/LltwdWJrZXldLCBuaXA0NjogbmlwNDY/LltwdWJrZXldIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5kaz8uY2FjaGVBZGFwdGVyPy5zYXZlTmlwMDUpIHtcbiAgICAgICAgICBuZGsuY2FjaGVBZGFwdGVyLnNhdmVOaXAwNShmdWxsbmFtZSwgcHJvZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2ZpbGU7XG4gICAgICB9IGNhdGNoIChfZSkge1xuICAgICAgICBpZiAobmRrPy5jYWNoZUFkYXB0ZXI/LnNhdmVOaXAwNSkge1xuICAgICAgICAgIG5kaz8uY2FjaGVBZGFwdGVyLnNhdmVOaXAwNShmdWxsbmFtZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBOSVAwNSBmb3JcIiwgZnVsbG5hbWUsIF9lKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlTklQMDVSZXN1bHQoanNvbikge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgbmFtZXM6IHt9XG4gIH07XG4gIGZvciAoY29uc3QgW25hbWUsIHB1YmtleV0gb2YgT2JqZWN0LmVudHJpZXMoanNvbi5uYW1lcykpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHB1YmtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVzdWx0Lm5hbWVzW25hbWUudG9Mb3dlckNhc2UoKV0gPSBwdWJrZXk7XG4gICAgfVxuICB9XG4gIGlmIChqc29uLnJlbGF5cykge1xuICAgIHJlc3VsdC5yZWxheXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtwdWJrZXksIHJlbGF5c10gb2YgT2JqZWN0LmVudHJpZXMoanNvbi5yZWxheXMpKSB7XG4gICAgICBpZiAodHlwZW9mIHB1YmtleSA9PT0gXCJzdHJpbmdcIiAmJiBBcnJheS5pc0FycmF5KHJlbGF5cykpIHtcbiAgICAgICAgcmVzdWx0LnJlbGF5c1twdWJrZXldID0gcmVsYXlzLmZpbHRlcigocmVsYXkpID0+IHR5cGVvZiByZWxheSA9PT0gXCJzdHJpbmdcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChqc29uLm5pcDQ2KSB7XG4gICAgcmVzdWx0Lm5pcDQ2ID0ge307XG4gICAgZm9yIChjb25zdCBbcHVia2V5LCBuaXA0Nl0gb2YgT2JqZWN0LmVudHJpZXMoanNvbi5uaXA0NikpIHtcbiAgICAgIGlmICh0eXBlb2YgcHVia2V5ID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkobmlwNDYpKSB7XG4gICAgICAgIHJlc3VsdC5uaXA0NltwdWJrZXldID0gbmlwNDYuZmlsdGVyKChyZWxheSkgPT4gdHlwZW9mIHJlbGF5ID09PSBcInN0cmluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3VzZXIvcHJvZmlsZS50c1xuZnVuY3Rpb24gcHJvZmlsZUZyb21FdmVudChldmVudCkge1xuICBjb25zdCBwcm9maWxlID0ge307XG4gIGxldCBwYXlsb2FkO1xuICB0cnkge1xuICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGV2ZW50LmNvbnRlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHByb2ZpbGUgZXZlbnQ6ICR7ZXJyb3J9YCk7XG4gIH1cbiAgcHJvZmlsZS5wcm9maWxlRXZlbnQgPSBKU09OLnN0cmluZ2lmeShldmVudC5yYXdFdmVudCgpKTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGF5bG9hZCkpIHtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgcHJvZmlsZS5uYW1lID0gcGF5bG9hZC5uYW1lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXNwbGF5X25hbWVcIjpcbiAgICAgICAgcHJvZmlsZS5kaXNwbGF5TmFtZSA9IHBheWxvYWQuZGlzcGxheV9uYW1lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgY2FzZSBcInBpY3R1cmVcIjpcbiAgICAgICAgcHJvZmlsZS5waWN0dXJlID0gcGF5bG9hZC5waWN0dXJlIHx8IHBheWxvYWQuaW1hZ2U7XG4gICAgICAgIHByb2ZpbGUuaW1hZ2UgPSBwcm9maWxlLnBpY3R1cmU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJhbm5lclwiOlxuICAgICAgICBwcm9maWxlLmJhbm5lciA9IHBheWxvYWQuYmFubmVyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJiaW9cIjpcbiAgICAgICAgcHJvZmlsZS5iaW8gPSBwYXlsb2FkLmJpbztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibmlwMDVcIjpcbiAgICAgICAgcHJvZmlsZS5uaXAwNSA9IHBheWxvYWQubmlwMDU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImx1ZDA2XCI6XG4gICAgICAgIHByb2ZpbGUubHVkMDYgPSBwYXlsb2FkLmx1ZDA2O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsdWQxNlwiOlxuICAgICAgICBwcm9maWxlLmx1ZDE2ID0gcGF5bG9hZC5sdWQxNjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYWJvdXRcIjpcbiAgICAgICAgcHJvZmlsZS5hYm91dCA9IHBheWxvYWQuYWJvdXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIndlYnNpdGVcIjpcbiAgICAgICAgcHJvZmlsZS53ZWJzaXRlID0gcGF5bG9hZC53ZWJzaXRlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHByb2ZpbGVba2V5XSA9IHBheWxvYWRba2V5XTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHByb2ZpbGUuY3JlYXRlZF9hdCA9IGV2ZW50LmNyZWF0ZWRfYXQ7XG4gIHJldHVybiBwcm9maWxlO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplUHJvZmlsZShwcm9maWxlKSB7XG4gIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHByb2ZpbGUpKSB7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgXCJ1c2VybmFtZVwiOlxuICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgcGF5bG9hZC5uYW1lID0gdmFsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXNwbGF5TmFtZVwiOlxuICAgICAgICBwYXlsb2FkLmRpc3BsYXlfbmFtZSA9IHZhbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgIGNhc2UgXCJwaWN0dXJlXCI6XG4gICAgICAgIHBheWxvYWQucGljdHVyZSA9IHZhbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmlvXCI6XG4gICAgICBjYXNlIFwiYWJvdXRcIjpcbiAgICAgICAgcGF5bG9hZC5hYm91dCA9IHZhbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBwYXlsb2FkW2tleV0gPSB2YWw7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG59XG5cbi8vIHNyYy91c2VyL2luZGV4LnRzXG52YXIgTkRLVXNlciA9IGNsYXNzIF9OREtVc2VyIHtcbiAgbmRrO1xuICBwcm9maWxlO1xuICBwcm9maWxlRXZlbnQ7XG4gIF9ucHViO1xuICBfcHVia2V5O1xuICByZWxheVVybHMgPSBbXTtcbiAgbmlwNDZVcmxzID0gW107XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBpZiAob3B0cy5ucHViKSB0aGlzLl9ucHViID0gb3B0cy5ucHViO1xuICAgIGlmIChvcHRzLmhleHB1YmtleSkgdGhpcy5fcHVia2V5ID0gb3B0cy5oZXhwdWJrZXk7XG4gICAgaWYgKG9wdHMucHVia2V5KSB0aGlzLl9wdWJrZXkgPSBvcHRzLnB1YmtleTtcbiAgICBpZiAob3B0cy5yZWxheVVybHMpIHRoaXMucmVsYXlVcmxzID0gb3B0cy5yZWxheVVybHM7XG4gICAgaWYgKG9wdHMubmlwNDZVcmxzKSB0aGlzLm5pcDQ2VXJscyA9IG9wdHMubmlwNDZVcmxzO1xuICAgIGlmIChvcHRzLm5wcm9maWxlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gbmlwMTk1LmRlY29kZShvcHRzLm5wcm9maWxlKTtcbiAgICAgICAgaWYgKGRlY29kZWQudHlwZSA9PT0gXCJucHJvZmlsZVwiKSB7XG4gICAgICAgICAgdGhpcy5fcHVia2V5ID0gZGVjb2RlZC5kYXRhLnB1YmtleTtcbiAgICAgICAgICBpZiAoZGVjb2RlZC5kYXRhLnJlbGF5cyAmJiBkZWNvZGVkLmRhdGEucmVsYXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVsYXlVcmxzLnB1c2goLi4uZGVjb2RlZC5kYXRhLnJlbGF5cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZGVjb2RlIG5wcm9maWxlXCIsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgbnB1YigpIHtcbiAgICBpZiAoIXRoaXMuX25wdWIpIHtcbiAgICAgIGlmICghdGhpcy5fcHVia2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMuX25wdWIgPSBuaXAxOTUubnB1YkVuY29kZSh0aGlzLnB1YmtleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ucHViO1xuICB9XG4gIGdldCBucHJvZmlsZSgpIHtcbiAgICBjb25zdCByZWxheXMgPSB0aGlzLnByb2ZpbGVFdmVudD8ub25SZWxheXM/Lm1hcCgocikgPT4gci51cmwpO1xuICAgIHJldHVybiBuaXAxOTUubnByb2ZpbGVFbmNvZGUoe1xuICAgICAgcHVia2V5OiB0aGlzLnB1YmtleSxcbiAgICAgIHJlbGF5c1xuICAgIH0pO1xuICB9XG4gIHNldCBucHViKG5wdWIyKSB7XG4gICAgdGhpcy5fbnB1YiA9IG5wdWIyO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIncyBwdWJrZXlcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHVzZXIncyBwdWJrZXlcbiAgICovXG4gIGdldCBwdWJrZXkoKSB7XG4gICAgaWYgKCF0aGlzLl9wdWJrZXkpIHtcbiAgICAgIGlmICghdGhpcy5fbnB1YikgdGhyb3cgbmV3IEVycm9yKFwibnB1YiBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5fcHVia2V5ID0gbmlwMTk1LmRlY29kZSh0aGlzLm5wdWIpLmRhdGE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wdWJrZXk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgdXNlcidzIHB1YmtleVxuICAgKiBAcGFyYW0gcHVia2V5IHtzdHJpbmd9IFRoZSB1c2VyJ3MgcHVia2V5XG4gICAqL1xuICBzZXQgcHVia2V5KHB1YmtleSkge1xuICAgIHRoaXMuX3B1YmtleSA9IHB1YmtleTtcbiAgfVxuICAvKipcbiAgICogRXF1aXZhbGVudCB0byBOREtFdmVudC5maWx0ZXJzKCkuXG4gICAqIEByZXR1cm5zIHtOREtGaWx0ZXJ9XG4gICAqL1xuICBmaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHsgXCIjcFwiOiBbdGhpcy5wdWJrZXldIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgTklQLTU3IGFuZCBOSVAtNjEgaW5mb3JtYXRpb24gdGhhdCB0aGlzIHVzZXIgaGFzIHNpZ25hbGVkXG4gICAqXG4gICAqIEBwYXJhbSBnZXRBbGwge2Jvb2xlYW59IFdoZXRoZXIgdG8gZ2V0IGFsbCB6YXAgaW5mbyBvciBqdXN0IHRoZSBmaXJzdCBvbmVcbiAgICovXG4gIGFzeW5jIGdldFphcEluZm8odGltZW91dE1zKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIGNvbnN0IHByb21pc2VXaXRoVGltZW91dCA9IGFzeW5jIChwcm9taXNlKSA9PiB7XG4gICAgICBpZiAoIXRpbWVvdXRNcykgcmV0dXJuIHByb21pc2U7XG4gICAgICBsZXQgdGltZW91dElkO1xuICAgICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcihcIlRpbWVvdXRcIikpLCB0aW1lb3V0TXMpO1xuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW3Byb21pc2UsIHRpbWVvdXRQcm9taXNlXSk7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZSA9PT0gXCJUaW1lb3V0XCIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSBjYXRjaCAoX29yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBbdXNlclByb2ZpbGUsIG1pbnRMaXN0RXZlbnRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgcHJvbWlzZVdpdGhUaW1lb3V0KHRoaXMuZmV0Y2hQcm9maWxlKCkpLFxuICAgICAgcHJvbWlzZVdpdGhUaW1lb3V0KHRoaXMubmRrLmZldGNoRXZlbnQoeyBraW5kczogWzEwMDE5IC8qIENhc2h1TWludExpc3QgKi9dLCBhdXRob3JzOiBbdGhpcy5wdWJrZXldIH0pKVxuICAgIF0pO1xuICAgIGNvbnN0IHJlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKG1pbnRMaXN0RXZlbnQpIHtcbiAgICAgIGNvbnN0IG1pbnRMaXN0ID0gTkRLQ2FzaHVNaW50TGlzdC5mcm9tKG1pbnRMaXN0RXZlbnQpO1xuICAgICAgaWYgKG1pbnRMaXN0Lm1pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzLnNldChcIm5pcDYxXCIsIHtcbiAgICAgICAgICBtaW50czogbWludExpc3QubWludHMsXG4gICAgICAgICAgcmVsYXlzOiBtaW50TGlzdC5yZWxheXMsXG4gICAgICAgICAgcDJwazogbWludExpc3QucDJwa1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVzZXJQcm9maWxlKSB7XG4gICAgICBjb25zdCB7IGx1ZDA2LCBsdWQxNiB9ID0gdXNlclByb2ZpbGU7XG4gICAgICByZXMuc2V0KFwibmlwNTdcIiwgeyBsdWQwNiwgbHVkMTYgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIGFuIE5ES1VzZXIgZnJvbSBhIE5JUC0wNSBzdHJpbmdcbiAgICogQHBhcmFtIG5pcDA1SWQge3N0cmluZ30gVGhlIHVzZXIncyBOSVAtMDVcbiAgICogQHBhcmFtIG5kayB7TkRLfSBBbiBOREsgaW5zdGFuY2VcbiAgICogQHBhcmFtIHNraXBDYWNoZSB7Ym9vbGVhbn0gV2hldGhlciB0byBza2lwIHRoZSBjYWNoZSBvciBub3RcbiAgICogQHJldHVybnMge05ES1VzZXIgfCB1bmRlZmluZWR9IEFuIE5ES1VzZXIgaWYgb25lIGlzIGZvdW5kIGZvciB0aGUgZ2l2ZW4gTklQLTA1LCB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21OaXAwNShuaXAwNUlkLCBuZGssIHNraXBDYWNoZSA9IGZhbHNlKSB7XG4gICAgaWYgKCFuZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICBjb25zdCBvcHRzID0ge307XG4gICAgaWYgKHNraXBDYWNoZSkgb3B0cy5jYWNoZSA9IFwibm8tY2FjaGVcIjtcbiAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgZ2V0TmlwMDVGb3IobmRrLCBuaXAwNUlkLCBuZGs/Lmh0dHBGZXRjaCwgb3B0cyk7XG4gICAgaWYgKHByb2ZpbGUpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBuZXcgX05ES1VzZXIoe1xuICAgICAgICBwdWJrZXk6IHByb2ZpbGUucHVia2V5LFxuICAgICAgICByZWxheVVybHM6IHByb2ZpbGUucmVsYXlzLFxuICAgICAgICBuaXA0NlVybHM6IHByb2ZpbGUubmlwNDZcbiAgICAgIH0pO1xuICAgICAgdXNlci5uZGsgPSBuZGs7XG4gICAgICByZXR1cm4gdXNlcjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgdXNlcidzIHByb2ZpbGVcbiAgICogQHBhcmFtIG9wdHMge05ES1N1YnNjcmlwdGlvbk9wdGlvbnN9IEEgc2V0IG9mIE5ES1N1YnNjcmlwdGlvbk9wdGlvbnNcbiAgICogQHBhcmFtIHN0b3JlUHJvZmlsZUV2ZW50IHtib29sZWFufSBXaGV0aGVyIHRvIHN0b3JlIHRoZSBwcm9maWxlIGV2ZW50IG9yIG5vdFxuICAgKiBAcmV0dXJucyBVc2VyIFByb2ZpbGVcbiAgICovXG4gIGFzeW5jIGZldGNoUHJvZmlsZShvcHRzLCBzdG9yZVByb2ZpbGVFdmVudCA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIG5vdCBzZXRcIik7XG4gICAgbGV0IHNldE1ldGFkYXRhRXZlbnQgPSBudWxsO1xuICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXIgJiYgKHRoaXMubmRrLmNhY2hlQWRhcHRlci5mZXRjaFByb2ZpbGUgfHwgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmZldGNoUHJvZmlsZVN5bmMpICYmIG9wdHM/LmNhY2hlVXNhZ2UgIT09IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi8pIHtcbiAgICAgIGxldCBwcm9maWxlID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZmV0Y2hQcm9maWxlU3luYykge1xuICAgICAgICBwcm9maWxlID0gdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmZldGNoUHJvZmlsZVN5bmModGhpcy5wdWJrZXkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZmV0Y2hQcm9maWxlKSB7XG4gICAgICAgIHByb2ZpbGUgPSBhd2FpdCB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZmV0Y2hQcm9maWxlKHRoaXMucHVia2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9maWxlKSB7XG4gICAgICAgIHRoaXMucHJvZmlsZSA9IHByb2ZpbGU7XG4gICAgICAgIHJldHVybiBwcm9maWxlO1xuICAgICAgfVxuICAgIH1cbiAgICBvcHRzID8/PSB7fTtcbiAgICBvcHRzLmNhY2hlVXNhZ2UgPz89IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi87XG4gICAgb3B0cy5jbG9zZU9uRW9zZSA/Pz0gdHJ1ZTtcbiAgICBvcHRzLmdyb3VwYWJsZSA/Pz0gdHJ1ZTtcbiAgICBvcHRzLmdyb3VwYWJsZURlbGF5ID8/PSAyNTA7XG4gICAgaWYgKCFzZXRNZXRhZGF0YUV2ZW50KSB7XG4gICAgICBzZXRNZXRhZGF0YUV2ZW50ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudCh7IGtpbmRzOiBbMF0sIGF1dGhvcnM6IFt0aGlzLnB1YmtleV0gfSwgb3B0cyk7XG4gICAgfVxuICAgIGlmICghc2V0TWV0YWRhdGFFdmVudCkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5wcm9maWxlID0gcHJvZmlsZUZyb21FdmVudChzZXRNZXRhZGF0YUV2ZW50KTtcbiAgICBpZiAoc3RvcmVQcm9maWxlRXZlbnQgJiYgdGhpcy5wcm9maWxlICYmIHRoaXMubmRrLmNhY2hlQWRhcHRlciAmJiB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuc2F2ZVByb2ZpbGUpIHtcbiAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5zYXZlUHJvZmlsZSh0aGlzLnB1YmtleSwgdGhpcy5wcm9maWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvZmlsZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNldCBvZiB1c2VycyB0aGF0IHRoaXMgdXNlciBmb2xsb3dzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZm9sbG93U2V0IGluc3RlYWRcbiAgICovXG4gIGZvbGxvd3MgPSBmb2xsb3dzLmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2V0IG9mIHB1YmtleXMgdGhhdCB0aGlzIHVzZXIgZm9sbG93cy5cbiAgICpcbiAgICogQHBhcmFtIG9wdHMgLSBOREtTdWJzY3JpcHRpb25PcHRpb25zXG4gICAqIEBwYXJhbSBvdXRib3ggLSBib29sZWFuXG4gICAqIEBwYXJhbSBraW5kIC0gbnVtYmVyXG4gICAqL1xuICBhc3luYyBmb2xsb3dTZXQob3B0cywgb3V0Ym94LCBraW5kID0gMyAvKiBDb250YWN0cyAqLykge1xuICAgIGNvbnN0IGZvbGxvd3MyID0gYXdhaXQgdGhpcy5mb2xsb3dzKG9wdHMsIG91dGJveCwga2luZCk7XG4gICAgcmV0dXJuIG5ldyBTZXQoQXJyYXkuZnJvbShmb2xsb3dzMikubWFwKChmKSA9PiBmLnB1YmtleSkpO1xuICB9XG4gIC8qKiBAZGVwcmVjYXRlZCBVc2UgcmVmZXJlbmNlVGFncyBpbnN0ZWFkLiAqL1xuICAvKipcbiAgICogR2V0IHRoZSB0YWcgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyB1c2VyIGluIGFuIGV2ZW50XG4gICAqIEByZXR1cm5zIHtOREtUYWd9IGFuIE5ES1RhZ1xuICAgKi9cbiAgdGFnUmVmZXJlbmNlKCkge1xuICAgIHJldHVybiBbXCJwXCIsIHRoaXMucHVia2V5XTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB0YWdzIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVmZXJlbmNlIHRoaXMgdXNlciBpbiBhbiBldmVudFxuICAgKiBAcmV0dXJucyB7TkRLVGFnW119IGFuIGFycmF5IG9mIE5ES1RhZ1xuICAgKi9cbiAgcmVmZXJlbmNlVGFncyhtYXJrZXIpIHtcbiAgICBjb25zdCB0YWcgPSBbW1wicFwiLCB0aGlzLnB1YmtleV1dO1xuICAgIGlmICghbWFya2VyKSByZXR1cm4gdGFnO1xuICAgIHRhZ1swXS5wdXNoKFwiXCIsIG1hcmtlcik7XG4gICAgcmV0dXJuIHRhZztcbiAgfVxuICAvKipcbiAgICogUHVibGlzaGVzIHRoZSBjdXJyZW50IHByb2ZpbGUuXG4gICAqL1xuICBhc3luYyBwdWJsaXNoKCkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICBpZiAoIXRoaXMucHJvZmlsZSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gcHJvZmlsZSBhdmFpbGFibGVcIik7XG4gICAgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IDAsXG4gICAgICBjb250ZW50OiBzZXJpYWxpemVQcm9maWxlKHRoaXMucHJvZmlsZSlcbiAgICB9KTtcbiAgICBhd2FpdCBldmVudC5wdWJsaXNoKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIGZvbGxvdyB0byB0aGlzIHVzZXIncyBjb250YWN0IGxpc3RcbiAgICpcbiAgICogQHBhcmFtIG5ld0ZvbGxvdyB7TkRLVXNlcn0gVGhlIHVzZXIgdG8gZm9sbG93XG4gICAqIEBwYXJhbSBjdXJyZW50Rm9sbG93TGlzdCB7U2V0PE5ES1VzZXI+fSBUaGUgY3VycmVudCBmb2xsb3cgbGlzdFxuICAgKiBAcGFyYW0ga2luZCB7TkRLS2luZH0gVGhlIGtpbmQgdG8gdXNlIGZvciB0aGlzIGNvbnRhY3QgbGlzdCAoZGVmYXVsdHMgdG8gYDNgKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gVHJ1ZSBpZiB0aGUgZm9sbG93IHdhcyBhZGRlZCwgZmFsc2UgaWYgdGhlIGZvbGxvdyBhbHJlYWR5IGV4aXN0c1xuICAgKi9cbiAgYXN5bmMgZm9sbG93KG5ld0ZvbGxvdywgY3VycmVudEZvbGxvd0xpc3QsIGtpbmQgPSAzIC8qIENvbnRhY3RzICovKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGlmICghY3VycmVudEZvbGxvd0xpc3QpIHtcbiAgICAgIGN1cnJlbnRGb2xsb3dMaXN0ID0gYXdhaXQgdGhpcy5mb2xsb3dzKHZvaWQgMCwgdm9pZCAwLCBraW5kKTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRGb2xsb3dMaXN0LmhhcyhuZXdGb2xsb3cpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGN1cnJlbnRGb2xsb3dMaXN0LmFkZChuZXdGb2xsb3cpO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KHRoaXMubmRrLCB7IGtpbmQgfSk7XG4gICAgZm9yIChjb25zdCBmb2xsb3cgb2YgY3VycmVudEZvbGxvd0xpc3QpIHtcbiAgICAgIGV2ZW50LnRhZyhmb2xsb3cpO1xuICAgIH1cbiAgICBhd2FpdCBldmVudC5wdWJsaXNoKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGZvbGxvdyBmcm9tIHRoaXMgdXNlcidzIGNvbnRhY3QgbGlzdFxuICAgKlxuICAgKiBAcGFyYW0gdXNlciB7TkRLVXNlcn0gVGhlIHVzZXIgdG8gdW5mb2xsb3dcbiAgICogQHBhcmFtIGN1cnJlbnRGb2xsb3dMaXN0IHtTZXQ8TkRLVXNlcj59IFRoZSBjdXJyZW50IGZvbGxvdyBsaXN0XG4gICAqIEBwYXJhbSBraW5kIHtOREtLaW5kfSBUaGUga2luZCB0byB1c2UgZm9yIHRoaXMgY29udGFjdCBsaXN0IChkZWZhdWx0cyB0byBgM2ApXG4gICAqIEByZXR1cm5zIFRoZSByZWxheXMgd2VyZSB0aGUgZm9sbG93IGxpc3Qgd2FzIHB1Ymxpc2hlZCBvciBmYWxzZSBpZiB0aGUgdXNlciB3YXNuJ3QgZm91bmRcbiAgICovXG4gIGFzeW5jIHVuZm9sbG93KHVzZXIsIGN1cnJlbnRGb2xsb3dMaXN0LCBraW5kID0gMyAvKiBDb250YWN0cyAqLykge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBpZiAoIWN1cnJlbnRGb2xsb3dMaXN0KSB7XG4gICAgICBjdXJyZW50Rm9sbG93TGlzdCA9IGF3YWl0IHRoaXMuZm9sbG93cyh2b2lkIDAsIHZvaWQgMCwga2luZCk7XG4gICAgfVxuICAgIGNvbnN0IG5ld1VzZXJGb2xsb3dMaXN0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgZm91bmRVc2VyID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBmb2xsb3cgb2YgY3VycmVudEZvbGxvd0xpc3QpIHtcbiAgICAgIGlmIChmb2xsb3cucHVia2V5ICE9PSB1c2VyLnB1YmtleSkge1xuICAgICAgICBuZXdVc2VyRm9sbG93TGlzdC5hZGQoZm9sbG93KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kVXNlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm91bmRVc2VyKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHsga2luZCB9KTtcbiAgICBmb3IgKGNvbnN0IGZvbGxvdyBvZiBuZXdVc2VyRm9sbG93TGlzdCkge1xuICAgICAgZXZlbnQudGFnKGZvbGxvdyk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBldmVudC5wdWJsaXNoKCk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGEgdXNlcidzIE5JUC0wNSBpZGVudGlmaWVyICh1c3VhbGx5IGZldGNoZWQgZnJvbSB0aGVpciBraW5kOjAgcHJvZmlsZSBkYXRhKVxuICAgKlxuICAgKiBAcGFyYW0gbmlwMDVJZCBUaGUgTklQLTA1IHN0cmluZyB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuIHwgbnVsbD59IFRydWUgaWYgdGhlIE5JUC0wNSBpcyBmb3VuZCBhbmQgbWF0Y2hlcyB0aGlzIHVzZXIncyBwdWJrZXksXG4gICAqIEZhbHNlIGlmIHRoZSBOSVAtMDUgaXMgZm91bmQgYnV0IGRvZXNuJ3QgbWF0Y2ggdGhpcyB1c2VyJ3MgcHVia2V5LFxuICAgKiBudWxsIGlmIHRoZSBOSVAtMDUgaXNuJ3QgZm91bmQgb24gdGhlIGRvbWFpbiBvciB3ZSdyZSB1bmFibGUgdG8gdmVyaWZ5IChiZWNhdXNlIG9mIG5ldHdvcmsgaXNzdWVzLCBldGMuKVxuICAgKi9cbiAgYXN5bmMgdmFsaWRhdGVOaXAwNShuaXAwNUlkKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIGNvbnN0IHByb2ZpbGVQb2ludGVyID0gYXdhaXQgZ2V0TmlwMDVGb3IodGhpcy5uZGssIG5pcDA1SWQpO1xuICAgIGlmIChwcm9maWxlUG9pbnRlciA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHByb2ZpbGVQb2ludGVyLnB1YmtleSA9PT0gdGhpcy5wdWJrZXk7XG4gIH1cbn07XG5cbi8vIHNyYy91c2VyL3Bpbi50c1xuYXN5bmMgZnVuY3Rpb24gcGluRXZlbnQodXNlciwgZXZlbnQsIHBpbkV2ZW50MiwgcHVibGlzaCkge1xuICBjb25zdCBraW5kID0gMTAwMDEgLyogUGluTGlzdCAqLztcbiAgaWYgKCF1c2VyLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICB1c2VyLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgaWYgKCFwaW5FdmVudDIpIHtcbiAgICBjb25zdCBldmVudHMgPSBhd2FpdCB1c2VyLm5kay5mZXRjaEV2ZW50cyhcbiAgICAgIHsga2luZHM6IFtraW5kXSwgYXV0aG9yczogW3VzZXIucHVia2V5XSB9LFxuICAgICAgeyBjYWNoZVVzYWdlOiBcIk9OTFlfUkVMQVlcIiAvKiBPTkxZX1JFTEFZICovIH1cbiAgICApO1xuICAgIGlmIChldmVudHMuc2l6ZSA+IDApIHtcbiAgICAgIHBpbkV2ZW50MiA9IGxpc3RzX2RlZmF1bHQuZnJvbShBcnJheS5mcm9tKGV2ZW50cylbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwaW5FdmVudDIgPSBuZXcgTkRLRXZlbnQodXNlci5uZGssIHtcbiAgICAgICAga2luZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHBpbkV2ZW50Mi50YWcoZXZlbnQpO1xuICBpZiAocHVibGlzaCkge1xuICAgIGF3YWl0IHBpbkV2ZW50Mi5wdWJsaXNoKCk7XG4gIH1cbiAgcmV0dXJuIHBpbkV2ZW50Mjtcbn1cblxuLy8gc3JjL2V2ZW50cy9raW5kcy9jbGFzc2lmaWVkLnRzXG52YXIgTkRLQ2xhc3NpZmllZCA9IGNsYXNzIF9OREtDbGFzc2lmaWVkIGV4dGVuZHMgTkRLRXZlbnQge1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzMDQwMiAvKiBDbGFzc2lmaWVkICovO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTkRLQ2xhc3NpZmllZCBmcm9tIGFuIGV4aXN0aW5nIE5ES0V2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgTkRLRXZlbnQgdG8gY3JlYXRlIHRoZSBOREtDbGFzc2lmaWVkIGZyb20uXG4gICAqIEByZXR1cm5zIE5ES0NsYXNzaWZpZWRcbiAgICovXG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLQ2xhc3NpZmllZChldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCB0aXRsZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gLSBUaGUgY2xhc3NpZmllZCB0aXRsZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgdGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ0aXRsZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCB0aXRsZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHRpdGxlIC0gVGhlIHRpdGxlIHRvIHNldCBmb3IgdGhlIGNsYXNzaWZpZWQuXG4gICAqL1xuICBzZXQgdGl0bGUodGl0bGUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInRpdGxlXCIpO1xuICAgIGlmICh0aXRsZSkgdGhpcy50YWdzLnB1c2goW1widGl0bGVcIiwgdGl0bGVdKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCBzdW1tYXJ5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBjbGFzc2lmaWVkIHN1bW1hcnkgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHN1bW1hcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJzdW1tYXJ5XCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIHN1bW1hcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBzdW1tYXJ5IC0gVGhlIHN1bW1hcnkgdG8gc2V0IGZvciB0aGUgY2xhc3NpZmllZC5cbiAgICovXG4gIHNldCBzdW1tYXJ5KHN1bW1hcnkpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInN1bW1hcnlcIik7XG4gICAgaWYgKHN1bW1hcnkpIHRoaXMudGFncy5wdXNoKFtcInN1bW1hcnlcIiwgc3VtbWFyeV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkJ3MgcHVibGljYXRpb24gdGltZXN0YW1wLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfSAtIFRoZSBVbml4IHRpbWVzdGFtcCBvZiB3aGVuIHRoZSBjbGFzc2lmaWVkIHdhcyBwdWJsaXNoZWQgb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHB1Ymxpc2hlZF9hdCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwicHVibGlzaGVkX2F0XCIpO1xuICAgIGlmICh0YWcpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQodGFnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCdzIHB1YmxpY2F0aW9uIHRpbWVzdGFtcC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IHRpbWVzdGFtcCAtIFRoZSBVbml4IHRpbWVzdGFtcCB0byBzZXQgZm9yIHRoZSBjbGFzc2lmaWVkJ3MgcHVibGljYXRpb24gZGF0ZS5cbiAgICovXG4gIHNldCBwdWJsaXNoZWRfYXQodGltZXN0YW1wKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwdWJsaXNoZWRfYXRcIik7XG4gICAgaWYgKHRpbWVzdGFtcCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwdWJsaXNoZWRfYXRcIiwgdGltZXN0YW1wLnRvU3RyaW5nKCldKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgbG9jYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGNsYXNzaWZpZWQgbG9jYXRpb24gaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IGxvY2F0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwibG9jYXRpb25cIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgbG9jYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiB0byBzZXQgZm9yIHRoZSBjbGFzc2lmaWVkLlxuICAgKi9cbiAgc2V0IGxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJsb2NhdGlvblwiKTtcbiAgICBpZiAobG9jYXRpb24pIHRoaXMudGFncy5wdXNoKFtcImxvY2F0aW9uXCIsIGxvY2F0aW9uXSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgcHJpY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtOREtDbGFzc2lmaWVkUHJpY2VUYWcgfCB1bmRlZmluZWR9IC0gVGhlIGNsYXNzaWZpZWQgcHJpY2UgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHByaWNlKCkge1xuICAgIGNvbnN0IHByaWNlVGFnID0gdGhpcy50YWdzLmZpbmQoKHRhZykgPT4gdGFnWzBdID09PSBcInByaWNlXCIpO1xuICAgIGlmIChwcmljZVRhZykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYW1vdW50OiBOdW1iZXIucGFyc2VGbG9hdChwcmljZVRhZ1sxXSksXG4gICAgICAgIGN1cnJlbmN5OiBwcmljZVRhZ1syXSxcbiAgICAgICAgZnJlcXVlbmN5OiBwcmljZVRhZ1szXVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCBwcmljZS5cbiAgICpcbiAgICogQHBhcmFtIHByaWNlIC0gVGhlIHByaWNlIHRvIHNldCBmb3IgdGhlIGNsYXNzaWZpZWQuXG4gICAqL1xuICBzZXQgcHJpY2UocHJpY2VUYWcpIHtcbiAgICBpZiAodHlwZW9mIHByaWNlVGFnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwcmljZVRhZyA9IHtcbiAgICAgICAgYW1vdW50OiBOdW1iZXIucGFyc2VGbG9hdChwcmljZVRhZylcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChwcmljZVRhZz8uYW1vdW50KSB7XG4gICAgICBjb25zdCB0YWcgPSBbXCJwcmljZVwiLCBwcmljZVRhZy5hbW91bnQudG9TdHJpbmcoKV07XG4gICAgICBpZiAocHJpY2VUYWcuY3VycmVuY3kpIHRhZy5wdXNoKHByaWNlVGFnLmN1cnJlbmN5KTtcbiAgICAgIGlmIChwcmljZVRhZy5mcmVxdWVuY3kpIHRhZy5wdXNoKHByaWNlVGFnLmZyZXF1ZW5jeSk7XG4gICAgICB0aGlzLnRhZ3MucHVzaCh0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZVRhZyhcInByaWNlXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvbnRlbnQgdGFncyBmb3IgdGhlIGNsYXNzaWZpZWQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGZpcnN0IGNoZWNrcyBhbmQgc2V0cyB0aGUgcHVibGljYXRpb24gZGF0ZSBpZiBub3QgYXZhaWxhYmxlLFxuICAgKiBhbmQgdGhlbiBnZW5lcmF0ZXMgY29udGVudCB0YWdzIGJhc2VkIG9uIHRoZSBiYXNlIE5ES0V2ZW50IGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gLSBUaGUgZ2VuZXJhdGVkIGNvbnRlbnQgdGFncy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlVGFncygpIHtcbiAgICBzdXBlci5nZW5lcmF0ZVRhZ3MoKTtcbiAgICBpZiAoIXRoaXMucHVibGlzaGVkX2F0KSB7XG4gICAgICB0aGlzLnB1Ymxpc2hlZF9hdCA9IHRoaXMuY3JlYXRlZF9hdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2RyYWZ0cy50c1xudmFyIE5ES0RyYWZ0ID0gY2xhc3MgX05ES0RyYWZ0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBfZXZlbnQ7XG4gIHN0YXRpYyBraW5kID0gMzEyMzQgLyogRHJhZnQgKi87XG4gIHN0YXRpYyBraW5kcyA9IFszMTIzNCAvKiBEcmFmdCAqLywgMTIzNCAvKiBEcmFmdENoZWNrcG9pbnQgKi9dO1xuICAvKipcbiAgICogQ2FuIGJlIHVzZWQgdG8gaW5jbHVkZSBhIGRpZmZlcmVudCBwdWJrZXkgYXMgcGFydCBvZiB0aGUgZHJhZnQuXG4gICAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gd2Ugd2FudCB0byBtYWtlIHRoZSBkcmFmdCBhIHByb3Bvc2FsIGZvciBhIGRpZmZlcmVudCB1c2VyIHRvIHB1Ymxpc2guXG4gICAqL1xuICBjb3VudGVycGFydHk7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMxMjM0IC8qIERyYWZ0ICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLRHJhZnQoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYW4gaWRlbnRpZmllciAoaS5lLiBkLXRhZylcbiAgICovXG4gIHNldCBpZGVudGlmaWVyKGlkKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImRcIiwgaWRdKTtcbiAgfVxuICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5kVGFnO1xuICB9XG4gIC8qKlxuICAgKiBFdmVudCB0aGF0IGlzIHRvIGJlIHNhdmVkLlxuICAgKi9cbiAgc2V0IGV2ZW50KGUpIHtcbiAgICBpZiAoIShlIGluc3RhbmNlb2YgTkRLRXZlbnQpKSB0aGlzLl9ldmVudCA9IG5ldyBOREtFdmVudCh2b2lkIDAsIGUpO1xuICAgIGVsc2UgdGhpcy5fZXZlbnQgPSBlO1xuICAgIHRoaXMucHJlcGFyZUV2ZW50KCk7XG4gIH1cbiAgLyoqXG4gICAqIE1hcmtzIHRoZSBldmVudCBhcyBhIGNoZWNrcG9pbnQgZm9yIGFub3RoZXIgZHJhZnQgZXZlbnQuXG4gICAqL1xuICBzZXQgY2hlY2twb2ludChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChwYXJlbnQudGFnUmVmZXJlbmNlKCkpO1xuICAgICAgdGhpcy5raW5kID0gMTIzNCAvKiBEcmFmdENoZWNrcG9pbnQgKi87XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlVGFnKFwiYVwiKTtcbiAgICAgIHRoaXMua2luZCA9IDMxMjM0IC8qIERyYWZ0ICovO1xuICAgIH1cbiAgfVxuICBnZXQgaXNDaGVja3BvaW50KCkge1xuICAgIHJldHVybiB0aGlzLmtpbmQgPT09IDEyMzQgLyogRHJhZnRDaGVja3BvaW50ICovO1xuICB9XG4gIGdldCBpc1Byb3Bvc2FsKCkge1xuICAgIGNvbnN0IHBUYWcgPSB0aGlzLnRhZ1ZhbHVlKFwicFwiKTtcbiAgICByZXR1cm4gISFwVGFnICYmIHBUYWcgIT09IHRoaXMucHVia2V5O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBldmVudC5cbiAgICogQHBhcmFtIHBhcmFtMFxuICAgKiBAcmV0dXJucyBOREtFdmVudCBvZiB0aGUgZHJhZnQgZXZlbnQgb3IgbnVsbCBpZiB0aGUgZHJhZnQgZXZlbnQgaGFzIGJlZW4gZGVsZXRlZCAoZW1wdGllZCkuXG4gICAqL1xuICBhc3luYyBnZXRFdmVudChzaWduZXIpIHtcbiAgICBpZiAodGhpcy5fZXZlbnQpIHJldHVybiB0aGlzLl9ldmVudDtcbiAgICBzaWduZXIgPz89IHRoaXMubmRrPy5zaWduZXI7XG4gICAgaWYgKCFzaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgaWYgKHRoaXMuY29udGVudCAmJiB0aGlzLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3duUHVia2V5ID0gc2lnbmVyLnB1YmtleTtcbiAgICAgICAgY29uc3QgcHVia2V5cyA9IFt0aGlzLnRhZ1ZhbHVlKFwicFwiKSwgdGhpcy5wdWJrZXldLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgY29uc3QgY291bnRlcnBhcnR5UHVia2V5ID0gcHVia2V5cy5maW5kKChwdWJrZXkpID0+IHB1YmtleSAhPT0gb3duUHVia2V5KTtcbiAgICAgICAgbGV0IHVzZXI7XG4gICAgICAgIHVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogY291bnRlcnBhcnR5UHVia2V5ID8/IG93blB1YmtleSB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5kZWNyeXB0KHVzZXIsIHNpZ25lcik7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgICAgIHRoaXMuX2V2ZW50ID0gYXdhaXQgd3JhcEV2ZW50KG5ldyBOREtFdmVudCh0aGlzLm5kaywgcGF5bG9hZCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBwcmVwYXJlRXZlbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gZXZlbnQgaGFzIGJlZW4gcHJvdmlkZWRcIik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJrXCIpO1xuICAgIGlmICh0aGlzLl9ldmVudC5raW5kKSB0aGlzLnRhZ3MucHVzaChbXCJrXCIsIHRoaXMuX2V2ZW50LmtpbmQudG9TdHJpbmcoKV0pO1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHRoaXMuX2V2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgZHJhZnQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBzaWduZXI6IE9wdGlvbmFsIHNpZ25lciB0byBlbmNyeXB0IHdpdGhcbiAgICogQHBhcmFtIHB1Ymxpc2g6IFdoZXRoZXIgdG8gcHVibGlzaCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIHJlbGF5U2V0IHRvIHB1Ymxpc2ggdG9cbiAgICovXG4gIGFzeW5jIHNhdmUoeyBzaWduZXIsIHB1Ymxpc2gsIHJlbGF5U2V0IH0pIHtcbiAgICBzaWduZXIgPz89IHRoaXMubmRrPy5zaWduZXI7XG4gICAgaWYgKCFzaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgdXNlciA9IHRoaXMuY291bnRlcnBhcnR5IHx8IGF3YWl0IHNpZ25lci51c2VyKCk7XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIsIHNpZ25lcik7XG4gICAgaWYgKHRoaXMuY291bnRlcnBhcnR5KSB7XG4gICAgICBjb25zdCBwdWJrZXkgPSB0aGlzLmNvdW50ZXJwYXJ0eS5wdWJrZXk7XG4gICAgICB0aGlzLnJlbW92ZVRhZyhcInBcIik7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwXCIsIHB1YmtleV0pO1xuICAgIH1cbiAgICBpZiAocHVibGlzaCA9PT0gZmFsc2UpIHJldHVybjtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoUmVwbGFjZWFibGUocmVsYXlTZXQpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2R2bS9mZWVkYmFjay50c1xudmFyIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMyKSA9PiB7XG4gIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzMltcIlByb2Nlc3NpbmdcIl0gPSBcInByb2Nlc3NpbmdcIjtcbiAgTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMyW1wiU3VjY2Vzc1wiXSA9IFwic3VjY2Vzc1wiO1xuICBOREtEdm1Kb2JGZWVkYmFja1N0YXR1czJbXCJTY2hlZHVsZWRcIl0gPSBcInNjaGVkdWxlZFwiO1xuICBOREtEdm1Kb2JGZWVkYmFja1N0YXR1czJbXCJQYXlSZXFcIl0gPSBcInBheW1lbnRfcmVxdWlyZWRcIjtcbiAgcmV0dXJuIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzMjtcbn0pKE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzIHx8IHt9KTtcbnZhciBOREtEVk1Kb2JGZWVkYmFjayA9IGNsYXNzIF9OREtEVk1Kb2JGZWVkYmFjayBleHRlbmRzIE5ES0V2ZW50IHtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gN2UzIC8qIERWTUpvYkZlZWRiYWNrICovO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tKGV2ZW50KSB7XG4gICAgY29uc3QgZSA9IG5ldyBfTkRLRFZNSm9iRmVlZGJhY2soZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgICBpZiAoZS5lbmNyeXB0ZWQpIGF3YWl0IGUuZHZtRGVjcnlwdCgpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJzdGF0dXNcIik7XG4gIH1cbiAgc2V0IHN0YXR1cyhzdGF0dXMpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInN0YXR1c1wiKTtcbiAgICBpZiAoc3RhdHVzICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInN0YXR1c1wiLCBzdGF0dXNdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGVuY3J5cHRlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldE1hdGNoaW5nVGFncyhcImVuY3J5cHRlZFwiKVswXTtcbiAgfVxuICBhc3luYyBkdm1EZWNyeXB0KCkge1xuICAgIGF3YWl0IHRoaXMuZGVjcnlwdCgpO1xuICAgIGNvbnN0IGRlY3J5cHRlZENvbnRlbnQgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgdGhpcy50YWdzLnB1c2goLi4uZGVjcnlwdGVkQ29udGVudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvZHZtL3JlcXVlc3QudHNcbnZhciBOREtEVk1SZXF1ZXN0ID0gY2xhc3MgX05ES0RWTVJlcXVlc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLRFZNUmVxdWVzdChldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIHNldCBiaWQobXNhdEFtb3VudCkge1xuICAgIGlmIChtc2F0QW1vdW50ID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVtb3ZlVGFnKFwiYmlkXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJiaWRcIiwgbXNhdEFtb3VudC50b1N0cmluZygpXSk7XG4gICAgfVxuICB9XG4gIGdldCBiaWQoKSB7XG4gICAgY29uc3QgdiA9IHRoaXMudGFnVmFsdWUoXCJiaWRcIik7XG4gICAgaWYgKHYgPT09IHZvaWQgMCkgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHYpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGlucHV0IHRvIHRoZSBqb2JcbiAgICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3VtZW50cyB0byB0aGUgaW5wdXRcbiAgICovXG4gIGFkZElucHV0KC4uLmFyZ3MpIHtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJpXCIsIC4uLmFyZ3NdKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG5ldyBwYXJhbWV0ZXIgdG8gdGhlIGpvYlxuICAgKi9cbiAgYWRkUGFyYW0oLi4uYXJncykge1xuICAgIHRoaXMudGFncy5wdXNoKFtcInBhcmFtXCIsIC4uLmFyZ3NdKTtcbiAgfVxuICBzZXQgb3V0cHV0KG91dHB1dCkge1xuICAgIGlmIChvdXRwdXQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW1vdmVUYWcoXCJvdXRwdXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygb3V0cHV0ID09PSBcInN0cmluZ1wiKSBvdXRwdXQgPSBbb3V0cHV0XTtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcIm91dHB1dFwiLCAuLi5vdXRwdXRdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG91dHB1dCgpIHtcbiAgICBjb25zdCBvdXRwdXRUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcIm91dHB1dFwiKVswXTtcbiAgICByZXR1cm4gb3V0cHV0VGFnID8gb3V0cHV0VGFnLnNsaWNlKDEpIDogdm9pZCAwO1xuICB9XG4gIGdldCBwYXJhbXMoKSB7XG4gICAgY29uc3QgcGFyYW1UYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwYXJhbVwiKTtcbiAgICByZXR1cm4gcGFyYW1UYWdzLm1hcCgodCkgPT4gdC5zbGljZSgxKSk7XG4gIH1cbiAgZ2V0UGFyYW0obmFtZSkge1xuICAgIGNvbnN0IHBhcmFtVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwYXJhbVwiKS5maW5kKCh0KSA9PiB0WzFdID09PSBuYW1lKTtcbiAgICByZXR1cm4gcGFyYW1UYWcgPyBwYXJhbVRhZ1syXSA6IHZvaWQgMDtcbiAgfVxuICBjcmVhdGVGZWVkYmFjayhzdGF0dXMpIHtcbiAgICBjb25zdCBmZWVkYmFjayA9IG5ldyBOREtEVk1Kb2JGZWVkYmFjayh0aGlzLm5kayk7XG4gICAgZmVlZGJhY2sudGFnKHRoaXMsIFwiam9iXCIpO1xuICAgIGZlZWRiYWNrLnN0YXR1cyA9IHN0YXR1cztcbiAgICByZXR1cm4gZmVlZGJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgam9iIGVuY3J5cHRpb24gZm9yIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIGR2bSBEVk0gdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBzaWduZXIgU2lnbmVyIHRvIHVzZSBmb3IgZW5jcnlwdGlvblxuICAgKi9cbiAgYXN5bmMgZW5jcnlwdGlvbihkdm0sIHNpZ25lcikge1xuICAgIGNvbnN0IGR2bVRhZ3MgPSBbXCJpXCIsIFwicGFyYW1cIiwgXCJvdXRwdXRcIiwgXCJyZWxheXNcIiwgXCJiaWRcIl07XG4gICAgY29uc3QgdGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+IGR2bVRhZ3MuaW5jbHVkZXModFswXSkpO1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+ICFkdm1UYWdzLmluY2x1ZGVzKHRbMF0pKTtcbiAgICB0aGlzLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0YWdzKTtcbiAgICB0aGlzLnRhZyhkdm0pO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImVuY3J5cHRlZFwiXSk7XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0KGR2bSwgc2lnbmVyKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgRFZNIHRoYXQgd2lsbCByZWNlaXZlIHRoZSBldmVudFxuICAgKi9cbiAgc2V0IGR2bShkdm0pIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInBcIik7XG4gICAgaWYgKGR2bSkgdGhpcy50YWcoZHZtKTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9kdm0vTkRLVHJhbnNjcmlwdGlvbkRWTS50c1xudmFyIE5ES1RyYW5zY3JpcHRpb25EVk0gPSBjbGFzcyBfTkRLVHJhbnNjcmlwdGlvbkRWTSBleHRlbmRzIE5ES0RWTVJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIobmRrLCBldmVudCk7XG4gICAgdGhpcy5raW5kID0gNWUzIC8qIERWTVJlcVRleHRFeHRyYWN0aW9uICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLVHJhbnNjcmlwdGlvbkRWTShldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2Ugb2YgdGhlIHRyYW5zY3JpcHRpb25cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgY29uc3QgaW5wdXRUYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJpXCIpO1xuICAgIGlmIChpbnB1dFRhZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRUYWdzWzBdWzFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSB0aXRsZSB0YWdcbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSB0aXRsZSB0YWdcbiAgICovXG4gIHNldCB0aXRsZSh2YWx1ZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB2YWx1ZV0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgaW1hZ2UgdGFnXG4gICAqL1xuICBnZXQgaW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJpbWFnZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgaW1hZ2UgdGFnXG4gICAqL1xuICBzZXQgaW1hZ2UodmFsdWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImltYWdlXCIpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiaW1hZ2VcIiwgdmFsdWVdKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvZHZtL3Jlc3VsdC50c1xudmFyIE5ES0RWTUpvYlJlc3VsdCA9IGNsYXNzIF9OREtEVk1Kb2JSZXN1bHQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLRFZNSm9iUmVzdWx0KGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgc2V0QW1vdW50KG1zYXQsIGludm9pY2UpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImFtb3VudFwiKTtcbiAgICBjb25zdCB0YWcgPSBbXCJhbW91bnRcIiwgbXNhdC50b1N0cmluZygpXTtcbiAgICBpZiAoaW52b2ljZSkgdGFnLnB1c2goaW52b2ljZSk7XG4gICAgdGhpcy50YWdzLnB1c2godGFnKTtcbiAgfVxuICBzZXQgcmVzdWx0KHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5jb250ZW50ID0gXCJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250ZW50ID0gcmVzdWx0O1xuICAgIH1cbiAgfVxuICBnZXQgcmVzdWx0KCkge1xuICAgIGlmICh0aGlzLmNvbnRlbnQgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gIH1cbiAgc2V0IHN0YXR1cyhzdGF0dXMpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInN0YXR1c1wiKTtcbiAgICBpZiAoc3RhdHVzICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInN0YXR1c1wiLCBzdGF0dXNdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInN0YXR1c1wiKTtcbiAgfVxuICBnZXQgam9iUmVxdWVzdElkKCkge1xuICAgIGZvciAoY29uc3QgZVRhZyBvZiB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIikpIHtcbiAgICAgIGlmIChlVGFnWzJdID09PSBcImpvYlwiKSByZXR1cm4gZVRhZ1sxXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuam9iUmVxdWVzdCkgcmV0dXJuIHRoaXMuam9iUmVxdWVzdC5pZDtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImVcIik7XG4gIH1cbiAgc2V0IGpvYlJlcXVlc3QoZXZlbnQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInJlcXVlc3RcIik7XG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICB0aGlzLmtpbmQgPSBldmVudC5raW5kICsgMWUzO1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicmVxdWVzdFwiLCBKU09OLnN0cmluZ2lmeShldmVudC5yYXdFdmVudCgpKV0pO1xuICAgICAgdGhpcy50YWcoZXZlbnQpO1xuICAgIH1cbiAgfVxuICBnZXQgam9iUmVxdWVzdCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwicmVxdWVzdFwiKTtcbiAgICBpZiAodGFnID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTkRLRXZlbnQodGhpcy5uZGssIEpTT04ucGFyc2UodGFnKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvY2FzaHUvdHgudHNcbnZhciBNQVJLRVJTID0ge1xuICBSRURFRU1FRDogXCJyZWRlZW1lZFwiLFxuICBDUkVBVEVEOiBcImNyZWF0ZWRcIixcbiAgREVTVFJPWUVEOiBcImRlc3Ryb3llZFwiLFxuICBSRVNFUlZFRDogXCJyZXNlcnZlZFwiXG59O1xudmFyIE5ES0Nhc2h1V2FsbGV0VHggPSBjbGFzcyBfTkRLQ2FzaHVXYWxsZXRUeCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIE1BUktFUlMgPSBNQVJLRVJTO1xuICBzdGF0aWMga2luZCA9IDczNzYgLyogQ2FzaHVXYWxsZXRUeCAqLztcbiAgc3RhdGljIGtpbmRzID0gWzczNzYgLyogQ2FzaHVXYWxsZXRUeCAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcihuZGssIGV2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDczNzYgLyogQ2FzaHVXYWxsZXRUeCAqLztcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbShldmVudCkge1xuICAgIGNvbnN0IHdhbGxldENoYW5nZSA9IG5ldyBfTkRLQ2FzaHVXYWxsZXRUeChldmVudC5uZGssIGV2ZW50KTtcbiAgICBjb25zdCBwcmV2Q29udGVudCA9IHdhbGxldENoYW5nZS5jb250ZW50O1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB3YWxsZXRDaGFuZ2UuZGVjcnlwdCgpO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICB3YWxsZXRDaGFuZ2UuY29udGVudCA/Pz0gcHJldkNvbnRlbnQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb250ZW50VGFncyA9IEpTT04ucGFyc2Uod2FsbGV0Q2hhbmdlLmNvbnRlbnQpO1xuICAgICAgd2FsbGV0Q2hhbmdlLnRhZ3MgPSBbLi4uY29udGVudFRhZ3MsIC4uLndhbGxldENoYW5nZS50YWdzXTtcbiAgICB9IGNhdGNoIChfZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gd2FsbGV0Q2hhbmdlO1xuICB9XG4gIHNldCBkaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkaXJlY3Rpb25cIik7XG4gICAgaWYgKGRpcmVjdGlvbikgdGhpcy50YWdzLnB1c2goW1wiZGlyZWN0aW9uXCIsIGRpcmVjdGlvbl0pO1xuICB9XG4gIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJkaXJlY3Rpb25cIik7XG4gIH1cbiAgc2V0IGFtb3VudChhbW91bnQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImFtb3VudFwiKTtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJhbW91bnRcIiwgYW1vdW50LnRvU3RyaW5nKCldKTtcbiAgfVxuICBnZXQgYW1vdW50KCkge1xuICAgIGNvbnN0IHZhbCA9IHRoaXMudGFnVmFsdWUoXCJhbW91bnRcIik7XG4gICAgaWYgKHZhbCA9PT0gdm9pZCAwKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBOdW1iZXIodmFsKTtcbiAgfVxuICBzZXQgZmVlKGZlZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZmVlXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImZlZVwiLCBmZWUudG9TdHJpbmcoKV0pO1xuICB9XG4gIGdldCBmZWUoKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy50YWdWYWx1ZShcImZlZVwiKTtcbiAgICBpZiAodmFsID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIE51bWJlcih2YWwpO1xuICB9XG4gIHNldCB1bml0KHVuaXQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInVuaXRcIik7XG4gICAgaWYgKHVuaXQpIHRoaXMudGFncy5wdXNoKFtcInVuaXRcIiwgdW5pdC50b1N0cmluZygpXSk7XG4gIH1cbiAgZ2V0IHVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ1bml0XCIpO1xuICB9XG4gIHNldCBkZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZGVzY3JpcHRpb25cIik7XG4gICAgaWYgKGRlc2NyaXB0aW9uKSB0aGlzLnRhZ3MucHVzaChbXCJkZXNjcmlwdGlvblwiLCBkZXNjcmlwdGlvbi50b1N0cmluZygpXSk7XG4gIH1cbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZGVzY3JpcHRpb25cIik7XG4gIH1cbiAgc2V0IG1pbnQobWludCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwibWludFwiKTtcbiAgICBpZiAobWludCkgdGhpcy50YWdzLnB1c2goW1wibWludFwiLCBtaW50LnRvU3RyaW5nKCldKTtcbiAgfVxuICBnZXQgbWludCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcIm1pbnRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFRhZ3MgdG9rZW5zIHRoYXQgd2VyZSBjcmVhdGVkIGluIHRoaXMgaGlzdG9yeSBldmVudFxuICAgKi9cbiAgc2V0IGRlc3Ryb3llZFRva2VucyhldmVudHMpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goZXZlbnQudGFnUmVmZXJlbmNlKE1BUktFUlMuREVTVFJPWUVEKSk7XG4gICAgfVxuICB9XG4gIHNldCBkZXN0cm95ZWRUb2tlbklkcyhpZHMpIHtcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiZVwiLCBpZCwgXCJcIiwgTUFSS0VSUy5ERVNUUk9ZRURdKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRhZ3MgdG9rZW5zIHRoYXQgd2VyZSBjcmVhdGVkIGluIHRoaXMgaGlzdG9yeSBldmVudFxuICAgKi9cbiAgc2V0IGNyZWF0ZWRUb2tlbnMoZXZlbnRzKSB7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKGV2ZW50LnRhZ1JlZmVyZW5jZShNQVJLRVJTLkNSRUFURUQpKTtcbiAgICB9XG4gIH1cbiAgc2V0IHJlc2VydmVkVG9rZW5zKGV2ZW50cykge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChldmVudC50YWdSZWZlcmVuY2UoTUFSS0VSUy5SRVNFUlZFRCkpO1xuICAgIH1cbiAgfVxuICBhZGRSZWRlZW1lZE51dHphcChldmVudCkge1xuICAgIHRoaXMudGFnKGV2ZW50LCBNQVJLRVJTLlJFREVFTUVEKTtcbiAgfVxuICBhc3luYyB0b05vc3RyRXZlbnQocHVia2V5KSB7XG4gICAgY29uc3QgZW5jcnlwdGVkVGFncyA9IFtdO1xuICAgIGNvbnN0IHVuZW5jcnlwdGVkVGFncyA9IFtdO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgaWYgKCF0aGlzLnNob3VsZEVuY3J5cHRUYWcodGFnKSkge1xuICAgICAgICB1bmVuY3J5cHRlZFRhZ3MucHVzaCh0YWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5jcnlwdGVkVGFncy5wdXNoKHRhZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudGFncyA9IHVuZW5jcnlwdGVkVGFncy5maWx0ZXIoKHQpID0+IHRbMF0gIT09IFwiY2xpZW50XCIpO1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGVuY3J5cHRlZFRhZ3MpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5kaz8uc2lnbmVyPy51c2VyKCk7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIGNvbnN0IG93blB1YmtleSA9IHVzZXIucHVia2V5O1xuICAgICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gdFswXSAhPT0gXCJwXCIgfHwgdFsxXSAhPT0gb3duUHVia2V5KTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIsIHZvaWQgMCwgXCJuaXA0NFwiKTtcbiAgICByZXR1cm4gc3VwZXIudG9Ob3N0ckV2ZW50KHB1YmtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBlbnRyeSBpbmNsdWRlcyBhIHJlZGVtcHRpb24gb2YgYSBOdXR6YXBcbiAgICovXG4gIGdldCBoYXNOdXR6YXBSZWRlbXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIiwgTUFSS0VSUy5SRURFRU1FRCkubGVuZ3RoID4gMDtcbiAgfVxuICBzaG91bGRFbmNyeXB0VGFnKHRhZykge1xuICAgIGNvbnN0IHVuZW5jcnlwdGVkVGFnTmFtZXMgPSBbXCJjbGllbnRcIl07XG4gICAgaWYgKHVuZW5jcnlwdGVkVGFnTmFtZXMuaW5jbHVkZXModGFnWzBdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiB0YWdbM10gPT09IE1BUktFUlMuUkVERUVNRUQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRhZ1swXSA9PT0gXCJwXCIpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9OREtSZWxheUxpc3QudHNcbnZhciBSRUFEX01BUktFUiA9IFwicmVhZFwiO1xudmFyIFdSSVRFX01BUktFUiA9IFwid3JpdGVcIjtcbnZhciBOREtSZWxheUxpc3QgPSBjbGFzcyBfTkRLUmVsYXlMaXN0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAxMDAwMiAvKiBSZWxheUxpc3QgKi87XG4gIH1cbiAgc3RhdGljIGZyb20obmRrRXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtSZWxheUxpc3QobmRrRXZlbnQubmRrLCBuZGtFdmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICBnZXQgcmVhZFJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiclwiIHx8IHRhZ1swXSA9PT0gXCJyZWxheVwiKS5maWx0ZXIoKHRhZykgPT4gIXRhZ1syXSB8fCB0YWdbMl0gJiYgdGFnWzJdID09PSBSRUFEX01BUktFUikubWFwKCh0YWcpID0+IHRyeU5vcm1hbGl6ZVJlbGF5VXJsKHRhZ1sxXSkpLmZpbHRlcigodXJsKSA9PiAhIXVybCk7XG4gIH1cbiAgc2V0IHJlYWRSZWxheVVybHMocmVsYXlzKSB7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiByZWxheXMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInJcIiwgcmVsYXksIFJFQURfTUFSS0VSXSk7XG4gICAgfVxuICB9XG4gIGdldCB3cml0ZVJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiclwiIHx8IHRhZ1swXSA9PT0gXCJyZWxheVwiKS5maWx0ZXIoKHRhZykgPT4gIXRhZ1syXSB8fCB0YWdbMl0gJiYgdGFnWzJdID09PSBXUklURV9NQVJLRVIpLm1hcCgodGFnKSA9PiB0cnlOb3JtYWxpemVSZWxheVVybCh0YWdbMV0pKS5maWx0ZXIoKHVybCkgPT4gISF1cmwpO1xuICB9XG4gIHNldCB3cml0ZVJlbGF5VXJscyhyZWxheXMpIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHJlbGF5cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiclwiLCByZWxheSwgV1JJVEVfTUFSS0VSXSk7XG4gICAgfVxuICB9XG4gIGdldCBib3RoUmVsYXlVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJyXCIgfHwgdGFnWzBdID09PSBcInJlbGF5XCIpLmZpbHRlcigodGFnKSA9PiAhdGFnWzJdKS5tYXAoKHRhZykgPT4gdGFnWzFdKTtcbiAgfVxuICBzZXQgYm90aFJlbGF5VXJscyhyZWxheXMpIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHJlbGF5cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiclwiLCByZWxheV0pO1xuICAgIH1cbiAgfVxuICBnZXQgcmVsYXlzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJyXCIgfHwgdGFnWzBdID09PSBcInJlbGF5XCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICB9XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIHJlbGF5U2V0IGZvciB0aGUgcmVsYXlzIGluIHRoaXMgbGlzdC5cbiAgICovXG4gIGdldCByZWxheVNldCgpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREtSZWxheUxpc3QgaGFzIG5vIE5ESyBpbnN0YW5jZVwiKTtcbiAgICByZXR1cm4gbmV3IE5ES1JlbGF5U2V0KFxuICAgICAgbmV3IFNldCh0aGlzLnJlbGF5cy5tYXAoKHUpID0+IHRoaXMubmRrPy5wb29sLmdldFJlbGF5KHUpKS5maWx0ZXIoKHIpID0+ICEhcikpLFxuICAgICAgdGhpcy5uZGtcbiAgICApO1xuICB9XG59O1xuZnVuY3Rpb24gcmVsYXlMaXN0RnJvbUtpbmQzKG5kaywgY29udGFjdExpc3QpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjb250ZW50ID0gSlNPTi5wYXJzZShjb250YWN0TGlzdC5jb250ZW50KTtcbiAgICBjb25zdCByZWxheUxpc3QgPSBuZXcgTkRLUmVsYXlMaXN0KG5kayk7XG4gICAgY29uc3QgcmVhZFJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgd3JpdGVSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IFtrZXksIGNvbmZpZ10gb2YgT2JqZWN0LmVudHJpZXMoY29udGVudCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZVJlbGF5VXJsKGtleSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICByZWFkUmVsYXlzLmFkZChrZXkpO1xuICAgICAgICB3cml0ZVJlbGF5cy5hZGQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlbGF5Q29uZmlnID0gY29uZmlnO1xuICAgICAgICBpZiAocmVsYXlDb25maWcud3JpdGUpIHdyaXRlUmVsYXlzLmFkZChrZXkpO1xuICAgICAgICBpZiAocmVsYXlDb25maWcucmVhZCkgcmVhZFJlbGF5cy5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVsYXlMaXN0LnJlYWRSZWxheVVybHMgPSBBcnJheS5mcm9tKHJlYWRSZWxheXMpO1xuICAgIHJlbGF5TGlzdC53cml0ZVJlbGF5VXJscyA9IEFycmF5LmZyb20od3JpdGVSZWxheXMpO1xuICAgIHJldHVybiByZWxheUxpc3Q7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvbmlwODkvYXBwLWhhbmRsZXIudHNcbnZhciBOREtBcHBIYW5kbGVyRXZlbnQgPSBjbGFzcyBfTkRLQXBwSGFuZGxlckV2ZW50IGV4dGVuZHMgTkRLRXZlbnQge1xuICBwcm9maWxlO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzMTk5MCAvKiBBcHBIYW5kbGVyICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKG5ka0V2ZW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgX05ES0FwcEhhbmRsZXJFdmVudChuZGtFdmVudC5uZGssIG5ka0V2ZW50LnJhd0V2ZW50KCkpO1xuICAgIGlmIChldmVudC5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIGNvbnN0IGNvbWJpbmF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgY29tYmluYXRpb25Gcm9tVGFnID0gKHRhZykgPT4gW3RhZ1swXSwgdGFnWzJdXS5qb2luKFwiOlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHRhZ3NUb0luc3BlY3QgPSBbXCJ3ZWJcIiwgXCJhbmRyb2lkXCIsIFwiaW9zXCJdO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgaWYgKHRhZ3NUb0luc3BlY3QuaW5jbHVkZXModGFnWzBdKSkge1xuICAgICAgICBjb25zdCBjb21iaW5hdGlvbiA9IGNvbWJpbmF0aW9uRnJvbVRhZyh0YWcpO1xuICAgICAgICBpZiAoY29tYmluYXRpb25zLmhhcyhjb21iaW5hdGlvbikpIHtcbiAgICAgICAgICBpZiAoY29tYmluYXRpb25zLmdldChjb21iaW5hdGlvbikgIT09IHRhZ1sxXS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbWJpbmF0aW9ucy5zZXQoY29tYmluYXRpb24sIHRhZ1sxXS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoZXMgYXBwIGhhbmRsZXIgaW5mb3JtYXRpb25cbiAgICogSWYgbm8gYXBwIGluZm9ybWF0aW9uIGlzIGF2YWlsYWJsZSBvbiB0aGUga2luZDozMTk5MCxcbiAgICogd2UgZmV0Y2ggdGhlIGV2ZW50J3MgYXV0aG9yJ3MgcHJvZmlsZSBhbmQgcmV0dXJuIHRoYXQgaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGZldGNoUHJvZmlsZSgpIHtcbiAgICBpZiAodGhpcy5wcm9maWxlID09PSB2b2lkIDAgJiYgdGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHByb2ZpbGUgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgICAgIGlmIChwcm9maWxlPy5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2ZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9maWxlID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICAgIHRoaXMucHJvZmlsZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBhdXRob3IgPSB0aGlzLmF1dGhvcjtcbiAgICAgIGF1dGhvci5mZXRjaFByb2ZpbGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShhdXRob3IucHJvZmlsZSk7XG4gICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3JlcG9zdC50c1xudmFyIE5ES1JlcG9zdCA9IGNsYXNzIF9OREtSZXBvc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIF9yZXBvc3RlZEV2ZW50cztcbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtSZXBvc3QoZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgcmVwb3N0ZWQgZXZlbnRzIGJ5IHRoZSBjdXJyZW50IGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ga2xhc3MgT3B0aW9uYWwgY2xhc3MgdG8gY29udmVydCB0aGUgZXZlbnRzIHRvLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgcmVwb3N0ZWRFdmVudHMoa2xhc3MsIG9wdHMpIHtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3Qgc2V0XCIpO1xuICAgIGlmICh0aGlzLl9yZXBvc3RlZEV2ZW50cyAhPT0gdm9pZCAwKSByZXR1cm4gdGhpcy5fcmVwb3N0ZWRFdmVudHM7XG4gICAgZm9yIChjb25zdCBldmVudElkIG9mIHRoaXMucmVwb3N0ZWRFdmVudElkcygpKSB7XG4gICAgICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJGb3JJZChldmVudElkKTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudChmaWx0ZXIsIG9wdHMpO1xuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGl0ZW1zLnB1c2goa2xhc3MgPyBrbGFzcy5mcm9tKGV2ZW50KSA6IGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXBvc3RlZCBldmVudCBJRHMuXG4gICAqL1xuICByZXBvc3RlZEV2ZW50SWRzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0KSA9PiB0WzBdID09PSBcImVcIiB8fCB0WzBdID09PSBcImFcIikubWFwKCh0KSA9PiB0WzFdKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZpbHRlckZvcklkKGlkKSB7XG4gIGlmIChpZC5tYXRjaCgvOi8pKSB7XG4gICAgY29uc3QgW2tpbmQsIHB1YmtleSwgaWRlbnRpZmllcl0gPSBpZC5zcGxpdChcIjpcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmRzOiBbTnVtYmVyLnBhcnNlSW50KGtpbmQpXSxcbiAgICAgIGF1dGhvcnM6IFtwdWJrZXldLFxuICAgICAgXCIjZFwiOiBbaWRlbnRpZmllcl1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7IGlkczogW2lkXSB9O1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3N1YnNjcmlwdGlvbnMvcmVjZWlwdC50c1xuaW1wb3J0IGRlYnVnNCBmcm9tIFwiZGVidWdcIjtcbnZhciBOREtTdWJzY3JpcHRpb25SZWNlaXB0ID0gY2xhc3MgX05ES1N1YnNjcmlwdGlvblJlY2VpcHQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGRlYnVnO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSA3MDAzIC8qIFN1YnNjcmlwdGlvblJlY2VpcHQgKi87XG4gICAgdGhpcy5kZWJ1ZyA9IG5kaz8uZGVidWcuZXh0ZW5kKFwic3Vic2NyaXB0aW9uLXN0YXJ0XCIpID8/IGRlYnVnNChcIm5kazpzdWJzY3JpcHRpb24tc3RhcnRcIik7XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtTdWJzY3JpcHRpb25SZWNlaXB0KGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIHBlcnNvbiBiZWluZyBzdWJzY3JpYmVkIHRvXG4gICAqL1xuICBnZXQgcmVjaXBpZW50KCkge1xuICAgIGNvbnN0IHBUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIik/LlswXTtcbiAgICBpZiAoIXBUYWcpIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBwVGFnWzFdIH0pO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIHNldCByZWNpcGllbnQodXNlcikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicFwiKTtcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJwXCIsIHVzZXIucHVia2V5XSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIHBlcnNvbiBzdWJzY3JpYmluZ1xuICAgKi9cbiAgZ2V0IHN1YnNjcmliZXIoKSB7XG4gICAgY29uc3QgUFRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiUFwiKT8uWzBdO1xuICAgIGlmICghUFRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCB1c2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXk6IFBUYWdbMV0gfSk7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgc2V0IHN1YnNjcmliZXIodXNlcikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiUFwiKTtcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJQXCIsIHVzZXIucHVia2V5XSk7XG4gIH1cbiAgc2V0IHN1YnNjcmlwdGlvblN0YXJ0KGV2ZW50KSB7XG4gICAgdGhpcy5kZWJ1ZyhgYmVmb3JlIHNldHRpbmcgc3Vic2NyaXB0aW9uIHN0YXJ0OiAke3RoaXMucmF3RXZlbnR9YCk7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJlXCIpO1xuICAgIHRoaXMudGFnKGV2ZW50LCBcInN1YnNjcmlwdGlvblwiLCB0cnVlKTtcbiAgICB0aGlzLmRlYnVnKGBhZnRlciBzZXR0aW5nIHN1YnNjcmlwdGlvbiBzdGFydDogJHt0aGlzLnJhd0V2ZW50fWApO1xuICB9XG4gIGdldCB0aWVyTmFtZSgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInRpZXJcIik/LlswXTtcbiAgICByZXR1cm4gdGFnPy5bMV07XG4gIH1cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgY29uc3QgcGVyaW9kID0gdGhpcy52YWxpZFBlcmlvZDtcbiAgICBpZiAoIXBlcmlvZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGVyaW9kLnN0YXJ0ID4gcGVyaW9kLmVuZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwVGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKTtcbiAgICBjb25zdCBQVGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiUFwiKTtcbiAgICBpZiAocFRhZ3MubGVuZ3RoICE9PSAxIHx8IFBUYWdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXQgdmFsaWRQZXJpb2QoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJ2YWxpZFwiKT8uWzBdO1xuICAgIGlmICghdGFnKSByZXR1cm4gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogbmV3IERhdGUoTnVtYmVyLnBhcnNlSW50KHRhZ1sxXSkgKiAxZTMpLFxuICAgICAgICBlbmQ6IG5ldyBEYXRlKE51bWJlci5wYXJzZUludCh0YWdbMl0pICogMWUzKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHNldCB2YWxpZFBlcmlvZChwZXJpb2QpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInZhbGlkXCIpO1xuICAgIGlmICghcGVyaW9kKSByZXR1cm47XG4gICAgdGhpcy50YWdzLnB1c2goW1xuICAgICAgXCJ2YWxpZFwiLFxuICAgICAgTWF0aC5mbG9vcihwZXJpb2Quc3RhcnQuZ2V0VGltZSgpIC8gMWUzKS50b1N0cmluZygpLFxuICAgICAgTWF0aC5mbG9vcihwZXJpb2QuZW5kLmdldFRpbWUoKSAvIDFlMykudG9TdHJpbmcoKVxuICAgIF0pO1xuICB9XG4gIGdldCBzdGFydFBlcmlvZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZFBlcmlvZD8uc3RhcnQ7XG4gIH1cbiAgZ2V0IGVuZFBlcmlvZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZFBlcmlvZD8uZW5kO1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdWJzY3JpcHRpb24gaXMgY3VycmVudGx5IGFjdGl2ZVxuICAgKi9cbiAgaXNBY3RpdmUodGltZSkge1xuICAgIHRpbWUgPz89IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IHBlcmlvZCA9IHRoaXMudmFsaWRQZXJpb2Q7XG4gICAgaWYgKCFwZXJpb2QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGltZSA8IHBlcmlvZC5zdGFydCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aW1lID4gcGVyaW9kLmVuZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3N1YnNjcmlwdGlvbnMvc3Vic2NyaXB0aW9uLXN0YXJ0LnRzXG5pbXBvcnQgZGVidWc1IGZyb20gXCJkZWJ1Z1wiO1xudmFyIE5ES1N1YnNjcmlwdGlvblN0YXJ0ID0gY2xhc3MgX05ES1N1YnNjcmlwdGlvblN0YXJ0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBkZWJ1ZztcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gNzAwMSAvKiBTdWJzY3JpYmUgKi87XG4gICAgdGhpcy5kZWJ1ZyA9IG5kaz8uZGVidWcuZXh0ZW5kKFwic3Vic2NyaXB0aW9uLXN0YXJ0XCIpID8/IGRlYnVnNShcIm5kazpzdWJzY3JpcHRpb24tc3RhcnRcIik7XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtTdWJzY3JpcHRpb25TdGFydChldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWNpcGllbnQgb2YgdGhlIHN1YnNjcmlwdGlvbi4gSS5lLiBUaGUgYXV0aG9yIG9mIHRoaXMgZXZlbnQgc3Vic2NyaWJlcyB0byB0aGlzIHVzZXIuXG4gICAqL1xuICBnZXQgcmVjaXBpZW50KCkge1xuICAgIGNvbnN0IHBUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIik/LlswXTtcbiAgICBpZiAoIXBUYWcpIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBwVGFnWzFdIH0pO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIHNldCByZWNpcGllbnQodXNlcikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicFwiKTtcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJwXCIsIHVzZXIucHVia2V5XSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICovXG4gIGdldCBhbW91bnQoKSB7XG4gICAgY29uc3QgYW1vdW50VGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhbW91bnRcIik/LlswXTtcbiAgICBpZiAoIWFtb3VudFRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gcGFyc2VUYWdUb1N1YnNjcmlwdGlvbkFtb3VudChhbW91bnRUYWcpO1xuICB9XG4gIHNldCBhbW91bnQoYW1vdW50KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhbW91bnRcIik7XG4gICAgaWYgKCFhbW91bnQpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChuZXdBbW91bnQoYW1vdW50LmFtb3VudCwgYW1vdW50LmN1cnJlbmN5LCBhbW91bnQudGVybSkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgaWQgb3IgTklQLTMzIHRhZyBpZCBvZiB0aGUgdGllciB0aGF0IHRoZSB1c2VyIGlzIHN1YnNjcmliaW5nIHRvLlxuICAgKi9cbiAgZ2V0IHRpZXJJZCgpIHtcbiAgICBjb25zdCBlVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJlXCIpPy5bMF07XG4gICAgY29uc3QgYVRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiYVwiKT8uWzBdO1xuICAgIGlmICghZVRhZyB8fCAhYVRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gZVRhZ1sxXSA/PyBhVGFnWzFdO1xuICB9XG4gIHNldCB0aWVyKHRpZXIpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImVcIik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhXCIpO1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZXZlbnRcIik7XG4gICAgaWYgKCF0aWVyKSByZXR1cm47XG4gICAgdGhpcy50YWcodGllcik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcInBcIiwgdGllci5wdWJrZXldKTtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJldmVudFwiLCBKU09OLnN0cmluZ2lmeSh0aWVyLnJhd0V2ZW50KCkpXSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoZXMgdGhlIHRpZXIgdGhhdCB0aGUgdXNlciBpcyBzdWJzY3JpYmluZyB0by5cbiAgICovXG4gIGFzeW5jIGZldGNoVGllcigpIHtcbiAgICBjb25zdCBldmVudFRhZyA9IHRoaXMudGFnVmFsdWUoXCJldmVudFwiKTtcbiAgICBpZiAoZXZlbnRUYWcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEV2ZW50ID0gSlNPTi5wYXJzZShldmVudFRhZyk7XG4gICAgICAgIHJldHVybiBuZXcgTkRLU3Vic2NyaXB0aW9uVGllcih0aGlzLm5kaywgcGFyc2VkRXZlbnQpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJGYWlsZWQgdG8gcGFyc2UgZXZlbnQgdGFnXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0aWVySWQgPSB0aGlzLnRpZXJJZDtcbiAgICBpZiAoIXRpZXJJZCkgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5uZGs/LmZldGNoRXZlbnQodGllcklkKTtcbiAgICBpZiAoIWUpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIE5ES1N1YnNjcmlwdGlvblRpZXIuZnJvbShlKTtcbiAgfVxuICBnZXQgaXNWYWxpZCgpIHtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhbW91bnRcIikubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiSW52YWxpZCAjIG9mIGFtb3VudCB0YWdcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5hbW91bnQpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJJbnZhbGlkIGFtb3VudCB0YWdcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIikubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiSW52YWxpZCAjIG9mIHAgdGFnXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVjaXBpZW50KSB7XG4gICAgICB0aGlzLmRlYnVnKFwiSW52YWxpZCBwIHRhZ1wiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMvZ2lmdC13cmFwcGluZy50c1xuaW1wb3J0IHsgZ2V0RXZlbnRIYXNoIGFzIGdldEV2ZW50SGFzaDIgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcblxuLy8gc3JjL3NpZ25lcnMvcHJpdmF0ZS1rZXkvaW5kZXgudHNcbmltcG9ydCB7IGZpbmFsaXplRXZlbnQsIGdlbmVyYXRlU2VjcmV0S2V5LCBnZXRQdWJsaWNLZXksIG5pcDA0LCBuaXA0NCB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4MiwgaGV4VG9CeXRlcyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBuaXAxOSBhcyBuaXAxOTYgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcblxuLy8gc3JjL3NpZ25lcnMvcmVnaXN0cnkudHNcbnZhciBzaWduZXJSZWdpc3RyeSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiByZWdpc3RlclNpZ25lcih0eXBlLCBzaWduZXJDbGFzcykge1xuICBzaWduZXJSZWdpc3RyeS5zZXQodHlwZSwgc2lnbmVyQ2xhc3MpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9wcml2YXRlLWtleS9pbmRleC50c1xudmFyIE5ES1ByaXZhdGVLZXlTaWduZXIgPSBjbGFzcyBfTkRLUHJpdmF0ZUtleVNpZ25lciB7XG4gIF91c2VyO1xuICBfcHJpdmF0ZUtleTtcbiAgX3B1YmtleTtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzaWduZXIgZnJvbSBhIHByaXZhdGUga2V5LlxuICAgKiBAcGFyYW0gcHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSB0byB1c2UgaW4gaGV4IGZvcm0gb3IgbnNlYy5cbiAgICogQHBhcmFtIG5kayAtIFRoZSBOREsgaW5zdGFuY2UgdG8gdXNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZUtleU9yTnNlYywgbmRrKSB7XG4gICAgaWYgKHR5cGVvZiBwcml2YXRlS2V5T3JOc2VjID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAocHJpdmF0ZUtleU9yTnNlYy5zdGFydHNXaXRoKFwibnNlYzFcIikpIHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBkYXRhIH0gPSBuaXAxOTYuZGVjb2RlKHByaXZhdGVLZXlPck5zZWMpO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJuc2VjXCIpIHRoaXMuX3ByaXZhdGVLZXkgPSBkYXRhO1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJpdmF0ZSBrZXkgcHJvdmlkZWQuXCIpO1xuICAgICAgfSBlbHNlIGlmIChwcml2YXRlS2V5T3JOc2VjLmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZUtleSA9IGhleFRvQnl0ZXMocHJpdmF0ZUtleU9yTnNlYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByaXZhdGUga2V5IHByb3ZpZGVkLlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcHJpdmF0ZUtleSA9IHByaXZhdGVLZXlPck5zZWM7XG4gICAgfVxuICAgIHRoaXMuX3B1YmtleSA9IGdldFB1YmxpY0tleSh0aGlzLl9wcml2YXRlS2V5KTtcbiAgICBpZiAobmRrKSB0aGlzLl91c2VyID0gbmRrLmdldFVzZXIoeyBwdWJrZXk6IHRoaXMuX3B1YmtleSB9KTtcbiAgICB0aGlzLl91c2VyID8/PSBuZXcgTkRLVXNlcih7IHB1YmtleTogdGhpcy5fcHVia2V5IH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHByaXZhdGUga2V5IGluIGhleCBmb3JtLlxuICAgKi9cbiAgZ2V0IHByaXZhdGVLZXkoKSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlS2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgcmVhZHlcIik7XG4gICAgcmV0dXJuIGJ5dGVzVG9IZXgyKHRoaXMuX3ByaXZhdGVLZXkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1YmxpYyBrZXkgaW4gaGV4IGZvcm0uXG4gICAqL1xuICBnZXQgcHVia2V5KCkge1xuICAgIGlmICghdGhpcy5fcHVia2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgcmVhZHlcIik7XG4gICAgcmV0dXJuIHRoaXMuX3B1YmtleTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBwcml2YXRlIGtleSBpbiBuc2VjIGZvcm0uXG4gICAqL1xuICBnZXQgbnNlYygpIHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGVLZXkpIHRocm93IG5ldyBFcnJvcihcIk5vdCByZWFkeVwiKTtcbiAgICByZXR1cm4gbmlwMTk2Lm5zZWNFbmNvZGUodGhpcy5fcHJpdmF0ZUtleSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgcHVibGljIGtleSBpbiBucHViIGZvcm0uXG4gICAqL1xuICBnZXQgbnB1YigpIHtcbiAgICBpZiAoIXRoaXMuX3B1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiTm90IHJlYWR5XCIpO1xuICAgIHJldHVybiBuaXAxOTYubnB1YkVuY29kZSh0aGlzLl9wdWJrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyBwcml2YXRlIGtleS5cbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZSgpIHtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gZ2VuZXJhdGVTZWNyZXRLZXkoKTtcbiAgICByZXR1cm4gbmV3IF9OREtQcml2YXRlS2V5U2lnbmVyKHByaXZhdGVLZXkpO1xuICB9XG4gIC8qKlxuICAgKiBOb29wIGluIE5ES1ByaXZhdGVLZXlTaWduZXIuXG4gICAqL1xuICBhc3luYyBibG9ja1VudGlsUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlci5cbiAgICovXG4gIGFzeW5jIHVzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlci5cbiAgICovXG4gIGdldCB1c2VyU3luYygpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlcjtcbiAgfVxuICBhc3luYyBzaWduKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkF0dGVtcHRlZCB0byBzaWduIHdpdGhvdXQgYSBwcml2YXRlIGtleVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmFsaXplRXZlbnQoZXZlbnQsIHRoaXMuX3ByaXZhdGVLZXkpLnNpZztcbiAgfVxuICBhc3luYyBlbmNyeXB0aW9uRW5hYmxlZChzY2hlbWUpIHtcbiAgICBjb25zdCBlbmFibGVkID0gW107XG4gICAgaWYgKCFzY2hlbWUgfHwgc2NoZW1lID09PSBcIm5pcDA0XCIpIGVuYWJsZWQucHVzaChcIm5pcDA0XCIpO1xuICAgIGlmICghc2NoZW1lIHx8IHNjaGVtZSA9PT0gXCJuaXA0NFwiKSBlbmFibGVkLnB1c2goXCJuaXA0NFwiKTtcbiAgICByZXR1cm4gZW5hYmxlZDtcbiAgfVxuICBhc3luYyBlbmNyeXB0KHJlY2lwaWVudCwgdmFsdWUsIHNjaGVtZSkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSB8fCAhdGhpcy5wcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkF0dGVtcHRlZCB0byBlbmNyeXB0IHdpdGhvdXQgYSBwcml2YXRlIGtleVwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVjaXBpZW50SGV4UHViS2V5ID0gcmVjaXBpZW50LnB1YmtleTtcbiAgICBpZiAoc2NoZW1lID09PSBcIm5pcDQ0XCIpIHtcbiAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbktleSA9IG5pcDQ0LnYyLnV0aWxzLmdldENvbnZlcnNhdGlvbktleSh0aGlzLl9wcml2YXRlS2V5LCByZWNpcGllbnRIZXhQdWJLZXkpO1xuICAgICAgcmV0dXJuIGF3YWl0IG5pcDQ0LnYyLmVuY3J5cHQodmFsdWUsIGNvbnZlcnNhdGlvbktleSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBuaXAwNC5lbmNyeXB0KHRoaXMuX3ByaXZhdGVLZXksIHJlY2lwaWVudEhleFB1YktleSwgdmFsdWUpO1xuICB9XG4gIGFzeW5jIGRlY3J5cHQoc2VuZGVyLCB2YWx1ZSwgc2NoZW1lKSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlS2V5IHx8ICF0aGlzLnByaXZhdGVLZXkpIHtcbiAgICAgIHRocm93IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGRlY3J5cHQgd2l0aG91dCBhIHByaXZhdGUga2V5XCIpO1xuICAgIH1cbiAgICBjb25zdCBzZW5kZXJIZXhQdWJLZXkgPSBzZW5kZXIucHVia2V5O1xuICAgIGlmIChzY2hlbWUgPT09IFwibmlwNDRcIikge1xuICAgICAgY29uc3QgY29udmVyc2F0aW9uS2V5ID0gbmlwNDQudjIudXRpbHMuZ2V0Q29udmVyc2F0aW9uS2V5KHRoaXMuX3ByaXZhdGVLZXksIHNlbmRlckhleFB1YktleSk7XG4gICAgICByZXR1cm4gYXdhaXQgbmlwNDQudjIuZGVjcnlwdCh2YWx1ZSwgY29udmVyc2F0aW9uS2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IG5pcDA0LmRlY3J5cHQodGhpcy5fcHJpdmF0ZUtleSwgc2VuZGVySGV4UHViS2V5LCB2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIHNpZ25lcidzIHByaXZhdGUga2V5IGludG8gYSBzdG9yYWJsZSBmb3JtYXQuXG4gICAqIEByZXR1cm5zIEEgSlNPTiBzdHJpbmcgY29udGFpbmluZyB0aGUgdHlwZSBhbmQgdGhlIGhleCBwcml2YXRlIGtleS5cbiAgICovXG4gIHRvUGF5bG9hZCgpIHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGVLZXkpIHRocm93IG5ldyBFcnJvcihcIlByaXZhdGUga2V5IG5vdCBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIHR5cGU6IFwicHJpdmF0ZS1rZXlcIixcbiAgICAgIHBheWxvYWQ6IHRoaXMucHJpdmF0ZUtleVxuICAgICAgLy8gVXNlIHRoZSBoZXggcHJpdmF0ZSBrZXlcbiAgICB9O1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgfVxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBzaWduZXIgZnJvbSBhIHBheWxvYWQgc3RyaW5nLlxuICAgKiBAcGFyYW0gcGF5bG9hZFN0cmluZyBUaGUgSlNPTiBzdHJpbmcgb2J0YWluZWQgZnJvbSB0b1BheWxvYWQoKS5cbiAgICogQHBhcmFtIG5kayBPcHRpb25hbCBOREsgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIE5ES1ByaXZhdGVLZXlTaWduZXIuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZnJvbVBheWxvYWQocGF5bG9hZFN0cmluZywgbmRrKSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UocGF5bG9hZFN0cmluZyk7XG4gICAgaWYgKHBheWxvYWQudHlwZSAhPT0gXCJwcml2YXRlLWtleVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGF5bG9hZCB0eXBlOiBleHBlY3RlZCAncHJpdmF0ZS1rZXknLCBnb3QgJHtwYXlsb2FkLnR5cGV9YCk7XG4gICAgfVxuICAgIGlmICghcGF5bG9hZC5wYXlsb2FkIHx8IHR5cGVvZiBwYXlsb2FkLnBheWxvYWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGF5bG9hZCBjb250ZW50IGZvciBwcml2YXRlLWtleSBzaWduZXJcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX05ES1ByaXZhdGVLZXlTaWduZXIocGF5bG9hZC5wYXlsb2FkLCBuZGspO1xuICB9XG59O1xucmVnaXN0ZXJTaWduZXIoXCJwcml2YXRlLWtleVwiLCBOREtQcml2YXRlS2V5U2lnbmVyKTtcblxuLy8gc3JjL2V2ZW50cy9naWZ0LXdyYXBwaW5nLnRzXG5hc3luYyBmdW5jdGlvbiBnaWZ0V3JhcChldmVudCwgcmVjaXBpZW50LCBzaWduZXIsIHBhcmFtcyA9IHt9KSB7XG4gIGxldCBfc2lnbmVyID0gc2lnbmVyO1xuICBwYXJhbXMuc2NoZW1lID8/PSBcIm5pcDQ0XCI7XG4gIGlmICghX3NpZ25lcikge1xuICAgIGlmICghZXZlbnQubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBzaWduZXIgYXZhaWxhYmxlIGZvciBnaWZ0V3JhcFwiKTtcbiAgICBfc2lnbmVyID0gZXZlbnQubmRrLnNpZ25lcjtcbiAgfVxuICBpZiAoIV9zaWduZXIpIHRocm93IG5ldyBFcnJvcihcIm5vIHNpZ25lclwiKTtcbiAgaWYgKCFfc2lnbmVyLmVuY3J5cHRpb25FbmFibGVkIHx8ICFfc2lnbmVyLmVuY3J5cHRpb25FbmFibGVkKHBhcmFtcy5zY2hlbWUpKVxuICAgIHRocm93IG5ldyBFcnJvcihcInNpZ25lciBpcyBub3QgYWJsZSB0byBnaWZ0V3JhcFwiKTtcbiAgY29uc3QgcnVtb3IgPSBnZXRSdW1vckV2ZW50KGV2ZW50LCBwYXJhbXM/LnJ1bW9yS2luZCk7XG4gIGNvbnN0IHNlYWwgPSBhd2FpdCBnZXRTZWFsRXZlbnQocnVtb3IsIHJlY2lwaWVudCwgX3NpZ25lciwgcGFyYW1zLnNjaGVtZSk7XG4gIGNvbnN0IHdyYXAgPSBhd2FpdCBnZXRXcmFwRXZlbnQoc2VhbCwgcmVjaXBpZW50LCBwYXJhbXMpO1xuICByZXR1cm4gbmV3IE5ES0V2ZW50KGV2ZW50Lm5kaywgd3JhcCk7XG59XG5hc3luYyBmdW5jdGlvbiBnaWZ0VW53cmFwKGV2ZW50LCBzZW5kZXIsIHNpZ25lciwgc2NoZW1lID0gXCJuaXA0NFwiKSB7XG4gIGNvbnN0IF9zZW5kZXIgPSBzZW5kZXIgfHwgbmV3IE5ES1VzZXIoeyBwdWJrZXk6IGV2ZW50LnB1YmtleSB9KTtcbiAgbGV0IF9zaWduZXIgPSBzaWduZXI7XG4gIGlmICghX3NpZ25lcikge1xuICAgIGlmICghZXZlbnQubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBzaWduZXIgYXZhaWxhYmxlIGZvciBnaWZ0VW53cmFwXCIpO1xuICAgIF9zaWduZXIgPSBldmVudC5uZGsuc2lnbmVyO1xuICB9XG4gIGlmICghc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBzaWduZXJcIik7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2VhbCA9IEpTT04ucGFyc2UoYXdhaXQgc2lnbmVyLmRlY3J5cHQoX3NlbmRlciwgZXZlbnQuY29udGVudCwgc2NoZW1lKSk7XG4gICAgaWYgKCFzZWFsKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVjcnlwdCB3cmFwcGVyXCIpO1xuICAgIGlmICghbmV3IE5ES0V2ZW50KHZvaWQgMCwgc2VhbCkudmVyaWZ5U2lnbmF0dXJlKGZhbHNlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkdpZnRTZWFsIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkIVwiKTtcbiAgICBjb25zdCBydW1vclNlbmRlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBzZWFsLnB1YmtleSB9KTtcbiAgICBjb25zdCBydW1vciA9IEpTT04ucGFyc2UoYXdhaXQgc2lnbmVyLmRlY3J5cHQocnVtb3JTZW5kZXIsIHNlYWwuY29udGVudCwgc2NoZW1lKSk7XG4gICAgaWYgKCFydW1vcikgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY3J5cHQgc2VhbFwiKTtcbiAgICBpZiAocnVtb3IucHVia2V5ICE9PSBzZWFsLnB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBHaWZ0V3JhcCwgc2VuZGVyIHZhbGlkYXRpb24gZmFpbGVkIVwiKTtcbiAgICByZXR1cm4gbmV3IE5ES0V2ZW50KGV2ZW50Lm5kaywgcnVtb3IpO1xuICB9IGNhdGNoIChfZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIkdvdCBlcnJvciB1bndyYXBwaW5nIGV2ZW50ISBTZWUgY29uc29sZSBsb2cuXCIpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSdW1vckV2ZW50KGV2ZW50LCBraW5kKSB7XG4gIGNvbnN0IHJ1bW9yID0gZXZlbnQucmF3RXZlbnQoKTtcbiAgcnVtb3Iua2luZCA9IGtpbmQgfHwgcnVtb3Iua2luZCB8fCAxNCAvKiBQcml2YXRlRGlyZWN0TWVzc2FnZSAqLztcbiAgcnVtb3Iuc2lnID0gdm9pZCAwO1xuICBydW1vci5pZCA9IGdldEV2ZW50SGFzaDIocnVtb3IpO1xuICByZXR1cm4gbmV3IE5ES0V2ZW50KGV2ZW50Lm5kaywgcnVtb3IpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U2VhbEV2ZW50KHJ1bW9yLCByZWNpcGllbnQsIHNpZ25lciwgc2NoZW1lID0gXCJuaXA0NFwiKSB7XG4gIGNvbnN0IHNlYWwgPSBuZXcgTkRLRXZlbnQocnVtb3IubmRrKTtcbiAgc2VhbC5raW5kID0gMTMgLyogR2lmdFdyYXBTZWFsICovO1xuICBzZWFsLmNyZWF0ZWRfYXQgPSBhcHByb3hpbWF0ZU5vdyg1KTtcbiAgc2VhbC5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkocnVtb3IucmF3RXZlbnQoKSk7XG4gIGF3YWl0IHNlYWwuZW5jcnlwdChyZWNpcGllbnQsIHNpZ25lciwgc2NoZW1lKTtcbiAgYXdhaXQgc2VhbC5zaWduKHNpZ25lcik7XG4gIHJldHVybiBzZWFsO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0V3JhcEV2ZW50KHNlYWxlZCwgcmVjaXBpZW50LCBwYXJhbXMsIHNjaGVtZSA9IFwibmlwNDRcIikge1xuICBjb25zdCBzaWduZXIgPSBOREtQcml2YXRlS2V5U2lnbmVyLmdlbmVyYXRlKCk7XG4gIGNvbnN0IHdyYXAgPSBuZXcgTkRLRXZlbnQoc2VhbGVkLm5kayk7XG4gIHdyYXAua2luZCA9IDEwNTkgLyogR2lmdFdyYXAgKi87XG4gIHdyYXAuY3JlYXRlZF9hdCA9IGFwcHJveGltYXRlTm93KDUpO1xuICBpZiAocGFyYW1zPy53cmFwVGFncykgd3JhcC50YWdzID0gcGFyYW1zLndyYXBUYWdzO1xuICB3cmFwLnRhZyhyZWNpcGllbnQpO1xuICB3cmFwLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShzZWFsZWQucmF3RXZlbnQoKSk7XG4gIGF3YWl0IHdyYXAuZW5jcnlwdChyZWNpcGllbnQsIHNpZ25lciwgc2NoZW1lKTtcbiAgYXdhaXQgd3JhcC5zaWduKHNpZ25lcik7XG4gIHJldHVybiB3cmFwO1xufVxuZnVuY3Rpb24gYXBwcm94aW1hdGVOb3coZHJpZnQgPSAwKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxZTMgLSBNYXRoLnJhbmRvbSgpICogMTAgKiogZHJpZnQpO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3NpbXBsZS1ncm91cC9pbmRleC50c1xudmFyIE5ES1NpbXBsZUdyb3VwID0gY2xhc3MgX05ES1NpbXBsZUdyb3VwIHtcbiAgbmRrO1xuICBncm91cElkO1xuICByZWxheVNldDtcbiAgZmV0Y2hpbmdNZXRhZGF0YTtcbiAgbWV0YWRhdGE7XG4gIG1lbWJlckxpc3Q7XG4gIGFkbWluTGlzdDtcbiAgY29uc3RydWN0b3IobmRrLCByZWxheVNldCwgZ3JvdXBJZCkge1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMuZ3JvdXBJZCA9IGdyb3VwSWQgPz8gcmFuZG9tSWQoMjQpO1xuICAgIHRoaXMucmVsYXlTZXQgPSByZWxheVNldDtcbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXBJZDtcbiAgfVxuICByZWxheVVybHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXlTZXQ/LnJlbGF5VXJscztcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRhZGF0YT8ubmFtZTtcbiAgfVxuICBnZXQgYWJvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGE/LmFib3V0O1xuICB9XG4gIGdldCBwaWN0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhPy5waWN0dXJlO1xuICB9XG4gIGdldCBtZW1iZXJzKCkge1xuICAgIHJldHVybiB0aGlzLm1lbWJlckxpc3Q/Lm1lbWJlcnMgPz8gW107XG4gIH1cbiAgZ2V0IGFkbWlucygpIHtcbiAgICByZXR1cm4gdGhpcy5hZG1pbkxpc3Q/Lm1lbWJlcnMgPz8gW107XG4gIH1cbiAgYXN5bmMgZ2V0TWV0YWRhdGEoKSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVNZXRhZGF0YUV2ZW50KCk7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGdyb3VwIGJ5IHB1Ymxpc2hpbmcgYSBraW5kOjkwMDcgZXZlbnQuXG4gICAqIEBwYXJhbSBzaWduZXJcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUdyb3VwKHNpZ25lcikge1xuICAgIHNpZ25lciA/Pz0gdGhpcy5uZGsuc2lnbmVyO1xuICAgIGlmICghc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBzaWduZXIudXNlcigpO1xuICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKFwiTm8gdXNlciBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGspO1xuICAgIGV2ZW50LmtpbmQgPSA5MDA3IC8qIEdyb3VwQWRtaW5DcmVhdGVHcm91cCAqLztcbiAgICBldmVudC50YWdzLnB1c2goW1wiaFwiLCB0aGlzLmdyb3VwSWRdKTtcbiAgICBhd2FpdCBldmVudC5zaWduKHNpZ25lcik7XG4gICAgcmV0dXJuIGV2ZW50LnB1Ymxpc2godGhpcy5yZWxheVNldCk7XG4gIH1cbiAgYXN5bmMgc2V0TWV0YWRhdGEoeyBuYW1lLCBhYm91dCwgcGljdHVyZSB9KSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGspO1xuICAgIGV2ZW50LmtpbmQgPSA5MDAyIC8qIEdyb3VwQWRtaW5FZGl0TWV0YWRhdGEgKi87XG4gICAgZXZlbnQudGFncy5wdXNoKFtcImhcIiwgdGhpcy5ncm91cElkXSk7XG4gICAgaWYgKG5hbWUpIGV2ZW50LnRhZ3MucHVzaChbXCJuYW1lXCIsIG5hbWVdKTtcbiAgICBpZiAoYWJvdXQpIGV2ZW50LnRhZ3MucHVzaChbXCJhYm91dFwiLCBhYm91dF0pO1xuICAgIGlmIChwaWN0dXJlKSBldmVudC50YWdzLnB1c2goW1wicGljdHVyZVwiLCBwaWN0dXJlXSk7XG4gICAgYXdhaXQgZXZlbnQuc2lnbigpO1xuICAgIHJldHVybiBldmVudC5wdWJsaXNoKHRoaXMucmVsYXlTZXQpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgdXNlciB0byB0aGUgZ3JvdXAgdXNpbmcgYSBraW5kOjkwMDAgZXZlbnRcbiAgICogQHBhcmFtIHVzZXIgdXNlciB0byBhZGRcbiAgICogQHBhcmFtIG9wdHMgb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgYWRkVXNlcih1c2VyKSB7XG4gICAgY29uc3QgYWRkVXNlckV2ZW50ID0gX05ES1NpbXBsZUdyb3VwLmdlbmVyYXRlQWRkVXNlckV2ZW50KHVzZXIucHVia2V5LCB0aGlzLmdyb3VwSWQpO1xuICAgIGFkZFVzZXJFdmVudC5uZGsgPSB0aGlzLm5kaztcbiAgICByZXR1cm4gYWRkVXNlckV2ZW50O1xuICB9XG4gIGFzeW5jIGdldE1lbWJlckxpc3RFdmVudCgpIHtcbiAgICBjb25zdCBtZW1iZXJMaXN0ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudChcbiAgICAgIHtcbiAgICAgICAga2luZHM6IFszOTAwMiAvKiBHcm91cE1lbWJlcnMgKi9dLFxuICAgICAgICBcIiNkXCI6IFt0aGlzLmdyb3VwSWRdXG4gICAgICB9LFxuICAgICAgdm9pZCAwLFxuICAgICAgdGhpcy5yZWxheVNldFxuICAgICk7XG4gICAgaWYgKCFtZW1iZXJMaXN0KSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTkRLU2ltcGxlR3JvdXBNZW1iZXJMaXN0LmZyb20obWVtYmVyTGlzdCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBsaXN0IG9mIHVzZXJzIHRoYXQgYmVsb25nIHRvIHRoaXMgZ3JvdXBcbiAgICovXG4gIGFzeW5jIGdldE1lbWJlcnMoKSB7XG4gICAgY29uc3QgbWVtYmVycyA9IFtdO1xuICAgIGNvbnN0IG1lbWJlclB1YmtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IG1lbWJlckxpc3RFdmVudCA9IGF3YWl0IHRoaXMuZ2V0TWVtYmVyTGlzdEV2ZW50KCk7XG4gICAgaWYgKCFtZW1iZXJMaXN0RXZlbnQpIHJldHVybiBbXTtcbiAgICBmb3IgKGNvbnN0IHBUYWcgb2YgbWVtYmVyTGlzdEV2ZW50LmdldE1hdGNoaW5nVGFncyhcInBcIikpIHtcbiAgICAgIGNvbnN0IHB1YmtleSA9IHBUYWdbMV07XG4gICAgICBpZiAobWVtYmVyUHVia2V5cy5oYXMocHVia2V5KSkgY29udGludWU7XG4gICAgICBtZW1iZXJQdWJrZXlzLmFkZChwdWJrZXkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWVtYmVycy5wdXNoKHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXkgfSkpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZW1iZXJzO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gZXZlbnQgdGhhdCBsaXN0cyB0aGUgbWVtYmVycyBvZiBhIGdyb3VwLlxuICAgKiBAcGFyYW0gZ3JvdXBJZFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlVXNlckxpc3RFdmVudChncm91cElkKSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodm9pZCAwLCB7XG4gICAgICBraW5kOiAzOTAwMiAvKiBHcm91cE1lbWJlcnMgKi8sXG4gICAgICB0YWdzOiBbXG4gICAgICAgIFtcImhcIiwgZ3JvdXBJZF0sXG4gICAgICAgIFtcImFsdFwiLCBcIkdyb3VwIE1lbWJlciBMaXN0XCJdXG4gICAgICBdXG4gICAgfSk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gZXZlbnQgdGhhdCBhZGRzIGEgdXNlciB0byBhIGdyb3VwLlxuICAgKiBAcGFyYW0gdXNlclB1YmtleSBwdWJrZXkgb2YgdGhlIHVzZXIgdG8gYWRkXG4gICAqIEBwYXJhbSBncm91cElkIGdyb3VwIHRvIGFkZCB0aGUgdXNlciB0b1xuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlQWRkVXNlckV2ZW50KHVzZXJQdWJrZXksIGdyb3VwSWQpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh2b2lkIDAsIHtcbiAgICAgIGtpbmQ6IDllMyAvKiBHcm91cEFkbWluQWRkVXNlciAqLyxcbiAgICAgIHRhZ3M6IFtbXCJoXCIsIGdyb3VwSWRdXVxuICAgIH0pO1xuICAgIGV2ZW50LnRhZ3MucHVzaChbXCJwXCIsIHVzZXJQdWJrZXldKTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdFRvSm9pbihfcHVia2V5LCBjb250ZW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IDkwMjEgLyogR3JvdXBBZG1pblJlcXVlc3RKb2luICovLFxuICAgICAgY29udGVudDogY29udGVudCA/PyBcIlwiLFxuICAgICAgdGFnczogW1tcImhcIiwgdGhpcy5ncm91cElkXV1cbiAgICB9KTtcbiAgICByZXR1cm4gZXZlbnQucHVibGlzaCh0aGlzLnJlbGF5U2V0KTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgc3VyZSB0aGF0IGEgbWV0YWRhdGEgZXZlbnQgZXhpc3RzIGxvY2FsbHlcbiAgICovXG4gIGFzeW5jIGVuc3VyZU1ldGFkYXRhRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMubWV0YWRhdGEpIHJldHVybjtcbiAgICBpZiAodGhpcy5mZXRjaGluZ01ldGFkYXRhKSByZXR1cm4gdGhpcy5mZXRjaGluZ01ldGFkYXRhO1xuICAgIHRoaXMuZmV0Y2hpbmdNZXRhZGF0YSA9IHRoaXMubmRrLmZldGNoRXZlbnQoXG4gICAgICB7XG4gICAgICAgIGtpbmRzOiBbMzllMyAvKiBHcm91cE1ldGFkYXRhICovXSxcbiAgICAgICAgXCIjZFwiOiBbdGhpcy5ncm91cElkXVxuICAgICAgfSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHRoaXMucmVsYXlTZXRcbiAgICApLnRoZW4oKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IE5ES1NpbXBsZUdyb3VwTWV0YWRhdGEuZnJvbShldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbmV3IE5ES1NpbXBsZUdyb3VwTWV0YWRhdGEodGhpcy5uZGspO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLmRUYWcgPSB0aGlzLmdyb3VwSWQ7XG4gICAgICB9XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICB0aGlzLmZldGNoaW5nTWV0YWRhdGEgPSB2b2lkIDA7XG4gICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggbWV0YWRhdGEgZm9yIGdyb3VwICR7dGhpcy5ncm91cElkfWApO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmZldGNoaW5nTWV0YWRhdGE7XG4gIH1cbn07XG5mdW5jdGlvbiByYW5kb21JZChsZW5ndGgpIHtcbiAgY29uc3QgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCI7XG4gIGNvbnN0IGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdCArPSBjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnNMZW5ndGgpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvYXBwLXNldHRpbmdzL2luZGV4LnRzXG52YXIgTkRLQXBwU2V0dGluZ3MgPSBjbGFzcyBfTkRLQXBwU2V0dGluZ3MgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGFwcE5hbWU7XG4gIHNldHRpbmdzID0ge307XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMwMDc4IC8qIEFwcFNwZWNpZmljRGF0YSAqLztcbiAgICB0aGlzLmRUYWcgPz89IHRoaXMuYXBwTmFtZTtcbiAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcGFyc2luZyBhcHAgc2V0dGluZ3NcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0FwcFNldHRpbmdzKGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSB2YWx1ZSBmb3IgYSBnaXZlbiBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuc2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSB2YWx1ZSBmb3IgYSBnaXZlbiBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR0aW5nc1trZXldO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2hSZXBsYWNlYWJsZShyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnNldHRpbmdzKTtcbiAgICByZXR1cm4gc3VwZXIucHVibGlzaFJlcGxhY2VhYmxlKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9yZWxheS9hdXRoLXBvbGljaWVzLnRzXG5pbXBvcnQgY3JlYXRlRGVidWcyIGZyb20gXCJkZWJ1Z1wiO1xuZnVuY3Rpb24gZGlzY29ubmVjdChwb29sLCBkZWJ1ZzkpIHtcbiAgZGVidWc5ID8/PSBjcmVhdGVEZWJ1ZzIoXCJuZGs6cmVsYXk6YXV0aC1wb2xpY2llczpkaXNjb25uZWN0XCIpO1xuICByZXR1cm4gYXN5bmMgKHJlbGF5KSA9PiB7XG4gICAgZGVidWc5Py4oYFJlbGF5ICR7cmVsYXkudXJsfSByZXF1ZXN0ZWQgYXV0aGVudGljYXRpb24sIGRpc2Nvbm5lY3RpbmdgKTtcbiAgICBwb29sLnJlbW92ZVJlbGF5KHJlbGF5LnVybCk7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBzaWduQW5kQXV0aChldmVudCwgcmVsYXksIHNpZ25lciwgZGVidWc5LCByZXNvbHZlLCByZWplY3QpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBldmVudC5zaWduKHNpZ25lcik7XG4gICAgcmVzb2x2ZShldmVudCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1Zzk/LihgRmFpbGVkIHRvIHB1Ymxpc2ggYXV0aCBldmVudCB0byByZWxheSAke3JlbGF5LnVybH1gLCBlKTtcbiAgICByZWplY3QoZXZlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBzaWduSW4oeyBuZGssIHNpZ25lciwgZGVidWc6IGRlYnVnOSB9ID0ge30pIHtcbiAgZGVidWc5ID8/PSBjcmVhdGVEZWJ1ZzIoXCJuZGs6YXV0aC1wb2xpY2llczpzaWduSW5cIik7XG4gIHJldHVybiBhc3luYyAocmVsYXksIGNoYWxsZW5nZSkgPT4ge1xuICAgIGRlYnVnOT8uKGBSZWxheSAke3JlbGF5LnVybH0gcmVxdWVzdGVkIGF1dGhlbnRpY2F0aW9uLCBzaWduaW5nIGluYCk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrKTtcbiAgICBldmVudC5raW5kID0gMjIyNDIgLyogQ2xpZW50QXV0aCAqLztcbiAgICBldmVudC50YWdzID0gW1xuICAgICAgW1wicmVsYXlcIiwgcmVsYXkudXJsXSxcbiAgICAgIFtcImNoYWxsZW5nZVwiLCBjaGFsbGVuZ2VdXG4gICAgXTtcbiAgICBzaWduZXIgPz89IG5kaz8uc2lnbmVyO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoc2lnbmVyKSB7XG4gICAgICAgIGF3YWl0IHNpZ25BbmRBdXRoKGV2ZW50LCByZWxheSwgc2lnbmVyLCBkZWJ1ZzksIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZGs/Lm9uY2UoXCJzaWduZXI6cmVhZHlcIiwgYXN5bmMgKHNpZ25lcjIpID0+IHtcbiAgICAgICAgICBhd2FpdCBzaWduQW5kQXV0aChldmVudCwgcmVsYXksIHNpZ25lcjIsIGRlYnVnOSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG52YXIgTkRLUmVsYXlBdXRoUG9saWNpZXMgPSB7XG4gIGRpc2Nvbm5lY3QsXG4gIHNpZ25JblxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwMDcvaW5kZXgudHNcbmltcG9ydCBkZWJ1ZzYgZnJvbSBcImRlYnVnXCI7XG52YXIgTkRLTmlwMDdTaWduZXIgPSBjbGFzcyBfTkRLTmlwMDdTaWduZXIge1xuICBfdXNlclByb21pc2U7XG4gIGVuY3J5cHRpb25RdWV1ZSA9IFtdO1xuICBlbmNyeXB0aW9uUHJvY2Vzc2luZyA9IGZhbHNlO1xuICBkZWJ1ZztcbiAgd2FpdFRpbWVvdXQ7XG4gIF9wdWJrZXk7XG4gIG5kaztcbiAgX3VzZXI7XG4gIC8qKlxuICAgKiBAcGFyYW0gd2FpdFRpbWVvdXQgLSBUaGUgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgdGhlIE5JUC0wNyB0byBiZWNvbWUgYXZhaWxhYmxlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3YWl0VGltZW91dCA9IDFlMywgbmRrKSB7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnNihcIm5kazpuaXAwN1wiKTtcbiAgICB0aGlzLndhaXRUaW1lb3V0ID0gd2FpdFRpbWVvdXQ7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gIH1cbiAgZ2V0IHB1YmtleSgpIHtcbiAgICBpZiAoIXRoaXMuX3B1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiTm90IHJlYWR5XCIpO1xuICAgIHJldHVybiB0aGlzLl9wdWJrZXk7XG4gIH1cbiAgYXN5bmMgYmxvY2tVbnRpbFJlYWR5KCkge1xuICAgIGF3YWl0IHRoaXMud2FpdEZvckV4dGVuc2lvbigpO1xuICAgIGNvbnN0IHB1YmtleSA9IGF3YWl0IHdpbmRvdy5ub3N0cj8uZ2V0UHVibGljS2V5KCk7XG4gICAgaWYgKCFwdWJrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgcmVqZWN0ZWQgYWNjZXNzXCIpO1xuICAgIH1cbiAgICB0aGlzLl9wdWJrZXkgPSBwdWJrZXk7XG4gICAgbGV0IHVzZXI7XG4gICAgaWYgKHRoaXMubmRrKSB1c2VyID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleSB9KTtcbiAgICBlbHNlIHVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleSB9KTtcbiAgICB0aGlzLl91c2VyID0gdXNlcjtcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgdXNlciBwcm9wZXJ0eS5cbiAgICogQHJldHVybnMgVGhlIE5ES1VzZXIgaW5zdGFuY2UuXG4gICAqL1xuICBhc3luYyB1c2VyKCkge1xuICAgIGlmICghdGhpcy5fdXNlclByb21pc2UpIHtcbiAgICAgIHRoaXMuX3VzZXJQcm9taXNlID0gdGhpcy5ibG9ja1VudGlsUmVhZHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJQcm9taXNlO1xuICB9XG4gIGdldCB1c2VyU3luYygpIHtcbiAgICBpZiAoIXRoaXMuX3VzZXIpIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IHJlYWR5XCIpO1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIC8qKlxuICAgKiBTaWducyB0aGUgZ2l2ZW4gTm9zdHIgZXZlbnQuXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBOb3N0ciBldmVudCB0byBiZSBzaWduZWQuXG4gICAqIEByZXR1cm5zIFRoZSBzaWduYXR1cmUgb2YgdGhlIHNpZ25lZCBldmVudC5cbiAgICogQHRocm93cyBFcnJvciBpZiB0aGUgTklQLTA3IGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAqL1xuICBhc3luYyBzaWduKGV2ZW50KSB7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3Qgc2lnbmVkRXZlbnQgPSBhd2FpdCB3aW5kb3cubm9zdHI/LnNpZ25FdmVudChldmVudCk7XG4gICAgaWYgKCFzaWduZWRFdmVudCkgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHNpZ24gZXZlbnRcIik7XG4gICAgcmV0dXJuIHNpZ25lZEV2ZW50LnNpZztcbiAgfVxuICBhc3luYyByZWxheXMobmRrKSB7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3QgcmVsYXlzID0gYXdhaXQgd2luZG93Lm5vc3RyPy5nZXRSZWxheXM/LigpIHx8IHt9O1xuICAgIGNvbnN0IGFjdGl2ZVJlbGF5cyA9IFtdO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIE9iamVjdC5rZXlzKHJlbGF5cykpIHtcbiAgICAgIGlmIChyZWxheXNbdXJsXS5yZWFkICYmIHJlbGF5c1t1cmxdLndyaXRlKSB7XG4gICAgICAgIGFjdGl2ZVJlbGF5cy5wdXNoKHVybCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVSZWxheXMubWFwKCh1cmwpID0+IG5ldyBOREtSZWxheSh1cmwsIG5kaz8ucmVsYXlBdXRoRGVmYXVsdFBvbGljeSwgbmRrKSk7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdGlvbkVuYWJsZWQobmlwKSB7XG4gICAgY29uc3QgZW5hYmxlZCA9IFtdO1xuICAgIGlmICgoIW5pcCB8fCBuaXAgPT09IFwibmlwMDRcIikgJiYgQm9vbGVhbih3aW5kb3cubm9zdHI/Lm5pcDA0KSkgZW5hYmxlZC5wdXNoKFwibmlwMDRcIik7XG4gICAgaWYgKCghbmlwIHx8IG5pcCA9PT0gXCJuaXA0NFwiKSAmJiBCb29sZWFuKHdpbmRvdy5ub3N0cj8ubmlwNDQpKSBlbmFibGVkLnB1c2goXCJuaXA0NFwiKTtcbiAgICByZXR1cm4gZW5hYmxlZDtcbiAgfVxuICBhc3luYyBlbmNyeXB0KHJlY2lwaWVudCwgdmFsdWUsIG5pcCA9IFwibmlwMDRcIikge1xuICAgIGlmICghYXdhaXQgdGhpcy5lbmNyeXB0aW9uRW5hYmxlZChuaXApKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25pcH1lbmNyeXB0aW9uIGlzIG5vdCBhdmFpbGFibGUgZnJvbSB5b3VyIGJyb3dzZXIgZXh0ZW5zaW9uYCk7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3QgcmVjaXBpZW50SGV4UHViS2V5ID0gcmVjaXBpZW50LnB1YmtleTtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZUVuY3J5cHRpb24obmlwLCBcImVuY3J5cHRcIiwgcmVjaXBpZW50SGV4UHViS2V5LCB2YWx1ZSk7XG4gIH1cbiAgYXN5bmMgZGVjcnlwdChzZW5kZXIsIHZhbHVlLCBuaXAgPSBcIm5pcDA0XCIpIHtcbiAgICBpZiAoIWF3YWl0IHRoaXMuZW5jcnlwdGlvbkVuYWJsZWQobmlwKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuaXB9ZW5jcnlwdGlvbiBpcyBub3QgYXZhaWxhYmxlIGZyb20geW91ciBicm93c2VyIGV4dGVuc2lvbmApO1xuICAgIGF3YWl0IHRoaXMud2FpdEZvckV4dGVuc2lvbigpO1xuICAgIGNvbnN0IHNlbmRlckhleFB1YktleSA9IHNlbmRlci5wdWJrZXk7XG4gICAgcmV0dXJuIHRoaXMucXVldWVFbmNyeXB0aW9uKG5pcCwgXCJkZWNyeXB0XCIsIHNlbmRlckhleFB1YktleSwgdmFsdWUpO1xuICB9XG4gIGFzeW5jIHF1ZXVlRW5jcnlwdGlvbihzY2hlbWUsIG1ldGhvZCwgY291bnRlcnBhcnR5SGV4cHVia2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmVuY3J5cHRpb25RdWV1ZS5wdXNoKHtcbiAgICAgICAgc2NoZW1lLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIGNvdW50ZXJwYXJ0eUhleHB1YmtleSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHJlc29sdmUsXG4gICAgICAgIHJlamVjdFxuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMuZW5jcnlwdGlvblByb2Nlc3NpbmcpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzRW5jcnlwdGlvblF1ZXVlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0VuY3J5cHRpb25RdWV1ZShpdGVtLCByZXRyaWVzID0gMCkge1xuICAgIGlmICghaXRlbSAmJiB0aGlzLmVuY3J5cHRpb25RdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmNyeXB0aW9uUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgY29uc3QgY3VycmVudEl0ZW0gPSBpdGVtIHx8IHRoaXMuZW5jcnlwdGlvblF1ZXVlLnNoaWZ0KCk7XG4gICAgaWYgKCFjdXJyZW50SXRlbSkge1xuICAgICAgdGhpcy5lbmNyeXB0aW9uUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHNjaGVtZSwgbWV0aG9kLCBjb3VudGVycGFydHlIZXhwdWJrZXksIHZhbHVlLCByZXNvbHZlLCByZWplY3QgfSA9IGN1cnJlbnRJdGVtO1xuICAgIHRoaXMuZGVidWcoXCJQcm9jZXNzaW5nIGVuY3J5cHRpb24gcXVldWUgaXRlbVwiLCB7XG4gICAgICBtZXRob2QsXG4gICAgICBjb3VudGVycGFydHlIZXhwdWJrZXksXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3aW5kb3cubm9zdHI/LltzY2hlbWVdPy5bbWV0aG9kXShjb3VudGVycGFydHlIZXhwdWJrZXksIHZhbHVlKTtcbiAgICAgIGlmICghcmVzdWx0KSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZW5jcnlwdC9kZWNyeXB0XCIpO1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICBpZiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKFwiY2FsbCBhbHJlYWR5IGV4ZWN1dGluZ1wiKSAmJiByZXRyaWVzIDwgNSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiUmV0cnlpbmcgZW5jcnlwdGlvbiBxdWV1ZSBpdGVtXCIsIHtcbiAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgY291bnRlcnBhcnR5SGV4cHVia2V5LFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHJldHJpZXNcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMucHJvY2Vzc0VuY3J5cHRpb25RdWV1ZShjdXJyZW50SXRlbSwgcmV0cmllcyArIDEpO1xuICAgICAgICB9LCA1MCAqIHJldHJpZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZWplY3QoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yTWVzc2FnZSkpO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NFbmNyeXB0aW9uUXVldWUoKTtcbiAgfVxuICB3YWl0Rm9yRXh0ZW5zaW9uKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAod2luZG93Lm5vc3RyKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHRpbWVySWQ7XG4gICAgICBjb25zdCBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBpZiAod2luZG93Lm5vc3RyKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDApO1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKFwiTklQLTA3IGV4dGVuc2lvbiBub3QgYXZhaWxhYmxlXCIpKTtcbiAgICAgIH0sIHRoaXMud2FpdFRpbWVvdXQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBzaWduZXIgdHlwZSBpbnRvIGEgc3RvcmFibGUgZm9ybWF0LlxuICAgKiBOSVAtMDcgc2lnbmVycyBkb24ndCBoYXZlIHBlcnNpc3RlbnQgc3RhdGUgdG8gc2VyaWFsaXplIGJleW9uZCB0aGVpciB0eXBlLlxuICAgKiBAcmV0dXJucyBBIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHR5cGUuXG4gICAqL1xuICB0b1BheWxvYWQoKSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIHR5cGU6IFwibmlwMDdcIixcbiAgICAgIHBheWxvYWQ6IFwiXCJcbiAgICAgIC8vIE5vIHNwZWNpZmljIHBheWxvYWQgbmVlZGVkIGZvciBOSVAtMDdcbiAgICB9O1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgfVxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBzaWduZXIgZnJvbSBhIHBheWxvYWQgc3RyaW5nLlxuICAgKiBDcmVhdGVzIGEgbmV3IE5ES05pcDA3U2lnbmVyIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gcGF5bG9hZFN0cmluZyBUaGUgSlNPTiBzdHJpbmcgb2J0YWluZWQgZnJvbSB0b1BheWxvYWQoKS5cbiAgICogQHBhcmFtIG5kayBPcHRpb25hbCBOREsgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIE5ES05pcDA3U2lnbmVyLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21QYXlsb2FkKHBheWxvYWRTdHJpbmcsIG5kaykge1xuICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKHBheWxvYWRTdHJpbmcpO1xuICAgIGlmIChwYXlsb2FkLnR5cGUgIT09IFwibmlwMDdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBheWxvYWQgdHlwZTogZXhwZWN0ZWQgJ25pcDA3JywgZ290ICR7cGF5bG9hZC50eXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9OREtOaXAwN1NpZ25lcih2b2lkIDAsIG5kayk7XG4gIH1cbn07XG5yZWdpc3RlclNpZ25lcihcIm5pcDA3XCIsIE5ES05pcDA3U2lnbmVyKTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9pbmRleC50c1xuaW1wb3J0IHsgaGV4VG9CeXRlcyBhcyBoZXhUb0J5dGVzMiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L3JwYy50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjUgfSBmcm9tIFwidHNlZXBcIjtcbnZhciBOREtOb3N0clJwYyA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyNSB7XG4gIG5kaztcbiAgc2lnbmVyO1xuICByZWxheVNldDtcbiAgZGVidWc7XG4gIGVuY3J5cHRpb25UeXBlID0gXCJuaXAwNFwiO1xuICBwb29sO1xuICBjb25zdHJ1Y3RvcihuZGssIHNpZ25lciwgZGVidWc5LCByZWxheVVybHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMuc2lnbmVyID0gc2lnbmVyO1xuICAgIGlmIChyZWxheVVybHMpIHtcbiAgICAgIHRoaXMucG9vbCA9IG5ldyBOREtQb29sKHJlbGF5VXJscywgW10sIG5kaywge1xuICAgICAgICBkZWJ1ZzogZGVidWc5LmV4dGVuZChcInJwYy1wb29sXCIpLFxuICAgICAgICBuYW1lOiBcIk5vc3RyIFJQQ1wiXG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVsYXlTZXQgPSBuZXcgTkRLUmVsYXlTZXQoLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgbmRrLCB0aGlzLnBvb2wpO1xuICAgICAgZm9yIChjb25zdCB1cmwgb2YgcmVsYXlVcmxzKSB7XG4gICAgICAgIGNvbnN0IHJlbGF5ID0gdGhpcy5wb29sLmdldFJlbGF5KHVybCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgcmVsYXkuYXV0aFBvbGljeSA9IE5ES1JlbGF5QXV0aFBvbGljaWVzLnNpZ25Jbih7IG5kaywgc2lnbmVyLCBkZWJ1ZzogZGVidWc5IH0pO1xuICAgICAgICB0aGlzLnJlbGF5U2V0LmFkZFJlbGF5KHJlbGF5KTtcbiAgICAgICAgcmVsYXkuY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRlYnVnID0gZGVidWc5LmV4dGVuZChcInJwY1wiKTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIGEgZmlsdGVyLiBUaGlzIGZ1bmN0aW9uIHdpbGwgcmVzb2x2ZSBvbmNlIHRoZSBzdWJzY3JpcHRpb24gaXMgcmVhZHkuXG4gICAqL1xuICBzdWJzY3JpYmUoZmlsdGVyKSB7XG4gICAgY29uc3Qgc3ViID0gdGhpcy5uZGsuc3Vic2NyaWJlKFxuICAgICAgZmlsdGVyLFxuICAgICAge1xuICAgICAgICBjbG9zZU9uRW9zZTogZmFsc2UsXG4gICAgICAgIGdyb3VwYWJsZTogZmFsc2UsXG4gICAgICAgIGNhY2hlVXNhZ2U6IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi8sXG4gICAgICAgIHBvb2w6IHRoaXMucG9vbCxcbiAgICAgICAgcmVsYXlTZXQ6IHRoaXMucmVsYXlTZXRcbiAgICAgIH0sXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgc3ViLm9uKFwiZXZlbnRcIiwgYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWRFdmVudCA9IGF3YWl0IHRoaXMucGFyc2VFdmVudChldmVudCk7XG4gICAgICAgIGlmIChwYXJzZWRFdmVudC5tZXRob2QpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJyZXF1ZXN0XCIsIHBhcnNlZEV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVtaXQoYHJlc3BvbnNlLSR7cGFyc2VkRXZlbnQuaWR9YCwgcGFyc2VkRXZlbnQpO1xuICAgICAgICAgIHRoaXMuZW1pdChcInJlc3BvbnNlXCIsIHBhcnNlZEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiZXJyb3IgcGFyc2luZyBldmVudFwiLCBlLCBldmVudC5yYXdFdmVudCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHN1Yi5vbihcImVvc2VcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmRlYnVnKFwiZW9zZWRcIik7XG4gICAgICAgIHJlc29sdmUoc3ViKTtcbiAgICAgIH0pO1xuICAgICAgc3ViLnN0YXJ0KCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcGFyc2VFdmVudChldmVudCkge1xuICAgIGlmICh0aGlzLmVuY3J5cHRpb25UeXBlID09PSBcIm5pcDQ0XCIgJiYgZXZlbnQuY29udGVudC5pbmNsdWRlcyhcIj9pdj1cIikpIHtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblR5cGUgPSBcIm5pcDA0XCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVuY3J5cHRpb25UeXBlID09PSBcIm5pcDA0XCIgJiYgIWV2ZW50LmNvbnRlbnQuaW5jbHVkZXMoXCI/aXY9XCIpKSB7XG4gICAgICB0aGlzLmVuY3J5cHRpb25UeXBlID0gXCJuaXA0NFwiO1xuICAgIH1cbiAgICBjb25zdCByZW1vdGVVc2VyID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogZXZlbnQucHVia2V5IH0pO1xuICAgIHJlbW90ZVVzZXIubmRrID0gdGhpcy5uZGs7XG4gICAgbGV0IGRlY3J5cHRlZENvbnRlbnQ7XG4gICAgdHJ5IHtcbiAgICAgIGRlY3J5cHRlZENvbnRlbnQgPSBhd2FpdCB0aGlzLnNpZ25lci5kZWNyeXB0KHJlbW90ZVVzZXIsIGV2ZW50LmNvbnRlbnQsIHRoaXMuZW5jcnlwdGlvblR5cGUpO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICBjb25zdCBvdGhlckVuY3J5cHRpb25UeXBlID0gdGhpcy5lbmNyeXB0aW9uVHlwZSA9PT0gXCJuaXAwNFwiID8gXCJuaXA0NFwiIDogXCJuaXAwNFwiO1xuICAgICAgZGVjcnlwdGVkQ29udGVudCA9IGF3YWl0IHRoaXMuc2lnbmVyLmRlY3J5cHQocmVtb3RlVXNlciwgZXZlbnQuY29udGVudCwgb3RoZXJFbmNyeXB0aW9uVHlwZSk7XG4gICAgICB0aGlzLmVuY3J5cHRpb25UeXBlID0gb3RoZXJFbmNyeXB0aW9uVHlwZTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkQ29udGVudCA9IEpTT04ucGFyc2UoZGVjcnlwdGVkQ29udGVudCk7XG4gICAgY29uc3QgeyBpZCwgbWV0aG9kLCBwYXJhbXMsIHJlc3VsdCwgZXJyb3IgfSA9IHBhcnNlZENvbnRlbnQ7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgcmV0dXJuIHsgaWQsIHB1YmtleTogZXZlbnQucHVia2V5LCBtZXRob2QsIHBhcmFtcywgZXZlbnQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaWQsIHJlc3VsdCwgZXJyb3IsIGV2ZW50IH07XG4gIH1cbiAgYXN5bmMgc2VuZFJlc3BvbnNlKGlkLCByZW1vdGVQdWJrZXksIHJlc3VsdCwga2luZCA9IDI0MTMzIC8qIE5vc3RyQ29ubmVjdCAqLywgZXJyb3IpIHtcbiAgICBjb25zdCByZXMgPSB7IGlkLCByZXN1bHQgfTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJlcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbFVzZXIgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3QgcmVtb3RlVXNlciA9IHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXk6IHJlbW90ZVB1YmtleSB9KTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywge1xuICAgICAga2luZCxcbiAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHJlcyksXG4gICAgICB0YWdzOiBbW1wicFwiLCByZW1vdGVQdWJrZXldXSxcbiAgICAgIHB1YmtleTogbG9jYWxVc2VyLnB1YmtleVxuICAgIH0pO1xuICAgIGV2ZW50LmNvbnRlbnQgPSBhd2FpdCB0aGlzLnNpZ25lci5lbmNyeXB0KHJlbW90ZVVzZXIsIGV2ZW50LmNvbnRlbnQsIHRoaXMuZW5jcnlwdGlvblR5cGUpO1xuICAgIGF3YWl0IGV2ZW50LnNpZ24odGhpcy5zaWduZXIpO1xuICAgIGF3YWl0IGV2ZW50LnB1Ymxpc2godGhpcy5yZWxheVNldCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmVxdWVzdC5cbiAgICogQHBhcmFtIHJlbW90ZVB1YmtleVxuICAgKiBAcGFyYW0gbWV0aG9kXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGtpbmRcbiAgICogQHBhcmFtIGlkXG4gICAqL1xuICBhc3luYyBzZW5kUmVxdWVzdChyZW1vdGVQdWJrZXksIG1ldGhvZCwgcGFyYW1zID0gW10sIGtpbmQgPSAyNDEzMywgY2IpIHtcbiAgICBjb25zdCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KTtcbiAgICBjb25zdCBsb2NhbFVzZXIgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3QgcmVtb3RlVXNlciA9IHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXk6IHJlbW90ZVB1YmtleSB9KTtcbiAgICBjb25zdCByZXF1ZXN0ID0geyBpZCwgbWV0aG9kLCBwYXJhbXMgfTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKCkgPT4ge1xuICAgICAgY29uc3QgcmVzcG9uc2VIYW5kbGVyID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5yZXN1bHQgPT09IFwiYXV0aF91cmxcIikge1xuICAgICAgICAgIHRoaXMub25jZShgcmVzcG9uc2UtJHtpZH1gLCByZXNwb25zZUhhbmRsZXIpO1xuICAgICAgICAgIHRoaXMuZW1pdChcImF1dGhVcmxcIiwgcmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICAgICAgY2IocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmNlKGByZXNwb25zZS0ke2lkfWAsIHJlc3BvbnNlSGFuZGxlcik7XG4gICAgfSk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQsXG4gICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSxcbiAgICAgIHRhZ3M6IFtbXCJwXCIsIHJlbW90ZVB1YmtleV1dLFxuICAgICAgcHVia2V5OiBsb2NhbFVzZXIucHVia2V5XG4gICAgfSk7XG4gICAgZXZlbnQuY29udGVudCA9IGF3YWl0IHRoaXMuc2lnbmVyLmVuY3J5cHQocmVtb3RlVXNlciwgZXZlbnQuY29udGVudCwgdGhpcy5lbmNyeXB0aW9uVHlwZSk7XG4gICAgYXdhaXQgZXZlbnQuc2lnbih0aGlzLnNpZ25lcik7XG4gICAgYXdhaXQgZXZlbnQucHVibGlzaCh0aGlzLnJlbGF5U2V0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9jb25uZWN0LnRzXG52YXIgQ29ubmVjdEV2ZW50SGFuZGxpbmdTdHJhdGVneSA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtfLCB0b2tlbl0gPSBwYXJhbXM7XG4gICAgY29uc3QgZGVidWc5ID0gYmFja2VuZC5kZWJ1Zy5leHRlbmQoXCJjb25uZWN0XCIpO1xuICAgIGRlYnVnOShgY29ubmVjdGlvbiByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9YCk7XG4gICAgaWYgKHRva2VuICYmIGJhY2tlbmQuYXBwbHlUb2tlbikge1xuICAgICAgZGVidWc5KFwiYXBwbHlpbmcgdG9rZW5cIik7XG4gICAgICBhd2FpdCBiYWNrZW5kLmFwcGx5VG9rZW4ocmVtb3RlUHVia2V5LCB0b2tlbik7XG4gICAgfVxuICAgIGlmIChhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgICAgaWQsXG4gICAgICBwdWJrZXk6IHJlbW90ZVB1YmtleSxcbiAgICAgIG1ldGhvZDogXCJjb25uZWN0XCIsXG4gICAgICBwYXJhbXM6IHRva2VuXG4gICAgfSkpIHtcbiAgICAgIGRlYnVnOShgY29ubmVjdGlvbiByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IGFsbG93ZWRgKTtcbiAgICAgIHJldHVybiBcImFja1wiO1xuICAgIH1cbiAgICBkZWJ1ZzkoYGNvbm5lY3Rpb24gcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSByZWplY3RlZGApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvZ2V0LXB1YmxpYy1rZXkudHNcbnZhciBHZXRQdWJsaWNLZXlIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgX2lkLCBfcmVtb3RlUHVia2V5LCBfcGFyYW1zKSB7XG4gICAgcmV0dXJuIGJhY2tlbmQubG9jYWxVc2VyPy5wdWJrZXk7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvbmlwMDQtZGVjcnlwdC50c1xudmFyIE5pcDA0RGVjcnlwdEhhbmRsaW5nU3RyYXRlZ3kgPSBjbGFzcyB7XG4gIGFzeW5jIGhhbmRsZShiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBwYXJhbXMpIHtcbiAgICBjb25zdCBbc2VuZGVyUHVia2V5LCBwYXlsb2FkXSA9IHBhcmFtcztcbiAgICBjb25zdCBzZW5kZXJVc2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXk6IHNlbmRlclB1YmtleSB9KTtcbiAgICBjb25zdCBkZWNyeXB0ZWRQYXlsb2FkID0gYXdhaXQgZGVjcnlwdDIoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgc2VuZGVyVXNlciwgcGF5bG9hZCk7XG4gICAgcmV0dXJuIGRlY3J5cHRlZFBheWxvYWQ7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0MihiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBzZW5kZXJVc2VyLCBwYXlsb2FkKSB7XG4gIGlmICghYXdhaXQgYmFja2VuZC5wdWJrZXlBbGxvd2VkKHtcbiAgICBpZCxcbiAgICBwdWJrZXk6IHJlbW90ZVB1YmtleSxcbiAgICBtZXRob2Q6IFwibmlwMDRfZGVjcnlwdFwiLFxuICAgIHBhcmFtczogcGF5bG9hZFxuICB9KSkge1xuICAgIGJhY2tlbmQuZGVidWcoYGRlY3J5cHQgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSByZWplY3RlZGApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IGJhY2tlbmQuc2lnbmVyLmRlY3J5cHQoc2VuZGVyVXNlciwgcGF5bG9hZCwgXCJuaXAwNFwiKTtcbn1cblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9uaXAwNC1lbmNyeXB0LnRzXG52YXIgTmlwMDRFbmNyeXB0SGFuZGxpbmdTdHJhdGVneSA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtyZWNpcGllbnRQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlY2lwaWVudFVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogcmVjaXBpZW50UHVia2V5IH0pO1xuICAgIGNvbnN0IGVuY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBlbmNyeXB0MihiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCByZWNpcGllbnRVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZW5jcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHQyKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHJlY2lwaWVudFVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXAwNF9lbmNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZW5jcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZW5jcnlwdChyZWNpcGllbnRVc2VyLCBwYXlsb2FkLCBcIm5pcDA0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL25pcDQ0LWRlY3J5cHQudHNcbnZhciBOaXAwNERlY3J5cHRIYW5kbGluZ1N0cmF0ZWd5MiA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtzZW5kZXJQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHNlbmRlclVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogc2VuZGVyUHVia2V5IH0pO1xuICAgIGNvbnN0IGRlY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBkZWNyeXB0MyhiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBzZW5kZXJVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZGVjcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQzKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHNlbmRlclVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXA0NF9kZWNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZGVjcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZGVjcnlwdChzZW5kZXJVc2VyLCBwYXlsb2FkLCBcIm5pcDQ0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL25pcDQ0LWVuY3J5cHQudHNcbnZhciBOaXAwNEVuY3J5cHRIYW5kbGluZ1N0cmF0ZWd5MiA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtyZWNpcGllbnRQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlY2lwaWVudFVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogcmVjaXBpZW50UHVia2V5IH0pO1xuICAgIGNvbnN0IGVuY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBlbmNyeXB0MyhiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCByZWNpcGllbnRVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZW5jcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHQzKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHJlY2lwaWVudFVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXA0NF9lbmNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZW5jcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZW5jcnlwdChyZWNpcGllbnRVc2VyLCBwYXlsb2FkLCBcIm5pcDQ0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL3BpbmcudHNcbnZhciBQaW5nRXZlbnRIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgX3BhcmFtcykge1xuICAgIGNvbnN0IGRlYnVnOSA9IGJhY2tlbmQuZGVidWcuZXh0ZW5kKFwicGluZ1wiKTtcbiAgICBkZWJ1ZzkoYHBpbmcgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fWApO1xuICAgIGlmIChhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoeyBpZCwgcHVia2V5OiByZW1vdGVQdWJrZXksIG1ldGhvZDogXCJwaW5nXCIgfSkpIHtcbiAgICAgIGRlYnVnOShgY29ubmVjdGlvbiByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IGFsbG93ZWRgKTtcbiAgICAgIHJldHVybiBcInBvbmdcIjtcbiAgICB9XG4gICAgZGVidWc5KGBjb25uZWN0aW9uIHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gcmVqZWN0ZWRgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL3NpZ24tZXZlbnQudHNcbnZhciBTaWduRXZlbnRIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gICAgY29uc3QgZXZlbnQgPSBhd2FpdCBzaWduRXZlbnQoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKTtcbiAgICBpZiAoIWV2ZW50KSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhd2FpdCBldmVudC50b05vc3RyRXZlbnQoKSk7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBzaWduRXZlbnQoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gIGNvbnN0IFtldmVudFN0cmluZ10gPSBwYXJhbXM7XG4gIGJhY2tlbmQuZGVidWcoYHNpZ24gZXZlbnQgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fWApO1xuICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudChiYWNrZW5kLm5kaywgSlNPTi5wYXJzZShldmVudFN0cmluZykpO1xuICBiYWNrZW5kLmRlYnVnKFwiZXZlbnQgdG8gc2lnblwiLCBldmVudC5yYXdFdmVudCgpKTtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJzaWduX2V2ZW50XCIsXG4gICAgcGFyYW1zOiBldmVudFxuICB9KSkge1xuICAgIGJhY2tlbmQuZGVidWcoYHNpZ24gZXZlbnQgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSByZWplY3RlZGApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgYmFja2VuZC5kZWJ1Zyhgc2lnbiBldmVudCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IGFsbG93ZWRgKTtcbiAgYXdhaXQgZXZlbnQuc2lnbihiYWNrZW5kLnNpZ25lcik7XG4gIHJldHVybiBldmVudDtcbn1cblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9pbmRleC50c1xudmFyIE5ES05pcDQ2QmFja2VuZCA9IGNsYXNzIHtcbiAgbmRrO1xuICBzaWduZXI7XG4gIGxvY2FsVXNlcjtcbiAgZGVidWc7XG4gIHJwYztcbiAgcGVybWl0Q2FsbGJhY2s7XG4gIHJlbGF5VXJscztcbiAgLyoqXG4gICAqIEBwYXJhbSBuZGsgVGhlIE5ESyBpbnN0YW5jZSB0byB1c2VcbiAgICogQHBhcmFtIHByaXZhdGVLZXlPclNpZ25lciBUaGUgcHJpdmF0ZSBrZXkgb3Igc2lnbmVyIG9mIHRoZSBucHViIHRoYXQgd2FudHMgdG8gYmUgcHVibGlzaGVkIGFzXG4gICAqIEBwYXJhbSBwZXJtaXRDYWxsYmFjayBDYWxsYmFjayBleGVjdXRlZCB3aGVuIHBlcm1pc3Npb24gaXMgcmVxdWVzdGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuZGssIHByaXZhdGVLZXlPclNpZ25lciwgcGVybWl0Q2FsbGJhY2ssIHJlbGF5VXJscykge1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIGlmIChwcml2YXRlS2V5T3JTaWduZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICB0aGlzLnNpZ25lciA9IG5ldyBOREtQcml2YXRlS2V5U2lnbmVyKHByaXZhdGVLZXlPclNpZ25lcik7XG4gICAgfSBlbHNlIGlmIChwcml2YXRlS2V5T3JTaWduZXIgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgIHRoaXMuc2lnbmVyID0gbmV3IE5ES1ByaXZhdGVLZXlTaWduZXIoaGV4VG9CeXRlczIocHJpdmF0ZUtleU9yU2lnbmVyKSk7XG4gICAgfSBlbHNlIGlmIChwcml2YXRlS2V5T3JTaWduZXIgaW5zdGFuY2VvZiBOREtQcml2YXRlS2V5U2lnbmVyKSB7XG4gICAgICB0aGlzLnNpZ25lciA9IHByaXZhdGVLZXlPclNpZ25lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduZXJcIik7XG4gICAgfVxuICAgIHRoaXMuZGVidWcgPSBuZGsuZGVidWcuZXh0ZW5kKFwibmlwNDY6YmFja2VuZFwiKTtcbiAgICB0aGlzLnJlbGF5VXJscyA9IHJlbGF5VXJscyA/PyBBcnJheS5mcm9tKG5kay5wb29sLnJlbGF5cy5rZXlzKCkpO1xuICAgIHRoaXMucnBjID0gbmV3IE5ES05vc3RyUnBjKG5kaywgdGhpcy5zaWduZXIsIHRoaXMuZGVidWcsIHRoaXMucmVsYXlVcmxzKTtcbiAgICB0aGlzLnBlcm1pdENhbGxiYWNrID0gcGVybWl0Q2FsbGJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHN0YXJ0cyB0aGUgYmFja2VuZCwgd2hpY2ggd2lsbCBzdGFydCBsaXN0ZW5pbmcgZm9yIGluY29taW5nXG4gICAqIHJlcXVlc3RzLlxuICAgKi9cbiAgYXN5bmMgc3RhcnQoKSB7XG4gICAgdGhpcy5sb2NhbFVzZXIgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3Qgc3ViID0gdGhpcy5uZGsuc3Vic2NyaWJlKFxuICAgICAge1xuICAgICAgICBraW5kczogWzI0MTMzXSxcbiAgICAgICAgXCIjcFwiOiBbdGhpcy5sb2NhbFVzZXIucHVia2V5XVxuICAgICAgfSxcbiAgICAgIHsgY2xvc2VPbkVvc2U6IGZhbHNlIH1cbiAgICApO1xuICAgIHN1Yi5vbihcImV2ZW50XCIsIChlKSA9PiB0aGlzLmhhbmRsZUluY29taW5nRXZlbnQoZSkpO1xuICB9XG4gIGhhbmRsZXJzID0ge1xuICAgIGNvbm5lY3Q6IG5ldyBDb25uZWN0RXZlbnRIYW5kbGluZ1N0cmF0ZWd5KCksXG4gICAgc2lnbl9ldmVudDogbmV3IFNpZ25FdmVudEhhbmRsaW5nU3RyYXRlZ3koKSxcbiAgICBuaXAwNF9lbmNyeXB0OiBuZXcgTmlwMDRFbmNyeXB0SGFuZGxpbmdTdHJhdGVneSgpLFxuICAgIG5pcDA0X2RlY3J5cHQ6IG5ldyBOaXAwNERlY3J5cHRIYW5kbGluZ1N0cmF0ZWd5KCksXG4gICAgbmlwNDRfZW5jcnlwdDogbmV3IE5pcDA0RW5jcnlwdEhhbmRsaW5nU3RyYXRlZ3kyKCksXG4gICAgbmlwNDRfZGVjcnlwdDogbmV3IE5pcDA0RGVjcnlwdEhhbmRsaW5nU3RyYXRlZ3kyKCksXG4gICAgZ2V0X3B1YmxpY19rZXk6IG5ldyBHZXRQdWJsaWNLZXlIYW5kbGluZ1N0cmF0ZWd5KCksXG4gICAgcGluZzogbmV3IFBpbmdFdmVudEhhbmRsaW5nU3RyYXRlZ3koKVxuICB9O1xuICAvKipcbiAgICogRW5hYmxlcyB0aGUgdXNlciB0byBzZXQgYSBjdXN0b20gc3RyYXRlZ3kgZm9yIGhhbmRsaW5nIGluY29taW5nIGV2ZW50cy5cbiAgICogQHBhcmFtIG1ldGhvZCAtIFRoZSBtZXRob2QgdG8gc2V0IHRoZSBzdHJhdGVneSBmb3JcbiAgICogQHBhcmFtIHN0cmF0ZWd5IC0gVGhlIHN0cmF0ZWd5IHRvIHNldFxuICAgKi9cbiAgc2V0U3RyYXRlZ3kobWV0aG9kLCBzdHJhdGVneSkge1xuICAgIHRoaXMuaGFuZGxlcnNbbWV0aG9kXSA9IHN0cmF0ZWd5O1xuICB9XG4gIC8qKlxuICAgKiBPdmVybG9hZCB0aGlzIG1ldGhvZCB0byBhcHBseSB0b2tlbnMsIHdoaWNoIGNhblxuICAgKiB3cmFwIHBlcm1pc3Npb24gc2V0cyB0byBiZSBhcHBsaWVkIHRvIGEgcHVia2V5LlxuICAgKiBAcGFyYW0gcHVia2V5IHB1YmxpYyBrZXkgdG8gYXBwbHkgdG9rZW4gdG9cbiAgICogQHBhcmFtIHRva2VuIHRva2VuIHRvIGFwcGx5XG4gICAqL1xuICBhc3luYyBhcHBseVRva2VuKF9wdWJrZXksIF90b2tlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvbm5lY3Rpb24gdG9rZW4gbm90IHN1cHBvcnRlZFwiKTtcbiAgfVxuICBhc3luYyBoYW5kbGVJbmNvbWluZ0V2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgeyBpZCwgbWV0aG9kLCBwYXJhbXMgfSA9IGF3YWl0IHRoaXMucnBjLnBhcnNlRXZlbnQoZXZlbnQpO1xuICAgIGNvbnN0IHJlbW90ZVB1YmtleSA9IGV2ZW50LnB1YmtleTtcbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgdGhpcy5kZWJ1ZyhcImluY29taW5nIGV2ZW50XCIsIHsgaWQsIG1ldGhvZCwgcGFyYW1zIH0pO1xuICAgIGlmICghZXZlbnQudmVyaWZ5U2lnbmF0dXJlKGZhbHNlKSkge1xuICAgICAgdGhpcy5kZWJ1ZyhcImludmFsaWQgc2lnbmF0dXJlXCIsIGV2ZW50LnJhd0V2ZW50KCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdHJhdGVneSA9IHRoaXMuaGFuZGxlcnNbbWV0aG9kXTtcbiAgICBpZiAoc3RyYXRlZ3kpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgc3RyYXRlZ3kuaGFuZGxlKHRoaXMsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJlcnJvciBoYW5kbGluZyBldmVudFwiLCBlLCB7IGlkLCBtZXRob2QsIHBhcmFtcyB9KTtcbiAgICAgICAgdGhpcy5ycGMuc2VuZFJlc3BvbnNlKGlkLCByZW1vdGVQdWJrZXksIFwiZXJyb3JcIiwgdm9pZCAwLCBlLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlYnVnKFwidW5zdXBwb3J0ZWQgbWV0aG9kXCIsIHsgbWV0aG9kLCBwYXJhbXMgfSk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgdGhpcy5kZWJ1Zyhgc2VuZGluZyByZXNwb25zZSB0byAke3JlbW90ZVB1YmtleX1gLCByZXNwb25zZSk7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVzcG9uc2UoaWQsIHJlbW90ZVB1YmtleSwgcmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVzcG9uc2UoaWQsIHJlbW90ZVB1YmtleSwgXCJlcnJvclwiLCB2b2lkIDAsIFwiTm90IGF1dGhvcml6ZWRcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGVuIGJ5IHRoZSB1c2VyIHRvIGFsbG93IG9yIHJlamVjdCBpbmNvbWluZ1xuICAgKiBjb25uZWN0aW9ucy5cbiAgICovXG4gIGFzeW5jIHB1YmtleUFsbG93ZWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMucGVybWl0Q2FsbGJhY2socGFyYW1zKTtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvaW5kZXgudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI2IH0gZnJvbSBcInRzZWVwXCI7XG5cbi8vIHNyYy9zaWduZXJzL2Rlc2VyaWFsaXphdGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gbmRrU2lnbmVyRnJvbVBheWxvYWQocGF5bG9hZFN0cmluZywgbmRrKSB7XG4gIGxldCBwYXJzZWQ7XG4gIHRyeSB7XG4gICAgcGFyc2VkID0gSlNPTi5wYXJzZShwYXlsb2FkU3RyaW5nKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcGFyc2Ugc2lnbmVyIHBheWxvYWQgc3RyaW5nXCIsIHBheWxvYWRTdHJpbmcsIGUpO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKCFwYXJzZWQgfHwgdHlwZW9mIHBhcnNlZC50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBzaWduZXIgcGF5bG9hZCBzdHJpbmdcIiwgcGF5bG9hZFN0cmluZywgbmV3IEVycm9yKFwiTWlzc2luZyB0eXBlIGZpZWxkXCIpKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IFNpZ25lckNsYXNzID0gc2lnbmVyUmVnaXN0cnkuZ2V0KHBhcnNlZC50eXBlKTtcbiAgaWYgKCFTaWduZXJDbGFzcykge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzaWduZXIgdHlwZTogJHtwYXJzZWQudHlwZX1gKTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBTaWduZXJDbGFzcy5mcm9tUGF5bG9hZChwYXlsb2FkU3RyaW5nLCBuZGspO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc3QgZXJyb3JNc2cgPSBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGVzZXJpYWxpemUgc2lnbmVyIHR5cGUgJHtwYXJzZWQudHlwZX06ICR7ZXJyb3JNc2d9YCk7XG4gIH1cbn1cblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvbm9zdHJjb25uZWN0LnRzXG5mdW5jdGlvbiBub3N0ckNvbm5lY3RHZW5lcmF0ZVNlY3JldCgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZU5vc3RyQ29ubmVjdFVyaShwdWJrZXksIHNlY3JldCwgcmVsYXksIG9wdGlvbnMpIHtcbiAgY29uc3QgbWV0YSA9IHtcbiAgICBuYW1lOiBvcHRpb25zPy5uYW1lID8gZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMubmFtZSkgOiBcIlwiLFxuICAgIHVybDogb3B0aW9ucz8udXJsID8gZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMudXJsKSA6IFwiXCIsXG4gICAgaW1hZ2U6IG9wdGlvbnM/LmltYWdlID8gZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMuaW1hZ2UpIDogXCJcIixcbiAgICBwZXJtczogb3B0aW9ucz8ucGVybXMgPyBlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5wZXJtcykgOiBcIlwiXG4gIH07XG4gIGxldCB1cmkgPSBgbm9zdHJjb25uZWN0Oi8vJHtwdWJrZXl9P2ltYWdlPSR7bWV0YS5pbWFnZX0mdXJsPSR7bWV0YS51cmx9Jm5hbWU9JHttZXRhLm5hbWV9JnBlcm1zPSR7bWV0YS5wZXJtc30mc2VjcmV0PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHNlY3JldCl9YDtcbiAgaWYgKHJlbGF5KSB7XG4gICAgdXJpICs9IGAmcmVsYXk9JHtlbmNvZGVVUklDb21wb25lbnQocmVsYXkpfWA7XG4gIH1cbiAgcmV0dXJuIHVyaTtcbn1cblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvaW5kZXgudHNcbnZhciBOREtOaXA0NlNpZ25lciA9IGNsYXNzIF9OREtOaXA0NlNpZ25lciBleHRlbmRzIEV2ZW50RW1pdHRlcjYge1xuICBuZGs7XG4gIF91c2VyO1xuICAvKipcbiAgICogVGhlIHB1YmtleSBvZiB0aGUgYnVua2VyIHRoYXQgd2lsbCBiZSBwcm92aWRpbmcgc2lnbmF0dXJlc1xuICAgKi9cbiAgYnVua2VyUHVia2V5O1xuICAvKipcbiAgICogVGhlIHB1YmtleSBvZiB0aGUgdXNlciB0aGF0IGV2ZW50cyB3aWxsIGJlIHB1Ymxpc2hlZCBhc1xuICAgKi9cbiAgdXNlclB1YmtleTtcbiAgZ2V0IHB1YmtleSgpIHtcbiAgICBpZiAoIXRoaXMudXNlclB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiTm90IHJlYWR5XCIpO1xuICAgIHJldHVybiB0aGlzLnVzZXJQdWJrZXk7XG4gIH1cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIHNlY3JldCB2YWx1ZSBwcm92aWRlZCB0byBjb25uZWN0IHRvIHRoZSBidW5rZXJcbiAgICovXG4gIHNlY3JldDtcbiAgbG9jYWxTaWduZXI7XG4gIG5pcDA1O1xuICBycGM7XG4gIGRlYnVnO1xuICByZWxheVVybHM7XG4gIHN1YnNjcmlwdGlvbjtcbiAgLyoqXG4gICAqIElmIHVzaW5nIG5vc3RyY29ubmVjdDovLywgc3RvcmVzIHRoZSBub3N0ckNvbm5lY3RVUklcbiAgICovXG4gIG5vc3RyQ29ubmVjdFVyaTtcbiAgLyoqXG4gICAqIFRoZSByYW5kb20gc2VjcmV0IHVzZWQgZm9yIG5vc3RyY29ubmVjdDovLyBmbG93cy5cbiAgICovXG4gIG5vc3RyQ29ubmVjdFNlY3JldDtcbiAgLyoqXG4gICAqXG4gICAqIERvbid0IGluc3RhbnRpYXRlIHRoaXMgZGlyZWN0bHkuIFVzZSB0aGUgc3RhdGljIG1ldGhvZHMgaW5zdGVhZC5cbiAgICpcbiAgICogQGV4YW1wbGU6XG4gICAqIC8vIGZvciBidW5rZXI6Ly8gZmxvd1xuICAgKiBjb25zdCBzaWduZXIgPSBOREtOaXA0NlNpZ25lci5idW5rZXIobmRrLCBcImJ1bmtlcjovLzxjb25uZWN0aW9uLXRva2VuPlwiKVxuICAgKiBjb25zdCBzaWduZXIgPSBOREtOaXA0NlNpZ25lci5idW5rZXIobmRrLCBcIjx5b3VyLW5pcDA1PlwiKTsgLy8gd2l0aCBuaXAwNSBmbG93XG4gICAqIC8vIGZvciBub3N0cmNvbm5lY3Q6Ly8gZmxvd1xuICAgKiBjb25zdCBzaWduZXIgPSBOREtOaXA0NlNpZ25lci5ub3N0cmNvbm5lY3QobmRrLCBcIndzczovL3JlbGF5LmV4YW1wbGUuY29tXCIpXG4gICAqXG4gICAqIEBwYXJhbSBuZGsgLSBUaGUgTkRLIGluc3RhbmNlIHRvIHVzZVxuICAgKiBAcGFyYW0gdXNlck9yQ29ubmVjdGlvblRva2VuIC0gVGhlIHB1YmxpYyBrZXksIG9yIGEgY29ubmVjdGlvbiB0b2tlbiwgb2YgdGhlIG5wdWIgdGhhdCB3YW50cyB0byBiZSBwdWJsaXNoZWQgYXNcbiAgICogQHBhcmFtIGxvY2FsU2lnbmVyIC0gVGhlIHNpZ25lciB0aGF0IHdpbGwgYmUgdXNlZCB0byByZXF1ZXN0IGV2ZW50cyB0byBiZSBzaWduZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKG5kaywgdXNlck9yQ29ubmVjdGlvblRva2VuLCBsb2NhbFNpZ25lciwgcmVsYXlVcmxzLCBub3N0ckNvbm5lY3RPcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLmRlYnVnID0gbmRrLmRlYnVnLmV4dGVuZChcIm5pcDQ2OnNpZ25lclwiKTtcbiAgICB0aGlzLnJlbGF5VXJscyA9IHJlbGF5VXJscztcbiAgICBpZiAoIWxvY2FsU2lnbmVyKSB7XG4gICAgICB0aGlzLmxvY2FsU2lnbmVyID0gTkRLUHJpdmF0ZUtleVNpZ25lci5nZW5lcmF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIGxvY2FsU2lnbmVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRoaXMubG9jYWxTaWduZXIgPSBuZXcgTkRLUHJpdmF0ZUtleVNpZ25lcihsb2NhbFNpZ25lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvY2FsU2lnbmVyID0gbG9jYWxTaWduZXI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1c2VyT3JDb25uZWN0aW9uVG9rZW4gPT09IGZhbHNlKSB7XG4gICAgfSBlbHNlIGlmICghdXNlck9yQ29ubmVjdGlvblRva2VuKSB7XG4gICAgICB0aGlzLm5vc3RyY29ubmVjdEZsb3dJbml0KG5vc3RyQ29ubmVjdE9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodXNlck9yQ29ubmVjdGlvblRva2VuLnN0YXJ0c1dpdGgoXCJidW5rZXI6Ly9cIikpIHtcbiAgICAgIHRoaXMuYnVua2VyRmxvd0luaXQodXNlck9yQ29ubmVjdGlvblRva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uaXAwNUluaXQodXNlck9yQ29ubmVjdGlvblRva2VuKTtcbiAgICB9XG4gICAgdGhpcy5ycGMgPSBuZXcgTkRLTm9zdHJScGModGhpcy5uZGssIHRoaXMubG9jYWxTaWduZXIsIHRoaXMuZGVidWcsIHRoaXMucmVsYXlVcmxzKTtcbiAgfVxuICAvKipcbiAgICogQ29ubm5lY3Qgd2l0aCBhIGJ1bmtlcjovLyBmbG93XG4gICAqIEBwYXJhbSBuZGtcbiAgICogQHBhcmFtIHVzZXJPckNvbm5lY3Rpb25Ub2tlbiBidW5rZXI6Ly8gY29ubmVjdGlvbiBzdHJpbmdcbiAgICogQHBhcmFtIGxvY2FsU2lnbmVyIElmIHlvdSBoYXZlIHByZXZpb3VzbHkgYXV0aGVudGljYXRlZCB3aXRoIHRoaXMgc2lnbmVyLCB5b3UgY2FuIHJlc3RvcmUgdGhlIHNlc3Npb24gYnkgcHJvdmlkaW5nIHRoZSBwcmV2aW91c2x5IGF1dGhlbnRpY2F0ZWQga2V5XG4gICAqL1xuICBzdGF0aWMgYnVua2VyKG5kaywgdXNlck9yQ29ubmVjdGlvblRva2VuLCBsb2NhbFNpZ25lcikge1xuICAgIHJldHVybiBuZXcgX05ES05pcDQ2U2lnbmVyKG5kaywgdXNlck9yQ29ubmVjdGlvblRva2VuLCBsb2NhbFNpZ25lcik7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3Qgd2l0aCBhIG5vc3RyY29ubmVjdDovLyBmbG93XG4gICAqIEBwYXJhbSBuZGtcbiAgICogQHBhcmFtIHJlbGF5IC0gUmVsYXkgdXNlZCB0byBjb25uZWN0IHdpdGggdGhlIHNpZ25lclxuICAgKiBAcGFyYW0gbG9jYWxTaWduZXIgSWYgeW91IGhhdmUgcHJldmlvdXNseSBhdXRoZW50aWNhdGVkIHdpdGggdGhpcyBzaWduZXIsIHlvdSBjYW4gcmVzdG9yZSB0aGUgc2Vzc2lvbiBieSBwcm92aWRpbmcgdGhlIHByZXZpb3VzbHkgYXV0aGVudGljYXRlZCBrZXlcbiAgICovXG4gIHN0YXRpYyBub3N0cmNvbm5lY3QobmRrLCByZWxheSwgbG9jYWxTaWduZXIsIG5vc3RyQ29ubmVjdE9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IF9OREtOaXA0NlNpZ25lcihuZGssIHZvaWQgMCwgbG9jYWxTaWduZXIsIFtyZWxheV0sIG5vc3RyQ29ubmVjdE9wdGlvbnMpO1xuICB9XG4gIG5vc3RyY29ubmVjdEZsb3dJbml0KG5vc3RyQ29ubmVjdE9wdGlvbnMpIHtcbiAgICB0aGlzLm5vc3RyQ29ubmVjdFNlY3JldCA9IG5vc3RyQ29ubmVjdEdlbmVyYXRlU2VjcmV0KCk7XG4gICAgY29uc3QgcHVia2V5ID0gdGhpcy5sb2NhbFNpZ25lci5wdWJrZXk7XG4gICAgdGhpcy5ub3N0ckNvbm5lY3RVcmkgPSBnZW5lcmF0ZU5vc3RyQ29ubmVjdFVyaShcbiAgICAgIHB1YmtleSxcbiAgICAgIHRoaXMubm9zdHJDb25uZWN0U2VjcmV0LFxuICAgICAgdGhpcy5yZWxheVVybHM/LlswXSxcbiAgICAgIG5vc3RyQ29ubmVjdE9wdGlvbnNcbiAgICApO1xuICB9XG4gIGJ1bmtlckZsb3dJbml0KGNvbm5lY3Rpb25Ub2tlbikge1xuICAgIGNvbnN0IGJ1bmtlclVybCA9IG5ldyBVUkwoY29ubmVjdGlvblRva2VuKTtcbiAgICBjb25zdCBidW5rZXJQdWJrZXkgPSBidW5rZXJVcmwuaG9zdG5hbWUgfHwgYnVua2VyVXJsLnBhdGhuYW1lLnJlcGxhY2UoL15cXC9cXC8vLCBcIlwiKTtcbiAgICBjb25zdCB1c2VyUHVia2V5ID0gYnVua2VyVXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJwdWJrZXlcIik7XG4gICAgY29uc3QgcmVsYXlVcmxzID0gYnVua2VyVXJsLnNlYXJjaFBhcmFtcy5nZXRBbGwoXCJyZWxheVwiKTtcbiAgICBjb25zdCBzZWNyZXQgPSBidW5rZXJVcmwuc2VhcmNoUGFyYW1zLmdldChcInNlY3JldFwiKTtcbiAgICB0aGlzLmJ1bmtlclB1YmtleSA9IGJ1bmtlclB1YmtleTtcbiAgICB0aGlzLnVzZXJQdWJrZXkgPSB1c2VyUHVia2V5O1xuICAgIHRoaXMucmVsYXlVcmxzID0gcmVsYXlVcmxzO1xuICAgIHRoaXMuc2VjcmV0ID0gc2VjcmV0O1xuICB9XG4gIG5pcDA1SW5pdChuaXAwNSkge1xuICAgIHRoaXMubmlwMDUgPSBuaXAwNTtcbiAgfVxuICAvKipcbiAgICogV2Ugc3RhcnQgbGlzdGVuaW5nIGZvciBldmVudHMgZnJvbSB0aGUgYnVua2VyXG4gICAqL1xuICBhc3luYyBzdGFydExpc3RlbmluZygpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHJldHVybjtcbiAgICBjb25zdCBsb2NhbFVzZXIgPSBhd2FpdCB0aGlzLmxvY2FsU2lnbmVyLnVzZXIoKTtcbiAgICBpZiAoIWxvY2FsVXNlcikgdGhyb3cgbmV3IEVycm9yKFwiTG9jYWwgc2lnbmVyIG5vdCByZWFkeVwiKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IGF3YWl0IHRoaXMucnBjLnN1YnNjcmliZSh7XG4gICAgICBraW5kczogWzI0MTMzIC8qIE5vc3RyQ29ubmVjdCAqL10sXG4gICAgICBcIiNwXCI6IFtsb2NhbFVzZXIucHVia2V5XVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIgdGhhdCBpcyBiZWluZyBwdWJsaXNoZWQgYXNcbiAgICovXG4gIGFzeW5jIHVzZXIoKSB7XG4gICAgaWYgKHRoaXMuX3VzZXIpIHJldHVybiB0aGlzLl91c2VyO1xuICAgIHJldHVybiB0aGlzLmJsb2NrVW50aWxSZWFkeSgpO1xuICB9XG4gIGdldCB1c2VyU3luYygpIHtcbiAgICBpZiAoIXRoaXMuX3VzZXIpIHRocm93IG5ldyBFcnJvcihcIlJlbW90ZSB1c2VyIG5vdCByZWFkeSBzeW5jaHJvbm91c2x5XCIpO1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIGFzeW5jIGJsb2NrVW50aWxSZWFkeU5vc3RyQ29ubmVjdCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgY29ubmVjdCA9IChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2UucmVzdWx0ID09PSB0aGlzLm5vc3RyQ29ubmVjdFNlY3JldCkge1xuICAgICAgICAgIHRoaXMuX3VzZXIgPSByZXNwb25zZS5ldmVudC5hdXRob3I7XG4gICAgICAgICAgdGhpcy51c2VyUHVia2V5ID0gcmVzcG9uc2UuZXZlbnQucHVia2V5O1xuICAgICAgICAgIHRoaXMuYnVua2VyUHVia2V5ID0gcmVzcG9uc2UuZXZlbnQucHVia2V5O1xuICAgICAgICAgIHRoaXMucnBjLm9mZihcInJlc3BvbnNlXCIsIGNvbm5lY3QpO1xuICAgICAgICAgIHJlc29sdmUodGhpcy5fdXNlcik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnN0YXJ0TGlzdGVuaW5nKCk7XG4gICAgICB0aGlzLnJwYy5vbihcInJlc3BvbnNlXCIsIGNvbm5lY3QpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGJsb2NrVW50aWxSZWFkeSgpIHtcbiAgICBpZiAoIXRoaXMuYnVua2VyUHVia2V5ICYmICF0aGlzLm5vc3RyQ29ubmVjdFNlY3JldCAmJiAhdGhpcy5uaXAwNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVua2VyIHB1YmtleSBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5ub3N0ckNvbm5lY3RTZWNyZXQpIHJldHVybiB0aGlzLmJsb2NrVW50aWxSZWFkeU5vc3RyQ29ubmVjdCgpO1xuICAgIGlmICh0aGlzLm5pcDA1ICYmICF0aGlzLnVzZXJQdWJrZXkpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBOREtVc2VyLmZyb21OaXAwNSh0aGlzLm5pcDA1LCB0aGlzLm5kayk7XG4gICAgICBpZiAodXNlcikge1xuICAgICAgICB0aGlzLl91c2VyID0gdXNlcjtcbiAgICAgICAgdGhpcy51c2VyUHVia2V5ID0gdXNlci5wdWJrZXk7XG4gICAgICAgIHRoaXMucmVsYXlVcmxzID0gdXNlci5uaXA0NlVybHM7XG4gICAgICAgIHRoaXMucnBjID0gbmV3IE5ES05vc3RyUnBjKHRoaXMubmRrLCB0aGlzLmxvY2FsU2lnbmVyLCB0aGlzLmRlYnVnLCB0aGlzLnJlbGF5VXJscyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkgJiYgdGhpcy51c2VyUHVia2V5KSB7XG4gICAgICB0aGlzLmJ1bmtlclB1YmtleSA9IHRoaXMudXNlclB1YmtleTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmJ1bmtlclB1YmtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVua2VyIHB1YmtleSBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnN0YXJ0TGlzdGVuaW5nKCk7XG4gICAgdGhpcy5ycGMub24oXCJhdXRoVXJsXCIsICguLi5wcm9wcykgPT4ge1xuICAgICAgdGhpcy5lbWl0KFwiYXV0aFVybFwiLCAuLi5wcm9wcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNvbm5lY3RQYXJhbXMgPSBbdGhpcy51c2VyUHVia2V5ID8/IFwiXCJdO1xuICAgICAgaWYgKHRoaXMuc2VjcmV0KSBjb25uZWN0UGFyYW1zLnB1c2godGhpcy5zZWNyZXQpO1xuICAgICAgaWYgKCF0aGlzLmJ1bmtlclB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiQnVua2VyIHB1YmtleSBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QodGhpcy5idW5rZXJQdWJrZXksIFwiY29ubmVjdFwiLCBjb25uZWN0UGFyYW1zLCAyNDEzMywgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5yZXN1bHQgPT09IFwiYWNrXCIpIHtcbiAgICAgICAgICB0aGlzLmdldFB1YmxpY0tleSgpLnRoZW4oKHB1YmtleSkgPT4ge1xuICAgICAgICAgICAgdGhpcy51c2VyUHVia2V5ID0gcHVia2V5O1xuICAgICAgICAgICAgdGhpcy5fdXNlciA9IHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXkgfSk7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMuX3VzZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChyZXNwb25zZS5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24/LnN0b3AoKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHZvaWQgMDtcbiAgfVxuICBhc3luYyBnZXRQdWJsaWNLZXkoKSB7XG4gICAgaWYgKHRoaXMudXNlclB1YmtleSkgcmV0dXJuIHRoaXMudXNlclB1YmtleTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIF9yZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KHRoaXMuYnVua2VyUHVia2V5LCBcImdldF9wdWJsaWNfa2V5XCIsIFtdLCAyNDEzMywgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIHJlc29sdmUocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGVuY3J5cHRpb25FbmFibGVkKHNjaGVtZSkge1xuICAgIGlmIChzY2hlbWUpIHJldHVybiBbc2NoZW1lXTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtcIm5pcDA0XCIsIFwibmlwNDRcIl0pO1xuICB9XG4gIGFzeW5jIGVuY3J5cHQocmVjaXBpZW50LCB2YWx1ZSwgc2NoZW1lID0gXCJuaXAwNFwiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvbihyZWNpcGllbnQsIHZhbHVlLCBzY2hlbWUsIFwiZW5jcnlwdFwiKTtcbiAgfVxuICBhc3luYyBkZWNyeXB0KHNlbmRlciwgdmFsdWUsIHNjaGVtZSA9IFwibmlwMDRcIikge1xuICAgIHJldHVybiB0aGlzLmVuY3J5cHRpb24oc2VuZGVyLCB2YWx1ZSwgc2NoZW1lLCBcImRlY3J5cHRcIik7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdGlvbihwZWVyLCB2YWx1ZSwgc2NoZW1lLCBtZXRob2QpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmJ1bmtlclB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiQnVua2VyIHB1YmtleSBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QoXG4gICAgICAgIHRoaXMuYnVua2VyUHVia2V5LFxuICAgICAgICBgJHtzY2hlbWV9XyR7bWV0aG9kfWAsXG4gICAgICAgIFtwZWVyLnB1YmtleSwgdmFsdWVdLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBhc3luYyBzaWduKGV2ZW50KSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KFxuICAgICAgICB0aGlzLmJ1bmtlclB1YmtleSxcbiAgICAgICAgXCJzaWduX2V2ZW50XCIsXG4gICAgICAgIFtKU09OLnN0cmluZ2lmeShldmVudCldLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgICAgIHJlc29sdmUoanNvbi5zaWcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIGNyZWF0aW5nIGEgbmV3IGFjY291bnQgb24gdGhlIHJlbW90ZSBzZXJ2ZXIuXG4gICAqIEBwYXJhbSB1c2VybmFtZSBEZXNpcmVkIHVzZXJuYW1lIGZvciB0aGUgTklQLTA1XG4gICAqIEBwYXJhbSBkb21haW4gRGVzaXJlZCBkb21haW4gZm9yIHRoZSBOSVAtMDVcbiAgICogQHBhcmFtIGVtYWlsIEVtYWlsIGFkZHJlc3MgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBhY2NvdW50IC0tIFJlbW90ZSBzZXJ2ZXJzIG1heSB1c2UgdGhpcyBmb3IgcmVjb3ZlcnlcbiAgICogQHJldHVybnMgVGhlIHB1YmxpYyBrZXkgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgYWNjb3VudFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQWNjb3VudCh1c2VybmFtZSwgZG9tYWluLCBlbWFpbCkge1xuICAgIGF3YWl0IHRoaXMuc3RhcnRMaXN0ZW5pbmcoKTtcbiAgICBjb25zdCByZXEgPSBbXTtcbiAgICBpZiAodXNlcm5hbWUpIHJlcS5wdXNoKHVzZXJuYW1lKTtcbiAgICBpZiAoZG9tYWluKSByZXEucHVzaChkb21haW4pO1xuICAgIGlmIChlbWFpbCkgcmVxLnB1c2goZW1haWwpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMuYnVua2VyUHVia2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJCdW5rZXIgcHVia2V5IG5vdCBzZXRcIik7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVxdWVzdChcbiAgICAgICAgdGhpcy5idW5rZXJQdWJrZXksXG4gICAgICAgIFwiY3JlYXRlX2FjY291bnRcIixcbiAgICAgICAgcmVxLFxuICAgICAgICAyNDEzMyAvKiBOb3N0ckNvbm5lY3QgKi8sXG4gICAgICAgIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGlmICghcmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YmtleSA9IHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgIHJlc29sdmUocHVia2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIHNpZ25lcidzIGNvbm5lY3Rpb24gZGV0YWlscyBhbmQgbG9jYWwgc2lnbmVyIHN0YXRlLlxuICAgKiBAcmV0dXJucyBBIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHR5cGUsIGNvbm5lY3Rpb24gaW5mbywgYW5kIGxvY2FsIHNpZ25lciBwYXlsb2FkLlxuICAgKi9cbiAgdG9QYXlsb2FkKCkge1xuICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkgfHwgIXRoaXMudXNlclB1YmtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTklQLTQ2IHNpZ25lciBpcyBub3QgZnVsbHkgaW5pdGlhbGl6ZWQgZm9yIHNlcmlhbGl6YXRpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICB0eXBlOiBcIm5pcDQ2XCIsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGJ1bmtlclB1YmtleTogdGhpcy5idW5rZXJQdWJrZXksXG4gICAgICAgIHVzZXJQdWJrZXk6IHRoaXMudXNlclB1YmtleSxcbiAgICAgICAgcmVsYXlVcmxzOiB0aGlzLnJlbGF5VXJscyxcbiAgICAgICAgc2VjcmV0OiB0aGlzLnNlY3JldCxcbiAgICAgICAgbG9jYWxTaWduZXJQYXlsb2FkOiB0aGlzLmxvY2FsU2lnbmVyLnRvUGF5bG9hZCgpLFxuICAgICAgICAvLyBTdG9yZSBuaXAwNSBpZiBpdCB3YXMgdXNlZCBmb3IgaW5pdGlhbGl6YXRpb24sIG90aGVyd2lzZSBudWxsXG4gICAgICAgIG5pcDA1OiB0aGlzLm5pcDA1IHx8IG51bGxcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgfVxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBzaWduZXIgZnJvbSBhIHBheWxvYWQgc3RyaW5nLlxuICAgKiBAcGFyYW0gcGF5bG9hZFN0cmluZyBUaGUgSlNPTiBzdHJpbmcgb2J0YWluZWQgZnJvbSB0b1BheWxvYWQoKS5cbiAgICogQHBhcmFtIG5kayBUaGUgTkRLIGluc3RhbmNlLCByZXF1aXJlZCBmb3IgTklQLTQ2LlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBOREtOaXA0NlNpZ25lci5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBmcm9tUGF5bG9hZChwYXlsb2FkU3RyaW5nLCBuZGspIHtcbiAgICBpZiAoIW5kaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIGlzIHJlcXVpcmVkIHRvIGRlc2VyaWFsaXplIE5JUC00NiBzaWduZXJcIik7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UocGF5bG9hZFN0cmluZyk7XG4gICAgaWYgKHBhcnNlZC50eXBlICE9PSBcIm5pcDQ2XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXlsb2FkIHR5cGU6IGV4cGVjdGVkICduaXA0NicsIGdvdCAke3BhcnNlZC50eXBlfWApO1xuICAgIH1cbiAgICBjb25zdCBwYXlsb2FkID0gcGFyc2VkLnBheWxvYWQ7XG4gICAgaWYgKCFwYXlsb2FkIHx8IHR5cGVvZiBwYXlsb2FkICE9PSBcIm9iamVjdFwiIHx8ICFwYXlsb2FkLmxvY2FsU2lnbmVyUGF5bG9hZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXlsb2FkIGNvbnRlbnQgZm9yIG5pcDQ2IHNpZ25lclwiKTtcbiAgICB9XG4gICAgY29uc3QgbG9jYWxTaWduZXIgPSBhd2FpdCBuZGtTaWduZXJGcm9tUGF5bG9hZChwYXlsb2FkLmxvY2FsU2lnbmVyUGF5bG9hZCwgbmRrKTtcbiAgICBpZiAoIWxvY2FsU2lnbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVzZXJpYWxpemUgbG9jYWwgc2lnbmVyIGZvciBOSVAtNDZcIik7XG4gICAgfVxuICAgIGlmICghKGxvY2FsU2lnbmVyIGluc3RhbmNlb2YgTkRLUHJpdmF0ZUtleVNpZ25lcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvY2FsIHNpZ25lciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIE5ES1ByaXZhdGVLZXlTaWduZXJcIik7XG4gICAgfVxuICAgIGxldCBzaWduZXI7XG4gICAgc2lnbmVyID0gbmV3IF9OREtOaXA0NlNpZ25lcihuZGssIGZhbHNlLCBsb2NhbFNpZ25lciwgcGF5bG9hZC5yZWxheVVybHMpO1xuICAgIHNpZ25lci51c2VyUHVia2V5ID0gcGF5bG9hZC51c2VyUHVia2V5O1xuICAgIHNpZ25lci5idW5rZXJQdWJrZXkgPSBwYXlsb2FkLmJ1bmtlclB1YmtleTtcbiAgICBzaWduZXIucmVsYXlVcmxzID0gcGF5bG9hZC5yZWxheVVybHM7XG4gICAgc2lnbmVyLnNlY3JldCA9IHBheWxvYWQuc2VjcmV0O1xuICAgIGlmIChwYXlsb2FkLnVzZXJQdWJrZXkpIHtcbiAgICAgIHNpZ25lci5fdXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBwYXlsb2FkLnVzZXJQdWJrZXkgfSk7XG4gICAgICBpZiAoc2lnbmVyLl91c2VyKSBzaWduZXIuX3VzZXIubmRrID0gbmRrO1xuICAgIH1cbiAgICByZXR1cm4gc2lnbmVyO1xuICB9XG59O1xucmVnaXN0ZXJTaWduZXIoXCJuaXA0NlwiLCBOREtOaXA0NlNpZ25lcik7XG5cbi8vIHNyYy9kdm0vc2NoZWR1bGUudHNcbmZ1bmN0aW9uIGFkZFJlbGF5cyhldmVudCwgcmVsYXlzKSB7XG4gIGNvbnN0IHRhZ3MgPSBbXTtcbiAgaWYgKCFyZWxheXMgfHwgcmVsYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnN0IHBvb2xSZWxheXMgPSBldmVudC5uZGs/LnBvb2wucmVsYXlzO1xuICAgIHJlbGF5cyA9IHBvb2xSZWxheXMgPyBPYmplY3Qua2V5cyhwb29sUmVsYXlzKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocmVsYXlzICYmIHJlbGF5cy5sZW5ndGggPiAwKSB0YWdzLnB1c2goW1wicmVsYXlzXCIsIC4uLnJlbGF5c10pO1xuICByZXR1cm4gdGFncztcbn1cbmFzeW5jIGZ1bmN0aW9uIGR2bVNjaGVkdWxlKGV2ZW50cywgZHZtLCByZWxheXMsIGVuY3J5cHRlZCA9IHRydWUsIHdhaXRGb3JDb25maXJtYXRpb25Gb3JNcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXZlbnRzKSkge1xuICAgIGV2ZW50cyA9IFtldmVudHNdO1xuICB9XG4gIGNvbnN0IG5kayA9IGV2ZW50c1swXS5uZGs7XG4gIGlmICghbmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgbm90IHNldFwiKTtcbiAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICBpZiAoIWV2ZW50LnNpZykgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgbm90IHNpZ25lZFwiKTtcbiAgICBpZiAoIWV2ZW50LmNyZWF0ZWRfYXQpIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IGhhcyBubyBkYXRlXCIpO1xuICAgIGlmICghZHZtKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBEVk0gc3BlY2lmaWVkXCIpO1xuICAgIGlmIChldmVudC5jcmVhdGVkX2F0IDw9IERhdGUubm93KCkgLyAxZTMpIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IG5lZWRzIHRvIGJlIGluIHRoZSBmdXR1cmVcIik7XG4gIH1cbiAgY29uc3Qgc2NoZWR1bGVFdmVudCA9IG5ldyBOREtEVk1SZXF1ZXN0KG5kaywge1xuICAgIGtpbmQ6IDU5MDUgLyogRFZNRXZlbnRTY2hlZHVsZSAqL1xuICB9KTtcbiAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICBzY2hlZHVsZUV2ZW50LmFkZElucHV0KEpTT04uc3RyaW5naWZ5KGV2ZW50LnJhd0V2ZW50KCkpLCBcInRleHRcIik7XG4gIH1cbiAgc2NoZWR1bGVFdmVudC50YWdzLnB1c2goLi4uYWRkUmVsYXlzKGV2ZW50c1swXSwgcmVsYXlzKSk7XG4gIGlmIChlbmNyeXB0ZWQpIHtcbiAgICBhd2FpdCBzY2hlZHVsZUV2ZW50LmVuY3J5cHRpb24oZHZtKTtcbiAgfSBlbHNlIHtcbiAgICBzY2hlZHVsZUV2ZW50LmR2bSA9IGR2bTtcbiAgfVxuICBhd2FpdCBzY2hlZHVsZUV2ZW50LnNpZ24oKTtcbiAgbGV0IHJlcztcbiAgaWYgKHdhaXRGb3JDb25maXJtYXRpb25Gb3JNcykge1xuICAgIHJlcyA9IG5kay5zdWJzY3JpYmUoXG4gICAgICB7XG4gICAgICAgIGtpbmRzOiBbNTkwNSAvKiBEVk1FdmVudFNjaGVkdWxlICovICsgMWUzLCA3ZTMgLyogRFZNSm9iRmVlZGJhY2sgKi9dLFxuICAgICAgICAuLi5zY2hlZHVsZUV2ZW50LmZpbHRlcigpXG4gICAgICB9LFxuICAgICAgeyBncm91cGFibGU6IGZhbHNlLCBjbG9zZU9uRW9zZTogZmFsc2UgfVxuICAgICk7XG4gIH1cbiAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVqZWN0KSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZXM/LnN0b3AoKTtcbiAgICAgIHJlamVjdChcIlRpbWVvdXQgd2FpdGluZyBmb3IgYW4gYW5zd2VyIGZyb20gdGhlIERWTVwiKTtcbiAgICB9LCB3YWl0Rm9yQ29uZmlybWF0aW9uRm9yTXMpO1xuICB9KTtcbiAgY29uc3Qgc2NoZWR1bGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmICh3YWl0Rm9yQ29uZmlybWF0aW9uRm9yTXMpIHtcbiAgICAgIHJlcz8ub24oXCJldmVudFwiLCBhc3luYyAoZSkgPT4ge1xuICAgICAgICByZXM/LnN0b3AoKTtcbiAgICAgICAgaWYgKGUua2luZCA9PT0gN2UzIC8qIERWTUpvYkZlZWRiYWNrICovKSB7XG4gICAgICAgICAgY29uc3QgZmVlZGJhY2sgPSBhd2FpdCBOREtEVk1Kb2JGZWVkYmFjay5mcm9tKGUpO1xuICAgICAgICAgIGlmIChmZWVkYmFjay5zdGF0dXMgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzVGFnID0gZmVlZGJhY2suZ2V0TWF0Y2hpbmdUYWdzKFwic3RhdHVzXCIpO1xuICAgICAgICAgICAgcmVqZWN0KHN0YXR1c1RhZz8uWzJdID8/IGZlZWRiYWNrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShmZWVkYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgc2NoZWR1bGVFdmVudC5wdWJsaXNoKCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIXdhaXRGb3JDb25maXJtYXRpb25Gb3JNcykgcmVzb2x2ZSh2b2lkIDApO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAod2FpdEZvckNvbmZpcm1hdGlvbkZvck1zKSB7XG4gICAgICBQcm9taXNlLnJhY2UoW3RpbWVvdXRQcm9taXNlLCBzY2hlZHVsZVByb21pc2VdKS50aGVuKChlKSA9PiB7XG4gICAgICAgIHJlc29sdmUoZSk7XG4gICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZVByb21pc2UudGhlbihyZXNvbHZlKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvbmRrL2luZGV4LnRzXG5pbXBvcnQgZGVidWc4IGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjggfSBmcm9tIFwidHNlZXBcIjtcblxuLy8gc3JjL2V2ZW50cy9kZWR1cC50c1xuZnVuY3Rpb24gZGVkdXAoZXZlbnQxLCBldmVudDIpIHtcbiAgaWYgKGV2ZW50MS5jcmVhdGVkX2F0ID4gZXZlbnQyLmNyZWF0ZWRfYXQpIHtcbiAgICByZXR1cm4gZXZlbnQxO1xuICB9XG4gIHJldHVybiBldmVudDI7XG59XG5cbi8vIHNyYy9vdXRib3gvdHJhY2tlci50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjcgfSBmcm9tIFwidHNlZXBcIjtcbmltcG9ydCB7IExSVUNhY2hlIGFzIExSVUNhY2hlMiB9IGZyb20gXCJ0eXBlc2NyaXB0LWxydS1jYWNoZVwiO1xuXG4vLyBzcmMvdXRpbHMvZ2V0LXVzZXJzLXJlbGF5LWxpc3QudHNcbmFzeW5jIGZ1bmN0aW9uIGdldFJlbGF5TGlzdEZvclVzZXIocHVia2V5LCBuZGspIHtcbiAgY29uc3QgbGlzdCA9IGF3YWl0IGdldFJlbGF5TGlzdEZvclVzZXJzKFtwdWJrZXldLCBuZGspO1xuICByZXR1cm4gbGlzdC5nZXQocHVia2V5KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFJlbGF5TGlzdEZvclVzZXJzKHB1YmtleXMsIG5kaywgc2tpcENhY2hlID0gZmFsc2UsIHRpbWVvdXQgPSAxZTMpIHtcbiAgY29uc3QgcG9vbCA9IG5kay5vdXRib3hQb29sIHx8IG5kay5wb29sO1xuICBjb25zdCBzZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHJlbGF5IG9mIHBvb2wucmVsYXlzLnZhbHVlcygpKSBzZXQuYWRkKHJlbGF5KTtcbiAgY29uc3QgcmVsYXlMaXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGZyb21Db250YWN0TGlzdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHJlbGF5U2V0ID0gbmV3IE5ES1JlbGF5U2V0KHNldCwgbmRrKTtcbiAgaWYgKG5kay5jYWNoZUFkYXB0ZXI/LmxvY2tpbmcgJiYgIXNraXBDYWNoZSkge1xuICAgIGNvbnN0IGNhY2hlZExpc3QgPSBhd2FpdCBuZGsuZmV0Y2hFdmVudHMoXG4gICAgICB7IGtpbmRzOiBbMywgMTAwMDJdLCBhdXRob3JzOiBBcnJheS5mcm9tKG5ldyBTZXQocHVia2V5cykpIH0sXG4gICAgICB7IGNhY2hlVXNhZ2U6IFwiT05MWV9DQUNIRVwiIC8qIE9OTFlfQ0FDSEUgKi8sIHN1YklkOiBcIm5kay1yZWxheS1saXN0LWZldGNoXCIgfVxuICAgICk7XG4gICAgZm9yIChjb25zdCByZWxheUxpc3Qgb2YgY2FjaGVkTGlzdCkge1xuICAgICAgaWYgKHJlbGF5TGlzdC5raW5kID09PSAxMDAwMikgcmVsYXlMaXN0cy5zZXQocmVsYXlMaXN0LnB1YmtleSwgTkRLUmVsYXlMaXN0LmZyb20ocmVsYXlMaXN0KSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcmVsYXlMaXN0IG9mIGNhY2hlZExpc3QpIHtcbiAgICAgIGlmIChyZWxheUxpc3Qua2luZCA9PT0gMykge1xuICAgICAgICBpZiAocmVsYXlMaXN0cy5oYXMocmVsYXlMaXN0LnB1YmtleSkpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBsaXN0ID0gcmVsYXlMaXN0RnJvbUtpbmQzKG5kaywgcmVsYXlMaXN0KTtcbiAgICAgICAgaWYgKGxpc3QpIGZyb21Db250YWN0TGlzdC5zZXQocmVsYXlMaXN0LnB1YmtleSwgbGlzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHB1YmtleXMgPSBwdWJrZXlzLmZpbHRlcigocHVia2V5KSA9PiAhcmVsYXlMaXN0cy5oYXMocHVia2V5KSAmJiAhZnJvbUNvbnRhY3RMaXN0LmhhcyhwdWJrZXkpKTtcbiAgfVxuICBpZiAocHVia2V5cy5sZW5ndGggPT09IDApIHJldHVybiByZWxheUxpc3RzO1xuICBjb25zdCByZWxheUxpc3RFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBjb250YWN0TGlzdEV2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVN1YnNjcmlwdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHN1YnNjcmliZU9wdHMgPSB7XG4gICAgICAgIGNsb3NlT25Fb3NlOiB0cnVlLFxuICAgICAgICBwb29sLFxuICAgICAgICBncm91cGFibGU6IHRydWUsXG4gICAgICAgIHN1YklkOiBcIm5kay1yZWxheS1saXN0LWZldGNoXCIsXG4gICAgICAgIGFkZFNpbmNlRnJvbUNhY2hlOiB0cnVlLFxuICAgICAgICByZWxheVNldFxuICAgICAgfTtcbiAgICAgIGlmIChyZWxheVNldCkgc3Vic2NyaWJlT3B0cy5yZWxheVNldCA9IHJlbGF5U2V0O1xuICAgICAgbmRrLnN1YnNjcmliZSh7IGtpbmRzOiBbMywgMTAwMDJdLCBhdXRob3JzOiBwdWJrZXlzIH0sIHN1YnNjcmliZU9wdHMsIHtcbiAgICAgICAgb25FdmVudDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50LmtpbmQgPT09IDEwMDAyIC8qIFJlbGF5TGlzdCAqLykge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdFdmVudCA9IHJlbGF5TGlzdEV2ZW50cy5nZXQoZXZlbnQucHVia2V5KTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0V2ZW50ICYmIGV4aXN0aW5nRXZlbnQuY3JlYXRlZF9hdCA+IGV2ZW50LmNyZWF0ZWRfYXQpIHJldHVybjtcbiAgICAgICAgICAgIHJlbGF5TGlzdEV2ZW50cy5zZXQoZXZlbnQucHVia2V5LCBldmVudCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5raW5kID09PSAzIC8qIENvbnRhY3RzICovKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0V2ZW50ID0gY29udGFjdExpc3RFdmVudHMuZ2V0KGV2ZW50LnB1YmtleSk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdFdmVudCAmJiBleGlzdGluZ0V2ZW50LmNyZWF0ZWRfYXQgPiBldmVudC5jcmVhdGVkX2F0KSByZXR1cm47XG4gICAgICAgICAgICBjb250YWN0TGlzdEV2ZW50cy5zZXQoZXZlbnQucHVia2V5LCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkVvc2U6ICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHJlbGF5TGlzdEV2ZW50cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcmVsYXlMaXN0cy5zZXQoZXZlbnQucHVia2V5LCBOREtSZWxheUxpc3QuZnJvbShldmVudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IHB1YmtleSBvZiBwdWJrZXlzKSB7XG4gICAgICAgICAgICBpZiAocmVsYXlMaXN0cy5oYXMocHVia2V5KSkgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBjb250YWN0TGlzdCA9IGNvbnRhY3RMaXN0RXZlbnRzLmdldChwdWJrZXkpO1xuICAgICAgICAgICAgaWYgKCFjb250YWN0TGlzdCkgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBsaXN0ID0gcmVsYXlMaXN0RnJvbUtpbmQzKG5kaywgY29udGFjdExpc3QpO1xuICAgICAgICAgICAgaWYgKGxpc3QpIHJlbGF5TGlzdHMuc2V0KHB1YmtleSwgbGlzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVsYXlMaXN0cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlc29sdmUocmVsYXlMaXN0cyk7XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICB9O1xuICAgIGhhbmRsZVN1YnNjcmlwdGlvbigpO1xuICB9KTtcbn1cblxuLy8gc3JjL291dGJveC90cmFja2VyLnRzXG52YXIgT3V0Ym94SXRlbSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFR5cGUgb2YgaXRlbVxuICAgKi9cbiAgdHlwZTtcbiAgLyoqXG4gICAqIFRoZSByZWxheSBVUkxzIHRoYXQgYXJlIG9mIGludGVyZXN0IHRvIHRoaXMgaXRlbVxuICAgKi9cbiAgcmVsYXlVcmxTY29yZXM7XG4gIHJlYWRSZWxheXM7XG4gIHdyaXRlUmVsYXlzO1xuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnJlbGF5VXJsU2NvcmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnJlYWRSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMud3JpdGVSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG59O1xudmFyIE91dGJveFRyYWNrZXIgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjcge1xuICBkYXRhO1xuICBuZGs7XG4gIGRlYnVnO1xuICBjb25zdHJ1Y3RvcihuZGspIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMuZGVidWcgPSBuZGsuZGVidWcuZXh0ZW5kKFwib3V0Ym94LXRyYWNrZXJcIik7XG4gICAgdGhpcy5kYXRhID0gbmV3IExSVUNhY2hlMih7XG4gICAgICBtYXhTaXplOiAxZTUsXG4gICAgICBlbnRyeUV4cGlyYXRpb25UaW1lSW5NUzogMiAqIDYwICogMWUzXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBsaXN0IG9mIHVzZXJzIHRvIHRoZSB0cmFja2VyLlxuICAgKiBAcGFyYW0gaXRlbXNcbiAgICogQHBhcmFtIHNraXBDYWNoZVxuICAgKi9cbiAgYXN5bmMgdHJhY2tVc2VycyhpdGVtcywgc2tpcENhY2hlID0gZmFsc2UpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDQwMCkge1xuICAgICAgY29uc3Qgc2xpY2UgPSBpdGVtcy5zbGljZShpLCBpICsgNDAwKTtcbiAgICAgIGNvbnN0IHB1YmtleXMgPSBzbGljZS5tYXAoKGl0ZW0pID0+IGdldEtleUZyb21JdGVtKGl0ZW0pKS5maWx0ZXIoKHB1YmtleSkgPT4gIXRoaXMuZGF0YS5oYXMocHVia2V5KSk7XG4gICAgICBpZiAocHVia2V5cy5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuICAgICAgZm9yIChjb25zdCBwdWJrZXkgb2YgcHVia2V5cykge1xuICAgICAgICB0aGlzLmRhdGEuc2V0KHB1YmtleSwgbmV3IE91dGJveEl0ZW0oXCJ1c2VyXCIpKTtcbiAgICAgIH1cbiAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgZ2V0UmVsYXlMaXN0Rm9yVXNlcnMocHVia2V5cywgdGhpcy5uZGssIHNraXBDYWNoZSkudGhlbigocmVsYXlMaXN0cykgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbcHVia2V5LCByZWxheUxpc3RdIG9mIHJlbGF5TGlzdHMpIHtcbiAgICAgICAgICAgICAgbGV0IG91dGJveEl0ZW0gPSB0aGlzLmRhdGEuZ2V0KHB1YmtleSk7XG4gICAgICAgICAgICAgIG91dGJveEl0ZW0gPz89IG5ldyBPdXRib3hJdGVtKFwidXNlclwiKTtcbiAgICAgICAgICAgICAgaWYgKHJlbGF5TGlzdCkge1xuICAgICAgICAgICAgICAgIG91dGJveEl0ZW0ucmVhZFJlbGF5cyA9IG5ldyBTZXQobm9ybWFsaXplKHJlbGF5TGlzdC5yZWFkUmVsYXlVcmxzKSk7XG4gICAgICAgICAgICAgICAgb3V0Ym94SXRlbS53cml0ZVJlbGF5cyA9IG5ldyBTZXQobm9ybWFsaXplKHJlbGF5TGlzdC53cml0ZVJlbGF5VXJscykpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2Ygb3V0Ym94SXRlbS5yZWFkUmVsYXlzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZGsucG9vbC5ibGFja2xpc3RSZWxheVVybHMuaGFzKHJlbGF5VXJsKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRib3hJdGVtLnJlYWRSZWxheXMuZGVsZXRlKHJlbGF5VXJsKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZWxheVVybCBvZiBvdXRib3hJdGVtLndyaXRlUmVsYXlzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZGsucG9vbC5ibGFja2xpc3RSZWxheVVybHMuaGFzKHJlbGF5VXJsKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRib3hJdGVtLndyaXRlUmVsYXlzLmRlbGV0ZShyZWxheVVybCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zZXQocHVia2V5LCBvdXRib3hJdGVtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLmZpbmFsbHkocmVzb2x2ZSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ga2V5XG4gICAqIEBwYXJhbSBzY29yZVxuICAgKi9cbiAgdHJhY2soaXRlbSwgdHlwZSwgX3NraXBDYWNoZSA9IHRydWUpIHtcbiAgICBjb25zdCBrZXkgPSBnZXRLZXlGcm9tSXRlbShpdGVtKTtcbiAgICB0eXBlID8/PSBnZXRUeXBlRnJvbUl0ZW0oaXRlbSk7XG4gICAgbGV0IG91dGJveEl0ZW0gPSB0aGlzLmRhdGEuZ2V0KGtleSk7XG4gICAgaWYgKCFvdXRib3hJdGVtKSB7XG4gICAgICBvdXRib3hJdGVtID0gbmV3IE91dGJveEl0ZW0odHlwZSk7XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES1VzZXIpIHtcbiAgICAgICAgdGhpcy50cmFja1VzZXJzKFtpdGVtXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRib3hJdGVtO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0S2V5RnJvbUl0ZW0oaXRlbSkge1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES1VzZXIpIHtcbiAgICByZXR1cm4gaXRlbS5wdWJrZXk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5mdW5jdGlvbiBnZXRUeXBlRnJvbUl0ZW0oaXRlbSkge1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES1VzZXIpIHtcbiAgICByZXR1cm4gXCJ1c2VyXCI7XG4gIH1cbiAgcmV0dXJuIFwia2luZFwiO1xufVxuXG4vLyBzcmMvcmVsYXkvc2V0cy91dGlscy50c1xuZnVuY3Rpb24gY29ycmVjdFJlbGF5U2V0KHJlbGF5U2V0LCBwb29sKSB7XG4gIGNvbnN0IGNvbm5lY3RlZFJlbGF5cyA9IHBvb2wuY29ubmVjdGVkUmVsYXlzKCk7XG4gIGNvbnN0IGluY2x1ZGVzQ29ubmVjdGVkUmVsYXkgPSBBcnJheS5mcm9tKHJlbGF5U2V0LnJlbGF5cykuc29tZSgocmVsYXkpID0+IHtcbiAgICByZXR1cm4gY29ubmVjdGVkUmVsYXlzLm1hcCgocikgPT4gci51cmwpLmluY2x1ZGVzKHJlbGF5LnVybCk7XG4gIH0pO1xuICBpZiAoIWluY2x1ZGVzQ29ubmVjdGVkUmVsYXkpIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIGNvbm5lY3RlZFJlbGF5cykge1xuICAgICAgcmVsYXlTZXQuYWRkUmVsYXkocmVsYXkpO1xuICAgIH1cbiAgfVxuICBpZiAoY29ubmVjdGVkUmVsYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoY29uc3QgcmVsYXkgb2YgcG9vbC5yZWxheXMudmFsdWVzKCkpIHtcbiAgICAgIHJlbGF5U2V0LmFkZFJlbGF5KHJlbGF5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbGF5U2V0O1xufVxuXG4vLyBzcmMvc3Vic2NyaXB0aW9uL21hbmFnZXIudHNcbmltcG9ydCB7IG1hdGNoRmlsdGVycyB9IGZyb20gXCJub3N0ci10b29sc1wiO1xudmFyIE5ES1N1YnNjcmlwdGlvbk1hbmFnZXIgPSBjbGFzcyB7XG4gIHN1YnNjcmlwdGlvbnM7XG4gIHNlZW5FdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGFkZChzdWIpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuc2V0KHN1Yi5pbnRlcm5hbElkLCBzdWIpO1xuICAgIGlmIChzdWIub25TdG9wcGVkKSB7XG4gICAgfVxuICAgIHN1Yi5vblN0b3BwZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1Yi5pbnRlcm5hbElkKTtcbiAgICB9O1xuICAgIHN1Yi5vbihcImNsb3NlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kZWxldGUoc3ViLmludGVybmFsSWQpO1xuICAgIH0pO1xuICB9XG4gIHNlZW5FdmVudChldmVudElkLCByZWxheSkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnNlZW5FdmVudHMuZ2V0KGV2ZW50SWQpIHx8IFtdO1xuICAgIGN1cnJlbnQucHVzaChyZWxheSk7XG4gICAgdGhpcy5zZWVuRXZlbnRzLnNldChldmVudElkLCBjdXJyZW50KTtcbiAgfVxuICAvKipcbiAgICogV2hlbmV2ZXIgYW4gZXZlbnQgY29tZXMgaW4sIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKiBUaGlzIGZ1bmN0aW9uIG1hdGNoZXMgdGhlIHJlY2VpdmVkIGV2ZW50IGFnYWluc3QgYWxsIHRoZVxuICAgKiBrbm93biAoaS5lLiBhY3RpdmUpIE5ES1N1YnNjcmlwdGlvbnMsIGFuZCBpZiBpdCBtYXRjaGVzLFxuICAgKiBpdCBzZW5kcyB0aGUgZXZlbnQgdG8gdGhlIHN1YnNjcmlwdGlvbi5cbiAgICpcbiAgICogVGhpcyBpcyB0aGUgc2luZ2xlIHBsYWNlIGluIHRoZSBjb2RlYmFzZSB0aGF0IG1hdGNoZXNcbiAgICogaW5jb21pbmcgZXZlbnRzIHdpdGggcGFydGllcyBpbnRlcmVzdGVkIGluIHRoZSBldmVudC5cbiAgICpcbiAgICogVGhpcyBpcyBhbHNvIHdoYXQgYWxsb3dzIGZvciByZWFjdGl2aXR5IGluIE5ESyBhcHBzLCBzdWNoIHRoYXRcbiAgICogd2hlbmV2ZXIgYW4gYWN0aXZlIHN1YnNjcmlwdGlvbiByZWNlaXZlcyBhbiBldmVudCB0aGF0IHNvbWVcbiAgICogb3RoZXIgYWN0aXZlIHN1YnNjcmlwdGlvbiB3b3VsZCB3YW50IHRvIHJlY2VpdmUsIGJvdGggcmVjZWl2ZSBpdC5cbiAgICpcbiAgICogVE9ETyBUaGlzIGFsc28gYWxsb3dzIGZvciBzdWJzY3JpcHRpb25zIHRoYXQgb3ZlcmxhcCBpbiBtZWFuaW5nXG4gICAqIHRvIGJlIGNvbGxhcHNlZCBpbnRvIG9uZS5cbiAgICpcbiAgICogSS5lLiBpZiBhIHN1YnNjcmlwdGlvbiB3aXRoIGZpbHRlcjoga2luZHM6IFsxXSwgYXV0aG9yczogW2FsaWNlXVxuICAgKiBpcyBjcmVhdGVkIGFuZCBFT1NFcywgYW5kIHRoZW4gYSBzdWJzZXF1ZW50IHN1YnNjcmlwdGlvbiB3aXRoXG4gICAqIGtpbmRzOiBbMV0sIGF1dGhvcnM6IFthbGljZV0gaXMgY3JlYXRlZCwgb25jZSB0aGUgc2Vjb25kIHN1YnNjcmlwdGlvblxuICAgKiBFT1NFcyB3ZSBjYW4gc2FmZWx5IGNsb3NlIGl0LCBpbmNyZW1lbnQgaXRzIHJlZkNvdW50IGFuZCBjbG9zZSBpdCxcbiAgICogYW5kIHdoZW4gdGhlIGZpcnN0IHN1YnNjcmlwdGlvbiByZWNlaXZlcyBhIG5ldyBldmVudCBmcm9tIEFsaWNlIHRoaXNcbiAgICogY29kZSB3aWxsIG1ha2UgdGhlIHNlY29uZCBzdWJzY3JpcHRpb24gcmVjZWl2ZSB0aGUgZXZlbnQgZXZlbiB0aG91Z2hcbiAgICogaXQgaGFzIG5vIGFjdGl2ZSBzdWJzY3JpcHRpb24gb24gYSByZWxheS5cbiAgICogQHBhcmFtIGV2ZW50IFJhdyBldmVudCByZWNlaXZlZCBmcm9tIGEgcmVsYXlcbiAgICogQHBhcmFtIHJlbGF5IFJlbGF5IHRoYXQgc2VudCB0aGUgZXZlbnRcbiAgICogQHBhcmFtIG9wdGltaXN0aWNQdWJsaXNoIFdoZXRoZXIgdGhlIGV2ZW50IGlzIGNvbWluZyBmcm9tIGFuIG9wdGltaXN0aWMgcHVibGlzaFxuICAgKi9cbiAgZGlzcGF0Y2hFdmVudChldmVudCwgcmVsYXksIG9wdGltaXN0aWNQdWJsaXNoID0gZmFsc2UpIHtcbiAgICBpZiAocmVsYXkpIHRoaXMuc2VlbkV2ZW50KGV2ZW50LmlkLCByZWxheSk7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucy52YWx1ZXMoKTtcbiAgICBjb25zdCBtYXRjaGluZ1N1YnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHN1YiBvZiBzdWJzY3JpcHRpb25zKSB7XG4gICAgICBpZiAobWF0Y2hGaWx0ZXJzKHN1Yi5maWx0ZXJzLCBldmVudCkpIHtcbiAgICAgICAgbWF0Y2hpbmdTdWJzLnB1c2goc3ViKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBzdWIgb2YgbWF0Y2hpbmdTdWJzKSB7XG4gICAgICBzdWIuZXZlbnRSZWNlaXZlZChldmVudCwgcmVsYXksIGZhbHNlLCBvcHRpbWlzdGljUHVibGlzaCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvbmRrL2FjdGl2ZS11c2VyLnRzXG5pbXBvcnQgY3JlYXRlRGVidWczIGZyb20gXCJkZWJ1Z1wiO1xudmFyIGRlYnVnNyA9IGNyZWF0ZURlYnVnMyhcIm5kazphY3RpdmUtdXNlclwiKTtcbmFzeW5jIGZ1bmN0aW9uIGdldFVzZXJSZWxheUxpc3QodXNlcikge1xuICBpZiAoIXRoaXMuYXV0b0Nvbm5lY3RVc2VyUmVsYXlzKSByZXR1cm47XG4gIGNvbnN0IHVzZXJSZWxheXMgPSBhd2FpdCBnZXRSZWxheUxpc3RGb3JVc2VyKHVzZXIucHVia2V5LCB0aGlzKTtcbiAgaWYgKCF1c2VyUmVsYXlzKSByZXR1cm47XG4gIGZvciAoY29uc3QgdXJsIG9mIHVzZXJSZWxheXMucmVsYXlzKSB7XG4gICAgbGV0IHJlbGF5ID0gdGhpcy5wb29sLnJlbGF5cy5nZXQodXJsKTtcbiAgICBpZiAoIXJlbGF5KSB7XG4gICAgICByZWxheSA9IG5ldyBOREtSZWxheSh1cmwsIHRoaXMucmVsYXlBdXRoRGVmYXVsdFBvbGljeSwgdGhpcyk7XG4gICAgICB0aGlzLnBvb2wuYWRkUmVsYXkocmVsYXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdXNlclJlbGF5cztcbn1cbmFzeW5jIGZ1bmN0aW9uIHNldEFjdGl2ZVVzZXIodXNlcikge1xuICBjb25zdCBwb29sID0gdGhpcy5vdXRib3hQb29sIHx8IHRoaXMucG9vbDtcbiAgaWYgKHBvb2wuY29ubmVjdGVkUmVsYXlzLmxlbmd0aCA+IDApIHtcbiAgICBzZXRBY3RpdmVVc2VyQ29ubmVjdGVkLmNhbGwodGhpcywgdXNlcik7XG4gIH0gZWxzZSB7XG4gICAgcG9vbC5vbmNlKFwiY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICBzZXRBY3RpdmVVc2VyQ29ubmVjdGVkLmNhbGwodGhpcywgdXNlcik7XG4gICAgfSk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNldEFjdGl2ZVVzZXJDb25uZWN0ZWQodXNlcikge1xuICBjb25zdCB1c2VyUmVsYXlzID0gYXdhaXQgZ2V0VXNlclJlbGF5TGlzdC5jYWxsKHRoaXMsIHVzZXIpO1xuICBjb25zdCBmaWx0ZXJzID0gW1xuICAgIHtcbiAgICAgIGtpbmRzOiBbMTAwMDYgLyogQmxvY2tSZWxheUxpc3QgKi9dLFxuICAgICAgYXV0aG9yczogW3VzZXIucHVia2V5XVxuICAgIH1cbiAgXTtcbiAgaWYgKHRoaXMuYXV0b0ZldGNoVXNlck11dGVsaXN0KSB7XG4gICAgZmlsdGVyc1swXS5raW5kcz8ucHVzaCgxZTQgLyogTXV0ZUxpc3QgKi8pO1xuICB9XG4gIGNvbnN0IGV2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHJlbGF5U2V0ID0gdXNlclJlbGF5cyA/IHVzZXJSZWxheXMucmVsYXlTZXQgOiB2b2lkIDA7XG4gIHRoaXMuc3Vic2NyaWJlKFxuICAgIGZpbHRlcnMsXG4gICAgeyBzdWJJZDogXCJhY3RpdmUtdXNlci1zZXR0aW5nc1wiLCBjbG9zZU9uRW9zZTogdHJ1ZSwgcmVsYXlTZXQgfSxcbiAgICB7XG4gICAgICBvbkV2ZW50OiAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgcHJldkV2ZW50ID0gZXZlbnRzLmdldChldmVudC5raW5kKTtcbiAgICAgICAgaWYgKHByZXZFdmVudCAmJiBwcmV2RXZlbnQuY3JlYXRlZF9hdCA+PSBldmVudC5jcmVhdGVkX2F0KSByZXR1cm47XG4gICAgICAgIGV2ZW50cy5zZXQoZXZlbnQua2luZCwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIG9uRW9zZTogKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cy52YWx1ZXMoKSkge1xuICAgICAgICAgIHByb2Nlc3NFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NFdmVudChldmVudCkge1xuICBpZiAoZXZlbnQua2luZCA9PT0gMTAwMDYgLyogQmxvY2tSZWxheUxpc3QgKi8pIHtcbiAgICBwcm9jZXNzQmxvY2tSZWxheUxpc3QuY2FsbCh0aGlzLCBldmVudCk7XG4gIH0gZWxzZSBpZiAoZXZlbnQua2luZCA9PT0gMWU0IC8qIE11dGVMaXN0ICovKSB7XG4gICAgcHJvY2Vzc011dGVMaXN0LmNhbGwodGhpcywgZXZlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzQmxvY2tSZWxheUxpc3QoZXZlbnQpIHtcbiAgY29uc3QgbGlzdCA9IGxpc3RzX2RlZmF1bHQuZnJvbShldmVudCk7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBsaXN0Lml0ZW1zKSB7XG4gICAgdGhpcy5wb29sLmJsYWNrbGlzdFJlbGF5VXJscy5hZGQoaXRlbVswXSk7XG4gIH1cbiAgZGVidWc3KFwiQWRkZWQgJWQgcmVsYXlzIHRvIHJlbGF5IGJsYWNrbGlzdFwiLCBsaXN0Lml0ZW1zLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBwcm9jZXNzTXV0ZUxpc3QobXV0ZUxpc3QpIHtcbiAgY29uc3QgbGlzdCA9IGxpc3RzX2RlZmF1bHQuZnJvbShtdXRlTGlzdCk7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBsaXN0Lml0ZW1zKSB7XG4gICAgdGhpcy5tdXRlZElkcy5zZXQoaXRlbVsxXSwgaXRlbVswXSk7XG4gIH1cbiAgZGVidWc3KFwiQWRkZWQgJWQgdXNlcnMgdG8gbXV0ZSBsaXN0XCIsIGxpc3QuaXRlbXMubGVuZ3RoKTtcbn1cblxuLy8gc3JjL25kay9lbnRpdHkudHNcbmltcG9ydCB7IG5pcDE5IGFzIG5pcDE5NyB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuZnVuY3Rpb24gZ2V0RW50aXR5KGVudGl0eSkge1xuICB0cnkge1xuICAgIGNvbnN0IGRlY29kZWQgPSBuaXAxOTcuZGVjb2RlKGVudGl0eSk7XG4gICAgaWYgKGRlY29kZWQudHlwZSA9PT0gXCJucHViXCIpIHJldHVybiBucHViKHRoaXMsIGRlY29kZWQuZGF0YSk7XG4gICAgaWYgKGRlY29kZWQudHlwZSA9PT0gXCJucHJvZmlsZVwiKSByZXR1cm4gbnByb2ZpbGUodGhpcywgZGVjb2RlZC5kYXRhKTtcbiAgICByZXR1cm4gZGVjb2RlZDtcbiAgfSBjYXRjaCAoX2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gbnB1YihuZGssIHB1YmtleSkge1xuICByZXR1cm4gbmRrLmdldFVzZXIoeyBwdWJrZXkgfSk7XG59XG5mdW5jdGlvbiBucHJvZmlsZShuZGssIHByb2ZpbGUpIHtcbiAgY29uc3QgdXNlciA9IG5kay5nZXRVc2VyKHsgcHVia2V5OiBwcm9maWxlLnB1YmtleSB9KTtcbiAgaWYgKHByb2ZpbGUucmVsYXlzKSB1c2VyLnJlbGF5VXJscyA9IHByb2ZpbGUucmVsYXlzO1xuICByZXR1cm4gdXNlcjtcbn1cblxuLy8gc3JjL25kay9mZXRjaC1ldmVudC1mcm9tLXRhZy50c1xuZnVuY3Rpb24gaXNWYWxpZEhpbnQoaGludCkge1xuICBpZiAoIWhpbnQgfHwgaGludCA9PT0gXCJcIikgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIG5ldyBVUkwoaGludCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKF9lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaEV2ZW50RnJvbVRhZyh0YWcsIG9yaWdpbmFsRXZlbnQsIHN1Yk9wdHMsIGZhbGxiYWNrID0ge1xuICB0eXBlOiBcInRpbWVvdXRcIlxufSkge1xuICBjb25zdCBkNCA9IHRoaXMuZGVidWcuZXh0ZW5kKFwiZmV0Y2gtZXZlbnQtZnJvbS10YWdcIik7XG4gIGNvbnN0IFtfLCBpZCwgaGludF0gPSB0YWc7XG4gIHN1Yk9wdHMgPSB7fTtcbiAgZDQoXCJmZXRjaGluZyBldmVudCBmcm9tIHRhZ1wiLCB0YWcsIHN1Yk9wdHMsIGZhbGxiYWNrKTtcbiAgY29uc3QgYXV0aG9yUmVsYXlzID0gZ2V0UmVsYXlzRm9yU3luYyh0aGlzLCBvcmlnaW5hbEV2ZW50LnB1YmtleSk7XG4gIGlmIChhdXRob3JSZWxheXMgJiYgYXV0aG9yUmVsYXlzLnNpemUgPiAwKSB7XG4gICAgZDQoXCJmZXRjaGluZyBldmVudCBmcm9tIGF1dGhvciByZWxheXMgJW9cIiwgQXJyYXkuZnJvbShhdXRob3JSZWxheXMpKTtcbiAgICBjb25zdCByZWxheVNldDIgPSBOREtSZWxheVNldC5mcm9tUmVsYXlVcmxzKEFycmF5LmZyb20oYXV0aG9yUmVsYXlzKSwgdGhpcyk7XG4gICAgY29uc3QgZXZlbnQyID0gYXdhaXQgdGhpcy5mZXRjaEV2ZW50KGlkLCBzdWJPcHRzLCByZWxheVNldDIpO1xuICAgIGlmIChldmVudDIpIHJldHVybiBldmVudDI7XG4gIH0gZWxzZSB7XG4gICAgZDQoXCJubyBhdXRob3IgcmVsYXlzIGZvdW5kIGZvciAlc1wiLCBvcmlnaW5hbEV2ZW50LnB1YmtleSwgb3JpZ2luYWxFdmVudCk7XG4gIH1cbiAgY29uc3QgcmVsYXlTZXQgPSBjYWxjdWxhdGVSZWxheVNldHNGcm9tRmlsdGVycyh0aGlzLCBbeyBpZHM6IFtpZF0gfV0sIHRoaXMucG9vbCk7XG4gIGQ0KFwiZmV0Y2hpbmcgZXZlbnQgd2l0aG91dCByZWxheSBoaW50XCIsIHJlbGF5U2V0KTtcbiAgY29uc3QgZXZlbnQgPSBhd2FpdCB0aGlzLmZldGNoRXZlbnQoaWQsIHN1Yk9wdHMpO1xuICBpZiAoZXZlbnQpIHJldHVybiBldmVudDtcbiAgaWYgKGhpbnQgJiYgaGludCAhPT0gXCJcIikge1xuICAgIGNvbnN0IGV2ZW50MiA9IGF3YWl0IHRoaXMuZmV0Y2hFdmVudChpZCwgc3ViT3B0cywgdGhpcy5wb29sLmdldFJlbGF5KGhpbnQsIHRydWUsIHRydWUsIFt7IGlkczogW2lkXSB9XSkpO1xuICAgIGlmIChldmVudDIpIHJldHVybiBldmVudDI7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IHZvaWQgMDtcbiAgY29uc3QgcmVsYXkgPSBpc1ZhbGlkSGludChoaW50KSA/IHRoaXMucG9vbC5nZXRSZWxheShoaW50LCBmYWxzZSwgdHJ1ZSwgW3sgaWRzOiBbaWRdIH1dKSA6IHZvaWQgMDtcbiAgY29uc3QgZmV0Y2hNYXliZVdpdGhSZWxheUhpbnQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHRoaXMuZmV0Y2hFdmVudChpZCwgc3ViT3B0cywgcmVsYXkpLnRoZW4ocmVzb2x2ZSk7XG4gIH0pO1xuICBpZiAoIWlzVmFsaWRIaW50KGhpbnQpIHx8IGZhbGxiYWNrLnR5cGUgPT09IFwibm9uZVwiKSB7XG4gICAgcmV0dXJuIGZldGNoTWF5YmVXaXRoUmVsYXlIaW50O1xuICB9XG4gIGNvbnN0IGZhbGxiYWNrRmV0Y2hQcm9taXNlID0gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBmYWxsYmFja1JlbGF5U2V0ID0gZmFsbGJhY2sucmVsYXlTZXQ7XG4gICAgY29uc3QgdGltZW91dCA9IGZhbGxiYWNrLnRpbWVvdXQgPz8gMTUwMDtcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlMikgPT4gc2V0VGltZW91dChyZXNvbHZlMiwgdGltZW91dCkpO1xuICAgIGlmIChmYWxsYmFjay50eXBlID09PSBcInRpbWVvdXRcIikgYXdhaXQgdGltZW91dFByb21pc2U7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkNChcImZhbGxiYWNrIGZldGNoIHRyaWdnZXJlZFwiKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrRXZlbnQgPSBhd2FpdCB0aGlzLmZldGNoRXZlbnQoaWQsIHN1Yk9wdHMsIGZhbGxiYWNrUmVsYXlTZXQpO1xuICAgICAgcmVzb2x2ZShmYWxsYmFja0V2ZW50KTtcbiAgICB9XG4gIH0pO1xuICBzd2l0Y2ggKGZhbGxiYWNrLnR5cGUpIHtcbiAgICBjYXNlIFwidGltZW91dFwiOlxuICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbZmV0Y2hNYXliZVdpdGhSZWxheUhpbnQsIGZhbGxiYWNrRmV0Y2hQcm9taXNlXSk7XG4gICAgY2FzZSBcImVvc2VcIjpcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGZldGNoTWF5YmVXaXRoUmVsYXlIaW50O1xuICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHJldHVybiBmYWxsYmFja0ZldGNoUHJvbWlzZTtcbiAgfVxufVxuXG4vLyBzcmMvbmRrL3F1ZXVlL2luZGV4LnRzXG52YXIgUXVldWUgPSBjbGFzcyB7XG4gIHF1ZXVlID0gW107XG4gIG1heENvbmN1cnJlbmN5O1xuICBwcm9jZXNzaW5nID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcHJvbWlzZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3RvcihfbmFtZSwgbWF4Q29uY3VycmVuY3kpIHtcbiAgICB0aGlzLm1heENvbmN1cnJlbmN5ID0gbWF4Q29uY3VycmVuY3k7XG4gIH1cbiAgYWRkKGl0ZW0pIHtcbiAgICBpZiAodGhpcy5wcm9taXNlcy5oYXMoaXRlbS5pZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb21pc2VzLmdldChpdGVtLmlkKTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucXVldWUucHVzaCh7XG4gICAgICAgIC4uLml0ZW0sXG4gICAgICAgIGZ1bmM6ICgpID0+IGl0ZW0uZnVuYygpLnRoZW4oXG4gICAgICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgICB0aGlzLnByb2Nlc3MoKTtcbiAgICB9KTtcbiAgICB0aGlzLnByb21pc2VzLnNldChpdGVtLmlkLCBwcm9taXNlKTtcbiAgICBwcm9taXNlLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdGhpcy5wcm9taXNlcy5kZWxldGUoaXRlbS5pZCk7XG4gICAgICB0aGlzLnByb2Nlc3NpbmcuZGVsZXRlKGl0ZW0uaWQpO1xuICAgICAgdGhpcy5wcm9jZXNzKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgcHJvY2VzcygpIHtcbiAgICBpZiAodGhpcy5wcm9jZXNzaW5nLnNpemUgPj0gdGhpcy5tYXhDb25jdXJyZW5jeSB8fCB0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgIGlmICghaXRlbSB8fCB0aGlzLnByb2Nlc3NpbmcuaGFzKGl0ZW0uaWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucHJvY2Vzc2luZy5hZGQoaXRlbS5pZCk7XG4gICAgaXRlbS5mdW5jKCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICB9XG4gIGNsZWFyUHJvY2Vzc2luZygpIHtcbiAgICB0aGlzLnByb2Nlc3NpbmcuY2xlYXIoKTtcbiAgfVxuICBjbGVhckFsbCgpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5jbGVhclByb2Nlc3NpbmcoKTtcbiAgfVxuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWUubGVuZ3RoO1xuICB9XG59O1xuXG4vLyBzcmMvbmRrL2luZGV4LnRzXG52YXIgREVGQVVMVF9PVVRCT1hfUkVMQVlTID0gW1wid3NzOi8vcHVycGxlcGFnLmVzL1wiLCBcIndzczovL25vcy5sb2wvXCJdO1xudmFyIERFRkFVTFRfQkxBQ0tMSVNURURfUkVMQVlTID0gW1xuICBcIndzczovL2JyYi5pby9cIixcbiAgLy8gQlJCXG4gIFwid3NzOi8vbm9zdHIubXV0aW55d2FsbGV0LmNvbS9cIlxuICAvLyBEb24ndCB0cnkgdG8gcmVhZCBmcm9tIHRoaXMgcmVsYXkgc2luY2UgaXQncyBhIHdyaXRlLW9ubHkgcmVsYXlcbiAgLy8gXCJ3c3M6Ly9wdXJwbGVwYWcuZXMvXCIsIC8vIFRoaXMgaXMgYSBoYWNrLCBzaW5jZSB0aGlzIGlzIGEgbW9zdGx5IHJlYWQtb25seSByZWxheSwgYnV0IG5vdCBmdWxseS4gT25jZSB3ZSBoYXZlIHJlbGF5IHJvdXRpbmcgdGhpcyBjYW4gYmUgcmVtb3ZlZCBzbyBpdCBvbmx5IHJlY2VpdmVzIHRoZSBzdXBwb3J0ZWQga2luZHNcbl07XG52YXIgTkRLID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXI4IHtcbiAgX2V4cGxpY2l0UmVsYXlVcmxzO1xuICBibGFja2xpc3RSZWxheVVybHM7XG4gIHBvb2w7XG4gIG91dGJveFBvb2w7XG4gIF9zaWduZXI7XG4gIF9hY3RpdmVVc2VyO1xuICBjYWNoZUFkYXB0ZXI7XG4gIGRlYnVnO1xuICBkZXZXcml0ZVJlbGF5U2V0O1xuICBvdXRib3hUcmFja2VyO1xuICBtdXRlZElkcztcbiAgY2xpZW50TmFtZTtcbiAgY2xpZW50TmlwODk7XG4gIHF1ZXVlc1phcENvbmZpZztcbiAgcXVldWVzTmlwMDU7XG4gIGFzeW5jU2lnVmVyaWZpY2F0aW9uID0gZmFsc2U7XG4gIGluaXRpYWxWYWxpZGF0aW9uUmF0aW8gPSAxO1xuICBsb3dlc3RWYWxpZGF0aW9uUmF0aW8gPSAwLjE7XG4gIHZhbGlkYXRpb25SYXRpb0ZuO1xuICBhdXRvQmxhY2tsaXN0SW52YWxpZFJlbGF5cyA9IGZhbHNlO1xuICBzdWJNYW5hZ2VyO1xuICAvKipcbiAgICogUHJpdmF0ZSBzdG9yYWdlIGZvciB0aGUgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmdW5jdGlvblxuICAgKi9cbiAgX3NpZ25hdHVyZVZlcmlmaWNhdGlvbkZ1bmN0aW9uO1xuICAvKipcbiAgICogUHJpdmF0ZSBzdG9yYWdlIGZvciB0aGUgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiB3b3JrZXJcbiAgICovXG4gIF9zaWduYXR1cmVWZXJpZmljYXRpb25Xb3JrZXI7XG4gIC8qKlxuICAgKiBSb2xsaW5nIHRvdGFsIG9mIHRpbWUgc3BlbnQgKGluIG1zKSBwZXJmb3JtaW5nIHNpZ25hdHVyZSB2ZXJpZmljYXRpb25zLlxuICAgKiBVc2VycyBjYW4gcmVhZCB0aGlzIHRvIG1vbml0b3Igb3IgZGlzcGxheSBhZ2dyZWdhdGUgdmVyaWZpY2F0aW9uIGNvc3QuXG4gICAqL1xuICBzaWduYXR1cmVWZXJpZmljYXRpb25UaW1lTXMgPSAwO1xuICBwdWJsaXNoaW5nRmFpbHVyZUhhbmRsZWQgPSBmYWxzZTtcbiAgcG9vbHMgPSBbXTtcbiAgLyoqXG4gICAqIERlZmF1bHQgcmVsYXktYXV0aCBwb2xpY3kgdGhhdCB3aWxsIGJlIHVzZWQgd2hlbiBhIHJlbGF5IHJlcXVlc3RzIGF1dGhlbnRpY2F0aW9uLFxuICAgKiBpZiBubyBvdGhlciBwb2xpY3kgaXMgc3BlY2lmaWVkIGZvciB0aGF0IHJlbGF5LlxuICAgKlxuICAgKiBAZXhhbXBsZSBEaXNjb25uZWN0IGZyb20gcmVsYXlzIHRoYXQgcmVxdWVzdCBhdXRoZW50aWNhdGlvbjpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBuZGsucmVsYXlBdXRoRGVmYXVsdFBvbGljeSA9IE5ES0F1dGhQb2xpY2llcy5kaXNjb25uZWN0KG5kay5wb29sKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlIFNpZ24gaW4gdG8gcmVsYXlzIHRoYXQgcmVxdWVzdCBhdXRoZW50aWNhdGlvbjpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBuZGsucmVsYXlBdXRoRGVmYXVsdFBvbGljeSA9IE5ES0F1dGhQb2xpY2llcy5zaWduSW4oe25ka30pXG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZSBTaWduIGluIHRvIHJlbGF5cyB0aGF0IHJlcXVlc3QgYXV0aGVudGljYXRpb24sIGFza2luZyB0aGUgdXNlciBmb3IgY29uZmlybWF0aW9uOlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIG5kay5yZWxheUF1dGhEZWZhdWx0UG9saWN5ID0gKHJlbGF5OiBOREtSZWxheSkgPT4ge1xuICAgKiAgICAgY29uc3Qgc2lnbkluID0gTkRLQXV0aFBvbGljaWVzLnNpZ25Jbih7bmRrfSk7XG4gICAqICAgICBpZiAoY29uZmlybShgUmVsYXkgJHtyZWxheS51cmx9IGlzIHJlcXVlc3RpbmcgYXV0aGVudGljYXRpb24sIGRvIHlvdSB3YW50IHRvIHNpZ24gaW4/YCkpIHtcbiAgICogICAgICAgIHNpZ25JbihyZWxheSk7XG4gICAqICAgICB9XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICByZWxheUF1dGhEZWZhdWx0UG9saWN5O1xuICAvKipcbiAgICogRmV0Y2ggZnVuY3Rpb24gdG8gdXNlIGZvciBIVFRQIHJlcXVlc3RzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGltcG9ydCBmZXRjaCBmcm9tIFwibm9kZS1mZXRjaFwiO1xuICAgKlxuICAgKiBuZGsuaHR0cEZldGNoID0gZmV0Y2g7XG4gICAqIGBgYFxuICAgKi9cbiAgaHR0cEZldGNoO1xuICAvKipcbiAgICogUHJvdmlkZSBhIGNhbGxlciBmdW5jdGlvbiB0byByZWNlaXZlIGFsbCBuZXR3b3JraW5nIHRyYWZmaWMgZnJvbSByZWxheXNcbiAgICovXG4gIG5ldERlYnVnO1xuICBhdXRvQ29ubmVjdFVzZXJSZWxheXMgPSB0cnVlO1xuICBhdXRvRmV0Y2hVc2VyTXV0ZWxpc3QgPSB0cnVlO1xuICB3YWxsZXRDb25maWc7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kZWJ1ZyA9IG9wdHMuZGVidWcgfHwgZGVidWc4KFwibmRrXCIpO1xuICAgIHRoaXMubmV0RGVidWcgPSBvcHRzLm5ldERlYnVnO1xuICAgIHRoaXMuX2V4cGxpY2l0UmVsYXlVcmxzID0gb3B0cy5leHBsaWNpdFJlbGF5VXJscyB8fCBbXTtcbiAgICB0aGlzLmJsYWNrbGlzdFJlbGF5VXJscyA9IG9wdHMuYmxhY2tsaXN0UmVsYXlVcmxzIHx8IERFRkFVTFRfQkxBQ0tMSVNURURfUkVMQVlTO1xuICAgIHRoaXMuc3ViTWFuYWdlciA9IG5ldyBOREtTdWJzY3JpcHRpb25NYW5hZ2VyKCk7XG4gICAgdGhpcy5wb29sID0gbmV3IE5ES1Bvb2wob3B0cy5leHBsaWNpdFJlbGF5VXJscyB8fCBbXSwgW10sIHRoaXMpO1xuICAgIHRoaXMucG9vbC5uYW1lID0gXCJNYWluXCI7XG4gICAgdGhpcy5wb29sLm9uKFwicmVsYXk6YXV0aFwiLCBhc3luYyAocmVsYXksIGNoYWxsZW5nZSkgPT4ge1xuICAgICAgaWYgKHRoaXMucmVsYXlBdXRoRGVmYXVsdFBvbGljeSkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlbGF5QXV0aERlZmF1bHRQb2xpY3kocmVsYXksIGNoYWxsZW5nZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hdXRvQ29ubmVjdFVzZXJSZWxheXMgPSBvcHRzLmF1dG9Db25uZWN0VXNlclJlbGF5cyA/PyB0cnVlO1xuICAgIHRoaXMuYXV0b0ZldGNoVXNlck11dGVsaXN0ID0gb3B0cy5hdXRvRmV0Y2hVc2VyTXV0ZWxpc3QgPz8gdHJ1ZTtcbiAgICB0aGlzLmNsaWVudE5hbWUgPSBvcHRzLmNsaWVudE5hbWU7XG4gICAgdGhpcy5jbGllbnROaXA4OSA9IG9wdHMuY2xpZW50TmlwODk7XG4gICAgdGhpcy5yZWxheUF1dGhEZWZhdWx0UG9saWN5ID0gb3B0cy5yZWxheUF1dGhEZWZhdWx0UG9saWN5O1xuICAgIGlmIChvcHRzLmVuYWJsZU91dGJveE1vZGVsKSB7XG4gICAgICB0aGlzLm91dGJveFBvb2wgPSBuZXcgTkRLUG9vbChvcHRzLm91dGJveFJlbGF5VXJscyB8fCBERUZBVUxUX09VVEJPWF9SRUxBWVMsIFtdLCB0aGlzLCB7XG4gICAgICAgIGRlYnVnOiB0aGlzLmRlYnVnLmV4dGVuZChcIm91dGJveC1wb29sXCIpLFxuICAgICAgICBuYW1lOiBcIk91dGJveCBQb29sXCJcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vdXRib3hUcmFja2VyID0gbmV3IE91dGJveFRyYWNrZXIodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuc2lnbmVyID0gb3B0cy5zaWduZXI7XG4gICAgdGhpcy5jYWNoZUFkYXB0ZXIgPSBvcHRzLmNhY2hlQWRhcHRlcjtcbiAgICB0aGlzLm11dGVkSWRzID0gb3B0cy5tdXRlZElkcyB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGlmIChvcHRzLmRldldyaXRlUmVsYXlVcmxzKSB7XG4gICAgICB0aGlzLmRldldyaXRlUmVsYXlTZXQgPSBOREtSZWxheVNldC5mcm9tUmVsYXlVcmxzKG9wdHMuZGV2V3JpdGVSZWxheVVybHMsIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnF1ZXVlc1phcENvbmZpZyA9IG5ldyBRdWV1ZShcInphcHNcIiwgMyk7XG4gICAgdGhpcy5xdWV1ZXNOaXAwNSA9IG5ldyBRdWV1ZShcIm5pcDA1XCIsIDEwKTtcbiAgICBpZiAob3B0cy5zaWduYXR1cmVWZXJpZmljYXRpb25Xb3JrZXIpIHtcbiAgICAgIHRoaXMuc2lnbmF0dXJlVmVyaWZpY2F0aW9uV29ya2VyID0gb3B0cy5zaWduYXR1cmVWZXJpZmljYXRpb25Xb3JrZXI7XG4gICAgfVxuICAgIGlmIChvcHRzLnNpZ25hdHVyZVZlcmlmaWNhdGlvbkZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLnNpZ25hdHVyZVZlcmlmaWNhdGlvbkZ1bmN0aW9uID0gb3B0cy5zaWduYXR1cmVWZXJpZmljYXRpb25GdW5jdGlvbjtcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsVmFsaWRhdGlvblJhdGlvID0gb3B0cy5pbml0aWFsVmFsaWRhdGlvblJhdGlvIHx8IDE7XG4gICAgdGhpcy5sb3dlc3RWYWxpZGF0aW9uUmF0aW8gPSBvcHRzLmxvd2VzdFZhbGlkYXRpb25SYXRpbyB8fCAwLjE7XG4gICAgdGhpcy5hdXRvQmxhY2tsaXN0SW52YWxpZFJlbGF5cyA9IG9wdHMuYXV0b0JsYWNrbGlzdEludmFsaWRSZWxheXMgfHwgZmFsc2U7XG4gICAgdGhpcy52YWxpZGF0aW9uUmF0aW9GbiA9IG9wdHMudmFsaWRhdGlvblJhdGlvRm4gfHwgdGhpcy5kZWZhdWx0VmFsaWRhdGlvblJhdGlvRm47XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuaHR0cEZldGNoID0gZmV0Y2g7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIHNldCBleHBsaWNpdFJlbGF5VXJscyh1cmxzKSB7XG4gICAgdGhpcy5fZXhwbGljaXRSZWxheVVybHMgPSB1cmxzLm1hcChub3JtYWxpemVSZWxheVVybCk7XG4gICAgdGhpcy5wb29sLnJlbGF5VXJscyA9IHVybHM7XG4gIH1cbiAgZ2V0IGV4cGxpY2l0UmVsYXlVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLl9leHBsaWNpdFJlbGF5VXJscyB8fCBbXTtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgV2ViIFdvcmtlciBmb3Igc2lnbmF0dXJlIHZlcmlmaWNhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaW5pdGlhbGl6ZXMgdGhlIHdvcmtlciBhbmQgc2V0cyB0aGUgYXN5bmNTaWdWZXJpZmljYXRpb24gZmxhZy5cbiAgICogVGhlIGFjdHVhbCB2ZXJpZmljYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgdmVyaWZ5U2lnbmF0dXJlQXN5bmMgZnVuY3Rpb24gaW4gc2lnbmF0dXJlLnRzLFxuICAgKiB3aGljaCB3aWxsIHVzZSB0aGUgd29ya2VyIGlmIGF2YWlsYWJsZS5cbiAgICovXG4gIHNldCBzaWduYXR1cmVWZXJpZmljYXRpb25Xb3JrZXIod29ya2VyMikge1xuICAgIHRoaXMuX3NpZ25hdHVyZVZlcmlmaWNhdGlvbldvcmtlciA9IHdvcmtlcjI7XG4gICAgaWYgKHdvcmtlcjIpIHtcbiAgICAgIHNpZ25hdHVyZVZlcmlmaWNhdGlvbkluaXQod29ya2VyMik7XG4gICAgICB0aGlzLmFzeW5jU2lnVmVyaWZpY2F0aW9uID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3luY1NpZ1ZlcmlmaWNhdGlvbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0IGEgY3VzdG9tIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZnVuY3Rpb24uXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHBsYXRmb3JtcyB0aGF0IGRvbid0IHN1cHBvcnQgV2ViIFdvcmtlcnMsXG4gICAqIHN1Y2ggYXMgUmVhY3QgTmF0aXZlLlxuICAgKlxuICAgKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIGl0IHdpbGwgYmUgdXNlZCBmb3Igc2lnbmF0dXJlIHZlcmlmaWNhdGlvblxuICAgKiBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IHdvcmtlci1iYXNlZCB2ZXJpZmljYXRpb24uIFRoaXMgZW5hYmxlcyBzaWduYXR1cmVcbiAgICogdmVyaWZpY2F0aW9uIG9uIHBsYXRmb3JtcyB3aGVyZSBXZWIgV29ya2VycyBhcmUgbm90IGF2YWlsYWJsZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBpbXBvcnQgeyB2ZXJpZnlTaWduYXR1cmVBc3luYyB9IGZyb20gXCJAbm9zdHItZGV2LWtpdC9uZGstbW9iaWxlXCI7XG4gICAqXG4gICAqIG5kay5zaWduYXR1cmVWZXJpZmljYXRpb25GdW5jdGlvbiA9IHZlcmlmeVNpZ25hdHVyZUFzeW5jO1xuICAgKiBgYGBcbiAgICovXG4gIHNldCBzaWduYXR1cmVWZXJpZmljYXRpb25GdW5jdGlvbihmbikge1xuICAgIHRoaXMuX3NpZ25hdHVyZVZlcmlmaWNhdGlvbkZ1bmN0aW9uID0gZm47XG4gICAgdGhpcy5hc3luY1NpZ1ZlcmlmaWNhdGlvbiA9ICEhZm47XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VzdG9tIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZnVuY3Rpb25cbiAgICovXG4gIGdldCBzaWduYXR1cmVWZXJpZmljYXRpb25GdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lnbmF0dXJlVmVyaWZpY2F0aW9uRnVuY3Rpb247XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gZXhwbGljaXQgcmVsYXkgdG8gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSB1cmxcbiAgICogQHBhcmFtIHJlbGF5QXV0aFBvbGljeSBBdXRoZW50aWNhdGlvbiBwb2xpY3kgdG8gdXNlIGlmIGRpZmZlcmVudCBmcm9tIHRoZSBkZWZhdWx0XG4gICAqIEBwYXJhbSBjb25uZWN0IFdoZXRoZXIgdG8gY29ubmVjdCB0byB0aGUgcmVsYXkgYXV0b21hdGljYWxseVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYWRkRXhwbGljaXRSZWxheSh1cmxPclJlbGF5LCByZWxheUF1dGhQb2xpY3ksIGNvbm5lY3QgPSB0cnVlKSB7XG4gICAgbGV0IHJlbGF5O1xuICAgIGlmICh0eXBlb2YgdXJsT3JSZWxheSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVsYXkgPSBuZXcgTkRLUmVsYXkodXJsT3JSZWxheSwgcmVsYXlBdXRoUG9saWN5LCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVsYXkgPSB1cmxPclJlbGF5O1xuICAgIH1cbiAgICB0aGlzLnBvb2wuYWRkUmVsYXkocmVsYXksIGNvbm5lY3QpO1xuICAgIHRoaXMuZXhwbGljaXRSZWxheVVybHM/LnB1c2gocmVsYXkudXJsKTtcbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7IHJlbGF5Q291bnQ6IHRoaXMucG9vbC5yZWxheXMuc2l6ZSB9LnRvU3RyaW5nKCk7XG4gIH1cbiAgZ2V0IGFjdGl2ZVVzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVVzZXI7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFjdGl2ZSB1c2VyIGZvciB0aGlzIE5ESyBpbnN0YW5jZSwgdHlwaWNhbGx5IHRoaXMgd2lsbCBiZVxuICAgKiBjYWxsZWQgd2hlbiBhc3NpZ25pbmcgYSBzaWduZXIgdG8gdGhlIE5ESyBpbnN0YW5jZS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgY29ubmVjdCB0byB0aGUgdXNlcidzIHJlbGF5cyBpZlxuICAgKiBgYXV0b0Nvbm5lY3RVc2VyUmVsYXlzYCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICpcbiAgICogSXQgd2lsbCBhbHNvIGZldGNoIHRoZSB1c2VyJ3MgbXV0ZWxpc3QgaWYgYGF1dG9GZXRjaFVzZXJNdXRlbGlzdGAgaXMgc2V0IHRvIHRydWUuXG4gICAqL1xuICBzZXQgYWN0aXZlVXNlcih1c2VyKSB7XG4gICAgY29uc3QgZGlmZmVyZW50VXNlciA9IHRoaXMuX2FjdGl2ZVVzZXI/LnB1YmtleSAhPT0gdXNlcj8ucHVia2V5O1xuICAgIHRoaXMuX2FjdGl2ZVVzZXIgPSB1c2VyO1xuICAgIGlmICh1c2VyICYmIGRpZmZlcmVudFVzZXIpIHtcbiAgICAgIHNldEFjdGl2ZVVzZXIuY2FsbCh0aGlzLCB1c2VyKTtcbiAgICB9IGVsc2UgaWYgKCF1c2VyKSB7XG4gICAgICB0aGlzLm11dGVkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNpZ25lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lnbmVyO1xuICB9XG4gIHNldCBzaWduZXIobmV3U2lnbmVyKSB7XG4gICAgdGhpcy5fc2lnbmVyID0gbmV3U2lnbmVyO1xuICAgIGlmIChuZXdTaWduZXIpIHRoaXMuZW1pdChcInNpZ25lcjpyZWFkeVwiLCBuZXdTaWduZXIpO1xuICAgIG5ld1NpZ25lcj8udXNlcigpLnRoZW4oKHVzZXIpID0+IHtcbiAgICAgIHVzZXIubmRrID0gdGhpcztcbiAgICAgIHRoaXMuYWN0aXZlVXNlciA9IHVzZXI7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3QgdG8gcmVsYXlzIHdpdGggb3B0aW9uYWwgdGltZW91dC5cbiAgICogSWYgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZCwgdGhlIGNvbm5lY3Rpb24gd2lsbCBiZSBjb250aW51ZWQgdG8gYmUgZXN0YWJsaXNoZWQgaW4gdGhlIGJhY2tncm91bmQuXG4gICAqL1xuICBhc3luYyBjb25uZWN0KHRpbWVvdXRNcykge1xuICAgIGlmICh0aGlzLl9zaWduZXIgJiYgdGhpcy5hdXRvQ29ubmVjdFVzZXJSZWxheXMpIHtcbiAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgIFwiQXR0ZW1wdGluZyB0byBjb25uZWN0IHRvIHVzZXIgcmVsYXlzIHNwZWNpZmllZCBieSBzaWduZXIgJW9cIixcbiAgICAgICAgYXdhaXQgdGhpcy5fc2lnbmVyLnJlbGF5cz8uKHRoaXMpXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuX3NpZ25lci5yZWxheXMpIHtcbiAgICAgICAgY29uc3QgcmVsYXlzID0gYXdhaXQgdGhpcy5fc2lnbmVyLnJlbGF5cyh0aGlzKTtcbiAgICAgICAgcmVsYXlzLmZvckVhY2goKHJlbGF5KSA9PiB0aGlzLnBvb2wuYWRkUmVsYXkocmVsYXkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvbnMgPSBbdGhpcy5wb29sLmNvbm5lY3QodGltZW91dE1zKV07XG4gICAgaWYgKHRoaXMub3V0Ym94UG9vbCkge1xuICAgICAgY29ubmVjdGlvbnMucHVzaCh0aGlzLm91dGJveFBvb2wuY29ubmVjdCh0aW1lb3V0TXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsU2V0dGxlZChjb25uZWN0aW9ucykudGhlbigoKSA9PiB7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENlbnRyYWxpemVkIG1ldGhvZCB0byByZXBvcnQgYW4gaW52YWxpZCBzaWduYXR1cmUsIGlkZW50aWZ5aW5nIHRoZSByZWxheSB0aGF0IHByb3ZpZGVkIGl0LlxuICAgKiBBIHNpbmdsZSBpbnZhbGlkIHNpZ25hdHVyZSBtZWFucyB0aGUgcmVsYXkgaXMgY29uc2lkZXJlZCBtYWxpY2lvdXMuXG4gICAqIEFsbCBpbnZhbGlkIHNpZ25hdHVyZSBkZXRlY3Rpb25zIChzeW5jaHJvbm91cyBvciBhc3luY2hyb25vdXMpIHNob3VsZCBkZWxlZ2F0ZSB0byB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB3aXRoIGFuIGludmFsaWQgc2lnbmF0dXJlXG4gICAqIEBwYXJhbSByZWxheSBUaGUgcmVsYXkgdGhhdCBwcm92aWRlZCB0aGUgaW52YWxpZCBzaWduYXR1cmVcbiAgICovXG4gIHJlcG9ydEludmFsaWRTaWduYXR1cmUoZXZlbnQsIHJlbGF5KSB7XG4gICAgdGhpcy5kZWJ1ZyhgSW52YWxpZCBzaWduYXR1cmUgZGV0ZWN0ZWQgZm9yIGV2ZW50ICR7ZXZlbnQuaWR9JHtyZWxheSA/IGAgZnJvbSByZWxheSAke3JlbGF5LnVybH1gIDogXCJcIn1gKTtcbiAgICB0aGlzLmVtaXQoXCJldmVudDppbnZhbGlkLXNpZ1wiLCBldmVudCwgcmVsYXkpO1xuICAgIGlmICh0aGlzLmF1dG9CbGFja2xpc3RJbnZhbGlkUmVsYXlzICYmIHJlbGF5KSB7XG4gICAgICB0aGlzLmJsYWNrbGlzdFJlbGF5KHJlbGF5LnVybCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGQgYSByZWxheSBVUkwgdG8gdGhlIGJsYWNrbGlzdCBhcyBpdCBoYXMgYmVlbiBpZGVudGlmaWVkIGFzIG1hbGljaW91c1xuICAgKi9cbiAgYmxhY2tsaXN0UmVsYXkodXJsKSB7XG4gICAgaWYgKCF0aGlzLmJsYWNrbGlzdFJlbGF5VXJscykge1xuICAgICAgdGhpcy5ibGFja2xpc3RSZWxheVVybHMgPSBbXTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmJsYWNrbGlzdFJlbGF5VXJscy5pbmNsdWRlcyh1cmwpKSB7XG4gICAgICB0aGlzLmJsYWNrbGlzdFJlbGF5VXJscy5wdXNoKHVybCk7XG4gICAgICB0aGlzLmRlYnVnKGBBZGRlZCByZWxheSB0byBibGFja2xpc3Q6ICR7dXJsfWApO1xuICAgICAgY29uc3QgcmVsYXkgPSB0aGlzLnBvb2wuZ2V0UmVsYXkodXJsLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgaWYgKHJlbGF5KSB7XG4gICAgICAgIHJlbGF5LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5kZWJ1ZyhgRGlzY29ubmVjdGVkIGZyb20gYmxhY2tsaXN0ZWQgcmVsYXk6ICR7dXJsfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVmYXVsdCBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdmFsaWRhdGlvbiByYXRpbyBiYXNlZCBvbiBoaXN0b3JpY2FsIHZhbGlkYXRpb24gcmVzdWx0cy5cbiAgICogVGhlIG1vcmUgZXZlbnRzIHZhbGlkYXRlZCBzdWNjZXNzZnVsbHksIHRoZSBsb3dlciB0aGUgcmF0aW8gZ29lcyAoZG93biB0byB0aGUgbWluaW11bSkuXG4gICAqL1xuICBkZWZhdWx0VmFsaWRhdGlvblJhdGlvRm4ocmVsYXksIHZhbGlkYXRlZENvdW50LCBub25WYWxpZGF0ZWRDb3VudCkge1xuICAgIGlmICh2YWxpZGF0ZWRDb3VudCA8IDEwKSByZXR1cm4gdGhpcy5pbml0aWFsVmFsaWRhdGlvblJhdGlvO1xuICAgIGNvbnN0IHRydXN0RmFjdG9yID0gTWF0aC5taW4odmFsaWRhdGVkQ291bnQgLyAxMDAsIDEpO1xuICAgIGNvbnN0IGNhbGN1bGF0ZWRSYXRpbyA9IHRoaXMuaW5pdGlhbFZhbGlkYXRpb25SYXRpbyAqICgxIC0gdHJ1c3RGYWN0b3IpICsgdGhpcy5sb3dlc3RWYWxpZGF0aW9uUmF0aW8gKiB0cnVzdEZhY3RvcjtcbiAgICByZXR1cm4gTWF0aC5tYXgoY2FsY3VsYXRlZFJhdGlvLCB0aGlzLmxvd2VzdFZhbGlkYXRpb25SYXRpbyk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIE5ES1VzZXIgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSBvcHRzXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRVc2VyKG9wdHMpIHtcbiAgICBjb25zdCB1c2VyID0gbmV3IE5ES1VzZXIob3B0cyk7XG4gICAgdXNlci5uZGsgPSB0aGlzO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBOREtVc2VyIGZyb20gYSBOSVAwNVxuICAgKiBAcGFyYW0gbmlwMDUgTklQLTA1IElEXG4gICAqIEBwYXJhbSBza2lwQ2FjaGUgU2tpcCBjYWNoZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgZ2V0VXNlckZyb21OaXAwNShuaXAwNSwgc2tpcENhY2hlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gTkRLVXNlci5mcm9tTmlwMDUobmlwMDUsIHRoaXMsIHNraXBDYWNoZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIHN0YXJ0cyBhIG5ldyBzdWJzY3JpcHRpb24uXG4gICAqXG4gICAqIFN1YnNjcmlwdGlvbnMgYXV0b21hdGljYWxseSBzdGFydCB1bmxlc3MgYGF1dG9TdGFydGAgaXMgc2V0IHRvIGBmYWxzZWAuXG4gICAqIFlvdSBjYW4gY29udHJvbCBhdXRvbWF0aWMgY2xvc2luZyBvbiBFT1NFIHZpYSBgb3B0cy5jbG9zZU9uRW9zZWAuXG4gICAqXG4gICAqIEBwYXJhbSBmaWx0ZXJzIC0gQSBzaW5nbGUgTkRLRmlsdGVyIG9iamVjdCBvciBhbiBhcnJheSBvZiBmaWx0ZXJzLlxuICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbmFsIE5ES1N1YnNjcmlwdGlvbk9wdGlvbnMgdG8gY3VzdG9taXplIGJlaGF2aW9yIChlLmcuLCBjYWNoaW5nLCBncm91cGluZykuXG4gICAqIEBwYXJhbSBoYW5kbGVycyAtIE9wdGlvbmFsIGhhbmRsZXJzIGZvciBzdWJzY3JpcHRpb24gZXZlbnRzLiBQYXNzaW5nIGhhbmRsZXJzIGlzIHRoZSBwcmVmZXJyZWQgbWV0aG9kIG9mIHVzaW5nIG5kay5zdWJzY3JpYmUuXG4gICAqICAgLSBgb25FdmVudGA6IENhbGxlZCBmb3IgZWFjaCBldmVudCByZWNlaXZlZC5cbiAgICogIC0gYG9uRXZlbnRzYDogQ2FsbGVkIG9uY2Ugd2l0aCBhbiBhcnJheSBvZiBldmVudHMgd2hlbiB0aGUgc3Vic2NyaXB0aW9uIHN0YXJ0cyAoZnJvbSB0aGUgY2FjaGUpLlxuICAgKiAgLSBgb25Fb3NlYDogQ2FsbGVkIHdoZW4gdGhlIHN1YnNjcmlwdGlvbiByZWNlaXZlcyBFT1NFLlxuICAgKiAgRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB0aGlzIHRoaXJkIHBhcmFtZXRlciBhbHNvIGFjY2VwdHMgYSByZWxheVNldCwgdGhlIHJlbGF5U2V0IHNob3VsZCBiZSBwYXNzZWQgdmlhIGBvcHRzLnJlbGF5U2V0YC5cbiAgICpcbiAgICogQHBhcmFtIF9hdXRvU3RhcnQgLSBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHRoaXMgY2FuIGJlIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gc3RhcnQgdGhlIHN1YnNjcmlwdGlvbiBpbW1lZGlhdGVseS5cbiAgICogIFRoaXMgcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlxuICAgKiAgIC0gYGZhbHNlYDogQ3JlYXRlcyB0aGUgc3Vic2NyaXB0aW9uIGJ1dCBkb2VzIG5vdCBzdGFydCBpdCAoY2FsbCBgc3Vic2NyaXB0aW9uLnN0YXJ0KClgIG1hbnVhbGx5KS5cbiAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgTkRLU3Vic2NyaXB0aW9uIGluc3RhbmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZSBCYXNpYyBzdWJzY3JpcHRpb25cbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBzdWIgPSBuZGsuc3Vic2NyaWJlKHsga2luZHM6IFsxXSwgYXV0aG9yczogW3B1YmtleV0gfSk7XG4gICAqIHN1Yi5vbihcImV2ZW50XCIsIChldmVudCkgPT4gY29uc29sZS5sb2coXCJLaW5kIDEgZXZlbnQ6XCIsIGV2ZW50LmNvbnRlbnQpKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlIFN1YnNjcmlwdGlvbiB3aXRoIG9wdGlvbnMgYW5kIGRpcmVjdCBoYW5kbGVyc1xuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHN1YiA9IG5kay5zdWJzY3JpYmUoXG4gICAqICAgeyBraW5kczogWzBdLCBhdXRob3JzOiBbcHVia2V5XSB9LFxuICAgKiAgIHsgY2xvc2VPbkVvc2U6IHRydWUsIGNhY2hlVXNhZ2U6IE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UuUEFSQUxMRUwgfSxcbiAgICogICB1bmRlZmluZWQsIC8vIFVzZSBkZWZhdWx0IHJlbGF5IHNldCBjYWxjdWxhdGlvblxuICAgKiAgIHtcbiAgICogICAgIG9uRXZlbnRzOiAoZXZlbnRzKSA9PiB7IC8vIFJlbmFtZWQgcGFyYW1ldGVyXG4gICAqICAgICAgIGlmIChldmVudHMubGVuZ3RoID4gMCkge1xuICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGBHb3QgJHtldmVudHMubGVuZ3RofSBwcm9maWxlIGV2ZW50cyBmcm9tIGNhY2hlOmAsIGV2ZW50c1swXS5jb250ZW50KTtcbiAgICogICAgICAgfVxuICAgKiAgICAgfSxcbiAgICogICAgIG9uRXZlbnQ6IChldmVudCkgPT4geyAvLyBSZW5hbWVkIHBhcmFtZXRlclxuICAgKiAgICAgICBjb25zb2xlLmxvZyhcIkdvdCBwcm9maWxlIHVwZGF0ZSBmcm9tIHJlbGF5OlwiLCBldmVudC5jb250ZW50KTsgLy8gQ2xhcmlmaWVkIHNvdXJjZVxuICAgKiAgICAgfSxcbiAgICogICAgIG9uRW9zZTogKCkgPT4gY29uc29sZS5sb2coXCJQcm9maWxlIHN1YnNjcmlwdGlvbiBmaW5pc2hlZC5cIilcbiAgICogICB9XG4gICAqICk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2luY2UgMi4xMy4wIGByZWxheVNldGAgcGFyYW1ldGVyIHJlbW92ZWQ7IHBhc3MgYHJlbGF5U2V0YCBvciBgcmVsYXlVcmxzYCB2aWEgYG9wdHNgLlxuICAgKi9cbiAgc3Vic2NyaWJlKGZpbHRlcnMsIG9wdHMsIGF1dG9TdGFydE9yUmVsYXlTZXQgPSB0cnVlLCBfYXV0b1N0YXJ0ID0gdHJ1ZSkge1xuICAgIGxldCBfcmVsYXlTZXQgPSBvcHRzPy5yZWxheVNldDtcbiAgICBsZXQgYXV0b1N0YXJ0ID0gX2F1dG9TdGFydDtcbiAgICBpZiAoYXV0b1N0YXJ0T3JSZWxheVNldCBpbnN0YW5jZW9mIE5ES1JlbGF5U2V0KSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJyZWxheVNldCBpcyBkZXByZWNhdGVkLCB1c2Ugb3B0cy5yZWxheVNldCBpbnN0ZWFkLiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIHYyLjE0LjBcIik7XG4gICAgICBfcmVsYXlTZXQgPSBhdXRvU3RhcnRPclJlbGF5U2V0O1xuICAgICAgYXV0b1N0YXJ0ID0gX2F1dG9TdGFydDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhdXRvU3RhcnRPclJlbGF5U2V0ID09PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgYXV0b1N0YXJ0T3JSZWxheVNldCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgYXV0b1N0YXJ0ID0gYXV0b1N0YXJ0T3JSZWxheVNldDtcbiAgICB9XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbmV3IE5ES1N1YnNjcmlwdGlvbih0aGlzLCBmaWx0ZXJzLCB7IHJlbGF5U2V0OiBfcmVsYXlTZXQsIC4uLm9wdHMgfSk7XG4gICAgdGhpcy5zdWJNYW5hZ2VyLmFkZChzdWJzY3JpcHRpb24pO1xuICAgIGNvbnN0IHBvb2wgPSBzdWJzY3JpcHRpb24ucG9vbDtcbiAgICBpZiAoc3Vic2NyaXB0aW9uLnJlbGF5U2V0KSB7XG4gICAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHN1YnNjcmlwdGlvbi5yZWxheVNldC5yZWxheXMpIHtcbiAgICAgICAgcG9vbC51c2VUZW1wb3JhcnlSZWxheShyZWxheSwgdm9pZCAwLCBzdWJzY3JpcHRpb24uZmlsdGVycyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm91dGJveFBvb2wgJiYgc3Vic2NyaXB0aW9uLmhhc0F1dGhvcnNGaWx0ZXIoKSkge1xuICAgICAgY29uc3QgYXV0aG9ycyA9IHN1YnNjcmlwdGlvbi5maWx0ZXJzLmZpbHRlcigoZmlsdGVyKSA9PiBmaWx0ZXIuYXV0aG9ycyAmJiBmaWx0ZXIuYXV0aG9ycz8ubGVuZ3RoID4gMCkuZmxhdE1hcCgoZmlsdGVyKSA9PiBmaWx0ZXIuYXV0aG9ycyk7XG4gICAgICB0aGlzLm91dGJveFRyYWNrZXI/LnRyYWNrVXNlcnMoYXV0aG9ycyk7XG4gICAgfVxuICAgIGlmIChhdXRvU3RhcnQpIHtcbiAgICAgIGxldCBldmVudHNIYW5kbGVyO1xuICAgICAgaWYgKHR5cGVvZiBhdXRvU3RhcnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKGF1dG9TdGFydC5vbkV2ZW50KSBzdWJzY3JpcHRpb24ub24oXCJldmVudFwiLCBhdXRvU3RhcnQub25FdmVudCk7XG4gICAgICAgIGlmIChhdXRvU3RhcnQub25Fb3NlKSBzdWJzY3JpcHRpb24ub24oXCJlb3NlXCIsIGF1dG9TdGFydC5vbkVvc2UpO1xuICAgICAgICBpZiAoYXV0b1N0YXJ0Lm9uRXZlbnRzKSBldmVudHNIYW5kbGVyID0gYXV0b1N0YXJ0Lm9uRXZlbnRzO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhY2hlZEV2ZW50cyA9IHN1YnNjcmlwdGlvbi5zdGFydCghZXZlbnRzSGFuZGxlcik7XG4gICAgICAgIGlmIChjYWNoZWRFdmVudHMgJiYgY2FjaGVkRXZlbnRzLmxlbmd0aCA+IDAgJiYgISFldmVudHNIYW5kbGVyKSBldmVudHNIYW5kbGVyKGNhY2hlZEV2ZW50cyk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZmV0Y2ggYW4gZXZlbnQgZnJvbSBhIHRhZywgZm9sbG93aW5nIHJlbGF5IGhpbnRzIGFuZFxuICAgKiBvdGhlciBiZXN0IHByYWN0aWNlcy5cbiAgICogQHBhcmFtIHRhZyBUYWcgdG8gZmV0Y2ggdGhlIGV2ZW50IGZyb21cbiAgICogQHBhcmFtIG9yaWdpbmFsRXZlbnQgRXZlbnQgd2hlcmUgdGhlIHRhZyBjYW1lIGZyb21cbiAgICogQHBhcmFtIHN1Yk9wdHMgU3Vic2NyaXB0aW9uIG9wdGlvbnMgdG8gdXNlIHdoZW4gZmV0Y2hpbmcgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBmYWxsYmFjayBGYWxsYmFjayBvcHRpb25zIHRvIHVzZSB3aGVuIHRoZSBoaW50IHJlbGF5IGRvZXNuJ3QgcmVzcG9uZFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZmV0Y2hFdmVudEZyb21UYWcgPSBmZXRjaEV2ZW50RnJvbVRhZy5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogRmV0Y2ggYW4gZXZlbnQgZnJvbSB0aGUgY2FjaGUgc3luY2hyb25vdXNseS5cbiAgICogQHBhcmFtIGlkT3JGaWx0ZXIgZXZlbnQgaWQgaW4gYmVjaDMyIGZvcm1hdCBvciBmaWx0ZXJcbiAgICogQHJldHVybnMgZXZlbnRzIGZyb20gdGhlIGNhY2hlIG9yIG51bGwgaWYgdGhlIGNhY2hlIGlzIGVtcHR5XG4gICAqL1xuICBmZXRjaEV2ZW50U3luYyhpZE9yRmlsdGVyKSB7XG4gICAgaWYgKCF0aGlzLmNhY2hlQWRhcHRlcikgdGhyb3cgbmV3IEVycm9yKFwiQ2FjaGUgYWRhcHRlciBub3Qgc2V0XCIpO1xuICAgIGxldCBmaWx0ZXJzO1xuICAgIGlmICh0eXBlb2YgaWRPckZpbHRlciA9PT0gXCJzdHJpbmdcIikgZmlsdGVycyA9IFtmaWx0ZXJGcm9tSWQoaWRPckZpbHRlcildO1xuICAgIGVsc2UgZmlsdGVycyA9IGlkT3JGaWx0ZXI7XG4gICAgY29uc3Qgc3ViID0gbmV3IE5ES1N1YnNjcmlwdGlvbih0aGlzLCBmaWx0ZXJzKTtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLmNhY2hlQWRhcHRlci5xdWVyeShzdWIpO1xuICAgIGlmIChldmVudHMgaW5zdGFuY2VvZiBQcm9taXNlKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWNoZSBhZGFwdGVyIGlzIGFzeW5jXCIpO1xuICAgIHJldHVybiBldmVudHMubWFwKChlKSA9PiB7XG4gICAgICBlLm5kayA9IHRoaXM7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBzaW5nbGUgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBpZE9yRmlsdGVyIGV2ZW50IGlkIGluIGJlY2gzMiBmb3JtYXQgb3IgZmlsdGVyXG4gICAqIEBwYXJhbSBvcHRzIHN1YnNjcmlwdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSByZWxheVNldE9yUmVsYXkgZXhwbGljaXQgcmVsYXkgc2V0IHRvIHVzZVxuICAgKi9cbiAgYXN5bmMgZmV0Y2hFdmVudChpZE9yRmlsdGVyLCBvcHRzLCByZWxheVNldE9yUmVsYXkpIHtcbiAgICBsZXQgZmlsdGVycztcbiAgICBsZXQgcmVsYXlTZXQ7XG4gICAgaWYgKHJlbGF5U2V0T3JSZWxheSBpbnN0YW5jZW9mIE5ES1JlbGF5KSB7XG4gICAgICByZWxheVNldCA9IG5ldyBOREtSZWxheVNldCgvKiBAX19QVVJFX18gKi8gbmV3IFNldChbcmVsYXlTZXRPclJlbGF5XSksIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAocmVsYXlTZXRPclJlbGF5IGluc3RhbmNlb2YgTkRLUmVsYXlTZXQpIHtcbiAgICAgIHJlbGF5U2V0ID0gcmVsYXlTZXRPclJlbGF5O1xuICAgIH1cbiAgICBpZiAoIXJlbGF5U2V0T3JSZWxheSAmJiB0eXBlb2YgaWRPckZpbHRlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKCFpc05pcDMzQVZhbHVlKGlkT3JGaWx0ZXIpKSB7XG4gICAgICAgIGNvbnN0IHJlbGF5cyA9IHJlbGF5c0Zyb21CZWNoMzIoaWRPckZpbHRlciwgdGhpcyk7XG4gICAgICAgIGlmIChyZWxheXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlbGF5U2V0ID0gbmV3IE5ES1JlbGF5U2V0KG5ldyBTZXQocmVsYXlzKSwgdGhpcyk7XG4gICAgICAgICAgcmVsYXlTZXQgPSBjb3JyZWN0UmVsYXlTZXQocmVsYXlTZXQsIHRoaXMucG9vbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpZE9yRmlsdGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBmaWx0ZXJzID0gW2ZpbHRlckZyb21JZChpZE9yRmlsdGVyKV07XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlkT3JGaWx0ZXIpKSB7XG4gICAgICBmaWx0ZXJzID0gaWRPckZpbHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsdGVycyA9IFtpZE9yRmlsdGVyXTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmlsdGVyOiAke0pTT04uc3RyaW5naWZ5KGlkT3JGaWx0ZXIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxldCBmZXRjaGVkRXZlbnQgPSBudWxsO1xuICAgICAgY29uc3Qgc3Vic2NyaWJlT3B0cyA9IHtcbiAgICAgICAgLi4ub3B0cyB8fCB7fSxcbiAgICAgICAgY2xvc2VPbkVvc2U6IHRydWVcbiAgICAgIH07XG4gICAgICBpZiAocmVsYXlTZXQpIHN1YnNjcmliZU9wdHMucmVsYXlTZXQgPSByZWxheVNldDtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLnN1YnNjcmliZShcbiAgICAgICAgZmlsdGVycyxcbiAgICAgICAgc3Vic2NyaWJlT3B0cyxcbiAgICAgICAgLy8gcmVsYXlTZXQsIC8vIFJlbW92ZWQ6IFBhc3NlZCB2aWEgb3B0c1xuICAgICAgICBmYWxzZVxuICAgICAgICAvLyBhdXRvU3RhcnQgPSBmYWxzZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHQyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHMuc3RvcCgpO1xuICAgICAgICByZXNvbHZlKGZldGNoZWRFdmVudCk7XG4gICAgICB9LCAxZTQpO1xuICAgICAgcy5vbihcImV2ZW50XCIsIChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5uZGsgPSB0aGlzO1xuICAgICAgICBpZiAoIWV2ZW50LmlzUmVwbGFjZWFibGUoKSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0Mik7XG4gICAgICAgICAgcmVzb2x2ZShldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWZldGNoZWRFdmVudCB8fCBmZXRjaGVkRXZlbnQuY3JlYXRlZF9hdCA8IGV2ZW50LmNyZWF0ZWRfYXQpIHtcbiAgICAgICAgICBmZXRjaGVkRXZlbnQgPSBldmVudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0Mik7XG4gICAgICAgIHJlc29sdmUoZmV0Y2hlZEV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgcy5zdGFydCgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBldmVudHNcbiAgICovXG4gIGFzeW5jIGZldGNoRXZlbnRzKGZpbHRlcnMsIG9wdHMsIHJlbGF5U2V0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBldmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3Qgc3Vic2NyaWJlT3B0cyA9IHtcbiAgICAgICAgLi4ub3B0cyB8fCB7fSxcbiAgICAgICAgY2xvc2VPbkVvc2U6IHRydWVcbiAgICAgIH07XG4gICAgICBpZiAocmVsYXlTZXQpIHN1YnNjcmliZU9wdHMucmVsYXlTZXQgPSByZWxheVNldDtcbiAgICAgIGNvbnN0IHJlbGF5U2V0U3Vic2NyaXB0aW9uID0gdGhpcy5zdWJzY3JpYmUoXG4gICAgICAgIGZpbHRlcnMsXG4gICAgICAgIHN1YnNjcmliZU9wdHMsXG4gICAgICAgIC8vIHJlbGF5U2V0LCAvLyBSZW1vdmVkOiBQYXNzZWQgdmlhIG9wdHNcbiAgICAgICAgZmFsc2VcbiAgICAgICAgLy8gYXV0b1N0YXJ0ID0gZmFsc2VcbiAgICAgICk7XG4gICAgICBjb25zdCBvbkV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGxldCBfZXZlbnQ7XG4gICAgICAgIGlmICghKGV2ZW50IGluc3RhbmNlb2YgTkRLRXZlbnQpKSBfZXZlbnQgPSBuZXcgTkRLRXZlbnQodm9pZCAwLCBldmVudCk7XG4gICAgICAgIGVsc2UgX2V2ZW50ID0gZXZlbnQ7XG4gICAgICAgIGNvbnN0IGRlZHVwS2V5ID0gX2V2ZW50LmRlZHVwbGljYXRpb25LZXkoKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdFdmVudCA9IGV2ZW50cy5nZXQoZGVkdXBLZXkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdFdmVudCkge1xuICAgICAgICAgIF9ldmVudCA9IGRlZHVwKGV4aXN0aW5nRXZlbnQsIF9ldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgX2V2ZW50Lm5kayA9IHRoaXM7XG4gICAgICAgIGV2ZW50cy5zZXQoZGVkdXBLZXksIF9ldmVudCk7XG4gICAgICB9O1xuICAgICAgcmVsYXlTZXRTdWJzY3JpcHRpb24ub24oXCJldmVudFwiLCBvbkV2ZW50KTtcbiAgICAgIHJlbGF5U2V0U3Vic2NyaXB0aW9uLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUobmV3IFNldChldmVudHMudmFsdWVzKCkpKTtcbiAgICAgIH0pO1xuICAgICAgcmVsYXlTZXRTdWJzY3JpcHRpb24uc3RhcnQoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IGEgc2lnbmVyIGlzIGF2YWlsYWJsZSB0byBzaWduIGFuIGV2ZW50LlxuICAgKi9cbiAgYXNzZXJ0U2lnbmVyKCkge1xuICAgIGlmICghdGhpcy5zaWduZXIpIHtcbiAgICAgIHRoaXMuZW1pdChcInNpZ25lcjpyZXF1aXJlZFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ25lciByZXF1aXJlZFwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0RW50aXR5ID0gZ2V0RW50aXR5LmJpbmQodGhpcyk7XG4gIHNldCB3YWxsZXQod2FsbGV0KSB7XG4gICAgaWYgKCF3YWxsZXQpIHtcbiAgICAgIHRoaXMud2FsbGV0Q29uZmlnID0gdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLndhbGxldENvbmZpZyA/Pz0ge307XG4gICAgdGhpcy53YWxsZXRDb25maWcubG5QYXkgPSB3YWxsZXQ/LmxuUGF5Py5iaW5kKHdhbGxldCk7XG4gICAgdGhpcy53YWxsZXRDb25maWcuY2FzaHVQYXkgPSB3YWxsZXQ/LmNhc2h1UGF5Py5iaW5kKHdhbGxldCk7XG4gIH1cbn07XG5cbi8vIHNyYy96YXAvaW52b2ljZS50c1xuaW1wb3J0IHsgZGVjb2RlIH0gZnJvbSBcImxpZ2h0LWJvbHQxMS1kZWNvZGVyXCI7XG5mdW5jdGlvbiB6YXBJbnZvaWNlRnJvbUV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwiZGVzY3JpcHRpb25cIilbMF07XG4gIGNvbnN0IGJvbHQxMSA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImJvbHQxMVwiKVswXTtcbiAgbGV0IGRlY29kZWRJbnZvaWNlO1xuICBsZXQgemFwUmVxdWVzdDtcbiAgaWYgKCFkZXNjcmlwdGlvbiB8fCAhYm9sdDExIHx8ICFib2x0MTFbMV0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIGxldCB6YXBSZXF1ZXN0UGF5bG9hZCA9IGRlc2NyaXB0aW9uWzFdO1xuICAgIGlmICh6YXBSZXF1ZXN0UGF5bG9hZC5zdGFydHNXaXRoKFwiJVwiKSkge1xuICAgICAgemFwUmVxdWVzdFBheWxvYWQgPSBkZWNvZGVVUklDb21wb25lbnQoemFwUmVxdWVzdFBheWxvYWQpO1xuICAgIH1cbiAgICBpZiAoemFwUmVxdWVzdFBheWxvYWQgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB6YXBSZXF1ZXN0ID0gSlNPTi5wYXJzZSh6YXBSZXF1ZXN0UGF5bG9hZCk7XG4gICAgZGVjb2RlZEludm9pY2UgPSBkZWNvZGUoYm9sdDExWzFdKTtcbiAgfSBjYXRjaCAoX2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBhbW91bnRTZWN0aW9uID0gZGVjb2RlZEludm9pY2Uuc2VjdGlvbnMuZmluZCgocykgPT4gcy5uYW1lID09PSBcImFtb3VudFwiKTtcbiAgaWYgKCFhbW91bnRTZWN0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYW1vdW50ID0gTnVtYmVyLnBhcnNlSW50KGFtb3VudFNlY3Rpb24udmFsdWUpO1xuICBpZiAoIWFtb3VudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGNvbnRlbnQgPSB6YXBSZXF1ZXN0LmNvbnRlbnQ7XG4gIGNvbnN0IHNlbmRlciA9IHphcFJlcXVlc3QucHVia2V5O1xuICBjb25zdCByZWNpcGllbnRUYWcgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpWzBdO1xuICBjb25zdCByZWNpcGllbnQgPSByZWNpcGllbnRUYWdbMV07XG4gIGxldCB6YXBwZWRFdmVudCA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImVcIilbMF07XG4gIGlmICghemFwcGVkRXZlbnQpIHtcbiAgICB6YXBwZWRFdmVudCA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImFcIilbMF07XG4gIH1cbiAgY29uc3QgemFwcGVkRXZlbnRJZCA9IHphcHBlZEV2ZW50ID8gemFwcGVkRXZlbnRbMV0gOiB2b2lkIDA7XG4gIGNvbnN0IHphcEludm9pY2UgPSB7XG4gICAgaWQ6IGV2ZW50LmlkLFxuICAgIHphcHBlcjogZXZlbnQucHVia2V5LFxuICAgIHphcHBlZTogc2VuZGVyLFxuICAgIHphcHBlZDogcmVjaXBpZW50LFxuICAgIHphcHBlZEV2ZW50OiB6YXBwZWRFdmVudElkLFxuICAgIGFtb3VudCxcbiAgICBjb21tZW50OiBjb250ZW50XG4gIH07XG4gIHJldHVybiB6YXBJbnZvaWNlO1xufVxuXG4vLyBzcmMvemFwcGVyL2luZGV4LnRzXG5pbXBvcnQgY3JlYXRlRGVidWc1IGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjkgfSBmcm9tIFwidHNlZXBcIjtcblxuLy8gc3JjL3phcHBlci9sbi50c1xuaW1wb3J0IHsgYmVjaDMyIH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG5pbXBvcnQgY3JlYXRlRGVidWc0IGZyb20gXCJkZWJ1Z1wiO1xudmFyIGQyID0gY3JlYXRlRGVidWc0KFwibmRrOnphcHBlcjpsblwiKTtcbmFzeW5jIGZ1bmN0aW9uIGdldE5pcDU3WmFwU3BlY0Zyb21MdWQoeyBsdWQwNiwgbHVkMTYgfSwgbmRrKSB7XG4gIGxldCB6YXBFbmRwb2ludDtcbiAgaWYgKGx1ZDE2ICYmICFsdWQxNi5zdGFydHNXaXRoKFwiTE5VUkxcIikpIHtcbiAgICBjb25zdCBbbmFtZSwgZG9tYWluXSA9IGx1ZDE2LnNwbGl0KFwiQFwiKTtcbiAgICB6YXBFbmRwb2ludCA9IGBodHRwczovLyR7ZG9tYWlufS8ud2VsbC1rbm93bi9sbnVybHAvJHtuYW1lfWA7XG4gIH0gZWxzZSBpZiAobHVkMDYpIHtcbiAgICBjb25zdCB7IHdvcmRzIH0gPSBiZWNoMzIuZGVjb2RlKGx1ZDA2LCAxZTMpO1xuICAgIGNvbnN0IGRhdGEgPSBiZWNoMzIuZnJvbVdvcmRzKHdvcmRzKTtcbiAgICBjb25zdCB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuICAgIHphcEVuZHBvaW50ID0gdXRmOERlY29kZXIuZGVjb2RlKGRhdGEpO1xuICB9XG4gIGlmICghemFwRW5kcG9pbnQpIHtcbiAgICBkMihcIk5vIHphcCBlbmRwb2ludCBmb3VuZCAlb1wiLCB7IGx1ZDA2LCBsdWQxNiB9KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB6YXAgZW5kcG9pbnQgZm91bmRcIik7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBfZmV0Y2ggPSBuZGsuaHR0cEZldGNoIHx8IGZldGNoO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2ZldGNoKHphcEVuZHBvaW50KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmZXRjaCB6YXAgZW5kcG9pbnQgJHt6YXBFbmRwb2ludH06ICR7dGV4dH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZldGNoIHphcCBlbmRwb2ludCAke3phcEVuZHBvaW50fTogJHtlfWApO1xuICB9XG59XG5cbi8vIHNyYy96YXBwZXIvbmlwNTcudHNcbmltcG9ydCB7IG5pcDU3IH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVphcFJlcXVlc3QodGFyZ2V0LCBuZGssIGRhdGEsIHB1YmtleSwgYW1vdW50LCByZWxheXMsIGNvbW1lbnQsIHRhZ3MsIHNpZ25lcikge1xuICBjb25zdCB6YXBFbmRwb2ludCA9IGRhdGEuY2FsbGJhY2s7XG4gIGNvbnN0IHphcFJlcXVlc3QgPSBuaXA1Ny5tYWtlWmFwUmVxdWVzdCh7XG4gICAgcHJvZmlsZTogcHVia2V5LFxuICAgIC8vIHNldCB0aGUgZXZlbnQgdG8gbnVsbCBzaW5jZSBub3N0ci10b29scyBkb2Vzbid0IHN1cHBvcnQgbmlwLTMzIHphcHNcbiAgICBldmVudDogbnVsbCxcbiAgICBhbW91bnQsXG4gICAgY29tbWVudDogY29tbWVudCB8fCBcIlwiLFxuICAgIHJlbGF5czogcmVsYXlzLnNsaWNlKDAsIDQpXG4gIH0pO1xuICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICBjb25zdCB0YWdzMiA9IHRhcmdldC5yZWZlcmVuY2VUYWdzKCk7XG4gICAgY29uc3Qgbm9uUFRhZ3MgPSB0YWdzMi5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcInBcIik7XG4gICAgemFwUmVxdWVzdC50YWdzLnB1c2goLi4ubm9uUFRhZ3MpO1xuICB9XG4gIHphcFJlcXVlc3QudGFncy5wdXNoKFtcImxudXJsXCIsIHphcEVuZHBvaW50XSk7XG4gIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgemFwUmVxdWVzdCk7XG4gIGlmICh0YWdzKSB7XG4gICAgZXZlbnQudGFncyA9IGV2ZW50LnRhZ3MuY29uY2F0KHRhZ3MpO1xuICB9XG4gIGNvbnN0IGVUYWdnZWRFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBhVGFnZ2VkRXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCB0YWcgb2YgZXZlbnQudGFncykge1xuICAgIGlmICh0YWdbMF0gPT09IFwiZVwiKSB7XG4gICAgICBlVGFnZ2VkRXZlbnRzLmFkZCh0YWdbMV0pO1xuICAgIH0gZWxzZSBpZiAodGFnWzBdID09PSBcImFcIikge1xuICAgICAgYVRhZ2dlZEV2ZW50cy5hZGQodGFnWzFdKTtcbiAgICB9XG4gIH1cbiAgaWYgKGVUYWdnZWRFdmVudHMuc2l6ZSA+IDEpIHRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGUtdGFnIGlzIGFsbG93ZWRcIik7XG4gIGlmIChhVGFnZ2VkRXZlbnRzLnNpemUgPiAxKSB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBhLXRhZyBpcyBhbGxvd2VkXCIpO1xuICBldmVudC50YWdzID0gZXZlbnQudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcInBcIik7XG4gIGV2ZW50LnRhZ3MucHVzaChbXCJwXCIsIHB1YmtleV0pO1xuICBhd2FpdCBldmVudC5zaWduKHNpZ25lcik7XG4gIHJldHVybiBldmVudDtcbn1cblxuLy8gc3JjL3phcHBlci9pbmRleC50c1xudmFyIGQzID0gY3JlYXRlRGVidWc1KFwibmRrOnphcHBlclwiKTtcbnZhciBOREtaYXBwZXIgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjkge1xuICB0YXJnZXQ7XG4gIG5kaztcbiAgY29tbWVudDtcbiAgYW1vdW50O1xuICB1bml0O1xuICB0YWdzO1xuICBzaWduZXI7XG4gIHphcE1ldGhvZDtcbiAgbnV0emFwQXNGYWxsYmFjaztcbiAgbG5QYXk7XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIGNhc2h1IHBheW1lbnQgaXMgdG8gYmUgbWFkZS5cbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgc3dhcC9taW50IHByb29mcyBmb3IgdGhlIHJlcXVpcmVkIGFtb3VudCwgaW4gdGhlIHJlcXVpcmVkIHVuaXQsXG4gICAqIGluIGFueSBvZiB0aGUgcHJvdmlkZWQgbWludHMgYW5kIHJldHVybiB0aGUgcHJvb2ZzIGFuZCBtaW50IHVzZWQuXG4gICAqL1xuICBjYXNodVBheTtcbiAgb25Db21wbGV0ZTtcbiAgbWF4UmVsYXlzID0gMztcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvZiB0aGUgemFwXG4gICAqIEBwYXJhbSBhbW91bnQgVGhlIGFtb3VudCB0byBzZW5kIGluZGljYXRlZCBpbiB0aGUgdW5pdFxuICAgKiBAcGFyYW0gdW5pdCBUaGUgdW5pdCBvZiB0aGUgYW1vdW50XG4gICAqIEBwYXJhbSBvcHRzIE9wdGlvbnMgZm9yIHRoZSB6YXBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhcmdldCwgYW1vdW50LCB1bml0ID0gXCJtc2F0XCIsIG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5uZGsgPSBvcHRzLm5kayB8fCB0YXJnZXQubmRrO1xuICAgIGlmICghdGhpcy5uZGspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBwcm92aWRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5hbW91bnQgPSBhbW91bnQ7XG4gICAgdGhpcy5jb21tZW50ID0gb3B0cy5jb21tZW50O1xuICAgIHRoaXMudW5pdCA9IHVuaXQ7XG4gICAgdGhpcy50YWdzID0gb3B0cy50YWdzO1xuICAgIHRoaXMuc2lnbmVyID0gb3B0cy5zaWduZXI7XG4gICAgdGhpcy5udXR6YXBBc0ZhbGxiYWNrID0gb3B0cy5udXR6YXBBc0ZhbGxiYWNrID8/IGZhbHNlO1xuICAgIHRoaXMubG5QYXkgPSBvcHRzLmxuUGF5IHx8IHRoaXMubmRrLndhbGxldENvbmZpZz8ubG5QYXk7XG4gICAgdGhpcy5jYXNodVBheSA9IG9wdHMuY2FzaHVQYXkgfHwgdGhpcy5uZGsud2FsbGV0Q29uZmlnPy5jYXNodVBheTtcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBvcHRzLm9uQ29tcGxldGUgfHwgdGhpcy5uZGsud2FsbGV0Q29uZmlnPy5vblBheW1lbnRDb21wbGV0ZTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGUgemFwcGluZyBwcm9jZXNzXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBjYWxjdWxhdGUgdGhlIHNwbGl0cyBmb3IgdGhpcyB6YXAgYW5kIGluaXRpYXRlIGVhY2ggemFwIHNwbGl0LlxuICAgKi9cbiAgYXN5bmMgemFwKG1ldGhvZHMpIHtcbiAgICBjb25zdCBzcGxpdHMgPSB0aGlzLmdldFphcFNwbGl0cygpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgc3BsaXRzLm1hcChhc3luYyAoc3BsaXQpID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnphcFNwbGl0KHNwbGl0LCBtZXRob2RzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyBFcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcInNwbGl0OmNvbXBsZXRlXCIsIHNwbGl0LCByZXN1bHQpO1xuICAgICAgICByZXN1bHRzLnNldChzcGxpdCwgcmVzdWx0KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLmVtaXQoXCJjb21wbGV0ZVwiLCByZXN1bHRzKTtcbiAgICBpZiAodGhpcy5vbkNvbXBsZXRlKSB0aGlzLm9uQ29tcGxldGUocmVzdWx0cyk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgYXN5bmMgemFwTmlwNTcoc3BsaXQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMubG5QYXkpIHRocm93IG5ldyBFcnJvcihcIk5vIGxuUGF5IGZ1bmN0aW9uIGF2YWlsYWJsZVwiKTtcbiAgICBjb25zdCB6YXBTcGVjID0gYXdhaXQgZ2V0TmlwNTdaYXBTcGVjRnJvbUx1ZChkYXRhLCB0aGlzLm5kayk7XG4gICAgaWYgKCF6YXBTcGVjKSB0aHJvdyBuZXcgRXJyb3IoXCJObyB6YXAgc3BlYyBhdmFpbGFibGUgZm9yIHJlY2lwaWVudFwiKTtcbiAgICBjb25zdCByZWxheXMgPSBhd2FpdCB0aGlzLnJlbGF5cyhzcGxpdC5wdWJrZXkpO1xuICAgIGNvbnN0IHphcFJlcXVlc3QgPSBhd2FpdCBnZW5lcmF0ZVphcFJlcXVlc3QoXG4gICAgICB0aGlzLnRhcmdldCxcbiAgICAgIHRoaXMubmRrLFxuICAgICAgemFwU3BlYyxcbiAgICAgIHNwbGl0LnB1YmtleSxcbiAgICAgIHNwbGl0LmFtb3VudCxcbiAgICAgIHJlbGF5cyxcbiAgICAgIHRoaXMuY29tbWVudCxcbiAgICAgIHRoaXMudGFncyxcbiAgICAgIHRoaXMuc2lnbmVyXG4gICAgKTtcbiAgICBpZiAoIXphcFJlcXVlc3QpIHtcbiAgICAgIGQzKFwiVW5hYmxlIHRvIGdlbmVyYXRlIHphcCByZXF1ZXN0XCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGdlbmVyYXRlIHphcCByZXF1ZXN0XCIpO1xuICAgIH1cbiAgICBjb25zdCBwciA9IGF3YWl0IHRoaXMuZ2V0TG5JbnZvaWNlKHphcFJlcXVlc3QsIHNwbGl0LmFtb3VudCwgemFwU3BlYyk7XG4gICAgaWYgKCFwcikge1xuICAgICAgZDMoXCJVbmFibGUgdG8gZ2V0IHBheW1lbnQgcmVxdWVzdFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBnZXQgcGF5bWVudCByZXF1ZXN0XCIpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJsbl9pbnZvaWNlXCIsIHtcbiAgICAgIGFtb3VudDogc3BsaXQuYW1vdW50LFxuICAgICAgcmVjaXBpZW50UHVia2V5OiBzcGxpdC5wdWJrZXksXG4gICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICBuaXA1N1phcFJlcXVlc3Q6IHphcFJlcXVlc3QsXG4gICAgICBwcixcbiAgICAgIHR5cGU6IFwibmlwNTdcIlxuICAgIH0pO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMubG5QYXkoe1xuICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCxcbiAgICAgIHJlY2lwaWVudFB1YmtleTogc3BsaXQucHVia2V5LFxuICAgICAgcGF5bWVudERlc2NyaXB0aW9uOiBcIk5JUC01NyBaYXBcIixcbiAgICAgIHByLFxuICAgICAgYW1vdW50OiBzcGxpdC5hbW91bnQsXG4gICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICBuaXA1N1phcFJlcXVlc3Q6IHphcFJlcXVlc3RcbiAgICB9KTtcbiAgICBpZiAocmVzPy5wcmVpbWFnZSkge1xuICAgICAgdGhpcy5lbWl0KFwibG5fcGF5bWVudFwiLCB7XG4gICAgICAgIHByZWltYWdlOiByZXMucHJlaW1hZ2UsXG4gICAgICAgIGFtb3VudDogc3BsaXQuYW1vdW50LFxuICAgICAgICByZWNpcGllbnRQdWJrZXk6IHNwbGl0LnB1YmtleSxcbiAgICAgICAgcHIsXG4gICAgICAgIHVuaXQ6IHRoaXMudW5pdCxcbiAgICAgICAgbmlwNTdaYXBSZXF1ZXN0OiB6YXBSZXF1ZXN0LFxuICAgICAgICB0eXBlOiBcIm5pcDU3XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaGVzIGluZm9ybWF0aW9uIGFib3V0IGEgTklQLTYxIHphcCBhbmQgYXNrcyB0aGUgY2FsbGVyIHRvIGNyZWF0ZSBjYXNodSBwcm9vZnMgZm9yIHRoZSB6YXAuXG4gICAqXG4gICAqIChub3RlIHRoYXQgdGhlIGNhc2h1UGF5IGZ1bmN0aW9uIGNhbiB1c2UgYW55IG1ldGhvZCB0byBjcmVhdGUgdGhlIHByb29mcywgaW5jbHVkaW5nIHVzaW5nIGxpZ2h0bmluZ1xuICAgKiB0byBtaW50IHByb29mcyBpbiB0aGUgc3BlY2lmaWVkIG1pbnQsIHRoZSByZXNwb25zaWJpbGl0eSBvZiBtaW50aW5nIHRoZSBwcm9vZnMgaXMgZGVsZWdhdGVkIHRvIHRoZSBjYWxsZXIgKGUuZy4gbmRrLXdhbGxldCkpXG4gICAqL1xuICBhc3luYyB6YXBOaXA2MShzcGxpdCwgZGF0YSkge1xuICAgIGlmICghdGhpcy5jYXNodVBheSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2FzaHVQYXkgZnVuY3Rpb24gYXZhaWxhYmxlXCIpO1xuICAgIGxldCByZXQ7XG4gICAgcmV0ID0gYXdhaXQgdGhpcy5jYXNodVBheShcbiAgICAgIHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCxcbiAgICAgICAgcmVjaXBpZW50UHVia2V5OiBzcGxpdC5wdWJrZXksXG4gICAgICAgIHBheW1lbnREZXNjcmlwdGlvbjogXCJOSVAtNjEgWmFwXCIsXG4gICAgICAgIGFtb3VudDogc3BsaXQuYW1vdW50LFxuICAgICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICAgIC4uLmRhdGEgPz8ge31cbiAgICAgIH0sXG4gICAgICAocHIpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFwibG5faW52b2ljZVwiLCB7XG4gICAgICAgICAgcHIsXG4gICAgICAgICAgYW1vdW50OiBzcGxpdC5hbW91bnQsXG4gICAgICAgICAgcmVjaXBpZW50UHVia2V5OiBzcGxpdC5wdWJrZXksXG4gICAgICAgICAgdW5pdDogdGhpcy51bml0LFxuICAgICAgICAgIHR5cGU6IFwibmlwNjFcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICAgIGQzKFwiTklQLTYxIFphcCByZXN1bHQ6ICVvXCIsIHJldCk7XG4gICAgaWYgKHJldCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBpZiAocmV0KSB7XG4gICAgICBjb25zdCB7IHByb29mcywgbWludCB9ID0gcmV0O1xuICAgICAgaWYgKCFwcm9vZnMgfHwgIW1pbnQpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB6YXAgY29uZmlybWF0aW9uOiBtaXNzaW5nIHByb29mcyBvciBtaW50OiAke3JldH1gKTtcbiAgICAgIGNvbnN0IHJlbGF5cyA9IGF3YWl0IHRoaXMucmVsYXlzKHNwbGl0LnB1YmtleSk7XG4gICAgICBjb25zdCByZWxheVNldCA9IE5ES1JlbGF5U2V0LmZyb21SZWxheVVybHMocmVsYXlzLCB0aGlzLm5kayk7XG4gICAgICBjb25zdCBudXR6YXAgPSBuZXcgTkRLTnV0emFwKHRoaXMubmRrKTtcbiAgICAgIG51dHphcC50YWdzID0gWy4uLm51dHphcC50YWdzLCAuLi50aGlzLnRhZ3MgfHwgW11dO1xuICAgICAgbnV0emFwLnByb29mcyA9IHByb29mcztcbiAgICAgIG51dHphcC5taW50ID0gbWludDtcbiAgICAgIG51dHphcC50YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgIG51dHphcC5jb21tZW50ID0gdGhpcy5jb21tZW50O1xuICAgICAgbnV0emFwLnVuaXQgPSBcInNhdFwiO1xuICAgICAgbnV0emFwLnJlY2lwaWVudFB1YmtleSA9IHNwbGl0LnB1YmtleTtcbiAgICAgIGF3YWl0IG51dHphcC5zaWduKHRoaXMuc2lnbmVyKTtcbiAgICAgIG51dHphcC5wdWJsaXNoKHJlbGF5U2V0KTtcbiAgICAgIHJldHVybiBudXR6YXA7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHphcCBtZXRob2RzIGF2YWlsYWJsZSBmb3IgdGhlIHJlY2lwaWVudCBhbmQgaW5pdGlhdGVzIHRoZSB6YXBcbiAgICogaW4gdGhlIGRlc2lyZWQgbWV0aG9kLlxuICAgKiBAcGFyYW0gc3BsaXRcbiAgICogQHBhcmFtIG1ldGhvZHMgLSBUaGUgbWV0aG9kcyB0byB0cnksIGlmIG5vdCBwcm92aWRlZCwgYWxsIG1ldGhvZHMgd2lsbCBiZSB0cmllZC5cbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIHphcFNwbGl0KHNwbGl0LCBtZXRob2RzKSB7XG4gICAgY29uc3QgcmVjaXBpZW50ID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogc3BsaXQucHVia2V5IH0pO1xuICAgIGNvbnN0IHphcE1ldGhvZHMgPSBhd2FpdCByZWNpcGllbnQuZ2V0WmFwSW5mbygyNTAwKTtcbiAgICBsZXQgcmV0VmFsO1xuICAgIGNvbnN0IGNhbkZhbGxiYWNrVG9OaXA2MSA9IHRoaXMubnV0emFwQXNGYWxsYmFjayAmJiB0aGlzLmNhc2h1UGF5O1xuICAgIGlmICh6YXBNZXRob2RzLnNpemUgPT09IDAgJiYgIWNhbkZhbGxiYWNrVG9OaXA2MSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHphcCBtZXRob2QgYXZhaWxhYmxlIGZvciByZWNpcGllbnQgYW5kIE5JUC02MSBmYWxsYmFjayBpcyBkaXNhYmxlZFwiKTtcbiAgICBjb25zdCBuaXA2MUZhbGxiYWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLm51dHphcEFzRmFsbGJhY2spIHJldHVybjtcbiAgICAgIGNvbnN0IHJlbGF5TGlzdHMgPSBhd2FpdCBnZXRSZWxheUxpc3RGb3JVc2Vycyhbc3BsaXQucHVia2V5XSwgdGhpcy5uZGspO1xuICAgICAgbGV0IHJlbGF5VXJscyA9IHJlbGF5TGlzdHMuZ2V0KHNwbGl0LnB1YmtleSk/LnJlYWRSZWxheVVybHM7XG4gICAgICByZWxheVVybHMgPSB0aGlzLm5kay5wb29sLmNvbm5lY3RlZFJlbGF5cygpLm1hcCgocikgPT4gci51cmwpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuemFwTmlwNjEoc3BsaXQsIHtcbiAgICAgICAgLy8gdXNlIHRoZSB1c2VyJ3MgcmVsYXkgbGlzdFxuICAgICAgICByZWxheXM6IHJlbGF5VXJscyxcbiAgICAgICAgLy8gbG9jayB0byB0aGUgdXNlcidzIGFjdHVhbCBwdWJrZXlcbiAgICAgICAgcDJwazogc3BsaXQucHVia2V5LFxuICAgICAgICAvLyBhbGxvdyBpbnRyYW1pbnQgZmFsbGJhY2tcbiAgICAgICAgYWxsb3dJbnRyYW1pbnRGYWxsYmFjazogISFjYW5GYWxsYmFja1RvTmlwNjFcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgY2FuVXNlTmlwNjEgPSAhbWV0aG9kcyB8fCBtZXRob2RzLmluY2x1ZGVzKFwibmlwNjFcIik7XG4gICAgY29uc3QgY2FuVXNlTmlwNTcgPSAhbWV0aG9kcyB8fCBtZXRob2RzLmluY2x1ZGVzKFwibmlwNTdcIik7XG4gICAgY29uc3QgbmlwNjFNZXRob2QgPSB6YXBNZXRob2RzLmdldChcIm5pcDYxXCIpO1xuICAgIGlmIChuaXA2MU1ldGhvZCAmJiBjYW5Vc2VOaXA2MSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0VmFsID0gYXdhaXQgdGhpcy56YXBOaXA2MShzcGxpdCwgbmlwNjFNZXRob2QpO1xuICAgICAgICBpZiAocmV0VmFsIGluc3RhbmNlb2YgTkRLTnV0emFwKSByZXR1cm4gcmV0VmFsO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJub3RpY2VcIiwgYE5JUC02MSBhdHRlbXB0IGZhaWxlZDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5pcDU3TWV0aG9kID0gemFwTWV0aG9kcy5nZXQoXCJuaXA1N1wiKTtcbiAgICBpZiAobmlwNTdNZXRob2QgJiYgY2FuVXNlTmlwNTcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldFZhbCA9IGF3YWl0IHRoaXMuemFwTmlwNTcoc3BsaXQsIG5pcDU3TWV0aG9kKTtcbiAgICAgICAgaWYgKCEocmV0VmFsIGluc3RhbmNlb2YgRXJyb3IpKSByZXR1cm4gcmV0VmFsO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJub3RpY2VcIiwgYE5JUC01NyBhdHRlbXB0IGZhaWxlZDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjYW5GYWxsYmFja1RvTmlwNjEpIHtcbiAgICAgIHJldFZhbCA9IGF3YWl0IG5pcDYxRmFsbGJhY2soKTtcbiAgICAgIGlmIChyZXRWYWwgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgcmV0VmFsO1xuICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwibm90aWNlXCIsIFwiWmFwIG1ldGhvZHMgZXhoYXVzdGVkIGFuZCB0aGVyZSB3YXMgbm8gZmFsbGJhY2sgdG8gTklQLTYxXCIpO1xuICAgIGlmIChyZXRWYWwgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgcmV0VmFsO1xuICAgIHJldHVybiByZXRWYWw7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBib2x0MTEgZm9yIGEgbmlwNTcgemFwXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcGFyYW0gYW1vdW50XG4gICAqIEBwYXJhbSB6YXBFbmRwb2ludFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgZ2V0TG5JbnZvaWNlKHphcFJlcXVlc3QsIGFtb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHphcEVuZHBvaW50ID0gZGF0YS5jYWxsYmFjaztcbiAgICBjb25zdCBldmVudFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeSh6YXBSZXF1ZXN0LnJhd0V2ZW50KCkpO1xuICAgIGQzKFxuICAgICAgYEZldGNoaW5nIGludm9pY2UgZnJvbSAke3phcEVuZHBvaW50fT8ke25ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhbW91bnQ6IGFtb3VudC50b1N0cmluZygpLFxuICAgICAgICBub3N0cjogZXZlbnRQYXlsb2FkXG4gICAgICB9KX1gXG4gICAgKTtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHphcEVuZHBvaW50KTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImFtb3VudFwiLCBhbW91bnQudG9TdHJpbmcoKSk7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJub3N0clwiLCBldmVudFBheWxvYWQpO1xuICAgIGQzKGBGZXRjaGluZyBpbnZvaWNlIGZyb20gJHt1cmwudG9TdHJpbmcoKX1gKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpKTtcbiAgICBkMyhgR290IHJlc3BvbnNlIGZyb20gemFwIGVuZHBvaW50OiAke3phcEVuZHBvaW50fWAsIHsgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICBkMyhgUmVjZWl2ZWQgbm9uLTIwMCBzdGF0dXMgZnJvbSB6YXAgZW5kcG9pbnQ6ICR7emFwRW5kcG9pbnR9YCwge1xuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgYW1vdW50LFxuICAgICAgICBub3N0cjogZXZlbnRQYXlsb2FkXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmZXRjaCB6YXAgZW5kcG9pbnQgJHt6YXBFbmRwb2ludH06ICR7dGV4dH1gKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gYm9keS5wcjtcbiAgfVxuICBnZXRaYXBTcGxpdHMoKSB7XG4gICAgaWYgKHRoaXMudGFyZ2V0IGluc3RhbmNlb2YgTkRLVXNlcikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHB1YmtleTogdGhpcy50YXJnZXQucHVia2V5LFxuICAgICAgICAgIGFtb3VudDogdGhpcy5hbW91bnRcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgY29uc3QgemFwVGFncyA9IHRoaXMudGFyZ2V0LmdldE1hdGNoaW5nVGFncyhcInphcFwiKTtcbiAgICBpZiAoemFwVGFncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICBwdWJrZXk6IHRoaXMudGFyZ2V0LnB1YmtleSxcbiAgICAgICAgICBhbW91bnQ6IHRoaXMuYW1vdW50XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0IHNwbGl0cyA9IFtdO1xuICAgIGNvbnN0IHRvdGFsID0gemFwVGFncy5yZWR1Y2UoKGFjYywgdGFnKSA9PiBhY2MgKyBOdW1iZXIucGFyc2VJbnQodGFnWzJdKSwgMCk7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgemFwVGFncykge1xuICAgICAgY29uc3QgcHVia2V5ID0gdGFnWzFdO1xuICAgICAgY29uc3QgYW1vdW50ID0gTWF0aC5mbG9vcihOdW1iZXIucGFyc2VJbnQodGFnWzJdKSAvIHRvdGFsICogdGhpcy5hbW91bnQpO1xuICAgICAgc3BsaXRzLnB1c2goeyBwdWJrZXksIGFtb3VudCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNwbGl0cztcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgemFwIG1ldGhvZCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHphcCBhIHB1YmJrZXlcbiAgICogQHBhcmFtIG5ka1xuICAgKiBAcGFyYW0gcHVia2V5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBnZXRaYXBNZXRob2RzKG5kaywgcmVjaXBpZW50LCB0aW1lb3V0ID0gMjUwMCkge1xuICAgIGNvbnN0IHVzZXIgPSBuZGsuZ2V0VXNlcih7IHB1YmtleTogcmVjaXBpZW50IH0pO1xuICAgIHJldHVybiBhd2FpdCB1c2VyLmdldFphcEluZm8odGltZW91dCk7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIHRoZSByZWxheXMgdG8gdXNlIGZvciB0aGUgemFwIHJlcXVlc3RcbiAgICovXG4gIGFzeW5jIHJlbGF5cyhwdWJrZXkpIHtcbiAgICBsZXQgciA9IFtdO1xuICAgIGlmICh0aGlzLm5kaz8uYWN0aXZlVXNlcikge1xuICAgICAgY29uc3QgcmVsYXlMaXN0cyA9IGF3YWl0IGdldFJlbGF5TGlzdEZvclVzZXJzKFt0aGlzLm5kay5hY3RpdmVVc2VyLnB1YmtleSwgcHVia2V5XSwgdGhpcy5uZGspO1xuICAgICAgY29uc3QgcmVsYXlTY29yZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCByZWxheUxpc3Qgb2YgcmVsYXlMaXN0cy52YWx1ZXMoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHVybCBvZiByZWxheUxpc3QucmVhZFJlbGF5VXJscykge1xuICAgICAgICAgIGNvbnN0IHNjb3JlID0gcmVsYXlTY29yZXMuZ2V0KHVybCkgfHwgMDtcbiAgICAgICAgICByZWxheVNjb3Jlcy5zZXQodXJsLCBzY29yZSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByID0gQXJyYXkuZnJvbShyZWxheVNjb3Jlcy5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKS5tYXAoKFt1cmxdKSA9PiB1cmwpLnNsaWNlKDAsIHRoaXMubWF4UmVsYXlzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmRrPy5wb29sPy5wZXJtYW5lbnRBbmRDb25uZWN0ZWRSZWxheXMoKS5sZW5ndGgpIHtcbiAgICAgIHIgPSB0aGlzLm5kay5wb29sLnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLm1hcCgocmVsYXkpID0+IHJlbGF5LnVybCk7XG4gICAgfVxuICAgIGlmICghci5sZW5ndGgpIHtcbiAgICAgIHIgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9maWx0ZXIudHNcbmZ1bmN0aW9uIG1hdGNoRmlsdGVyKGZpbHRlciwgZXZlbnQpIHtcbiAgaWYgKGZpbHRlci5pZHMgJiYgZmlsdGVyLmlkcy5pbmRleE9mKGV2ZW50LmlkKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbHRlci5raW5kcyAmJiBmaWx0ZXIua2luZHMuaW5kZXhPZihldmVudC5raW5kKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbHRlci5hdXRob3JzICYmIGZpbHRlci5hdXRob3JzLmluZGV4T2YoZXZlbnQucHVia2V5KSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBmIGluIGZpbHRlcikge1xuICAgIGlmIChmWzBdID09PSBcIiNcIikge1xuICAgICAgY29uc3QgdGFnTmFtZSA9IGYuc2xpY2UoMSk7XG4gICAgICBpZiAodGFnTmFtZSA9PT0gXCJ0XCIpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZmlsdGVyW2AjJHt0YWdOYW1lfWBdPy5tYXAoKHYpID0+IHYudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmICh2YWx1ZXMgJiYgIWV2ZW50LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSB0YWdOYW1lICYmIHZhbHVlcz8uaW5kZXhPZih2LnRvTG93ZXJDYXNlKCkpICE9PSAtMSkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZmlsdGVyW2AjJHt0YWdOYW1lfWBdO1xuICAgICAgICBpZiAodmFsdWVzICYmICFldmVudC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gdGFnTmFtZSAmJiB2YWx1ZXM/LmluZGV4T2YodikgIT09IC0xKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZmlsdGVyLnNpbmNlICYmIGV2ZW50LmNyZWF0ZWRfYXQgPCBmaWx0ZXIuc2luY2UpIHJldHVybiBmYWxzZTtcbiAgaWYgKGZpbHRlci51bnRpbCAmJiBldmVudC5jcmVhdGVkX2F0ID4gZmlsdGVyLnVudGlsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IHtcbiAgQkVDSDMyX1JFR0VYLFxuICBOREtBcHBIYW5kbGVyRXZlbnQsXG4gIE5ES0FwcFNldHRpbmdzLFxuICBOREtBcnRpY2xlLFxuICBOREtCbG9zc29tTGlzdCxcbiAgTkRLQ2FzaHVNaW50TGlzdCxcbiAgTkRLQ2FzaHVUb2tlbixcbiAgTkRLQ2FzaHVXYWxsZXRUeCxcbiAgTkRLQ2xhc3NpZmllZCxcbiAgTkRLRFZNSm9iRmVlZGJhY2ssXG4gIE5ES0RWTUpvYlJlc3VsdCxcbiAgTkRLRFZNUmVxdWVzdCxcbiAgTkRLRHJhZnQsXG4gIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzLFxuICBOREtFdmVudCxcbiAgTkRLRm9sbG93UGFjayxcbiAgTkRLSGlnaGxpZ2h0LFxuICBOREtJbWFnZSxcbiAgTkRLS2luZCxcbiAgTkRLTGlzdCxcbiAgTkRLTGlzdEtpbmRzLFxuICBOREtOaXAwN1NpZ25lcixcbiAgTkRLTmlwNDZCYWNrZW5kLFxuICBOREtOaXA0NlNpZ25lcixcbiAgTkRLTm9zdHJScGMsXG4gIE5ES051dHphcCxcbiAgTkRLUG9vbCxcbiAgTkRLUHJpdmF0ZUtleVNpZ25lcixcbiAgTkRLUHVibGlzaEVycm9yLFxuICBOREtSZWxheSxcbiAgTkRLUmVsYXlBdXRoUG9saWNpZXMsXG4gIE5ES1JlbGF5TGlzdCxcbiAgTkRLUmVsYXlTZXQsXG4gIE5ES1JlbGF5U3RhdHVzLFxuICBOREtSZXBvc3QsXG4gIE5ES1NpbXBsZUdyb3VwLFxuICBOREtTaW1wbGVHcm91cE1lbWJlckxpc3QsXG4gIE5ES1NpbXBsZUdyb3VwTWV0YWRhdGEsXG4gIE5ES1N0b3J5LFxuICBOREtTdG9yeVN0aWNrZXIsXG4gIE5ES1N0b3J5U3RpY2tlclR5cGUsXG4gIE5ES1N1YnNjcmlwdGlvbixcbiAgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZSxcbiAgTkRLU3Vic2NyaXB0aW9uUmVjZWlwdCxcbiAgTkRLU3Vic2NyaXB0aW9uU3RhcnQsXG4gIE5ES1N1YnNjcmlwdGlvblRpZXIsXG4gIE5ES1RyYW5zY3JpcHRpb25EVk0sXG4gIE5ES1VzZXIsXG4gIE5ES1ZpZGVvLFxuICBOREtXaWtpLFxuICBOREtXaWtpTWVyZ2VSZXF1ZXN0LFxuICBOREtaYXBwZXIsXG4gIE5JUDMzX0FfUkVHRVgsXG4gIE5ka051dHphcFN0YXR1cyxcbiAgU2lnbmF0dXJlVmVyaWZpY2F0aW9uU3RhdHMsXG4gIGNhbGN1bGF0ZVJlbGF5U2V0RnJvbUV2ZW50LFxuICBjYWxjdWxhdGVUZXJtRHVyYXRpb25JblNlY29uZHMsXG4gIGNhc2h1UHVia2V5VG9Ob3N0clB1YmtleSxcbiAgY29tcGFyZUZpbHRlcixcbiAgTkRLIGFzIGRlZmF1bHQsXG4gIGRlZmF1bHRPcHRzLFxuICBkZXNlcmlhbGl6ZSxcbiAgZHZtU2NoZWR1bGUsXG4gIGV2ZW50SGFzRVRhZ01hcmtlcnMsXG4gIGV2ZW50SXNQYXJ0T2ZUaHJlYWQsXG4gIGV2ZW50SXNSZXBseSxcbiAgZXZlbnRSZXBsaWVzLFxuICBldmVudFRocmVhZElkcyxcbiAgZXZlbnRUaHJlYWRzLFxuICBldmVudHNCeVNhbWVBdXRob3IsXG4gIGZpbHRlckFuZFJlbGF5U2V0RnJvbUJlY2gzMixcbiAgZmlsdGVyRmluZ2VycHJpbnQsXG4gIGZpbHRlckZvckV2ZW50c1RhZ2dpbmdJZCxcbiAgZmlsdGVyRnJvbUlkLFxuICBnZW5lcmF0ZUNvbnRlbnRUYWdzLFxuICBnZW5lcmF0ZUhhc2h0YWdzLFxuICBnZW5lcmF0ZVN1YklkLFxuICBnZW5lcmF0ZVphcFJlcXVlc3QsXG4gIGdldEV2ZW50UmVwbHlJZCxcbiAgZ2V0TmlwNTdaYXBTcGVjRnJvbUx1ZCxcbiAgZ2V0UmVsYXlMaXN0Rm9yVXNlcixcbiAgZ2V0UmVsYXlMaXN0Rm9yVXNlcnMsXG4gIGdldFJlcGx5VGFnLFxuICBnZXRSb290RXZlbnRJZCxcbiAgZ2V0Um9vdFRhZyxcbiAgZ2lmdFVud3JhcCxcbiAgZ2lmdFdyYXAsXG4gIGltZXRhVGFnVG9UYWcsXG4gIGlzRXZlbnRPcmlnaW5hbFBvc3QsXG4gIGlzTmlwMzNBVmFsdWUsXG4gIG1hcEltZXRhVGFnLFxuICBtYXRjaEZpbHRlcixcbiAgbWVyZ2VGaWx0ZXJzLFxuICBtZXJnZVRhZ3MsXG4gIG5ka1NpZ25lckZyb21QYXlsb2FkLFxuICBuZXdBbW91bnQsXG4gIG5vcm1hbGl6ZSxcbiAgbm9ybWFsaXplUmVsYXlVcmwsXG4gIG5vcm1hbGl6ZVVybCxcbiAgcGFyc2VUYWdUb1N1YnNjcmlwdGlvbkFtb3VudCxcbiAgcGluRXZlbnQsXG4gIHBvc3NpYmxlSW50ZXJ2YWxGcmVxdWVuY2llcyxcbiAgcHJvZmlsZUZyb21FdmVudCxcbiAgcHJvb2ZQMnBrLFxuICBwcm9vZlAycGtOb3N0cixcbiAgcHJvb2ZzVG90YWxCYWxhbmNlLFxuICBxdWVyeUZ1bGx5RmlsbGVkLFxuICByZWdpc3RlclNpZ25lcixcbiAgcmVsYXlMaXN0RnJvbUtpbmQzLFxuICByZWxheXNGcm9tQmVjaDMyLFxuICBzZXJpYWxpemUsXG4gIHNlcmlhbGl6ZVByb2ZpbGUsXG4gIHN0YXJ0U2lnbmF0dXJlVmVyaWZpY2F0aW9uU3RhdHMsXG4gIHN0clRvRGltZW5zaW9uLFxuICBzdHJUb1Bvc2l0aW9uLFxuICB0cnlOb3JtYWxpemVSZWxheVVybCxcbiAgdW5pcXVlVGFnLFxuICB3cmFwRXZlbnQsXG4gIHphcEludm9pY2VGcm9tRXZlbnRcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@nostr-dev-kit+ndk@2.14.24_nostr-tools@2.14.2_typescript@5.8.3_/node_modules/@nostr-dev-kit/ndk/dist/index.mjs\n");

/***/ })

};
;