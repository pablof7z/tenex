"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@nostr-dev-kit";
exports.ids = ["vendor-chunks/@nostr-dev-kit"];
exports.modules = {

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/dist/index.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/dist/index.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   db: () => (/* binding */ db),\n/* harmony export */   \"default\": () => (/* binding */ NDKCacheAdapterDexie),\n/* harmony export */   foundEvent: () => (/* binding */ foundEvent),\n/* harmony export */   foundEvents: () => (/* binding */ foundEvents)\n/* harmony export */ });\n/* harmony import */ var _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @nostr-dev-kit/ndk */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/@nostr-dev-kit/ndk/dist/index.mjs\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! nostr-tools */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/lib/esm/index.js\");\n/* harmony import */ var dexie__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dexie */ \"(ssr)/./node_modules/dexie/import-wrapper.mjs\");\n/* harmony import */ var typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! typescript-lru-cache */ \"(ssr)/./node_modules/typescript-lru-cache/dist/index.js\");\n// src/index.ts\n\n\n\n\n// src/caches/event-tags.ts\nasync function eventTagsWarmUp(cacheHandler, eventTags) {\n  const array = await eventTags.limit(cacheHandler.maxSize).toArray();\n  for (const event of array) {\n    cacheHandler.add(event.tagValue, event.eventId, false);\n  }\n}\nvar eventTagsDump = (eventTags, debug) => {\n  return async (dirtyKeys, cache) => {\n    const entries = [];\n    for (const tagValue of dirtyKeys) {\n      const eventIds = cache.get(tagValue);\n      if (eventIds) {\n        for (const eventId of eventIds) entries.push({ tagValue, eventId });\n      }\n    }\n    if (entries.length > 0) {\n      debug(`Saving ${entries.length} events cache entries to database`);\n      await eventTags.bulkPut(entries);\n    }\n    dirtyKeys.clear();\n  };\n};\n\n// src/caches/events.ts\nasync function eventsWarmUp(cacheHandler, events) {\n  const array = await events.limit(cacheHandler.maxSize).toArray();\n  for (const event of array) {\n    cacheHandler.set(event.id, event, false);\n  }\n}\nvar eventsDump = (events, debug) => {\n  return async (dirtyKeys, cache) => {\n    const entries = [];\n    for (const event of dirtyKeys) {\n      const entry = cache.get(event);\n      if (entry) entries.push(entry);\n    }\n    if (entries.length > 0) {\n      debug(`Saving ${entries.length} events cache entries to database`);\n      await events.bulkPut(entries);\n    }\n    dirtyKeys.clear();\n  };\n};\n\n// src/caches/nip05.ts\nasync function nip05WarmUp(cacheHandler, nip05s) {\n  const array = await nip05s.limit(cacheHandler.maxSize).toArray();\n  for (const nip05 of array) {\n    cacheHandler.set(nip05.nip05, nip05, false);\n  }\n}\nvar nip05Dump = (nip05s, debug) => {\n  return async (dirtyKeys, cache) => {\n    const entries = [];\n    for (const nip05 of dirtyKeys) {\n      const entry = cache.get(nip05);\n      if (entry) {\n        entries.push({\n          nip05,\n          ...entry\n        });\n      }\n    }\n    if (entries.length) {\n      debug(`Saving ${entries.length} NIP-05 cache entries to database`);\n      await nip05s.bulkPut(entries);\n    }\n    dirtyKeys.clear();\n  };\n};\n\n// src/db.ts\n\nvar Database = class extends dexie__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n  profiles;\n  events;\n  eventTags;\n  nip05;\n  lnurl;\n  relayStatus;\n  unpublishedEvents;\n  constructor(name) {\n    super(name);\n    this.version(15).stores({\n      profiles: \"&pubkey\",\n      events: \"&id, kind\",\n      eventTags: \"&tagValue\",\n      nip05: \"&nip05\",\n      lnurl: \"&pubkey\",\n      relayStatus: \"&url\",\n      unpublishedEvents: \"&id\"\n    });\n  }\n};\nvar db;\nfunction createDatabase(name) {\n  db = new Database(name);\n}\n\n// src/caches/profiles.ts\n\nvar d = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:dexie-adapter:profiles\");\nasync function profilesWarmUp(cacheHandler, profiles) {\n  const array = await profiles.limit(cacheHandler.maxSize).toArray();\n  for (const user of array) {\n    const obj = user;\n    cacheHandler.set(user.pubkey, obj, false);\n  }\n  d(\"Loaded %d profiles from database\", cacheHandler.size());\n}\nvar profilesDump = (profiles, debug) => {\n  return async (dirtyKeys, cache) => {\n    const entries = [];\n    for (const pubkey of dirtyKeys) {\n      const entry = cache.get(pubkey);\n      if (entry) {\n        entries.push(entry);\n      }\n    }\n    if (entries.length) {\n      debug(`Saving ${entries.length} users to database`);\n      await profiles.bulkPut(entries);\n    }\n    dirtyKeys.clear();\n  };\n};\n\n// src/caches/relay-info.ts\nasync function relayInfoWarmUp(cacheHandler, relayStatus) {\n  const array = await relayStatus.limit(cacheHandler.maxSize).toArray();\n  for (const entry of array) {\n    cacheHandler.set(\n      entry.url,\n      {\n        url: entry.url,\n        updatedAt: entry.updatedAt,\n        lastConnectedAt: entry.lastConnectedAt,\n        dontConnectBefore: entry.dontConnectBefore\n      },\n      false\n    );\n  }\n}\nvar relayInfoDump = (relayStatus, debug) => {\n  return async (dirtyKeys, cache) => {\n    const entries = [];\n    for (const url of dirtyKeys) {\n      const info = cache.get(url);\n      if (info) {\n        entries.push({\n          url,\n          updatedAt: info.updatedAt,\n          lastConnectedAt: info.lastConnectedAt,\n          dontConnectBefore: info.dontConnectBefore\n        });\n      }\n    }\n    if (entries.length > 0) {\n      debug(`Saving ${entries.length} relay status cache entries to database`);\n      await relayStatus.bulkPut(entries);\n    }\n    dirtyKeys.clear();\n  };\n};\n\n// src/caches/unpublished-events.ts\n\nvar WRITE_STATUS_THRESHOLD = 3;\nasync function unpublishedEventsWarmUp(cacheHandler, unpublishedEvents) {\n  await unpublishedEvents.each((unpublishedEvent) => {\n    cacheHandler.set(unpublishedEvent.event.id, unpublishedEvent, false);\n  });\n}\nfunction unpublishedEventsDump(unpublishedEvents, debug) {\n  return async (dirtyKeys, cache) => {\n    const entries = [];\n    for (const eventId of dirtyKeys) {\n      const entry = cache.get(eventId);\n      if (entry) {\n        entries.push(entry);\n      }\n    }\n    if (entries.length > 0) {\n      debug(`Saving ${entries.length} unpublished events cache entries to database`);\n      await unpublishedEvents.bulkPut(entries);\n    }\n    dirtyKeys.clear();\n  };\n}\nasync function discardUnpublishedEvent(unpublishedEvents, eventId) {\n  await unpublishedEvents.delete(eventId);\n}\nasync function getUnpublishedEvents(unpublishedEvents) {\n  const events = [];\n  await unpublishedEvents.each((unpublishedEvent) => {\n    events.push({\n      event: new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKEvent(void 0, unpublishedEvent.event),\n      relays: Object.keys(unpublishedEvent.relays),\n      lastTryAt: unpublishedEvent.lastTryAt\n    });\n  });\n  return events;\n}\nfunction addUnpublishedEvent(event, relays) {\n  const r = {};\n  relays.forEach((url) => r[url] = false);\n  this.unpublishedEvents.set(event.id, { id: event.id, event: event.rawEvent(), relays: r });\n  const onPublished = (relay) => {\n    const url = relay.url;\n    const existingEntry = this.unpublishedEvents.get(event.id);\n    if (!existingEntry) {\n      event.off(\"publushed\", onPublished);\n      return;\n    }\n    existingEntry.relays[url] = true;\n    this.unpublishedEvents.set(event.id, existingEntry);\n    const successWrites = Object.values(existingEntry.relays).filter((v) => v).length;\n    const unsuccessWrites = Object.values(existingEntry.relays).length - successWrites;\n    if (successWrites >= WRITE_STATUS_THRESHOLD || unsuccessWrites === 0) {\n      this.unpublishedEvents.delete(event.id);\n      event.off(\"published\", onPublished);\n    }\n  };\n  event.on(\"published\", onPublished);\n}\n\n// src/caches/zapper.ts\nasync function zapperWarmUp(cacheHandler, lnurls) {\n  const array = await lnurls.limit(cacheHandler.maxSize).toArray();\n  for (const lnurl of array) {\n    cacheHandler.set(lnurl.pubkey, { document: lnurl.document, fetchedAt: lnurl.fetchedAt }, false);\n  }\n}\nvar zapperDump = (lnurls, debug) => {\n  return async (dirtyKeys, cache) => {\n    const entries = [];\n    for (const pubkey of dirtyKeys) {\n      const entry = cache.get(pubkey);\n      if (entry) {\n        entries.push({\n          pubkey,\n          ...entry\n        });\n      }\n    }\n    if (entries.length) {\n      debug(`Saving ${entries.length} zapper cache entries to database`);\n      await lnurls.bulkPut(entries);\n    }\n    dirtyKeys.clear();\n  };\n};\n\n// src/lru-cache.ts\n\nvar CacheHandler = class {\n  cache;\n  dirtyKeys = /* @__PURE__ */ new Set();\n  options;\n  debug;\n  indexes;\n  isSet = false;\n  maxSize = 0;\n  constructor(options) {\n    this.debug = options.debug;\n    this.options = options;\n    this.maxSize = options.maxSize;\n    if (options.maxSize > 0) {\n      this.cache = new typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({ maxSize: options.maxSize });\n      setInterval(() => this.dump().catch(console.error), 1e3 * 10);\n    }\n    this.indexes = /* @__PURE__ */ new Map();\n  }\n  getSet(key) {\n    return this.cache?.get(key);\n  }\n  /**\n   * Get all entries that match the filter.\n   */\n  getAllWithFilter(filter) {\n    const ret = /* @__PURE__ */ new Map();\n    this.cache?.forEach((val, key) => {\n      if (filter(key, val)) {\n        ret.set(key, val);\n      }\n    });\n    return ret;\n  }\n  get(key) {\n    return this.cache?.get(key);\n  }\n  async getWithFallback(key, table) {\n    let entry = this.get(key);\n    if (!entry) {\n      entry = await table.get(key);\n      if (entry) {\n        this.set(key, entry);\n      }\n    }\n    return entry;\n  }\n  async getManyWithFallback(keys, table) {\n    const entries = [];\n    const missingKeys = [];\n    for (const key of keys) {\n      const entry = this.get(key);\n      if (entry) entries.push(entry);\n      else missingKeys.push(key);\n    }\n    if (entries.length > 0) {\n      this.debug(`Cache hit for keys ${entries.length} and miss for ${missingKeys.length} keys`);\n    }\n    if (missingKeys.length > 0) {\n      const startTime = Date.now();\n      const missingEntries = await table.bulkGet(missingKeys);\n      const endTime = Date.now();\n      let foundKeys = 0;\n      for (const entry of missingEntries) {\n        if (entry) {\n          this.set(entry.id, entry);\n          entries.push(entry);\n          foundKeys++;\n        }\n      }\n      this.debug(\n        `Time spent querying database: ${endTime - startTime}ms for ${missingKeys.length} keys, which added ${foundKeys} entries to the cache`\n      );\n    }\n    return entries;\n  }\n  add(key, value, dirty = true) {\n    const existing = this.get(key) ?? /* @__PURE__ */ new Set();\n    existing.add(value);\n    this.cache?.set(key, existing);\n    if (dirty) this.dirtyKeys.add(key);\n  }\n  set(key, value, dirty = true) {\n    this.cache?.set(key, value);\n    if (dirty) this.dirtyKeys.add(key);\n    for (const [attribute, index] of this.indexes.entries()) {\n      const indexKey = value[attribute];\n      if (indexKey) {\n        const indexValue = index.get(indexKey) || /* @__PURE__ */ new Set();\n        indexValue.add(key);\n        index.set(indexKey, indexValue);\n      }\n    }\n  }\n  size() {\n    return this.cache?.size || 0;\n  }\n  delete(key) {\n    this.cache?.delete(key);\n    this.dirtyKeys.add(key);\n  }\n  async dump() {\n    if (this.dirtyKeys.size > 0 && this.cache) {\n      await this.options.dump(this.dirtyKeys, this.cache);\n      this.dirtyKeys.clear();\n    }\n  }\n  addIndex(attribute) {\n    this.indexes.set(attribute, new typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({ maxSize: this.options.maxSize }));\n  }\n  getFromIndex(index, key) {\n    const ret = /* @__PURE__ */ new Set();\n    const indexValues = this.indexes.get(index);\n    if (indexValues) {\n      const values = indexValues.get(key);\n      if (values) {\n        for (const key2 of values.values()) {\n          const entry = this.get(key2);\n          if (entry) ret.add(entry);\n        }\n      }\n    }\n    return ret;\n  }\n};\n\n// src/index.ts\nvar INDEXABLE_TAGS_LIMIT = 10;\nvar NDKCacheAdapterDexie = class {\n  debug;\n  locking = false;\n  ready = false;\n  profiles;\n  zappers;\n  nip05s;\n  events;\n  eventTags;\n  relayInfo;\n  unpublishedEvents;\n  warmedUp = false;\n  warmUpPromise;\n  devMode = false;\n  saveSig;\n  _onReady;\n  constructor(opts = {}) {\n    createDatabase(opts.dbName || \"ndk\");\n    this.debug = opts.debug || debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:dexie-adapter\");\n    this.saveSig = opts.saveSig || false;\n    this.profiles = new CacheHandler({\n      maxSize: opts.profileCacheSize || 1e5,\n      dump: profilesDump(db.profiles, this.debug),\n      debug: this.debug\n    });\n    this.zappers = new CacheHandler({\n      maxSize: opts.zapperCacheSize || 200,\n      dump: zapperDump(db.lnurl, this.debug),\n      debug: this.debug\n    });\n    this.nip05s = new CacheHandler({\n      maxSize: opts.nip05CacheSize || 1e3,\n      dump: nip05Dump(db.nip05, this.debug),\n      debug: this.debug\n    });\n    this.events = new CacheHandler({\n      maxSize: opts.eventCacheSize || 5e4,\n      dump: eventsDump(db.events, this.debug),\n      debug: this.debug\n    });\n    this.events.addIndex(\"pubkey\");\n    this.events.addIndex(\"kind\");\n    this.eventTags = new CacheHandler({\n      maxSize: opts.eventTagsCacheSize || 1e5,\n      dump: eventTagsDump(db.eventTags, this.debug),\n      debug: this.debug\n    });\n    this.relayInfo = new CacheHandler({\n      maxSize: 500,\n      debug: this.debug,\n      dump: relayInfoDump(db.relayStatus, this.debug)\n    });\n    this.unpublishedEvents = new CacheHandler({\n      maxSize: 5e3,\n      debug: this.debug,\n      dump: unpublishedEventsDump(db.unpublishedEvents, this.debug)\n    });\n    const profile = (label, fn) => {\n      const start = Date.now();\n      return fn().then(() => {\n        const end = Date.now();\n        this.debug(label, \"took\", end - start, \"ms\");\n      });\n    };\n    const startTime = Date.now();\n    this.warmUpPromise = Promise.allSettled([\n      profile(\"profilesWarmUp\", () => profilesWarmUp(this.profiles, db.profiles)),\n      profile(\"zapperWarmUp\", () => zapperWarmUp(this.zappers, db.lnurl)),\n      profile(\"nip05WarmUp\", () => nip05WarmUp(this.nip05s, db.nip05)),\n      profile(\"relayInfoWarmUp\", () => relayInfoWarmUp(this.relayInfo, db.relayStatus)),\n      profile(\n        \"unpublishedEventsWarmUp\",\n        () => unpublishedEventsWarmUp(this.unpublishedEvents, db.unpublishedEvents)\n      ),\n      profile(\"eventsWarmUp\", () => eventsWarmUp(this.events, db.events)),\n      profile(\"eventTagsWarmUp\", () => eventTagsWarmUp(this.eventTags, db.eventTags))\n    ]);\n    this.warmUpPromise.then(() => {\n      const endTime = Date.now();\n      this.warmedUp = true;\n      this.ready = true;\n      this.locking = true;\n      this.debug(\"Warm up completed, time\", endTime - startTime, \"ms\");\n      if (this._onReady) this._onReady();\n    });\n  }\n  onReady(callback) {\n    this._onReady = callback;\n  }\n  async query(subscription) {\n    if (!this.warmedUp) {\n      const startTime2 = Date.now();\n      await this.warmUpPromise;\n      this.debug(\"froze query for\", Date.now() - startTime2, \"ms\", subscription.filters);\n    }\n    const startTime = Date.now();\n    subscription.filters.map((filter) => this.processFilter(filter, subscription));\n    const dur = Date.now() - startTime;\n    if (dur > 100) this.debug(\"query took\", dur, \"ms\", subscription.filter);\n    return [];\n  }\n  async fetchProfile(pubkey) {\n    if (!this.profiles) return null;\n    const user = await this.profiles.getWithFallback(pubkey, db.profiles);\n    return user;\n  }\n  fetchProfileSync(pubkey) {\n    if (!this.profiles) return null;\n    const user = this.profiles.get(pubkey);\n    return user;\n  }\n  async getProfiles(fn) {\n    if (!this.profiles) return;\n    return this.profiles.getAllWithFilter(fn);\n  }\n  saveProfile(pubkey, profile) {\n    const existingValue = this.profiles.get(pubkey);\n    if (existingValue?.created_at && profile.created_at && existingValue.created_at >= profile.created_at) {\n      return;\n    }\n    const cachedAt = Math.floor(Date.now() / 1e3);\n    this.profiles.set(pubkey, { pubkey, ...profile, cachedAt });\n    this.debug(\"Saved profile for pubkey\", pubkey, profile);\n  }\n  async loadNip05(nip05, maxAgeForMissing = 3600) {\n    const cache = this.nip05s?.get(nip05);\n    if (cache) {\n      if (cache.profile === null) {\n        if (cache.fetchedAt + maxAgeForMissing * 1e3 < Date.now()) return \"missing\";\n        return null;\n      }\n      try {\n        return JSON.parse(cache.profile);\n      } catch (_e) {\n        return \"missing\";\n      }\n    }\n    const nip = await db.nip05.get({ nip05 });\n    if (!nip) return \"missing\";\n    const now = Date.now();\n    if (nip.profile === null) {\n      if (nip.fetchedAt + maxAgeForMissing * 1e3 < now) return \"missing\";\n      return null;\n    }\n    try {\n      return JSON.parse(nip.profile);\n    } catch (_e) {\n      return \"missing\";\n    }\n  }\n  async saveNip05(nip05, profile) {\n    try {\n      const document = profile ? JSON.stringify(profile) : null;\n      this.nip05s.set(nip05, { profile: document, fetchedAt: Date.now() });\n    } catch (error) {\n      console.error(\"Failed to save NIP-05 profile for nip05:\", nip05, error);\n    }\n  }\n  async loadUsersLNURLDoc(pubkey, maxAgeInSecs = 86400, maxAgeForMissing = 3600) {\n    const cache = this.zappers?.get(pubkey);\n    if (cache) {\n      if (cache.document === null) {\n        if (cache.fetchedAt + maxAgeForMissing * 1e3 < Date.now()) return \"missing\";\n        return null;\n      }\n      try {\n        return JSON.parse(cache.document);\n      } catch (_e) {\n        return \"missing\";\n      }\n    }\n    const lnurl = await db.lnurl.get({ pubkey });\n    if (!lnurl) return \"missing\";\n    const now = Date.now();\n    if (lnurl.fetchedAt + maxAgeInSecs * 1e3 < now) return \"missing\";\n    if (lnurl.document === null) {\n      if (lnurl.fetchedAt + maxAgeForMissing * 1e3 < now) return \"missing\";\n      return null;\n    }\n    try {\n      return JSON.parse(lnurl.document);\n    } catch (_e) {\n      return \"missing\";\n    }\n  }\n  async saveUsersLNURLDoc(pubkey, doc) {\n    try {\n      const document = doc ? JSON.stringify(doc) : null;\n      this.zappers?.set(pubkey, { document, fetchedAt: Date.now() });\n    } catch (error) {\n      console.error(\"Failed to save LNURL document for pubkey:\", pubkey, error);\n    }\n  }\n  processFilter(filter, subscription) {\n    const _filter = { ...filter };\n    _filter.limit = void 0;\n    const filterKeys = new Set(Object.keys(_filter || {}));\n    filterKeys.delete(\"since\");\n    filterKeys.delete(\"limit\");\n    filterKeys.delete(\"until\");\n    try {\n      if (this.byNip33Query(filterKeys, filter, subscription)) return;\n      if (this.byAuthors(filter, subscription)) return;\n      if (this.byIdsQuery(filter, subscription)) return;\n      if (this.byTags(filter, subscription)) return;\n      if (this.byKinds(filterKeys, filter, subscription)) return;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n  async deleteEventIds(eventIds) {\n    eventIds.forEach((id) => this.events.delete(id));\n    await db.events.where({ id: eventIds }).delete();\n  }\n  addUnpublishedEvent = addUnpublishedEvent.bind(this);\n  getUnpublishedEvents = () => getUnpublishedEvents(db.unpublishedEvents);\n  discardUnpublishedEvent = (id) => discardUnpublishedEvent(db.unpublishedEvents, id);\n  async setEvent(event, _filters, relay) {\n    if (event.kind === 0) {\n      if (!this.profiles) return;\n      try {\n        const profile = (0,_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.profileFromEvent)(event);\n        this.saveProfile(event.pubkey, profile);\n      } catch {\n        this.debug(`Failed to save profile for pubkey: ${event.pubkey}`);\n      }\n    }\n    let addEvent = true;\n    if (event.isParamReplaceable()) {\n      const existingEvent = this.events.get(event.tagId());\n      if (existingEvent && event.created_at && existingEvent.createdAt > event.created_at) {\n        addEvent = false;\n      }\n    }\n    if (addEvent) {\n      const eventData = {\n        id: event.tagId(),\n        pubkey: event.pubkey,\n        kind: event.kind,\n        createdAt: event.created_at,\n        relay: relay?.url,\n        event: event.serialize(this.saveSig, true)\n      };\n      if (this.saveSig && event.sig) {\n        eventData.sig = event.sig;\n      }\n      this.events.set(event.tagId(), eventData);\n      const indexableTags = getIndexableTags(event);\n      for (const tag of indexableTags) {\n        this.eventTags.add(tag[0] + tag[1], event.tagId());\n      }\n    }\n  }\n  updateRelayStatus(url, info) {\n    const val = { url, updatedAt: Date.now(), ...info };\n    this.relayInfo.set(url, val);\n  }\n  getRelayStatus(url) {\n    const a = this.relayInfo.get(url);\n    if (a) {\n      return {\n        lastConnectedAt: a.lastConnectedAt,\n        dontConnectBefore: a.dontConnectBefore\n      };\n    }\n  }\n  /**\n   * Searches by authors\n   */\n  byAuthors(filter, subscription) {\n    if (!filter.authors) return false;\n    let _total = 0;\n    for (const pubkey of filter.authors) {\n      let events = Array.from(this.events.getFromIndex(\"pubkey\", pubkey));\n      if (filter.kinds) events = events.filter((e) => filter.kinds?.includes(e.kind));\n      foundEvents(subscription, events, filter);\n      _total += events.length;\n    }\n    return true;\n  }\n  /**\n   * Searches by ids\n   */\n  byIdsQuery(filter, subscription) {\n    if (filter.ids) {\n      for (const id of filter.ids) {\n        const event = this.events.get(id);\n        if (event) foundEvent(subscription, event, event.relay, filter);\n      }\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Searches by NIP-33\n   */\n  byNip33Query(filterKeys, filter, subscription) {\n    const f = [\"#d\", \"authors\", \"kinds\"];\n    const hasAllKeys = filterKeys.size === f.length && f.every((k) => filterKeys.has(k));\n    if (hasAllKeys && filter.kinds && filter.authors) {\n      for (const kind of filter.kinds) {\n        const replaceableKind = kind >= 3e4 && kind < 4e4;\n        if (!replaceableKind) continue;\n        for (const author of filter.authors) {\n          for (const dTag of filter[\"#d\"]) {\n            const replaceableId = `${kind}:${author}:${dTag}`;\n            const event = this.events.get(replaceableId);\n            if (event) foundEvent(subscription, event, event.relay, filter);\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Searches by tags and optionally filters by tags\n   */\n  byTags(filter, subscription) {\n    const tagFilters = Object.entries(filter).filter(([filter2]) => filter2.startsWith(\"#\") && filter2.length === 2).map(([filter2, values]) => [filter2[1], values]);\n    if (tagFilters.length === 0) return false;\n    for (const [tag, values] of tagFilters) {\n      for (const value of values) {\n        const tagValue = tag + value;\n        const eventIds = this.eventTags.getSet(tagValue);\n        if (!eventIds) continue;\n        eventIds.forEach((id) => {\n          const event = this.events.get(id);\n          if (!event) return;\n          if (!filter.kinds || filter.kinds.includes(event.kind)) {\n            foundEvent(subscription, event, event.relay, filter);\n          }\n        });\n      }\n    }\n    return true;\n  }\n  byKinds(filterKeys, filter, subscription) {\n    if (!filter.kinds || filterKeys.size !== 1 || !filterKeys.has(\"kinds\")) return false;\n    const limit = filter.limit || 500;\n    let totalEvents = 0;\n    const processedEventIds = /* @__PURE__ */ new Set();\n    const sortedKinds = [...filter.kinds].sort(\n      (a, b) => (this.events.indexes.get(\"kind\")?.get(a)?.size || 0) - (this.events.indexes.get(\"kind\")?.get(b)?.size || 0)\n    );\n    for (const kind of sortedKinds) {\n      const events = this.events.getFromIndex(\"kind\", kind);\n      for (const event of events) {\n        if (processedEventIds.has(event.id)) continue;\n        processedEventIds.add(event.id);\n        foundEvent(subscription, event, event.relay, filter);\n        totalEvents++;\n        if (totalEvents >= limit) break;\n      }\n      if (totalEvents >= limit) break;\n    }\n    return true;\n  }\n};\nfunction foundEvents(subscription, events, filter) {\n  if (filter?.limit && events.length > filter.limit) {\n    events = events.sort((a, b) => b.createdAt - a.createdAt).slice(0, filter.limit);\n  }\n  for (const event of events) {\n    foundEvent(subscription, event, event.relay, filter);\n  }\n}\nfunction foundEvent(subscription, event, relayUrl, filter) {\n  try {\n    const deserializedEvent = (0,_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.deserialize)(event.event);\n    if (filter && !(0,nostr_tools__WEBPACK_IMPORTED_MODULE_4__.matchFilter)(filter, deserializedEvent)) return;\n    const ndkEvent = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKEvent(void 0, deserializedEvent);\n    const relay = relayUrl ? subscription.pool.getRelay(relayUrl, false) : void 0;\n    ndkEvent.relay = relay;\n    subscription.eventReceived(ndkEvent, relay, true);\n  } catch (e) {\n    console.error(\"failed to deserialize event\", e);\n  }\n}\nfunction getIndexableTags(event) {\n  const indexableTags = [];\n  if (event.kind === 3) return [];\n  for (const tag of event.tags) {\n    if (tag[0].length !== 1) continue;\n    indexableTags.push(tag);\n    if (indexableTags.length >= INDEXABLE_TAGS_LIMIT) return [];\n  }\n  return indexableTags;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQzBGO0FBQ3pEO0FBQ1M7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG1CQUFtQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMwQjtBQUMxQiw2QkFBNkIsNkNBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDZ0M7QUFDaEMsUUFBUSxrQ0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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LE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvRUFBZ0I7QUFDeEM7QUFDQSxRQUFRO0FBQ1IseURBQXlELGFBQWE7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUssR0FBRyxPQUFPLEdBQUcsS0FBSztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrREFBVztBQUN6QyxtQkFBbUIsd0RBQVc7QUFDOUIseUJBQXlCLHdEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1FIiwic291cmNlcyI6WyIvVXNlcnMvcGFibG9mZXJuYW5kZXovdGVzdDEyMy9URU5FWC1wZmttYzkvbWFpbi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgTkRLRXZlbnQgYXMgTkRLRXZlbnQyLCBkZXNlcmlhbGl6ZSwgcHJvZmlsZUZyb21FdmVudCB9IGZyb20gXCJAbm9zdHItZGV2LWtpdC9uZGtcIjtcbmltcG9ydCBjcmVhdGVEZWJ1ZzIgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBtYXRjaEZpbHRlciB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuXG4vLyBzcmMvY2FjaGVzL2V2ZW50LXRhZ3MudHNcbmFzeW5jIGZ1bmN0aW9uIGV2ZW50VGFnc1dhcm1VcChjYWNoZUhhbmRsZXIsIGV2ZW50VGFncykge1xuICBjb25zdCBhcnJheSA9IGF3YWl0IGV2ZW50VGFncy5saW1pdChjYWNoZUhhbmRsZXIubWF4U2l6ZSkudG9BcnJheSgpO1xuICBmb3IgKGNvbnN0IGV2ZW50IG9mIGFycmF5KSB7XG4gICAgY2FjaGVIYW5kbGVyLmFkZChldmVudC50YWdWYWx1ZSwgZXZlbnQuZXZlbnRJZCwgZmFsc2UpO1xuICB9XG59XG52YXIgZXZlbnRUYWdzRHVtcCA9IChldmVudFRhZ3MsIGRlYnVnKSA9PiB7XG4gIHJldHVybiBhc3luYyAoZGlydHlLZXlzLCBjYWNoZSkgPT4ge1xuICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIG9mIGRpcnR5S2V5cykge1xuICAgICAgY29uc3QgZXZlbnRJZHMgPSBjYWNoZS5nZXQodGFnVmFsdWUpO1xuICAgICAgaWYgKGV2ZW50SWRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnRJZCBvZiBldmVudElkcykgZW50cmllcy5wdXNoKHsgdGFnVmFsdWUsIGV2ZW50SWQgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGRlYnVnKGBTYXZpbmcgJHtlbnRyaWVzLmxlbmd0aH0gZXZlbnRzIGNhY2hlIGVudHJpZXMgdG8gZGF0YWJhc2VgKTtcbiAgICAgIGF3YWl0IGV2ZW50VGFncy5idWxrUHV0KGVudHJpZXMpO1xuICAgIH1cbiAgICBkaXJ0eUtleXMuY2xlYXIoKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9jYWNoZXMvZXZlbnRzLnRzXG5hc3luYyBmdW5jdGlvbiBldmVudHNXYXJtVXAoY2FjaGVIYW5kbGVyLCBldmVudHMpIHtcbiAgY29uc3QgYXJyYXkgPSBhd2FpdCBldmVudHMubGltaXQoY2FjaGVIYW5kbGVyLm1heFNpemUpLnRvQXJyYXkoKTtcbiAgZm9yIChjb25zdCBldmVudCBvZiBhcnJheSkge1xuICAgIGNhY2hlSGFuZGxlci5zZXQoZXZlbnQuaWQsIGV2ZW50LCBmYWxzZSk7XG4gIH1cbn1cbnZhciBldmVudHNEdW1wID0gKGV2ZW50cywgZGVidWcpID0+IHtcbiAgcmV0dXJuIGFzeW5jIChkaXJ0eUtleXMsIGNhY2hlKSA9PiB7XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZGlydHlLZXlzKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGNhY2hlLmdldChldmVudCk7XG4gICAgICBpZiAoZW50cnkpIGVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgfVxuICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGRlYnVnKGBTYXZpbmcgJHtlbnRyaWVzLmxlbmd0aH0gZXZlbnRzIGNhY2hlIGVudHJpZXMgdG8gZGF0YWJhc2VgKTtcbiAgICAgIGF3YWl0IGV2ZW50cy5idWxrUHV0KGVudHJpZXMpO1xuICAgIH1cbiAgICBkaXJ0eUtleXMuY2xlYXIoKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9jYWNoZXMvbmlwMDUudHNcbmFzeW5jIGZ1bmN0aW9uIG5pcDA1V2FybVVwKGNhY2hlSGFuZGxlciwgbmlwMDVzKSB7XG4gIGNvbnN0IGFycmF5ID0gYXdhaXQgbmlwMDVzLmxpbWl0KGNhY2hlSGFuZGxlci5tYXhTaXplKS50b0FycmF5KCk7XG4gIGZvciAoY29uc3QgbmlwMDUgb2YgYXJyYXkpIHtcbiAgICBjYWNoZUhhbmRsZXIuc2V0KG5pcDA1Lm5pcDA1LCBuaXAwNSwgZmFsc2UpO1xuICB9XG59XG52YXIgbmlwMDVEdW1wID0gKG5pcDA1cywgZGVidWcpID0+IHtcbiAgcmV0dXJuIGFzeW5jIChkaXJ0eUtleXMsIGNhY2hlKSA9PiB7XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbmlwMDUgb2YgZGlydHlLZXlzKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGNhY2hlLmdldChuaXAwNSk7XG4gICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgZW50cmllcy5wdXNoKHtcbiAgICAgICAgICBuaXAwNSxcbiAgICAgICAgICAuLi5lbnRyeVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICBkZWJ1ZyhgU2F2aW5nICR7ZW50cmllcy5sZW5ndGh9IE5JUC0wNSBjYWNoZSBlbnRyaWVzIHRvIGRhdGFiYXNlYCk7XG4gICAgICBhd2FpdCBuaXAwNXMuYnVsa1B1dChlbnRyaWVzKTtcbiAgICB9XG4gICAgZGlydHlLZXlzLmNsZWFyKCk7XG4gIH07XG59O1xuXG4vLyBzcmMvZGIudHNcbmltcG9ydCBEZXhpZSBmcm9tIFwiZGV4aWVcIjtcbnZhciBEYXRhYmFzZSA9IGNsYXNzIGV4dGVuZHMgRGV4aWUge1xuICBwcm9maWxlcztcbiAgZXZlbnRzO1xuICBldmVudFRhZ3M7XG4gIG5pcDA1O1xuICBsbnVybDtcbiAgcmVsYXlTdGF0dXM7XG4gIHVucHVibGlzaGVkRXZlbnRzO1xuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgc3VwZXIobmFtZSk7XG4gICAgdGhpcy52ZXJzaW9uKDE1KS5zdG9yZXMoe1xuICAgICAgcHJvZmlsZXM6IFwiJnB1YmtleVwiLFxuICAgICAgZXZlbnRzOiBcIiZpZCwga2luZFwiLFxuICAgICAgZXZlbnRUYWdzOiBcIiZ0YWdWYWx1ZVwiLFxuICAgICAgbmlwMDU6IFwiJm5pcDA1XCIsXG4gICAgICBsbnVybDogXCImcHVia2V5XCIsXG4gICAgICByZWxheVN0YXR1czogXCImdXJsXCIsXG4gICAgICB1bnB1Ymxpc2hlZEV2ZW50czogXCImaWRcIlxuICAgIH0pO1xuICB9XG59O1xudmFyIGRiO1xuZnVuY3Rpb24gY3JlYXRlRGF0YWJhc2UobmFtZSkge1xuICBkYiA9IG5ldyBEYXRhYmFzZShuYW1lKTtcbn1cblxuLy8gc3JjL2NhY2hlcy9wcm9maWxlcy50c1xuaW1wb3J0IGNyZWF0ZURlYnVnIGZyb20gXCJkZWJ1Z1wiO1xudmFyIGQgPSBjcmVhdGVEZWJ1ZyhcIm5kazpkZXhpZS1hZGFwdGVyOnByb2ZpbGVzXCIpO1xuYXN5bmMgZnVuY3Rpb24gcHJvZmlsZXNXYXJtVXAoY2FjaGVIYW5kbGVyLCBwcm9maWxlcykge1xuICBjb25zdCBhcnJheSA9IGF3YWl0IHByb2ZpbGVzLmxpbWl0KGNhY2hlSGFuZGxlci5tYXhTaXplKS50b0FycmF5KCk7XG4gIGZvciAoY29uc3QgdXNlciBvZiBhcnJheSkge1xuICAgIGNvbnN0IG9iaiA9IHVzZXI7XG4gICAgY2FjaGVIYW5kbGVyLnNldCh1c2VyLnB1YmtleSwgb2JqLCBmYWxzZSk7XG4gIH1cbiAgZChcIkxvYWRlZCAlZCBwcm9maWxlcyBmcm9tIGRhdGFiYXNlXCIsIGNhY2hlSGFuZGxlci5zaXplKCkpO1xufVxudmFyIHByb2ZpbGVzRHVtcCA9IChwcm9maWxlcywgZGVidWcpID0+IHtcbiAgcmV0dXJuIGFzeW5jIChkaXJ0eUtleXMsIGNhY2hlKSA9PiB7XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIGZvciAoY29uc3QgcHVia2V5IG9mIGRpcnR5S2V5cykge1xuICAgICAgY29uc3QgZW50cnkgPSBjYWNoZS5nZXQocHVia2V5KTtcbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIGRlYnVnKGBTYXZpbmcgJHtlbnRyaWVzLmxlbmd0aH0gdXNlcnMgdG8gZGF0YWJhc2VgKTtcbiAgICAgIGF3YWl0IHByb2ZpbGVzLmJ1bGtQdXQoZW50cmllcyk7XG4gICAgfVxuICAgIGRpcnR5S2V5cy5jbGVhcigpO1xuICB9O1xufTtcblxuLy8gc3JjL2NhY2hlcy9yZWxheS1pbmZvLnRzXG5hc3luYyBmdW5jdGlvbiByZWxheUluZm9XYXJtVXAoY2FjaGVIYW5kbGVyLCByZWxheVN0YXR1cykge1xuICBjb25zdCBhcnJheSA9IGF3YWl0IHJlbGF5U3RhdHVzLmxpbWl0KGNhY2hlSGFuZGxlci5tYXhTaXplKS50b0FycmF5KCk7XG4gIGZvciAoY29uc3QgZW50cnkgb2YgYXJyYXkpIHtcbiAgICBjYWNoZUhhbmRsZXIuc2V0KFxuICAgICAgZW50cnkudXJsLFxuICAgICAge1xuICAgICAgICB1cmw6IGVudHJ5LnVybCxcbiAgICAgICAgdXBkYXRlZEF0OiBlbnRyeS51cGRhdGVkQXQsXG4gICAgICAgIGxhc3RDb25uZWN0ZWRBdDogZW50cnkubGFzdENvbm5lY3RlZEF0LFxuICAgICAgICBkb250Q29ubmVjdEJlZm9yZTogZW50cnkuZG9udENvbm5lY3RCZWZvcmVcbiAgICAgIH0sXG4gICAgICBmYWxzZVxuICAgICk7XG4gIH1cbn1cbnZhciByZWxheUluZm9EdW1wID0gKHJlbGF5U3RhdHVzLCBkZWJ1ZykgPT4ge1xuICByZXR1cm4gYXN5bmMgKGRpcnR5S2V5cywgY2FjaGUpID0+IHtcbiAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgZm9yIChjb25zdCB1cmwgb2YgZGlydHlLZXlzKSB7XG4gICAgICBjb25zdCBpbmZvID0gY2FjaGUuZ2V0KHVybCk7XG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICBlbnRyaWVzLnB1c2goe1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICB1cGRhdGVkQXQ6IGluZm8udXBkYXRlZEF0LFxuICAgICAgICAgIGxhc3RDb25uZWN0ZWRBdDogaW5mby5sYXN0Q29ubmVjdGVkQXQsXG4gICAgICAgICAgZG9udENvbm5lY3RCZWZvcmU6IGluZm8uZG9udENvbm5lY3RCZWZvcmVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGRlYnVnKGBTYXZpbmcgJHtlbnRyaWVzLmxlbmd0aH0gcmVsYXkgc3RhdHVzIGNhY2hlIGVudHJpZXMgdG8gZGF0YWJhc2VgKTtcbiAgICAgIGF3YWl0IHJlbGF5U3RhdHVzLmJ1bGtQdXQoZW50cmllcyk7XG4gICAgfVxuICAgIGRpcnR5S2V5cy5jbGVhcigpO1xuICB9O1xufTtcblxuLy8gc3JjL2NhY2hlcy91bnB1Ymxpc2hlZC1ldmVudHMudHNcbmltcG9ydCB7IE5ES0V2ZW50IH0gZnJvbSBcIkBub3N0ci1kZXYta2l0L25ka1wiO1xudmFyIFdSSVRFX1NUQVRVU19USFJFU0hPTEQgPSAzO1xuYXN5bmMgZnVuY3Rpb24gdW5wdWJsaXNoZWRFdmVudHNXYXJtVXAoY2FjaGVIYW5kbGVyLCB1bnB1Ymxpc2hlZEV2ZW50cykge1xuICBhd2FpdCB1bnB1Ymxpc2hlZEV2ZW50cy5lYWNoKCh1bnB1Ymxpc2hlZEV2ZW50KSA9PiB7XG4gICAgY2FjaGVIYW5kbGVyLnNldCh1bnB1Ymxpc2hlZEV2ZW50LmV2ZW50LmlkLCB1bnB1Ymxpc2hlZEV2ZW50LCBmYWxzZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdW5wdWJsaXNoZWRFdmVudHNEdW1wKHVucHVibGlzaGVkRXZlbnRzLCBkZWJ1Zykge1xuICByZXR1cm4gYXN5bmMgKGRpcnR5S2V5cywgY2FjaGUpID0+IHtcbiAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgZm9yIChjb25zdCBldmVudElkIG9mIGRpcnR5S2V5cykge1xuICAgICAgY29uc3QgZW50cnkgPSBjYWNoZS5nZXQoZXZlbnRJZCk7XG4gICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgZGVidWcoYFNhdmluZyAke2VudHJpZXMubGVuZ3RofSB1bnB1Ymxpc2hlZCBldmVudHMgY2FjaGUgZW50cmllcyB0byBkYXRhYmFzZWApO1xuICAgICAgYXdhaXQgdW5wdWJsaXNoZWRFdmVudHMuYnVsa1B1dChlbnRyaWVzKTtcbiAgICB9XG4gICAgZGlydHlLZXlzLmNsZWFyKCk7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBkaXNjYXJkVW5wdWJsaXNoZWRFdmVudCh1bnB1Ymxpc2hlZEV2ZW50cywgZXZlbnRJZCkge1xuICBhd2FpdCB1bnB1Ymxpc2hlZEV2ZW50cy5kZWxldGUoZXZlbnRJZCk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRVbnB1Ymxpc2hlZEV2ZW50cyh1bnB1Ymxpc2hlZEV2ZW50cykge1xuICBjb25zdCBldmVudHMgPSBbXTtcbiAgYXdhaXQgdW5wdWJsaXNoZWRFdmVudHMuZWFjaCgodW5wdWJsaXNoZWRFdmVudCkgPT4ge1xuICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgIGV2ZW50OiBuZXcgTkRLRXZlbnQodm9pZCAwLCB1bnB1Ymxpc2hlZEV2ZW50LmV2ZW50KSxcbiAgICAgIHJlbGF5czogT2JqZWN0LmtleXModW5wdWJsaXNoZWRFdmVudC5yZWxheXMpLFxuICAgICAgbGFzdFRyeUF0OiB1bnB1Ymxpc2hlZEV2ZW50Lmxhc3RUcnlBdFxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGV2ZW50cztcbn1cbmZ1bmN0aW9uIGFkZFVucHVibGlzaGVkRXZlbnQoZXZlbnQsIHJlbGF5cykge1xuICBjb25zdCByID0ge307XG4gIHJlbGF5cy5mb3JFYWNoKCh1cmwpID0+IHJbdXJsXSA9IGZhbHNlKTtcbiAgdGhpcy51bnB1Ymxpc2hlZEV2ZW50cy5zZXQoZXZlbnQuaWQsIHsgaWQ6IGV2ZW50LmlkLCBldmVudDogZXZlbnQucmF3RXZlbnQoKSwgcmVsYXlzOiByIH0pO1xuICBjb25zdCBvblB1Ymxpc2hlZCA9IChyZWxheSkgPT4ge1xuICAgIGNvbnN0IHVybCA9IHJlbGF5LnVybDtcbiAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gdGhpcy51bnB1Ymxpc2hlZEV2ZW50cy5nZXQoZXZlbnQuaWQpO1xuICAgIGlmICghZXhpc3RpbmdFbnRyeSkge1xuICAgICAgZXZlbnQub2ZmKFwicHVibHVzaGVkXCIsIG9uUHVibGlzaGVkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXhpc3RpbmdFbnRyeS5yZWxheXNbdXJsXSA9IHRydWU7XG4gICAgdGhpcy51bnB1Ymxpc2hlZEV2ZW50cy5zZXQoZXZlbnQuaWQsIGV4aXN0aW5nRW50cnkpO1xuICAgIGNvbnN0IHN1Y2Nlc3NXcml0ZXMgPSBPYmplY3QudmFsdWVzKGV4aXN0aW5nRW50cnkucmVsYXlzKS5maWx0ZXIoKHYpID0+IHYpLmxlbmd0aDtcbiAgICBjb25zdCB1bnN1Y2Nlc3NXcml0ZXMgPSBPYmplY3QudmFsdWVzKGV4aXN0aW5nRW50cnkucmVsYXlzKS5sZW5ndGggLSBzdWNjZXNzV3JpdGVzO1xuICAgIGlmIChzdWNjZXNzV3JpdGVzID49IFdSSVRFX1NUQVRVU19USFJFU0hPTEQgfHwgdW5zdWNjZXNzV3JpdGVzID09PSAwKSB7XG4gICAgICB0aGlzLnVucHVibGlzaGVkRXZlbnRzLmRlbGV0ZShldmVudC5pZCk7XG4gICAgICBldmVudC5vZmYoXCJwdWJsaXNoZWRcIiwgb25QdWJsaXNoZWQpO1xuICAgIH1cbiAgfTtcbiAgZXZlbnQub24oXCJwdWJsaXNoZWRcIiwgb25QdWJsaXNoZWQpO1xufVxuXG4vLyBzcmMvY2FjaGVzL3phcHBlci50c1xuYXN5bmMgZnVuY3Rpb24gemFwcGVyV2FybVVwKGNhY2hlSGFuZGxlciwgbG51cmxzKSB7XG4gIGNvbnN0IGFycmF5ID0gYXdhaXQgbG51cmxzLmxpbWl0KGNhY2hlSGFuZGxlci5tYXhTaXplKS50b0FycmF5KCk7XG4gIGZvciAoY29uc3QgbG51cmwgb2YgYXJyYXkpIHtcbiAgICBjYWNoZUhhbmRsZXIuc2V0KGxudXJsLnB1YmtleSwgeyBkb2N1bWVudDogbG51cmwuZG9jdW1lbnQsIGZldGNoZWRBdDogbG51cmwuZmV0Y2hlZEF0IH0sIGZhbHNlKTtcbiAgfVxufVxudmFyIHphcHBlckR1bXAgPSAobG51cmxzLCBkZWJ1ZykgPT4ge1xuICByZXR1cm4gYXN5bmMgKGRpcnR5S2V5cywgY2FjaGUpID0+IHtcbiAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgZm9yIChjb25zdCBwdWJrZXkgb2YgZGlydHlLZXlzKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGNhY2hlLmdldChwdWJrZXkpO1xuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIGVudHJpZXMucHVzaCh7XG4gICAgICAgICAgcHVia2V5LFxuICAgICAgICAgIC4uLmVudHJ5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW50cmllcy5sZW5ndGgpIHtcbiAgICAgIGRlYnVnKGBTYXZpbmcgJHtlbnRyaWVzLmxlbmd0aH0gemFwcGVyIGNhY2hlIGVudHJpZXMgdG8gZGF0YWJhc2VgKTtcbiAgICAgIGF3YWl0IGxudXJscy5idWxrUHV0KGVudHJpZXMpO1xuICAgIH1cbiAgICBkaXJ0eUtleXMuY2xlYXIoKTtcbiAgfTtcbn07XG5cbi8vIHNyYy9scnUtY2FjaGUudHNcbmltcG9ydCB7IExSVUNhY2hlIH0gZnJvbSBcInR5cGVzY3JpcHQtbHJ1LWNhY2hlXCI7XG52YXIgQ2FjaGVIYW5kbGVyID0gY2xhc3Mge1xuICBjYWNoZTtcbiAgZGlydHlLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgb3B0aW9ucztcbiAgZGVidWc7XG4gIGluZGV4ZXM7XG4gIGlzU2V0ID0gZmFsc2U7XG4gIG1heFNpemUgPSAwO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5kZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLm1heFNpemUgPSBvcHRpb25zLm1heFNpemU7XG4gICAgaWYgKG9wdGlvbnMubWF4U2l6ZSA+IDApIHtcbiAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTFJVQ2FjaGUoeyBtYXhTaXplOiBvcHRpb25zLm1heFNpemUgfSk7XG4gICAgICBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLmR1bXAoKS5jYXRjaChjb25zb2xlLmVycm9yKSwgMWUzICogMTApO1xuICAgIH1cbiAgICB0aGlzLmluZGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGdldFNldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZT8uZ2V0KGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhbGwgZW50cmllcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIuXG4gICAqL1xuICBnZXRBbGxXaXRoRmlsdGVyKGZpbHRlcikge1xuICAgIGNvbnN0IHJldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5jYWNoZT8uZm9yRWFjaCgodmFsLCBrZXkpID0+IHtcbiAgICAgIGlmIChmaWx0ZXIoa2V5LCB2YWwpKSB7XG4gICAgICAgIHJldC5zZXQoa2V5LCB2YWwpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlPy5nZXQoa2V5KTtcbiAgfVxuICBhc3luYyBnZXRXaXRoRmFsbGJhY2soa2V5LCB0YWJsZSkge1xuICAgIGxldCBlbnRyeSA9IHRoaXMuZ2V0KGtleSk7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgZW50cnkgPSBhd2FpdCB0YWJsZS5nZXQoa2V5KTtcbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICB0aGlzLnNldChrZXksIGVudHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG4gIGFzeW5jIGdldE1hbnlXaXRoRmFsbGJhY2soa2V5cywgdGFibGUpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgY29uc3QgbWlzc2luZ0tleXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IHRoaXMuZ2V0KGtleSk7XG4gICAgICBpZiAoZW50cnkpIGVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgICBlbHNlIG1pc3NpbmdLZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5kZWJ1ZyhgQ2FjaGUgaGl0IGZvciBrZXlzICR7ZW50cmllcy5sZW5ndGh9IGFuZCBtaXNzIGZvciAke21pc3NpbmdLZXlzLmxlbmd0aH0ga2V5c2ApO1xuICAgIH1cbiAgICBpZiAobWlzc2luZ0tleXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IG1pc3NpbmdFbnRyaWVzID0gYXdhaXQgdGFibGUuYnVsa0dldChtaXNzaW5nS2V5cyk7XG4gICAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGxldCBmb3VuZEtleXMgPSAwO1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBtaXNzaW5nRW50cmllcykge1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB0aGlzLnNldChlbnRyeS5pZCwgZW50cnkpO1xuICAgICAgICAgIGVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgZm91bmRLZXlzKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgIGBUaW1lIHNwZW50IHF1ZXJ5aW5nIGRhdGFiYXNlOiAke2VuZFRpbWUgLSBzdGFydFRpbWV9bXMgZm9yICR7bWlzc2luZ0tleXMubGVuZ3RofSBrZXlzLCB3aGljaCBhZGRlZCAke2ZvdW5kS2V5c30gZW50cmllcyB0byB0aGUgY2FjaGVgXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZW50cmllcztcbiAgfVxuICBhZGQoa2V5LCB2YWx1ZSwgZGlydHkgPSB0cnVlKSB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmdldChrZXkpID8/IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZXhpc3RpbmcuYWRkKHZhbHVlKTtcbiAgICB0aGlzLmNhY2hlPy5zZXQoa2V5LCBleGlzdGluZyk7XG4gICAgaWYgKGRpcnR5KSB0aGlzLmRpcnR5S2V5cy5hZGQoa2V5KTtcbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSwgZGlydHkgPSB0cnVlKSB7XG4gICAgdGhpcy5jYWNoZT8uc2V0KGtleSwgdmFsdWUpO1xuICAgIGlmIChkaXJ0eSkgdGhpcy5kaXJ0eUtleXMuYWRkKGtleSk7XG4gICAgZm9yIChjb25zdCBbYXR0cmlidXRlLCBpbmRleF0gb2YgdGhpcy5pbmRleGVzLmVudHJpZXMoKSkge1xuICAgICAgY29uc3QgaW5kZXhLZXkgPSB2YWx1ZVthdHRyaWJ1dGVdO1xuICAgICAgaWYgKGluZGV4S2V5KSB7XG4gICAgICAgIGNvbnN0IGluZGV4VmFsdWUgPSBpbmRleC5nZXQoaW5kZXhLZXkpIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgIGluZGV4VmFsdWUuYWRkKGtleSk7XG4gICAgICAgIGluZGV4LnNldChpbmRleEtleSwgaW5kZXhWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGU/LnNpemUgfHwgMDtcbiAgfVxuICBkZWxldGUoa2V5KSB7XG4gICAgdGhpcy5jYWNoZT8uZGVsZXRlKGtleSk7XG4gICAgdGhpcy5kaXJ0eUtleXMuYWRkKGtleSk7XG4gIH1cbiAgYXN5bmMgZHVtcCgpIHtcbiAgICBpZiAodGhpcy5kaXJ0eUtleXMuc2l6ZSA+IDAgJiYgdGhpcy5jYWNoZSkge1xuICAgICAgYXdhaXQgdGhpcy5vcHRpb25zLmR1bXAodGhpcy5kaXJ0eUtleXMsIHRoaXMuY2FjaGUpO1xuICAgICAgdGhpcy5kaXJ0eUtleXMuY2xlYXIoKTtcbiAgICB9XG4gIH1cbiAgYWRkSW5kZXgoYXR0cmlidXRlKSB7XG4gICAgdGhpcy5pbmRleGVzLnNldChhdHRyaWJ1dGUsIG5ldyBMUlVDYWNoZSh7IG1heFNpemU6IHRoaXMub3B0aW9ucy5tYXhTaXplIH0pKTtcbiAgfVxuICBnZXRGcm9tSW5kZXgoaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IHJldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgaW5kZXhWYWx1ZXMgPSB0aGlzLmluZGV4ZXMuZ2V0KGluZGV4KTtcbiAgICBpZiAoaW5kZXhWYWx1ZXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGluZGV4VmFsdWVzLmdldChrZXkpO1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleTIgb2YgdmFsdWVzLnZhbHVlcygpKSB7XG4gICAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmdldChrZXkyKTtcbiAgICAgICAgICBpZiAoZW50cnkpIHJldC5hZGQoZW50cnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbn07XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIElOREVYQUJMRV9UQUdTX0xJTUlUID0gMTA7XG52YXIgTkRLQ2FjaGVBZGFwdGVyRGV4aWUgPSBjbGFzcyB7XG4gIGRlYnVnO1xuICBsb2NraW5nID0gZmFsc2U7XG4gIHJlYWR5ID0gZmFsc2U7XG4gIHByb2ZpbGVzO1xuICB6YXBwZXJzO1xuICBuaXAwNXM7XG4gIGV2ZW50cztcbiAgZXZlbnRUYWdzO1xuICByZWxheUluZm87XG4gIHVucHVibGlzaGVkRXZlbnRzO1xuICB3YXJtZWRVcCA9IGZhbHNlO1xuICB3YXJtVXBQcm9taXNlO1xuICBkZXZNb2RlID0gZmFsc2U7XG4gIHNhdmVTaWc7XG4gIF9vblJlYWR5O1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBjcmVhdGVEYXRhYmFzZShvcHRzLmRiTmFtZSB8fCBcIm5ka1wiKTtcbiAgICB0aGlzLmRlYnVnID0gb3B0cy5kZWJ1ZyB8fCBjcmVhdGVEZWJ1ZzIoXCJuZGs6ZGV4aWUtYWRhcHRlclwiKTtcbiAgICB0aGlzLnNhdmVTaWcgPSBvcHRzLnNhdmVTaWcgfHwgZmFsc2U7XG4gICAgdGhpcy5wcm9maWxlcyA9IG5ldyBDYWNoZUhhbmRsZXIoe1xuICAgICAgbWF4U2l6ZTogb3B0cy5wcm9maWxlQ2FjaGVTaXplIHx8IDFlNSxcbiAgICAgIGR1bXA6IHByb2ZpbGVzRHVtcChkYi5wcm9maWxlcywgdGhpcy5kZWJ1ZyksXG4gICAgICBkZWJ1ZzogdGhpcy5kZWJ1Z1xuICAgIH0pO1xuICAgIHRoaXMuemFwcGVycyA9IG5ldyBDYWNoZUhhbmRsZXIoe1xuICAgICAgbWF4U2l6ZTogb3B0cy56YXBwZXJDYWNoZVNpemUgfHwgMjAwLFxuICAgICAgZHVtcDogemFwcGVyRHVtcChkYi5sbnVybCwgdGhpcy5kZWJ1ZyksXG4gICAgICBkZWJ1ZzogdGhpcy5kZWJ1Z1xuICAgIH0pO1xuICAgIHRoaXMubmlwMDVzID0gbmV3IENhY2hlSGFuZGxlcih7XG4gICAgICBtYXhTaXplOiBvcHRzLm5pcDA1Q2FjaGVTaXplIHx8IDFlMyxcbiAgICAgIGR1bXA6IG5pcDA1RHVtcChkYi5uaXAwNSwgdGhpcy5kZWJ1ZyksXG4gICAgICBkZWJ1ZzogdGhpcy5kZWJ1Z1xuICAgIH0pO1xuICAgIHRoaXMuZXZlbnRzID0gbmV3IENhY2hlSGFuZGxlcih7XG4gICAgICBtYXhTaXplOiBvcHRzLmV2ZW50Q2FjaGVTaXplIHx8IDVlNCxcbiAgICAgIGR1bXA6IGV2ZW50c0R1bXAoZGIuZXZlbnRzLCB0aGlzLmRlYnVnKSxcbiAgICAgIGRlYnVnOiB0aGlzLmRlYnVnXG4gICAgfSk7XG4gICAgdGhpcy5ldmVudHMuYWRkSW5kZXgoXCJwdWJrZXlcIik7XG4gICAgdGhpcy5ldmVudHMuYWRkSW5kZXgoXCJraW5kXCIpO1xuICAgIHRoaXMuZXZlbnRUYWdzID0gbmV3IENhY2hlSGFuZGxlcih7XG4gICAgICBtYXhTaXplOiBvcHRzLmV2ZW50VGFnc0NhY2hlU2l6ZSB8fCAxZTUsXG4gICAgICBkdW1wOiBldmVudFRhZ3NEdW1wKGRiLmV2ZW50VGFncywgdGhpcy5kZWJ1ZyksXG4gICAgICBkZWJ1ZzogdGhpcy5kZWJ1Z1xuICAgIH0pO1xuICAgIHRoaXMucmVsYXlJbmZvID0gbmV3IENhY2hlSGFuZGxlcih7XG4gICAgICBtYXhTaXplOiA1MDAsXG4gICAgICBkZWJ1ZzogdGhpcy5kZWJ1ZyxcbiAgICAgIGR1bXA6IHJlbGF5SW5mb0R1bXAoZGIucmVsYXlTdGF0dXMsIHRoaXMuZGVidWcpXG4gICAgfSk7XG4gICAgdGhpcy51bnB1Ymxpc2hlZEV2ZW50cyA9IG5ldyBDYWNoZUhhbmRsZXIoe1xuICAgICAgbWF4U2l6ZTogNWUzLFxuICAgICAgZGVidWc6IHRoaXMuZGVidWcsXG4gICAgICBkdW1wOiB1bnB1Ymxpc2hlZEV2ZW50c0R1bXAoZGIudW5wdWJsaXNoZWRFdmVudHMsIHRoaXMuZGVidWcpXG4gICAgfSk7XG4gICAgY29uc3QgcHJvZmlsZSA9IChsYWJlbCwgZm4pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgIHJldHVybiBmbigpLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb25zdCBlbmQgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLmRlYnVnKGxhYmVsLCBcInRvb2tcIiwgZW5kIC0gc3RhcnQsIFwibXNcIik7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy53YXJtVXBQcm9taXNlID0gUHJvbWlzZS5hbGxTZXR0bGVkKFtcbiAgICAgIHByb2ZpbGUoXCJwcm9maWxlc1dhcm1VcFwiLCAoKSA9PiBwcm9maWxlc1dhcm1VcCh0aGlzLnByb2ZpbGVzLCBkYi5wcm9maWxlcykpLFxuICAgICAgcHJvZmlsZShcInphcHBlcldhcm1VcFwiLCAoKSA9PiB6YXBwZXJXYXJtVXAodGhpcy56YXBwZXJzLCBkYi5sbnVybCkpLFxuICAgICAgcHJvZmlsZShcIm5pcDA1V2FybVVwXCIsICgpID0+IG5pcDA1V2FybVVwKHRoaXMubmlwMDVzLCBkYi5uaXAwNSkpLFxuICAgICAgcHJvZmlsZShcInJlbGF5SW5mb1dhcm1VcFwiLCAoKSA9PiByZWxheUluZm9XYXJtVXAodGhpcy5yZWxheUluZm8sIGRiLnJlbGF5U3RhdHVzKSksXG4gICAgICBwcm9maWxlKFxuICAgICAgICBcInVucHVibGlzaGVkRXZlbnRzV2FybVVwXCIsXG4gICAgICAgICgpID0+IHVucHVibGlzaGVkRXZlbnRzV2FybVVwKHRoaXMudW5wdWJsaXNoZWRFdmVudHMsIGRiLnVucHVibGlzaGVkRXZlbnRzKVxuICAgICAgKSxcbiAgICAgIHByb2ZpbGUoXCJldmVudHNXYXJtVXBcIiwgKCkgPT4gZXZlbnRzV2FybVVwKHRoaXMuZXZlbnRzLCBkYi5ldmVudHMpKSxcbiAgICAgIHByb2ZpbGUoXCJldmVudFRhZ3NXYXJtVXBcIiwgKCkgPT4gZXZlbnRUYWdzV2FybVVwKHRoaXMuZXZlbnRUYWdzLCBkYi5ldmVudFRhZ3MpKVxuICAgIF0pO1xuICAgIHRoaXMud2FybVVwUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgdGhpcy53YXJtZWRVcCA9IHRydWU7XG4gICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMubG9ja2luZyA9IHRydWU7XG4gICAgICB0aGlzLmRlYnVnKFwiV2FybSB1cCBjb21wbGV0ZWQsIHRpbWVcIiwgZW5kVGltZSAtIHN0YXJ0VGltZSwgXCJtc1wiKTtcbiAgICAgIGlmICh0aGlzLl9vblJlYWR5KSB0aGlzLl9vblJlYWR5KCk7XG4gICAgfSk7XG4gIH1cbiAgb25SZWFkeShjYWxsYmFjaykge1xuICAgIHRoaXMuX29uUmVhZHkgPSBjYWxsYmFjaztcbiAgfVxuICBhc3luYyBxdWVyeShzdWJzY3JpcHRpb24pIHtcbiAgICBpZiAoIXRoaXMud2FybWVkVXApIHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZTIgPSBEYXRlLm5vdygpO1xuICAgICAgYXdhaXQgdGhpcy53YXJtVXBQcm9taXNlO1xuICAgICAgdGhpcy5kZWJ1ZyhcImZyb3plIHF1ZXJ5IGZvclwiLCBEYXRlLm5vdygpIC0gc3RhcnRUaW1lMiwgXCJtc1wiLCBzdWJzY3JpcHRpb24uZmlsdGVycyk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgc3Vic2NyaXB0aW9uLmZpbHRlcnMubWFwKChmaWx0ZXIpID0+IHRoaXMucHJvY2Vzc0ZpbHRlcihmaWx0ZXIsIHN1YnNjcmlwdGlvbikpO1xuICAgIGNvbnN0IGR1ciA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgaWYgKGR1ciA+IDEwMCkgdGhpcy5kZWJ1ZyhcInF1ZXJ5IHRvb2tcIiwgZHVyLCBcIm1zXCIsIHN1YnNjcmlwdGlvbi5maWx0ZXIpO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBhc3luYyBmZXRjaFByb2ZpbGUocHVia2V5KSB7XG4gICAgaWYgKCF0aGlzLnByb2ZpbGVzKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5wcm9maWxlcy5nZXRXaXRoRmFsbGJhY2socHVia2V5LCBkYi5wcm9maWxlcyk7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgZmV0Y2hQcm9maWxlU3luYyhwdWJrZXkpIHtcbiAgICBpZiAoIXRoaXMucHJvZmlsZXMpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHVzZXIgPSB0aGlzLnByb2ZpbGVzLmdldChwdWJrZXkpO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIGFzeW5jIGdldFByb2ZpbGVzKGZuKSB7XG4gICAgaWYgKCF0aGlzLnByb2ZpbGVzKSByZXR1cm47XG4gICAgcmV0dXJuIHRoaXMucHJvZmlsZXMuZ2V0QWxsV2l0aEZpbHRlcihmbik7XG4gIH1cbiAgc2F2ZVByb2ZpbGUocHVia2V5LCBwcm9maWxlKSB7XG4gICAgY29uc3QgZXhpc3RpbmdWYWx1ZSA9IHRoaXMucHJvZmlsZXMuZ2V0KHB1YmtleSk7XG4gICAgaWYgKGV4aXN0aW5nVmFsdWU/LmNyZWF0ZWRfYXQgJiYgcHJvZmlsZS5jcmVhdGVkX2F0ICYmIGV4aXN0aW5nVmFsdWUuY3JlYXRlZF9hdCA+PSBwcm9maWxlLmNyZWF0ZWRfYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVkQXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpO1xuICAgIHRoaXMucHJvZmlsZXMuc2V0KHB1YmtleSwgeyBwdWJrZXksIC4uLnByb2ZpbGUsIGNhY2hlZEF0IH0pO1xuICAgIHRoaXMuZGVidWcoXCJTYXZlZCBwcm9maWxlIGZvciBwdWJrZXlcIiwgcHVia2V5LCBwcm9maWxlKTtcbiAgfVxuICBhc3luYyBsb2FkTmlwMDUobmlwMDUsIG1heEFnZUZvck1pc3NpbmcgPSAzNjAwKSB7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLm5pcDA1cz8uZ2V0KG5pcDA1KTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIGlmIChjYWNoZS5wcm9maWxlID09PSBudWxsKSB7XG4gICAgICAgIGlmIChjYWNoZS5mZXRjaGVkQXQgKyBtYXhBZ2VGb3JNaXNzaW5nICogMWUzIDwgRGF0ZS5ub3coKSkgcmV0dXJuIFwibWlzc2luZ1wiO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGNhY2hlLnByb2ZpbGUpO1xuICAgICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgICAgcmV0dXJuIFwibWlzc2luZ1wiO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuaXAgPSBhd2FpdCBkYi5uaXAwNS5nZXQoeyBuaXAwNSB9KTtcbiAgICBpZiAoIW5pcCkgcmV0dXJuIFwibWlzc2luZ1wiO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgaWYgKG5pcC5wcm9maWxlID09PSBudWxsKSB7XG4gICAgICBpZiAobmlwLmZldGNoZWRBdCArIG1heEFnZUZvck1pc3NpbmcgKiAxZTMgPCBub3cpIHJldHVybiBcIm1pc3NpbmdcIjtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UobmlwLnByb2ZpbGUpO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICByZXR1cm4gXCJtaXNzaW5nXCI7XG4gICAgfVxuICB9XG4gIGFzeW5jIHNhdmVOaXAwNShuaXAwNSwgcHJvZmlsZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IHByb2ZpbGUgPyBKU09OLnN0cmluZ2lmeShwcm9maWxlKSA6IG51bGw7XG4gICAgICB0aGlzLm5pcDA1cy5zZXQobmlwMDUsIHsgcHJvZmlsZTogZG9jdW1lbnQsIGZldGNoZWRBdDogRGF0ZS5ub3coKSB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzYXZlIE5JUC0wNSBwcm9maWxlIGZvciBuaXAwNTpcIiwgbmlwMDUsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgbG9hZFVzZXJzTE5VUkxEb2MocHVia2V5LCBtYXhBZ2VJblNlY3MgPSA4NjQwMCwgbWF4QWdlRm9yTWlzc2luZyA9IDM2MDApIHtcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuemFwcGVycz8uZ2V0KHB1YmtleSk7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICBpZiAoY2FjaGUuZG9jdW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKGNhY2hlLmZldGNoZWRBdCArIG1heEFnZUZvck1pc3NpbmcgKiAxZTMgPCBEYXRlLm5vdygpKSByZXR1cm4gXCJtaXNzaW5nXCI7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoY2FjaGUuZG9jdW1lbnQpO1xuICAgICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgICAgcmV0dXJuIFwibWlzc2luZ1wiO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsbnVybCA9IGF3YWl0IGRiLmxudXJsLmdldCh7IHB1YmtleSB9KTtcbiAgICBpZiAoIWxudXJsKSByZXR1cm4gXCJtaXNzaW5nXCI7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAobG51cmwuZmV0Y2hlZEF0ICsgbWF4QWdlSW5TZWNzICogMWUzIDwgbm93KSByZXR1cm4gXCJtaXNzaW5nXCI7XG4gICAgaWYgKGxudXJsLmRvY3VtZW50ID09PSBudWxsKSB7XG4gICAgICBpZiAobG51cmwuZmV0Y2hlZEF0ICsgbWF4QWdlRm9yTWlzc2luZyAqIDFlMyA8IG5vdykgcmV0dXJuIFwibWlzc2luZ1wiO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShsbnVybC5kb2N1bWVudCk7XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgIHJldHVybiBcIm1pc3NpbmdcIjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2F2ZVVzZXJzTE5VUkxEb2MocHVia2V5LCBkb2MpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBkb2MgPyBKU09OLnN0cmluZ2lmeShkb2MpIDogbnVsbDtcbiAgICAgIHRoaXMuemFwcGVycz8uc2V0KHB1YmtleSwgeyBkb2N1bWVudCwgZmV0Y2hlZEF0OiBEYXRlLm5vdygpIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNhdmUgTE5VUkwgZG9jdW1lbnQgZm9yIHB1YmtleTpcIiwgcHVia2V5LCBlcnJvcik7XG4gICAgfVxuICB9XG4gIHByb2Nlc3NGaWx0ZXIoZmlsdGVyLCBzdWJzY3JpcHRpb24pIHtcbiAgICBjb25zdCBfZmlsdGVyID0geyAuLi5maWx0ZXIgfTtcbiAgICBfZmlsdGVyLmxpbWl0ID0gdm9pZCAwO1xuICAgIGNvbnN0IGZpbHRlcktleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKF9maWx0ZXIgfHwge30pKTtcbiAgICBmaWx0ZXJLZXlzLmRlbGV0ZShcInNpbmNlXCIpO1xuICAgIGZpbHRlcktleXMuZGVsZXRlKFwibGltaXRcIik7XG4gICAgZmlsdGVyS2V5cy5kZWxldGUoXCJ1bnRpbFwiKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuYnlOaXAzM1F1ZXJ5KGZpbHRlcktleXMsIGZpbHRlciwgc3Vic2NyaXB0aW9uKSkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuYnlBdXRob3JzKGZpbHRlciwgc3Vic2NyaXB0aW9uKSkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuYnlJZHNRdWVyeShmaWx0ZXIsIHN1YnNjcmlwdGlvbikpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmJ5VGFncyhmaWx0ZXIsIHN1YnNjcmlwdGlvbikpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmJ5S2luZHMoZmlsdGVyS2V5cywgZmlsdGVyLCBzdWJzY3JpcHRpb24pKSByZXR1cm47XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyBkZWxldGVFdmVudElkcyhldmVudElkcykge1xuICAgIGV2ZW50SWRzLmZvckVhY2goKGlkKSA9PiB0aGlzLmV2ZW50cy5kZWxldGUoaWQpKTtcbiAgICBhd2FpdCBkYi5ldmVudHMud2hlcmUoeyBpZDogZXZlbnRJZHMgfSkuZGVsZXRlKCk7XG4gIH1cbiAgYWRkVW5wdWJsaXNoZWRFdmVudCA9IGFkZFVucHVibGlzaGVkRXZlbnQuYmluZCh0aGlzKTtcbiAgZ2V0VW5wdWJsaXNoZWRFdmVudHMgPSAoKSA9PiBnZXRVbnB1Ymxpc2hlZEV2ZW50cyhkYi51bnB1Ymxpc2hlZEV2ZW50cyk7XG4gIGRpc2NhcmRVbnB1Ymxpc2hlZEV2ZW50ID0gKGlkKSA9PiBkaXNjYXJkVW5wdWJsaXNoZWRFdmVudChkYi51bnB1Ymxpc2hlZEV2ZW50cywgaWQpO1xuICBhc3luYyBzZXRFdmVudChldmVudCwgX2ZpbHRlcnMsIHJlbGF5KSB7XG4gICAgaWYgKGV2ZW50LmtpbmQgPT09IDApIHtcbiAgICAgIGlmICghdGhpcy5wcm9maWxlcykgcmV0dXJuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHJvZmlsZSA9IHByb2ZpbGVGcm9tRXZlbnQoZXZlbnQpO1xuICAgICAgICB0aGlzLnNhdmVQcm9maWxlKGV2ZW50LnB1YmtleSwgcHJvZmlsZSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhgRmFpbGVkIHRvIHNhdmUgcHJvZmlsZSBmb3IgcHVia2V5OiAke2V2ZW50LnB1YmtleX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGFkZEV2ZW50ID0gdHJ1ZTtcbiAgICBpZiAoZXZlbnQuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nRXZlbnQgPSB0aGlzLmV2ZW50cy5nZXQoZXZlbnQudGFnSWQoKSk7XG4gICAgICBpZiAoZXhpc3RpbmdFdmVudCAmJiBldmVudC5jcmVhdGVkX2F0ICYmIGV4aXN0aW5nRXZlbnQuY3JlYXRlZEF0ID4gZXZlbnQuY3JlYXRlZF9hdCkge1xuICAgICAgICBhZGRFdmVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWRkRXZlbnQpIHtcbiAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IHtcbiAgICAgICAgaWQ6IGV2ZW50LnRhZ0lkKCksXG4gICAgICAgIHB1YmtleTogZXZlbnQucHVia2V5LFxuICAgICAgICBraW5kOiBldmVudC5raW5kLFxuICAgICAgICBjcmVhdGVkQXQ6IGV2ZW50LmNyZWF0ZWRfYXQsXG4gICAgICAgIHJlbGF5OiByZWxheT8udXJsLFxuICAgICAgICBldmVudDogZXZlbnQuc2VyaWFsaXplKHRoaXMuc2F2ZVNpZywgdHJ1ZSlcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5zYXZlU2lnICYmIGV2ZW50LnNpZykge1xuICAgICAgICBldmVudERhdGEuc2lnID0gZXZlbnQuc2lnO1xuICAgICAgfVxuICAgICAgdGhpcy5ldmVudHMuc2V0KGV2ZW50LnRhZ0lkKCksIGV2ZW50RGF0YSk7XG4gICAgICBjb25zdCBpbmRleGFibGVUYWdzID0gZ2V0SW5kZXhhYmxlVGFncyhldmVudCk7XG4gICAgICBmb3IgKGNvbnN0IHRhZyBvZiBpbmRleGFibGVUYWdzKSB7XG4gICAgICAgIHRoaXMuZXZlbnRUYWdzLmFkZCh0YWdbMF0gKyB0YWdbMV0sIGV2ZW50LnRhZ0lkKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1cGRhdGVSZWxheVN0YXR1cyh1cmwsIGluZm8pIHtcbiAgICBjb25zdCB2YWwgPSB7IHVybCwgdXBkYXRlZEF0OiBEYXRlLm5vdygpLCAuLi5pbmZvIH07XG4gICAgdGhpcy5yZWxheUluZm8uc2V0KHVybCwgdmFsKTtcbiAgfVxuICBnZXRSZWxheVN0YXR1cyh1cmwpIHtcbiAgICBjb25zdCBhID0gdGhpcy5yZWxheUluZm8uZ2V0KHVybCk7XG4gICAgaWYgKGEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhc3RDb25uZWN0ZWRBdDogYS5sYXN0Q29ubmVjdGVkQXQsXG4gICAgICAgIGRvbnRDb25uZWN0QmVmb3JlOiBhLmRvbnRDb25uZWN0QmVmb3JlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2VhcmNoZXMgYnkgYXV0aG9yc1xuICAgKi9cbiAgYnlBdXRob3JzKGZpbHRlciwgc3Vic2NyaXB0aW9uKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXV0aG9ycykgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBfdG90YWwgPSAwO1xuICAgIGZvciAoY29uc3QgcHVia2V5IG9mIGZpbHRlci5hdXRob3JzKSB7XG4gICAgICBsZXQgZXZlbnRzID0gQXJyYXkuZnJvbSh0aGlzLmV2ZW50cy5nZXRGcm9tSW5kZXgoXCJwdWJrZXlcIiwgcHVia2V5KSk7XG4gICAgICBpZiAoZmlsdGVyLmtpbmRzKSBldmVudHMgPSBldmVudHMuZmlsdGVyKChlKSA9PiBmaWx0ZXIua2luZHM/LmluY2x1ZGVzKGUua2luZCkpO1xuICAgICAgZm91bmRFdmVudHMoc3Vic2NyaXB0aW9uLCBldmVudHMsIGZpbHRlcik7XG4gICAgICBfdG90YWwgKz0gZXZlbnRzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNlYXJjaGVzIGJ5IGlkc1xuICAgKi9cbiAgYnlJZHNRdWVyeShmaWx0ZXIsIHN1YnNjcmlwdGlvbikge1xuICAgIGlmIChmaWx0ZXIuaWRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGlkIG9mIGZpbHRlci5pZHMpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLmV2ZW50cy5nZXQoaWQpO1xuICAgICAgICBpZiAoZXZlbnQpIGZvdW5kRXZlbnQoc3Vic2NyaXB0aW9uLCBldmVudCwgZXZlbnQucmVsYXksIGZpbHRlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBTZWFyY2hlcyBieSBOSVAtMzNcbiAgICovXG4gIGJ5TmlwMzNRdWVyeShmaWx0ZXJLZXlzLCBmaWx0ZXIsIHN1YnNjcmlwdGlvbikge1xuICAgIGNvbnN0IGYgPSBbXCIjZFwiLCBcImF1dGhvcnNcIiwgXCJraW5kc1wiXTtcbiAgICBjb25zdCBoYXNBbGxLZXlzID0gZmlsdGVyS2V5cy5zaXplID09PSBmLmxlbmd0aCAmJiBmLmV2ZXJ5KChrKSA9PiBmaWx0ZXJLZXlzLmhhcyhrKSk7XG4gICAgaWYgKGhhc0FsbEtleXMgJiYgZmlsdGVyLmtpbmRzICYmIGZpbHRlci5hdXRob3JzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtpbmQgb2YgZmlsdGVyLmtpbmRzKSB7XG4gICAgICAgIGNvbnN0IHJlcGxhY2VhYmxlS2luZCA9IGtpbmQgPj0gM2U0ICYmIGtpbmQgPCA0ZTQ7XG4gICAgICAgIGlmICghcmVwbGFjZWFibGVLaW5kKSBjb250aW51ZTtcbiAgICAgICAgZm9yIChjb25zdCBhdXRob3Igb2YgZmlsdGVyLmF1dGhvcnMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGRUYWcgb2YgZmlsdGVyW1wiI2RcIl0pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VhYmxlSWQgPSBgJHtraW5kfToke2F1dGhvcn06JHtkVGFnfWA7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IHRoaXMuZXZlbnRzLmdldChyZXBsYWNlYWJsZUlkKTtcbiAgICAgICAgICAgIGlmIChldmVudCkgZm91bmRFdmVudChzdWJzY3JpcHRpb24sIGV2ZW50LCBldmVudC5yZWxheSwgZmlsdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIFNlYXJjaGVzIGJ5IHRhZ3MgYW5kIG9wdGlvbmFsbHkgZmlsdGVycyBieSB0YWdzXG4gICAqL1xuICBieVRhZ3MoZmlsdGVyLCBzdWJzY3JpcHRpb24pIHtcbiAgICBjb25zdCB0YWdGaWx0ZXJzID0gT2JqZWN0LmVudHJpZXMoZmlsdGVyKS5maWx0ZXIoKFtmaWx0ZXIyXSkgPT4gZmlsdGVyMi5zdGFydHNXaXRoKFwiI1wiKSAmJiBmaWx0ZXIyLmxlbmd0aCA9PT0gMikubWFwKChbZmlsdGVyMiwgdmFsdWVzXSkgPT4gW2ZpbHRlcjJbMV0sIHZhbHVlc10pO1xuICAgIGlmICh0YWdGaWx0ZXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoY29uc3QgW3RhZywgdmFsdWVzXSBvZiB0YWdGaWx0ZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICBjb25zdCB0YWdWYWx1ZSA9IHRhZyArIHZhbHVlO1xuICAgICAgICBjb25zdCBldmVudElkcyA9IHRoaXMuZXZlbnRUYWdzLmdldFNldCh0YWdWYWx1ZSk7XG4gICAgICAgIGlmICghZXZlbnRJZHMpIGNvbnRpbnVlO1xuICAgICAgICBldmVudElkcy5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5ldmVudHMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoIWV2ZW50KSByZXR1cm47XG4gICAgICAgICAgaWYgKCFmaWx0ZXIua2luZHMgfHwgZmlsdGVyLmtpbmRzLmluY2x1ZGVzKGV2ZW50LmtpbmQpKSB7XG4gICAgICAgICAgICBmb3VuZEV2ZW50KHN1YnNjcmlwdGlvbiwgZXZlbnQsIGV2ZW50LnJlbGF5LCBmaWx0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGJ5S2luZHMoZmlsdGVyS2V5cywgZmlsdGVyLCBzdWJzY3JpcHRpb24pIHtcbiAgICBpZiAoIWZpbHRlci5raW5kcyB8fCBmaWx0ZXJLZXlzLnNpemUgIT09IDEgfHwgIWZpbHRlcktleXMuaGFzKFwia2luZHNcIikpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBsaW1pdCA9IGZpbHRlci5saW1pdCB8fCA1MDA7XG4gICAgbGV0IHRvdGFsRXZlbnRzID0gMDtcbiAgICBjb25zdCBwcm9jZXNzZWRFdmVudElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgc29ydGVkS2luZHMgPSBbLi4uZmlsdGVyLmtpbmRzXS5zb3J0KFxuICAgICAgKGEsIGIpID0+ICh0aGlzLmV2ZW50cy5pbmRleGVzLmdldChcImtpbmRcIik/LmdldChhKT8uc2l6ZSB8fCAwKSAtICh0aGlzLmV2ZW50cy5pbmRleGVzLmdldChcImtpbmRcIik/LmdldChiKT8uc2l6ZSB8fCAwKVxuICAgICk7XG4gICAgZm9yIChjb25zdCBraW5kIG9mIHNvcnRlZEtpbmRzKSB7XG4gICAgICBjb25zdCBldmVudHMgPSB0aGlzLmV2ZW50cy5nZXRGcm9tSW5kZXgoXCJraW5kXCIsIGtpbmQpO1xuICAgICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgaWYgKHByb2Nlc3NlZEV2ZW50SWRzLmhhcyhldmVudC5pZCkpIGNvbnRpbnVlO1xuICAgICAgICBwcm9jZXNzZWRFdmVudElkcy5hZGQoZXZlbnQuaWQpO1xuICAgICAgICBmb3VuZEV2ZW50KHN1YnNjcmlwdGlvbiwgZXZlbnQsIGV2ZW50LnJlbGF5LCBmaWx0ZXIpO1xuICAgICAgICB0b3RhbEV2ZW50cysrO1xuICAgICAgICBpZiAodG90YWxFdmVudHMgPj0gbGltaXQpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHRvdGFsRXZlbnRzID49IGxpbWl0KSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5mdW5jdGlvbiBmb3VuZEV2ZW50cyhzdWJzY3JpcHRpb24sIGV2ZW50cywgZmlsdGVyKSB7XG4gIGlmIChmaWx0ZXI/LmxpbWl0ICYmIGV2ZW50cy5sZW5ndGggPiBmaWx0ZXIubGltaXQpIHtcbiAgICBldmVudHMgPSBldmVudHMuc29ydCgoYSwgYikgPT4gYi5jcmVhdGVkQXQgLSBhLmNyZWF0ZWRBdCkuc2xpY2UoMCwgZmlsdGVyLmxpbWl0KTtcbiAgfVxuICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgIGZvdW5kRXZlbnQoc3Vic2NyaXB0aW9uLCBldmVudCwgZXZlbnQucmVsYXksIGZpbHRlcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGZvdW5kRXZlbnQoc3Vic2NyaXB0aW9uLCBldmVudCwgcmVsYXlVcmwsIGZpbHRlcikge1xuICB0cnkge1xuICAgIGNvbnN0IGRlc2VyaWFsaXplZEV2ZW50ID0gZGVzZXJpYWxpemUoZXZlbnQuZXZlbnQpO1xuICAgIGlmIChmaWx0ZXIgJiYgIW1hdGNoRmlsdGVyKGZpbHRlciwgZGVzZXJpYWxpemVkRXZlbnQpKSByZXR1cm47XG4gICAgY29uc3QgbmRrRXZlbnQgPSBuZXcgTkRLRXZlbnQyKHZvaWQgMCwgZGVzZXJpYWxpemVkRXZlbnQpO1xuICAgIGNvbnN0IHJlbGF5ID0gcmVsYXlVcmwgPyBzdWJzY3JpcHRpb24ucG9vbC5nZXRSZWxheShyZWxheVVybCwgZmFsc2UpIDogdm9pZCAwO1xuICAgIG5ka0V2ZW50LnJlbGF5ID0gcmVsYXk7XG4gICAgc3Vic2NyaXB0aW9uLmV2ZW50UmVjZWl2ZWQobmRrRXZlbnQsIHJlbGF5LCB0cnVlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJmYWlsZWQgdG8gZGVzZXJpYWxpemUgZXZlbnRcIiwgZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEluZGV4YWJsZVRhZ3MoZXZlbnQpIHtcbiAgY29uc3QgaW5kZXhhYmxlVGFncyA9IFtdO1xuICBpZiAoZXZlbnQua2luZCA9PT0gMykgcmV0dXJuIFtdO1xuICBmb3IgKGNvbnN0IHRhZyBvZiBldmVudC50YWdzKSB7XG4gICAgaWYgKHRhZ1swXS5sZW5ndGggIT09IDEpIGNvbnRpbnVlO1xuICAgIGluZGV4YWJsZVRhZ3MucHVzaCh0YWcpO1xuICAgIGlmIChpbmRleGFibGVUYWdzLmxlbmd0aCA+PSBJTkRFWEFCTEVfVEFHU19MSU1JVCkgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBpbmRleGFibGVUYWdzO1xufVxuZXhwb3J0IHtcbiAgZGIsXG4gIE5ES0NhY2hlQWRhcHRlckRleGllIGFzIGRlZmF1bHQsXG4gIGZvdW5kRXZlbnQsXG4gIGZvdW5kRXZlbnRzXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/@nostr-dev-kit/ndk/dist/index.mjs":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/@nostr-dev-kit/ndk/dist/index.mjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BECH32_REGEX: () => (/* binding */ BECH32_REGEX),\n/* harmony export */   NDKAppHandlerEvent: () => (/* binding */ NDKAppHandlerEvent),\n/* harmony export */   NDKAppSettings: () => (/* binding */ NDKAppSettings),\n/* harmony export */   NDKArticle: () => (/* binding */ NDKArticle),\n/* harmony export */   NDKCashuMintList: () => (/* binding */ NDKCashuMintList),\n/* harmony export */   NDKCashuToken: () => (/* binding */ NDKCashuToken),\n/* harmony export */   NDKCashuWalletTx: () => (/* binding */ NDKCashuWalletTx),\n/* harmony export */   NDKClassified: () => (/* binding */ NDKClassified),\n/* harmony export */   NDKDVMJobFeedback: () => (/* binding */ NDKDVMJobFeedback),\n/* harmony export */   NDKDVMJobResult: () => (/* binding */ NDKDVMJobResult),\n/* harmony export */   NDKDVMRequest: () => (/* binding */ NDKDVMRequest),\n/* harmony export */   NDKDraft: () => (/* binding */ NDKDraft),\n/* harmony export */   NDKDvmJobFeedbackStatus: () => (/* binding */ NDKDvmJobFeedbackStatus),\n/* harmony export */   NDKEvent: () => (/* binding */ NDKEvent),\n/* harmony export */   NDKHighlight: () => (/* binding */ NDKHighlight),\n/* harmony export */   NDKImage: () => (/* binding */ NDKImage),\n/* harmony export */   NDKKind: () => (/* binding */ NDKKind),\n/* harmony export */   NDKList: () => (/* binding */ NDKList),\n/* harmony export */   NDKListKinds: () => (/* binding */ NDKListKinds),\n/* harmony export */   NDKNip07Signer: () => (/* binding */ NDKNip07Signer),\n/* harmony export */   NDKNip46Backend: () => (/* binding */ NDKNip46Backend),\n/* harmony export */   NDKNip46Signer: () => (/* binding */ NDKNip46Signer),\n/* harmony export */   NDKNostrRpc: () => (/* binding */ NDKNostrRpc),\n/* harmony export */   NDKNutzap: () => (/* binding */ NDKNutzap),\n/* harmony export */   NDKPool: () => (/* binding */ NDKPool),\n/* harmony export */   NDKPrivateKeySigner: () => (/* binding */ NDKPrivateKeySigner),\n/* harmony export */   NDKPublishError: () => (/* binding */ NDKPublishError),\n/* harmony export */   NDKRelay: () => (/* binding */ NDKRelay),\n/* harmony export */   NDKRelayAuthPolicies: () => (/* binding */ NDKRelayAuthPolicies),\n/* harmony export */   NDKRelayList: () => (/* binding */ NDKRelayList),\n/* harmony export */   NDKRelaySet: () => (/* binding */ NDKRelaySet),\n/* harmony export */   NDKRelayStatus: () => (/* binding */ NDKRelayStatus),\n/* harmony export */   NDKRepost: () => (/* binding */ NDKRepost),\n/* harmony export */   NDKSimpleGroup: () => (/* binding */ NDKSimpleGroup),\n/* harmony export */   NDKSimpleGroupMemberList: () => (/* binding */ NDKSimpleGroupMemberList),\n/* harmony export */   NDKSimpleGroupMetadata: () => (/* binding */ NDKSimpleGroupMetadata),\n/* harmony export */   NDKStory: () => (/* binding */ NDKStory),\n/* harmony export */   NDKStorySticker: () => (/* binding */ NDKStorySticker),\n/* harmony export */   NDKStoryStickerType: () => (/* binding */ NDKStoryStickerType),\n/* harmony export */   NDKSubscription: () => (/* binding */ NDKSubscription),\n/* harmony export */   NDKSubscriptionCacheUsage: () => (/* binding */ NDKSubscriptionCacheUsage),\n/* harmony export */   NDKSubscriptionReceipt: () => (/* binding */ NDKSubscriptionReceipt),\n/* harmony export */   NDKSubscriptionStart: () => (/* binding */ NDKSubscriptionStart),\n/* harmony export */   NDKSubscriptionTier: () => (/* binding */ NDKSubscriptionTier),\n/* harmony export */   NDKTranscriptionDVM: () => (/* binding */ NDKTranscriptionDVM),\n/* harmony export */   NDKUser: () => (/* binding */ NDKUser),\n/* harmony export */   NDKVideo: () => (/* binding */ NDKVideo),\n/* harmony export */   NDKWiki: () => (/* binding */ NDKWiki),\n/* harmony export */   NDKWikiMergeRequest: () => (/* binding */ NDKWikiMergeRequest),\n/* harmony export */   NDKZapper: () => (/* binding */ NDKZapper),\n/* harmony export */   NIP33_A_REGEX: () => (/* binding */ NIP33_A_REGEX),\n/* harmony export */   NdkNutzapStatus: () => (/* binding */ NdkNutzapStatus),\n/* harmony export */   calculateRelaySetFromEvent: () => (/* binding */ calculateRelaySetFromEvent),\n/* harmony export */   calculateTermDurationInSeconds: () => (/* binding */ calculateTermDurationInSeconds),\n/* harmony export */   cashuPubkeyToNostrPubkey: () => (/* binding */ cashuPubkeyToNostrPubkey),\n/* harmony export */   compareFilter: () => (/* binding */ compareFilter),\n/* harmony export */   \"default\": () => (/* binding */ NDK),\n/* harmony export */   defaultOpts: () => (/* binding */ defaultOpts),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   dvmSchedule: () => (/* binding */ dvmSchedule),\n/* harmony export */   eventHasETagMarkers: () => (/* binding */ eventHasETagMarkers),\n/* harmony export */   eventIsPartOfThread: () => (/* binding */ eventIsPartOfThread),\n/* harmony export */   eventIsReply: () => (/* binding */ eventIsReply),\n/* harmony export */   eventReplies: () => (/* binding */ eventReplies),\n/* harmony export */   eventThreadIds: () => (/* binding */ eventThreadIds),\n/* harmony export */   eventThreads: () => (/* binding */ eventThreads),\n/* harmony export */   eventsBySameAuthor: () => (/* binding */ eventsBySameAuthor),\n/* harmony export */   filterAndRelaySetFromBech32: () => (/* binding */ filterAndRelaySetFromBech32),\n/* harmony export */   filterFingerprint: () => (/* binding */ filterFingerprint),\n/* harmony export */   filterForEventsTaggingId: () => (/* binding */ filterForEventsTaggingId),\n/* harmony export */   filterFromId: () => (/* binding */ filterFromId),\n/* harmony export */   generateContentTags: () => (/* binding */ generateContentTags),\n/* harmony export */   generateHashtags: () => (/* binding */ generateHashtags),\n/* harmony export */   generateSubId: () => (/* binding */ generateSubId),\n/* harmony export */   generateZapRequest: () => (/* binding */ generateZapRequest),\n/* harmony export */   getEventReplyId: () => (/* binding */ getEventReplyId),\n/* harmony export */   getNip57ZapSpecFromLud: () => (/* binding */ getNip57ZapSpecFromLud),\n/* harmony export */   getRelayListForUser: () => (/* binding */ getRelayListForUser),\n/* harmony export */   getRelayListForUsers: () => (/* binding */ getRelayListForUsers),\n/* harmony export */   getReplyTag: () => (/* binding */ getReplyTag),\n/* harmony export */   getRootEventId: () => (/* binding */ getRootEventId),\n/* harmony export */   getRootTag: () => (/* binding */ getRootTag),\n/* harmony export */   giftUnwrap: () => (/* binding */ giftUnwrap),\n/* harmony export */   giftWrap: () => (/* binding */ giftWrap),\n/* harmony export */   imetaTagToTag: () => (/* binding */ imetaTagToTag),\n/* harmony export */   isEventOriginalPost: () => (/* binding */ isEventOriginalPost),\n/* harmony export */   isNip33AValue: () => (/* binding */ isNip33AValue),\n/* harmony export */   mapImetaTag: () => (/* binding */ mapImetaTag),\n/* harmony export */   matchFilter: () => (/* binding */ matchFilter),\n/* harmony export */   mergeFilters: () => (/* binding */ mergeFilters),\n/* harmony export */   mergeTags: () => (/* binding */ mergeTags),\n/* harmony export */   ndkSignerFromPayload: () => (/* binding */ ndkSignerFromPayload),\n/* harmony export */   newAmount: () => (/* binding */ newAmount),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   normalizeRelayUrl: () => (/* binding */ normalizeRelayUrl),\n/* harmony export */   normalizeUrl: () => (/* binding */ normalizeUrl),\n/* harmony export */   parseTagToSubscriptionAmount: () => (/* binding */ parseTagToSubscriptionAmount),\n/* harmony export */   pinEvent: () => (/* binding */ pinEvent),\n/* harmony export */   possibleIntervalFrequencies: () => (/* binding */ possibleIntervalFrequencies),\n/* harmony export */   profileFromEvent: () => (/* binding */ profileFromEvent),\n/* harmony export */   proofP2pk: () => (/* binding */ proofP2pk),\n/* harmony export */   proofP2pkNostr: () => (/* binding */ proofP2pkNostr),\n/* harmony export */   proofsTotalBalance: () => (/* binding */ proofsTotalBalance),\n/* harmony export */   queryFullyFilled: () => (/* binding */ queryFullyFilled),\n/* harmony export */   relayListFromKind3: () => (/* binding */ relayListFromKind3),\n/* harmony export */   relaysFromBech32: () => (/* binding */ relaysFromBech32),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializeProfile: () => (/* binding */ serializeProfile),\n/* harmony export */   signerRegistry: () => (/* binding */ signerRegistry),\n/* harmony export */   strToDimension: () => (/* binding */ strToDimension),\n/* harmony export */   strToPosition: () => (/* binding */ strToPosition),\n/* harmony export */   tryNormalizeRelayUrl: () => (/* binding */ tryNormalizeRelayUrl),\n/* harmony export */   uniqueTag: () => (/* binding */ uniqueTag),\n/* harmony export */   wrapEvent: () => (/* binding */ wrapEvent),\n/* harmony export */   zapInvoiceFromEvent: () => (/* binding */ zapInvoiceFromEvent)\n/* harmony export */ });\n/* harmony import */ var tseep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tseep */ \"(ssr)/./node_modules/tseep/lib/index.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nostr-tools */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! typescript-lru-cache */ \"(ssr)/./node_modules/typescript-lru-cache/dist/index.js\");\n/* harmony import */ var light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! light-bolt11-decoder */ \"(ssr)/./node_modules/light-bolt11-decoder/bolt11.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n// src/types.ts\nvar NdkNutzapStatus = /* @__PURE__ */ ((NdkNutzapStatus2) => {\n  NdkNutzapStatus2[\"INITIAL\"] = \"initial\";\n  NdkNutzapStatus2[\"PROCESSING\"] = \"processing\";\n  NdkNutzapStatus2[\"REDEEMED\"] = \"redeemed\";\n  NdkNutzapStatus2[\"SPENT\"] = \"spent\";\n  NdkNutzapStatus2[\"MISSING_PRIVKEY\"] = \"missing_privkey\";\n  NdkNutzapStatus2[\"TEMPORARY_ERROR\"] = \"temporary_error\";\n  NdkNutzapStatus2[\"PERMANENT_ERROR\"] = \"permanent_error\";\n  NdkNutzapStatus2[\"INVALID_NUTZAP\"] = \"invalid_nutzap\";\n  return NdkNutzapStatus2;\n})(NdkNutzapStatus || {});\n\n// src/events/kinds/index.ts\nvar NDKKind = /* @__PURE__ */ ((NDKKind2) => {\n  NDKKind2[NDKKind2[\"Metadata\"] = 0] = \"Metadata\";\n  NDKKind2[NDKKind2[\"Text\"] = 1] = \"Text\";\n  NDKKind2[NDKKind2[\"RecommendRelay\"] = 2] = \"RecommendRelay\";\n  NDKKind2[NDKKind2[\"Contacts\"] = 3] = \"Contacts\";\n  NDKKind2[NDKKind2[\"EncryptedDirectMessage\"] = 4] = \"EncryptedDirectMessage\";\n  NDKKind2[NDKKind2[\"EventDeletion\"] = 5] = \"EventDeletion\";\n  NDKKind2[NDKKind2[\"Repost\"] = 6] = \"Repost\";\n  NDKKind2[NDKKind2[\"Reaction\"] = 7] = \"Reaction\";\n  NDKKind2[NDKKind2[\"BadgeAward\"] = 8] = \"BadgeAward\";\n  NDKKind2[NDKKind2[\"GroupChat\"] = 9] = \"GroupChat\";\n  NDKKind2[NDKKind2[\"GroupNote\"] = 11] = \"GroupNote\";\n  NDKKind2[NDKKind2[\"GroupReply\"] = 12] = \"GroupReply\";\n  NDKKind2[NDKKind2[\"GiftWrapSeal\"] = 13] = \"GiftWrapSeal\";\n  NDKKind2[NDKKind2[\"PrivateDirectMessage\"] = 14] = \"PrivateDirectMessage\";\n  NDKKind2[NDKKind2[\"Image\"] = 20] = \"Image\";\n  NDKKind2[NDKKind2[\"Video\"] = 21] = \"Video\";\n  NDKKind2[NDKKind2[\"ShortVideo\"] = 22] = \"ShortVideo\";\n  NDKKind2[NDKKind2[\"Story\"] = 23] = \"Story\";\n  NDKKind2[NDKKind2[\"Vanish\"] = 62] = \"Vanish\";\n  NDKKind2[NDKKind2[\"CashuWalletBackup\"] = 375] = \"CashuWalletBackup\";\n  NDKKind2[NDKKind2[\"GiftWrap\"] = 1059] = \"GiftWrap\";\n  NDKKind2[NDKKind2[\"GenericRepost\"] = 16] = \"GenericRepost\";\n  NDKKind2[NDKKind2[\"ChannelCreation\"] = 40] = \"ChannelCreation\";\n  NDKKind2[NDKKind2[\"ChannelMetadata\"] = 41] = \"ChannelMetadata\";\n  NDKKind2[NDKKind2[\"ChannelMessage\"] = 42] = \"ChannelMessage\";\n  NDKKind2[NDKKind2[\"ChannelHideMessage\"] = 43] = \"ChannelHideMessage\";\n  NDKKind2[NDKKind2[\"ChannelMuteUser\"] = 44] = \"ChannelMuteUser\";\n  NDKKind2[NDKKind2[\"WikiMergeRequest\"] = 818] = \"WikiMergeRequest\";\n  NDKKind2[NDKKind2[\"GenericReply\"] = 1111] = \"GenericReply\";\n  NDKKind2[NDKKind2[\"Media\"] = 1063] = \"Media\";\n  NDKKind2[NDKKind2[\"Report\"] = 1984] = \"Report\";\n  NDKKind2[NDKKind2[\"Label\"] = 1985] = \"Label\";\n  NDKKind2[NDKKind2[\"DVMReqTextExtraction\"] = 5e3] = \"DVMReqTextExtraction\";\n  NDKKind2[NDKKind2[\"DVMReqTextSummarization\"] = 5001] = \"DVMReqTextSummarization\";\n  NDKKind2[NDKKind2[\"DVMReqTextTranslation\"] = 5002] = \"DVMReqTextTranslation\";\n  NDKKind2[NDKKind2[\"DVMReqTextGeneration\"] = 5050] = \"DVMReqTextGeneration\";\n  NDKKind2[NDKKind2[\"DVMReqImageGeneration\"] = 5100] = \"DVMReqImageGeneration\";\n  NDKKind2[NDKKind2[\"DVMReqTextToSpeech\"] = 5250] = \"DVMReqTextToSpeech\";\n  NDKKind2[NDKKind2[\"DVMReqDiscoveryNostrContent\"] = 5300] = \"DVMReqDiscoveryNostrContent\";\n  NDKKind2[NDKKind2[\"DVMReqDiscoveryNostrPeople\"] = 5301] = \"DVMReqDiscoveryNostrPeople\";\n  NDKKind2[NDKKind2[\"DVMReqTimestamping\"] = 5900] = \"DVMReqTimestamping\";\n  NDKKind2[NDKKind2[\"DVMEventSchedule\"] = 5905] = \"DVMEventSchedule\";\n  NDKKind2[NDKKind2[\"DVMJobFeedback\"] = 7e3] = \"DVMJobFeedback\";\n  NDKKind2[NDKKind2[\"Subscribe\"] = 7001] = \"Subscribe\";\n  NDKKind2[NDKKind2[\"Unsubscribe\"] = 7002] = \"Unsubscribe\";\n  NDKKind2[NDKKind2[\"SubscriptionReceipt\"] = 7003] = \"SubscriptionReceipt\";\n  NDKKind2[NDKKind2[\"CashuReserve\"] = 7373] = \"CashuReserve\";\n  NDKKind2[NDKKind2[\"CashuQuote\"] = 7374] = \"CashuQuote\";\n  NDKKind2[NDKKind2[\"CashuToken\"] = 7375] = \"CashuToken\";\n  NDKKind2[NDKKind2[\"CashuWalletTx\"] = 7376] = \"CashuWalletTx\";\n  NDKKind2[NDKKind2[\"GroupAdminAddUser\"] = 9e3] = \"GroupAdminAddUser\";\n  NDKKind2[NDKKind2[\"GroupAdminRemoveUser\"] = 9001] = \"GroupAdminRemoveUser\";\n  NDKKind2[NDKKind2[\"GroupAdminEditMetadata\"] = 9002] = \"GroupAdminEditMetadata\";\n  NDKKind2[NDKKind2[\"GroupAdminEditStatus\"] = 9006] = \"GroupAdminEditStatus\";\n  NDKKind2[NDKKind2[\"GroupAdminCreateGroup\"] = 9007] = \"GroupAdminCreateGroup\";\n  NDKKind2[NDKKind2[\"GroupAdminRequestJoin\"] = 9021] = \"GroupAdminRequestJoin\";\n  NDKKind2[NDKKind2[\"MuteList\"] = 1e4] = \"MuteList\";\n  NDKKind2[NDKKind2[\"PinList\"] = 10001] = \"PinList\";\n  NDKKind2[NDKKind2[\"RelayList\"] = 10002] = \"RelayList\";\n  NDKKind2[NDKKind2[\"BookmarkList\"] = 10003] = \"BookmarkList\";\n  NDKKind2[NDKKind2[\"CommunityList\"] = 10004] = \"CommunityList\";\n  NDKKind2[NDKKind2[\"PublicChatList\"] = 10005] = \"PublicChatList\";\n  NDKKind2[NDKKind2[\"BlockRelayList\"] = 10006] = \"BlockRelayList\";\n  NDKKind2[NDKKind2[\"SearchRelayList\"] = 10007] = \"SearchRelayList\";\n  NDKKind2[NDKKind2[\"SimpleGroupList\"] = 10009] = \"SimpleGroupList\";\n  NDKKind2[NDKKind2[\"InterestList\"] = 10015] = \"InterestList\";\n  NDKKind2[NDKKind2[\"CashuMintList\"] = 10019] = \"CashuMintList\";\n  NDKKind2[NDKKind2[\"EmojiList\"] = 10030] = \"EmojiList\";\n  NDKKind2[NDKKind2[\"DirectMessageReceiveRelayList\"] = 10050] = \"DirectMessageReceiveRelayList\";\n  NDKKind2[NDKKind2[\"BlossomList\"] = 10063] = \"BlossomList\";\n  NDKKind2[NDKKind2[\"NostrWaletConnectInfo\"] = 13194] = \"NostrWaletConnectInfo\";\n  NDKKind2[NDKKind2[\"TierList\"] = 17e3] = \"TierList\";\n  NDKKind2[NDKKind2[\"CashuWallet\"] = 17375] = \"CashuWallet\";\n  NDKKind2[NDKKind2[\"FollowSet\"] = 3e4] = \"FollowSet\";\n  NDKKind2[NDKKind2[\"CategorizedPeopleList\"] = 3e4 /* FollowSet */] = \"CategorizedPeopleList\";\n  NDKKind2[NDKKind2[\"CategorizedBookmarkList\"] = 30001] = \"CategorizedBookmarkList\";\n  NDKKind2[NDKKind2[\"RelaySet\"] = 30002] = \"RelaySet\";\n  NDKKind2[NDKKind2[\"CategorizedRelayList\"] = 30002 /* RelaySet */] = \"CategorizedRelayList\";\n  NDKKind2[NDKKind2[\"BookmarkSet\"] = 30003] = \"BookmarkSet\";\n  NDKKind2[NDKKind2[\"CurationSet\"] = 30004] = \"CurationSet\";\n  NDKKind2[NDKKind2[\"ArticleCurationSet\"] = 30004] = \"ArticleCurationSet\";\n  NDKKind2[NDKKind2[\"VideoCurationSet\"] = 30005] = \"VideoCurationSet\";\n  NDKKind2[NDKKind2[\"ImageCurationSet\"] = 30006] = \"ImageCurationSet\";\n  NDKKind2[NDKKind2[\"InterestSet\"] = 30015] = \"InterestSet\";\n  NDKKind2[NDKKind2[\"InterestsList\"] = 30015 /* InterestSet */] = \"InterestsList\";\n  NDKKind2[NDKKind2[\"EmojiSet\"] = 30030] = \"EmojiSet\";\n  NDKKind2[NDKKind2[\"ModularArticle\"] = 30040] = \"ModularArticle\";\n  NDKKind2[NDKKind2[\"ModularArticleItem\"] = 30041] = \"ModularArticleItem\";\n  NDKKind2[NDKKind2[\"Wiki\"] = 30818] = \"Wiki\";\n  NDKKind2[NDKKind2[\"Draft\"] = 31234] = \"Draft\";\n  NDKKind2[NDKKind2[\"SubscriptionTier\"] = 37001] = \"SubscriptionTier\";\n  NDKKind2[NDKKind2[\"EcashMintRecommendation\"] = 38e3] = \"EcashMintRecommendation\";\n  NDKKind2[NDKKind2[\"HighlightSet\"] = 39802] = \"HighlightSet\";\n  NDKKind2[NDKKind2[\"CategorizedHighlightList\"] = 39802 /* HighlightSet */] = \"CategorizedHighlightList\";\n  NDKKind2[NDKKind2[\"Nutzap\"] = 9321] = \"Nutzap\";\n  NDKKind2[NDKKind2[\"ZapRequest\"] = 9734] = \"ZapRequest\";\n  NDKKind2[NDKKind2[\"Zap\"] = 9735] = \"Zap\";\n  NDKKind2[NDKKind2[\"Highlight\"] = 9802] = \"Highlight\";\n  NDKKind2[NDKKind2[\"ClientAuth\"] = 22242] = \"ClientAuth\";\n  NDKKind2[NDKKind2[\"NostrWalletConnectReq\"] = 23194] = \"NostrWalletConnectReq\";\n  NDKKind2[NDKKind2[\"NostrWalletConnectRes\"] = 23195] = \"NostrWalletConnectRes\";\n  NDKKind2[NDKKind2[\"NostrConnect\"] = 24133] = \"NostrConnect\";\n  NDKKind2[NDKKind2[\"BlossomUpload\"] = 24242] = \"BlossomUpload\";\n  NDKKind2[NDKKind2[\"HttpAuth\"] = 27235] = \"HttpAuth\";\n  NDKKind2[NDKKind2[\"ProfileBadge\"] = 30008] = \"ProfileBadge\";\n  NDKKind2[NDKKind2[\"BadgeDefinition\"] = 30009] = \"BadgeDefinition\";\n  NDKKind2[NDKKind2[\"MarketStall\"] = 30017] = \"MarketStall\";\n  NDKKind2[NDKKind2[\"MarketProduct\"] = 30018] = \"MarketProduct\";\n  NDKKind2[NDKKind2[\"Article\"] = 30023] = \"Article\";\n  NDKKind2[NDKKind2[\"AppSpecificData\"] = 30078] = \"AppSpecificData\";\n  NDKKind2[NDKKind2[\"Classified\"] = 30402] = \"Classified\";\n  NDKKind2[NDKKind2[\"HorizontalVideo\"] = 34235] = \"HorizontalVideo\";\n  NDKKind2[NDKKind2[\"VerticalVideo\"] = 34236] = \"VerticalVideo\";\n  NDKKind2[NDKKind2[\"LegacyCashuWallet\"] = 37375] = \"LegacyCashuWallet\";\n  NDKKind2[NDKKind2[\"GroupMetadata\"] = 39e3] = \"GroupMetadata\";\n  NDKKind2[NDKKind2[\"GroupAdmins\"] = 39001] = \"GroupAdmins\";\n  NDKKind2[NDKKind2[\"GroupMembers\"] = 39002] = \"GroupMembers\";\n  NDKKind2[NDKKind2[\"AppRecommendation\"] = 31989] = \"AppRecommendation\";\n  NDKKind2[NDKKind2[\"AppHandler\"] = 31990] = \"AppHandler\";\n  return NDKKind2;\n})(NDKKind || {});\nvar NDKListKinds = [\n  1e4 /* MuteList */,\n  10001 /* PinList */,\n  10002 /* RelayList */,\n  10003 /* BookmarkList */,\n  10004 /* CommunityList */,\n  10005 /* PublicChatList */,\n  10006 /* BlockRelayList */,\n  10007 /* SearchRelayList */,\n  10015 /* InterestList */,\n  10030 /* EmojiList */,\n  10050 /* DirectMessageReceiveRelayList */,\n  3e4 /* FollowSet */,\n  30003 /* BookmarkSet */,\n  30001 /* CategorizedBookmarkList */,\n  // Backwards compatibility\n  30002 /* RelaySet */,\n  30004 /* ArticleCurationSet */,\n  30005 /* VideoCurationSet */,\n  30015 /* InterestSet */,\n  30030 /* EmojiSet */,\n  39802 /* HighlightSet */\n];\n\n// src/events/index.ts\n\n\n// src/relay/sets/calculate.ts\n\n\n// src/outbox/write.ts\nfunction getRelaysForSync(ndk, author, type = \"write\") {\n  if (!ndk.outboxTracker) return void 0;\n  const item = ndk.outboxTracker.data.get(author);\n  if (!item) return void 0;\n  if (type === \"write\") {\n    return item.writeRelays;\n  }\n  return item.readRelays;\n}\nasync function getWriteRelaysFor(ndk, author, type = \"write\") {\n  if (!ndk.outboxTracker) return void 0;\n  if (!ndk.outboxTracker.data.has(author)) {\n    await ndk.outboxTracker.trackUsers([author]);\n  }\n  return getRelaysForSync(ndk, author, type);\n}\n\n// src/outbox/relay-ranking.ts\nfunction getTopRelaysForAuthors(ndk, authors) {\n  const relaysWithCount = /* @__PURE__ */ new Map();\n  authors.forEach((author) => {\n    const writeRelays = getRelaysForSync(ndk, author);\n    if (writeRelays) {\n      writeRelays.forEach((relay) => {\n        const count = relaysWithCount.get(relay) || 0;\n        relaysWithCount.set(relay, count + 1);\n      });\n    }\n  });\n  const sortedRelays = Array.from(relaysWithCount.entries()).sort((a, b) => b[1] - a[1]);\n  return sortedRelays.map((entry) => entry[0]);\n}\n\n// src/outbox/index.ts\nfunction getAllRelaysForAllPubkeys(ndk, pubkeys, type = \"read\") {\n  const pubkeysToRelays = /* @__PURE__ */ new Map();\n  const authorsMissingRelays = /* @__PURE__ */ new Set();\n  pubkeys.forEach((pubkey) => {\n    const relays = getRelaysForSync(ndk, pubkey, type);\n    if (relays && relays.size > 0) {\n      relays.forEach((relay) => {\n        const pubkeysInRelay = pubkeysToRelays.get(relay) || /* @__PURE__ */ new Set();\n        pubkeysInRelay.add(pubkey);\n      });\n      pubkeysToRelays.set(pubkey, relays);\n    } else {\n      authorsMissingRelays.add(pubkey);\n    }\n  });\n  return { pubkeysToRelays, authorsMissingRelays };\n}\nfunction chooseRelayCombinationForPubkeys(ndk, pubkeys, type, { count, preferredRelays } = {}) {\n  count ??= 2;\n  preferredRelays ??= /* @__PURE__ */ new Set();\n  const pool = ndk.pool;\n  const connectedRelays = pool.connectedRelays();\n  connectedRelays.forEach((relay) => {\n    preferredRelays?.add(relay.url);\n  });\n  const relayToAuthorsMap = /* @__PURE__ */ new Map();\n  const { pubkeysToRelays, authorsMissingRelays } = getAllRelaysForAllPubkeys(ndk, pubkeys, type);\n  const sortedRelays = getTopRelaysForAuthors(ndk, pubkeys);\n  const addAuthorToRelay = (author, relay) => {\n    const authorsInRelay = relayToAuthorsMap.get(relay) || [];\n    authorsInRelay.push(author);\n    relayToAuthorsMap.set(relay, authorsInRelay);\n  };\n  for (const [author, authorRelays] of pubkeysToRelays.entries()) {\n    let missingRelayCount = count;\n    for (const relay of connectedRelays) {\n      if (authorRelays.has(relay.url)) {\n        addAuthorToRelay(author, relay.url);\n        missingRelayCount--;\n      }\n    }\n    for (const authorRelay of authorRelays) {\n      if (relayToAuthorsMap.has(authorRelay)) {\n        addAuthorToRelay(author, authorRelay);\n        missingRelayCount--;\n      }\n    }\n    if (missingRelayCount <= 0) continue;\n    for (const relay of sortedRelays) {\n      if (missingRelayCount <= 0) break;\n      if (authorRelays.has(relay)) {\n        addAuthorToRelay(author, relay);\n        missingRelayCount--;\n      }\n    }\n  }\n  for (const author of authorsMissingRelays) {\n    pool.permanentAndConnectedRelays().forEach((relay) => {\n      const authorsInRelay = relayToAuthorsMap.get(relay.url) || [];\n      authorsInRelay.push(author);\n      relayToAuthorsMap.set(relay.url, authorsInRelay);\n    });\n  }\n  return relayToAuthorsMap;\n}\n\n// src/outbox/read/with-authors.ts\nfunction getRelaysForFilterWithAuthors(ndk, authors, relayGoalPerAuthor = 2) {\n  return chooseRelayCombinationForPubkeys(ndk, authors, \"write\", { count: relayGoalPerAuthor });\n}\n\n// src/utils/normalize-url.ts\nfunction tryNormalizeRelayUrl(url) {\n  try {\n    return normalizeRelayUrl(url);\n  } catch {\n    return void 0;\n  }\n}\nfunction normalizeRelayUrl(url) {\n  let r = normalizeUrl(url, {\n    stripAuthentication: false,\n    stripWWW: false,\n    stripHash: true\n  });\n  if (!r.endsWith(\"/\")) {\n    r += \"/\";\n  }\n  return r;\n}\nfunction normalize(urls) {\n  const normalized = /* @__PURE__ */ new Set();\n  for (const url of urls) {\n    try {\n      normalized.add(normalizeRelayUrl(url));\n    } catch {\n    }\n  }\n  return Array.from(normalized);\n}\nvar DATA_URL_DEFAULT_MIME_TYPE = \"text/plain\";\nvar DATA_URL_DEFAULT_CHARSET = \"us-ascii\";\nvar testParameter = (name, filters) => filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);\nvar supportedProtocols = /* @__PURE__ */ new Set([\"https:\", \"http:\", \"file:\"]);\nvar hasCustomProtocol = (urlString) => {\n  try {\n    const { protocol } = new URL(urlString);\n    return protocol.endsWith(\":\") && !protocol.includes(\".\") && !supportedProtocols.has(protocol);\n  } catch {\n    return false;\n  }\n};\nvar normalizeDataURL = (urlString, { stripHash }) => {\n  const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);\n  if (!match) {\n    throw new Error(`Invalid URL: ${urlString}`);\n  }\n  const type = match.groups?.type ?? \"\";\n  const data = match.groups?.data ?? \"\";\n  let hash = match.groups?.hash ?? \"\";\n  const mediaType = type.split(\";\");\n  hash = stripHash ? \"\" : hash;\n  let isBase64 = false;\n  if (mediaType[mediaType.length - 1] === \"base64\") {\n    mediaType.pop();\n    isBase64 = true;\n  }\n  const mimeType = mediaType.shift()?.toLowerCase() ?? \"\";\n  const attributes = mediaType.map((attribute) => {\n    let [key, value = \"\"] = attribute.split(\"=\").map((string) => string.trim());\n    if (key === \"charset\") {\n      value = value.toLowerCase();\n      if (value === DATA_URL_DEFAULT_CHARSET) {\n        return \"\";\n      }\n    }\n    return `${key}${value ? `=${value}` : \"\"}`;\n  }).filter(Boolean);\n  const normalizedMediaType = [...attributes];\n  if (isBase64) {\n    normalizedMediaType.push(\"base64\");\n  }\n  if (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {\n    normalizedMediaType.unshift(mimeType);\n  }\n  return `data:${normalizedMediaType.join(\";\")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : \"\"}`;\n};\nfunction normalizeUrl(urlString, options = {}) {\n  options = {\n    defaultProtocol: \"http\",\n    normalizeProtocol: true,\n    forceHttp: false,\n    forceHttps: false,\n    stripAuthentication: true,\n    stripHash: false,\n    stripTextFragment: true,\n    stripWWW: true,\n    removeQueryParameters: [/^utm_\\w+/i],\n    removeTrailingSlash: true,\n    removeSingleSlash: true,\n    removeDirectoryIndex: false,\n    removeExplicitPort: false,\n    sortQueryParameters: true,\n    ...options\n  };\n  if (typeof options.defaultProtocol === \"string\" && !options.defaultProtocol.endsWith(\":\")) {\n    options.defaultProtocol = `${options.defaultProtocol}:`;\n  }\n  urlString = urlString.trim();\n  if (/^data:/i.test(urlString)) {\n    return normalizeDataURL(urlString, options);\n  }\n  if (hasCustomProtocol(urlString)) {\n    return urlString;\n  }\n  const hasRelativeProtocol = urlString.startsWith(\"//\");\n  const isRelativeUrl = !hasRelativeProtocol && /^\\.*\\//.test(urlString);\n  if (!isRelativeUrl) {\n    urlString = urlString.replace(/^(?!(?:\\w+:)?\\/\\/)|^\\/\\//, options.defaultProtocol);\n  }\n  const urlObject = new URL(urlString);\n  urlObject.hostname = urlObject.hostname.toLowerCase();\n  if (options.forceHttp && options.forceHttps) {\n    throw new Error(\"The `forceHttp` and `forceHttps` options cannot be used together\");\n  }\n  if (options.forceHttp && urlObject.protocol === \"https:\") {\n    urlObject.protocol = \"http:\";\n  }\n  if (options.forceHttps && urlObject.protocol === \"http:\") {\n    urlObject.protocol = \"https:\";\n  }\n  if (options.stripAuthentication) {\n    urlObject.username = \"\";\n    urlObject.password = \"\";\n  }\n  if (options.stripHash) {\n    urlObject.hash = \"\";\n  } else if (options.stripTextFragment) {\n    urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, \"\");\n  }\n  if (urlObject.pathname) {\n    const protocolRegex = /\\b[a-z][a-z\\d+\\-.]{1,50}:\\/\\//g;\n    let lastIndex = 0;\n    let result = \"\";\n    for (; ; ) {\n      const match = protocolRegex.exec(urlObject.pathname);\n      if (!match) {\n        break;\n      }\n      const protocol = match[0];\n      const protocolAtIndex = match.index;\n      const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);\n      result += intermediate.replace(/\\/{2,}/g, \"/\");\n      result += protocol;\n      lastIndex = protocolAtIndex + protocol.length;\n    }\n    const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);\n    result += remnant.replace(/\\/{2,}/g, \"/\");\n    urlObject.pathname = result;\n  }\n  if (urlObject.pathname) {\n    try {\n      urlObject.pathname = decodeURI(urlObject.pathname);\n    } catch {\n    }\n  }\n  if (options.removeDirectoryIndex === true) {\n    options.removeDirectoryIndex = [/^index\\.[a-z]+$/];\n  }\n  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {\n    let pathComponents = urlObject.pathname.split(\"/\");\n    const lastComponent = pathComponents[pathComponents.length - 1];\n    if (testParameter(lastComponent, options.removeDirectoryIndex)) {\n      pathComponents = pathComponents.slice(0, -1);\n      urlObject.pathname = `${pathComponents.slice(1).join(\"/\")}/`;\n    }\n  }\n  if (urlObject.hostname) {\n    urlObject.hostname = urlObject.hostname.replace(/\\.$/, \"\");\n    if (options.stripWWW && /^www\\.(?!www\\.)[a-z\\-\\d]{1,63}\\.[a-z.\\-\\d]{2,63}$/.test(urlObject.hostname)) {\n      urlObject.hostname = urlObject.hostname.replace(/^www\\./, \"\");\n    }\n  }\n  if (Array.isArray(options.removeQueryParameters)) {\n    for (const key of [...urlObject.searchParams.keys()]) {\n      if (testParameter(key, options.removeQueryParameters)) {\n        urlObject.searchParams.delete(key);\n      }\n    }\n  }\n  if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {\n    urlObject.search = \"\";\n  }\n  if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {\n    for (const key of [...urlObject.searchParams.keys()]) {\n      if (!testParameter(key, options.keepQueryParameters)) {\n        urlObject.searchParams.delete(key);\n      }\n    }\n  }\n  if (options.sortQueryParameters) {\n    urlObject.searchParams.sort();\n    try {\n      urlObject.search = decodeURIComponent(urlObject.search);\n    } catch {\n    }\n  }\n  if (options.removeTrailingSlash) {\n    urlObject.pathname = urlObject.pathname.replace(/\\/$/, \"\");\n  }\n  if (options.removeExplicitPort && urlObject.port) {\n    urlObject.port = \"\";\n  }\n  const oldUrlString = urlString;\n  urlString = urlObject.toString();\n  if (!options.removeSingleSlash && urlObject.pathname === \"/\" && !oldUrlString.endsWith(\"/\") && urlObject.hash === \"\") {\n    urlString = urlString.replace(/\\/$/, \"\");\n  }\n  if ((options.removeTrailingSlash || urlObject.pathname === \"/\") && urlObject.hash === \"\" && options.removeSingleSlash) {\n    urlString = urlString.replace(/\\/$/, \"\");\n  }\n  if (hasRelativeProtocol && !options.normalizeProtocol) {\n    urlString = urlString.replace(/^http:\\/\\//, \"//\");\n  }\n  if (options.stripProtocol) {\n    urlString = urlString.replace(/^(?:https?:)?\\/\\//, \"\");\n  }\n  return urlString;\n}\n\n// src/relay/index.ts\n\n\n\n// src/relay/connectivity.ts\nvar MAX_RECONNECT_ATTEMPTS = 5;\nvar FLAPPING_THRESHOLD_MS = 1e3;\nvar NDKRelayConnectivity = class {\n  ndkRelay;\n  ws;\n  _status;\n  timeoutMs;\n  connectedAt;\n  _connectionStats = {\n    attempts: 0,\n    success: 0,\n    durations: []\n  };\n  debug;\n  netDebug;\n  connectTimeout;\n  reconnectTimeout;\n  ndk;\n  openSubs = /* @__PURE__ */ new Map();\n  openCountRequests = /* @__PURE__ */ new Map();\n  openEventPublishes = /* @__PURE__ */ new Map();\n  serial = 0;\n  baseEoseTimeout = 4400;\n  constructor(ndkRelay, ndk) {\n    this.ndkRelay = ndkRelay;\n    this._status = 1 /* DISCONNECTED */;\n    const rand = Math.floor(Math.random() * 1e3);\n    this.debug = this.ndkRelay.debug.extend(`connectivity${rand}`);\n    this.ndk = ndk;\n  }\n  /**\n   * Connects to the NDK relay and handles the connection lifecycle.\n   *\n   * This method attempts to establish a WebSocket connection to the NDK relay specified in the `ndkRelay` object.\n   * If the connection is successful, it updates the connection statistics, sets the connection status to `CONNECTED`,\n   * and emits `connect` and `ready` events on the `ndkRelay` object.\n   *\n   * If the connection attempt fails, it handles the error by either initiating a reconnection attempt or emitting a\n   * `delayed-connect` event on the `ndkRelay` object, depending on the `reconnect` parameter.\n   *\n   * @param timeoutMs - The timeout in milliseconds for the connection attempt. If not provided, the default timeout from the `ndkRelay` object is used.\n   * @param reconnect - Indicates whether a reconnection should be attempted if the connection fails. Defaults to `true`.\n   * @returns A Promise that resolves when the connection is established, or rejects if the connection fails.\n   */\n  async connect(timeoutMs, reconnect = true) {\n    if (this._status !== 2 /* RECONNECTING */ && this._status !== 1 /* DISCONNECTED */ || this.reconnectTimeout) {\n      this.debug(\n        \"Relay requested to be connected but was in state %s or it had a reconnect timeout\",\n        this._status\n      );\n      return;\n    }\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = void 0;\n    }\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = void 0;\n    }\n    timeoutMs ??= this.timeoutMs;\n    if (!this.timeoutMs && timeoutMs) this.timeoutMs = timeoutMs;\n    if (this.timeoutMs) this.connectTimeout = setTimeout(() => this.onConnectionError(reconnect), this.timeoutMs);\n    try {\n      this.updateConnectionStats.attempt();\n      if (this._status === 1 /* DISCONNECTED */) this._status = 4 /* CONNECTING */;\n      else this._status = 2 /* RECONNECTING */;\n      this.ws = new WebSocket(this.ndkRelay.url);\n      this.ws.onopen = this.onConnect.bind(this);\n      this.ws.onclose = this.onDisconnect.bind(this);\n      this.ws.onmessage = this.onMessage.bind(this);\n      this.ws.onerror = this.onError.bind(this);\n    } catch (e) {\n      this.debug(`Failed to connect to ${this.ndkRelay.url}`, e);\n      this._status = 1 /* DISCONNECTED */;\n      if (reconnect) this.handleReconnection();\n      else this.ndkRelay.emit(\"delayed-connect\", 2 * 24 * 60 * 60 * 1e3);\n      throw e;\n    }\n  }\n  /**\n   * Disconnects the WebSocket connection to the NDK relay.\n   * This method sets the connection status to `NDKRelayStatus.DISCONNECTING`,\n   * attempts to close the WebSocket connection, and sets the status to\n   * `NDKRelayStatus.DISCONNECTED` if the disconnect operation fails.\n   */\n  disconnect() {\n    this._status = 0 /* DISCONNECTING */;\n    try {\n      this.ws?.close();\n    } catch (e) {\n      this.debug(\"Failed to disconnect\", e);\n      this._status = 1 /* DISCONNECTED */;\n    }\n  }\n  /**\n   * Handles the error that occurred when attempting to connect to the NDK relay.\n   * If `reconnect` is `true`, this method will initiate a reconnection attempt.\n   * Otherwise, it will emit a `delayed-connect` event on the `ndkRelay` object,\n   * indicating that a reconnection should be attempted after a delay.\n   *\n   * @param reconnect - Indicates whether a reconnection should be attempted.\n   */\n  onConnectionError(reconnect) {\n    this.debug(`Error connecting to ${this.ndkRelay.url}`, this.timeoutMs);\n    if (reconnect && !this.reconnectTimeout) {\n      this.handleReconnection();\n    }\n  }\n  /**\n   * Handles the connection event when the WebSocket connection is established.\n   * This method is called when the WebSocket connection is successfully opened.\n   * It clears any existing connection and reconnection timeouts, updates the connection statistics,\n   * sets the connection status to `CONNECTED`, and emits `connect` and `ready` events on the `ndkRelay` object.\n   */\n  onConnect() {\n    this.netDebug?.(\"connected\", this.ndkRelay);\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = void 0;\n    }\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = void 0;\n    }\n    this.updateConnectionStats.connected();\n    this._status = 5 /* CONNECTED */;\n    this.ndkRelay.emit(\"connect\");\n    this.ndkRelay.emit(\"ready\");\n  }\n  /**\n   * Handles the disconnection event when the WebSocket connection is closed.\n   * This method is called when the WebSocket connection is successfully closed.\n   * It updates the connection statistics, sets the connection status to `DISCONNECTED`,\n   * initiates a reconnection attempt if we didn't disconnect ourselves,\n   * and emits a `disconnect` event on the `ndkRelay` object.\n   */\n  onDisconnect() {\n    this.netDebug?.(\"disconnected\", this.ndkRelay);\n    this.updateConnectionStats.disconnected();\n    if (this._status === 5 /* CONNECTED */) {\n      this.handleReconnection();\n    }\n    this._status = 1 /* DISCONNECTED */;\n    this.ndkRelay.emit(\"disconnect\");\n  }\n  /**\n   * Handles incoming messages from the NDK relay WebSocket connection.\n   * This method is called whenever a message is received from the relay.\n   * It parses the message data and dispatches the appropriate handling logic based on the message type.\n   *\n   * @param event - The MessageEvent containing the received message data.\n   */\n  onMessage(event) {\n    this.netDebug?.(event.data, this.ndkRelay, \"recv\");\n    try {\n      const data = JSON.parse(event.data);\n      const [cmd, id, ..._rest] = data;\n      switch (cmd) {\n        case \"EVENT\": {\n          const so = this.openSubs.get(id);\n          const event2 = data[2];\n          if (!so) {\n            this.debug(`Received event for unknown subscription ${id}`);\n            return;\n          }\n          so.onevent(event2);\n          return;\n        }\n        case \"COUNT\": {\n          const payload = data[2];\n          const cr = this.openCountRequests.get(id);\n          if (cr) {\n            cr.resolve(payload.count);\n            this.openCountRequests.delete(id);\n          }\n          return;\n        }\n        case \"EOSE\": {\n          const so = this.openSubs.get(id);\n          if (!so) return;\n          so.oneose(id);\n          return;\n        }\n        case \"OK\": {\n          const ok = data[2];\n          const reason = data[3];\n          const ep = this.openEventPublishes.get(id);\n          const firstEp = ep?.pop();\n          if (!ep || !firstEp) {\n            this.debug(\"Received OK for unknown event publish\", id);\n            return;\n          }\n          if (ok) firstEp.resolve(reason);\n          else firstEp.reject(new Error(reason));\n          if (ep.length === 0) {\n            this.openEventPublishes.delete(id);\n          } else {\n            this.openEventPublishes.set(id, ep);\n          }\n          return;\n        }\n        case \"CLOSED\": {\n          const so = this.openSubs.get(id);\n          if (!so) return;\n          so.onclosed(data[2]);\n          return;\n        }\n        case \"NOTICE\":\n          this.onNotice(data[1]);\n          return;\n        case \"AUTH\": {\n          this.onAuthRequested(data[1]);\n          return;\n        }\n      }\n    } catch (error) {\n      this.debug(`Error parsing message from ${this.ndkRelay.url}: ${error.message}`, error?.stack);\n      return;\n    }\n  }\n  /**\n   * Handles an authentication request from the NDK relay.\n   *\n   * If an authentication policy is configured, it will be used to authenticate the connection.\n   * Otherwise, the `auth` event will be emitted to allow the application to handle the authentication.\n   *\n   * @param challenge - The authentication challenge provided by the NDK relay.\n   */\n  async onAuthRequested(challenge) {\n    const authPolicy = this.ndkRelay.authPolicy ?? this.ndk?.relayAuthDefaultPolicy;\n    this.debug(\"Relay requested authentication\", {\n      havePolicy: !!authPolicy\n    });\n    if (this._status === 7 /* AUTHENTICATING */) {\n      this.debug(\"Already authenticating, ignoring\");\n      return;\n    }\n    this._status = 6 /* AUTH_REQUESTED */;\n    if (authPolicy) {\n      if (this._status >= 5 /* CONNECTED */) {\n        this._status = 7 /* AUTHENTICATING */;\n        let res;\n        try {\n          res = await authPolicy(this.ndkRelay, challenge);\n        } catch (e) {\n          this.debug(\"Authentication policy threw an error\", e);\n          res = false;\n        }\n        this.debug(\"Authentication policy returned\", !!res);\n        if (res instanceof NDKEvent || res === true) {\n          if (res instanceof NDKEvent) {\n            await this.auth(res);\n          }\n          const authenticate = async () => {\n            if (this._status >= 5 /* CONNECTED */ && this._status < 8 /* AUTHENTICATED */) {\n              const event = new NDKEvent(this.ndk);\n              event.kind = 22242 /* ClientAuth */;\n              event.tags = [\n                [\"relay\", this.ndkRelay.url],\n                [\"challenge\", challenge]\n              ];\n              await event.sign();\n              this.auth(event).then(() => {\n                this._status = 8 /* AUTHENTICATED */;\n                this.ndkRelay.emit(\"authed\");\n                this.debug(\"Authentication successful\");\n              }).catch((e) => {\n                this._status = 6 /* AUTH_REQUESTED */;\n                this.ndkRelay.emit(\"auth:failed\", e);\n                this.debug(\"Authentication failed\", e);\n              });\n            } else {\n              this.debug(\"Authentication failed, it changed status, status is %d\", this._status);\n            }\n          };\n          if (res === true) {\n            if (!this.ndk?.signer) {\n              this.debug(\"No signer available for authentication localhost\");\n              this.ndk?.once(\"signer:ready\", authenticate);\n            } else {\n              authenticate().catch((e) => {\n                console.error(\"Error authenticating\", e);\n              });\n            }\n          }\n          this._status = 5 /* CONNECTED */;\n          this.ndkRelay.emit(\"authed\");\n        }\n      }\n    } else {\n      this.ndkRelay.emit(\"auth\", challenge);\n    }\n  }\n  /**\n   * Handles errors that occur on the WebSocket connection to the relay.\n   * @param error - The error or event that occurred.\n   */\n  onError(error) {\n    this.debug(`WebSocket error on ${this.ndkRelay.url}:`, error);\n  }\n  /**\n   * Gets the current status of the NDK relay connection.\n   * @returns {NDKRelayStatus} The current status of the NDK relay connection.\n   */\n  get status() {\n    return this._status;\n  }\n  /**\n   * Checks if the NDK relay connection is currently available.\n   * @returns {boolean} `true` if the relay connection is in the `CONNECTED` status, `false` otherwise.\n   */\n  isAvailable() {\n    return this._status === 5 /* CONNECTED */;\n  }\n  /**\n   * Checks if the NDK relay connection is flapping, which means the connection is rapidly\n   * disconnecting and reconnecting. This is determined by analyzing the durations of the\n   * last three connection attempts. If the standard deviation of the durations is less\n   * than 1000 milliseconds, the connection is considered to be flapping.\n   *\n   * @returns {boolean} `true` if the connection is flapping, `false` otherwise.\n   */\n  isFlapping() {\n    const durations = this._connectionStats.durations;\n    if (durations.length % 3 !== 0) return false;\n    const sum = durations.reduce((a, b) => a + b, 0);\n    const avg = sum / durations.length;\n    const variance = durations.map((x) => (x - avg) ** 2).reduce((a, b) => a + b, 0) / durations.length;\n    const stdDev = Math.sqrt(variance);\n    const isFlapping = stdDev < FLAPPING_THRESHOLD_MS;\n    return isFlapping;\n  }\n  /**\n   * Handles a notice received from the NDK relay.\n   * If the notice indicates the relay is complaining (e.g. \"too many\" or \"maximum\"),\n   * the method disconnects from the relay and attempts to reconnect after a 2-second delay.\n   * A debug message is logged with the relay URL and the notice text.\n   * The \"notice\" event is emitted on the ndkRelay instance with the notice text.\n   *\n   * @param notice - The notice text received from the NDK relay.\n   */\n  async onNotice(notice) {\n    this.ndkRelay.emit(\"notice\", notice);\n  }\n  /**\n   * Attempts to reconnect to the NDK relay after a connection is lost.\n   * This function is called recursively to handle multiple reconnection attempts.\n   * It checks if the relay is flapping and emits a \"flapping\" event if so.\n   * It then calculates a delay before the next reconnection attempt based on the number of previous attempts.\n   * The function sets a timeout to execute the next reconnection attempt after the calculated delay.\n   * If the maximum number of reconnection attempts is reached, a debug message is logged.\n   *\n   * @param attempt - The current attempt number (default is 0).\n   */\n  handleReconnection(attempt = 0) {\n    if (this.reconnectTimeout) return;\n    if (this.isFlapping()) {\n      this.ndkRelay.emit(\"flapping\", this._connectionStats);\n      this._status = 3 /* FLAPPING */;\n      return;\n    }\n    const reconnectDelay = this.connectedAt ? Math.max(0, 6e4 - (Date.now() - this.connectedAt)) : 5e3 * (this._connectionStats.attempts + 1);\n    this.reconnectTimeout = setTimeout(() => {\n      this.reconnectTimeout = void 0;\n      this._status = 2 /* RECONNECTING */;\n      this.connect().catch((_err) => {\n        if (attempt < MAX_RECONNECT_ATTEMPTS) {\n          setTimeout(\n            () => {\n              this.handleReconnection(attempt + 1);\n            },\n            1e3 * (attempt + 1) ^ 4\n          );\n        } else {\n          this.debug(\"Reconnect failed\");\n        }\n      });\n    }, reconnectDelay);\n    this.ndkRelay.emit(\"delayed-connect\", reconnectDelay);\n    this.debug(\"Reconnecting in\", reconnectDelay);\n    this._connectionStats.nextReconnectAt = Date.now() + reconnectDelay;\n  }\n  /**\n   * Sends a message to the NDK relay if the connection is in the CONNECTED state and the WebSocket is open.\n   * If the connection is not in the CONNECTED state or the WebSocket is not open, logs a debug message and throws an error.\n   *\n   * @param message - The message to send to the NDK relay.\n   * @throws {Error} If attempting to send on a closed relay connection.\n   */\n  async send(message) {\n    if (this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN) {\n      this.ws?.send(message);\n      this.netDebug?.(message, this.ndkRelay, \"send\");\n    } else {\n      this.debug(`Not connected to ${this.ndkRelay.url} (%d), not sending message ${message}`, this._status);\n    }\n  }\n  /**\n   * Authenticates the NDK event by sending it to the NDK relay and returning a promise that resolves with the result.\n   *\n   * @param event - The NDK event to authenticate.\n   * @returns A promise that resolves with the authentication result.\n   */\n  async auth(event) {\n    const ret = new Promise((resolve, reject) => {\n      const val = this.openEventPublishes.get(event.id) ?? [];\n      val.push({ resolve, reject });\n      this.openEventPublishes.set(event.id, val);\n    });\n    this.send(`[\"AUTH\",${JSON.stringify(event.rawEvent())}]`);\n    return ret;\n  }\n  /**\n   * Publishes an NDK event to the relay and returns a promise that resolves with the result.\n   *\n   * @param event - The NDK event to publish.\n   * @returns A promise that resolves with the result of the event publication.\n   * @throws {Error} If attempting to publish on a closed relay connection.\n   */\n  async publish(event) {\n    const ret = new Promise((resolve, reject) => {\n      const val = this.openEventPublishes.get(event.id) ?? [];\n      if (val.length > 0) {\n        console.warn(`Duplicate event publishing detected, you are publishing event ${event.id} twice`);\n      }\n      val.push({ resolve, reject });\n      this.openEventPublishes.set(event.id, val);\n    });\n    this.send(`[\"EVENT\",${JSON.stringify(event)}]`);\n    return ret;\n  }\n  /**\n   * Counts the number of events that match the provided filters.\n   *\n   * @param filters - The filters to apply to the count request.\n   * @param params - An optional object containing a custom id for the count request.\n   * @returns A promise that resolves with the number of matching events.\n   * @throws {Error} If attempting to send the count request on a closed relay connection.\n   */\n  async count(filters, params) {\n    this.serial++;\n    const id = params?.id || `count:${this.serial}`;\n    const ret = new Promise((resolve, reject) => {\n      this.openCountRequests.set(id, { resolve, reject });\n    });\n    this.send(`[\"COUNT\",\"${id}\",${JSON.stringify(filters).substring(1)}`);\n    return ret;\n  }\n  close(subId, reason) {\n    this.send(`[\"CLOSE\",\"${subId}\"]`);\n    const sub = this.openSubs.get(subId);\n    this.openSubs.delete(subId);\n    if (sub) sub.onclose(reason);\n  }\n  /**\n   * Subscribes to the NDK relay with the provided filters and parameters.\n   *\n   * @param filters - The filters to apply to the subscription.\n   * @param params - The subscription parameters, including an optional custom id.\n   * @returns A new NDKRelaySubscription instance.\n   */\n  req(relaySub) {\n    `${this.send(`[\"REQ\",\"${relaySub.subId}\",${JSON.stringify(relaySub.executeFilters).substring(1)}`)}]`;\n    this.openSubs.set(relaySub.subId, relaySub);\n  }\n  /**\n   * Utility functions to update the connection stats.\n   */\n  updateConnectionStats = {\n    connected: () => {\n      this._connectionStats.success++;\n      this._connectionStats.connectedAt = Date.now();\n    },\n    disconnected: () => {\n      if (this._connectionStats.connectedAt) {\n        this._connectionStats.durations.push(Date.now() - this._connectionStats.connectedAt);\n        if (this._connectionStats.durations.length > 100) {\n          this._connectionStats.durations.shift();\n        }\n      }\n      this._connectionStats.connectedAt = void 0;\n    },\n    attempt: () => {\n      this._connectionStats.attempts++;\n      this._connectionStats.connectedAt = Date.now();\n    }\n  };\n  /** Returns the connection stats. */\n  get connectionStats() {\n    return this._connectionStats;\n  }\n  /** Returns the relay URL */\n  get url() {\n    return this.ndkRelay.url;\n  }\n  get connected() {\n    return this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN;\n  }\n};\n\n// src/relay/publisher.ts\nvar NDKRelayPublisher = class {\n  ndkRelay;\n  debug;\n  constructor(ndkRelay) {\n    this.ndkRelay = ndkRelay;\n    this.debug = ndkRelay.debug.extend(\"publisher\");\n  }\n  /**\n   * Published an event to the relay; if the relay is not connected, it will\n   * wait for the relay to connect before publishing the event.\n   *\n   * If the relay does not connect within the timeout, the publish operation\n   * will fail.\n   * @param event  The event to publish\n   * @param timeoutMs  The timeout for the publish operation in milliseconds\n   * @returns A promise that resolves when the event has been published or rejects if the operation times out\n   */\n  async publish(event, timeoutMs = 2500) {\n    let timeout;\n    const publishConnected = () => {\n      return new Promise((resolve, reject) => {\n        try {\n          this.publishEvent(event).then((_result) => {\n            this.ndkRelay.emit(\"published\", event);\n            event.emit(\"relay:published\", this.ndkRelay);\n            resolve(true);\n          }).catch(reject);\n        } catch (err) {\n          reject(err);\n        }\n      });\n    };\n    const timeoutPromise = new Promise((_, reject) => {\n      timeout = setTimeout(() => {\n        timeout = void 0;\n        reject(new Error(`Timeout: ${timeoutMs}ms`));\n      }, timeoutMs);\n    });\n    const onConnectHandler = () => {\n      publishConnected().then((result) => connectResolve(result)).catch((err) => connectReject(err));\n    };\n    let connectResolve;\n    let connectReject;\n    const onError = (err) => {\n      this.ndkRelay.debug(\"Publish failed\", err, event.id);\n      this.ndkRelay.emit(\"publish:failed\", event, err);\n      event.emit(\"relay:publish:failed\", this.ndkRelay, err);\n      throw err;\n    };\n    const onFinally = () => {\n      if (timeout) clearTimeout(timeout);\n      this.ndkRelay.removeListener(\"connect\", onConnectHandler);\n    };\n    if (this.ndkRelay.status >= 5 /* CONNECTED */) {\n      return Promise.race([publishConnected(), timeoutPromise]).catch(onError).finally(onFinally);\n    }\n    if (this.ndkRelay.status <= 1 /* DISCONNECTED */) {\n      console.warn(\"Relay is disconnected, trying to connect to publish an event\", this.ndkRelay.url);\n      this.ndkRelay.connect();\n    } else {\n      console.warn(\"Relay not connected, waiting for connection to publish an event\", this.ndkRelay.url);\n    }\n    return Promise.race([\n      new Promise((resolve, reject) => {\n        connectResolve = resolve;\n        connectReject = reject;\n        this.ndkRelay.once(\"connect\", onConnectHandler);\n      }),\n      timeoutPromise\n    ]).catch(onError).finally(onFinally);\n  }\n  async publishEvent(event) {\n    return this.ndkRelay.connectivity.publish(event.rawEvent());\n  }\n};\n\n// src/subscription/grouping.ts\nfunction filterFingerprint(filters, closeOnEose) {\n  const elements = [];\n  for (const filter of filters) {\n    const keys = Object.entries(filter || {}).map(([key, values]) => {\n      if ([\"since\", \"until\"].includes(key)) {\n        return `${key}:${values}`;\n      }\n      return key;\n    }).sort().join(\"-\");\n    elements.push(keys);\n  }\n  let id = closeOnEose ? \"+\" : \"\";\n  id += elements.join(\"|\");\n  return id;\n}\nfunction mergeFilters(filters) {\n  const result = [];\n  const lastResult = {};\n  filters.filter((f) => !!f.limit).forEach((filterWithLimit) => result.push(filterWithLimit));\n  filters = filters.filter((f) => !f.limit);\n  if (filters.length === 0) return result;\n  filters.forEach((filter) => {\n    Object.entries(filter).forEach(([key, value]) => {\n      if (Array.isArray(value)) {\n        if (lastResult[key] === void 0) {\n          lastResult[key] = [...value];\n        } else {\n          lastResult[key] = Array.from(/* @__PURE__ */ new Set([...lastResult[key], ...value]));\n        }\n      } else {\n        lastResult[key] = value;\n      }\n    });\n  });\n  return [...result, lastResult];\n}\n\n// src/relay/subscription.ts\nvar NDKRelaySubscription = class {\n  fingerprint;\n  items = /* @__PURE__ */ new Map();\n  topSubManager;\n  debug;\n  /**\n   * Tracks the status of this REQ.\n   */\n  status = 0 /* INITIAL */;\n  onClose;\n  relay;\n  /**\n   * Whether this subscription has reached EOSE.\n   */\n  eosed = false;\n  /**\n   * Timeout at which this subscription will\n   * start executing.\n   */\n  executionTimer;\n  /**\n   * Track the time at which this subscription will fire.\n   */\n  fireTime;\n  /**\n   * The delay type that the current fireTime was calculated with.\n   */\n  delayType;\n  /**\n   * The filters that have been executed.\n   */\n  executeFilters;\n  id = Math.random().toString(36).substring(7);\n  /**\n   *\n   * @param fingerprint The fingerprint of this subscription.\n   */\n  constructor(relay, fingerprint, topSubManager) {\n    this.relay = relay;\n    this.topSubManager = topSubManager;\n    this.debug = relay.debug.extend(`sub[${this.id}]`);\n    this.fingerprint = fingerprint || Math.random().toString(36).substring(7);\n  }\n  _subId;\n  get subId() {\n    if (this._subId) return this._subId;\n    this._subId = this.fingerprint.slice(0, 15);\n    return this._subId;\n  }\n  subIdParts = /* @__PURE__ */ new Set();\n  addSubIdPart(part) {\n    this.subIdParts.add(part);\n  }\n  addItem(subscription, filters) {\n    this.debug(\"Adding item\", {\n      filters,\n      internalId: subscription.internalId,\n      status: this.status,\n      fingerprint: this.fingerprint,\n      id: this.subId,\n      items: this.items,\n      itemsSize: this.items.size\n    });\n    if (this.items.has(subscription.internalId)) return;\n    subscription.on(\"close\", this.removeItem.bind(this, subscription));\n    this.items.set(subscription.internalId, { subscription, filters });\n    if (this.status !== 3 /* RUNNING */) {\n      if (subscription.subId && (!this._subId || this._subId.length < 48)) {\n        if (this.status === 0 /* INITIAL */ || this.status === 1 /* PENDING */) {\n          this.addSubIdPart(subscription.subId);\n        }\n      }\n    }\n    switch (this.status) {\n      case 0 /* INITIAL */:\n        this.evaluateExecutionPlan(subscription);\n        break;\n      case 3 /* RUNNING */:\n        break;\n      case 1 /* PENDING */:\n        this.evaluateExecutionPlan(subscription);\n        break;\n      case 4 /* CLOSED */:\n        this.debug(\"Subscription is closed, cannot add new items %o (%o)\", subscription, filters);\n        throw new Error(\"Cannot add new items to a closed subscription\");\n    }\n  }\n  /**\n   * A subscription has been closed, remove it from the list of items.\n   * @param subscription\n   */\n  removeItem(subscription) {\n    this.items.delete(subscription.internalId);\n    if (this.items.size === 0) {\n      if (!this.eosed) return;\n      this.close();\n      this.cleanup();\n    }\n  }\n  close() {\n    if (this.status === 4 /* CLOSED */) return;\n    const prevStatus = this.status;\n    this.status = 4 /* CLOSED */;\n    if (prevStatus === 3 /* RUNNING */) {\n      try {\n        this.relay.close(this.subId);\n      } catch (e) {\n        this.debug(\"Error closing subscription\", e, this);\n      }\n    } else {\n      this.debug(\"Subscription wanted to close but it wasn't running, this is probably ok\", {\n        subId: this.subId,\n        prevStatus,\n        sub: this\n      });\n    }\n    this.cleanup();\n  }\n  cleanup() {\n    if (this.executionTimer) clearTimeout(this.executionTimer);\n    this.relay.off(\"ready\", this.executeOnRelayReady);\n    this.relay.off(\"authed\", this.reExecuteAfterAuth);\n    if (this.onClose) this.onClose(this);\n  }\n  evaluateExecutionPlan(subscription) {\n    if (!subscription.isGroupable()) {\n      this.status = 1 /* PENDING */;\n      this.execute();\n      return;\n    }\n    if (subscription.filters.find((filter) => !!filter.limit)) {\n      this.executeFilters = this.compileFilters();\n      if (this.executeFilters.length >= 10) {\n        this.status = 1 /* PENDING */;\n        this.execute();\n        return;\n      }\n    }\n    const delay = subscription.groupableDelay;\n    const delayType = subscription.groupableDelayType;\n    if (!delay) throw new Error(\"Cannot group a subscription without a delay\");\n    if (this.status === 0 /* INITIAL */) {\n      this.schedule(delay, delayType);\n    } else {\n      const existingDelayType = this.delayType;\n      const timeUntilFire = this.fireTime - Date.now();\n      if (existingDelayType === \"at-least\" && delayType === \"at-least\") {\n        if (timeUntilFire < delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-least\" && delayType === \"at-most\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-most\" && delayType === \"at-most\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-most\" && delayType === \"at-least\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else {\n        throw new Error(`Unknown delay type combination ${existingDelayType} ${delayType}`);\n      }\n    }\n  }\n  schedule(delay, delayType) {\n    this.status = 1 /* PENDING */;\n    const currentTime = Date.now();\n    this.fireTime = currentTime + delay;\n    this.delayType = delayType;\n    const timer = setTimeout(this.execute.bind(this), delay);\n    if (delayType === \"at-least\") {\n      this.executionTimer = timer;\n    }\n  }\n  executeOnRelayReady = () => {\n    if (this.status !== 2 /* WAITING */) return;\n    if (this.items.size === 0) {\n      this.debug(\"No items to execute; this relay was probably too slow to respond and the caller gave up\", {\n        status: this.status,\n        fingerprint: this.fingerprint,\n        items: this.items,\n        itemsSize: this.items.size,\n        id: this.id,\n        subId: this.subId\n      });\n      this.cleanup();\n      return;\n    }\n    this.debug(\"Executing on relay ready\", {\n      status: this.status,\n      fingerprint: this.fingerprint,\n      items: this.items,\n      itemsSize: this.items.size\n    });\n    this.status = 1 /* PENDING */;\n    this.execute();\n  };\n  finalizeSubId() {\n    if (this.subIdParts.size > 0) {\n      this._subId = Array.from(this.subIdParts).join(\"-\");\n    } else {\n      this._subId = this.fingerprint.slice(0, 15);\n    }\n    this._subId += `-${Math.random().toString(36).substring(2, 7)}`;\n  }\n  // we do it this way so that we can remove the listener\n  reExecuteAfterAuth = (() => {\n    const oldSubId = this.subId;\n    this.debug(\"Re-executing after auth\", this.items.size);\n    if (this.eosed) {\n      this.relay.close(this.subId);\n    } else {\n      this.debug(\"We are abandoning an opened subscription, once it EOSE's, the handler will close it\", {\n        oldSubId\n      });\n    }\n    this._subId = void 0;\n    this.status = 1 /* PENDING */;\n    this.execute();\n    this.debug(\"Re-executed after auth %s \\u{1F449} %s\", oldSubId, this.subId);\n  }).bind(this);\n  execute() {\n    if (this.status !== 1 /* PENDING */) {\n      return;\n    }\n    if (!this.relay.connected) {\n      this.status = 2 /* WAITING */;\n      this.debug(\"Waiting for relay to be ready\", {\n        status: this.status,\n        id: this.subId,\n        fingerprint: this.fingerprint,\n        items: this.items,\n        itemsSize: this.items.size\n      });\n      this.relay.once(\"ready\", this.executeOnRelayReady);\n      return;\n    }\n    if (this.relay.status < 8 /* AUTHENTICATED */) {\n      this.relay.once(\"authed\", this.reExecuteAfterAuth);\n    }\n    this.status = 3 /* RUNNING */;\n    this.finalizeSubId();\n    this.executeFilters = this.compileFilters();\n    this.relay.req(this);\n  }\n  onstart() {\n  }\n  onevent(event) {\n    this.topSubManager.dispatchEvent(event, this.relay);\n  }\n  oneose(subId) {\n    this.eosed = true;\n    if (subId !== this.subId) {\n      this.debug(\"Received EOSE for an abandoned subscription\", subId, this.subId);\n      this.relay.close(subId);\n      return;\n    }\n    if (this.items.size === 0) {\n      this.close();\n    }\n    for (const { subscription } of this.items.values()) {\n      subscription.eoseReceived(this.relay);\n      if (subscription.closeOnEose) {\n        this.debug(\"Removing item because of EOSE\", {\n          filters: subscription.filters,\n          internalId: subscription.internalId,\n          status: this.status,\n          fingerprint: this.fingerprint,\n          items: this.items,\n          itemsSize: this.items.size\n        });\n        this.removeItem(subscription);\n      }\n    }\n  }\n  onclose(_reason) {\n    this.status = 4 /* CLOSED */;\n  }\n  onclosed(reason) {\n    if (!reason) return;\n    for (const { subscription } of this.items.values()) {\n      subscription.closedReceived(this.relay, reason);\n    }\n  }\n  /**\n   * Grabs the filters from all the subscriptions\n   * and merges them into a single filter.\n   */\n  compileFilters() {\n    const mergedFilters = [];\n    const filters = Array.from(this.items.values()).map((item) => item.filters);\n    if (!filters[0]) {\n      this.debug(\"\\u{1F440} No filters to merge\", this.items);\n      console.error(\"BUG: No filters to merge!\", this.items);\n      return [];\n    }\n    const filterCount = filters[0].length;\n    for (let i = 0; i < filterCount; i++) {\n      const allFiltersAtIndex = filters.map((filter) => filter[i]);\n      mergedFilters.push(...mergeFilters(allFiltersAtIndex));\n    }\n    return mergedFilters;\n  }\n};\n\n// src/relay/sub-manager.ts\nvar NDKRelaySubscriptionManager = class {\n  relay;\n  subscriptions;\n  generalSubManager;\n  /**\n   * @param relay - The relay instance.\n   * @param generalSubManager - The subscription manager instance.\n   */\n  constructor(relay, generalSubManager) {\n    this.relay = relay;\n    this.subscriptions = /* @__PURE__ */ new Map();\n    this.generalSubManager = generalSubManager;\n  }\n  /**\n   * Adds a subscription to the manager.\n   */\n  addSubscription(sub, filters) {\n    let relaySub;\n    if (!sub.isGroupable()) {\n      relaySub = this.createSubscription(sub, filters);\n    } else {\n      const filterFp = filterFingerprint(filters, sub.closeOnEose);\n      if (filterFp) {\n        const existingSubs = this.subscriptions.get(filterFp);\n        relaySub = (existingSubs || []).find((sub2) => sub2.status < 3 /* RUNNING */);\n      }\n      relaySub ??= this.createSubscription(sub, filters, filterFp);\n    }\n    relaySub.addItem(sub, filters);\n  }\n  createSubscription(_sub, _filters, fingerprint) {\n    const relaySub = new NDKRelaySubscription(this.relay, fingerprint || null, this.generalSubManager);\n    relaySub.onClose = this.onRelaySubscriptionClose.bind(this);\n    const currentVal = this.subscriptions.get(relaySub.fingerprint) ?? [];\n    this.subscriptions.set(relaySub.fingerprint, [...currentVal, relaySub]);\n    return relaySub;\n  }\n  onRelaySubscriptionClose(sub) {\n    let currentVal = this.subscriptions.get(sub.fingerprint) ?? [];\n    if (!currentVal) {\n      console.warn(\"Unexpectedly did not find a subscription with fingerprint\", sub.fingerprint);\n    } else if (currentVal.length === 1) {\n      this.subscriptions.delete(sub.fingerprint);\n    } else {\n      currentVal = currentVal.filter((s) => s.id !== sub.id);\n      this.subscriptions.set(sub.fingerprint, currentVal);\n    }\n  }\n};\n\n// src/relay/index.ts\nvar NDKRelayStatus = /* @__PURE__ */ ((NDKRelayStatus2) => {\n  NDKRelayStatus2[NDKRelayStatus2[\"DISCONNECTING\"] = 0] = \"DISCONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"DISCONNECTED\"] = 1] = \"DISCONNECTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"FLAPPING\"] = 3] = \"FLAPPING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"CONNECTING\"] = 4] = \"CONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"CONNECTED\"] = 5] = \"CONNECTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTH_REQUESTED\"] = 6] = \"AUTH_REQUESTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTHENTICATING\"] = 7] = \"AUTHENTICATING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTHENTICATED\"] = 8] = \"AUTHENTICATED\";\n  return NDKRelayStatus2;\n})(NDKRelayStatus || {});\nvar NDKRelay = class _NDKRelay extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  url;\n  scores;\n  connectivity;\n  subs;\n  publisher;\n  authPolicy;\n  /**\n   * The lowest validation ratio this relay can reach.\n   */\n  lowestValidationRatio;\n  /**\n   * Current validation ratio this relay is targeting.\n   */\n  targetValidationRatio;\n  validationRatioFn;\n  /**\n   * This tracks events that have been seen by this relay\n   * with a valid signature.\n   */\n  validatedEventCount = 0;\n  /**\n   * This tracks events that have been seen by this relay\n   * but have not been validated.\n   */\n  nonValidatedEventCount = 0;\n  /**\n   * Whether this relay is trusted.\n   *\n   * Trusted relay's events do not get their signature verified.\n   */\n  trusted = false;\n  complaining = false;\n  debug;\n  static defaultValidationRatioUpdateFn = (relay, validatedCount, _nonValidatedCount) => {\n    if (relay.lowestValidationRatio === void 0 || relay.targetValidationRatio === void 0) return 1;\n    let newRatio = relay.validationRatio;\n    if (relay.validationRatio > relay.targetValidationRatio) {\n      const factor = validatedCount / 100;\n      newRatio = Math.max(relay.lowestValidationRatio, relay.validationRatio - factor);\n    }\n    if (newRatio < relay.validationRatio) {\n      return newRatio;\n    }\n    return relay.validationRatio;\n  };\n  constructor(url, authPolicy, ndk) {\n    super();\n    this.url = normalizeRelayUrl(url);\n    this.scores = /* @__PURE__ */ new Map();\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_1__(`ndk:relay:${url}`);\n    this.connectivity = new NDKRelayConnectivity(this, ndk);\n    this.connectivity.netDebug = ndk?.netDebug;\n    this.req = this.connectivity.req.bind(this.connectivity);\n    this.close = this.connectivity.close.bind(this.connectivity);\n    this.subs = new NDKRelaySubscriptionManager(this, ndk.subManager);\n    this.publisher = new NDKRelayPublisher(this);\n    this.authPolicy = authPolicy;\n    this.targetValidationRatio = ndk?.initialValidationRatio;\n    this.lowestValidationRatio = ndk?.lowestValidationRatio;\n    this.validationRatioFn = (ndk?.validationRatioFn ?? _NDKRelay.defaultValidationRatioUpdateFn).bind(this);\n    this.updateValidationRatio();\n    if (!ndk) {\n      console.trace(\"relay created without ndk\");\n    }\n  }\n  updateValidationRatio() {\n    setTimeout(() => {\n      this.updateValidationRatio();\n    }, 3e4);\n  }\n  get status() {\n    return this.connectivity.status;\n  }\n  get connectionStats() {\n    return this.connectivity.connectionStats;\n  }\n  /**\n   * Connects to the relay.\n   */\n  async connect(timeoutMs, reconnect = true) {\n    return this.connectivity.connect(timeoutMs, reconnect);\n  }\n  /**\n   * Disconnects from the relay.\n   */\n  disconnect() {\n    if (this.status === 1 /* DISCONNECTED */) {\n      return;\n    }\n    this.connectivity.disconnect();\n  }\n  /**\n   * Queues or executes the subscription of a specific set of filters\n   * within this relay.\n   *\n   * @param subscription NDKSubscription this filters belong to.\n   * @param filters Filters to execute\n   */\n  subscribe(subscription, filters) {\n    this.subs.addSubscription(subscription, filters);\n  }\n  /**\n   * Publishes an event to the relay with an optional timeout.\n   *\n   * If the relay is not connected, the event will be published when the relay connects,\n   * unless the timeout is reached before the relay connects.\n   *\n   * @param event The event to publish\n   * @param timeoutMs The timeout for the publish operation in milliseconds\n   * @returns A promise that resolves when the event has been published or rejects if the operation times out\n   */\n  async publish(event, timeoutMs = 2500) {\n    return this.publisher.publish(event, timeoutMs);\n  }\n  referenceTags() {\n    return [[\"r\", this.url]];\n  }\n  addValidatedEvent() {\n    this.validatedEventCount++;\n  }\n  addNonValidatedEvent() {\n    this.nonValidatedEventCount++;\n  }\n  /**\n   * The current validation ratio this relay has achieved.\n   */\n  get validationRatio() {\n    if (this.nonValidatedEventCount === 0) {\n      return 1;\n    }\n    return this.validatedEventCount / (this.validatedEventCount + this.nonValidatedEventCount);\n  }\n  shouldValidateEvent() {\n    if (this.trusted) {\n      return false;\n    }\n    if (this.targetValidationRatio === void 0) {\n      return true;\n    }\n    return this.validationRatio < this.targetValidationRatio;\n  }\n  get connected() {\n    return this.connectivity.connected;\n  }\n  req;\n  close;\n};\n\n// src/relay/sets/index.ts\nvar NDKPublishError = class extends Error {\n  errors;\n  publishedToRelays;\n  /**\n   * Intended relay set where the publishing was intended to happen.\n   */\n  intendedRelaySet;\n  constructor(message, errors, publishedToRelays, intendedRelaySet) {\n    super(message);\n    this.errors = errors;\n    this.publishedToRelays = publishedToRelays;\n    this.intendedRelaySet = intendedRelaySet;\n  }\n  get relayErrors() {\n    const errors = [];\n    for (const [relay, err] of this.errors) {\n      errors.push(`${relay.url}: ${err}`);\n    }\n    return errors.join(\"\\n\");\n  }\n};\nvar NDKRelaySet = class _NDKRelaySet {\n  relays;\n  debug;\n  ndk;\n  pool;\n  constructor(relays, ndk, pool) {\n    this.relays = relays;\n    this.ndk = ndk;\n    this.pool = pool ?? ndk.pool;\n    this.debug = ndk.debug.extend(\"relayset\");\n  }\n  /**\n   * Adds a relay to this set.\n   */\n  addRelay(relay) {\n    this.relays.add(relay);\n  }\n  get relayUrls() {\n    return Array.from(this.relays).map((r) => r.url);\n  }\n  /**\n   * Creates a relay set from a list of relay URLs.\n   *\n   * If no connection to the relay is found in the pool it will temporarily\n   * connect to it.\n   *\n   * @param relayUrls - list of relay URLs to include in this set\n   * @param ndk\n   * @param connect - whether to connect to the relay immediately if it was already in the pool but not connected\n   * @returns NDKRelaySet\n   */\n  static fromRelayUrls(relayUrls, ndk, connect = true, pool) {\n    pool = pool ?? ndk.pool;\n    if (!pool) throw new Error(\"No pool provided\");\n    const relays = /* @__PURE__ */ new Set();\n    for (const url of relayUrls) {\n      const relay = pool.relays.get(normalizeRelayUrl(url));\n      if (relay) {\n        if (relay.status < 5 /* CONNECTED */ && connect) {\n          relay.connect();\n        }\n        relays.add(relay);\n      } else {\n        const temporaryRelay = new NDKRelay(normalizeRelayUrl(url), ndk?.relayAuthDefaultPolicy, ndk);\n        pool.useTemporaryRelay(temporaryRelay, void 0, `requested from fromRelayUrls ${relayUrls}`);\n        relays.add(temporaryRelay);\n      }\n    }\n    return new _NDKRelaySet(new Set(relays), ndk, pool);\n  }\n  /**\n   * Publish an event to all relays in this relay set.\n   *\n   * This method implements a robust mechanism for publishing events to multiple relays with\n   * built-in handling for race conditions, timeouts, and partial failures. The implementation\n   * uses a dual-tracking mechanism to ensure accurate reporting of which relays successfully\n   * received an event.\n   *\n   * Key aspects of this implementation:\n   *\n   * 1. DUAL-TRACKING MECHANISM:\n   *    - Promise-based tracking: Records successes/failures from the promises returned by relay.publish()\n   *    - Event-based tracking: Listens for 'relay:published' events that indicate successful publishing\n   *    This approach ensures we don't miss successful publishes even if there are subsequent errors in\n   *    the promise chain.\n   *\n   * 2. RACE CONDITION HANDLING:\n   *    - If a relay emits a success event but later fails in the promise chain, we still count it as a success\n   *    - If a relay times out after successfully publishing, we still count it as a success\n   *    - All relay operations happen in parallel, with proper tracking regardless of completion order\n   *\n   * 3. TIMEOUT MANAGEMENT:\n   *    - Individual timeouts for each relay operation\n   *    - Proper cleanup of timeouts to prevent memory leaks\n   *    - Clear timeout error reporting\n   *\n   * 4. ERROR HANDLING:\n   *    - Detailed tracking of specific errors for each failed relay\n   *    - Special handling for ephemeral events (which don't expect acknowledgement)\n   *    - RequiredRelayCount parameter to control the minimum success threshold\n   *\n   * @param event Event to publish\n   * @param timeoutMs Timeout in milliseconds for each relay publish operation\n   * @param requiredRelayCount The minimum number of relays we expect the event to be published to\n   * @returns A set of relays the event was published to\n   * @throws {NDKPublishError} If the event could not be published to at least `requiredRelayCount` relays\n   * @example\n   * ```typescript\n   * const relaySet = new NDKRelaySet(new Set([relay1, relay2]), ndk);\n   * const publishedToRelays = await relaySet.publish(event);\n   * // publishedToRelays can contain relay1, relay2, both, or none\n   * // depending on which relays the event was successfully published to\n   * if (publishedToRelays.size > 0) {\n   *   console.log(\"Event published to at least one relay\");\n   * }\n   * ```\n   */\n  async publish(event, timeoutMs, requiredRelayCount = 1) {\n    const publishedToRelays = /* @__PURE__ */ new Set();\n    const errors = /* @__PURE__ */ new Map();\n    const isEphemeral2 = event.isEphemeral();\n    event.publishStatus = \"pending\";\n    const relayPublishedHandler = (relay) => {\n      publishedToRelays.add(relay);\n    };\n    event.on(\"relay:published\", relayPublishedHandler);\n    try {\n      const promises = Array.from(this.relays).map((relay) => {\n        return new Promise((resolve) => {\n          const timeoutId = timeoutMs ? setTimeout(() => {\n            if (!publishedToRelays.has(relay)) {\n              errors.set(relay, new Error(`Publish timeout after ${timeoutMs}ms`));\n              resolve(false);\n            }\n          }, timeoutMs) : null;\n          relay.publish(event, timeoutMs).then((success) => {\n            if (timeoutId) clearTimeout(timeoutId);\n            if (success) {\n              publishedToRelays.add(relay);\n              resolve(true);\n            } else {\n              resolve(false);\n            }\n          }).catch((err) => {\n            if (timeoutId) clearTimeout(timeoutId);\n            if (!isEphemeral2) {\n              errors.set(relay, err);\n            }\n            resolve(false);\n          });\n        });\n      });\n      await Promise.all(promises);\n      if (publishedToRelays.size < requiredRelayCount) {\n        if (!isEphemeral2) {\n          const error = new NDKPublishError(\n            \"Not enough relays received the event\",\n            errors,\n            publishedToRelays,\n            this\n          );\n          event.publishStatus = \"error\";\n          event.publishError = error;\n          this.ndk?.emit(\"event:publish-failed\", event, error, this.relayUrls);\n          throw error;\n        }\n      } else {\n        event.publishStatus = \"success\";\n        event.emit(\"published\", { relaySet: this, publishedToRelays });\n      }\n      return publishedToRelays;\n    } finally {\n      event.off(\"relay:published\", relayPublishedHandler);\n    }\n  }\n  get size() {\n    return this.relays.size;\n  }\n};\n\n// src/relay/sets/calculate.ts\nvar d = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:outbox:calculate\");\nasync function calculateRelaySetFromEvent(ndk, event) {\n  const relays = /* @__PURE__ */ new Set();\n  const authorWriteRelays = await getWriteRelaysFor(ndk, event.pubkey);\n  if (authorWriteRelays) {\n    authorWriteRelays.forEach((relayUrl) => {\n      const relay = ndk.pool?.getRelay(relayUrl);\n      if (relay) relays.add(relay);\n    });\n  }\n  let relayHints = event.tags.filter((tag) => [\"a\", \"e\"].includes(tag[0])).map((tag) => tag[2]).filter((url) => url?.startsWith(\"wss://\")).filter((url) => {\n    try {\n      new URL(url);\n      return true;\n    } catch {\n      return false;\n    }\n  }).map((url) => normalizeRelayUrl(url));\n  relayHints = Array.from(new Set(relayHints)).slice(0, 5);\n  relayHints.forEach((relayUrl) => {\n    const relay = ndk.pool?.getRelay(relayUrl, true, true);\n    if (relay) {\n      d(\"Adding relay hint %s\", relayUrl);\n      relays.add(relay);\n    }\n  });\n  const pTags = event.getMatchingTags(\"p\").map((tag) => tag[1]);\n  if (pTags.length < 5) {\n    const pTaggedRelays = Array.from(\n      chooseRelayCombinationForPubkeys(ndk, pTags, \"read\", {\n        preferredRelays: new Set(authorWriteRelays)\n      }).keys()\n    );\n    pTaggedRelays.forEach((relayUrl) => {\n      const relay = ndk.pool?.getRelay(relayUrl, false, true);\n      if (relay) {\n        d(\"Adding p-tagged relay %s\", relayUrl);\n        relays.add(relay);\n      }\n    });\n  } else {\n    d(\"Too many p-tags to consider %d\", pTags.length);\n  }\n  ndk.pool?.permanentAndConnectedRelays().forEach((relay) => relays.add(relay));\n  return new NDKRelaySet(relays, ndk);\n}\nfunction calculateRelaySetsFromFilter(ndk, filters, pool) {\n  const result = /* @__PURE__ */ new Map();\n  const authors = /* @__PURE__ */ new Set();\n  filters.forEach((filter) => {\n    if (filter.authors) {\n      filter.authors.forEach((author) => authors.add(author));\n    }\n  });\n  if (authors.size > 0) {\n    const authorToRelaysMap = getRelaysForFilterWithAuthors(ndk, Array.from(authors));\n    for (const relayUrl of authorToRelaysMap.keys()) {\n      result.set(relayUrl, []);\n    }\n    for (const filter of filters) {\n      if (filter.authors) {\n        for (const [relayUrl, authors2] of authorToRelaysMap.entries()) {\n          const authorFilterAndRelayPubkeyIntersection = filter.authors.filter(\n            (author) => authors2.includes(author)\n          );\n          result.set(relayUrl, [\n            ...result.get(relayUrl),\n            {\n              ...filter,\n              // Overwrite authors sent to this relay with the authors that were\n              // present in the filter and are also present in the relay\n              authors: authorFilterAndRelayPubkeyIntersection\n            }\n          ]);\n        }\n      } else {\n        for (const relayUrl of authorToRelaysMap.keys()) {\n          result.set(relayUrl, [...result.get(relayUrl), filter]);\n        }\n      }\n    }\n  } else {\n    if (ndk.explicitRelayUrls) {\n      ndk.explicitRelayUrls.forEach((relayUrl) => {\n        result.set(relayUrl, filters);\n      });\n    }\n  }\n  if (result.size === 0) {\n    pool.permanentAndConnectedRelays().slice(0, 5).forEach((relay) => {\n      result.set(relay.url, filters);\n    });\n  }\n  return result;\n}\nfunction calculateRelaySetsFromFilters(ndk, filters, pool) {\n  const a = calculateRelaySetsFromFilter(ndk, filters, pool);\n  return a;\n}\n\n// src/events/content-tagger.ts\n\nfunction mergeTags(tags1, tags2) {\n  const tagMap = /* @__PURE__ */ new Map();\n  const generateKey = (tag) => tag.join(\",\");\n  const isContained = (smaller, larger) => {\n    return smaller.every((value, index) => value === larger[index]);\n  };\n  const processTag = (tag) => {\n    for (const [key, existingTag] of tagMap) {\n      if (isContained(existingTag, tag) || isContained(tag, existingTag)) {\n        if (tag.length >= existingTag.length) {\n          tagMap.set(key, tag);\n        }\n        return;\n      }\n    }\n    tagMap.set(generateKey(tag), tag);\n  };\n  tags1.concat(tags2).forEach(processTag);\n  return Array.from(tagMap.values());\n}\nfunction uniqueTag(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  const sameLength = aLength === bLength;\n  if (sameLength) {\n    if (a.every((v, i) => v === b[i])) {\n      return [a];\n    }\n    return [a, b];\n  }\n  if (aLength > bLength && a.every((v, i) => v === b[i])) {\n    return [a];\n  }\n  if (bLength > aLength && b.every((v, i) => v === a[i])) {\n    return [b];\n  }\n  return [a, b];\n}\nvar hashtagRegex = /(?<=\\s|^)(#[^\\s!@#$%^&*()=+./,[{\\]};:'\"?><]+)/g;\nfunction generateHashtags(content) {\n  const hashtags = content.match(hashtagRegex);\n  const tagIds = /* @__PURE__ */ new Set();\n  const tag = /* @__PURE__ */ new Set();\n  if (hashtags) {\n    for (const hashtag of hashtags) {\n      if (tagIds.has(hashtag.slice(1))) continue;\n      tag.add(hashtag.slice(1));\n      tagIds.add(hashtag.slice(1));\n    }\n  }\n  return Array.from(tag);\n}\nasync function generateContentTags(content, tags = []) {\n  const tagRegex = /(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g;\n  const promises = [];\n  const addTagIfNew = (t) => {\n    if (!tags.find((t2) => [\"q\", t[0]].includes(t2[0]) && t2[1] === t[1])) {\n      tags.push(t);\n    }\n  };\n  content = content.replace(tagRegex, (tag) => {\n    try {\n      const entity = tag.split(/(@|nostr:)/)[2];\n      const { type, data } = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(entity);\n      let t;\n      switch (type) {\n        case \"npub\":\n          t = [\"p\", data];\n          break;\n        case \"nprofile\":\n          t = [\"p\", data.pubkey];\n          break;\n        case \"note\":\n          promises.push(\n            new Promise(async (resolve) => {\n              addTagIfNew([\"q\", data, await maybeGetEventRelayUrl(entity)]);\n              resolve();\n            })\n          );\n          break;\n        case \"nevent\":\n          promises.push(\n            new Promise(async (resolve) => {\n              const { id, author } = data;\n              let { relays } = data;\n              if (!relays || relays.length === 0) {\n                relays = [await maybeGetEventRelayUrl(entity)];\n              }\n              addTagIfNew([\"q\", id, relays[0]]);\n              if (author) addTagIfNew([\"p\", author]);\n              resolve();\n            })\n          );\n          break;\n        case \"naddr\":\n          promises.push(\n            new Promise(async (resolve) => {\n              const id = [data.kind, data.pubkey, data.identifier].join(\":\");\n              let relays = data.relays ?? [];\n              if (relays.length === 0) {\n                relays = [await maybeGetEventRelayUrl(entity)];\n              }\n              addTagIfNew([\"q\", id, relays[0]]);\n              addTagIfNew([\"p\", data.pubkey]);\n              resolve();\n            })\n          );\n          break;\n        default:\n          return tag;\n      }\n      if (t) addTagIfNew(t);\n      return `nostr:${entity}`;\n    } catch (_error) {\n      return tag;\n    }\n  });\n  await Promise.all(promises);\n  const newTags = generateHashtags(content).map((hashtag) => [\"t\", hashtag]);\n  tags = mergeTags(tags, newTags);\n  return { content, tags };\n}\nasync function maybeGetEventRelayUrl(_nip19Id) {\n  return \"\";\n}\n\n// src/events/encryption.ts\nasync function encrypt(recipient, signer, scheme = \"nip44\") {\n  let encrypted;\n  if (!this.ndk) throw new Error(\"No NDK instance found!\");\n  let currentSigner = signer;\n  if (!currentSigner) {\n    this.ndk.assertSigner();\n    currentSigner = this.ndk.signer;\n  }\n  if (!currentSigner) throw new Error(\"no NDK signer\");\n  const currentRecipient = recipient || (() => {\n    const pTags = this.getMatchingTags(\"p\");\n    if (pTags.length !== 1) {\n      throw new Error(\"No recipient could be determined and no explicit recipient was provided\");\n    }\n    return this.ndk.getUser({ pubkey: pTags[0][1] });\n  })();\n  if (scheme === \"nip44\" && await isEncryptionEnabled(currentSigner, \"nip44\")) {\n    encrypted = await currentSigner.encrypt(currentRecipient, this.content, \"nip44\");\n  }\n  if ((!encrypted || scheme === \"nip04\") && await isEncryptionEnabled(currentSigner, \"nip04\")) {\n    encrypted = await currentSigner.encrypt(currentRecipient, this.content, \"nip04\");\n  }\n  if (!encrypted) throw new Error(\"Failed to encrypt event.\");\n  this.content = encrypted;\n}\nasync function decrypt(sender, signer, scheme) {\n  if (this.ndk?.cacheAdapter?.getDecryptedEvent) {\n    let cachedEvent = null;\n    if (typeof this.ndk.cacheAdapter.getDecryptedEvent === \"function\") {\n      cachedEvent = this.ndk.cacheAdapter.getDecryptedEvent(this.id);\n    }\n    if (cachedEvent) {\n      this.content = cachedEvent.content;\n      return;\n    }\n  }\n  let decrypted;\n  if (!this.ndk) throw new Error(\"No NDK instance found!\");\n  let currentSigner = signer;\n  if (!currentSigner) {\n    this.ndk.assertSigner();\n    currentSigner = this.ndk.signer;\n  }\n  if (!currentSigner) throw new Error(\"no NDK signer\");\n  const currentSender = sender || this.author;\n  if (!currentSender) throw new Error(\"No sender provided and no author available\");\n  const currentScheme = scheme || (this.content.match(/\\\\?iv=/) ? \"nip04\" : \"nip44\");\n  if ((currentScheme === \"nip04\" || this.kind === 4) && await isEncryptionEnabled(currentSigner, \"nip04\") && this.content.search(\"\\\\?iv=\")) {\n    decrypted = await currentSigner.decrypt(currentSender, this.content, \"nip04\");\n  }\n  if (!decrypted && currentScheme === \"nip44\" && await isEncryptionEnabled(currentSigner, \"nip44\")) {\n    decrypted = await currentSigner.decrypt(currentSender, this.content, \"nip44\");\n  }\n  if (!decrypted) throw new Error(\"Failed to decrypt event.\");\n  this.content = decrypted;\n  if (this.ndk?.cacheAdapter?.addDecryptedEvent) {\n    this.ndk.cacheAdapter.addDecryptedEvent(this);\n  }\n}\nasync function isEncryptionEnabled(signer, scheme) {\n  if (!signer.encryptionEnabled) return false;\n  if (!scheme) return true;\n  return Boolean(await signer.encryptionEnabled(scheme));\n}\n\n// src/thread/index.ts\nfunction eventsBySameAuthor(op, events) {\n  const eventsByAuthor = /* @__PURE__ */ new Map();\n  eventsByAuthor.set(op.id, op);\n  events.forEach((event) => {\n    if (event.pubkey === op.pubkey) {\n      eventsByAuthor.set(event.id, event);\n    }\n  });\n  return eventsByAuthor;\n}\nvar hasMarkers = (event, tagType) => {\n  return event.getMatchingTags(tagType).some((tag) => tag[3] && tag[3] !== \"\");\n};\nfunction eventIsReply(op, event, threadIds = /* @__PURE__ */ new Set(), tagType) {\n  tagType ??= op.tagType();\n  const tags = event.getMatchingTags(tagType);\n  threadIds.add(op.tagId());\n  if (threadIds.has(event.tagId())) return false;\n  const heedExplicitReplyMarker = () => {\n    let eventIsTagged = false;\n    for (const tag of tags) {\n      if (tag[3] === \"reply\") return threadIds.has(tag[1]);\n      const markerIsEmpty = tag[3] === \"\" || tag[3] === void 0;\n      const markerIsRoot = tag[3] === \"root\";\n      if (tag[1] === op.tagId() && (markerIsEmpty || markerIsRoot)) {\n        eventIsTagged = markerIsRoot ? \"root\" : true;\n      }\n    }\n    if (!eventIsTagged) return false;\n    if (eventIsTagged === \"root\") return true;\n  };\n  const explicitReplyMarker = heedExplicitReplyMarker();\n  if (explicitReplyMarker !== void 0) return explicitReplyMarker;\n  if (hasMarkers(event, tagType)) return false;\n  const expectedTags = op.getMatchingTags(\"e\").map((tag) => tag[1]);\n  expectedTags.push(op.id);\n  return event.getMatchingTags(\"e\").every((tag) => expectedTags.includes(tag[1]));\n}\nfunction eventThreads(op, events) {\n  const eventsByAuthor = eventsBySameAuthor(op, events);\n  const threadEvents = events.filter((event) => eventIsPartOfThread(op, event, eventsByAuthor));\n  return threadEvents.sort((a, b) => a.created_at - b.created_at);\n}\nfunction getEventReplyId(event) {\n  const replyTag = getReplyTag(event);\n  if (replyTag) return replyTag[1];\n  const rootTag = getRootTag(event);\n  if (rootTag) return rootTag[1];\n}\nfunction isEventOriginalPost(event) {\n  return getEventReplyId(event) === void 0;\n}\nfunction eventThreadIds(op, events) {\n  const threadIds = /* @__PURE__ */ new Map();\n  const threadEvents = eventThreads(op, events);\n  threadEvents.forEach((event) => threadIds.set(event.id, event));\n  return threadIds;\n}\nfunction eventReplies(op, events, threadEventIds) {\n  threadEventIds ??= new Set(eventThreadIds(op, events).keys());\n  return events.filter((event) => eventIsReply(op, event, threadEventIds));\n}\nfunction eventIsPartOfThread(op, event, eventsByAuthor) {\n  if (op.pubkey !== event.pubkey) return false;\n  const taggedEventIds = event.getMatchingTags(\"e\").map((tag) => tag[1]);\n  const allTaggedEventsAreByOriginalAuthor = taggedEventIds.every((id) => eventsByAuthor.has(id));\n  return allTaggedEventsAreByOriginalAuthor;\n}\nfunction eventHasETagMarkers(event) {\n  for (const tag of event.tags) {\n    if (tag[0] === \"e\" && (tag[3] ?? \"\").length > 0) return true;\n  }\n  return false;\n}\nfunction getRootEventId(event, searchTag) {\n  searchTag ??= event.tagType();\n  const rootEventTag = getRootTag(event, searchTag);\n  if (rootEventTag) return rootEventTag[1];\n  const replyTag = getReplyTag(event, searchTag);\n  return replyTag?.[1];\n}\nfunction getRootTag(event, searchTag) {\n  searchTag ??= event.tagType();\n  const rootEventTag = event.tags.find(isTagRootTag);\n  if (!rootEventTag) {\n    if (eventHasETagMarkers(event)) return;\n    const matchingTags = event.getMatchingTags(searchTag);\n    if (matchingTags.length < 3) return matchingTags[0];\n  }\n  return rootEventTag;\n}\nvar nip22RootTags = /* @__PURE__ */ new Set([\"A\", \"E\", \"I\"]);\nvar nip22ReplyTags = /* @__PURE__ */ new Set([\"a\", \"e\", \"i\"]);\nfunction getReplyTag(event, searchTag) {\n  if (event.kind === 1111 /* GenericReply */) {\n    let replyTag2;\n    for (const tag of event.tags) {\n      if (nip22RootTags.has(tag[0])) replyTag2 = tag;\n      else if (nip22ReplyTags.has(tag[0])) {\n        replyTag2 = tag;\n        break;\n      }\n    }\n    return replyTag2;\n  }\n  searchTag ??= event.tagType();\n  let hasMarkers2 = false;\n  let replyTag;\n  for (const tag of event.tags) {\n    if (tag[0] !== searchTag) continue;\n    if ((tag[3] ?? \"\").length > 0) hasMarkers2 = true;\n    if (hasMarkers2 && tag[3] === \"reply\") return tag;\n    if (hasMarkers2 && tag[3] === \"root\") replyTag = tag;\n    if (!hasMarkers2) replyTag = tag;\n  }\n  return replyTag;\n}\nfunction isTagRootTag(tag) {\n  return tag[0] === \"E\" || tag[3] === \"root\";\n}\n\n// src/events/fetch-tagged-event.ts\nasync function fetchTaggedEvent(tag, marker) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const t = this.getMatchingTags(tag, marker);\n  if (t.length === 0) return void 0;\n  const [_, id, hint] = t[0];\n  let relay = hint !== \"\" ? this.ndk.pool.getRelay(hint) : void 0;\n  const event = await this.ndk.fetchEvent(id, {}, relay);\n  return event;\n}\nasync function fetchRootEvent(subOpts) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const rootTag = getRootTag(this);\n  if (!rootTag) return void 0;\n  return this.ndk.fetchEventFromTag(rootTag, this, subOpts);\n}\nasync function fetchReplyEvent(subOpts) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const replyTag = getReplyTag(this);\n  if (!replyTag) return void 0;\n  return this.ndk.fetchEventFromTag(replyTag, this, subOpts);\n}\n\n// src/events/kind.ts\nfunction isReplaceable() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return [0, 3].includes(this.kind) || this.kind >= 1e4 && this.kind < 2e4 || this.kind >= 3e4 && this.kind < 4e4;\n}\nfunction isEphemeral() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return this.kind >= 2e4 && this.kind < 3e4;\n}\nfunction isParamReplaceable() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return this.kind >= 3e4 && this.kind < 4e4;\n}\n\n// src/events/nip19.ts\n\nvar DEFAULT_RELAY_COUNT = 2;\nfunction encode(maxRelayCount = DEFAULT_RELAY_COUNT) {\n  let relays = [];\n  if (this.onRelays.length > 0) {\n    relays = this.onRelays.map((relay) => relay.url);\n  } else if (this.relay) {\n    relays = [this.relay.url];\n  }\n  if (relays.length > maxRelayCount) {\n    relays = relays.slice(0, maxRelayCount);\n  }\n  if (this.isParamReplaceable()) {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.naddrEncode({\n      kind: this.kind,\n      pubkey: this.pubkey,\n      identifier: this.replaceableDTag(),\n      relays\n    });\n  }\n  if (relays.length > 0) {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.neventEncode({\n      id: this.tagId(),\n      relays,\n      author: this.pubkey\n    });\n  }\n  return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.noteEncode(this.tagId());\n}\n\n// src/events/repost.ts\nasync function repost(publish = true, signer) {\n  if (!signer && publish) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    signer = this.ndk.signer;\n  }\n  const e = new NDKEvent(this.ndk, {\n    kind: getKind(this)\n  });\n  if (!this.isProtected) e.content = JSON.stringify(this.rawEvent());\n  e.tag(this);\n  if (this.kind !== 1 /* Text */) {\n    e.tags.push([\"k\", `${this.kind}`]);\n  }\n  if (signer) await e.sign(signer);\n  if (publish) await e.publish();\n  return e;\n}\nfunction getKind(event) {\n  if (event.kind === 1) {\n    return 6 /* Repost */;\n  }\n  return 16 /* GenericRepost */;\n}\n\n// src/events/serializer.ts\nfunction serialize(includeSig = false, includeId = false) {\n  const payload = [0, this.pubkey, this.created_at, this.kind, this.tags, this.content];\n  if (includeSig) payload.push(this.sig);\n  if (includeId) payload.push(this.id);\n  return JSON.stringify(payload);\n}\nfunction deserialize(serializedEvent) {\n  const eventArray = JSON.parse(serializedEvent);\n  const ret = {\n    pubkey: eventArray[1],\n    created_at: eventArray[2],\n    kind: eventArray[3],\n    tags: eventArray[4],\n    content: eventArray[5]\n  };\n  if (eventArray.length >= 7) {\n    const first = eventArray[6];\n    const second = eventArray[7];\n    if (first && first.length === 128) {\n      ret.sig = first;\n      if (second && second.length === 64) {\n        ret.id = second;\n      }\n    } else if (first && first.length === 64) {\n      ret.id = first;\n      if (second && second.length === 128) {\n        ret.sig = second;\n      }\n    }\n  }\n  return ret;\n}\n\n// src/events/validation.ts\n\n\n\n\n\n// src/events/signature.ts\nvar worker;\nvar processingQueue = {};\nfunction signatureVerificationInit(w) {\n  worker = w;\n  worker.onmessage = (msg) => {\n    const [eventId, result] = msg.data;\n    const record = processingQueue[eventId];\n    if (!record) {\n      console.error(\"No record found for event\", eventId);\n      return;\n    }\n    delete processingQueue[eventId];\n    for (const resolve of record.resolves) {\n      resolve(result);\n    }\n  };\n}\nasync function verifySignatureAsync(event, _persist) {\n  const promise = new Promise((resolve) => {\n    const serialized = event.serialize();\n    let enqueue = false;\n    if (!processingQueue[event.id]) {\n      processingQueue[event.id] = { event, resolves: [] };\n      enqueue = true;\n    }\n    processingQueue[event.id].resolves.push(resolve);\n    if (!enqueue) return;\n    worker?.postMessage({\n      serialized,\n      id: event.id,\n      sig: event.sig,\n      pubkey: event.pubkey\n    });\n  });\n  return promise;\n}\n\n// src/events/validation.ts\nvar PUBKEY_REGEX = /^[a-f0-9]{64}$/;\nfunction validate() {\n  if (typeof this.kind !== \"number\") return false;\n  if (typeof this.content !== \"string\") return false;\n  if (typeof this.created_at !== \"number\") return false;\n  if (typeof this.pubkey !== \"string\") return false;\n  if (!this.pubkey.match(PUBKEY_REGEX)) return false;\n  if (!Array.isArray(this.tags)) return false;\n  for (let i = 0; i < this.tags.length; i++) {\n    const tag = this.tags[i];\n    if (!Array.isArray(tag)) return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\") return false;\n    }\n  }\n  return true;\n}\nvar verifiedSignatures = new typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({\n  maxSize: 1e3,\n  entryExpirationTimeInMS: 6e4\n});\nfunction verifySignature(persist) {\n  if (typeof this.signatureVerified === \"boolean\") return this.signatureVerified;\n  const prevVerification = verifiedSignatures.get(this.id);\n  if (prevVerification !== null) {\n    this.signatureVerified = !!prevVerification;\n    return this.signatureVerified;\n  }\n  try {\n    if (this.ndk?.asyncSigVerification) {\n      verifySignatureAsync(this, persist).then((result) => {\n        if (persist) {\n          this.signatureVerified = result;\n          if (result) verifiedSignatures.set(this.id, this.sig);\n        }\n        if (!result) {\n          this.ndk?.emit(\"event:invalid-sig\", this);\n          verifiedSignatures.set(this.id, false);\n        }\n      });\n    } else {\n      const hash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(new TextEncoder().encode(this.serialize()));\n      const res = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__.schnorr.verify(this.sig, hash, this.pubkey);\n      if (res) verifiedSignatures.set(this.id, this.sig);\n      else verifiedSignatures.set(this.id, false);\n      this.signatureVerified = res;\n      return res;\n    }\n  } catch (_err) {\n    this.signatureVerified = false;\n    return false;\n  }\n}\nfunction getEventHash() {\n  return getEventHashFromSerializedEvent(this.serialize());\n}\nfunction getEventHashFromSerializedEvent(serializedEvent) {\n  const eventHash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(new TextEncoder().encode(serializedEvent));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(eventHash);\n}\n\n// src/events/index.ts\nvar skipClientTagOnKinds = /* @__PURE__ */ new Set([\n  0 /* Metadata */,\n  4 /* EncryptedDirectMessage */,\n  1059 /* GiftWrap */,\n  13 /* GiftWrapSeal */,\n  3 /* Contacts */,\n  9734 /* ZapRequest */,\n  5 /* EventDeletion */\n]);\nvar NDKEvent = class _NDKEvent extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  created_at;\n  content = \"\";\n  tags = [];\n  kind;\n  id = \"\";\n  sig;\n  pubkey = \"\";\n  signatureVerified;\n  _author = void 0;\n  /**\n   * The relay that this event was first received from.\n   */\n  relay;\n  /**\n   * The relays that this event was received from and/or successfully published to.\n   */\n  get onRelays() {\n    let res = [];\n    if (!this.ndk) {\n      if (this.relay) res.push(this.relay);\n    } else {\n      res = this.ndk.subManager.seenEvents.get(this.id) || [];\n    }\n    return res;\n  }\n  /**\n   * The status of the publish operation.\n   */\n  publishStatus = \"success\";\n  publishError;\n  constructor(ndk, event) {\n    super();\n    this.ndk = ndk;\n    this.created_at = event?.created_at;\n    this.content = event?.content || \"\";\n    this.tags = event?.tags || [];\n    this.id = event?.id || \"\";\n    this.sig = event?.sig;\n    this.pubkey = event?.pubkey || \"\";\n    this.kind = event?.kind;\n    if (event instanceof _NDKEvent) {\n      if (this.relay) {\n        this.relay = event.relay;\n        this.ndk?.subManager.seenEvent(event.id, this.relay);\n      }\n      this.publishStatus = event.publishStatus;\n      this.publishError = event.publishError;\n    }\n  }\n  /**\n   * Deserialize an NDKEvent from a serialized payload.\n   * @param ndk\n   * @param event\n   * @returns\n   */\n  static deserialize(ndk, event) {\n    return new _NDKEvent(ndk, deserialize(event));\n  }\n  /**\n   * Returns the event as is.\n   */\n  rawEvent() {\n    return {\n      created_at: this.created_at,\n      content: this.content,\n      tags: this.tags,\n      kind: this.kind,\n      pubkey: this.pubkey,\n      id: this.id,\n      sig: this.sig\n    };\n  }\n  set author(user) {\n    this.pubkey = user.pubkey;\n    this._author = user;\n    this._author.ndk ??= this.ndk;\n  }\n  /**\n   * Returns an NDKUser for the author of the event.\n   */\n  get author() {\n    if (this._author) return this._author;\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const user = this.ndk.getUser({ pubkey: this.pubkey });\n    this._author = user;\n    return user;\n  }\n  /**\n   * NIP-73 tagging of external entities\n   * @param entity to be tagged\n   * @param type of the entity\n   * @param markerUrl to be used as the marker URL\n   *\n   * @example\n   * ```typescript\n   * event.tagExternal(\"https://example.com/article/123#nostr\", \"url\");\n   * event.tags => [[\"i\", \"https://example.com/123\"], [\"k\", \"https://example.com\"]]\n   * ```\n   *\n   * @example tag a podcast:item:guid\n   * ```typescript\n   * event.tagExternal(\"e32b4890-b9ea-4aef-a0bf-54b787833dc5\", \"podcast:item:guid\");\n   * event.tags => [[\"i\", \"podcast:item:guid:e32b4890-b9ea-4aef-a0bf-54b787833dc5\"], [\"k\", \"podcast:item:guid\"]]\n   * ```\n   *\n   * @see https://github.com/nostr-protocol/nips/blob/master/73.md\n   */\n  tagExternal(entity, type, markerUrl) {\n    const iTag = [\"i\"];\n    const kTag = [\"k\"];\n    switch (type) {\n      case \"url\": {\n        const url = new URL(entity);\n        url.hash = \"\";\n        iTag.push(url.toString());\n        kTag.push(`${url.protocol}//${url.host}`);\n        break;\n      }\n      case \"hashtag\":\n        iTag.push(`#${entity.toLowerCase()}`);\n        kTag.push(\"#\");\n        break;\n      case \"geohash\":\n        iTag.push(`geo:${entity.toLowerCase()}`);\n        kTag.push(\"geo\");\n        break;\n      case \"isbn\":\n        iTag.push(`isbn:${entity.replace(/-/g, \"\")}`);\n        kTag.push(\"isbn\");\n        break;\n      case \"podcast:guid\":\n        iTag.push(`podcast:guid:${entity}`);\n        kTag.push(\"podcast:guid\");\n        break;\n      case \"podcast:item:guid\":\n        iTag.push(`podcast:item:guid:${entity}`);\n        kTag.push(\"podcast:item:guid\");\n        break;\n      case \"podcast:publisher:guid\":\n        iTag.push(`podcast:publisher:guid:${entity}`);\n        kTag.push(\"podcast:publisher:guid\");\n        break;\n      case \"isan\":\n        iTag.push(`isan:${entity.split(\"-\").slice(0, 4).join(\"-\")}`);\n        kTag.push(\"isan\");\n        break;\n      case \"doi\":\n        iTag.push(`doi:${entity.toLowerCase()}`);\n        kTag.push(\"doi\");\n        break;\n      default:\n        throw new Error(`Unsupported NIP-73 entity type: ${type}`);\n    }\n    if (markerUrl) {\n      iTag.push(markerUrl);\n    }\n    this.tags.push(iTag);\n    this.tags.push(kTag);\n  }\n  /**\n   * Tag a user with an optional marker.\n   * @param target What is to be tagged. Can be an NDKUser, NDKEvent, or an NDKTag.\n   * @param marker The marker to use in the tag.\n   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event.\n   * @param forceTag Force a specific tag to be used instead of the default \"e\" or \"a\" tag.\n   * @example\n   * ```typescript\n   * reply.tag(opEvent, \"reply\");\n   * // reply.tags => [[\"e\", <id>, <relay>, \"reply\"]]\n   * ```\n   */\n  tag(target, marker, skipAuthorTag, forceTag) {\n    let tags = [];\n    const isNDKUser = target.fetchProfile !== void 0;\n    if (isNDKUser) {\n      forceTag ??= \"p\";\n      const tag = [forceTag, target.pubkey];\n      if (marker) tag.push(...[\"\", marker]);\n      tags.push(tag);\n    } else if (target instanceof _NDKEvent) {\n      const event = target;\n      skipAuthorTag ??= event?.pubkey === this.pubkey;\n      tags = event.referenceTags(marker, skipAuthorTag, forceTag);\n      for (const pTag of event.getMatchingTags(\"p\")) {\n        if (pTag[1] === this.pubkey) continue;\n        if (this.tags.find((t) => t[0] === \"p\" && t[1] === pTag[1])) continue;\n        this.tags.push([\"p\", pTag[1]]);\n      }\n    } else if (Array.isArray(target)) {\n      tags = [target];\n    } else {\n      throw new Error(\"Invalid argument\", target);\n    }\n    this.tags = mergeTags(this.tags, tags);\n  }\n  /**\n   * Return a NostrEvent object, trying to fill in missing fields\n   * when possible, adding tags when necessary.\n   * @param pubkey {string} The pubkey of the user who the event belongs to.\n   * @returns {Promise<NostrEvent>} A promise that resolves to a NostrEvent.\n   */\n  async toNostrEvent(pubkey) {\n    if (!pubkey && this.pubkey === \"\") {\n      const user = await this.ndk?.signer?.user();\n      this.pubkey = user?.pubkey || \"\";\n    }\n    if (!this.created_at) {\n      this.created_at = Math.floor(Date.now() / 1e3);\n    }\n    const { content, tags } = await this.generateTags();\n    this.content = content || \"\";\n    this.tags = tags;\n    try {\n      this.id = this.getEventHash();\n    } catch (_e) {\n    }\n    return this.rawEvent();\n  }\n  serialize = serialize.bind(this);\n  getEventHash = getEventHash.bind(this);\n  validate = validate.bind(this);\n  verifySignature = verifySignature.bind(this);\n  /**\n   * Is this event replaceable (whether parameterized or not)?\n   *\n   * This will return true for kind 0, 3, 10k-20k and 30k-40k\n   */\n  isReplaceable = isReplaceable.bind(this);\n  isEphemeral = isEphemeral.bind(this);\n  isDvm = () => this.kind && this.kind >= 5e3 && this.kind <= 7e3;\n  /**\n   * Is this event parameterized replaceable?\n   *\n   * This will return true for kind 30k-40k\n   */\n  isParamReplaceable = isParamReplaceable.bind(this);\n  /**\n   * Encodes a bech32 id.\n   *\n   * @param relays {string[]} The relays to encode in the id\n   * @returns {string} - Encoded naddr, note or nevent.\n   */\n  encode = encode.bind(this);\n  encrypt = encrypt.bind(this);\n  decrypt = decrypt.bind(this);\n  /**\n   * Get all tags with the given name\n   * @param tagName {string} The name of the tag to search for\n   * @returns {NDKTag[]} An array of the matching tags\n   */\n  getMatchingTags(tagName, marker) {\n    const t = this.tags.filter((tag) => tag[0] === tagName);\n    if (marker === void 0) return t;\n    return t.filter((tag) => tag[3] === marker);\n  }\n  /**\n   * Check if the event has a tag with the given name\n   * @param tagName\n   * @param marker\n   * @returns\n   */\n  hasTag(tagName, marker) {\n    return this.tags.some((tag) => tag[0] === tagName && (!marker || tag[3] === marker));\n  }\n  /**\n   * Get the first tag with the given name\n   * @param tagName Tag name to search for\n   * @returns The value of the first tag with the given name, or undefined if no such tag exists\n   */\n  tagValue(tagName, marker) {\n    const tags = this.getMatchingTags(tagName, marker);\n    if (tags.length === 0) return void 0;\n    return tags[0][1];\n  }\n  /**\n   * Gets the NIP-31 \"alt\" tag of the event.\n   */\n  get alt() {\n    return this.tagValue(\"alt\");\n  }\n  /**\n   * Sets the NIP-31 \"alt\" tag of the event. Use this to set an alt tag so\n   * clients that don't handle a particular event kind can display something\n   * useful for users.\n   */\n  set alt(alt) {\n    this.removeTag(\"alt\");\n    if (alt) this.tags.push([\"alt\", alt]);\n  }\n  /**\n   * Gets the NIP-33 \"d\" tag of the event.\n   */\n  get dTag() {\n    return this.tagValue(\"d\");\n  }\n  /**\n   * Sets the NIP-33 \"d\" tag of the event.\n   */\n  set dTag(value) {\n    this.removeTag(\"d\");\n    if (value) this.tags.push([\"d\", value]);\n  }\n  /**\n   * Remove all tags with the given name (e.g. \"d\", \"a\", \"p\")\n   * @param tagName Tag name(s) to search for and remove\n   * @param marker Optional marker to check for too\n   *\n   * @example\n   * Remove a tags with a \"defer\" marker\n   * ```typescript\n   * event.tags = [\n   *   [\"a\", \"....\", \"defer\"],\n   *   [\"a\", \"....\", \"no-defer\"],\n   * ]\n   *\n   * event.removeTag(\"a\", \"defer\");\n   *\n   * // event.tags => [[\"a\", \"....\", \"no-defer\"]]\n   *\n   * @returns {void}\n   */\n  removeTag(tagName, marker) {\n    const tagNames = Array.isArray(tagName) ? tagName : [tagName];\n    this.tags = this.tags.filter((tag) => {\n      const include = tagNames.includes(tag[0]);\n      const hasMarker = marker ? tag[3] === marker : true;\n      return !(include && hasMarker);\n    });\n  }\n  /**\n   * Replace a tag with a new value. If not found, it will be added.\n   * @param tag The tag to replace.\n   * @param value The new value for the tag.\n   */\n  replaceTag(tag) {\n    this.removeTag(tag[0]);\n    this.tags.push(tag);\n  }\n  /**\n   * Sign the event if a signer is present.\n   *\n   * It will generate tags.\n   * Repleacable events will have their created_at field set to the current time.\n   * @param signer {NDKSigner} The NDKSigner to use to sign the event\n   * @returns {Promise<string>} A Promise that resolves to the signature of the signed event.\n   */\n  async sign(signer) {\n    if (!signer) {\n      this.ndk?.assertSigner();\n      signer = this.ndk?.signer;\n    } else {\n      this.author = await signer.user();\n    }\n    const nostrEvent = await this.toNostrEvent();\n    this.sig = await signer.sign(nostrEvent);\n    return this.sig;\n  }\n  /**\n   *\n   * @param relaySet\n   * @param timeoutMs\n   * @param requiredRelayCount\n   * @returns\n   */\n  async publishReplaceable(relaySet, timeoutMs, requiredRelayCount) {\n    this.id = \"\";\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.sig = \"\";\n    return this.publish(relaySet, timeoutMs, requiredRelayCount);\n  }\n  /**\n   * Attempt to sign and then publish an NDKEvent to a given relaySet.\n   * If no relaySet is provided, the relaySet will be calculated by NDK.\n   * @param relaySet {NDKRelaySet} The relaySet to publish the even to.\n   * @param timeoutM {number} The timeout for the publish operation in milliseconds.\n   * @param requiredRelayCount The number of relays that must receive the event for the publish to be considered successful.\n   * @returns A promise that resolves to the relays the event was published to.\n   */\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    if (!this.sig) await this.sign();\n    if (!this.ndk) throw new Error(\"NDKEvent must be associated with an NDK instance to publish\");\n    if (!relaySet || relaySet.size === 0) {\n      relaySet = this.ndk.devWriteRelaySet || await calculateRelaySetFromEvent(this.ndk, this);\n    }\n    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {\n      const eTags = this.getMatchingTags(\"e\").map((tag) => tag[1]);\n      this.ndk.cacheAdapter.deleteEventIds(eTags);\n    }\n    const rawEvent = this.rawEvent();\n    if (this.ndk.cacheAdapter?.addUnpublishedEvent && shouldTrackUnpublishedEvent(this)) {\n      try {\n        this.ndk.cacheAdapter.addUnpublishedEvent(this, relaySet.relayUrls);\n      } catch (e) {\n        console.error(\"Error adding unpublished event to cache\", e);\n      }\n    }\n    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {\n      this.ndk.cacheAdapter.deleteEventIds(this.getMatchingTags(\"e\").map((tag) => tag[1]));\n    }\n    this.ndk.subManager.dispatchEvent(rawEvent, void 0, true);\n    const relays = await relaySet.publish(this, timeoutMs, requiredRelayCount);\n    relays.forEach((relay) => this.ndk?.subManager.seenEvent(this.id, relay));\n    return relays;\n  }\n  /**\n   * Generates tags for users, notes, and other events tagged in content.\n   * Will also generate random \"d\" tag for parameterized replaceable events where needed.\n   * @returns {ContentTag} The tags and content of the event.\n   */\n  async generateTags() {\n    let tags = [];\n    const g = await generateContentTags(this.content, this.tags);\n    const content = g.content;\n    tags = g.tags;\n    if (this.kind && this.isParamReplaceable()) {\n      const dTag = this.getMatchingTags(\"d\")[0];\n      if (!dTag) {\n        const title = this.tagValue(\"title\");\n        const randLength = title ? 6 : 16;\n        let str = [...Array(randLength)].map(() => Math.random().toString(36)[2]).join(\"\");\n        if (title && title.length > 0) {\n          str = `${title.replace(/[^a-z0-9]+/gi, \"-\").replace(/^-|-$/g, \"\")}-${str}`;\n        }\n        tags.push([\"d\", str]);\n      }\n    }\n    if (this.shouldAddClientTag) {\n      const clientTag = [\"client\", this.ndk?.clientName ?? \"\"];\n      if (this.ndk?.clientNip89) clientTag.push(this.ndk?.clientNip89);\n      tags.push(clientTag);\n    } else if (this.shouldStripClientTag) {\n      tags = tags.filter((tag) => tag[0] !== \"client\");\n    }\n    return { content: content || \"\", tags };\n  }\n  get shouldAddClientTag() {\n    if (!this.ndk?.clientName && !this.ndk?.clientNip89) return false;\n    if (skipClientTagOnKinds.has(this.kind)) return false;\n    if (this.isEphemeral()) return false;\n    if (this.isReplaceable() && !this.isParamReplaceable()) return false;\n    if (this.isDvm()) return false;\n    if (this.hasTag(\"client\")) return false;\n    return true;\n  }\n  get shouldStripClientTag() {\n    return skipClientTagOnKinds.has(this.kind);\n  }\n  muted() {\n    const authorMutedEntry = this.ndk?.mutedIds.get(this.pubkey);\n    if (authorMutedEntry && authorMutedEntry === \"p\") return \"author\";\n    const eventTagReference = this.tagReference();\n    const eventMutedEntry = this.ndk?.mutedIds.get(eventTagReference[1]);\n    if (eventMutedEntry && eventMutedEntry === eventTagReference[0]) return \"event\";\n    return null;\n  }\n  /**\n   * Returns the \"d\" tag of a parameterized replaceable event or throws an error if the event isn't\n   * a parameterized replaceable event.\n   * @returns {string} the \"d\" tag of the event.\n   *\n   * @deprecated Use `dTag` instead.\n   */\n  replaceableDTag() {\n    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {\n      const dTag = this.getMatchingTags(\"d\")[0];\n      const dTagId = dTag ? dTag[1] : \"\";\n      return dTagId;\n    }\n    throw new Error(\"Event is not a parameterized replaceable event\");\n  }\n  /**\n   * Provides a deduplication key for the event.\n   *\n   * For kinds 0, 3, 10k-20k this will be the event <kind>:<pubkey>\n   * For kinds 30k-40k this will be the event <kind>:<pubkey>:<d-tag>\n   * For all other kinds this will be the event id\n   */\n  deduplicationKey() {\n    if (this.kind === 0 || this.kind === 3 || this.kind && this.kind >= 1e4 && this.kind < 2e4) {\n      return `${this.kind}:${this.pubkey}`;\n    }\n    return this.tagId();\n  }\n  /**\n   * Returns the id of the event or, if it's a parameterized event, the generated id of the event using \"d\" tag, pubkey, and kind.\n   * @returns {string} The id\n   */\n  tagId() {\n    if (this.isParamReplaceable()) {\n      return this.tagAddress();\n    }\n    return this.id;\n  }\n  /**\n   * Returns a stable reference value for a replaceable event.\n   *\n   * Param replaceable events are returned in the expected format of `<kind>:<pubkey>:<d-tag>`.\n   * Kind-replaceable events are returned in the format of `<kind>:<pubkey>:`.\n   *\n   * @returns {string} A stable reference value for replaceable events\n   */\n  tagAddress() {\n    if (this.isParamReplaceable()) {\n      const dTagId = this.dTag ?? \"\";\n      return `${this.kind}:${this.pubkey}:${dTagId}`;\n    }\n    if (this.isReplaceable()) {\n      return `${this.kind}:${this.pubkey}:`;\n    }\n    throw new Error(\"Event is not a replaceable event\");\n  }\n  /**\n   * Determines the type of tag that can be used to reference this event from another event.\n   * @returns {string} The tag type\n   * @example\n   * event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   * event.tagType(); // \"a\"\n   */\n  tagType() {\n    return this.isParamReplaceable() ? \"a\" : \"e\";\n  }\n  /**\n   * Get the tag that can be used to reference this event from another event.\n   *\n   * Consider using referenceTags() instead (unless you have a good reason to use this)\n   *\n   * @example\n   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *     event.tagReference(); // [\"a\", \"30000:pubkey:d-code\"]\n   *\n   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *     event.tagReference(); // [\"e\", \"eventid\"]\n   * @returns {NDKTag} The NDKTag object referencing this event\n   */\n  tagReference(marker) {\n    let tag;\n    if (this.isParamReplaceable()) {\n      tag = [\"a\", this.tagAddress()];\n    } else {\n      tag = [\"e\", this.tagId()];\n    }\n    if (this.relay) {\n      tag.push(this.relay.url);\n    } else {\n      tag.push(\"\");\n    }\n    tag.push(marker ?? \"\");\n    if (!this.isParamReplaceable()) {\n      tag.push(this.pubkey);\n    }\n    return tag;\n  }\n  /**\n   * Get the tags that can be used to reference this event from another event\n   * @param marker The marker to use in the tag\n   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event\n   * @param forceTag Force a specific tag to be used instead of the default \"e\" or \"a\" tag\n   * @example\n   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *     event.referenceTags(); // [[\"a\", \"30000:pubkey:d-code\"], [\"e\", \"parent-id\"]]\n   *\n   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *     event.referenceTags(); // [[\"e\", \"parent-id\"]]\n   * @returns {NDKTag} The NDKTag object referencing this event\n   */\n  referenceTags(marker, skipAuthorTag, forceTag) {\n    let tags = [];\n    if (this.isParamReplaceable()) {\n      tags = [\n        [forceTag ?? \"a\", this.tagAddress()],\n        [forceTag ?? \"e\", this.id]\n      ];\n    } else {\n      tags = [[forceTag ?? \"e\", this.id]];\n    }\n    tags = tags.map((tag) => {\n      if (tag[0] === \"e\" || marker) {\n        tag.push(this.relay?.url ?? \"\");\n      } else if (this.relay?.url) {\n        tag.push(this.relay?.url);\n      }\n      return tag;\n    });\n    tags.forEach((tag) => {\n      if (tag[0] === \"e\") {\n        tag.push(marker ?? \"\");\n        tag.push(this.pubkey);\n      } else if (marker) {\n        tag.push(marker);\n      }\n    });\n    tags = [...tags, ...this.getMatchingTags(\"h\")];\n    if (!skipAuthorTag) tags.push(...this.author.referenceTags());\n    return tags;\n  }\n  /**\n   * Provides the filter that will return matching events for this event.\n   *\n   * @example\n   *    event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *    event.filter(); // { \"#a\": [\"30000:pubkey:d-code\"] }\n   * @example\n   *    event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *    event.filter(); // { \"#e\": [\"eventid\"] }\n   *\n   * @returns The filter that will return matching events for this event\n   */\n  filter() {\n    if (this.isParamReplaceable()) {\n      return { \"#a\": [this.tagId()] };\n    }\n    return { \"#e\": [this.tagId()] };\n  }\n  nip22Filter() {\n    if (this.isParamReplaceable()) {\n      return { \"#A\": [this.tagId()] };\n    }\n    return { \"#E\": [this.tagId()] };\n  }\n  /**\n   * Generates a deletion event of the current event\n   *\n   * @param reason The reason for the deletion\n   * @param publish Whether to publish the deletion event automatically\n   * @returns The deletion event\n   */\n  async delete(reason, publish = true) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const e = new _NDKEvent(this.ndk, {\n      kind: 5 /* EventDeletion */,\n      content: reason || \"\"\n    });\n    e.tag(this, void 0, true);\n    e.tags.push([\"k\", this.kind?.toString()]);\n    if (publish) {\n      this.emit(\"deleted\");\n      await e.publish();\n    }\n    return e;\n  }\n  /**\n   * Establishes whether this is a NIP-70-protectede event.\n   * @@satisfies NIP-70\n   */\n  set isProtected(val) {\n    this.removeTag(\"-\");\n    if (val) this.tags.push([\"-\"]);\n  }\n  /**\n   * Whether this is a NIP-70-protected event.\n   * @@satisfies NIP-70\n   */\n  get isProtected() {\n    return this.hasTag(\"-\");\n  }\n  /**\n   * Fetch an event tagged with the given tag following relay hints if provided.\n   * @param tag The tag to search for\n   * @param marker The marker to use in the tag (e.g. \"root\")\n   * @returns The fetched event or null if no event was found, undefined if no matching tag was found in the event\n   * * @example\n   * const replyEvent = await ndk.fetchEvent(\"nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd\")\n   * const originalEvent = await replyEvent.fetchTaggedEvent(\"e\", \"reply\");\n   * console.log(replyEvent.encode() + \" is a reply to event \" + originalEvent?.encode());\n   */\n  fetchTaggedEvent = fetchTaggedEvent.bind(this);\n  /**\n   * Fetch the root event of the current event.\n   * @returns The fetched root event or null if no event was found\n   * @example\n   * const replyEvent = await ndk.fetchEvent(\"nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd\")\n   * const rootEvent = await replyEvent.fetchRootEvent();\n   * console.log(replyEvent.encode() + \" is a reply in the thread \" + rootEvent?.encode());\n   */\n  fetchRootEvent = fetchRootEvent.bind(this);\n  /**\n   * Fetch the event the current event is replying to.\n   * @returns The fetched reply event or null if no event was found\n   */\n  fetchReplyEvent = fetchReplyEvent.bind(this);\n  /**\n   * NIP-18 reposting event.\n   *\n   * @param publish Whether to publish the reposted event automatically @default true\n   * @param signer The signer to use for signing the reposted event\n   * @returns The reposted event\n   *\n   * @function\n   */\n  repost = repost.bind(this);\n  /**\n   * React to an existing event\n   *\n   * @param content The content of the reaction\n   */\n  async react(content, publish = true) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const e = new _NDKEvent(this.ndk, {\n      kind: 7 /* Reaction */,\n      content\n    });\n    e.tag(this);\n    if (publish) await e.publish();\n    return e;\n  }\n  /**\n   * Checks whether the event is valid per underlying NIPs.\n   *\n   * This method is meant to be overridden by subclasses that implement specific NIPs\n   * to allow the enforcement of NIP-specific validation rules.\n   *\n   * Otherwise, it will only check for basic event properties.\n   *\n   */\n  get isValid() {\n    return this.validate();\n  }\n  get inspect() {\n    return JSON.stringify(this.rawEvent(), null, 4);\n  }\n  /**\n   * Dump the event to console for debugging purposes.\n   * Prints a JSON stringified version of rawEvent() with indentation\n   * and also lists all relay URLs for onRelays.\n   */\n  dump() {\n    console.debug(JSON.stringify(this.rawEvent(), null, 4));\n    console.debug(\"Event on relays:\", this.onRelays.map((relay) => relay.url).join(\", \"));\n  }\n  /**\n   * Creates a reply event for the current event.\n   *\n   * This function will use NIP-22 when appropriate (i.e. replies to non-kind:1 events).\n   * This function does not have side-effects; it will just return an event with the appropriate tags\n   * to generate the reply event; the caller is responsible for publishing the event.\n   */\n  reply() {\n    const reply = new _NDKEvent(this.ndk);\n    if (this.kind === 1) {\n      reply.kind = 1;\n      const opHasETag = this.hasTag(\"e\");\n      if (opHasETag) {\n        reply.tags = [\n          ...reply.tags,\n          ...this.getMatchingTags(\"e\"),\n          ...this.getMatchingTags(\"p\"),\n          ...this.getMatchingTags(\"a\"),\n          ...this.referenceTags(\"reply\")\n        ];\n      } else {\n        reply.tag(this, \"root\");\n      }\n    } else {\n      reply.kind = 1111 /* GenericReply */;\n      const carryOverTags = [\"A\", \"E\", \"I\", \"P\"];\n      const rootTags = this.tags.filter((tag) => carryOverTags.includes(tag[0]));\n      if (rootTags.length > 0) {\n        const rootKind = this.tagValue(\"K\");\n        reply.tags.push(...rootTags);\n        if (rootKind) reply.tags.push([\"K\", rootKind]);\n        const [type, id, _, ...extra] = this.tagReference();\n        const tag = [type, id, ...extra];\n        reply.tags.push(tag);\n      } else {\n        const [type, id, _, relayHint] = this.tagReference();\n        const tag = [type, id, relayHint ?? \"\"];\n        if (type === \"e\") tag.push(this.pubkey);\n        reply.tags.push(tag);\n        const uppercaseTag = [...tag];\n        uppercaseTag[0] = uppercaseTag[0].toUpperCase();\n        reply.tags.push(uppercaseTag);\n        reply.tags.push([\"K\", this.kind?.toString()]);\n        reply.tags.push([\"P\", this.pubkey]);\n      }\n      reply.tags.push([\"k\", this.kind?.toString()]);\n      reply.tags.push(...this.getMatchingTags(\"p\"));\n      reply.tags.push([\"p\", this.pubkey]);\n    }\n    return reply;\n  }\n};\nvar untrackedUnpublishedEvents = /* @__PURE__ */ new Set([\n  24133 /* NostrConnect */,\n  13194 /* NostrWaletConnectInfo */,\n  23194 /* NostrWalletConnectReq */,\n  23195 /* NostrWalletConnectRes */\n]);\nfunction shouldTrackUnpublishedEvent(event) {\n  return !untrackedUnpublishedEvents.has(event.kind);\n}\n\n// src/relay/pool/index.ts\n\nvar NDKPool = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  // TODO: This should probably be an LRU cache\n  _relays = /* @__PURE__ */ new Map();\n  status = \"idle\";\n  autoConnectRelays = /* @__PURE__ */ new Set();\n  poolBlacklistRelayUrls = /* @__PURE__ */ new Set();\n  debug;\n  temporaryRelayTimers = /* @__PURE__ */ new Map();\n  flappingRelays = /* @__PURE__ */ new Set();\n  // A map to store timeouts for each flapping relay.\n  backoffTimes = /* @__PURE__ */ new Map();\n  ndk;\n  get blacklistRelayUrls() {\n    const val = new Set(this.ndk.blacklistRelayUrls);\n    this.poolBlacklistRelayUrls.forEach((url) => val.add(url));\n    return val;\n  }\n  /**\n   * @param relayUrls - The URLs of the relays to connect to.\n   * @param blacklistedRelayUrls - URLs to blacklist for this pool IN ADDITION to those blacklisted at the ndk-level\n   * @param ndk - The NDK instance.\n   * @param opts - Options for the pool.\n   */\n  constructor(relayUrls, blacklistedRelayUrls, ndk, {\n    debug: debug8,\n    name\n  } = {}) {\n    super();\n    this.debug = debug8 ?? ndk.debug.extend(\"pool\");\n    if (name) this._name = name;\n    this.ndk = ndk;\n    this.relayUrls = relayUrls;\n    this.poolBlacklistRelayUrls = new Set(blacklistedRelayUrls);\n    this.ndk.pools.push(this);\n  }\n  get relays() {\n    return this._relays;\n  }\n  set relayUrls(urls) {\n    this._relays.clear();\n    for (const relayUrl of urls) {\n      const relay = new NDKRelay(relayUrl, void 0, this.ndk);\n      relay.connectivity.netDebug = this.ndk.netDebug;\n      this.addRelay(relay);\n    }\n  }\n  _name = \"unnamed\";\n  get name() {\n    return this._name;\n  }\n  set name(name) {\n    this._name = name;\n    this.debug = this.debug.extend(name);\n  }\n  /**\n   * Adds a relay to the pool, and sets a timer to remove it if it is not used within the specified time.\n   * @param relay - The relay to add to the pool.\n   * @param removeIfUnusedAfter - The time in milliseconds to wait before removing the relay from the pool after it is no longer used.\n   */\n  useTemporaryRelay(relay, removeIfUnusedAfter = 3e4, filters) {\n    const relayAlreadyInPool = this.relays.has(relay.url);\n    if (!relayAlreadyInPool) {\n      this.addRelay(relay);\n      this.debug(\"Adding temporary relay %s for filters %o\", relay.url, filters);\n    }\n    const existingTimer = this.temporaryRelayTimers.get(relay.url);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n    }\n    if (!relayAlreadyInPool || existingTimer) {\n      const timer = setTimeout(() => {\n        if (this.ndk.explicitRelayUrls?.includes(relay.url)) return;\n        this.removeRelay(relay.url);\n      }, removeIfUnusedAfter);\n      this.temporaryRelayTimers.set(relay.url, timer);\n    }\n  }\n  /**\n   * Adds a relay to the pool.\n   *\n   * @param relay - The relay to add to the pool.\n   * @param connect - Whether or not to connect to the relay.\n   */\n  addRelay(relay, connect = true) {\n    const isAlreadyInPool = this.relays.has(relay.url);\n    const isBlacklisted = this.blacklistRelayUrls?.has(relay.url);\n    const isCustomRelayUrl = relay.url.includes(\"/npub1\");\n    let reconnect = true;\n    const relayUrl = relay.url;\n    if (isAlreadyInPool) return;\n    if (isBlacklisted) {\n      this.debug(`Refusing to add relay ${relayUrl}: blacklisted`);\n      return;\n    }\n    if (isCustomRelayUrl) {\n      this.debug(`Refusing to add relay ${relayUrl}: is a filter relay`);\n      return;\n    }\n    if (this.ndk.cacheAdapter?.getRelayStatus) {\n      const info = this.ndk.cacheAdapter.getRelayStatus(relayUrl);\n      if (info?.dontConnectBefore) {\n        if (info.dontConnectBefore > Date.now()) {\n          const delay = info.dontConnectBefore - Date.now();\n          this.debug(`Refusing to add relay ${relayUrl}: delayed connect for ${delay}ms`);\n          setTimeout(() => {\n            this.addRelay(relay, connect);\n          }, delay);\n          return;\n        }\n        reconnect = false;\n      }\n    }\n    const noticeHandler = (notice) => this.emit(\"notice\", relay, notice);\n    const connectHandler = () => this.handleRelayConnect(relayUrl);\n    const readyHandler = () => this.handleRelayReady(relay);\n    const disconnectHandler = () => this.emit(\"relay:disconnect\", relay);\n    const flappingHandler = () => this.handleFlapping(relay);\n    const authHandler = (challenge) => this.emit(\"relay:auth\", relay, challenge);\n    const authedHandler = () => this.emit(\"relay:authed\", relay);\n    relay.off(\"notice\", noticeHandler);\n    relay.off(\"connect\", connectHandler);\n    relay.off(\"ready\", readyHandler);\n    relay.off(\"disconnect\", disconnectHandler);\n    relay.off(\"flapping\", flappingHandler);\n    relay.off(\"auth\", authHandler);\n    relay.off(\"authed\", authedHandler);\n    relay.on(\"notice\", noticeHandler);\n    relay.on(\"connect\", connectHandler);\n    relay.on(\"ready\", readyHandler);\n    relay.on(\"disconnect\", disconnectHandler);\n    relay.on(\"flapping\", flappingHandler);\n    relay.on(\"auth\", authHandler);\n    relay.on(\"authed\", authedHandler);\n    relay.on(\"delayed-connect\", (delay) => {\n      if (this.ndk.cacheAdapter?.updateRelayStatus) {\n        this.ndk.cacheAdapter.updateRelayStatus(relay.url, {\n          dontConnectBefore: Date.now() + delay\n        });\n      }\n    });\n    this._relays.set(relayUrl, relay);\n    if (connect) this.autoConnectRelays.add(relayUrl);\n    if (connect && this.status === \"active\") {\n      this.emit(\"relay:connecting\", relay);\n      relay.connect(void 0, reconnect).catch((e) => {\n        this.debug(`Failed to connect to relay ${relayUrl}`, e);\n      });\n    }\n  }\n  /**\n   * Removes a relay from the pool.\n   * @param relayUrl - The URL of the relay to remove.\n   * @returns {boolean} True if the relay was removed, false if it was not found.\n   */\n  removeRelay(relayUrl) {\n    const relay = this.relays.get(relayUrl);\n    if (relay) {\n      relay.disconnect();\n      this.relays.delete(relayUrl);\n      this.autoConnectRelays.delete(relayUrl);\n      this.emit(\"relay:disconnect\", relay);\n      return true;\n    }\n    const existingTimer = this.temporaryRelayTimers.get(relayUrl);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n      this.temporaryRelayTimers.delete(relayUrl);\n    }\n    return false;\n  }\n  /**\n   * Checks whether a relay is already connected in the pool.\n   */\n  isRelayConnected(url) {\n    const normalizedUrl = normalizeRelayUrl(url);\n    const relay = this.relays.get(normalizedUrl);\n    if (!relay) return false;\n    return relay.status === 5 /* CONNECTED */;\n  }\n  /**\n   * Fetches a relay from the pool, or creates a new one if it does not exist.\n   *\n   * New relays will be attempted to be connected.\n   */\n  getRelay(url, connect = true, temporary = false, filters) {\n    let relay = this.relays.get(normalizeRelayUrl(url));\n    if (!relay) {\n      relay = new NDKRelay(url, void 0, this.ndk);\n      relay.connectivity.netDebug = this.ndk.netDebug;\n      if (temporary) {\n        this.useTemporaryRelay(relay, 3e4, filters);\n      } else {\n        this.addRelay(relay, connect);\n      }\n    }\n    return relay;\n  }\n  handleRelayConnect(relayUrl) {\n    const relay = this.relays.get(relayUrl);\n    if (!relay) {\n      console.error(\"NDK BUG: relay not found in pool\", { relayUrl });\n      return;\n    }\n    this.emit(\"relay:connect\", relay);\n    if (this.stats().connected === this.relays.size) {\n      this.emit(\"connect\");\n    }\n  }\n  handleRelayReady(relay) {\n    this.emit(\"relay:ready\", relay);\n  }\n  /**\n   * Attempts to establish a connection to each relay in the pool.\n   *\n   * @async\n   * @param {number} [timeoutMs] - Optional timeout in milliseconds for each connection attempt.\n   * @returns {Promise<void>} A promise that resolves when all connection attempts have completed.\n   * @throws {Error} If any of the connection attempts result in an error or timeout.\n   */\n  async connect(timeoutMs) {\n    const promises = [];\n    this.status = \"active\";\n    this.debug(`Connecting to ${this.relays.size} relays${timeoutMs ? `, timeout ${timeoutMs}...` : \"\"}`);\n    const relaysToConnect = new Set(this.autoConnectRelays.keys());\n    for (const relayUrl of relaysToConnect) {\n      const relay = this.relays.get(relayUrl);\n      if (!relay) {\n        continue;\n      }\n      const connectPromise = new Promise((resolve, reject) => {\n        this.emit(\"relay:connecting\", relay);\n        return relay.connect(timeoutMs).then(resolve).catch(reject);\n      });\n      if (timeoutMs) {\n        const timeoutPromise = new Promise((_, reject) => {\n          setTimeout(() => reject(`Timed out after ${timeoutMs}ms`), timeoutMs);\n        });\n        promises.push(\n          Promise.race([connectPromise, timeoutPromise]).catch((e) => {\n            this.debug(`Failed to connect to relay ${relay.url}: ${e ?? \"No reason specified\"}`);\n          })\n        );\n      } else {\n        promises.push(connectPromise);\n      }\n    }\n    const maybeEmitConnect = () => {\n      const allConnected = this.stats().connected === this.relays.size;\n      const someConnected = this.stats().connected > 0;\n      if (!allConnected && someConnected) {\n        this.emit(\"connect\");\n      }\n    };\n    if (timeoutMs) setTimeout(maybeEmitConnect, timeoutMs);\n    await Promise.all(promises);\n    maybeEmitConnect();\n  }\n  checkOnFlappingRelays() {\n    const flappingRelaysCount = this.flappingRelays.size;\n    const totalRelays = this.relays.size;\n    if (flappingRelaysCount / totalRelays >= 0.8) {\n      for (const relayUrl of this.flappingRelays) {\n        this.backoffTimes.set(relayUrl, 0);\n      }\n    }\n  }\n  handleFlapping(relay) {\n    this.debug(`Relay ${relay.url} is flapping`);\n    let currentBackoff = this.backoffTimes.get(relay.url) || 5e3;\n    currentBackoff = currentBackoff * 2;\n    this.backoffTimes.set(relay.url, currentBackoff);\n    this.debug(`Backoff time for ${relay.url} is ${currentBackoff}ms`);\n    setTimeout(() => {\n      this.debug(`Attempting to reconnect to ${relay.url}`);\n      this.emit(\"relay:connecting\", relay);\n      relay.connect();\n      this.checkOnFlappingRelays();\n    }, currentBackoff);\n    relay.disconnect();\n    this.emit(\"flapping\", relay);\n  }\n  size() {\n    return this.relays.size;\n  }\n  /**\n   * Returns the status of each relay in the pool.\n   * @returns {NDKPoolStats} An object containing the number of relays in each status.\n   */\n  stats() {\n    const stats = {\n      total: 0,\n      connected: 0,\n      disconnected: 0,\n      connecting: 0\n    };\n    for (const relay of this.relays.values()) {\n      stats.total++;\n      if (relay.status === 5 /* CONNECTED */) {\n        stats.connected++;\n      } else if (relay.status === 1 /* DISCONNECTED */) {\n        stats.disconnected++;\n      } else if (relay.status === 4 /* CONNECTING */) {\n        stats.connecting++;\n      }\n    }\n    return stats;\n  }\n  connectedRelays() {\n    return Array.from(this.relays.values()).filter((relay) => relay.status >= 5 /* CONNECTED */);\n  }\n  permanentAndConnectedRelays() {\n    return Array.from(this.relays.values()).filter(\n      (relay) => relay.status >= 5 /* CONNECTED */ && !this.temporaryRelayTimers.has(relay.url)\n    );\n  }\n  /**\n   * Get a list of all relay urls in the pool.\n   */\n  urls() {\n    return Array.from(this.relays.keys());\n  }\n};\n\n// src/user/index.ts\n\n\n// src/events/kinds/nutzap/mint-list.ts\nvar NDKCashuMintList = class _NDKCashuMintList extends NDKEvent {\n  static kind = 10019 /* CashuMintList */;\n  static kinds = [10019 /* CashuMintList */];\n  _p2pk;\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 10019 /* CashuMintList */;\n  }\n  static from(event) {\n    return new _NDKCashuMintList(event.ndk, event);\n  }\n  set relays(urls) {\n    this.tags = this.tags.filter((t) => t[0] !== \"relay\");\n    for (const url of urls) {\n      this.tags.push([\"relay\", url]);\n    }\n  }\n  get relays() {\n    const r = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"relay\") {\n        r.push(tag[1]);\n      }\n    }\n    return r;\n  }\n  set mints(urls) {\n    this.tags = this.tags.filter((t) => t[0] !== \"mint\");\n    for (const url of urls) {\n      this.tags.push([\"mint\", url]);\n    }\n  }\n  get mints() {\n    const r = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"mint\") {\n        r.push(tag[1]);\n      }\n    }\n    return Array.from(new Set(r));\n  }\n  get p2pk() {\n    if (this._p2pk) {\n      return this._p2pk;\n    }\n    this._p2pk = this.tagValue(\"pubkey\") ?? this.pubkey;\n    return this._p2pk;\n  }\n  set p2pk(pubkey) {\n    this._p2pk = pubkey;\n    this.removeTag(\"pubkey\");\n    if (pubkey) {\n      this.tags.push([\"pubkey\", pubkey]);\n    }\n  }\n  get relaySet() {\n    return NDKRelaySet.fromRelayUrls(this.relays, this.ndk);\n  }\n};\n\n// src/subscription/index.ts\n\n\n// src/events/kinds/article.ts\nvar NDKArticle = class _NDKArticle extends NDKEvent {\n  static kind = 30023 /* Article */;\n  static kinds = [30023 /* Article */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30023 /* Article */;\n  }\n  /**\n   * Creates a NDKArticle from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKArticle from.\n   * @returns NDKArticle\n   */\n  static from(event) {\n    return new _NDKArticle(event.ndk, event);\n  }\n  /**\n   * Getter for the article title.\n   *\n   * @returns {string | undefined} - The article title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the article title.\n   *\n   * @param {string | undefined} title - The title to set for the article.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the article image.\n   *\n   * @returns {string | undefined} - The article image if available, otherwise undefined.\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Setter for the article image.\n   *\n   * @param {string | undefined} image - The image to set for the article.\n   */\n  set image(image) {\n    this.removeTag(\"image\");\n    if (image) this.tags.push([\"image\", image]);\n  }\n  get summary() {\n    return this.tagValue(\"summary\");\n  }\n  set summary(summary) {\n    this.removeTag(\"summary\");\n    if (summary) this.tags.push([\"summary\", summary]);\n  }\n  /**\n   * Getter for the article's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      let val = Number.parseInt(tag);\n      if (val > 1e12) {\n        val = Math.floor(val / 1e3);\n      }\n      return val;\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the article's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the article's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Generates content tags for the article.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n  /**\n   * Getter for the article's URL.\n   *\n   * @returns {string | undefined} - The article's URL if available, otherwise undefined.\n   */\n  get url() {\n    return this.tagValue(\"url\");\n  }\n  /**\n   * Setter for the article's URL.\n   *\n   * @param {string | undefined} url - The URL to set for the article.\n   */\n  set url(url) {\n    if (url) {\n      this.tags.push([\"url\", url]);\n    } else {\n      this.removeTag(\"url\");\n    }\n  }\n};\n\n// src/events/kinds/cashu/token.ts\nfunction proofsTotalBalance(proofs) {\n  return proofs.reduce((acc, proof) => {\n    if (proof.amount < 0) {\n      throw new Error(\"proof amount is negative\");\n    }\n    return acc + proof.amount;\n  }, 0);\n}\nvar NDKCashuToken = class _NDKCashuToken extends NDKEvent {\n  _proofs = [];\n  _mint;\n  static kind = 7375 /* CashuToken */;\n  static kinds = [7375 /* CashuToken */];\n  /**\n   * Tokens that this token superseeds\n   */\n  _deletes = [];\n  original;\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7375 /* CashuToken */;\n  }\n  static async from(event) {\n    const token = new _NDKCashuToken(event.ndk, event);\n    token.original = event;\n    try {\n      await token.decrypt();\n    } catch {\n      token.content = token.original.content;\n    }\n    try {\n      const content = JSON.parse(token.content);\n      token.proofs = content.proofs;\n      token.mint = content.mint ?? token.tagValue(\"mint\");\n      token.deletedTokens = content.del ?? [];\n      if (!Array.isArray(token.proofs)) return;\n    } catch (_e) {\n      return;\n    }\n    return token;\n  }\n  get proofs() {\n    return this._proofs;\n  }\n  set proofs(proofs) {\n    const cs = /* @__PURE__ */ new Set();\n    this._proofs = proofs.filter((proof) => {\n      if (cs.has(proof.C)) {\n        console.warn(\"Passed in proofs had duplicates, ignoring\", proof.C);\n        return false;\n      }\n      if (proof.amount < 0) {\n        console.warn(\"Invalid proof with negative amount\", proof);\n        return false;\n      }\n      cs.add(proof.C);\n      return true;\n    }).map(this.cleanProof);\n  }\n  /**\n   * Returns a minimal proof object with only essential properties\n   */\n  cleanProof(proof) {\n    return {\n      id: proof.id,\n      amount: proof.amount,\n      C: proof.C,\n      secret: proof.secret\n    };\n  }\n  async toNostrEvent(pubkey) {\n    if (!this.ndk) throw new Error(\"no ndk\");\n    if (!this.ndk.signer) throw new Error(\"no signer\");\n    const payload = {\n      proofs: this.proofs.map(this.cleanProof),\n      mint: this.mint,\n      del: this.deletedTokens ?? []\n    };\n    this.content = JSON.stringify(payload);\n    const user = await this.ndk.signer.user();\n    await this.encrypt(user, void 0, \"nip44\");\n    return super.toNostrEvent(pubkey);\n  }\n  set mint(mint) {\n    this._mint = mint;\n  }\n  get mint() {\n    return this._mint;\n  }\n  /**\n   * Tokens that were deleted by the creation of this token.\n   */\n  get deletedTokens() {\n    return this._deletes;\n  }\n  /**\n   * Marks tokens that were deleted by the creation of this token.\n   */\n  set deletedTokens(tokenIds) {\n    this._deletes = tokenIds;\n  }\n  get amount() {\n    return proofsTotalBalance(this.proofs);\n  }\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    if (this.original) {\n      return this.original.publish(relaySet, timeoutMs, requiredRelayCount);\n    }\n    return super.publish(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/events/kinds/highlight.ts\n\nvar NDKHighlight = class _NDKHighlight extends NDKEvent {\n  _article;\n  static kind = 9802 /* Highlight */;\n  static kinds = [9802 /* Highlight */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 9802 /* Highlight */;\n  }\n  static from(event) {\n    return new _NDKHighlight(event.ndk, event);\n  }\n  get url() {\n    return this.tagValue(\"r\");\n  }\n  /**\n   * Context tag.\n   */\n  set context(context) {\n    if (context === void 0) {\n      this.tags = this.tags.filter(([tag, _value]) => tag !== \"context\");\n    } else {\n      this.tags = this.tags.filter(([tag, _value]) => tag !== \"context\");\n      this.tags.push([\"context\", context]);\n    }\n  }\n  get context() {\n    return this.tags.find(([tag, _value]) => tag === \"context\")?.[1] ?? void 0;\n  }\n  /**\n   * Will return the article URL or NDKEvent if they have already been\n   * set (it won't attempt to load remote events)\n   */\n  get article() {\n    return this._article;\n  }\n  /**\n   * Article the highlight is coming from.\n   *\n   * @param article Article URL or NDKEvent.\n   */\n  set article(article) {\n    this._article = article;\n    if (typeof article === \"string\") {\n      this.tags.push([\"r\", article]);\n    } else {\n      this.tag(article);\n    }\n  }\n  getArticleTag() {\n    return this.getMatchingTags(\"a\")[0] || this.getMatchingTags(\"e\")[0] || this.getMatchingTags(\"r\")[0];\n  }\n  async getArticle() {\n    if (this._article !== void 0) return this._article;\n    let taggedBech32;\n    const articleTag = this.getArticleTag();\n    if (!articleTag) return void 0;\n    switch (articleTag[0]) {\n      case \"a\": {\n        const [kind, pubkey, identifier] = articleTag[1].split(\":\");\n        taggedBech32 = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.naddrEncode({\n          kind: Number.parseInt(kind),\n          pubkey,\n          identifier\n        });\n        break;\n      }\n      case \"e\":\n        taggedBech32 = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.noteEncode(articleTag[1]);\n        break;\n      case \"r\":\n        this._article = articleTag[1];\n        break;\n    }\n    if (taggedBech32) {\n      let a = await this.ndk?.fetchEvent(taggedBech32);\n      if (a) {\n        if (a.kind === 30023 /* Article */) {\n          a = NDKArticle.from(a);\n        }\n        this._article = a;\n      }\n    }\n    return this._article;\n  }\n};\n\n// src/utils/imeta.ts\nfunction mapImetaTag(tag) {\n  const data = {};\n  if (tag.length === 2) {\n    const parts = tag[1].split(\" \");\n    for (let i = 0; i < parts.length; i += 2) {\n      const key = parts[i];\n      const value = parts[i + 1];\n      if (key === \"fallback\") {\n        if (!data.fallback) data.fallback = [];\n        data.fallback.push(value);\n      } else {\n        data[key] = value;\n      }\n    }\n    return data;\n  }\n  const tags = tag.slice(1);\n  for (const val of tags) {\n    const parts = val.split(\" \");\n    const key = parts[0];\n    const value = parts.slice(1).join(\" \");\n    if (key === \"fallback\") {\n      if (!data.fallback) data.fallback = [];\n      data.fallback.push(value);\n    } else {\n      data[key] = value;\n    }\n  }\n  return data;\n}\nfunction imetaTagToTag(imeta) {\n  const tag = [\"imeta\"];\n  for (const [key, value] of Object.entries(imeta)) {\n    if (Array.isArray(value)) {\n      for (const v of value) {\n        tag.push(`${key} ${v}`);\n      }\n    } else if (value) {\n      tag.push(`${key} ${value}`);\n    }\n  }\n  return tag;\n}\n\n// src/events/kinds/image.ts\nvar NDKImage = class _NDKImage extends NDKEvent {\n  static kind = 20 /* Image */;\n  static kinds = [20 /* Image */];\n  _imetas;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 20 /* Image */;\n  }\n  /**\n   * Creates a NDKImage from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKImage from.\n   * @returns NDKImage\n   */\n  static from(event) {\n    return new _NDKImage(event.ndk, event.rawEvent());\n  }\n  get isValid() {\n    return this.imetas.length > 0;\n  }\n  get imetas() {\n    if (this._imetas) return this._imetas;\n    this._imetas = this.tags.filter((tag) => tag[0] === \"imeta\").map(mapImetaTag).filter((imeta) => !!imeta.url);\n    return this._imetas;\n  }\n  set imetas(tags) {\n    this._imetas = tags;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"imeta\");\n    this.tags.push(...tags.map(imetaTagToTag));\n  }\n};\n\n// src/events/kinds/lists/index.ts\nvar NDKList = class _NDKList extends NDKEvent {\n  _encryptedTags;\n  static kinds = [\n    10063 /* BlossomList */,\n    30001 /* CategorizedBookmarkList */,\n    10004 /* CommunityList */,\n    10050 /* DirectMessageReceiveRelayList */,\n    10030 /* EmojiList */,\n    10015 /* InterestList */,\n    10001 /* PinList */,\n    10002 /* RelayList */,\n    10007 /* SearchRelayList */,\n    10006 /* BlockRelayList */,\n    10003 /* BookmarkList */\n  ];\n  /**\n   * Stores the number of bytes the content was before decryption\n   * to expire the cache when the content changes.\n   */\n  encryptedTagsLength;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30001 /* CategorizedBookmarkList */;\n  }\n  /**\n   * Wrap a NDKEvent into a NDKList\n   */\n  static from(ndkEvent) {\n    return new _NDKList(ndkEvent.ndk, ndkEvent);\n  }\n  /**\n   * Returns the title of the list. Falls back on fetching the name tag value.\n   */\n  get title() {\n    const titleTag = this.tagValue(\"title\") || this.tagValue(\"name\");\n    if (titleTag) return titleTag;\n    if (this.kind === 3 /* Contacts */) {\n      return \"Contacts\";\n    }\n    if (this.kind === 1e4 /* MuteList */) {\n      return \"Mute\";\n    }\n    if (this.kind === 10001 /* PinList */) {\n      return \"Pinned Notes\";\n    }\n    if (this.kind === 10002 /* RelayList */) {\n      return \"Relay Metadata\";\n    }\n    if (this.kind === 10003 /* BookmarkList */) {\n      return \"Bookmarks\";\n    }\n    if (this.kind === 10004 /* CommunityList */) {\n      return \"Communities\";\n    }\n    if (this.kind === 10005 /* PublicChatList */) {\n      return \"Public Chats\";\n    }\n    if (this.kind === 10006 /* BlockRelayList */) {\n      return \"Blocked Relays\";\n    }\n    if (this.kind === 10007 /* SearchRelayList */) {\n      return \"Search Relays\";\n    }\n    if (this.kind === 10050 /* DirectMessageReceiveRelayList */) {\n      return \"Direct Message Receive Relays\";\n    }\n    if (this.kind === 10015 /* InterestList */) {\n      return \"Interests\";\n    }\n    if (this.kind === 10030 /* EmojiList */) {\n      return \"Emojis\";\n    }\n    return this.tagValue(\"d\");\n  }\n  /**\n   * Sets the title of the list.\n   */\n  set title(title) {\n    this.removeTag([\"title\", \"name\"]);\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Returns the name of the list.\n   * @deprecated Please use \"title\" instead.\n   */\n  get name() {\n    return this.title;\n  }\n  /**\n   * Sets the name of the list.\n   * @deprecated Please use \"title\" instead. This method will use the `title` tag instead.\n   */\n  set name(name) {\n    this.title = name;\n  }\n  /**\n   * Returns the description of the list.\n   */\n  get description() {\n    return this.tagValue(\"description\");\n  }\n  /**\n   * Sets the description of the list.\n   */\n  set description(name) {\n    this.removeTag(\"description\");\n    if (name) this.tags.push([\"description\", name]);\n  }\n  /**\n   * Returns the image of the list.\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Sets the image of the list.\n   */\n  set image(name) {\n    this.removeTag(\"image\");\n    if (name) this.tags.push([\"image\", name]);\n  }\n  isEncryptedTagsCacheValid() {\n    return !!(this._encryptedTags && this.encryptedTagsLength === this.content.length);\n  }\n  /**\n   * Returns the decrypted content of the list.\n   */\n  async encryptedTags(useCache = true) {\n    if (useCache && this.isEncryptedTagsCacheValid()) return this._encryptedTags;\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    const user = await this.ndk.signer.user();\n    try {\n      if (this.content.length > 0) {\n        try {\n          const decryptedContent = await this.ndk.signer.decrypt(user, this.content);\n          const a = JSON.parse(decryptedContent);\n          if (a?.[0]) {\n            this.encryptedTagsLength = this.content.length;\n            return this._encryptedTags = a;\n          }\n          this.encryptedTagsLength = this.content.length;\n          return this._encryptedTags = [];\n        } catch (_e) {\n        }\n      }\n    } catch (_e) {\n    }\n    return [];\n  }\n  /**\n   * This method can be overriden to validate that a tag is valid for this list.\n   *\n   * (i.e. the NDKPersonList can validate that items are NDKUser instances)\n   */\n  validateTag(_tagValue) {\n    return true;\n  }\n  getItems(type) {\n    return this.tags.filter((tag) => tag[0] === type);\n  }\n  /**\n   * Returns the unecrypted items in this list.\n   */\n  get items() {\n    return this.tags.filter((t) => {\n      return ![\n        \"d\",\n        \"L\",\n        \"l\",\n        \"title\",\n        \"name\",\n        \"description\",\n        \"published_at\",\n        \"summary\",\n        \"image\",\n        \"thumb\",\n        \"alt\",\n        \"expiration\",\n        \"subject\",\n        \"client\"\n      ].includes(t[0]);\n    });\n  }\n  /**\n   * Adds a new item to the list.\n   * @param relay Relay to add\n   * @param mark Optional mark to add to the item\n   * @param encrypted Whether to encrypt the item\n   * @param position Where to add the item in the list (top or bottom)\n   */\n  async addItem(item, mark = void 0, encrypted = false, position = \"bottom\") {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    let tags;\n    if (item instanceof NDKEvent) {\n      tags = [item.tagReference(mark)];\n    } else if (item instanceof NDKUser) {\n      tags = item.referenceTags();\n    } else if (item instanceof NDKRelay) {\n      tags = item.referenceTags();\n    } else if (Array.isArray(item)) {\n      tags = [item];\n    } else {\n      throw new Error(\"Invalid object type\");\n    }\n    if (mark) tags[0].push(mark);\n    if (encrypted) {\n      const user = await this.ndk.signer.user();\n      const currentList = await this.encryptedTags();\n      if (position === \"top\") currentList.unshift(...tags);\n      else currentList.push(...tags);\n      this._encryptedTags = currentList;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(currentList);\n      await this.encrypt(user);\n    } else {\n      if (position === \"top\") this.tags.unshift(...tags);\n      else this.tags.push(...tags);\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n  }\n  /**\n   * Removes an item from the list from both the encrypted and unencrypted lists.\n   * @param value value of item to remove from the list\n   * @param publish whether to publish the change\n   * @returns\n   */\n  async removeItemByValue(value, publish = true) {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    const index = this.tags.findIndex((tag) => tag[1] === value);\n    if (index >= 0) {\n      this.tags.splice(index, 1);\n    }\n    const user = await this.ndk.signer.user();\n    const encryptedTags = await this.encryptedTags();\n    const encryptedIndex = encryptedTags.findIndex((tag) => tag[1] === value);\n    if (encryptedIndex >= 0) {\n      encryptedTags.splice(encryptedIndex, 1);\n      this._encryptedTags = encryptedTags;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(encryptedTags);\n      await this.encrypt(user);\n    }\n    if (publish) {\n      return this.publishReplaceable();\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n  }\n  /**\n   * Removes an item from the list.\n   *\n   * @param index The index of the item to remove.\n   * @param encrypted Whether to remove from the encrypted list or not.\n   */\n  async removeItem(index, encrypted) {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    if (encrypted) {\n      const user = await this.ndk.signer.user();\n      const currentList = await this.encryptedTags();\n      currentList.splice(index, 1);\n      this._encryptedTags = currentList;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(currentList);\n      await this.encrypt(user);\n    } else {\n      this.tags.splice(index, 1);\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n    return this;\n  }\n  has(item) {\n    return this.items.some((tag) => tag[1] === item);\n  }\n  /**\n   * Creates a filter that will result in fetching\n   * the items of this list\n   * @example\n   * const list = new NDKList(...);\n   * const filters = list.filterForItems();\n   * const events = await ndk.fetchEvents(filters);\n   */\n  filterForItems() {\n    const ids = /* @__PURE__ */ new Set();\n    const nip33Queries = /* @__PURE__ */ new Map();\n    const filters = [];\n    for (const tag of this.items) {\n      if (tag[0] === \"e\" && tag[1]) {\n        ids.add(tag[1]);\n      } else if (tag[0] === \"a\" && tag[1]) {\n        const [kind, pubkey, dTag] = tag[1].split(\":\");\n        if (!kind || !pubkey) continue;\n        const key = `${kind}:${pubkey}`;\n        const item = nip33Queries.get(key) || [];\n        item.push(dTag || \"\");\n        nip33Queries.set(key, item);\n      }\n    }\n    if (ids.size > 0) {\n      filters.push({ ids: Array.from(ids) });\n    }\n    if (nip33Queries.size > 0) {\n      for (const [key, values] of nip33Queries.entries()) {\n        const [kind, pubkey] = key.split(\":\");\n        filters.push({\n          kinds: [Number.parseInt(kind)],\n          authors: [pubkey],\n          \"#d\": values\n        });\n      }\n    }\n    return filters;\n  }\n};\nvar lists_default = NDKList;\n\n// src/events/kinds/nutzap/index.ts\n\nvar NDKNutzap = class _NDKNutzap extends NDKEvent {\n  debug;\n  _proofs = [];\n  static kind = 9321 /* Nutzap */;\n  static kinds = [_NDKNutzap.kind];\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 9321 /* Nutzap */;\n    this.debug = ndk?.debug.extend(\"nutzap\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:nutzap\");\n    if (!this.alt) this.alt = \"This is a nutzap\";\n    try {\n      const proofTags = this.getMatchingTags(\"proof\");\n      if (proofTags.length) {\n        this._proofs = proofTags.map((tag) => JSON.parse(tag[1]));\n      } else {\n        this._proofs = JSON.parse(this.content);\n      }\n    } catch {\n      return;\n    }\n  }\n  static from(event) {\n    const e = new _NDKNutzap(event.ndk, event);\n    if (!e._proofs || !e._proofs.length) return;\n    return e;\n  }\n  set comment(comment) {\n    this.content = comment ?? \"\";\n  }\n  get comment() {\n    const c = this.tagValue(\"comment\");\n    if (c) return c;\n    return this.content;\n  }\n  set proofs(proofs) {\n    this._proofs = proofs;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"proof\");\n    for (const proof of proofs) {\n      this.tags.push([\"proof\", JSON.stringify(proof)]);\n    }\n  }\n  get proofs() {\n    return this._proofs;\n  }\n  get rawP2pk() {\n    const firstProof = this.proofs[0];\n    try {\n      const secret = JSON.parse(firstProof.secret);\n      let payload;\n      if (typeof secret === \"string\") {\n        payload = JSON.parse(secret);\n        this.debug(\"stringified payload\", firstProof.secret);\n      } else if (typeof secret === \"object\") {\n        payload = secret;\n      }\n      if (Array.isArray(payload) && payload[0] === \"P2PK\" && payload.length > 1 && typeof payload[1] === \"object\" && payload[1] !== null) {\n        return payload[1].data;\n      }\n      if (typeof payload === \"object\" && payload !== null && typeof payload[1]?.data === \"string\") {\n        return payload[1].data;\n      }\n    } catch (e) {\n      this.debug(\"error parsing p2pk pubkey\", e, this.proofs[0]);\n    }\n    return void 0;\n  }\n  /**\n   * Gets the p2pk pubkey that is embedded in the first proof.\n   *\n   * Note that this returns a nostr pubkey, not a cashu pubkey (no \"02\" prefix)\n   */\n  get p2pk() {\n    const rawP2pk = this.rawP2pk;\n    if (!rawP2pk) return;\n    return rawP2pk.startsWith(\"02\") ? rawP2pk.slice(2) : rawP2pk;\n  }\n  /**\n   * Get the mint where this nutzap proofs exist\n   */\n  get mint() {\n    return this.tagValue(\"u\");\n  }\n  set mint(value) {\n    this.replaceTag([\"u\", value]);\n  }\n  get unit() {\n    let _unit = this.tagValue(\"unit\") ?? \"sat\";\n    if (_unit?.startsWith(\"msat\")) _unit = \"sat\";\n    return _unit;\n  }\n  set unit(value) {\n    this.removeTag(\"unit\");\n    if (value?.startsWith(\"msat\")) throw new Error(\"msat is not allowed, use sat denomination instead\");\n    if (value) this.tag([\"unit\", value]);\n  }\n  get amount() {\n    const amount = this.proofs.reduce((total, proof) => total + proof.amount, 0);\n    return amount;\n  }\n  sender = this.author;\n  /**\n   * Set the target of the nutzap\n   * @param target The target of the nutzap (a user or an event)\n   */\n  set target(target) {\n    this.tags = this.tags.filter((t) => t[0] !== \"p\");\n    if (target instanceof NDKEvent) {\n      this.tags.push(target.tagReference());\n    }\n  }\n  set recipientPubkey(pubkey) {\n    this.removeTag(\"p\");\n    this.tag([\"p\", pubkey]);\n  }\n  get recipientPubkey() {\n    return this.tagValue(\"p\");\n  }\n  get recipient() {\n    const pubkey = this.recipientPubkey;\n    if (this.ndk) return this.ndk.getUser({ pubkey });\n    return new NDKUser({ pubkey });\n  }\n  async toNostrEvent() {\n    if (this.unit === \"msat\") {\n      this.unit = \"sat\";\n    }\n    this.removeTag(\"amount\");\n    this.tags.push([\"amount\", this.amount.toString()]);\n    const event = await super.toNostrEvent();\n    event.content = this.comment;\n    return event;\n  }\n  /**\n   * Validates that the nutzap conforms to NIP-61\n   */\n  get isValid() {\n    let eTagCount = 0;\n    let pTagCount = 0;\n    let mintTagCount = 0;\n    for (const tag of this.tags) {\n      if (tag[0] === \"e\") eTagCount++;\n      if (tag[0] === \"p\") pTagCount++;\n      if (tag[0] === \"u\") mintTagCount++;\n    }\n    return (\n      // exactly one recipient and mint\n      pTagCount === 1 && mintTagCount === 1 && // must have at most one e tag\n      eTagCount <= 1 && // must have at least one proof\n      this.proofs.length > 0\n    );\n  }\n};\nfunction proofP2pk(proof) {\n  try {\n    const secret = JSON.parse(proof.secret);\n    let payload = {};\n    if (typeof secret === \"string\") {\n      payload = JSON.parse(secret);\n    } else if (typeof secret === \"object\") {\n      payload = secret;\n    }\n    const isP2PKLocked = payload[0] === \"P2PK\" && payload[1]?.data;\n    if (isP2PKLocked) {\n      return payload[1].data;\n    }\n  } catch (e) {\n    console.error(\"error parsing p2pk pubkey\", e, proof);\n  }\n}\nfunction proofP2pkNostr(proof) {\n  const p2pk = proofP2pk(proof);\n  if (!p2pk) return;\n  if (p2pk.startsWith(\"02\") && p2pk.length === 66) return p2pk.slice(2);\n  return p2pk;\n}\nfunction cashuPubkeyToNostrPubkey(cashuPubkey) {\n  if (cashuPubkey.startsWith(\"02\") && cashuPubkey.length === 66) return cashuPubkey.slice(2);\n  return void 0;\n}\n\n// src/events/kinds/simple-group/member-list.ts\nvar NDKSimpleGroupMemberList = class _NDKSimpleGroupMemberList extends NDKEvent {\n  relaySet;\n  memberSet = /* @__PURE__ */ new Set();\n  static kind = 39002 /* GroupMembers */;\n  static kinds = [39002 /* GroupMembers */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 39002 /* GroupMembers */;\n    this.memberSet = new Set(this.members);\n  }\n  static from(event) {\n    return new _NDKSimpleGroupMemberList(event.ndk, event);\n  }\n  get members() {\n    return this.getMatchingTags(\"p\").map((tag) => tag[1]);\n  }\n  hasMember(member) {\n    return this.memberSet.has(member);\n  }\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    relaySet ??= this.relaySet;\n    return super.publishReplaceable(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/events/kinds/simple-group/metadata.ts\nvar NDKSimpleGroupMetadata = class _NDKSimpleGroupMetadata extends NDKEvent {\n  static kind = 39e3 /* GroupMetadata */;\n  static kinds = [39e3 /* GroupMetadata */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 39e3 /* GroupMetadata */;\n  }\n  static from(event) {\n    return new _NDKSimpleGroupMetadata(event.ndk, event);\n  }\n  get name() {\n    return this.tagValue(\"name\");\n  }\n  get picture() {\n    return this.tagValue(\"picture\");\n  }\n  get about() {\n    return this.tagValue(\"about\");\n  }\n  get scope() {\n    if (this.getMatchingTags(\"public\").length > 0) return \"public\";\n    if (this.getMatchingTags(\"public\").length > 0) return \"private\";\n    return void 0;\n  }\n  set scope(scope) {\n    this.removeTag(\"public\");\n    this.removeTag(\"private\");\n    if (scope === \"public\") {\n      this.tags.push([\"public\", \"\"]);\n    } else if (scope === \"private\") {\n      this.tags.push([\"private\", \"\"]);\n    }\n  }\n  get access() {\n    if (this.getMatchingTags(\"open\").length > 0) return \"open\";\n    if (this.getMatchingTags(\"closed\").length > 0) return \"closed\";\n    return void 0;\n  }\n  set access(access) {\n    this.removeTag(\"open\");\n    this.removeTag(\"closed\");\n    if (access === \"open\") {\n      this.tags.push([\"open\", \"\"]);\n    } else if (access === \"closed\") {\n      this.tags.push([\"closed\", \"\"]);\n    }\n  }\n};\n\n// src/events/kinds/story.ts\nvar NDKStoryStickerType = /* @__PURE__ */ ((NDKStoryStickerType2) => {\n  NDKStoryStickerType2[\"Pubkey\"] = \"pubkey\";\n  NDKStoryStickerType2[\"Event\"] = \"event\";\n  NDKStoryStickerType2[\"Prompt\"] = \"prompt\";\n  NDKStoryStickerType2[\"Text\"] = \"text\";\n  NDKStoryStickerType2[\"Countdown\"] = \"countdown\";\n  return NDKStoryStickerType2;\n})(NDKStoryStickerType || {});\nfunction strToPosition(positionStr) {\n  const [x, y] = positionStr.split(\",\").map(Number);\n  return { x, y };\n}\nfunction strToDimension(dimensionStr) {\n  const [width, height] = dimensionStr.split(\"x\").map(Number);\n  return { width, height };\n}\nvar NDKStorySticker = class _NDKStorySticker {\n  static Text = \"text\" /* Text */;\n  static Pubkey = \"pubkey\" /* Pubkey */;\n  static Event = \"event\" /* Event */;\n  static Prompt = \"prompt\" /* Prompt */;\n  static Countdown = \"countdown\" /* Countdown */;\n  type;\n  value;\n  position;\n  dimension;\n  properties;\n  constructor(arg) {\n    if (Array.isArray(arg)) {\n      const tag = arg;\n      if (tag[0] !== \"sticker\" || tag.length < 5) {\n        throw new Error(\"Invalid sticker tag\");\n      }\n      this.type = tag[1];\n      this.value = tag[2];\n      this.position = strToPosition(tag[3]);\n      this.dimension = strToDimension(tag[4]);\n      const props = {};\n      for (let i = 5; i < tag.length; i++) {\n        const [key, ...rest] = tag[i].split(\" \");\n        props[key] = rest.join(\" \");\n      }\n      if (Object.keys(props).length > 0) {\n        this.properties = props;\n      }\n    } else {\n      this.type = arg;\n      this.value = void 0;\n      this.position = { x: 0, y: 0 };\n      this.dimension = { width: 0, height: 0 };\n    }\n  }\n  static fromTag(tag) {\n    try {\n      return new _NDKStorySticker(tag);\n    } catch {\n      return null;\n    }\n  }\n  get style() {\n    return this.properties?.style;\n  }\n  set style(style) {\n    if (style) this.properties = { ...this.properties, style };\n    else delete this.properties?.style;\n  }\n  get rotation() {\n    return this.properties?.rot ? Number.parseFloat(this.properties.rot) : void 0;\n  }\n  set rotation(rotation) {\n    if (rotation !== void 0) {\n      this.properties = { ...this.properties, rot: rotation.toString() };\n    } else {\n      delete this.properties?.rot;\n    }\n  }\n  /**\n   * Checks if the sticker is valid.\n   *\n   * @returns {boolean} - True if the sticker is valid, false otherwise.\n   */\n  get isValid() {\n    return this.hasValidDimensions() && this.hasValidPosition();\n  }\n  hasValidDimensions = () => {\n    return typeof this.dimension.width === \"number\" && typeof this.dimension.height === \"number\" && !Number.isNaN(this.dimension.width) && !Number.isNaN(this.dimension.height);\n  };\n  hasValidPosition = () => {\n    return typeof this.position.x === \"number\" && typeof this.position.y === \"number\" && !Number.isNaN(this.position.x) && !Number.isNaN(this.position.y);\n  };\n  toTag() {\n    if (!this.isValid) {\n      const errors = [\n        !this.hasValidDimensions() ? \"dimensions is invalid\" : void 0,\n        !this.hasValidPosition() ? \"position is invalid\" : void 0\n      ].filter(Boolean);\n      throw new Error(`Invalid sticker: ${errors.join(\", \")}`);\n    }\n    let value;\n    switch (this.type) {\n      case \"event\" /* Event */:\n        value = this.value.tagId();\n        break;\n      case \"pubkey\" /* Pubkey */:\n        value = this.value.pubkey;\n        break;\n      default:\n        value = this.value;\n    }\n    const tag = [\"sticker\", this.type, value, coordinates(this.position), dimension(this.dimension)];\n    if (this.properties) {\n      for (const [key, propValue] of Object.entries(this.properties)) {\n        tag.push(`${key} ${propValue}`);\n      }\n    }\n    return tag;\n  }\n};\nvar NDKStory = class _NDKStory extends NDKEvent {\n  static kind = 23 /* Story */;\n  static kinds = [23 /* Story */];\n  _imeta;\n  _dimensions;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 23 /* Story */;\n    if (rawEvent) {\n      for (const tag of rawEvent.tags) {\n        switch (tag[0]) {\n          case \"imeta\":\n            this._imeta = mapImetaTag(tag);\n            break;\n          case \"dim\":\n            this.dimensions = strToDimension(tag[1]);\n            break;\n        }\n      }\n    }\n  }\n  /**\n   * Creates a NDKStory from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKStory from.\n   * @returns NDKStory\n   */\n  static from(event) {\n    return new _NDKStory(event.ndk, event);\n  }\n  /**\n   * Checks if the story is valid (has exactly one imeta tag).\n   */\n  get isValid() {\n    return !!this.imeta;\n  }\n  /**\n   * Gets the first imeta tag (there should only be one).\n   */\n  get imeta() {\n    return this._imeta;\n  }\n  /**\n   * Sets a single imeta tag, replacing any existing ones.\n   */\n  set imeta(tag) {\n    this._imeta = tag;\n    this.tags = this.tags.filter((t) => t[0] !== \"imeta\");\n    if (tag) {\n      this.tags.push(imetaTagToTag(tag));\n    }\n  }\n  /**\n   * Getter for the story dimensions.\n   *\n   * @returns {NDKStoryDimension | undefined} - The story dimensions if available, otherwise undefined.\n   */\n  get dimensions() {\n    const dimTag = this.tagValue(\"dim\");\n    if (!dimTag) return void 0;\n    return strToDimension(dimTag);\n  }\n  /**\n   * Setter for the story dimensions.\n   *\n   * @param {NDKStoryDimension | undefined} dimensions - The dimensions to set for the story.\n   */\n  set dimensions(dimensions) {\n    this.removeTag(\"dim\");\n    if (dimensions) {\n      this.tags.push([\"dim\", `${dimensions.width}x${dimensions.height}`]);\n    }\n  }\n  /**\n   * Getter for the story duration.\n   *\n   * @returns {number | undefined} - The story duration in seconds if available, otherwise undefined.\n   */\n  get duration() {\n    const durTag = this.tagValue(\"dur\");\n    if (!durTag) return void 0;\n    return Number.parseInt(durTag);\n  }\n  /**\n   * Setter for the story duration.\n   *\n   * @param {number | undefined} duration - The duration in seconds to set for the story.\n   */\n  set duration(duration) {\n    this.removeTag(\"dur\");\n    if (duration !== void 0) {\n      this.tags.push([\"dur\", duration.toString()]);\n    }\n  }\n  /**\n   * Gets all stickers from the story.\n   *\n   * @returns {NDKStorySticker[]} - Array of stickers in the story.\n   */\n  get stickers() {\n    const stickers = [];\n    for (const tag of this.tags) {\n      if (tag[0] !== \"sticker\" || tag.length < 5) continue;\n      const sticker = NDKStorySticker.fromTag(tag);\n      if (sticker) stickers.push(sticker);\n    }\n    return stickers;\n  }\n  /**\n   * Adds a sticker to the story.\n   *\n   * @param {NDKStorySticker|StorySticker} sticker - The sticker to add.\n   */\n  addSticker(sticker) {\n    let stickerToAdd;\n    if (sticker instanceof NDKStorySticker) {\n      stickerToAdd = sticker;\n    } else {\n      const tag = [\n        \"sticker\",\n        sticker.type,\n        typeof sticker.value === \"string\" ? sticker.value : \"\",\n        coordinates(sticker.position),\n        dimension(sticker.dimension)\n      ];\n      if (sticker.properties) {\n        for (const [key, value] of Object.entries(sticker.properties)) {\n          tag.push(`${key} ${value}`);\n        }\n      }\n      stickerToAdd = new NDKStorySticker(tag);\n      stickerToAdd.value = sticker.value;\n    }\n    if (stickerToAdd.type === \"pubkey\" /* Pubkey */) {\n      this.tag(stickerToAdd.value);\n    } else if (stickerToAdd.type === \"event\" /* Event */) {\n      this.tag(stickerToAdd.value);\n    }\n    this.tags.push(stickerToAdd.toTag());\n  }\n  /**\n   * Removes a sticker from the story.\n   *\n   * @param {number} index - The index of the sticker to remove.\n   */\n  removeSticker(index) {\n    const stickers = this.stickers;\n    if (index < 0 || index >= stickers.length) return;\n    let stickerCount = 0;\n    for (let i = 0; i < this.tags.length; i++) {\n      if (this.tags[i][0] === \"sticker\") {\n        if (stickerCount === index) {\n          this.tags.splice(i, 1);\n          break;\n        }\n        stickerCount++;\n      }\n    }\n  }\n};\nvar coordinates = (position) => `${position.x},${position.y}`;\nvar dimension = (dimension2) => `${dimension2.width}x${dimension2.height}`;\n\n// src/events/kinds/subscriptions/amount.ts\nvar possibleIntervalFrequencies = [\n  \"daily\",\n  \"weekly\",\n  \"monthly\",\n  \"quarterly\",\n  \"yearly\"\n];\nfunction calculateTermDurationInSeconds(term) {\n  switch (term) {\n    case \"daily\":\n      return 24 * 60 * 60;\n    case \"weekly\":\n      return 7 * 24 * 60 * 60;\n    case \"monthly\":\n      return 30 * 24 * 60 * 60;\n    case \"quarterly\":\n      return 3 * 30 * 24 * 60 * 60;\n    case \"yearly\":\n      return 365 * 24 * 60 * 60;\n  }\n}\nfunction newAmount(amount, currency, term) {\n  return [\"amount\", amount.toString(), currency, term];\n}\nfunction parseTagToSubscriptionAmount(tag) {\n  const amount = Number.parseInt(tag[1]);\n  if (Number.isNaN(amount) || amount === void 0 || amount === null || amount <= 0) return void 0;\n  const currency = tag[2];\n  if (currency === void 0 || currency === \"\") return void 0;\n  const term = tag[3];\n  if (term === void 0) return void 0;\n  if (!possibleIntervalFrequencies.includes(term)) return void 0;\n  return {\n    amount,\n    currency,\n    term\n  };\n}\n\n// src/events/kinds/subscriptions/tier.ts\nvar NDKSubscriptionTier = class _NDKSubscriptionTier extends NDKArticle {\n  static kind = 37001 /* SubscriptionTier */;\n  static kinds = [37001 /* SubscriptionTier */];\n  constructor(ndk, rawEvent) {\n    const k = rawEvent?.kind ?? 37001 /* SubscriptionTier */;\n    super(ndk, rawEvent);\n    this.kind = k;\n  }\n  /**\n   * Creates a new NDKSubscriptionTier from an event\n   * @param event\n   * @returns NDKSubscriptionTier\n   */\n  static from(event) {\n    return new _NDKSubscriptionTier(event.ndk, event);\n  }\n  /**\n   * Returns perks for this tier\n   */\n  get perks() {\n    return this.getMatchingTags(\"perk\").map((tag) => tag[1]).filter((perk) => perk !== void 0);\n  }\n  /**\n   * Adds a perk to this tier\n   */\n  addPerk(perk) {\n    this.tags.push([\"perk\", perk]);\n  }\n  /**\n   * Returns the amount for this tier\n   */\n  get amounts() {\n    return this.getMatchingTags(\"amount\").map((tag) => parseTagToSubscriptionAmount(tag)).filter((a) => a !== void 0);\n  }\n  /**\n   * Adds an amount to this tier\n   * @param amount Amount in the smallest unit of the currency (e.g. cents, msats)\n   * @param currency Currency code. Use msat for millisatoshis\n   * @param term One of daily, weekly, monthly, quarterly, yearly\n   */\n  addAmount(amount, currency, term) {\n    this.tags.push(newAmount(amount, currency, term));\n  }\n  /**\n   * Sets a relay where content related to this tier can be found\n   * @param relayUrl URL of the relay\n   */\n  set relayUrl(relayUrl) {\n    this.tags.push([\"r\", relayUrl]);\n  }\n  /**\n   * Returns the relay URLs for this tier\n   */\n  get relayUrls() {\n    return this.getMatchingTags(\"r\").map((tag) => tag[1]).filter((relay) => relay !== void 0);\n  }\n  /**\n   * Gets the verifier pubkey for this tier. This is the pubkey that will generate\n   * subscription payment receipts\n   */\n  get verifierPubkey() {\n    return this.tagValue(\"p\");\n  }\n  /**\n   * Sets the verifier pubkey for this tier.\n   */\n  set verifierPubkey(pubkey) {\n    this.removeTag(\"p\");\n    if (pubkey) this.tags.push([\"p\", pubkey]);\n  }\n  /**\n   * Checks if this tier is valid\n   */\n  get isValid() {\n    return this.title !== void 0 && // Must have a title\n    this.amounts.length > 0;\n  }\n};\n\n// src/events/kinds/video.ts\nvar NDKVideo = class _NDKVideo extends NDKEvent {\n  static kind = 21 /* Video */;\n  static kinds = [34235 /* HorizontalVideo */, 34236 /* VerticalVideo */, 22 /* ShortVideo */, 21 /* Video */];\n  _imetas;\n  /**\n   * Creates a NDKArticle from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKArticle from.\n   * @returns NDKArticle\n   */\n  static from(event) {\n    return new _NDKVideo(event.ndk, event.rawEvent());\n  }\n  /**\n   * Getter for the article title.\n   *\n   * @returns {string | undefined} - The article title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the article title.\n   *\n   * @param {string | undefined} title - The title to set for the article.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the article thumbnail.\n   *\n   * @returns {string | undefined} - The article thumbnail if available, otherwise undefined.\n   */\n  get thumbnail() {\n    let thumbnail;\n    if (this.imetas && this.imetas.length > 0) {\n      thumbnail = this.imetas[0].image?.[0];\n    }\n    return thumbnail ?? this.tagValue(\"thumb\");\n  }\n  get imetas() {\n    if (this._imetas) return this._imetas;\n    this._imetas = this.tags.filter((tag) => tag[0] === \"imeta\").map(mapImetaTag);\n    return this._imetas;\n  }\n  set imetas(tags) {\n    this._imetas = tags;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"imeta\");\n    this.tags.push(...tags.map(imetaTagToTag));\n  }\n  get url() {\n    if (this.imetas && this.imetas.length > 0) {\n      return this.imetas[0].url;\n    }\n    return this.tagValue(\"url\");\n  }\n  /**\n   * Getter for the article's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      return Number.parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Generates content tags for the article.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.kind) {\n      if (this.imetas?.[0]?.dim) {\n        const [width, height] = this.imetas[0].dim.split(\"x\");\n        const isPortrait = width && height && Number.parseInt(width) < Number.parseInt(height);\n        const isShort = this.duration && this.duration < 120;\n        if (isShort && isPortrait) this.kind = 22 /* ShortVideo */;\n        else this.kind = 21 /* Video */;\n      }\n    }\n    return super.generateTags();\n  }\n  get duration() {\n    const tag = this.tagValue(\"duration\");\n    if (tag) {\n      return Number.parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the video's duration\n   *\n   * @param {number | undefined} duration - The duration to set for the video (in seconds)\n   */\n  set duration(dur) {\n    this.removeTag(\"duration\");\n    if (dur !== void 0) {\n      this.tags.push([\"duration\", Math.floor(dur).toString()]);\n    }\n  }\n};\n\n// src/events/kinds/wiki.ts\nvar NDKWiki = class _NDKWiki extends NDKArticle {\n  static kind = 30818 /* Wiki */;\n  static kinds = [30818 /* Wiki */];\n  static from(event) {\n    return new _NDKWiki(event.ndk, event.rawEvent());\n  }\n  get isDefered() {\n    return this.hasTag(\"a\", \"defer\");\n  }\n  get deferedId() {\n    return this.tagValue(\"a\", \"defer\");\n  }\n  /**\n   * Defers the author's wiki event to another wiki event.\n   *\n   * Wiki-events can tag other wiki-events with a `defer` marker to indicate that it considers someone else's entry as a \"better\" version of itself. If using a `defer` marker both `a` and `e` tags SHOULD be used.\n   *\n   * @example\n   * myWiki.defer = betterWikiEntryOnTheSameTopic;\n   * myWiki.publishReplaceable()\n   */\n  set defer(deferedTo) {\n    this.removeTag(\"a\", \"defer\");\n    this.tag(deferedTo, \"defer\");\n  }\n};\nvar NDKWikiMergeRequest = class _NDKWikiMergeRequest extends NDKEvent {\n  static kind = 818 /* WikiMergeRequest */;\n  static kinds = [818 /* WikiMergeRequest */];\n  static from(event) {\n    return new _NDKWikiMergeRequest(event.ndk, event.rawEvent());\n  }\n  /**\n   * The target ID (<kind:pubkey:d-tag>) of the wiki event to merge into.\n   */\n  get targetId() {\n    return this.tagValue(\"a\");\n  }\n  /**\n   * Sets the target ID (<kind:pubkey:d-tag>) of the wiki event to merge into.\n   */\n  set target(targetEvent) {\n    this.tags = this.tags.filter((tag) => {\n      if (tag[0] === \"a\") return true;\n      if (tag[0] === \"e\" && tag[3] !== \"source\") return true;\n    });\n    this.tag(targetEvent);\n  }\n  /**\n   * The source ID of the wiki event to merge from.\n   */\n  get sourceId() {\n    return this.tagValue(\"e\", \"source\");\n  }\n  /**\n   * Sets the event we are asking to get merged into the target.\n   */\n  set source(sourceEvent) {\n    this.removeTag(\"e\", \"source\");\n    this.tag(sourceEvent, \"source\", false, \"e\");\n  }\n};\n\n// src/events/wrap.ts\nfunction wrapEvent(event) {\n  const eventWrappingMap = /* @__PURE__ */ new Map();\n  for (const klass2 of [\n    NDKImage,\n    NDKVideo,\n    NDKCashuMintList,\n    NDKArticle,\n    NDKHighlight,\n    NDKWiki,\n    NDKNutzap,\n    NDKSimpleGroupMemberList,\n    NDKSimpleGroupMetadata,\n    NDKSubscriptionTier,\n    NDKCashuToken,\n    NDKList,\n    NDKStory\n  ]) {\n    for (const kind of klass2.kinds) {\n      eventWrappingMap.set(kind, klass2);\n    }\n  }\n  const klass = eventWrappingMap.get(event.kind);\n  if (klass) return klass.from(event);\n  return event;\n}\n\n// src/subscription/utils.ts\n\nvar MAX_SUBID_LENGTH = 20;\nfunction queryFullyFilled(subscription) {\n  if (filterIncludesIds(subscription.filter)) {\n    if (resultHasAllRequestedIds(subscription)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction compareFilter(filter1, filter2) {\n  if (Object.keys(filter1).length !== Object.keys(filter2).length) return false;\n  for (const [key, value] of Object.entries(filter1)) {\n    const valuesInFilter2 = filter2[key];\n    if (!valuesInFilter2) return false;\n    if (Array.isArray(value) && Array.isArray(valuesInFilter2)) {\n      const v = value;\n      for (const valueInFilter2 of valuesInFilter2) {\n        const val = valueInFilter2;\n        if (!v.includes(val)) {\n          return false;\n        }\n      }\n    } else {\n      if (valuesInFilter2 !== value) return false;\n    }\n  }\n  return true;\n}\nfunction filterIncludesIds(filter) {\n  return !!filter.ids;\n}\nfunction resultHasAllRequestedIds(subscription) {\n  const ids = subscription.filter.ids;\n  return !!ids && ids.length === subscription.eventFirstSeen.size;\n}\nfunction generateSubId(subscriptions, filters) {\n  const subIds = subscriptions.map((sub) => sub.subId).filter(Boolean);\n  const subIdParts = [];\n  const filterNonKindKeys = /* @__PURE__ */ new Set();\n  const filterKinds = /* @__PURE__ */ new Set();\n  if (subIds.length > 0) {\n    subIdParts.push(Array.from(new Set(subIds)).join(\",\"));\n  } else {\n    for (const filter of filters) {\n      for (const key of Object.keys(filter)) {\n        if (key === \"kinds\") {\n          filter.kinds?.forEach((k) => filterKinds.add(k));\n        } else {\n          filterNonKindKeys.add(key);\n        }\n      }\n    }\n    if (filterKinds.size > 0) {\n      subIdParts.push(`kinds:${Array.from(filterKinds).join(\",\")}`);\n    }\n    if (filterNonKindKeys.size > 0) {\n      subIdParts.push(Array.from(filterNonKindKeys).join(\",\"));\n    }\n  }\n  let subId = subIdParts.join(\"-\");\n  if (subId.length > MAX_SUBID_LENGTH) subId = subId.substring(0, MAX_SUBID_LENGTH);\n  subId += `-${Math.floor(Math.random() * 999).toString()}`;\n  return subId;\n}\nfunction filterForEventsTaggingId(id) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(id);\n    switch (decoded.type) {\n      case \"naddr\":\n        return {\n          \"#a\": [`${decoded.data.kind}:${decoded.data.pubkey}:${decoded.data.identifier}`]\n        };\n      case \"nevent\":\n        return { \"#e\": [decoded.data.id] };\n      case \"note\":\n        return { \"#e\": [decoded.data] };\n      case \"nprofile\":\n        return { \"#p\": [decoded.data.pubkey] };\n      case \"npub\":\n        return { \"#p\": [decoded.data] };\n    }\n  } catch {\n  }\n}\nfunction filterAndRelaySetFromBech32(beche2, ndk) {\n  const filter = filterFromId(beche2);\n  const relays = relaysFromBech32(beche2, ndk);\n  if (relays.length === 0) return { filter };\n  return {\n    filter,\n    relaySet: new NDKRelaySet(new Set(relays), ndk)\n  };\n}\nfunction filterFromId(id) {\n  let decoded;\n  if (id.match(NIP33_A_REGEX)) {\n    const [kind, pubkey, identifier] = id.split(\":\");\n    const filter = {\n      authors: [pubkey],\n      kinds: [Number.parseInt(kind)]\n    };\n    if (identifier) {\n      filter[\"#d\"] = [identifier];\n    }\n    return filter;\n  }\n  if (id.match(BECH32_REGEX)) {\n    try {\n      decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(id);\n      switch (decoded.type) {\n        case \"nevent\": {\n          const filter = { ids: [decoded.data.id] };\n          if (decoded.data.author) filter.authors = [decoded.data.author];\n          if (decoded.data.kind) filter.kinds = [decoded.data.kind];\n          return filter;\n        }\n        case \"note\":\n          return { ids: [decoded.data] };\n        case \"naddr\": {\n          const filter = {\n            authors: [decoded.data.pubkey],\n            kinds: [decoded.data.kind]\n          };\n          if (decoded.data.identifier) filter[\"#d\"] = [decoded.data.identifier];\n          return filter;\n        }\n      }\n    } catch (e) {\n      console.error(\"Error decoding\", id, e);\n    }\n  }\n  return { ids: [id] };\n}\nfunction isNip33AValue(value) {\n  return value.match(NIP33_A_REGEX) !== null;\n}\nvar NIP33_A_REGEX = /^(\\d+):([0-9A-Fa-f]+)(?::(.*))?$/;\nvar BECH32_REGEX = /^n(event|ote|profile|pub|addr)1[\\d\\w]+$/;\nfunction relaysFromBech32(bech322, ndk) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(bech322);\n    if ([\"naddr\", \"nevent\"].includes(decoded?.type)) {\n      const data = decoded.data;\n      if (data?.relays) {\n        return data.relays.map((r) => new NDKRelay(r, ndk.relayAuthDefaultPolicy, ndk));\n      }\n    }\n  } catch (_e) {\n  }\n  return [];\n}\n\n// src/subscription/index.ts\nvar NDKSubscriptionCacheUsage = /* @__PURE__ */ ((NDKSubscriptionCacheUsage2) => {\n  NDKSubscriptionCacheUsage2[\"ONLY_CACHE\"] = \"ONLY_CACHE\";\n  NDKSubscriptionCacheUsage2[\"CACHE_FIRST\"] = \"CACHE_FIRST\";\n  NDKSubscriptionCacheUsage2[\"PARALLEL\"] = \"PARALLEL\";\n  NDKSubscriptionCacheUsage2[\"ONLY_RELAY\"] = \"ONLY_RELAY\";\n  return NDKSubscriptionCacheUsage2;\n})(NDKSubscriptionCacheUsage || {});\nvar defaultOpts = {\n  closeOnEose: false,\n  cacheUsage: \"CACHE_FIRST\" /* CACHE_FIRST */,\n  dontSaveToCache: false,\n  groupable: true,\n  groupableDelay: 100,\n  groupableDelayType: \"at-most\",\n  cacheUnconstrainFilter: [\"limit\", \"since\", \"until\"]\n};\nvar NDKSubscription = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  subId;\n  filters;\n  opts;\n  pool;\n  skipVerification = false;\n  skipValidation = false;\n  /**\n   * Tracks the filters as they are executed on each relay\n   */\n  relayFilters;\n  relaySet;\n  ndk;\n  debug;\n  /**\n   * Events that have been seen by the subscription, with the time they were first seen.\n   */\n  eventFirstSeen = /* @__PURE__ */ new Map();\n  /**\n   * Relays that have sent an EOSE.\n   */\n  eosesSeen = /* @__PURE__ */ new Set();\n  /**\n   * The time the last event was received by the subscription.\n   * This is used to calculate when EOSE should be emitted.\n   */\n  lastEventReceivedAt;\n  /**\n   * The most recent event timestamp from cache results.\n   * This is used for addSinceFromCache functionality.\n   */\n  mostRecentCacheEventTimestamp;\n  internalId;\n  /**\n   * Whether the subscription should close when all relays have reached the end of the event stream.\n   */\n  closeOnEose;\n  /**\n   * Pool monitor callback\n   */\n  poolMonitor;\n  skipOptimisticPublishEvent = false;\n  /**\n   * Filters to remove when querying the cache.\n   */\n  cacheUnconstrainFilter;\n  constructor(ndk, filters, opts, subId) {\n    super();\n    this.ndk = ndk;\n    this.opts = { ...defaultOpts, ...opts || {} };\n    this.pool = this.opts.pool || ndk.pool;\n    this.filters = Array.isArray(filters) ? filters : [filters];\n    this.subId = subId || this.opts.subId;\n    this.internalId = Math.random().toString(36).substring(7);\n    this.debug = ndk.debug.extend(`subscription[${this.opts.subId ?? this.internalId}]`);\n    if (this.opts.relaySet) {\n      this.relaySet = this.opts.relaySet;\n    } else if (this.opts.relayUrls) {\n      this.relaySet = NDKRelaySet.fromRelayUrls(this.opts.relayUrls, this.ndk);\n    }\n    this.skipVerification = this.opts.skipVerification || false;\n    this.skipValidation = this.opts.skipValidation || false;\n    this.closeOnEose = this.opts.closeOnEose || false;\n    this.skipOptimisticPublishEvent = this.opts.skipOptimisticPublishEvent || false;\n    this.cacheUnconstrainFilter = this.opts.cacheUnconstrainFilter;\n  }\n  /**\n   * Returns the relays that have not yet sent an EOSE.\n   */\n  relaysMissingEose() {\n    if (!this.relayFilters) return [];\n    const relaysMissingEose = Array.from(this.relayFilters?.keys()).filter(\n      (url) => !this.eosesSeen.has(this.pool.getRelay(url, false, false))\n    );\n    return relaysMissingEose;\n  }\n  /**\n   * Provides access to the first filter of the subscription for\n   * backwards compatibility.\n   */\n  get filter() {\n    return this.filters[0];\n  }\n  get groupableDelay() {\n    if (!this.isGroupable()) return void 0;\n    return this.opts?.groupableDelay;\n  }\n  get groupableDelayType() {\n    return this.opts?.groupableDelayType || \"at-most\";\n  }\n  isGroupable() {\n    return this.opts?.groupable || false;\n  }\n  shouldQueryCache() {\n    if (this.opts.addSinceFromCache) return true;\n    if (this.opts?.cacheUsage === \"ONLY_RELAY\" /* ONLY_RELAY */) return false;\n    const hasNonEphemeralKind = this.filters.some((f) => f.kinds?.some((k) => kindIsEphemeral(k)));\n    if (hasNonEphemeralKind) return true;\n    return true;\n  }\n  shouldQueryRelays() {\n    return this.opts?.cacheUsage !== \"ONLY_CACHE\" /* ONLY_CACHE */;\n  }\n  shouldWaitForCache() {\n    if (this.opts.addSinceFromCache) return true;\n    return (\n      // Must want to close on EOSE; subscriptions\n      // that want to receive further updates must\n      // always hit the relay\n      !!this.opts.closeOnEose && // Cache adapter must claim to be fast\n      !!this.ndk.cacheAdapter?.locking && // If explicitly told to run in parallel, then\n      // we should not wait for the cache\n      this.opts.cacheUsage !== \"PARALLEL\" /* PARALLEL */\n    );\n  }\n  /**\n   * Start the subscription. This is the main method that should be called\n   * after creating a subscription.\n   *\n   * @param emitCachedEvents - Whether to emit events coming from a synchronous cache\n   *\n   * When using a synchronous cache, the events will be returned immediately\n   * by this function. If you will use those returned events, you should\n   * set emitCachedEvents to false to prevent seeing them as duplicate events.\n   */\n  start(emitCachedEvents = true) {\n    let cacheResult;\n    const updateStateFromCacheResults = (events) => {\n      if (emitCachedEvents) {\n        for (const event of events) {\n          if (!this.mostRecentCacheEventTimestamp || event.created_at > this.mostRecentCacheEventTimestamp) {\n            this.mostRecentCacheEventTimestamp = event.created_at;\n          }\n          this.eventReceived(event, void 0, true, false);\n        }\n      } else {\n        cacheResult = [];\n        for (const event of events) {\n          if (!this.mostRecentCacheEventTimestamp || event.created_at > this.mostRecentCacheEventTimestamp) {\n            this.mostRecentCacheEventTimestamp = event.created_at;\n          }\n          event.ndk = this.ndk;\n          const e = this.opts.wrap ? wrapEvent(event) : event;\n          if (!e) break;\n          if (e instanceof Promise) {\n            e.then((wrappedEvent) => {\n              this.emitEvent(false, wrappedEvent, void 0, true, false);\n            });\n            break;\n          }\n          this.eventFirstSeen.set(e.id, Date.now());\n          cacheResult.push(e);\n        }\n      }\n    };\n    const loadFromRelays = () => {\n      if (this.shouldQueryRelays()) {\n        this.startWithRelays();\n        this.startPoolMonitor();\n      } else {\n        this.emit(\"eose\", this);\n      }\n    };\n    if (this.shouldQueryCache()) {\n      cacheResult = this.startWithCache();\n      if (cacheResult instanceof Promise) {\n        if (this.shouldWaitForCache()) {\n          cacheResult.then((events) => {\n            updateStateFromCacheResults(events);\n            if (queryFullyFilled(this)) {\n              this.emit(\"eose\", this);\n              return;\n            }\n            loadFromRelays();\n          });\n          return null;\n        }\n        cacheResult.then((events) => {\n          updateStateFromCacheResults(events);\n        });\n        loadFromRelays();\n        return null;\n      }\n      updateStateFromCacheResults(cacheResult);\n      if (queryFullyFilled(this)) {\n        this.emit(\"eose\", this);\n      } else {\n        loadFromRelays();\n      }\n      return cacheResult;\n    }\n    loadFromRelays();\n    return null;\n  }\n  /**\n   * We want to monitor for new relays that are coming online, in case\n   * they should be part of this subscription.\n   */\n  startPoolMonitor() {\n    const _d = this.debug.extend(\"pool-monitor\");\n    this.poolMonitor = (relay) => {\n      if (this.relayFilters?.has(relay.url)) return;\n      const calc = calculateRelaySetsFromFilters(this.ndk, this.filters, this.pool);\n      if (calc.get(relay.url)) {\n        this.relayFilters?.set(relay.url, this.filters);\n        relay.subscribe(this, this.filters);\n      }\n    };\n    this.pool.on(\"relay:connect\", this.poolMonitor);\n  }\n  onStopped;\n  stop() {\n    this.emit(\"close\", this);\n    this.poolMonitor && this.pool.off(\"relay:connect\", this.poolMonitor);\n    this.onStopped?.();\n  }\n  /**\n   * @returns Whether the subscription has an authors filter.\n   */\n  hasAuthorsFilter() {\n    return this.filters.some((f) => f.authors?.length);\n  }\n  startWithCache() {\n    if (this.ndk.cacheAdapter?.query) {\n      return this.ndk.cacheAdapter.query(this);\n    }\n    return [];\n  }\n  /**\n   * Find available relays that should be part of this subscription and execute in them.\n   *\n   * Note that this is executed in addition to using the pool monitor, so even if the relay set\n   * that is computed (i.e. we don't have any relays available), when relays come online, we will\n   * check if we need to execute in them.\n   */\n  startWithRelays() {\n    let filters = this.filters;\n    if (this.opts.addSinceFromCache && this.mostRecentCacheEventTimestamp) {\n      const sinceTimestamp = this.mostRecentCacheEventTimestamp + 1;\n      filters = filters.map((filter) => ({\n        ...filter,\n        since: Math.max(filter.since || 0, sinceTimestamp)\n      }));\n    }\n    if (!this.relaySet || this.relaySet.relays.size === 0) {\n      this.relayFilters = calculateRelaySetsFromFilters(this.ndk, filters, this.pool);\n    } else {\n      this.relayFilters = /* @__PURE__ */ new Map();\n      for (const relay of this.relaySet.relays) {\n        this.relayFilters.set(relay.url, filters);\n      }\n    }\n    for (const [relayUrl, filters2] of this.relayFilters) {\n      const relay = this.pool.getRelay(relayUrl, true, true, filters2);\n      relay.subscribe(this, filters2);\n    }\n  }\n  // EVENT handling\n  /**\n   * Called when an event is received from a relay or the cache\n   * @param event\n   * @param relay\n   * @param fromCache Whether the event was received from the cache\n   * @param optimisticPublish Whether this event is coming from an optimistic publish\n   */\n  eventReceived(event, relay, fromCache = false, optimisticPublish = false) {\n    const eventId = event.id;\n    const eventAlreadySeen = this.eventFirstSeen.has(eventId);\n    let ndkEvent;\n    if (event instanceof NDKEvent) ndkEvent = event;\n    if (!eventAlreadySeen) {\n      ndkEvent ??= new NDKEvent(this.ndk, event);\n      ndkEvent.ndk = this.ndk;\n      ndkEvent.relay = relay;\n      if (!fromCache && !optimisticPublish) {\n        if (!this.skipValidation) {\n          if (!ndkEvent.isValid) {\n            this.debug(\"Event failed validation %s from relay %s\", eventId, relay?.url);\n            return;\n          }\n        }\n        if (relay) {\n          if (relay?.shouldValidateEvent() !== false) {\n            if (!this.skipVerification) {\n              if (!ndkEvent.verifySignature(true) && !this.ndk.asyncSigVerification) {\n                this.debug(\"Event failed signature validation\", event);\n                return;\n              }\n              if (relay) {\n                relay.addValidatedEvent();\n              }\n            }\n          } else {\n            relay.addNonValidatedEvent();\n          }\n        }\n        if (this.ndk.cacheAdapter && !this.opts.dontSaveToCache) {\n          this.ndk.cacheAdapter.setEvent(ndkEvent, this.filters, relay);\n        }\n      }\n      if (!optimisticPublish || this.skipOptimisticPublishEvent !== true) {\n        this.emitEvent(this.opts?.wrap ?? false, ndkEvent, relay, fromCache, optimisticPublish);\n        this.eventFirstSeen.set(eventId, Date.now());\n      }\n    } else {\n      const timeSinceFirstSeen = Date.now() - (this.eventFirstSeen.get(eventId) || 0);\n      this.emit(\"event:dup\", event, relay, timeSinceFirstSeen, this, fromCache, optimisticPublish);\n      if (relay) {\n        const signature = verifiedSignatures.get(eventId);\n        if (signature && typeof signature === \"string\") {\n          if (event.sig === signature) {\n            relay.addValidatedEvent();\n          }\n        }\n      }\n    }\n    this.lastEventReceivedAt = Date.now();\n  }\n  /**\n   * Optionally wraps, sync or async, and emits the event (if one comes back from the wrapper)\n   */\n  emitEvent(wrap, evt, relay, fromCache, optimisticPublish) {\n    const wrapped = wrap ? wrapEvent(evt) : evt;\n    if (wrapped instanceof Promise) {\n      wrapped.then((e) => this.emitEvent(false, e, relay, fromCache, optimisticPublish));\n    } else if (wrapped) {\n      this.emit(\"event\", wrapped, relay, this, fromCache, optimisticPublish);\n    }\n  }\n  closedReceived(relay, reason) {\n    this.emit(\"closed\", relay, reason);\n  }\n  // EOSE handling\n  eoseTimeout;\n  eosed = false;\n  eoseReceived(relay) {\n    this.debug(\"EOSE received from %s\", relay.url);\n    this.eosesSeen.add(relay);\n    let lastEventSeen = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;\n    const hasSeenAllEoses = this.eosesSeen.size === this.relayFilters?.size;\n    const queryFilled = queryFullyFilled(this);\n    const performEose = (reason) => {\n      this.debug(\"Performing EOSE: %s %d\", reason, this.eosed);\n      if (this.eosed) return;\n      if (this.eoseTimeout) clearTimeout(this.eoseTimeout);\n      this.emit(\"eose\", this);\n      this.eosed = true;\n      if (this.opts?.closeOnEose) this.stop();\n    };\n    if (queryFilled || hasSeenAllEoses) {\n      performEose(\"query filled or seen all\");\n    } else if (this.relayFilters) {\n      let timeToWaitForNextEose = 1e3;\n      const connectedRelays = new Set(this.pool.connectedRelays().map((r) => r.url));\n      const connectedRelaysWithFilters = Array.from(this.relayFilters.keys()).filter(\n        (url) => connectedRelays.has(url)\n      );\n      if (connectedRelaysWithFilters.length === 0) {\n        this.debug(\n          \"No connected relays, waiting for all relays to connect\",\n          Array.from(this.relayFilters.keys()).join(\", \")\n        );\n        return;\n      }\n      const percentageOfRelaysThatHaveSentEose = this.eosesSeen.size / connectedRelaysWithFilters.length;\n      this.debug(\"Percentage of relays that have sent EOSE\", {\n        subId: this.subId,\n        percentageOfRelaysThatHaveSentEose,\n        seen: this.eosesSeen.size,\n        total: connectedRelaysWithFilters.length\n      });\n      if (this.eosesSeen.size >= 2 && percentageOfRelaysThatHaveSentEose >= 0.5) {\n        timeToWaitForNextEose = timeToWaitForNextEose * (1 - percentageOfRelaysThatHaveSentEose);\n        if (timeToWaitForNextEose === 0) {\n          performEose(\"time to wait was 0\");\n          return;\n        }\n        if (this.eoseTimeout) clearTimeout(this.eoseTimeout);\n        const sendEoseTimeout = () => {\n          lastEventSeen = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;\n          if (lastEventSeen !== void 0 && lastEventSeen < 20) {\n            this.eoseTimeout = setTimeout(sendEoseTimeout, timeToWaitForNextEose);\n          } else {\n            performEose(`send eose timeout: ${timeToWaitForNextEose}`);\n          }\n        };\n        this.eoseTimeout = setTimeout(sendEoseTimeout, timeToWaitForNextEose);\n      }\n    }\n  }\n};\nvar kindIsEphemeral = (kind) => kind >= 2e4 && kind < 3e4;\n\n// src/user/follows.ts\nasync function follows(opts, outbox, kind = 3 /* Contacts */) {\n  if (!this.ndk) throw new Error(\"NDK not set\");\n  const contactListEvent = await this.ndk.fetchEvent(\n    { kinds: [kind], authors: [this.pubkey] },\n    opts || { groupable: false }\n  );\n  if (contactListEvent) {\n    const pubkeys = /* @__PURE__ */ new Set();\n    contactListEvent.tags.forEach((tag) => {\n      if (tag[0] === \"p\") pubkeys.add(tag[1]);\n    });\n    if (outbox) {\n      this.ndk?.outboxTracker?.trackUsers(Array.from(pubkeys));\n    }\n    return [...pubkeys].reduce((acc, pubkey) => {\n      const user = new NDKUser({ pubkey });\n      user.ndk = this.ndk;\n      acc.add(user);\n      return acc;\n    }, /* @__PURE__ */ new Set());\n  }\n  return /* @__PURE__ */ new Set();\n}\n\n// src/user/nip05.ts\nvar NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w.-]+)$/;\nasync function getNip05For(ndk, fullname, _fetch = fetch, fetchOpts = {}) {\n  return await ndk.queuesNip05.add({\n    id: fullname,\n    func: async () => {\n      if (ndk.cacheAdapter?.loadNip05) {\n        const profile = await ndk.cacheAdapter.loadNip05(fullname);\n        if (profile !== \"missing\") {\n          if (profile) {\n            const user = new NDKUser({\n              pubkey: profile.pubkey,\n              relayUrls: profile.relays,\n              nip46Urls: profile.nip46\n            });\n            user.ndk = ndk;\n            return user;\n          }\n          if (fetchOpts.cache !== \"no-cache\") {\n            return null;\n          }\n        }\n      }\n      const match = fullname.match(NIP05_REGEX);\n      if (!match) return null;\n      const [_, name = \"_\", domain] = match;\n      try {\n        const res = await _fetch(`https://${domain}/.well-known/nostr.json?name=${name}`, fetchOpts);\n        const { names, relays, nip46 } = parseNIP05Result(await res.json());\n        const pubkey = names[name.toLowerCase()];\n        let profile = null;\n        if (pubkey) {\n          profile = { pubkey, relays: relays?.[pubkey], nip46: nip46?.[pubkey] };\n        }\n        if (ndk?.cacheAdapter?.saveNip05) {\n          ndk.cacheAdapter.saveNip05(fullname, profile);\n        }\n        return profile;\n      } catch (_e) {\n        if (ndk?.cacheAdapter?.saveNip05) {\n          ndk?.cacheAdapter.saveNip05(fullname, null);\n        }\n        console.error(\"Failed to fetch NIP05 for\", fullname, _e);\n        return null;\n      }\n    }\n  });\n}\nfunction parseNIP05Result(json) {\n  const result = {\n    names: {}\n  };\n  for (const [name, pubkey] of Object.entries(json.names)) {\n    if (typeof name === \"string\" && typeof pubkey === \"string\") {\n      result.names[name.toLowerCase()] = pubkey;\n    }\n  }\n  if (json.relays) {\n    result.relays = {};\n    for (const [pubkey, relays] of Object.entries(json.relays)) {\n      if (typeof pubkey === \"string\" && Array.isArray(relays)) {\n        result.relays[pubkey] = relays.filter((relay) => typeof relay === \"string\");\n      }\n    }\n  }\n  if (json.nip46) {\n    result.nip46 = {};\n    for (const [pubkey, nip46] of Object.entries(json.nip46)) {\n      if (typeof pubkey === \"string\" && Array.isArray(nip46)) {\n        result.nip46[pubkey] = nip46.filter((relay) => typeof relay === \"string\");\n      }\n    }\n  }\n  return result;\n}\n\n// src/user/profile.ts\nfunction profileFromEvent(event) {\n  const profile = {};\n  let payload;\n  try {\n    payload = JSON.parse(event.content);\n  } catch (error) {\n    throw new Error(`Failed to parse profile event: ${error}`);\n  }\n  profile.profileEvent = JSON.stringify(event.rawEvent());\n  for (const key of Object.keys(payload)) {\n    switch (key) {\n      case \"name\":\n        profile.name = payload.name;\n        break;\n      case \"display_name\":\n        profile.displayName = payload.display_name;\n        break;\n      case \"image\":\n      case \"picture\":\n        profile.picture = payload.picture || payload.image;\n        profile.image = profile.picture;\n        break;\n      case \"banner\":\n        profile.banner = payload.banner;\n        break;\n      case \"bio\":\n        profile.bio = payload.bio;\n        break;\n      case \"nip05\":\n        profile.nip05 = payload.nip05;\n        break;\n      case \"lud06\":\n        profile.lud06 = payload.lud06;\n        break;\n      case \"lud16\":\n        profile.lud16 = payload.lud16;\n        break;\n      case \"about\":\n        profile.about = payload.about;\n        break;\n      case \"website\":\n        profile.website = payload.website;\n        break;\n      default:\n        profile[key] = payload[key];\n        break;\n    }\n  }\n  profile.created_at = event.created_at;\n  return profile;\n}\nfunction serializeProfile(profile) {\n  const payload = {};\n  for (const [key, val] of Object.entries(profile)) {\n    switch (key) {\n      case \"username\":\n      case \"name\":\n        payload.name = val;\n        break;\n      case \"displayName\":\n        payload.display_name = val;\n        break;\n      case \"image\":\n      case \"picture\":\n        payload.picture = val;\n        break;\n      case \"bio\":\n      case \"about\":\n        payload.about = val;\n        break;\n      default:\n        payload[key] = val;\n        break;\n    }\n  }\n  return JSON.stringify(payload);\n}\n\n// src/user/index.ts\nvar NDKUser = class _NDKUser {\n  ndk;\n  profile;\n  profileEvent;\n  _npub;\n  _pubkey;\n  relayUrls = [];\n  nip46Urls = [];\n  constructor(opts) {\n    if (opts.npub) this._npub = opts.npub;\n    if (opts.hexpubkey) this._pubkey = opts.hexpubkey;\n    if (opts.pubkey) this._pubkey = opts.pubkey;\n    if (opts.relayUrls) this.relayUrls = opts.relayUrls;\n    if (opts.nip46Urls) this.nip46Urls = opts.nip46Urls;\n    if (opts.nprofile) {\n      try {\n        const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(opts.nprofile);\n        if (decoded.type === \"nprofile\") {\n          this._pubkey = decoded.data.pubkey;\n          if (decoded.data.relays && decoded.data.relays.length > 0) {\n            this.relayUrls.push(...decoded.data.relays);\n          }\n        }\n      } catch (e) {\n        console.error(\"Failed to decode nprofile\", e);\n      }\n    }\n  }\n  get npub() {\n    if (!this._npub) {\n      if (!this._pubkey) throw new Error(\"pubkey not set\");\n      this._npub = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.npubEncode(this.pubkey);\n    }\n    return this._npub;\n  }\n  get nprofile() {\n    const relays = this.profileEvent?.onRelays?.map((r) => r.url);\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.nprofileEncode({\n      pubkey: this.pubkey,\n      relays\n    });\n  }\n  set npub(npub2) {\n    this._npub = npub2;\n  }\n  /**\n   * Get the user's pubkey\n   * @returns {string} The user's pubkey\n   */\n  get pubkey() {\n    if (!this._pubkey) {\n      if (!this._npub) throw new Error(\"npub not set\");\n      this._pubkey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(this.npub).data;\n    }\n    return this._pubkey;\n  }\n  /**\n   * Set the user's pubkey\n   * @param pubkey {string} The user's pubkey\n   */\n  set pubkey(pubkey) {\n    this._pubkey = pubkey;\n  }\n  /**\n   * Equivalent to NDKEvent.filters().\n   * @returns {NDKFilter}\n   */\n  filter() {\n    return { \"#p\": [this.pubkey] };\n  }\n  /**\n   * Gets NIP-57 and NIP-61 information that this user has signaled\n   *\n   * @param getAll {boolean} Whether to get all zap info or just the first one\n   */\n  async getZapInfo(timeoutMs) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const promiseWithTimeout = async (promise) => {\n      if (!timeoutMs) return promise;\n      let timeoutId;\n      const timeoutPromise = new Promise((_, reject) => {\n        timeoutId = setTimeout(() => reject(new Error(\"Timeout\")), timeoutMs);\n      });\n      try {\n        const result = await Promise.race([promise, timeoutPromise]);\n        if (timeoutId) clearTimeout(timeoutId);\n        return result;\n      } catch (e) {\n        if (e instanceof Error && e.message === \"Timeout\") {\n          try {\n            const result = await promise;\n            return result;\n          } catch (_originalError) {\n            return void 0;\n          }\n        }\n        return void 0;\n      }\n    };\n    const [userProfile, mintListEvent] = await Promise.all([\n      promiseWithTimeout(this.fetchProfile()),\n      promiseWithTimeout(this.ndk.fetchEvent({ kinds: [10019 /* CashuMintList */], authors: [this.pubkey] }))\n    ]);\n    const res = /* @__PURE__ */ new Map();\n    if (mintListEvent) {\n      const mintList = NDKCashuMintList.from(mintListEvent);\n      if (mintList.mints.length > 0) {\n        res.set(\"nip61\", {\n          mints: mintList.mints,\n          relays: mintList.relays,\n          p2pk: mintList.p2pk\n        });\n      }\n    }\n    if (userProfile) {\n      const { lud06, lud16 } = userProfile;\n      res.set(\"nip57\", { lud06, lud16 });\n    }\n    return res;\n  }\n  /**\n   * Instantiate an NDKUser from a NIP-05 string\n   * @param nip05Id {string} The user's NIP-05\n   * @param ndk {NDK} An NDK instance\n   * @param skipCache {boolean} Whether to skip the cache or not\n   * @returns {NDKUser | undefined} An NDKUser if one is found for the given NIP-05, undefined otherwise.\n   */\n  static async fromNip05(nip05Id, ndk, skipCache = false) {\n    if (!ndk) throw new Error(\"No NDK instance found\");\n    const opts = {};\n    if (skipCache) opts.cache = \"no-cache\";\n    const profile = await getNip05For(ndk, nip05Id, ndk?.httpFetch, opts);\n    if (profile) {\n      const user = new _NDKUser({\n        pubkey: profile.pubkey,\n        relayUrls: profile.relays,\n        nip46Urls: profile.nip46\n      });\n      user.ndk = ndk;\n      return user;\n    }\n  }\n  /**\n   * Fetch a user's profile\n   * @param opts {NDKSubscriptionOptions} A set of NDKSubscriptionOptions\n   * @param storeProfileEvent {boolean} Whether to store the profile event or not\n   * @returns User Profile\n   */\n  async fetchProfile(opts, storeProfileEvent = false) {\n    if (!this.ndk) throw new Error(\"NDK not set\");\n    let setMetadataEvent = null;\n    if (this.ndk.cacheAdapter && (this.ndk.cacheAdapter.fetchProfile || this.ndk.cacheAdapter.fetchProfileSync) && opts?.cacheUsage !== \"ONLY_RELAY\" /* ONLY_RELAY */) {\n      let profile = null;\n      if (this.ndk.cacheAdapter.fetchProfileSync) {\n        profile = this.ndk.cacheAdapter.fetchProfileSync(this.pubkey);\n      } else if (this.ndk.cacheAdapter.fetchProfile) {\n        profile = await this.ndk.cacheAdapter.fetchProfile(this.pubkey);\n      }\n      if (profile) {\n        this.profile = profile;\n        return profile;\n      }\n    }\n    opts ??= {};\n    opts.cacheUsage ??= \"ONLY_RELAY\" /* ONLY_RELAY */;\n    opts.closeOnEose ??= true;\n    opts.groupable ??= true;\n    opts.groupableDelay ??= 250;\n    if (!setMetadataEvent) {\n      setMetadataEvent = await this.ndk.fetchEvent({ kinds: [0], authors: [this.pubkey] }, opts);\n    }\n    if (!setMetadataEvent) return null;\n    this.profile = profileFromEvent(setMetadataEvent);\n    if (storeProfileEvent && this.profile && this.ndk.cacheAdapter && this.ndk.cacheAdapter.saveProfile) {\n      this.ndk.cacheAdapter.saveProfile(this.pubkey, this.profile);\n    }\n    return this.profile;\n  }\n  /**\n   * Returns a set of users that this user follows.\n   *\n   * @deprecated Use followSet instead\n   */\n  follows = follows.bind(this);\n  /**\n   * Returns a set of pubkeys that this user follows.\n   *\n   * @param opts - NDKSubscriptionOptions\n   * @param outbox - boolean\n   * @param kind - number\n   */\n  async followSet(opts, outbox, kind = 3 /* Contacts */) {\n    const follows2 = await this.follows(opts, outbox, kind);\n    return new Set(Array.from(follows2).map((f) => f.pubkey));\n  }\n  /** @deprecated Use referenceTags instead. */\n  /**\n   * Get the tag that can be used to reference this user in an event\n   * @returns {NDKTag} an NDKTag\n   */\n  tagReference() {\n    return [\"p\", this.pubkey];\n  }\n  /**\n   * Get the tags that can be used to reference this user in an event\n   * @returns {NDKTag[]} an array of NDKTag\n   */\n  referenceTags(marker) {\n    const tag = [[\"p\", this.pubkey]];\n    if (!marker) return tag;\n    tag[0].push(\"\", marker);\n    return tag;\n  }\n  /**\n   * Publishes the current profile.\n   */\n  async publish() {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    if (!this.profile) throw new Error(\"No profile available\");\n    this.ndk.assertSigner();\n    const event = new NDKEvent(this.ndk, {\n      kind: 0,\n      content: serializeProfile(this.profile)\n    });\n    await event.publish();\n  }\n  /**\n   * Add a follow to this user's contact list\n   *\n   * @param newFollow {NDKUser} The user to follow\n   * @param currentFollowList {Set<NDKUser>} The current follow list\n   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)\n   * @returns {Promise<boolean>} True if the follow was added, false if the follow already exists\n   */\n  async follow(newFollow, currentFollowList, kind = 3 /* Contacts */) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    if (!currentFollowList) {\n      currentFollowList = await this.follows(void 0, void 0, kind);\n    }\n    if (currentFollowList.has(newFollow)) {\n      return false;\n    }\n    currentFollowList.add(newFollow);\n    const event = new NDKEvent(this.ndk, { kind });\n    for (const follow of currentFollowList) {\n      event.tag(follow);\n    }\n    await event.publish();\n    return true;\n  }\n  /**\n   * Remove a follow from this user's contact list\n   *\n   * @param user {NDKUser} The user to unfollow\n   * @param currentFollowList {Set<NDKUser>} The current follow list\n   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)\n   * @returns The relays were the follow list was published or false if the user wasn't found\n   */\n  async unfollow(user, currentFollowList, kind = 3 /* Contacts */) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    if (!currentFollowList) {\n      currentFollowList = await this.follows(void 0, void 0, kind);\n    }\n    const newUserFollowList = /* @__PURE__ */ new Set();\n    let foundUser = false;\n    for (const follow of currentFollowList) {\n      if (follow.pubkey !== user.pubkey) {\n        newUserFollowList.add(follow);\n      } else {\n        foundUser = true;\n      }\n    }\n    if (!foundUser) return false;\n    const event = new NDKEvent(this.ndk, { kind });\n    for (const follow of newUserFollowList) {\n      event.tag(follow);\n    }\n    return await event.publish();\n  }\n  /**\n   * Validate a user's NIP-05 identifier (usually fetched from their kind:0 profile data)\n   *\n   * @param nip05Id The NIP-05 string to validate\n   * @returns {Promise<boolean | null>} True if the NIP-05 is found and matches this user's pubkey,\n   * False if the NIP-05 is found but doesn't match this user's pubkey,\n   * null if the NIP-05 isn't found on the domain or we're unable to verify (because of network issues, etc.)\n   */\n  async validateNip05(nip05Id) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const profilePointer = await getNip05For(this.ndk, nip05Id);\n    if (profilePointer === null) return null;\n    return profilePointer.pubkey === this.pubkey;\n  }\n};\n\n// src/user/pin.ts\nasync function pinEvent(user, event, pinEvent2, publish) {\n  const kind = 10001 /* PinList */;\n  if (!user.ndk) throw new Error(\"No NDK instance found\");\n  user.ndk.assertSigner();\n  if (!pinEvent2) {\n    const events = await user.ndk.fetchEvents(\n      { kinds: [kind], authors: [user.pubkey] },\n      { cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */ }\n    );\n    if (events.size > 0) {\n      pinEvent2 = lists_default.from(Array.from(events)[0]);\n    } else {\n      pinEvent2 = new NDKEvent(user.ndk, {\n        kind\n      });\n    }\n  }\n  pinEvent2.tag(event);\n  if (publish) {\n    await pinEvent2.publish();\n  }\n  return pinEvent2;\n}\n\n// src/events/kinds/classified.ts\nvar NDKClassified = class _NDKClassified extends NDKEvent {\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30402 /* Classified */;\n  }\n  /**\n   * Creates a NDKClassified from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKClassified from.\n   * @returns NDKClassified\n   */\n  static from(event) {\n    return new _NDKClassified(event.ndk, event);\n  }\n  /**\n   * Getter for the classified title.\n   *\n   * @returns {string | undefined} - The classified title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the classified title.\n   *\n   * @param {string | undefined} title - The title to set for the classified.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the classified summary.\n   *\n   * @returns {string | undefined} - The classified summary if available, otherwise undefined.\n   */\n  get summary() {\n    return this.tagValue(\"summary\");\n  }\n  /**\n   * Setter for the classified summary.\n   *\n   * @param {string | undefined} summary - The summary to set for the classified.\n   */\n  set summary(summary) {\n    this.removeTag(\"summary\");\n    if (summary) this.tags.push([\"summary\", summary]);\n  }\n  /**\n   * Getter for the classified's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the classified was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      return Number.parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the classified's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the classified's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Getter for the classified location.\n   *\n   * @returns {string | undefined} - The classified location if available, otherwise undefined.\n   */\n  get location() {\n    return this.tagValue(\"location\");\n  }\n  /**\n   * Setter for the classified location.\n   *\n   * @param {string | undefined} location - The location to set for the classified.\n   */\n  set location(location) {\n    this.removeTag(\"location\");\n    if (location) this.tags.push([\"location\", location]);\n  }\n  /**\n   * Getter for the classified price.\n   *\n   * @returns {NDKClassifiedPriceTag | undefined} - The classified price if available, otherwise undefined.\n   */\n  get price() {\n    const priceTag = this.tags.find((tag) => tag[0] === \"price\");\n    if (priceTag) {\n      return {\n        amount: Number.parseFloat(priceTag[1]),\n        currency: priceTag[2],\n        frequency: priceTag[3]\n      };\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the classified price.\n   *\n   * @param price - The price to set for the classified.\n   */\n  set price(priceTag) {\n    if (typeof priceTag === \"string\") {\n      priceTag = {\n        amount: Number.parseFloat(priceTag)\n      };\n    }\n    if (priceTag?.amount) {\n      const tag = [\"price\", priceTag.amount.toString()];\n      if (priceTag.currency) tag.push(priceTag.currency);\n      if (priceTag.frequency) tag.push(priceTag.frequency);\n      this.tags.push(tag);\n    } else {\n      this.removeTag(\"price\");\n    }\n  }\n  /**\n   * Generates content tags for the classified.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n};\n\n// src/events/kinds/drafts.ts\nvar NDKDraft = class _NDKDraft extends NDKEvent {\n  _event;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 31234 /* Draft */;\n  }\n  static from(event) {\n    return new _NDKDraft(event.ndk, event);\n  }\n  /**\n   * Sets an identifier (i.e. d-tag)\n   */\n  set identifier(id) {\n    this.removeTag(\"d\");\n    this.tags.push([\"d\", id]);\n  }\n  get identifier() {\n    return this.dTag;\n  }\n  /**\n   * Event that is to be saved.\n   */\n  set event(e) {\n    if (e instanceof NDKEvent) this._event = e.rawEvent();\n    else this._event = e;\n    this.prepareEvent();\n  }\n  /**\n   * Gets the event.\n   * @param param0\n   * @returns NDKEvent of the draft event or null if the draft event has been deleted (emptied).\n   */\n  async getEvent(signer) {\n    if (this._event) return new NDKEvent(this.ndk, this._event);\n    signer ??= this.ndk?.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    if (this.content && this.content.length > 0) {\n      try {\n        await this.decrypt(user, signer);\n        const payload = JSON.parse(this.content);\n        this._event = payload;\n        return new NDKEvent(this.ndk, payload);\n      } catch (e) {\n        console.error(e);\n        return void 0;\n      }\n    } else {\n      return null;\n    }\n  }\n  prepareEvent() {\n    if (!this._event) throw new Error(\"No event has been provided\");\n    this.removeTag(\"k\");\n    if (this._event.kind) this.tags.push([\"k\", this._event.kind.toString()]);\n    this.content = JSON.stringify(this._event);\n  }\n  /**\n   * Generates draft event.\n   *\n   * @param signer: Optional signer to encrypt with\n   * @param publish: Whether to publish, optionally specifying relaySet to publish to\n   */\n  async save({ signer, publish, relaySet }) {\n    signer ??= this.ndk?.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    await this.encrypt(user, signer);\n    if (publish === false) return;\n    return this.publish(relaySet);\n  }\n};\n\n// src/events/kinds/dvm/feedback.ts\nvar NDKDvmJobFeedbackStatus = /* @__PURE__ */ ((NDKDvmJobFeedbackStatus2) => {\n  NDKDvmJobFeedbackStatus2[\"Processing\"] = \"processing\";\n  NDKDvmJobFeedbackStatus2[\"Success\"] = \"success\";\n  NDKDvmJobFeedbackStatus2[\"Scheduled\"] = \"scheduled\";\n  NDKDvmJobFeedbackStatus2[\"PayReq\"] = \"payment_required\";\n  return NDKDvmJobFeedbackStatus2;\n})(NDKDvmJobFeedbackStatus || {});\nvar NDKDVMJobFeedback = class _NDKDVMJobFeedback extends NDKEvent {\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7e3 /* DVMJobFeedback */;\n  }\n  static async from(event) {\n    const e = new _NDKDVMJobFeedback(event.ndk, event.rawEvent());\n    if (e.encrypted) await e.dvmDecrypt();\n    return e;\n  }\n  get status() {\n    return this.tagValue(\"status\");\n  }\n  set status(status) {\n    this.removeTag(\"status\");\n    if (status !== void 0) {\n      this.tags.push([\"status\", status]);\n    }\n  }\n  get encrypted() {\n    return !!this.getMatchingTags(\"encrypted\")[0];\n  }\n  async dvmDecrypt() {\n    await this.decrypt();\n    const decryptedContent = JSON.parse(this.content);\n    this.tags.push(...decryptedContent);\n  }\n};\n\n// src/events/kinds/dvm/request.ts\nvar NDKDVMRequest = class _NDKDVMRequest extends NDKEvent {\n  static from(event) {\n    return new _NDKDVMRequest(event.ndk, event.rawEvent());\n  }\n  set bid(msatAmount) {\n    if (msatAmount === void 0) {\n      this.removeTag(\"bid\");\n    } else {\n      this.tags.push([\"bid\", msatAmount.toString()]);\n    }\n  }\n  get bid() {\n    const v = this.tagValue(\"bid\");\n    if (v === void 0) return void 0;\n    return Number.parseInt(v);\n  }\n  /**\n   * Adds a new input to the job\n   * @param args The arguments to the input\n   */\n  addInput(...args) {\n    this.tags.push([\"i\", ...args]);\n  }\n  /**\n   * Adds a new parameter to the job\n   */\n  addParam(...args) {\n    this.tags.push([\"param\", ...args]);\n  }\n  set output(output) {\n    if (output === void 0) {\n      this.removeTag(\"output\");\n    } else {\n      if (typeof output === \"string\") output = [output];\n      this.tags.push([\"output\", ...output]);\n    }\n  }\n  get output() {\n    const outputTag = this.getMatchingTags(\"output\")[0];\n    return outputTag ? outputTag.slice(1) : void 0;\n  }\n  get params() {\n    const paramTags = this.getMatchingTags(\"param\");\n    return paramTags.map((t) => t.slice(1));\n  }\n  getParam(name) {\n    const paramTag = this.getMatchingTags(\"param\").find((t) => t[1] === name);\n    return paramTag ? paramTag[2] : void 0;\n  }\n  createFeedback(status) {\n    const feedback = new NDKDVMJobFeedback(this.ndk);\n    feedback.tag(this, \"job\");\n    feedback.status = status;\n    return feedback;\n  }\n  /**\n   * Enables job encryption for this event\n   * @param dvm DVM that will receive the event\n   * @param signer Signer to use for encryption\n   */\n  async encryption(dvm, signer) {\n    const dvmTags = [\"i\", \"param\", \"output\", \"relays\", \"bid\"];\n    const tags = this.tags.filter((t) => dvmTags.includes(t[0]));\n    this.tags = this.tags.filter((t) => !dvmTags.includes(t[0]));\n    this.content = JSON.stringify(tags);\n    this.tag(dvm);\n    this.tags.push([\"encrypted\"]);\n    await this.encrypt(dvm, signer);\n  }\n  /**\n   * Sets the DVM that will receive the event\n   */\n  set dvm(dvm) {\n    this.removeTag(\"p\");\n    if (dvm) this.tag(dvm);\n  }\n};\n\n// src/events/kinds/dvm/NDKTranscriptionDVM.ts\nvar NDKTranscriptionDVM = class _NDKTranscriptionDVM extends NDKDVMRequest {\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind = 5e3 /* DVMReqTextExtraction */;\n  }\n  static from(event) {\n    return new _NDKTranscriptionDVM(event.ndk, event.rawEvent());\n  }\n  /**\n   * Returns the original source of the transcription\n   */\n  get url() {\n    const inputTags = this.getMatchingTags(\"i\");\n    if (inputTags.length !== 1) {\n      return void 0;\n    }\n    return inputTags[0][1];\n  }\n  /**\n   * Getter for the title tag\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the title tag\n   */\n  set title(value) {\n    this.removeTag(\"title\");\n    if (value) {\n      this.tags.push([\"title\", value]);\n    }\n  }\n  /**\n   * Getter for the image tag\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Setter for the image tag\n   */\n  set image(value) {\n    this.removeTag(\"image\");\n    if (value) {\n      this.tags.push([\"image\", value]);\n    }\n  }\n};\n\n// src/events/kinds/dvm/result.ts\nvar NDKDVMJobResult = class _NDKDVMJobResult extends NDKEvent {\n  static from(event) {\n    return new _NDKDVMJobResult(event.ndk, event.rawEvent());\n  }\n  setAmount(msat, invoice) {\n    this.removeTag(\"amount\");\n    const tag = [\"amount\", msat.toString()];\n    if (invoice) tag.push(invoice);\n    this.tags.push(tag);\n  }\n  set result(result) {\n    if (result === void 0) {\n      this.content = \"\";\n    } else {\n      this.content = result;\n    }\n  }\n  get result() {\n    if (this.content === \"\") {\n      return void 0;\n    }\n    return this.content;\n  }\n  set status(status) {\n    this.removeTag(\"status\");\n    if (status !== void 0) {\n      this.tags.push([\"status\", status]);\n    }\n  }\n  get status() {\n    return this.tagValue(\"status\");\n  }\n  get jobRequestId() {\n    for (const eTag of this.getMatchingTags(\"e\")) {\n      if (eTag[2] === \"job\") return eTag[1];\n    }\n    if (this.jobRequest) return this.jobRequest.id;\n    return this.tagValue(\"e\");\n  }\n  set jobRequest(event) {\n    this.removeTag(\"request\");\n    if (event) {\n      this.kind = event.kind + 1e3;\n      this.tags.push([\"request\", JSON.stringify(event.rawEvent())]);\n      this.tag(event);\n    }\n  }\n  get jobRequest() {\n    const tag = this.tagValue(\"request\");\n    if (tag === void 0) {\n      return void 0;\n    }\n    return new NDKEvent(this.ndk, JSON.parse(tag));\n  }\n};\n\n// src/events/kinds/cashu/tx.ts\nvar MARKERS = {\n  REDEEMED: \"redeemed\",\n  CREATED: \"created\",\n  DESTROYED: \"destroyed\",\n  RESERVED: \"reserved\"\n};\nvar NDKCashuWalletTx = class _NDKCashuWalletTx extends NDKEvent {\n  static MARKERS = MARKERS;\n  static kind = 7376 /* CashuWalletTx */;\n  static kinds = [7376 /* CashuWalletTx */];\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7376 /* CashuWalletTx */;\n  }\n  static async from(event) {\n    const walletChange = new _NDKCashuWalletTx(event.ndk, event);\n    const prevContent = walletChange.content;\n    try {\n      await walletChange.decrypt();\n    } catch (_e) {\n      walletChange.content ??= prevContent;\n    }\n    try {\n      const contentTags = JSON.parse(walletChange.content);\n      walletChange.tags = [...contentTags, ...walletChange.tags];\n    } catch (_e) {\n      return;\n    }\n    return walletChange;\n  }\n  set direction(direction) {\n    this.removeTag(\"direction\");\n    if (direction) this.tags.push([\"direction\", direction]);\n  }\n  get direction() {\n    return this.tagValue(\"direction\");\n  }\n  set amount(amount) {\n    this.removeTag(\"amount\");\n    this.tags.push([\"amount\", amount.toString()]);\n  }\n  get amount() {\n    const val = this.tagValue(\"amount\");\n    if (val === void 0) return void 0;\n    return Number(val);\n  }\n  set fee(fee) {\n    this.removeTag(\"fee\");\n    this.tags.push([\"fee\", fee.toString()]);\n  }\n  get fee() {\n    const val = this.tagValue(\"fee\");\n    if (val === void 0) return void 0;\n    return Number(val);\n  }\n  set unit(unit) {\n    this.removeTag(\"unit\");\n    if (unit) this.tags.push([\"unit\", unit.toString()]);\n  }\n  get unit() {\n    return this.tagValue(\"unit\");\n  }\n  set description(description) {\n    this.removeTag(\"description\");\n    if (description) this.tags.push([\"description\", description.toString()]);\n  }\n  get description() {\n    return this.tagValue(\"description\");\n  }\n  set mint(mint) {\n    this.removeTag(\"mint\");\n    if (mint) this.tags.push([\"mint\", mint.toString()]);\n  }\n  get mint() {\n    return this.tagValue(\"mint\");\n  }\n  /**\n   * Tags tokens that were created in this history event\n   */\n  set destroyedTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.DESTROYED));\n    }\n  }\n  set destroyedTokenIds(ids) {\n    for (const id of ids) {\n      this.tags.push([\"e\", id, \"\", MARKERS.DESTROYED]);\n    }\n  }\n  /**\n   * Tags tokens that were created in this history event\n   */\n  set createdTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.CREATED));\n    }\n  }\n  set reservedTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.RESERVED));\n    }\n  }\n  addRedeemedNutzap(event) {\n    this.tag(event, MARKERS.REDEEMED);\n  }\n  async toNostrEvent(pubkey) {\n    const encryptedTags = [];\n    const unencryptedTags = [];\n    for (const tag of this.tags) {\n      if (!this.shouldEncryptTag(tag)) {\n        unencryptedTags.push(tag);\n      } else {\n        encryptedTags.push(tag);\n      }\n    }\n    this.tags = unencryptedTags.filter((t) => t[0] !== \"client\");\n    this.content = JSON.stringify(encryptedTags);\n    const user = await this.ndk?.signer?.user();\n    await this.encrypt(user, void 0, \"nip44\");\n    return super.toNostrEvent(pubkey);\n  }\n  /**\n   * Whether this entry includes a redemption of a Nutzap\n   */\n  get hasNutzapRedemption() {\n    return this.getMatchingTags(\"e\", MARKERS.REDEEMED).length > 0;\n  }\n  shouldEncryptTag(tag) {\n    const unencryptedTagNames = [\"client\"];\n    if (unencryptedTagNames.includes(tag[0])) {\n      return false;\n    }\n    if (tag[0] === \"e\" && tag[3] === MARKERS.REDEEMED) {\n      return false;\n    }\n    if (tag[0] === \"p\") return false;\n    return true;\n  }\n};\n\n// src/events/kinds/NDKRelayList.ts\nvar READ_MARKER = \"read\";\nvar WRITE_MARKER = \"write\";\nvar NDKRelayList = class _NDKRelayList extends NDKEvent {\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 10002 /* RelayList */;\n  }\n  static from(ndkEvent) {\n    return new _NDKRelayList(ndkEvent.ndk, ndkEvent.rawEvent());\n  }\n  get readRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2] || tag[2] && tag[2] === READ_MARKER).map((tag) => tryNormalizeRelayUrl(tag[1])).filter((url) => !!url);\n  }\n  set readRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay, READ_MARKER]);\n    }\n  }\n  get writeRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2] || tag[2] && tag[2] === WRITE_MARKER).map((tag) => tryNormalizeRelayUrl(tag[1])).filter((url) => !!url);\n  }\n  set writeRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay, WRITE_MARKER]);\n    }\n  }\n  get bothRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2]).map((tag) => tag[1]);\n  }\n  set bothRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay]);\n    }\n  }\n  get relays() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").map((tag) => tag[1]);\n  }\n  /**\n   * Provides a relaySet for the relays in this list.\n   */\n  get relaySet() {\n    if (!this.ndk) throw new Error(\"NDKRelayList has no NDK instance\");\n    return new NDKRelaySet(\n      new Set(this.relays.map((u) => this.ndk?.pool.getRelay(u)).filter((r) => !!r)),\n      this.ndk\n    );\n  }\n};\nfunction relayListFromKind3(ndk, contactList) {\n  try {\n    const content = JSON.parse(contactList.content);\n    const relayList = new NDKRelayList(ndk);\n    const readRelays = /* @__PURE__ */ new Set();\n    const writeRelays = /* @__PURE__ */ new Set();\n    for (let [key, config] of Object.entries(content)) {\n      try {\n        key = normalizeRelayUrl(key);\n      } catch {\n        continue;\n      }\n      if (!config) {\n        readRelays.add(key);\n        writeRelays.add(key);\n      } else {\n        const relayConfig = config;\n        if (relayConfig.write) writeRelays.add(key);\n        if (relayConfig.read) readRelays.add(key);\n      }\n    }\n    relayList.readRelayUrls = Array.from(readRelays);\n    relayList.writeRelayUrls = Array.from(writeRelays);\n    return relayList;\n  } catch {\n  }\n  return void 0;\n}\n\n// src/events/kinds/nip89/app-handler.ts\nvar NDKAppHandlerEvent = class _NDKAppHandlerEvent extends NDKEvent {\n  profile;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 31990 /* AppHandler */;\n  }\n  static from(ndkEvent) {\n    const event = new _NDKAppHandlerEvent(ndkEvent.ndk, ndkEvent.rawEvent());\n    if (event.isValid) {\n      return event;\n    }\n    return null;\n  }\n  get isValid() {\n    const combinations = /* @__PURE__ */ new Map();\n    const combinationFromTag = (tag) => [tag[0], tag[2]].join(\":\").toLowerCase();\n    const tagsToInspect = [\"web\", \"android\", \"ios\"];\n    for (const tag of this.tags) {\n      if (tagsToInspect.includes(tag[0])) {\n        const combination = combinationFromTag(tag);\n        if (combinations.has(combination)) {\n          if (combinations.get(combination) !== tag[1].toLowerCase()) {\n            return false;\n          }\n        }\n        combinations.set(combination, tag[1].toLowerCase());\n      }\n    }\n    return true;\n  }\n  /**\n   * Fetches app handler information\n   * If no app information is available on the kind:31990,\n   * we fetch the event's author's profile and return that instead.\n   */\n  async fetchProfile() {\n    if (this.profile === void 0 && this.content.length > 0) {\n      try {\n        const profile = JSON.parse(this.content);\n        if (profile?.name) {\n          return profile;\n        }\n        this.profile = null;\n      } catch (_e) {\n        this.profile = null;\n      }\n    }\n    return new Promise((resolve, reject) => {\n      const author = this.author;\n      author.fetchProfile().then(() => {\n        resolve(author.profile);\n      }).catch(reject);\n    });\n  }\n};\n\n// src/events/kinds/repost.ts\nvar NDKRepost = class _NDKRepost extends NDKEvent {\n  _repostedEvents;\n  static from(event) {\n    return new _NDKRepost(event.ndk, event.rawEvent());\n  }\n  /**\n   * Returns all reposted events by the current event.\n   *\n   * @param klass Optional class to convert the events to.\n   * @returns\n   */\n  async repostedEvents(klass, opts) {\n    const items = [];\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (this._repostedEvents !== void 0) return this._repostedEvents;\n    for (const eventId of this.repostedEventIds()) {\n      const filter = filterForId(eventId);\n      const event = await this.ndk.fetchEvent(filter, opts);\n      if (event) {\n        items.push(klass ? klass.from(event) : event);\n      }\n    }\n    return items;\n  }\n  /**\n   * Returns the reposted event IDs.\n   */\n  repostedEventIds() {\n    return this.tags.filter((t) => t[0] === \"e\" || t[0] === \"a\").map((t) => t[1]);\n  }\n};\nfunction filterForId(id) {\n  if (id.match(/:/)) {\n    const [kind, pubkey, identifier] = id.split(\":\");\n    return {\n      kinds: [Number.parseInt(kind)],\n      authors: [pubkey],\n      \"#d\": [identifier]\n    };\n  }\n  return { ids: [id] };\n}\n\n// src/events/kinds/subscriptions/receipt.ts\n\nvar NDKSubscriptionReceipt = class _NDKSubscriptionReceipt extends NDKEvent {\n  debug;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 7003 /* SubscriptionReceipt */;\n    this.debug = ndk?.debug.extend(\"subscription-start\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:subscription-start\");\n  }\n  static from(event) {\n    return new _NDKSubscriptionReceipt(event.ndk, event.rawEvent());\n  }\n  /**\n   * This is the person being subscribed to\n   */\n  get recipient() {\n    const pTag = this.getMatchingTags(\"p\")?.[0];\n    if (!pTag) return void 0;\n    const user = new NDKUser({ pubkey: pTag[1] });\n    return user;\n  }\n  set recipient(user) {\n    this.removeTag(\"p\");\n    if (!user) return;\n    this.tags.push([\"p\", user.pubkey]);\n  }\n  /**\n   * This is the person subscribing\n   */\n  get subscriber() {\n    const PTag = this.getMatchingTags(\"P\")?.[0];\n    if (!PTag) return void 0;\n    const user = new NDKUser({ pubkey: PTag[1] });\n    return user;\n  }\n  set subscriber(user) {\n    this.removeTag(\"P\");\n    if (!user) return;\n    this.tags.push([\"P\", user.pubkey]);\n  }\n  set subscriptionStart(event) {\n    this.debug(`before setting subscription start: ${this.rawEvent}`);\n    this.removeTag(\"e\");\n    this.tag(event, \"subscription\", true);\n    this.debug(`after setting subscription start: ${this.rawEvent}`);\n  }\n  get tierName() {\n    const tag = this.getMatchingTags(\"tier\")?.[0];\n    return tag?.[1];\n  }\n  get isValid() {\n    const period = this.validPeriod;\n    if (!period) {\n      return false;\n    }\n    if (period.start > period.end) {\n      return false;\n    }\n    const pTags = this.getMatchingTags(\"p\");\n    const PTags = this.getMatchingTags(\"P\");\n    if (pTags.length !== 1 || PTags.length !== 1) {\n      return false;\n    }\n    return true;\n  }\n  get validPeriod() {\n    const tag = this.getMatchingTags(\"valid\")?.[0];\n    if (!tag) return void 0;\n    try {\n      return {\n        start: new Date(Number.parseInt(tag[1]) * 1e3),\n        end: new Date(Number.parseInt(tag[2]) * 1e3)\n      };\n    } catch {\n      return void 0;\n    }\n  }\n  set validPeriod(period) {\n    this.removeTag(\"valid\");\n    if (!period) return;\n    this.tags.push([\n      \"valid\",\n      Math.floor(period.start.getTime() / 1e3).toString(),\n      Math.floor(period.end.getTime() / 1e3).toString()\n    ]);\n  }\n  get startPeriod() {\n    return this.validPeriod?.start;\n  }\n  get endPeriod() {\n    return this.validPeriod?.end;\n  }\n  /**\n   * Whether the subscription is currently active\n   */\n  isActive(time) {\n    time ??= /* @__PURE__ */ new Date();\n    const period = this.validPeriod;\n    if (!period) return false;\n    if (time < period.start) return false;\n    if (time > period.end) return false;\n    return true;\n  }\n};\n\n// src/events/kinds/subscriptions/subscription-start.ts\n\nvar NDKSubscriptionStart = class _NDKSubscriptionStart extends NDKEvent {\n  debug;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 7001 /* Subscribe */;\n    this.debug = ndk?.debug.extend(\"subscription-start\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:subscription-start\");\n  }\n  static from(event) {\n    return new _NDKSubscriptionStart(event.ndk, event.rawEvent());\n  }\n  /**\n   * Recipient of the subscription. I.e. The author of this event subscribes to this user.\n   */\n  get recipient() {\n    const pTag = this.getMatchingTags(\"p\")?.[0];\n    if (!pTag) return void 0;\n    const user = new NDKUser({ pubkey: pTag[1] });\n    return user;\n  }\n  set recipient(user) {\n    this.removeTag(\"p\");\n    if (!user) return;\n    this.tags.push([\"p\", user.pubkey]);\n  }\n  /**\n   * The amount of the subscription.\n   */\n  get amount() {\n    const amountTag = this.getMatchingTags(\"amount\")?.[0];\n    if (!amountTag) return void 0;\n    return parseTagToSubscriptionAmount(amountTag);\n  }\n  set amount(amount) {\n    this.removeTag(\"amount\");\n    if (!amount) return;\n    this.tags.push(newAmount(amount.amount, amount.currency, amount.term));\n  }\n  /**\n   * The event id or NIP-33 tag id of the tier that the user is subscribing to.\n   */\n  get tierId() {\n    const eTag = this.getMatchingTags(\"e\")?.[0];\n    const aTag = this.getMatchingTags(\"a\")?.[0];\n    if (!eTag || !aTag) return void 0;\n    return eTag[1] ?? aTag[1];\n  }\n  set tier(tier) {\n    this.removeTag(\"e\");\n    this.removeTag(\"a\");\n    this.removeTag(\"event\");\n    if (!tier) return;\n    this.tag(tier);\n    this.removeTag(\"p\");\n    this.tags.push([\"p\", tier.pubkey]);\n    this.tags.push([\"event\", JSON.stringify(tier.rawEvent())]);\n  }\n  /**\n   * Fetches the tier that the user is subscribing to.\n   */\n  async fetchTier() {\n    const eventTag = this.tagValue(\"event\");\n    if (eventTag) {\n      try {\n        const parsedEvent = JSON.parse(eventTag);\n        return new NDKSubscriptionTier(this.ndk, parsedEvent);\n      } catch {\n        this.debug(\"Failed to parse event tag\");\n      }\n    }\n    const tierId = this.tierId;\n    if (!tierId) return void 0;\n    const e = await this.ndk?.fetchEvent(tierId);\n    if (!e) return void 0;\n    return NDKSubscriptionTier.from(e);\n  }\n  get isValid() {\n    if (this.getMatchingTags(\"amount\").length !== 1) {\n      this.debug(\"Invalid # of amount tag\");\n      return false;\n    }\n    if (!this.amount) {\n      this.debug(\"Invalid amount tag\");\n      return false;\n    }\n    if (this.getMatchingTags(\"p\").length !== 1) {\n      this.debug(\"Invalid # of p tag\");\n      return false;\n    }\n    if (!this.recipient) {\n      this.debug(\"Invalid p tag\");\n      return false;\n    }\n    return true;\n  }\n};\n\n// src/events/gift-wrapping.ts\n\n\n// src/signers/private-key/index.ts\n\n\n\nvar NDKPrivateKeySigner = class _NDKPrivateKeySigner {\n  _user;\n  _privateKey;\n  _pubkey;\n  /**\n   * Create a new signer from a private key.\n   * @param privateKey - The private key to use in hex form or nsec.\n   * @param ndk - The NDK instance to use.\n   */\n  constructor(privateKeyOrNsec, ndk) {\n    if (typeof privateKeyOrNsec === \"string\") {\n      if (privateKeyOrNsec.startsWith(\"nsec1\")) {\n        const { type, data } = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(privateKeyOrNsec);\n        if (type === \"nsec\") this._privateKey = data;\n        else throw new Error(\"Invalid private key provided.\");\n      } else if (privateKeyOrNsec.length === 64) {\n        this._privateKey = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(privateKeyOrNsec);\n      } else {\n        throw new Error(\"Invalid private key provided.\");\n      }\n    } else {\n      this._privateKey = privateKeyOrNsec;\n    }\n    this._pubkey = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.getPublicKey)(this._privateKey);\n    if (ndk) this._user = ndk.getUser({ pubkey: this._pubkey });\n    this._user ??= new NDKUser({ pubkey: this._pubkey });\n  }\n  /**\n   * Get the private key in hex form.\n   */\n  get privateKey() {\n    if (!this._privateKey) throw new Error(\"Not ready\");\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(this._privateKey);\n  }\n  /**\n   * Get the public key in hex form.\n   */\n  get pubkey() {\n    if (!this._pubkey) throw new Error(\"Not ready\");\n    return this._pubkey;\n  }\n  /**\n   * Get the private key in nsec form.\n   */\n  get nsec() {\n    if (!this._privateKey) throw new Error(\"Not ready\");\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.nsecEncode(this._privateKey);\n  }\n  /**\n   * Get the public key in npub form.\n   */\n  get npub() {\n    if (!this._pubkey) throw new Error(\"Not ready\");\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.npubEncode(this._pubkey);\n  }\n  /**\n   * Generate a new private key.\n   */\n  static generate() {\n    const privateKey = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.generateSecretKey)();\n    return new _NDKPrivateKeySigner(privateKey);\n  }\n  /**\n   * Noop in NDKPrivateKeySigner.\n   */\n  async blockUntilReady() {\n    return this._user;\n  }\n  /**\n   * Get the user.\n   */\n  async user() {\n    return this._user;\n  }\n  /**\n   * Get the user.\n   */\n  get userSync() {\n    return this._user;\n  }\n  async sign(event) {\n    if (!this._privateKey) {\n      throw Error(\"Attempted to sign without a private key\");\n    }\n    return (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(event, this._privateKey).sig;\n  }\n  async encryptionEnabled(scheme) {\n    const enabled = [];\n    if (!scheme || scheme === \"nip04\") enabled.push(\"nip04\");\n    if (!scheme || scheme === \"nip44\") enabled.push(\"nip44\");\n    return enabled;\n  }\n  async encrypt(recipient, value, scheme) {\n    if (!this._privateKey || !this.privateKey) {\n      throw Error(\"Attempted to encrypt without a private key\");\n    }\n    const recipientHexPubKey = recipient.pubkey;\n    if (scheme === \"nip44\") {\n      const conversationKey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.utils.getConversationKey(this._privateKey, recipientHexPubKey);\n      return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.encrypt(value, conversationKey);\n    }\n    return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip04.encrypt(this._privateKey, recipientHexPubKey, value);\n  }\n  async decrypt(sender, value, scheme) {\n    if (!this._privateKey || !this.privateKey) {\n      throw Error(\"Attempted to decrypt without a private key\");\n    }\n    const senderHexPubKey = sender.pubkey;\n    if (scheme === \"nip44\") {\n      const conversationKey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.utils.getConversationKey(this._privateKey, senderHexPubKey);\n      return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.decrypt(value, conversationKey);\n    }\n    return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip04.decrypt(this._privateKey, senderHexPubKey, value);\n  }\n  /**\n   * Serializes the signer's private key into a storable format.\n   * @returns A JSON string containing the type and the hex private key.\n   */\n  toPayload() {\n    if (!this._privateKey) throw new Error(\"Private key not available\");\n    const payload = {\n      type: \"private-key\",\n      payload: this.privateKey\n      // Use the hex private key\n    };\n    return JSON.stringify(payload);\n  }\n  /**\n   * Deserializes the signer from a payload string.\n   * @param payloadString The JSON string obtained from toPayload().\n   * @param ndk Optional NDK instance.\n   * @returns An instance of NDKPrivateKeySigner.\n   */\n  static async fromPayload(payloadString, ndk) {\n    const payload = JSON.parse(payloadString);\n    if (payload.type !== \"private-key\") {\n      throw new Error(`Invalid payload type: expected 'private-key', got ${payload.type}`);\n    }\n    if (!payload.payload || typeof payload.payload !== \"string\") {\n      throw new Error(\"Invalid payload content for private-key signer\");\n    }\n    return new _NDKPrivateKeySigner(payload.payload, ndk);\n  }\n};\n\n// src/events/gift-wrapping.ts\nasync function giftWrap(event, recipient, signer, params = {}) {\n  let _signer = signer;\n  params.scheme ??= \"nip44\";\n  if (!_signer) {\n    if (!event.ndk) throw new Error(\"no signer available for giftWrap\");\n    _signer = event.ndk.signer;\n  }\n  if (!_signer) throw new Error(\"no signer\");\n  if (!_signer.encryptionEnabled || !_signer.encryptionEnabled(params.scheme))\n    throw new Error(\"signer is not able to giftWrap\");\n  const rumor = getRumorEvent(event, params?.rumorKind);\n  const seal = await getSealEvent(rumor, recipient, _signer, params.scheme);\n  const wrap = await getWrapEvent(seal, recipient, params);\n  return new NDKEvent(event.ndk, wrap);\n}\nasync function giftUnwrap(event, sender, signer, scheme = \"nip44\") {\n  const _sender = sender || new NDKUser({ pubkey: event.pubkey });\n  let _signer = signer;\n  if (!_signer) {\n    if (!event.ndk) throw new Error(\"no signer available for giftUnwrap\");\n    _signer = event.ndk.signer;\n  }\n  if (!signer) throw new Error(\"no signer\");\n  try {\n    const seal = JSON.parse(await signer.decrypt(_sender, event.content, scheme));\n    if (!seal) throw new Error(\"Failed to decrypt wrapper\");\n    if (!new NDKEvent(void 0, seal).verifySignature(false))\n      throw new Error(\"GiftSeal signature verification failed!\");\n    const rumorSender = new NDKUser({ pubkey: seal.pubkey });\n    const rumor = JSON.parse(await signer.decrypt(rumorSender, seal.content, scheme));\n    if (!rumor) throw new Error(\"Failed to decrypt seal\");\n    if (rumor.pubkey !== seal.pubkey) throw new Error(\"Invalid GiftWrap, sender validation failed!\");\n    return new NDKEvent(event.ndk, rumor);\n  } catch (_e) {\n    return Promise.reject(\"Got error unwrapping event! See console log.\");\n  }\n}\nfunction getRumorEvent(event, kind) {\n  const rumor = event.rawEvent();\n  rumor.kind = kind || rumor.kind || 14 /* PrivateDirectMessage */;\n  rumor.sig = void 0;\n  rumor.id = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.getEventHash)(rumor);\n  return new NDKEvent(event.ndk, rumor);\n}\nasync function getSealEvent(rumor, recipient, signer, scheme = \"nip44\") {\n  const seal = new NDKEvent(rumor.ndk);\n  seal.kind = 13 /* GiftWrapSeal */;\n  seal.created_at = approximateNow(5);\n  seal.content = JSON.stringify(rumor.rawEvent());\n  await seal.encrypt(recipient, signer, scheme);\n  await seal.sign(signer);\n  return seal;\n}\nasync function getWrapEvent(sealed, recipient, params, scheme = \"nip44\") {\n  const signer = NDKPrivateKeySigner.generate();\n  const wrap = new NDKEvent(sealed.ndk);\n  wrap.kind = 1059 /* GiftWrap */;\n  wrap.created_at = approximateNow(5);\n  if (params?.wrapTags) wrap.tags = params.wrapTags;\n  wrap.tag(recipient);\n  wrap.content = JSON.stringify(sealed.rawEvent());\n  await wrap.encrypt(recipient, signer, scheme);\n  await wrap.sign(signer);\n  return wrap;\n}\nfunction approximateNow(drift = 0) {\n  return Math.round(Date.now() / 1e3 - Math.random() * 10 ** drift);\n}\n\n// src/events/kinds/simple-group/index.ts\nvar NDKSimpleGroup = class _NDKSimpleGroup {\n  ndk;\n  groupId;\n  relaySet;\n  fetchingMetadata;\n  metadata;\n  memberList;\n  adminList;\n  constructor(ndk, relaySet, groupId) {\n    this.ndk = ndk;\n    this.groupId = groupId ?? randomId(24);\n    this.relaySet = relaySet;\n  }\n  get id() {\n    return this.groupId;\n  }\n  relayUrls() {\n    return this.relaySet?.relayUrls;\n  }\n  get name() {\n    return this.metadata?.name;\n  }\n  get about() {\n    return this.metadata?.about;\n  }\n  get picture() {\n    return this.metadata?.picture;\n  }\n  get members() {\n    return this.memberList?.members ?? [];\n  }\n  get admins() {\n    return this.adminList?.members ?? [];\n  }\n  async getMetadata() {\n    await this.ensureMetadataEvent();\n    return this.metadata;\n  }\n  /**\n   * Creates the group by publishing a kind:9007 event.\n   * @param signer\n   * @returns\n   */\n  async createGroup(signer) {\n    signer ??= this.ndk.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    if (!user) throw new Error(\"No user available\");\n    const event = new NDKEvent(this.ndk);\n    event.kind = 9007 /* GroupAdminCreateGroup */;\n    event.tags.push([\"h\", this.groupId]);\n    await event.sign(signer);\n    return event.publish(this.relaySet);\n  }\n  async setMetadata({ name, about, picture }) {\n    const event = new NDKEvent(this.ndk);\n    event.kind = 9002 /* GroupAdminEditMetadata */;\n    event.tags.push([\"h\", this.groupId]);\n    if (name) event.tags.push([\"name\", name]);\n    if (about) event.tags.push([\"about\", about]);\n    if (picture) event.tags.push([\"picture\", picture]);\n    await event.sign();\n    return event.publish(this.relaySet);\n  }\n  /**\n   * Adds a user to the group using a kind:9000 event\n   * @param user user to add\n   * @param opts options\n   */\n  async addUser(user) {\n    const addUserEvent = _NDKSimpleGroup.generateAddUserEvent(user.pubkey, this.groupId);\n    addUserEvent.ndk = this.ndk;\n    return addUserEvent;\n  }\n  async getMemberListEvent() {\n    const memberList = await this.ndk.fetchEvent(\n      {\n        kinds: [39002 /* GroupMembers */],\n        \"#d\": [this.groupId]\n      },\n      void 0,\n      this.relaySet\n    );\n    if (!memberList) return null;\n    return NDKSimpleGroupMemberList.from(memberList);\n  }\n  /**\n   * Gets a list of users that belong to this group\n   */\n  async getMembers() {\n    const members = [];\n    const memberPubkeys = /* @__PURE__ */ new Set();\n    const memberListEvent = await this.getMemberListEvent();\n    if (!memberListEvent) return [];\n    for (const pTag of memberListEvent.getMatchingTags(\"p\")) {\n      const pubkey = pTag[1];\n      if (memberPubkeys.has(pubkey)) continue;\n      memberPubkeys.add(pubkey);\n      try {\n        members.push(this.ndk.getUser({ pubkey }));\n      } catch {\n      }\n    }\n    return members;\n  }\n  /**\n   * Generates an event that lists the members of a group.\n   * @param groupId\n   * @returns\n   */\n  static generateUserListEvent(groupId) {\n    const event = new NDKEvent(void 0, {\n      kind: 39002 /* GroupMembers */,\n      tags: [\n        [\"h\", groupId],\n        [\"alt\", \"Group Member List\"]\n      ]\n    });\n    return event;\n  }\n  /**\n   * Generates an event that adds a user to a group.\n   * @param userPubkey pubkey of the user to add\n   * @param groupId group to add the user to\n   * @returns\n   */\n  static generateAddUserEvent(userPubkey, groupId) {\n    const event = new NDKEvent(void 0, {\n      kind: 9e3 /* GroupAdminAddUser */,\n      tags: [[\"h\", groupId]]\n    });\n    event.tags.push([\"p\", userPubkey]);\n    return event;\n  }\n  async requestToJoin(_pubkey, content) {\n    const event = new NDKEvent(this.ndk, {\n      kind: 9021 /* GroupAdminRequestJoin */,\n      content: content ?? \"\",\n      tags: [[\"h\", this.groupId]]\n    });\n    return event.publish(this.relaySet);\n  }\n  /**\n   * Makes sure that a metadata event exists locally\n   */\n  async ensureMetadataEvent() {\n    if (this.metadata) return;\n    if (this.fetchingMetadata) return this.fetchingMetadata;\n    this.fetchingMetadata = this.ndk.fetchEvent(\n      {\n        kinds: [39e3 /* GroupMetadata */],\n        \"#d\": [this.groupId]\n      },\n      void 0,\n      this.relaySet\n    ).then((event) => {\n      if (event) {\n        this.metadata = NDKSimpleGroupMetadata.from(event);\n      } else {\n        this.metadata = new NDKSimpleGroupMetadata(this.ndk);\n        this.metadata.dTag = this.groupId;\n      }\n    }).finally(() => {\n      this.fetchingMetadata = void 0;\n    }).catch(() => {\n      throw new Error(`Failed to fetch metadata for group ${this.groupId}`);\n    });\n    return this.fetchingMetadata;\n  }\n};\nfunction randomId(length) {\n  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  const charsLength = chars.length;\n  let result = \"\";\n  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * charsLength));\n  }\n  return result;\n}\n\n// src/app-settings/index.ts\nvar NDKAppSettings = class _NDKAppSettings extends NDKEvent {\n  appName;\n  settings = {};\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30078 /* AppSpecificData */;\n    this.dTag ??= this.appName;\n    if (this.content.length > 0) {\n      try {\n        this.settings = JSON.parse(this.content);\n      } catch (error) {\n        console.error(\"Error parsing app settings\", error);\n      }\n    }\n  }\n  static from(event) {\n    return new _NDKAppSettings(event.ndk, event);\n  }\n  /**\n   * Set a value for a given key.\n   *\n   * @param key\n   * @param value\n   */\n  set(key, value) {\n    this.settings[key] = value;\n  }\n  /**\n   * Get a value for a given key.\n   *\n   * @param key\n   * @returns\n   */\n  get(key) {\n    return this.settings[key];\n  }\n  async publishReplaceable(relaySet, timeoutMs, requiredRelayCount) {\n    this.content = JSON.stringify(this.settings);\n    return super.publishReplaceable(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/relay/auth-policies.ts\n\nfunction disconnect(pool, debug8) {\n  debug8 ??= debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:relay:auth-policies:disconnect\");\n  return async (relay) => {\n    debug8?.(`Relay ${relay.url} requested authentication, disconnecting`);\n    pool.removeRelay(relay.url);\n  };\n}\nasync function signAndAuth(event, relay, signer, debug8, resolve, reject) {\n  try {\n    await event.sign(signer);\n    resolve(event);\n  } catch (e) {\n    debug8?.(`Failed to publish auth event to relay ${relay.url}`, e);\n    reject(event);\n  }\n}\nfunction signIn({ ndk, signer, debug: debug8 } = {}) {\n  debug8 ??= debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:auth-policies:signIn\");\n  return async (relay, challenge) => {\n    debug8?.(`Relay ${relay.url} requested authentication, signing in`);\n    const event = new NDKEvent(ndk);\n    event.kind = 22242 /* ClientAuth */;\n    event.tags = [\n      [\"relay\", relay.url],\n      [\"challenge\", challenge]\n    ];\n    signer ??= ndk?.signer;\n    return new Promise(async (resolve, reject) => {\n      if (signer) {\n        await signAndAuth(event, relay, signer, debug8, resolve, reject);\n      } else {\n        ndk?.once(\"signer:ready\", async (signer2) => {\n          await signAndAuth(event, relay, signer2, debug8, resolve, reject);\n        });\n      }\n    });\n  };\n}\nvar NDKRelayAuthPolicies = {\n  disconnect,\n  signIn\n};\n\n// src/signers/nip07/index.ts\n\nvar NDKNip07Signer = class _NDKNip07Signer {\n  _userPromise;\n  encryptionQueue = [];\n  encryptionProcessing = false;\n  debug;\n  waitTimeout;\n  _pubkey;\n  ndk;\n  _user;\n  /**\n   * @param waitTimeout - The timeout in milliseconds to wait for the NIP-07 to become available\n   */\n  constructor(waitTimeout = 1e3, ndk) {\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:nip07\");\n    this.waitTimeout = waitTimeout;\n    this.ndk = ndk;\n  }\n  get pubkey() {\n    if (!this._pubkey) throw new Error(\"Not ready\");\n    return this._pubkey;\n  }\n  async blockUntilReady() {\n    await this.waitForExtension();\n    const pubkey = await window.nostr?.getPublicKey();\n    if (!pubkey) {\n      throw new Error(\"User rejected access\");\n    }\n    this._pubkey = pubkey;\n    let user;\n    if (this.ndk) user = this.ndk.getUser({ pubkey });\n    else user = new NDKUser({ pubkey });\n    this._user = user;\n    return user;\n  }\n  /**\n   * Getter for the user property.\n   * @returns The NDKUser instance.\n   */\n  async user() {\n    if (!this._userPromise) {\n      this._userPromise = this.blockUntilReady();\n    }\n    return this._userPromise;\n  }\n  get userSync() {\n    if (!this._user) throw new Error(\"User not ready\");\n    return this._user;\n  }\n  /**\n   * Signs the given Nostr event.\n   * @param event - The Nostr event to be signed.\n   * @returns The signature of the signed event.\n   * @throws Error if the NIP-07 is not available on the window object.\n   */\n  async sign(event) {\n    await this.waitForExtension();\n    const signedEvent = await window.nostr?.signEvent(event);\n    if (!signedEvent) throw new Error(\"Failed to sign event\");\n    return signedEvent.sig;\n  }\n  async relays(ndk) {\n    await this.waitForExtension();\n    const relays = await window.nostr?.getRelays?.() || {};\n    const activeRelays = [];\n    for (const url of Object.keys(relays)) {\n      if (relays[url].read && relays[url].write) {\n        activeRelays.push(url);\n      }\n    }\n    return activeRelays.map((url) => new NDKRelay(url, ndk?.relayAuthDefaultPolicy, ndk));\n  }\n  async encryptionEnabled(nip) {\n    const enabled = [];\n    if ((!nip || nip === \"nip04\") && Boolean(window.nostr?.nip04)) enabled.push(\"nip04\");\n    if ((!nip || nip === \"nip44\") && Boolean(window.nostr?.nip44)) enabled.push(\"nip44\");\n    return enabled;\n  }\n  async encrypt(recipient, value, nip = \"nip04\") {\n    if (!await this.encryptionEnabled(nip))\n      throw new Error(`${nip}encryption is not available from your browser extension`);\n    await this.waitForExtension();\n    const recipientHexPubKey = recipient.pubkey;\n    return this.queueEncryption(nip, \"encrypt\", recipientHexPubKey, value);\n  }\n  async decrypt(sender, value, nip = \"nip04\") {\n    if (!await this.encryptionEnabled(nip))\n      throw new Error(`${nip}encryption is not available from your browser extension`);\n    await this.waitForExtension();\n    const senderHexPubKey = sender.pubkey;\n    return this.queueEncryption(nip, \"decrypt\", senderHexPubKey, value);\n  }\n  async queueEncryption(scheme, method, counterpartyHexpubkey, value) {\n    return new Promise((resolve, reject) => {\n      this.encryptionQueue.push({\n        scheme,\n        method,\n        counterpartyHexpubkey,\n        value,\n        resolve,\n        reject\n      });\n      if (!this.encryptionProcessing) {\n        this.processEncryptionQueue();\n      }\n    });\n  }\n  async processEncryptionQueue(item, retries = 0) {\n    if (!item && this.encryptionQueue.length === 0) {\n      this.encryptionProcessing = false;\n      return;\n    }\n    this.encryptionProcessing = true;\n    const currentItem = item || this.encryptionQueue.shift();\n    if (!currentItem) {\n      this.encryptionProcessing = false;\n      return;\n    }\n    const { scheme, method, counterpartyHexpubkey, value, resolve, reject } = currentItem;\n    this.debug(\"Processing encryption queue item\", {\n      method,\n      counterpartyHexpubkey,\n      value\n    });\n    try {\n      const result = await window.nostr?.[scheme]?.[method](counterpartyHexpubkey, value);\n      if (!result) throw new Error(\"Failed to encrypt/decrypt\");\n      resolve(result);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      if (errorMessage.includes(\"call already executing\") && retries < 5) {\n        this.debug(\"Retrying encryption queue item\", {\n          method,\n          counterpartyHexpubkey,\n          value,\n          retries\n        });\n        setTimeout(() => {\n          this.processEncryptionQueue(currentItem, retries + 1);\n        }, 50 * retries);\n        return;\n      }\n      reject(error instanceof Error ? error : new Error(errorMessage));\n    }\n    this.processEncryptionQueue();\n  }\n  waitForExtension() {\n    return new Promise((resolve, reject) => {\n      if (window.nostr) {\n        resolve();\n        return;\n      }\n      let timerId;\n      const intervalId = setInterval(() => {\n        if (window.nostr) {\n          clearTimeout(timerId);\n          clearInterval(intervalId);\n          resolve();\n        }\n      }, 100);\n      timerId = setTimeout(() => {\n        clearInterval(intervalId);\n        reject(new Error(\"NIP-07 extension not available\"));\n      }, this.waitTimeout);\n    });\n  }\n  /**\n   * Serializes the signer type into a storable format.\n   * NIP-07 signers don't have persistent state to serialize beyond their type.\n   * @returns A JSON string containing the type.\n   */\n  toPayload() {\n    const payload = {\n      type: \"nip07\",\n      payload: \"\"\n      // No specific payload needed for NIP-07\n    };\n    return JSON.stringify(payload);\n  }\n  /**\n   * Deserializes the signer from a payload string.\n   * Creates a new NDKNip07Signer instance.\n   * @param payloadString The JSON string obtained from toPayload().\n   * @param ndk Optional NDK instance.\n   * @returns An instance of NDKNip07Signer.\n   */\n  static async fromPayload(payloadString, ndk) {\n    const payload = JSON.parse(payloadString);\n    if (payload.type !== \"nip07\") {\n      throw new Error(`Invalid payload type: expected 'nip07', got ${payload.type}`);\n    }\n    return new _NDKNip07Signer(void 0, ndk);\n  }\n};\n\n// src/signers/nip46/backend/index.ts\n\n\n// src/signers/nip46/rpc.ts\n\nvar NDKNostrRpc = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  signer;\n  relaySet;\n  debug;\n  encryptionType = \"nip04\";\n  pool;\n  constructor(ndk, signer, debug8, relayUrls) {\n    super();\n    this.ndk = ndk;\n    this.signer = signer;\n    if (relayUrls) {\n      this.pool = new NDKPool(relayUrls, [], ndk, {\n        debug: debug8.extend(\"rpc-pool\"),\n        name: \"Nostr RPC\"\n      });\n      this.relaySet = new NDKRelaySet(/* @__PURE__ */ new Set(), ndk, this.pool);\n      for (const url of relayUrls) {\n        const relay = this.pool.getRelay(url, false, false);\n        relay.authPolicy = NDKRelayAuthPolicies.signIn({ ndk, signer, debug: debug8 });\n        this.relaySet.addRelay(relay);\n        relay.connect();\n      }\n    }\n    this.debug = debug8.extend(\"rpc\");\n  }\n  /**\n   * Subscribe to a filter. This function will resolve once the subscription is ready.\n   */\n  subscribe(filter) {\n    const sub = this.ndk.subscribe(\n      filter,\n      {\n        closeOnEose: false,\n        groupable: false,\n        cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */,\n        pool: this.pool,\n        relaySet: this.relaySet\n      },\n      false\n    );\n    sub.on(\"event\", async (event) => {\n      try {\n        const parsedEvent = await this.parseEvent(event);\n        if (parsedEvent.method) {\n          this.emit(\"request\", parsedEvent);\n        } else {\n          this.emit(`response-${parsedEvent.id}`, parsedEvent);\n        }\n      } catch (e) {\n        this.debug(\"error parsing event\", e, event.rawEvent());\n      }\n    });\n    return new Promise((resolve) => {\n      sub.on(\"eose\", () => {\n        this.debug(\"eosed\");\n        resolve(sub);\n      });\n      sub.start();\n    });\n  }\n  async parseEvent(event) {\n    if (this.encryptionType === \"nip44\" && event.content.includes(\"?iv=\")) {\n      this.encryptionType = \"nip04\";\n    } else if (this.encryptionType === \"nip04\" && !event.content.includes(\"?iv=\")) {\n      this.encryptionType = \"nip44\";\n    }\n    const remoteUser = this.ndk.getUser({ pubkey: event.pubkey });\n    remoteUser.ndk = this.ndk;\n    let decryptedContent;\n    try {\n      decryptedContent = await this.signer.decrypt(remoteUser, event.content, this.encryptionType);\n    } catch (_e) {\n      const otherEncryptionType = this.encryptionType === \"nip04\" ? \"nip44\" : \"nip04\";\n      decryptedContent = await this.signer.decrypt(remoteUser, event.content, otherEncryptionType);\n      this.encryptionType = otherEncryptionType;\n    }\n    const parsedContent = JSON.parse(decryptedContent);\n    const { id, method, params, result, error } = parsedContent;\n    if (method) {\n      return { id, pubkey: event.pubkey, method, params, event };\n    }\n    return { id, result, error, event };\n  }\n  async sendResponse(id, remotePubkey, result, kind = 24133 /* NostrConnect */, error) {\n    const res = { id, result };\n    if (error) {\n      res.error = error;\n    }\n    const localUser = await this.signer.user();\n    const remoteUser = this.ndk.getUser({ pubkey: remotePubkey });\n    const event = new NDKEvent(this.ndk, {\n      kind,\n      content: JSON.stringify(res),\n      tags: [[\"p\", remotePubkey]],\n      pubkey: localUser.pubkey\n    });\n    event.content = await this.signer.encrypt(remoteUser, event.content, this.encryptionType);\n    await event.sign(this.signer);\n    await event.publish(this.relaySet);\n  }\n  /**\n   * Sends a request.\n   * @param remotePubkey\n   * @param method\n   * @param params\n   * @param kind\n   * @param id\n   */\n  async sendRequest(remotePubkey, method, params = [], kind = 24133, cb) {\n    const id = Math.random().toString(36).substring(7);\n    const localUser = await this.signer.user();\n    const remoteUser = this.ndk.getUser({ pubkey: remotePubkey });\n    const request = { id, method, params };\n    const promise = new Promise(() => {\n      const responseHandler = (response) => {\n        if (response.result === \"auth_url\") {\n          this.once(`response-${id}`, responseHandler);\n          this.emit(\"authUrl\", response.error);\n        } else if (cb) {\n          cb(response);\n        }\n      };\n      this.once(`response-${id}`, responseHandler);\n    });\n    const event = new NDKEvent(this.ndk, {\n      kind,\n      content: JSON.stringify(request),\n      tags: [[\"p\", remotePubkey]],\n      pubkey: localUser.pubkey\n    });\n    event.content = await this.signer.encrypt(remoteUser, event.content, this.encryptionType);\n    await event.sign(this.signer);\n    await event.publish(this.relaySet);\n    return promise;\n  }\n};\n\n// src/signers/nip46/backend/connect.ts\nvar ConnectEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [_, token] = params;\n    const debug8 = backend.debug.extend(\"connect\");\n    debug8(`connection request from ${remotePubkey}`);\n    if (token && backend.applyToken) {\n      debug8(\"applying token\");\n      await backend.applyToken(remotePubkey, token);\n    }\n    if (await backend.pubkeyAllowed({\n      id,\n      pubkey: remotePubkey,\n      method: \"connect\",\n      params: token\n    })) {\n      debug8(`connection request from ${remotePubkey} allowed`);\n      return \"ack\";\n    }\n    debug8(`connection request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n};\n\n// src/signers/nip46/backend/get-public-key.ts\nvar GetPublicKeyHandlingStrategy = class {\n  async handle(backend, _id, _remotePubkey, _params) {\n    return backend.localUser?.pubkey;\n  }\n};\n\n// src/signers/nip46/backend/nip04-decrypt.ts\nvar Nip04DecryptHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [senderPubkey, payload] = params;\n    const senderUser = new NDKUser({ pubkey: senderPubkey });\n    const decryptedPayload = await decrypt2(backend, id, remotePubkey, senderUser, payload);\n    return decryptedPayload;\n  }\n};\nasync function decrypt2(backend, id, remotePubkey, senderUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip04_decrypt\",\n    params: payload\n  })) {\n    backend.debug(`decrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.decrypt(senderUser, payload, \"nip04\");\n}\n\n// src/signers/nip46/backend/nip04-encrypt.ts\nvar Nip04EncryptHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [recipientPubkey, payload] = params;\n    const recipientUser = new NDKUser({ pubkey: recipientPubkey });\n    const encryptedPayload = await encrypt2(backend, id, remotePubkey, recipientUser, payload);\n    return encryptedPayload;\n  }\n};\nasync function encrypt2(backend, id, remotePubkey, recipientUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip04_encrypt\",\n    params: payload\n  })) {\n    backend.debug(`encrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.encrypt(recipientUser, payload, \"nip04\");\n}\n\n// src/signers/nip46/backend/nip44-decrypt.ts\nvar Nip04DecryptHandlingStrategy2 = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [senderPubkey, payload] = params;\n    const senderUser = new NDKUser({ pubkey: senderPubkey });\n    const decryptedPayload = await decrypt3(backend, id, remotePubkey, senderUser, payload);\n    return decryptedPayload;\n  }\n};\nasync function decrypt3(backend, id, remotePubkey, senderUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip44_decrypt\",\n    params: payload\n  })) {\n    backend.debug(`decrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.decrypt(senderUser, payload, \"nip44\");\n}\n\n// src/signers/nip46/backend/nip44-encrypt.ts\nvar Nip04EncryptHandlingStrategy2 = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [recipientPubkey, payload] = params;\n    const recipientUser = new NDKUser({ pubkey: recipientPubkey });\n    const encryptedPayload = await encrypt3(backend, id, remotePubkey, recipientUser, payload);\n    return encryptedPayload;\n  }\n};\nasync function encrypt3(backend, id, remotePubkey, recipientUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip44_encrypt\",\n    params: payload\n  })) {\n    backend.debug(`encrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.encrypt(recipientUser, payload, \"nip44\");\n}\n\n// src/signers/nip46/backend/ping.ts\nvar PingEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, _params) {\n    const debug8 = backend.debug.extend(\"ping\");\n    debug8(`ping request from ${remotePubkey}`);\n    if (await backend.pubkeyAllowed({ id, pubkey: remotePubkey, method: \"ping\" })) {\n      debug8(`connection request from ${remotePubkey} allowed`);\n      return \"pong\";\n    }\n    debug8(`connection request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n};\n\n// src/signers/nip46/backend/sign-event.ts\nvar SignEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const event = await signEvent(backend, id, remotePubkey, params);\n    if (!event) return void 0;\n    return JSON.stringify(await event.toNostrEvent());\n  }\n};\nasync function signEvent(backend, id, remotePubkey, params) {\n  const [eventString] = params;\n  backend.debug(`sign event request from ${remotePubkey}`);\n  const event = new NDKEvent(backend.ndk, JSON.parse(eventString));\n  backend.debug(\"event to sign\", event.rawEvent());\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"sign_event\",\n    params: event\n  })) {\n    backend.debug(`sign event request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  backend.debug(`sign event request from ${remotePubkey} allowed`);\n  await event.sign(backend.signer);\n  return event;\n}\n\n// src/signers/nip46/backend/index.ts\nvar NDKNip46Backend = class {\n  ndk;\n  signer;\n  localUser;\n  debug;\n  rpc;\n  permitCallback;\n  relayUrls;\n  /**\n   * @param ndk The NDK instance to use\n   * @param privateKeyOrSigner The private key or signer of the npub that wants to be published as\n   * @param permitCallback Callback executed when permission is requested\n   */\n  constructor(ndk, privateKeyOrSigner, permitCallback, relayUrls) {\n    this.ndk = ndk;\n    if (privateKeyOrSigner instanceof Uint8Array) {\n      this.signer = new NDKPrivateKeySigner(privateKeyOrSigner);\n    } else if (privateKeyOrSigner instanceof String) {\n      this.signer = new NDKPrivateKeySigner((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(privateKeyOrSigner));\n    } else if (privateKeyOrSigner instanceof NDKPrivateKeySigner) {\n      this.signer = privateKeyOrSigner;\n    } else {\n      throw new Error(\"Invalid signer\");\n    }\n    this.debug = ndk.debug.extend(\"nip46:backend\");\n    this.relayUrls = relayUrls ?? Array.from(ndk.pool.relays.keys());\n    this.rpc = new NDKNostrRpc(ndk, this.signer, this.debug, this.relayUrls);\n    this.permitCallback = permitCallback;\n  }\n  /**\n   * This method starts the backend, which will start listening for incoming\n   * requests.\n   */\n  async start() {\n    this.localUser = await this.signer.user();\n    const sub = this.ndk.subscribe(\n      {\n        kinds: [24133],\n        \"#p\": [this.localUser.pubkey]\n      },\n      { closeOnEose: false }\n    );\n    sub.on(\"event\", (e) => this.handleIncomingEvent(e));\n  }\n  handlers = {\n    connect: new ConnectEventHandlingStrategy(),\n    sign_event: new SignEventHandlingStrategy(),\n    nip04_encrypt: new Nip04EncryptHandlingStrategy(),\n    nip04_decrypt: new Nip04DecryptHandlingStrategy(),\n    nip44_encrypt: new Nip04EncryptHandlingStrategy2(),\n    nip44_decrypt: new Nip04DecryptHandlingStrategy2(),\n    get_public_key: new GetPublicKeyHandlingStrategy(),\n    ping: new PingEventHandlingStrategy()\n  };\n  /**\n   * Enables the user to set a custom strategy for handling incoming events.\n   * @param method - The method to set the strategy for\n   * @param strategy - The strategy to set\n   */\n  setStrategy(method, strategy) {\n    this.handlers[method] = strategy;\n  }\n  /**\n   * Overload this method to apply tokens, which can\n   * wrap permission sets to be applied to a pubkey.\n   * @param pubkey public key to apply token to\n   * @param token token to apply\n   */\n  async applyToken(_pubkey, _token) {\n    throw new Error(\"connection token not supported\");\n  }\n  async handleIncomingEvent(event) {\n    const { id, method, params } = await this.rpc.parseEvent(event);\n    const remotePubkey = event.pubkey;\n    let response;\n    this.debug(\"incoming event\", { id, method, params });\n    if (!event.verifySignature(false)) {\n      this.debug(\"invalid signature\", event.rawEvent());\n      return;\n    }\n    const strategy = this.handlers[method];\n    if (strategy) {\n      try {\n        response = await strategy.handle(this, id, remotePubkey, params);\n      } catch (e) {\n        this.debug(\"error handling event\", e, { id, method, params });\n        this.rpc.sendResponse(id, remotePubkey, \"error\", void 0, e.message);\n      }\n    } else {\n      this.debug(\"unsupported method\", { method, params });\n    }\n    if (response) {\n      this.debug(`sending response to ${remotePubkey}`, response);\n      this.rpc.sendResponse(id, remotePubkey, response);\n    } else {\n      this.rpc.sendResponse(id, remotePubkey, \"error\", void 0, \"Not authorized\");\n    }\n  }\n  /**\n   * This method should be overriden by the user to allow or reject incoming\n   * connections.\n   */\n  async pubkeyAllowed(params) {\n    return this.permitCallback(params);\n  }\n};\n\n// src/signers/nip46/index.ts\n\n\n// src/signers/deserialization.ts\nvar signerRegistry = /* @__PURE__ */ new Map();\nsignerRegistry.set(\"private-key\", NDKPrivateKeySigner);\nsignerRegistry.set(\"nip07\", NDKNip07Signer);\nsignerRegistry.set(\"nip46\", NDKNip46Signer);\nasync function ndkSignerFromPayload(payloadString, ndk) {\n  let parsed;\n  try {\n    parsed = JSON.parse(payloadString);\n  } catch (e) {\n    throw new Error(`Failed to parse signer payload: ${e instanceof Error ? e.message : String(e)}`);\n  }\n  const SignerClass = signerRegistry.get(parsed.type);\n  if (!SignerClass) {\n    throw new Error(`Unknown signer type: ${parsed.type}`);\n  }\n  try {\n    return await SignerClass.fromPayload(payloadString, ndk);\n  } catch (e) {\n    const errorMsg = e instanceof Error ? e.message : String(e);\n    throw new Error(`Failed to deserialize signer type ${parsed.type}: ${errorMsg}`);\n  }\n}\n\n// src/signers/nip46/index.ts\nvar NDKNip46Signer = class _NDKNip46Signer extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  _user;\n  /**\n   * The pubkey of the bunker that will be providing signatures\n   */\n  bunkerPubkey;\n  /**\n   * The pubkey of the user that events will be published as\n   */\n  userPubkey;\n  get pubkey() {\n    if (!this.userPubkey) throw new Error(\"Not ready\");\n    return this.userPubkey;\n  }\n  /**\n   * An optional secret value provided to connect to the bunker\n   */\n  secret;\n  localSigner;\n  nip05;\n  rpc;\n  debug;\n  relayUrls;\n  subscription;\n  /**\n   * @param ndk - The NDK instance to use\n   * @param userOrConnectionToken - The public key, or a connection token, of the npub that wants to be published as\n   * @param localSigner - The signer that will be used to request events to be signed\n   */\n  constructor(ndk, userOrConnectionToken, localSigner) {\n    super();\n    this.ndk = ndk;\n    this.debug = ndk.debug.extend(\"nip46:signer\");\n    if (userOrConnectionToken.startsWith(\"bunker://\")) {\n      this.connectionTokenInit(userOrConnectionToken);\n    } else {\n      this.nip05Init(userOrConnectionToken);\n    }\n    if (!localSigner) {\n      this.localSigner = NDKPrivateKeySigner.generate();\n    } else {\n      this.localSigner = localSigner;\n    }\n    this.rpc = new NDKNostrRpc(this.ndk, this.localSigner, this.debug, this.relayUrls);\n  }\n  connectionTokenInit(connectionToken) {\n    const bunkerUrl = new URL(connectionToken);\n    const bunkerPubkey = bunkerUrl.hostname || bunkerUrl.pathname.replace(/^\\/\\//, \"\");\n    const userPubkey = bunkerUrl.searchParams.get(\"pubkey\");\n    const relayUrls = bunkerUrl.searchParams.getAll(\"relay\");\n    const secret = bunkerUrl.searchParams.get(\"secret\");\n    this.bunkerPubkey = bunkerPubkey;\n    this.userPubkey = userPubkey;\n    this.relayUrls = relayUrls;\n    this.secret = secret;\n  }\n  nip05Init(nip05) {\n    this.nip05 = nip05;\n  }\n  /**\n   * We start listening for events from the bunker\n   */\n  async startListening() {\n    if (this.subscription) return;\n    const localUser = await this.localSigner.user();\n    if (!localUser) throw new Error(\"Local signer not ready\");\n    this.subscription = await this.rpc.subscribe({\n      kinds: [24133 /* NostrConnect */],\n      \"#p\": [localUser.pubkey]\n    });\n  }\n  /**\n   * Get the user that is being published as\n   */\n  async user() {\n    if (this._user) return this._user;\n    return this.blockUntilReady();\n  }\n  get userSync() {\n    if (!this._user) throw new Error(\"Remote user not ready synchronously\");\n    return this._user;\n  }\n  async blockUntilReady() {\n    if (this.nip05 && !this.userPubkey) {\n      const user = await NDKUser.fromNip05(this.nip05, this.ndk);\n      if (user) {\n        this._user = user;\n        this.userPubkey = user.pubkey;\n        this.relayUrls = user.nip46Urls;\n        this.rpc = new NDKNostrRpc(this.ndk, this.localSigner, this.debug, this.relayUrls);\n      }\n    }\n    if (!this.bunkerPubkey && this.userPubkey) {\n      this.bunkerPubkey = this.userPubkey;\n    } else if (!this.bunkerPubkey) {\n      throw new Error(\"Bunker pubkey not set\");\n    }\n    await this.startListening();\n    this.rpc.on(\"authUrl\", (...props) => {\n      this.emit(\"authUrl\", ...props);\n    });\n    return new Promise((resolve, reject) => {\n      const connectParams = [this.userPubkey ?? \"\"];\n      if (this.secret) connectParams.push(this.secret);\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(this.bunkerPubkey, \"connect\", connectParams, 24133, (response) => {\n        if (response.result === \"ack\") {\n          this.getPublicKey().then((pubkey) => {\n            this.userPubkey = pubkey;\n            this._user = this.ndk.getUser({ pubkey });\n            resolve(this._user);\n          });\n        } else {\n          reject(response.error);\n        }\n      });\n    });\n  }\n  async getPublicKey() {\n    if (this.userPubkey) return this.userPubkey;\n    return new Promise((resolve, _reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(this.bunkerPubkey, \"get_public_key\", [], 24133, (response) => {\n        resolve(response.result);\n      });\n    });\n  }\n  async encryptionEnabled(scheme) {\n    if (scheme) return [scheme];\n    return Promise.resolve([\"nip04\", \"nip44\"]);\n  }\n  async encrypt(recipient, value, scheme = \"nip04\") {\n    return this.encryption(recipient, value, scheme, \"encrypt\");\n  }\n  async decrypt(sender, value, scheme = \"nip04\") {\n    return this.encryption(sender, value, scheme, \"decrypt\");\n  }\n  async encryption(peer, value, scheme, method) {\n    const promise = new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        `${scheme}_${method}`,\n        [peer.pubkey, value],\n        24133,\n        (response) => {\n          if (!response.error) {\n            resolve(response.result);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n    return promise;\n  }\n  async sign(event) {\n    const promise = new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"sign_event\",\n        [JSON.stringify(event)],\n        24133,\n        (response) => {\n          if (!response.error) {\n            const json = JSON.parse(response.result);\n            resolve(json.sig);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n    return promise;\n  }\n  /**\n   * Allows creating a new account on the remote server.\n   * @param username Desired username for the NIP-05\n   * @param domain Desired domain for the NIP-05\n   * @param email Email address to associate with this account -- Remote servers may use this for recovery\n   * @returns The public key of the newly created account\n   */\n  async createAccount(username, domain, email) {\n    await this.startListening();\n    const req = [];\n    if (username) req.push(username);\n    if (domain) req.push(domain);\n    if (email) req.push(email);\n    return new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"create_account\",\n        req,\n        24133 /* NostrConnect */,\n        (response) => {\n          if (!response.error) {\n            const pubkey = response.result;\n            resolve(pubkey);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n  }\n  /**\n   * Serializes the signer's connection details and local signer state.\n   * @returns A JSON string containing the type, connection info, and local signer payload.\n   */\n  toPayload() {\n    if (!this.bunkerPubkey || !this.userPubkey) {\n      throw new Error(\"NIP-46 signer is not fully initialized for serialization\");\n    }\n    const payload = {\n      type: \"nip46\",\n      payload: {\n        bunkerPubkey: this.bunkerPubkey,\n        userPubkey: this.userPubkey,\n        relayUrls: this.relayUrls,\n        secret: this.secret,\n        localSignerPayload: this.localSigner.toPayload(),\n        // Store nip05 if it was used for initialization, otherwise null\n        nip05: this.nip05 || null\n      }\n    };\n    return JSON.stringify(payload);\n  }\n  /**\n   * Deserializes the signer from a payload string.\n   * @param payloadString The JSON string obtained from toPayload().\n   * @param ndk The NDK instance, required for NIP-46.\n   * @returns An instance of NDKNip46Signer.\n   */\n  static async fromPayload(payloadString, ndk) {\n    if (!ndk) {\n      throw new Error(\"NDK instance is required to deserialize NIP-46 signer\");\n    }\n    const parsed = JSON.parse(payloadString);\n    if (parsed.type !== \"nip46\") {\n      throw new Error(`Invalid payload type: expected 'nip46', got ${parsed.type}`);\n    }\n    const payload = parsed.payload;\n    if (!payload || typeof payload !== \"object\" || !payload.localSignerPayload) {\n      throw new Error(\"Invalid payload content for nip46 signer\");\n    }\n    const localSigner = await ndkSignerFromPayload(payload.localSignerPayload, ndk);\n    if (!localSigner) {\n      throw new Error(\"Failed to deserialize local signer for NIP-46\");\n    }\n    let signer;\n    if (payload.nip05) {\n      signer = new _NDKNip46Signer(ndk, payload.nip05, localSigner);\n      signer.userPubkey = payload.userPubkey;\n      signer.bunkerPubkey = payload.bunkerPubkey;\n      signer.relayUrls = payload.relayUrls;\n      signer.secret = payload.secret;\n    } else {\n      signer = new _NDKNip46Signer(ndk, payload.userPubkey, localSigner);\n      signer.bunkerPubkey = payload.bunkerPubkey;\n      signer.relayUrls = payload.relayUrls;\n      signer.secret = payload.secret;\n    }\n    return signer;\n  }\n};\n\n// src/dvm/schedule.ts\nfunction addRelays(event, relays) {\n  const tags = [];\n  if (!relays || relays.length === 0) {\n    const poolRelays = event.ndk?.pool.relays;\n    relays = poolRelays ? Object.keys(poolRelays) : void 0;\n  }\n  if (relays && relays.length > 0) tags.push([\"relays\", ...relays]);\n  return tags;\n}\nasync function dvmSchedule(events, dvm, relays, encrypted = true, waitForConfirmationForMs) {\n  if (!Array.isArray(events)) {\n    events = [events];\n  }\n  const ndk = events[0].ndk;\n  if (!ndk) throw new Error(\"NDK not set\");\n  for (const event of events) {\n    if (!event.sig) throw new Error(\"Event not signed\");\n    if (!event.created_at) throw new Error(\"Event has no date\");\n    if (!dvm) throw new Error(\"No DVM specified\");\n    if (event.created_at <= Date.now() / 1e3) throw new Error(\"Event needs to be in the future\");\n  }\n  const scheduleEvent = new NDKDVMRequest(ndk, {\n    kind: 5905 /* DVMEventSchedule */\n  });\n  for (const event of events) {\n    scheduleEvent.addInput(JSON.stringify(event.rawEvent()), \"text\");\n  }\n  scheduleEvent.tags.push(...addRelays(events[0], relays));\n  if (encrypted) {\n    await scheduleEvent.encryption(dvm);\n  } else {\n    scheduleEvent.dvm = dvm;\n  }\n  await scheduleEvent.sign();\n  let res;\n  if (waitForConfirmationForMs) {\n    res = ndk.subscribe(\n      {\n        kinds: [5905 /* DVMEventSchedule */ + 1e3, 7e3 /* DVMJobFeedback */],\n        ...scheduleEvent.filter()\n      },\n      { groupable: false, closeOnEose: false }\n    );\n  }\n  const timeoutPromise = new Promise((reject) => {\n    setTimeout(() => {\n      res?.stop();\n      reject(\"Timeout waiting for an answer from the DVM\");\n    }, waitForConfirmationForMs);\n  });\n  const schedulePromise = new Promise((resolve, reject) => {\n    if (waitForConfirmationForMs) {\n      res?.on(\"event\", async (e) => {\n        res?.stop();\n        if (e.kind === 7e3 /* DVMJobFeedback */) {\n          const feedback = await NDKDVMJobFeedback.from(e);\n          if (feedback.status === \"error\") {\n            const statusTag = feedback.getMatchingTags(\"status\");\n            reject(statusTag?.[2] ?? feedback);\n          } else {\n            resolve(feedback);\n          }\n        }\n        resolve(e);\n      });\n    }\n    scheduleEvent.publish().then(() => {\n      if (!waitForConfirmationForMs) resolve(void 0);\n    });\n  });\n  return new Promise((resolve, reject) => {\n    if (waitForConfirmationForMs) {\n      Promise.race([timeoutPromise, schedulePromise]).then((e) => {\n        resolve(e);\n      }).catch(reject);\n    } else {\n      schedulePromise.then(resolve);\n    }\n  });\n}\n\n// src/ndk/index.ts\n\n\n\n// src/events/dedup.ts\nfunction dedup(event1, event2) {\n  if (event1.created_at > event2.created_at) {\n    return event1;\n  }\n  return event2;\n}\n\n// src/outbox/tracker.ts\n\n\n\n// src/utils/get-users-relay-list.ts\nasync function getRelayListForUser(pubkey, ndk) {\n  const list = await getRelayListForUsers([pubkey], ndk);\n  return list.get(pubkey);\n}\nasync function getRelayListForUsers(pubkeys, ndk, skipCache = false, timeout = 1e3) {\n  const pool = ndk.outboxPool || ndk.pool;\n  const set = /* @__PURE__ */ new Set();\n  for (const relay of pool.relays.values()) set.add(relay);\n  const relayLists = /* @__PURE__ */ new Map();\n  const fromContactList = /* @__PURE__ */ new Map();\n  const relaySet = new NDKRelaySet(set, ndk);\n  if (ndk.cacheAdapter?.locking && !skipCache) {\n    const cachedList = await ndk.fetchEvents(\n      { kinds: [3, 10002], authors: Array.from(new Set(pubkeys)) },\n      { cacheUsage: \"ONLY_CACHE\" /* ONLY_CACHE */, subId: \"ndk-relay-list-fetch\" }\n    );\n    for (const relayList of cachedList) {\n      if (relayList.kind === 10002) relayLists.set(relayList.pubkey, NDKRelayList.from(relayList));\n    }\n    for (const relayList of cachedList) {\n      if (relayList.kind === 3) {\n        if (relayLists.has(relayList.pubkey)) continue;\n        const list = relayListFromKind3(ndk, relayList);\n        if (list) fromContactList.set(relayList.pubkey, list);\n      }\n    }\n    pubkeys = pubkeys.filter((pubkey) => !relayLists.has(pubkey) && !fromContactList.has(pubkey));\n  }\n  if (pubkeys.length === 0) return relayLists;\n  const relayListEvents = /* @__PURE__ */ new Map();\n  const contactListEvents = /* @__PURE__ */ new Map();\n  return new Promise((resolve) => {\n    const handleSubscription = async () => {\n      const subscribeOpts = {\n        closeOnEose: true,\n        pool,\n        groupable: true,\n        subId: \"ndk-relay-list-fetch\",\n        addSinceFromCache: true,\n        relaySet\n      };\n      if (relaySet) subscribeOpts.relaySet = relaySet;\n      ndk.subscribe({ kinds: [3, 10002], authors: pubkeys }, subscribeOpts, {\n        onEvent: (event) => {\n          if (event.kind === 10002 /* RelayList */) {\n            const existingEvent = relayListEvents.get(event.pubkey);\n            if (existingEvent && existingEvent.created_at > event.created_at) return;\n            relayListEvents.set(event.pubkey, event);\n          } else if (event.kind === 3 /* Contacts */) {\n            const existingEvent = contactListEvents.get(event.pubkey);\n            if (existingEvent && existingEvent.created_at > event.created_at) return;\n            contactListEvents.set(event.pubkey, event);\n          }\n        },\n        onEose: () => {\n          for (const event of relayListEvents.values()) {\n            relayLists.set(event.pubkey, NDKRelayList.from(event));\n          }\n          for (const pubkey of pubkeys) {\n            if (relayLists.has(pubkey)) continue;\n            const contactList = contactListEvents.get(pubkey);\n            if (!contactList) continue;\n            const list = relayListFromKind3(ndk, contactList);\n            if (list) relayLists.set(pubkey, list);\n          }\n          resolve(relayLists);\n        }\n      });\n      setTimeout(() => {\n        resolve(relayLists);\n      }, timeout);\n    };\n    handleSubscription();\n  });\n}\n\n// src/outbox/tracker.ts\nvar OutboxItem = class {\n  /**\n   * Type of item\n   */\n  type;\n  /**\n   * The relay URLs that are of interest to this item\n   */\n  relayUrlScores;\n  readRelays;\n  writeRelays;\n  constructor(type) {\n    this.type = type;\n    this.relayUrlScores = /* @__PURE__ */ new Map();\n    this.readRelays = /* @__PURE__ */ new Set();\n    this.writeRelays = /* @__PURE__ */ new Set();\n  }\n};\nvar OutboxTracker = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  data;\n  ndk;\n  debug;\n  constructor(ndk) {\n    super();\n    this.ndk = ndk;\n    this.debug = ndk.debug.extend(\"outbox-tracker\");\n    this.data = new typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({\n      maxSize: 1e5,\n      entryExpirationTimeInMS: 2 * 60 * 1e3\n    });\n  }\n  /**\n   * Adds a list of users to the tracker.\n   * @param items\n   * @param skipCache\n   */\n  async trackUsers(items, skipCache = false) {\n    const promises = [];\n    for (let i = 0; i < items.length; i += 400) {\n      const slice = items.slice(i, i + 400);\n      const pubkeys = slice.map((item) => getKeyFromItem(item)).filter((pubkey) => !this.data.has(pubkey));\n      if (pubkeys.length === 0) continue;\n      for (const pubkey of pubkeys) {\n        this.data.set(pubkey, new OutboxItem(\"user\"));\n      }\n      promises.push(\n        new Promise((resolve) => {\n          getRelayListForUsers(pubkeys, this.ndk, skipCache).then((relayLists) => {\n            for (const [pubkey, relayList] of relayLists) {\n              let outboxItem = this.data.get(pubkey);\n              outboxItem ??= new OutboxItem(\"user\");\n              if (relayList) {\n                outboxItem.readRelays = new Set(normalize(relayList.readRelayUrls));\n                outboxItem.writeRelays = new Set(normalize(relayList.writeRelayUrls));\n                for (const relayUrl of outboxItem.readRelays) {\n                  if (this.ndk.pool.blacklistRelayUrls.has(relayUrl)) {\n                    outboxItem.readRelays.delete(relayUrl);\n                  }\n                }\n                for (const relayUrl of outboxItem.writeRelays) {\n                  if (this.ndk.pool.blacklistRelayUrls.has(relayUrl)) {\n                    outboxItem.writeRelays.delete(relayUrl);\n                  }\n                }\n                this.data.set(pubkey, outboxItem);\n              }\n            }\n          }).finally(resolve);\n        })\n      );\n    }\n    return Promise.all(promises);\n  }\n  /**\n   *\n   * @param key\n   * @param score\n   */\n  track(item, type, _skipCache = true) {\n    const key = getKeyFromItem(item);\n    type ??= getTypeFromItem(item);\n    let outboxItem = this.data.get(key);\n    if (!outboxItem) {\n      outboxItem = new OutboxItem(type);\n      if (item instanceof NDKUser) {\n        this.trackUsers([item]);\n      }\n    }\n    return outboxItem;\n  }\n};\nfunction getKeyFromItem(item) {\n  if (item instanceof NDKUser) {\n    return item.pubkey;\n  }\n  return item;\n}\nfunction getTypeFromItem(item) {\n  if (item instanceof NDKUser) {\n    return \"user\";\n  }\n  return \"kind\";\n}\n\n// src/relay/sets/utils.ts\nfunction correctRelaySet(relaySet, pool) {\n  const connectedRelays = pool.connectedRelays();\n  const includesConnectedRelay = Array.from(relaySet.relays).some((relay) => {\n    return connectedRelays.map((r) => r.url).includes(relay.url);\n  });\n  if (!includesConnectedRelay) {\n    for (const relay of connectedRelays) {\n      relaySet.addRelay(relay);\n    }\n  }\n  if (connectedRelays.length === 0) {\n    for (const relay of pool.relays.values()) {\n      relaySet.addRelay(relay);\n    }\n  }\n  return relaySet;\n}\n\n// src/subscription/manager.ts\n\nvar NDKSubscriptionManager = class {\n  subscriptions;\n  seenEvents = /* @__PURE__ */ new Map();\n  constructor() {\n    this.subscriptions = /* @__PURE__ */ new Map();\n  }\n  add(sub) {\n    this.subscriptions.set(sub.internalId, sub);\n    if (sub.onStopped) {\n    }\n    sub.onStopped = () => {\n      this.subscriptions.delete(sub.internalId);\n    };\n    sub.on(\"close\", () => {\n      this.subscriptions.delete(sub.internalId);\n    });\n  }\n  seenEvent(eventId, relay) {\n    const current = this.seenEvents.get(eventId) || [];\n    current.push(relay);\n    this.seenEvents.set(eventId, current);\n  }\n  /**\n   * Whenever an event comes in, this function is called.\n   * This function matches the received event against all the\n   * known (i.e. active) NDKSubscriptions, and if it matches,\n   * it sends the event to the subscription.\n   *\n   * This is the single place in the codebase that matches\n   * incoming events with parties interested in the event.\n   *\n   * This is also what allows for reactivity in NDK apps, such that\n   * whenever an active subscription receives an event that some\n   * other active subscription would want to receive, both receive it.\n   *\n   * TODO This also allows for subscriptions that overlap in meaning\n   * to be collapsed into one.\n   *\n   * I.e. if a subscription with filter: kinds: [1], authors: [alice]\n   * is created and EOSEs, and then a subsequent subscription with\n   * kinds: [1], authors: [alice] is created, once the second subscription\n   * EOSEs we can safely close it, increment its refCount and close it,\n   * and when the first subscription receives a new event from Alice this\n   * code will make the second subscription receive the event even though\n   * it has no active subscription on a relay.\n   * @param event Raw event received from a relay\n   * @param relay Relay that sent the event\n   * @param optimisticPublish Whether the event is coming from an optimistic publish\n   */\n  dispatchEvent(event, relay, optimisticPublish = false) {\n    if (relay) this.seenEvent(event.id, relay);\n    const subscriptions = this.subscriptions.values();\n    const matchingSubs = [];\n    for (const sub of subscriptions) {\n      if ((0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.matchFilters)(sub.filters, event)) {\n        matchingSubs.push(sub);\n      }\n    }\n    for (const sub of matchingSubs) {\n      sub.eventReceived(event, relay, false, optimisticPublish);\n    }\n  }\n};\n\n// src/ndk/active-user.ts\n\nvar debug6 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:active-user\");\nasync function getUserRelayList(user) {\n  if (!this.autoConnectUserRelays) return;\n  const userRelays = await getRelayListForUser(user.pubkey, this);\n  if (!userRelays) return;\n  for (const url of userRelays.relays) {\n    let relay = this.pool.relays.get(url);\n    if (!relay) {\n      relay = new NDKRelay(url, this.relayAuthDefaultPolicy, this);\n      this.pool.addRelay(relay);\n    }\n  }\n  return userRelays;\n}\nasync function setActiveUser(user) {\n  const pool = this.outboxPool || this.pool;\n  if (pool.connectedRelays.length > 0) {\n    setActiveUserConnected.call(this, user);\n  } else {\n    pool.once(\"connect\", () => {\n      setActiveUserConnected.call(this, user);\n    });\n  }\n}\nasync function setActiveUserConnected(user) {\n  const userRelays = await getUserRelayList.call(this, user);\n  const filters = [\n    {\n      kinds: [10006 /* BlockRelayList */],\n      authors: [user.pubkey]\n    }\n  ];\n  if (this.autoFetchUserMutelist) {\n    filters[0].kinds?.push(1e4 /* MuteList */);\n  }\n  const events = /* @__PURE__ */ new Map();\n  const relaySet = userRelays ? userRelays.relaySet : void 0;\n  this.subscribe(\n    filters,\n    { subId: \"active-user-settings\", closeOnEose: true, relaySet },\n    {\n      onEvent: (event) => {\n        const prevEvent = events.get(event.kind);\n        if (prevEvent && prevEvent.created_at >= event.created_at) return;\n        events.set(event.kind, event);\n      },\n      onEose: () => {\n        for (const event of events.values()) {\n          processEvent.call(this, event);\n        }\n      }\n    }\n  );\n}\nasync function processEvent(event) {\n  if (event.kind === 10006 /* BlockRelayList */) {\n    processBlockRelayList.call(this, event);\n  } else if (event.kind === 1e4 /* MuteList */) {\n    processMuteList.call(this, event);\n  }\n}\nfunction processBlockRelayList(event) {\n  const list = lists_default.from(event);\n  for (const item of list.items) {\n    this.pool.blacklistRelayUrls.add(item[0]);\n  }\n  debug6(\"Added %d relays to relay blacklist\", list.items.length);\n}\nfunction processMuteList(muteList) {\n  const list = lists_default.from(muteList);\n  for (const item of list.items) {\n    this.mutedIds.set(item[1], item[0]);\n  }\n  debug6(\"Added %d users to mute list\", list.items.length);\n}\n\n// src/ndk/entity.ts\n\nfunction getEntity(entity) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(entity);\n    if (decoded.type === \"npub\") return npub(this, decoded.data);\n    if (decoded.type === \"nprofile\") return nprofile(this, decoded.data);\n    return decoded;\n  } catch (_e) {\n    return null;\n  }\n}\nfunction npub(ndk, pubkey) {\n  return ndk.getUser({ pubkey });\n}\nfunction nprofile(ndk, profile) {\n  const user = ndk.getUser({ pubkey: profile.pubkey });\n  if (profile.relays) user.relayUrls = profile.relays;\n  return user;\n}\n\n// src/ndk/fetch-event-from-tag.ts\nfunction isValidHint(hint) {\n  if (!hint || hint === \"\") return false;\n  try {\n    new URL(hint);\n    return true;\n  } catch (_e) {\n    return false;\n  }\n}\nasync function fetchEventFromTag(tag, originalEvent, subOpts, fallback = {\n  type: \"timeout\"\n}) {\n  const d4 = this.debug.extend(\"fetch-event-from-tag\");\n  const [_, id, hint] = tag;\n  subOpts = {};\n  d4(\"fetching event from tag\", tag, subOpts, fallback);\n  const authorRelays = getRelaysForSync(this, originalEvent.pubkey);\n  if (authorRelays && authorRelays.size > 0) {\n    d4(\"fetching event from author relays %o\", Array.from(authorRelays));\n    const relaySet2 = NDKRelaySet.fromRelayUrls(Array.from(authorRelays), this);\n    const event2 = await this.fetchEvent(id, subOpts, relaySet2);\n    if (event2) return event2;\n  } else {\n    d4(\"no author relays found for %s\", originalEvent.pubkey, originalEvent);\n  }\n  const relaySet = calculateRelaySetsFromFilters(this, [{ ids: [id] }], this.pool);\n  d4(\"fetching event without relay hint\", relaySet);\n  const event = await this.fetchEvent(id, subOpts);\n  if (event) return event;\n  if (hint && hint !== \"\") {\n    const event2 = await this.fetchEvent(id, subOpts, this.pool.getRelay(hint, true, true, [{ ids: [id] }]));\n    if (event2) return event2;\n  }\n  let result = void 0;\n  const relay = isValidHint(hint) ? this.pool.getRelay(hint, false, true, [{ ids: [id] }]) : void 0;\n  const fetchMaybeWithRelayHint = new Promise((resolve) => {\n    this.fetchEvent(id, subOpts, relay).then(resolve);\n  });\n  if (!isValidHint(hint) || fallback.type === \"none\") {\n    return fetchMaybeWithRelayHint;\n  }\n  const fallbackFetchPromise = new Promise(async (resolve) => {\n    const fallbackRelaySet = fallback.relaySet;\n    const timeout = fallback.timeout ?? 1500;\n    const timeoutPromise = new Promise((resolve2) => setTimeout(resolve2, timeout));\n    if (fallback.type === \"timeout\") await timeoutPromise;\n    if (result) {\n      resolve(result);\n    } else {\n      d4(\"fallback fetch triggered\");\n      const fallbackEvent = await this.fetchEvent(id, subOpts, fallbackRelaySet);\n      resolve(fallbackEvent);\n    }\n  });\n  switch (fallback.type) {\n    case \"timeout\":\n      return Promise.race([fetchMaybeWithRelayHint, fallbackFetchPromise]);\n    case \"eose\":\n      result = await fetchMaybeWithRelayHint;\n      if (result) return result;\n      return fallbackFetchPromise;\n  }\n}\n\n// src/ndk/queue/index.ts\nvar Queue = class {\n  queue = [];\n  maxConcurrency;\n  processing = /* @__PURE__ */ new Set();\n  promises = /* @__PURE__ */ new Map();\n  constructor(_name, maxConcurrency) {\n    this.maxConcurrency = maxConcurrency;\n  }\n  add(item) {\n    if (this.promises.has(item.id)) {\n      return this.promises.get(item.id);\n    }\n    const promise = new Promise((resolve, reject) => {\n      this.queue.push({\n        ...item,\n        func: () => item.func().then(\n          (result) => {\n            resolve(result);\n            return result;\n          },\n          (error) => {\n            reject(error);\n            throw error;\n          }\n        )\n      });\n      this.process();\n    });\n    this.promises.set(item.id, promise);\n    promise.finally(() => {\n      this.promises.delete(item.id);\n      this.processing.delete(item.id);\n      this.process();\n    });\n    return promise;\n  }\n  process() {\n    if (this.processing.size >= this.maxConcurrency || this.queue.length === 0) {\n      return;\n    }\n    const item = this.queue.shift();\n    if (!item || this.processing.has(item.id)) {\n      return;\n    }\n    this.processing.add(item.id);\n    item.func();\n  }\n  clear() {\n    this.queue = [];\n  }\n  clearProcessing() {\n    this.processing.clear();\n  }\n  clearAll() {\n    this.clear();\n    this.clearProcessing();\n  }\n  length() {\n    return this.queue.length;\n  }\n};\n\n// src/ndk/index.ts\nvar DEFAULT_OUTBOX_RELAYS = [\"wss://purplepag.es/\", \"wss://nos.lol/\"];\nvar DEFAULT_BLACKLISTED_RELAYS = [\n  \"wss://brb.io/\",\n  // BRB\n  \"wss://nostr.mutinywallet.com/\"\n  // Don't try to read from this relay since it's a write-only relay\n  // \"wss://purplepag.es/\", // This is a hack, since this is a mostly read-only relay, but not fully. Once we have relay routing this can be removed so it only receives the supported kinds\n];\nvar NDK = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  _explicitRelayUrls;\n  blacklistRelayUrls;\n  pool;\n  outboxPool;\n  _signer;\n  _activeUser;\n  cacheAdapter;\n  debug;\n  devWriteRelaySet;\n  outboxTracker;\n  mutedIds;\n  clientName;\n  clientNip89;\n  queuesZapConfig;\n  queuesNip05;\n  asyncSigVerification = false;\n  initialValidationRatio = 1;\n  lowestValidationRatio = 1;\n  validationRatioFn;\n  subManager;\n  publishingFailureHandled = false;\n  pools = [];\n  /**\n   * Default relay-auth policy that will be used when a relay requests authentication,\n   * if no other policy is specified for that relay.\n   *\n   * @example Disconnect from relays that request authentication:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.disconnect(ndk.pool);\n   * ```\n   *\n   * @example Sign in to relays that request authentication:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.signIn({ndk})\n   * ```\n   *\n   * @example Sign in to relays that request authentication, asking the user for confirmation:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = (relay: NDKRelay) => {\n   *     const signIn = NDKAuthPolicies.signIn({ndk});\n   *     if (confirm(`Relay ${relay.url} is requesting authentication, do you want to sign in?`)) {\n   *        signIn(relay);\n   *     }\n   * }\n   * ```\n   */\n  relayAuthDefaultPolicy;\n  /**\n   * Fetch function to use for HTTP requests.\n   *\n   * @example\n   * ```typescript\n   * import fetch from \"node-fetch\";\n   *\n   * ndk.httpFetch = fetch;\n   * ```\n   */\n  httpFetch;\n  /**\n   * Provide a caller function to receive all networking traffic from relays\n   */\n  netDebug;\n  autoConnectUserRelays = true;\n  autoFetchUserMutelist = true;\n  walletConfig;\n  constructor(opts = {}) {\n    super();\n    this.debug = opts.debug || debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk\");\n    this.netDebug = opts.netDebug;\n    this._explicitRelayUrls = opts.explicitRelayUrls || [];\n    this.blacklistRelayUrls = opts.blacklistRelayUrls || DEFAULT_BLACKLISTED_RELAYS;\n    this.subManager = new NDKSubscriptionManager();\n    this.pool = new NDKPool(opts.explicitRelayUrls || [], [], this);\n    this.pool.name = \"Main\";\n    this.pool.on(\"relay:auth\", async (relay, challenge) => {\n      if (this.relayAuthDefaultPolicy) {\n        await this.relayAuthDefaultPolicy(relay, challenge);\n      }\n    });\n    this.autoConnectUserRelays = opts.autoConnectUserRelays ?? true;\n    this.autoFetchUserMutelist = opts.autoFetchUserMutelist ?? true;\n    this.clientName = opts.clientName;\n    this.clientNip89 = opts.clientNip89;\n    this.relayAuthDefaultPolicy = opts.relayAuthDefaultPolicy;\n    if (opts.enableOutboxModel) {\n      this.outboxPool = new NDKPool(opts.outboxRelayUrls || DEFAULT_OUTBOX_RELAYS, [], this, {\n        debug: this.debug.extend(\"outbox-pool\"),\n        name: \"Outbox Pool\"\n      });\n      this.outboxTracker = new OutboxTracker(this);\n    }\n    this.signer = opts.signer;\n    this.cacheAdapter = opts.cacheAdapter;\n    this.mutedIds = opts.mutedIds || /* @__PURE__ */ new Map();\n    if (opts.devWriteRelayUrls) {\n      this.devWriteRelaySet = NDKRelaySet.fromRelayUrls(opts.devWriteRelayUrls, this);\n    }\n    this.queuesZapConfig = new Queue(\"zaps\", 3);\n    this.queuesNip05 = new Queue(\"nip05\", 10);\n    this.signatureVerificationWorker = opts.signatureVerificationWorker;\n    this.initialValidationRatio = opts.initialValidationRatio || 1;\n    this.lowestValidationRatio = opts.lowestValidationRatio || 1;\n    try {\n      this.httpFetch = fetch;\n    } catch {\n    }\n  }\n  set explicitRelayUrls(urls) {\n    this._explicitRelayUrls = urls.map(normalizeRelayUrl);\n    this.pool.relayUrls = urls;\n  }\n  get explicitRelayUrls() {\n    return this._explicitRelayUrls || [];\n  }\n  set signatureVerificationWorker(worker2) {\n    this.asyncSigVerification = !!worker2;\n    if (worker2) {\n      signatureVerificationInit(worker2);\n    }\n  }\n  /**\n   * Adds an explicit relay to the pool.\n   * @param url\n   * @param relayAuthPolicy Authentication policy to use if different from the default\n   * @param connect Whether to connect to the relay automatically\n   * @returns\n   */\n  addExplicitRelay(urlOrRelay, relayAuthPolicy, connect = true) {\n    let relay;\n    if (typeof urlOrRelay === \"string\") {\n      relay = new NDKRelay(urlOrRelay, relayAuthPolicy, this);\n    } else {\n      relay = urlOrRelay;\n    }\n    this.pool.addRelay(relay, connect);\n    this.explicitRelayUrls?.push(relay.url);\n    return relay;\n  }\n  toJSON() {\n    return { relayCount: this.pool.relays.size }.toString();\n  }\n  get activeUser() {\n    return this._activeUser;\n  }\n  /**\n   * Sets the active user for this NDK instance, typically this will be\n   * called when assigning a signer to the NDK instance.\n   *\n   * This function will automatically connect to the user's relays if\n   * `autoConnectUserRelays` is set to true.\n   *\n   * It will also fetch the user's mutelist if `autoFetchUserMutelist` is set to true.\n   */\n  set activeUser(user) {\n    const differentUser = this._activeUser?.pubkey !== user?.pubkey;\n    this._activeUser = user;\n    if (user && differentUser) {\n      setActiveUser.call(this, user);\n    } else if (!user) {\n      this.mutedIds = /* @__PURE__ */ new Map();\n    }\n  }\n  get signer() {\n    return this._signer;\n  }\n  set signer(newSigner) {\n    this._signer = newSigner;\n    if (newSigner) this.emit(\"signer:ready\", newSigner);\n    newSigner?.user().then((user) => {\n      user.ndk = this;\n      this.activeUser = user;\n    });\n  }\n  /**\n   * Connect to relays with optional timeout.\n   * If the timeout is reached, the connection will be continued to be established in the background.\n   */\n  async connect(timeoutMs) {\n    if (this._signer && this.autoConnectUserRelays) {\n      this.debug(\n        \"Attempting to connect to user relays specified by signer %o\",\n        await this._signer.relays?.(this)\n      );\n      if (this._signer.relays) {\n        const relays = await this._signer.relays(this);\n        relays.forEach((relay) => this.pool.addRelay(relay));\n      }\n    }\n    const connections = [this.pool.connect(timeoutMs)];\n    if (this.outboxPool) {\n      connections.push(this.outboxPool.connect(timeoutMs));\n    }\n    this.debug(\"Connecting to relays %o\", { timeoutMs });\n    return Promise.allSettled(connections).then(() => {\n    });\n  }\n  /**\n   * Get a NDKUser object\n   *\n   * @param opts\n   * @returns\n   */\n  getUser(opts) {\n    const user = new NDKUser(opts);\n    user.ndk = this;\n    return user;\n  }\n  /**\n   * Get a NDKUser from a NIP05\n   * @param nip05 NIP-05 ID\n   * @param skipCache Skip cache\n   * @returns\n   */\n  async getUserFromNip05(nip05, skipCache = false) {\n    return NDKUser.fromNip05(nip05, this, skipCache);\n  }\n  /**\n   * Creates and starts a new subscription.\n   *\n   * Subscriptions automatically start unless `autoStart` is set to `false`.\n   * You can control automatic closing on EOSE via `opts.closeOnEose`.\n   *\n   * @param filters - A single NDKFilter object or an array of filters.\n   * @param opts - Optional NDKSubscriptionOptions to customize behavior (e.g., caching, grouping).\n   * @param handlers - Optional handlers for subscription events. Passing handlers is the preferred method of using ndk.subscribe.\n   *   - `onEvent`: Called for each event received.\n   *  - `onEvents`: Called once with an array of events when the subscription starts (from the cache).\n   *  - `onEose`: Called when the subscription receives EOSE.\n   *  For backwards compatibility, this third parameter also accepts a relaySet, the relaySet should be passed via `opts.relaySet`.\n   *\n   * @param _autoStart - For backwards compatibility, this can be a boolean indicating whether to start the subscription immediately.\n   *  This parameter is deprecated and will be removed in a future version.\n   *   - `false`: Creates the subscription but does not start it (call `subscription.start()` manually).\n   * @returns The created NDKSubscription instance.\n   *\n   * @example Basic subscription\n   * ```typescript\n   * const sub = ndk.subscribe({ kinds: [1], authors: [pubkey] });\n   * sub.on(\"event\", (event) => console.log(\"Kind 1 event:\", event.content));\n   * ```\n   *\n   * @example Subscription with options and direct handlers\n   * ```typescript\n   * const sub = ndk.subscribe(\n   *   { kinds: [0], authors: [pubkey] },\n   *   { closeOnEose: true, cacheUsage: NDKSubscriptionCacheUsage.PARALLEL },\n   *   undefined, // Use default relay set calculation\n   *   {\n   *     onEvents: (events) => { // Renamed parameter\n   *       if (events.length > 0) {\n   *         console.log(`Got ${events.length} profile events from cache:`, events[0].content);\n   *       }\n   *     },\n   *     onEvent: (event) => { // Renamed parameter\n   *       console.log(\"Got profile update from relay:\", event.content); // Clarified source\n   *     },\n   *     onEose: () => console.log(\"Profile subscription finished.\")\n   *   }\n   * );\n   * ```\n   *\n   * @since 2.13.0 `relaySet` parameter removed; pass `relaySet` or `relayUrls` via `opts`.\n   */\n  subscribe(filters, opts, autoStartOrRelaySet = true, _autoStart = true) {\n    let _relaySet = opts?.relaySet;\n    let autoStart = _autoStart;\n    if (autoStartOrRelaySet instanceof NDKRelaySet) {\n      console.warn(\"relaySet is deprecated, use opts.relaySet instead. This will be removed in version v2.14.0\");\n      _relaySet = autoStartOrRelaySet;\n      autoStart = _autoStart;\n    } else if (typeof autoStartOrRelaySet === \"boolean\" || typeof autoStartOrRelaySet === \"object\") {\n      autoStart = autoStartOrRelaySet;\n    }\n    const subscription = new NDKSubscription(this, filters, { relaySet: _relaySet, ...opts });\n    this.subManager.add(subscription);\n    const pool = subscription.pool;\n    if (subscription.relaySet) {\n      for (const relay of subscription.relaySet.relays) {\n        pool.useTemporaryRelay(relay, void 0, subscription.filters);\n      }\n    }\n    if (this.outboxPool && subscription.hasAuthorsFilter()) {\n      const authors = subscription.filters.filter((filter) => filter.authors && filter.authors?.length > 0).flatMap((filter) => filter.authors);\n      this.outboxTracker?.trackUsers(authors);\n    }\n    if (autoStart) {\n      let eventsHandler;\n      if (typeof autoStart === \"object\") {\n        if (autoStart.onEvent) subscription.on(\"event\", autoStart.onEvent);\n        if (autoStart.onEose) subscription.on(\"eose\", autoStart.onEose);\n        if (autoStart.onEvents) eventsHandler = autoStart.onEvents;\n      }\n      setTimeout(() => {\n        const cachedEvents = subscription.start(!eventsHandler);\n        if (cachedEvents && cachedEvents.length > 0 && !!eventsHandler) eventsHandler(cachedEvents);\n      }, 0);\n    }\n    return subscription;\n  }\n  /**\n   * Publish an event to a relay\n   * @param event event to publish\n   * @param relaySet explicit relay set to use\n   * @param timeoutMs timeout in milliseconds to wait for the event to be published\n   * @returns The relays the event was published to\n   *\n   * @deprecated Use `event.publish()` instead\n   */\n  async publish(event, relaySet, timeoutMs) {\n    this.debug(\"Deprecated: Use `event.publish()` instead\");\n    return event.publish(relaySet, timeoutMs);\n  }\n  /**\n   * Attempts to fetch an event from a tag, following relay hints and\n   * other best practices.\n   * @param tag Tag to fetch the event from\n   * @param originalEvent Event where the tag came from\n   * @param subOpts Subscription options to use when fetching the event\n   * @param fallback Fallback options to use when the hint relay doesn't respond\n   * @returns\n   */\n  fetchEventFromTag = fetchEventFromTag.bind(this);\n  /**\n   * Fetch an event from the cache synchronously.\n   * @param idOrFilter event id in bech32 format or filter\n   * @returns events from the cache or null if the cache is empty\n   */\n  fetchEventSync(idOrFilter) {\n    if (!this.cacheAdapter) throw new Error(\"Cache adapter not set\");\n    let filters;\n    if (typeof idOrFilter === \"string\") filters = [filterFromId(idOrFilter)];\n    else filters = idOrFilter;\n    const sub = new NDKSubscription(this, filters);\n    const events = this.cacheAdapter.query(sub);\n    if (events instanceof Promise) throw new Error(\"Cache adapter is async\");\n    return events.map((e) => {\n      e.ndk = this;\n      return e;\n    });\n  }\n  /**\n   * Fetch a single event.\n   *\n   * @param idOrFilter event id in bech32 format or filter\n   * @param opts subscription options\n   * @param relaySetOrRelay explicit relay set to use\n   */\n  async fetchEvent(idOrFilter, opts, relaySetOrRelay) {\n    let filters;\n    let relaySet;\n    if (relaySetOrRelay instanceof NDKRelay) {\n      relaySet = new NDKRelaySet(/* @__PURE__ */ new Set([relaySetOrRelay]), this);\n    } else if (relaySetOrRelay instanceof NDKRelaySet) {\n      relaySet = relaySetOrRelay;\n    }\n    if (!relaySetOrRelay && typeof idOrFilter === \"string\") {\n      if (!isNip33AValue(idOrFilter)) {\n        const relays = relaysFromBech32(idOrFilter, this);\n        if (relays.length > 0) {\n          relaySet = new NDKRelaySet(new Set(relays), this);\n          relaySet = correctRelaySet(relaySet, this.pool);\n        }\n      }\n    }\n    if (typeof idOrFilter === \"string\") {\n      filters = [filterFromId(idOrFilter)];\n    } else if (Array.isArray(idOrFilter)) {\n      filters = idOrFilter;\n    } else {\n      filters = [idOrFilter];\n    }\n    if (filters.length === 0) {\n      throw new Error(`Invalid filter: ${JSON.stringify(idOrFilter)}`);\n    }\n    return new Promise((resolve) => {\n      let fetchedEvent = null;\n      const subscribeOpts = {\n        ...opts || {},\n        closeOnEose: true\n      };\n      if (relaySet) subscribeOpts.relaySet = relaySet;\n      const s = this.subscribe(\n        filters,\n        subscribeOpts,\n        // relaySet, // Removed: Passed via opts\n        false\n        // autoStart = false\n      );\n      const t2 = setTimeout(() => {\n        s.stop();\n        resolve(fetchedEvent);\n      }, 1e4);\n      s.on(\"event\", (event) => {\n        event.ndk = this;\n        if (!event.isReplaceable()) {\n          clearTimeout(t2);\n          resolve(event);\n        } else if (!fetchedEvent || fetchedEvent.created_at < event.created_at) {\n          fetchedEvent = event;\n        }\n      });\n      s.on(\"eose\", () => {\n        clearTimeout(t2);\n        resolve(fetchedEvent);\n      });\n      s.start();\n    });\n  }\n  /**\n   * Fetch events\n   */\n  async fetchEvents(filters, opts, relaySet) {\n    return new Promise((resolve) => {\n      const events = /* @__PURE__ */ new Map();\n      const subscribeOpts = {\n        ...opts || {},\n        closeOnEose: true\n      };\n      if (relaySet) subscribeOpts.relaySet = relaySet;\n      const relaySetSubscription = this.subscribe(\n        filters,\n        subscribeOpts,\n        // relaySet, // Removed: Passed via opts\n        false\n        // autoStart = false\n      );\n      const onEvent = (event) => {\n        let _event;\n        if (!(event instanceof NDKEvent)) _event = new NDKEvent(void 0, event);\n        else _event = event;\n        const dedupKey = _event.deduplicationKey();\n        const existingEvent = events.get(dedupKey);\n        if (existingEvent) {\n          _event = dedup(existingEvent, _event);\n        }\n        _event.ndk = this;\n        events.set(dedupKey, _event);\n      };\n      relaySetSubscription.on(\"event\", onEvent);\n      relaySetSubscription.on(\"eose\", () => {\n        resolve(new Set(events.values()));\n      });\n      relaySetSubscription.start();\n    });\n  }\n  /**\n   * Ensures that a signer is available to sign an event.\n   */\n  assertSigner() {\n    if (!this.signer) {\n      this.emit(\"signer:required\");\n      throw new Error(\"Signer required\");\n    }\n  }\n  getEntity = getEntity.bind(this);\n  set wallet(wallet) {\n    if (!wallet) {\n      this.walletConfig = void 0;\n      return;\n    }\n    this.walletConfig ??= {};\n    this.walletConfig.lnPay = wallet?.lnPay?.bind(wallet);\n    this.walletConfig.cashuPay = wallet?.cashuPay?.bind(wallet);\n  }\n};\n\n// src/zap/invoice.ts\n\nfunction zapInvoiceFromEvent(event) {\n  const description = event.getMatchingTags(\"description\")[0];\n  const bolt11 = event.getMatchingTags(\"bolt11\")[0];\n  let decodedInvoice;\n  let zapRequest;\n  if (!description || !bolt11 || !bolt11[1]) {\n    return null;\n  }\n  try {\n    let zapRequestPayload = description[1];\n    if (zapRequestPayload.startsWith(\"%\")) {\n      zapRequestPayload = decodeURIComponent(zapRequestPayload);\n    }\n    if (zapRequestPayload === \"\") {\n      return null;\n    }\n    zapRequest = JSON.parse(zapRequestPayload);\n    decodedInvoice = (0,light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_7__.decode)(bolt11[1]);\n  } catch (_e) {\n    return null;\n  }\n  const amountSection = decodedInvoice.sections.find((s) => s.name === \"amount\");\n  if (!amountSection) {\n    return null;\n  }\n  const amount = Number.parseInt(amountSection.value);\n  if (!amount) {\n    return null;\n  }\n  const content = zapRequest.content;\n  const sender = zapRequest.pubkey;\n  const recipientTag = event.getMatchingTags(\"p\")[0];\n  const recipient = recipientTag[1];\n  let zappedEvent = event.getMatchingTags(\"e\")[0];\n  if (!zappedEvent) {\n    zappedEvent = event.getMatchingTags(\"a\")[0];\n  }\n  const zappedEventId = zappedEvent ? zappedEvent[1] : void 0;\n  const zapInvoice = {\n    id: event.id,\n    zapper: event.pubkey,\n    zappee: sender,\n    zapped: recipient,\n    zappedEvent: zappedEventId,\n    amount,\n    comment: content\n  };\n  return zapInvoice;\n}\n\n// src/zapper/index.ts\n\n\n\n// src/zapper/ln.ts\n\n\nvar d2 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:zapper:ln\");\nasync function getNip57ZapSpecFromLud({ lud06, lud16 }, ndk) {\n  let zapEndpoint;\n  if (lud16 && !lud16.startsWith(\"LNURL\")) {\n    const [name, domain] = lud16.split(\"@\");\n    zapEndpoint = `https://${domain}/.well-known/lnurlp/${name}`;\n  } else if (lud06) {\n    const { words } = _scure_base__WEBPACK_IMPORTED_MODULE_8__.bech32.decode(lud06, 1e3);\n    const data = _scure_base__WEBPACK_IMPORTED_MODULE_8__.bech32.fromWords(words);\n    const utf8Decoder = new TextDecoder(\"utf-8\");\n    zapEndpoint = utf8Decoder.decode(data);\n  }\n  if (!zapEndpoint) {\n    d2(\"No zap endpoint found %o\", { lud06, lud16 });\n    throw new Error(\"No zap endpoint found\");\n  }\n  try {\n    const _fetch = ndk.httpFetch || fetch;\n    const response = await _fetch(zapEndpoint);\n    if (response.status !== 200) {\n      const text = await response.text();\n      throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${text}`);\n    }\n    return await response.json();\n  } catch (e) {\n    throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${e}`);\n  }\n}\n\n// src/zapper/nip57.ts\n\nasync function generateZapRequest(target, ndk, data, pubkey, amount, relays, comment, tags, signer) {\n  const zapEndpoint = data.callback;\n  const zapRequest = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip57.makeZapRequest({\n    profile: pubkey,\n    // set the event to null since nostr-tools doesn't support nip-33 zaps\n    event: null,\n    amount,\n    comment: comment || \"\",\n    relays: relays.slice(0, 4)\n  });\n  if (target instanceof NDKEvent) {\n    const tags2 = target.referenceTags();\n    const nonPTags = tags2.filter((tag) => tag[0] !== \"p\");\n    zapRequest.tags.push(...nonPTags);\n  }\n  zapRequest.tags.push([\"lnurl\", zapEndpoint]);\n  const event = new NDKEvent(ndk, zapRequest);\n  if (tags) {\n    event.tags = event.tags.concat(tags);\n  }\n  const eTaggedEvents = /* @__PURE__ */ new Set();\n  const aTaggedEvents = /* @__PURE__ */ new Set();\n  for (const tag of event.tags) {\n    if (tag[0] === \"e\") {\n      eTaggedEvents.add(tag[1]);\n    } else if (tag[0] === \"a\") {\n      aTaggedEvents.add(tag[1]);\n    }\n  }\n  if (eTaggedEvents.size > 1) throw new Error(\"Only one e-tag is allowed\");\n  if (aTaggedEvents.size > 1) throw new Error(\"Only one a-tag is allowed\");\n  event.tags = event.tags.filter((tag) => tag[0] !== \"p\");\n  event.tags.push([\"p\", pubkey]);\n  await event.sign(signer);\n  return event;\n}\n\n// src/zapper/index.ts\nvar d3 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:zapper\");\nvar NDKZapper = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  target;\n  ndk;\n  comment;\n  amount;\n  unit;\n  tags;\n  signer;\n  zapMethod;\n  nutzapAsFallback;\n  lnPay;\n  /**\n   * Called when a cashu payment is to be made.\n   * This function should swap/mint proofs for the required amount, in the required unit,\n   * in any of the provided mints and return the proofs and mint used.\n   */\n  cashuPay;\n  onComplete;\n  maxRelays = 3;\n  /**\n   *\n   * @param target The target of the zap\n   * @param amount The amount to send indicated in the unit\n   * @param unit The unit of the amount\n   * @param opts Options for the zap\n   */\n  constructor(target, amount, unit = \"msat\", opts = {}) {\n    super();\n    this.target = target;\n    this.ndk = opts.ndk || target.ndk;\n    if (!this.ndk) {\n      throw new Error(\"No NDK instance provided\");\n    }\n    this.amount = amount;\n    this.comment = opts.comment;\n    this.unit = unit;\n    this.tags = opts.tags;\n    this.signer = opts.signer;\n    this.nutzapAsFallback = opts.nutzapAsFallback ?? false;\n    this.lnPay = opts.lnPay || this.ndk.walletConfig?.lnPay;\n    this.cashuPay = opts.cashuPay || this.ndk.walletConfig?.cashuPay;\n    this.onComplete = opts.onComplete || this.ndk.walletConfig?.onPaymentComplete;\n  }\n  /**\n   * Initiate zapping process\n   *\n   * This function will calculate the splits for this zap and initiate each zap split.\n   */\n  async zap(methods) {\n    const splits = this.getZapSplits();\n    const results = /* @__PURE__ */ new Map();\n    await Promise.all(\n      splits.map(async (split) => {\n        let result;\n        try {\n          result = await this.zapSplit(split, methods);\n        } catch (e) {\n          result = new Error(e.message);\n        }\n        this.emit(\"split:complete\", split, result);\n        results.set(split, result);\n      })\n    );\n    this.emit(\"complete\", results);\n    if (this.onComplete) this.onComplete(results);\n    return results;\n  }\n  async zapNip57(split, data) {\n    if (!this.lnPay) throw new Error(\"No lnPay function available\");\n    const zapSpec = await getNip57ZapSpecFromLud(data, this.ndk);\n    if (!zapSpec) throw new Error(\"No zap spec available for recipient\");\n    const relays = await this.relays(split.pubkey);\n    const zapRequest = await generateZapRequest(\n      this.target,\n      this.ndk,\n      zapSpec,\n      split.pubkey,\n      split.amount,\n      relays,\n      this.comment,\n      this.tags,\n      this.signer\n    );\n    if (!zapRequest) {\n      d3(\"Unable to generate zap request\");\n      throw new Error(\"Unable to generate zap request\");\n    }\n    const pr = await this.getLnInvoice(zapRequest, split.amount, zapSpec);\n    if (!pr) {\n      d3(\"Unable to get payment request\");\n      throw new Error(\"Unable to get payment request\");\n    }\n    this.emit(\"ln_invoice\", {\n      amount: split.amount,\n      recipientPubkey: split.pubkey,\n      unit: this.unit,\n      nip57ZapRequest: zapRequest,\n      pr,\n      type: \"nip57\"\n    });\n    const res = await this.lnPay({\n      target: this.target,\n      recipientPubkey: split.pubkey,\n      paymentDescription: \"NIP-57 Zap\",\n      pr,\n      amount: split.amount,\n      unit: this.unit,\n      nip57ZapRequest: zapRequest\n    });\n    if (res?.preimage) {\n      this.emit(\"ln_payment\", {\n        preimage: res.preimage,\n        amount: split.amount,\n        recipientPubkey: split.pubkey,\n        pr,\n        unit: this.unit,\n        nip57ZapRequest: zapRequest,\n        type: \"nip57\"\n      });\n    }\n    return res;\n  }\n  /**\n   * Fetches information about a NIP-61 zap and asks the caller to create cashu proofs for the zap.\n   *\n   * (note that the cashuPay function can use any method to create the proofs, including using lightning\n   * to mint proofs in the specified mint, the responsibility of minting the proofs is delegated to the caller (e.g. ndk-wallet))\n   */\n  async zapNip61(split, data) {\n    if (!this.cashuPay) throw new Error(\"No cashuPay function available\");\n    let ret;\n    ret = await this.cashuPay(\n      {\n        target: this.target,\n        recipientPubkey: split.pubkey,\n        paymentDescription: \"NIP-61 Zap\",\n        amount: split.amount,\n        unit: this.unit,\n        ...data ?? {}\n      },\n      (pr) => {\n        this.emit(\"ln_invoice\", {\n          pr,\n          amount: split.amount,\n          recipientPubkey: split.pubkey,\n          unit: this.unit,\n          type: \"nip61\"\n        });\n      }\n    );\n    d3(\"NIP-61 Zap result: %o\", ret);\n    if (ret instanceof Error) {\n      return ret;\n    }\n    if (ret) {\n      const { proofs, mint } = ret;\n      if (!proofs || !mint) throw new Error(`Invalid zap confirmation: missing proofs or mint: ${ret}`);\n      const relays = await this.relays(split.pubkey);\n      const relaySet = NDKRelaySet.fromRelayUrls(relays, this.ndk);\n      const nutzap = new NDKNutzap(this.ndk);\n      nutzap.tags = [...nutzap.tags, ...this.tags || []];\n      nutzap.proofs = proofs;\n      nutzap.mint = mint;\n      nutzap.target = this.target;\n      nutzap.comment = this.comment;\n      nutzap.unit = \"sat\";\n      nutzap.recipientPubkey = split.pubkey;\n      await nutzap.sign(this.signer);\n      nutzap.publish(relaySet);\n      return nutzap;\n    }\n  }\n  /**\n   * Get the zap methods available for the recipient and initiates the zap\n   * in the desired method.\n   * @param split\n   * @param methods - The methods to try, if not provided, all methods will be tried.\n   * @returns\n   */\n  async zapSplit(split, methods) {\n    const recipient = this.ndk.getUser({ pubkey: split.pubkey });\n    const zapMethods = await recipient.getZapInfo(2500);\n    let retVal;\n    const canFallbackToNip61 = this.nutzapAsFallback && this.cashuPay;\n    if (zapMethods.size === 0 && !canFallbackToNip61)\n      throw new Error(\"No zap method available for recipient and NIP-61 fallback is disabled\");\n    const nip61Fallback = async () => {\n      if (!this.nutzapAsFallback) return;\n      const relayLists = await getRelayListForUsers([split.pubkey], this.ndk);\n      let relayUrls = relayLists.get(split.pubkey)?.readRelayUrls;\n      relayUrls = this.ndk.pool.connectedRelays().map((r) => r.url);\n      return await this.zapNip61(split, {\n        // use the user's relay list\n        relays: relayUrls,\n        // lock to the user's actual pubkey\n        p2pk: split.pubkey,\n        // allow intramint fallback\n        allowIntramintFallback: !!canFallbackToNip61\n      });\n    };\n    const canUseNip61 = !methods || methods.includes(\"nip61\");\n    const canUseNip57 = !methods || methods.includes(\"nip57\");\n    const nip61Method = zapMethods.get(\"nip61\");\n    if (nip61Method && canUseNip61) {\n      try {\n        retVal = await this.zapNip61(split, nip61Method);\n        if (retVal instanceof NDKNutzap) return retVal;\n      } catch (e) {\n        this.emit(\"notice\", `NIP-61 attempt failed: ${e.message}`);\n      }\n    }\n    const nip57Method = zapMethods.get(\"nip57\");\n    if (nip57Method && canUseNip57) {\n      try {\n        retVal = await this.zapNip57(split, nip57Method);\n        if (!(retVal instanceof Error)) return retVal;\n      } catch (e) {\n        this.emit(\"notice\", `NIP-57 attempt failed: ${e.message}`);\n      }\n    }\n    if (canFallbackToNip61) {\n      retVal = await nip61Fallback();\n      if (retVal instanceof Error) throw retVal;\n      return retVal;\n    }\n    this.emit(\"notice\", \"Zap methods exhausted and there was no fallback to NIP-61\");\n    if (retVal instanceof Error) throw retVal;\n    return retVal;\n  }\n  /**\n   * Gets a bolt11 for a nip57 zap\n   * @param event\n   * @param amount\n   * @param zapEndpoint\n   * @returns\n   */\n  async getLnInvoice(zapRequest, amount, data) {\n    const zapEndpoint = data.callback;\n    const eventPayload = JSON.stringify(zapRequest.rawEvent());\n    d3(\n      `Fetching invoice from ${zapEndpoint}?${new URLSearchParams({\n        amount: amount.toString(),\n        nostr: eventPayload\n      })}`\n    );\n    const url = new URL(zapEndpoint);\n    url.searchParams.append(\"amount\", amount.toString());\n    url.searchParams.append(\"nostr\", eventPayload);\n    d3(`Fetching invoice from ${url.toString()}`);\n    const response = await fetch(url.toString());\n    d3(`Got response from zap endpoint: ${zapEndpoint}`, { status: response.status });\n    if (response.status !== 200) {\n      d3(`Received non-200 status from zap endpoint: ${zapEndpoint}`, {\n        status: response.status,\n        amount,\n        nostr: eventPayload\n      });\n      const text = await response.text();\n      throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${text}`);\n    }\n    const body = await response.json();\n    return body.pr;\n  }\n  getZapSplits() {\n    if (this.target instanceof NDKUser) {\n      return [\n        {\n          pubkey: this.target.pubkey,\n          amount: this.amount\n        }\n      ];\n    }\n    const zapTags = this.target.getMatchingTags(\"zap\");\n    if (zapTags.length === 0) {\n      return [\n        {\n          pubkey: this.target.pubkey,\n          amount: this.amount\n        }\n      ];\n    }\n    const splits = [];\n    const total = zapTags.reduce((acc, tag) => acc + Number.parseInt(tag[2]), 0);\n    for (const tag of zapTags) {\n      const pubkey = tag[1];\n      const amount = Math.floor(Number.parseInt(tag[2]) / total * this.amount);\n      splits.push({ pubkey, amount });\n    }\n    return splits;\n  }\n  /**\n   * Gets the zap method that should be used to zap a pubbkey\n   * @param ndk\n   * @param pubkey\n   * @returns\n   */\n  async getZapMethods(ndk, recipient, timeout = 2500) {\n    const user = ndk.getUser({ pubkey: recipient });\n    return await user.getZapInfo(timeout);\n  }\n  /**\n   * @returns the relays to use for the zap request\n   */\n  async relays(pubkey) {\n    let r = [];\n    if (this.ndk?.activeUser) {\n      const relayLists = await getRelayListForUsers([this.ndk.activeUser.pubkey, pubkey], this.ndk);\n      const relayScores = /* @__PURE__ */ new Map();\n      for (const relayList of relayLists.values()) {\n        for (const url of relayList.readRelayUrls) {\n          const score = relayScores.get(url) || 0;\n          relayScores.set(url, score + 1);\n        }\n      }\n      r = Array.from(relayScores.entries()).sort((a, b) => b[1] - a[1]).map(([url]) => url).slice(0, this.maxRelays);\n    }\n    if (this.ndk?.pool?.permanentAndConnectedRelays().length) {\n      r = this.ndk.pool.permanentAndConnectedRelays().map((relay) => relay.url);\n    }\n    if (!r.length) {\n      r = [];\n    }\n    return r;\n  }\n};\n\n// src/utils/filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    return false;\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {\n    return false;\n  }\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    return false;\n  }\n  for (const f in filter) {\n    if (f[0] === \"#\") {\n      const tagName = f.slice(1);\n      if (tagName === \"t\") {\n        const values = filter[`#${tagName}`]?.map((v) => v.toLowerCase());\n        if (values && !event.tags.find(([t, v]) => t === tagName && values?.indexOf(v.toLowerCase()) !== -1))\n          return false;\n      } else {\n        const values = filter[`#${tagName}`];\n        if (values && !event.tags.find(([t, v]) => t === tagName && values?.indexOf(v) !== -1)) return false;\n      }\n    }\n  }\n  if (filter.since && event.created_at < filter.since) return false;\n  if (filter.until && event.created_at > filter.until) return false;\n  return true;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLLGFBQWEsS0FBSztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzBCO0FBQ1c7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxHQUFHO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sK0NBQStDLGtCQUFrQixJQUFJLGNBQWM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQ0FBSyxjQUFjLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVUsSUFBSSxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsdUZBQXVGLFVBQVU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxVQUFVO0FBQzdFO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0NBQWtDLG1DQUFtQztBQUNyRTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQ0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ29DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWEsRUFBRSw4Q0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkMsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscUJBQXFCO0FBQ25ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzhDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVyw4Q0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxTQUFTLDhDQUFNO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDc0Q7QUFDdEQsNEJBQTRCLCtDQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVMsd0JBQXdCLE1BQU07QUFDckY7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxVQUFVO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxlQUFlO0FBQzlCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0IsUUFBUSx5QkFBeUIsVUFBVSxVQUFVO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EscURBQXFELFVBQVU7QUFDL0QsU0FBUztBQUNUO0FBQ0E7QUFDQSxxREFBcUQsVUFBVSxJQUFJLDJCQUEyQjtBQUM5RixXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVcsS0FBSyxlQUFlO0FBQ2xFO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLLEVBQUUsRUFBRTtBQUM3QjtBQUNBLE1BQU07QUFDTixrQkFBa0IsS0FBSyxFQUFFLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsdUJBQXVCLEtBQUssR0FBRyxPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxrQ0FBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRCx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjtBQUM1QjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtDQUFrQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkNBQTJDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhDQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0IsR0FBRyxvQkFBb0IsR0FBRyx3QkFBd0I7QUFDeEY7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQU07QUFDdEI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4Q0FBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQ0FBaUM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtDQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxtQ0FBbUM7QUFDckY7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLCtCQUErQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPLEdBQUcsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5REFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2lDO0FBQ2pDLGFBQWEsa0NBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsa0NBQVk7QUFDckIsOEJBQThCLCtDQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QixpR0FBaUcsSUFBSTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHNCQUFzQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0RBQXNELFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0RBQXNELFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWSxHQUFHO0FBQzlDO0FBQ0E7QUFDQSxPQUFPLEVBQUU7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0EsMENBQTBDLFlBQVksS0FBSyx5QkFBeUI7QUFDcEY7QUFDQSx1REFBdUQsWUFBWTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzREFBc0QsWUFBWSxJQUFJLEtBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXFIRSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhYmxvZmVybmFuZGV6L3Rlc3QxMjMvVEVORVgtcGZrbWM5L21haW4vbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay1jYWNoZS1kZXhpZS9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy90eXBlcy50c1xudmFyIE5ka051dHphcFN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ka051dHphcFN0YXR1czIpID0+IHtcbiAgTmRrTnV0emFwU3RhdHVzMltcIklOSVRJQUxcIl0gPSBcImluaXRpYWxcIjtcbiAgTmRrTnV0emFwU3RhdHVzMltcIlBST0NFU1NJTkdcIl0gPSBcInByb2Nlc3NpbmdcIjtcbiAgTmRrTnV0emFwU3RhdHVzMltcIlJFREVFTUVEXCJdID0gXCJyZWRlZW1lZFwiO1xuICBOZGtOdXR6YXBTdGF0dXMyW1wiU1BFTlRcIl0gPSBcInNwZW50XCI7XG4gIE5ka051dHphcFN0YXR1czJbXCJNSVNTSU5HX1BSSVZLRVlcIl0gPSBcIm1pc3NpbmdfcHJpdmtleVwiO1xuICBOZGtOdXR6YXBTdGF0dXMyW1wiVEVNUE9SQVJZX0VSUk9SXCJdID0gXCJ0ZW1wb3JhcnlfZXJyb3JcIjtcbiAgTmRrTnV0emFwU3RhdHVzMltcIlBFUk1BTkVOVF9FUlJPUlwiXSA9IFwicGVybWFuZW50X2Vycm9yXCI7XG4gIE5ka051dHphcFN0YXR1czJbXCJJTlZBTElEX05VVFpBUFwiXSA9IFwiaW52YWxpZF9udXR6YXBcIjtcbiAgcmV0dXJuIE5ka051dHphcFN0YXR1czI7XG59KShOZGtOdXR6YXBTdGF0dXMgfHwge30pO1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2luZGV4LnRzXG52YXIgTkRLS2luZCA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ES0tpbmQyKSA9PiB7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTWV0YWRhdGFcIl0gPSAwXSA9IFwiTWV0YWRhdGFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJUZXh0XCJdID0gMV0gPSBcIlRleHRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJSZWNvbW1lbmRSZWxheVwiXSA9IDJdID0gXCJSZWNvbW1lbmRSZWxheVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNvbnRhY3RzXCJdID0gM10gPSBcIkNvbnRhY3RzXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRW5jcnlwdGVkRGlyZWN0TWVzc2FnZVwiXSA9IDRdID0gXCJFbmNyeXB0ZWREaXJlY3RNZXNzYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRXZlbnREZWxldGlvblwiXSA9IDVdID0gXCJFdmVudERlbGV0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUmVwb3N0XCJdID0gNl0gPSBcIlJlcG9zdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlJlYWN0aW9uXCJdID0gN10gPSBcIlJlYWN0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQmFkZ2VBd2FyZFwiXSA9IDhdID0gXCJCYWRnZUF3YXJkXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBDaGF0XCJdID0gOV0gPSBcIkdyb3VwQ2hhdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwTm90ZVwiXSA9IDExXSA9IFwiR3JvdXBOb3RlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBSZXBseVwiXSA9IDEyXSA9IFwiR3JvdXBSZXBseVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdpZnRXcmFwU2VhbFwiXSA9IDEzXSA9IFwiR2lmdFdyYXBTZWFsXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUHJpdmF0ZURpcmVjdE1lc3NhZ2VcIl0gPSAxNF0gPSBcIlByaXZhdGVEaXJlY3RNZXNzYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSW1hZ2VcIl0gPSAyMF0gPSBcIkltYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiVmlkZW9cIl0gPSAyMV0gPSBcIlZpZGVvXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU2hvcnRWaWRlb1wiXSA9IDIyXSA9IFwiU2hvcnRWaWRlb1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlN0b3J5XCJdID0gMjNdID0gXCJTdG9yeVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlZhbmlzaFwiXSA9IDYyXSA9IFwiVmFuaXNoXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVXYWxsZXRCYWNrdXBcIl0gPSAzNzVdID0gXCJDYXNodVdhbGxldEJhY2t1cFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdpZnRXcmFwXCJdID0gMTA1OV0gPSBcIkdpZnRXcmFwXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR2VuZXJpY1JlcG9zdFwiXSA9IDE2XSA9IFwiR2VuZXJpY1JlcG9zdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNoYW5uZWxDcmVhdGlvblwiXSA9IDQwXSA9IFwiQ2hhbm5lbENyZWF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2hhbm5lbE1ldGFkYXRhXCJdID0gNDFdID0gXCJDaGFubmVsTWV0YWRhdGFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDaGFubmVsTWVzc2FnZVwiXSA9IDQyXSA9IFwiQ2hhbm5lbE1lc3NhZ2VcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDaGFubmVsSGlkZU1lc3NhZ2VcIl0gPSA0M10gPSBcIkNoYW5uZWxIaWRlTWVzc2FnZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNoYW5uZWxNdXRlVXNlclwiXSA9IDQ0XSA9IFwiQ2hhbm5lbE11dGVVc2VyXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiV2lraU1lcmdlUmVxdWVzdFwiXSA9IDgxOF0gPSBcIldpa2lNZXJnZVJlcXVlc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHZW5lcmljUmVwbHlcIl0gPSAxMTExXSA9IFwiR2VuZXJpY1JlcGx5XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTWVkaWFcIl0gPSAxMDYzXSA9IFwiTWVkaWFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJSZXBvcnRcIl0gPSAxOTg0XSA9IFwiUmVwb3J0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTGFiZWxcIl0gPSAxOTg1XSA9IFwiTGFiZWxcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFUZXh0RXh0cmFjdGlvblwiXSA9IDVlM10gPSBcIkRWTVJlcVRleHRFeHRyYWN0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxVGV4dFN1bW1hcml6YXRpb25cIl0gPSA1MDAxXSA9IFwiRFZNUmVxVGV4dFN1bW1hcml6YXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFUZXh0VHJhbnNsYXRpb25cIl0gPSA1MDAyXSA9IFwiRFZNUmVxVGV4dFRyYW5zbGF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxVGV4dEdlbmVyYXRpb25cIl0gPSA1MDUwXSA9IFwiRFZNUmVxVGV4dEdlbmVyYXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFJbWFnZUdlbmVyYXRpb25cIl0gPSA1MTAwXSA9IFwiRFZNUmVxSW1hZ2VHZW5lcmF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxVGV4dFRvU3BlZWNoXCJdID0gNTI1MF0gPSBcIkRWTVJlcVRleHRUb1NwZWVjaFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcURpc2NvdmVyeU5vc3RyQ29udGVudFwiXSA9IDUzMDBdID0gXCJEVk1SZXFEaXNjb3ZlcnlOb3N0ckNvbnRlbnRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFEaXNjb3ZlcnlOb3N0clBlb3BsZVwiXSA9IDUzMDFdID0gXCJEVk1SZXFEaXNjb3ZlcnlOb3N0clBlb3BsZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcVRpbWVzdGFtcGluZ1wiXSA9IDU5MDBdID0gXCJEVk1SZXFUaW1lc3RhbXBpbmdcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1FdmVudFNjaGVkdWxlXCJdID0gNTkwNV0gPSBcIkRWTUV2ZW50U2NoZWR1bGVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1Kb2JGZWVkYmFja1wiXSA9IDdlM10gPSBcIkRWTUpvYkZlZWRiYWNrXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU3Vic2NyaWJlXCJdID0gNzAwMV0gPSBcIlN1YnNjcmliZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlVuc3Vic2NyaWJlXCJdID0gNzAwMl0gPSBcIlVuc3Vic2NyaWJlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU3Vic2NyaXB0aW9uUmVjZWlwdFwiXSA9IDcwMDNdID0gXCJTdWJzY3JpcHRpb25SZWNlaXB0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVSZXNlcnZlXCJdID0gNzM3M10gPSBcIkNhc2h1UmVzZXJ2ZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhc2h1UXVvdGVcIl0gPSA3Mzc0XSA9IFwiQ2FzaHVRdW90ZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhc2h1VG9rZW5cIl0gPSA3Mzc1XSA9IFwiQ2FzaHVUb2tlblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhc2h1V2FsbGV0VHhcIl0gPSA3Mzc2XSA9IFwiQ2FzaHVXYWxsZXRUeFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5BZGRVc2VyXCJdID0gOWUzXSA9IFwiR3JvdXBBZG1pbkFkZFVzZXJcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cEFkbWluUmVtb3ZlVXNlclwiXSA9IDkwMDFdID0gXCJHcm91cEFkbWluUmVtb3ZlVXNlclwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5FZGl0TWV0YWRhdGFcIl0gPSA5MDAyXSA9IFwiR3JvdXBBZG1pbkVkaXRNZXRhZGF0YVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5FZGl0U3RhdHVzXCJdID0gOTAwNl0gPSBcIkdyb3VwQWRtaW5FZGl0U3RhdHVzXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pbkNyZWF0ZUdyb3VwXCJdID0gOTAwN10gPSBcIkdyb3VwQWRtaW5DcmVhdGVHcm91cFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5SZXF1ZXN0Sm9pblwiXSA9IDkwMjFdID0gXCJHcm91cEFkbWluUmVxdWVzdEpvaW5cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNdXRlTGlzdFwiXSA9IDFlNF0gPSBcIk11dGVMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUGluTGlzdFwiXSA9IDEwMDAxXSA9IFwiUGluTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlJlbGF5TGlzdFwiXSA9IDEwMDAyXSA9IFwiUmVsYXlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQm9va21hcmtMaXN0XCJdID0gMTAwMDNdID0gXCJCb29rbWFya0xpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDb21tdW5pdHlMaXN0XCJdID0gMTAwMDRdID0gXCJDb21tdW5pdHlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUHVibGljQ2hhdExpc3RcIl0gPSAxMDAwNV0gPSBcIlB1YmxpY0NoYXRMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQmxvY2tSZWxheUxpc3RcIl0gPSAxMDAwNl0gPSBcIkJsb2NrUmVsYXlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU2VhcmNoUmVsYXlMaXN0XCJdID0gMTAwMDddID0gXCJTZWFyY2hSZWxheUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJTaW1wbGVHcm91cExpc3RcIl0gPSAxMDAwOV0gPSBcIlNpbXBsZUdyb3VwTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkludGVyZXN0TGlzdFwiXSA9IDEwMDE1XSA9IFwiSW50ZXJlc3RMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVNaW50TGlzdFwiXSA9IDEwMDE5XSA9IFwiQ2FzaHVNaW50TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkVtb2ppTGlzdFwiXSA9IDEwMDMwXSA9IFwiRW1vamlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRGlyZWN0TWVzc2FnZVJlY2VpdmVSZWxheUxpc3RcIl0gPSAxMDA1MF0gPSBcIkRpcmVjdE1lc3NhZ2VSZWNlaXZlUmVsYXlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQmxvc3NvbUxpc3RcIl0gPSAxMDA2M10gPSBcIkJsb3Nzb21MaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTm9zdHJXYWxldENvbm5lY3RJbmZvXCJdID0gMTMxOTRdID0gXCJOb3N0cldhbGV0Q29ubmVjdEluZm9cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJUaWVyTGlzdFwiXSA9IDE3ZTNdID0gXCJUaWVyTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhc2h1V2FsbGV0XCJdID0gMTczNzVdID0gXCJDYXNodVdhbGxldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkZvbGxvd1NldFwiXSA9IDNlNF0gPSBcIkZvbGxvd1NldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhdGVnb3JpemVkUGVvcGxlTGlzdFwiXSA9IDNlNCAvKiBGb2xsb3dTZXQgKi9dID0gXCJDYXRlZ29yaXplZFBlb3BsZUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXRlZ29yaXplZEJvb2ttYXJrTGlzdFwiXSA9IDMwMDAxXSA9IFwiQ2F0ZWdvcml6ZWRCb29rbWFya0xpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJSZWxheVNldFwiXSA9IDMwMDAyXSA9IFwiUmVsYXlTZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXRlZ29yaXplZFJlbGF5TGlzdFwiXSA9IDMwMDAyIC8qIFJlbGF5U2V0ICovXSA9IFwiQ2F0ZWdvcml6ZWRSZWxheUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCb29rbWFya1NldFwiXSA9IDMwMDAzXSA9IFwiQm9va21hcmtTZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDdXJhdGlvblNldFwiXSA9IDMwMDA0XSA9IFwiQ3VyYXRpb25TZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJBcnRpY2xlQ3VyYXRpb25TZXRcIl0gPSAzMDAwNF0gPSBcIkFydGljbGVDdXJhdGlvblNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlZpZGVvQ3VyYXRpb25TZXRcIl0gPSAzMDAwNV0gPSBcIlZpZGVvQ3VyYXRpb25TZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJJbWFnZUN1cmF0aW9uU2V0XCJdID0gMzAwMDZdID0gXCJJbWFnZUN1cmF0aW9uU2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSW50ZXJlc3RTZXRcIl0gPSAzMDAxNV0gPSBcIkludGVyZXN0U2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSW50ZXJlc3RzTGlzdFwiXSA9IDMwMDE1IC8qIEludGVyZXN0U2V0ICovXSA9IFwiSW50ZXJlc3RzTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkVtb2ppU2V0XCJdID0gMzAwMzBdID0gXCJFbW9qaVNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk1vZHVsYXJBcnRpY2xlXCJdID0gMzAwNDBdID0gXCJNb2R1bGFyQXJ0aWNsZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk1vZHVsYXJBcnRpY2xlSXRlbVwiXSA9IDMwMDQxXSA9IFwiTW9kdWxhckFydGljbGVJdGVtXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiV2lraVwiXSA9IDMwODE4XSA9IFwiV2lraVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRyYWZ0XCJdID0gMzEyMzRdID0gXCJEcmFmdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlN1YnNjcmlwdGlvblRpZXJcIl0gPSAzNzAwMV0gPSBcIlN1YnNjcmlwdGlvblRpZXJcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJFY2FzaE1pbnRSZWNvbW1lbmRhdGlvblwiXSA9IDM4ZTNdID0gXCJFY2FzaE1pbnRSZWNvbW1lbmRhdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkhpZ2hsaWdodFNldFwiXSA9IDM5ODAyXSA9IFwiSGlnaGxpZ2h0U2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2F0ZWdvcml6ZWRIaWdobGlnaHRMaXN0XCJdID0gMzk4MDIgLyogSGlnaGxpZ2h0U2V0ICovXSA9IFwiQ2F0ZWdvcml6ZWRIaWdobGlnaHRMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTnV0emFwXCJdID0gOTMyMV0gPSBcIk51dHphcFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlphcFJlcXVlc3RcIl0gPSA5NzM0XSA9IFwiWmFwUmVxdWVzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlphcFwiXSA9IDk3MzVdID0gXCJaYXBcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJIaWdobGlnaHRcIl0gPSA5ODAyXSA9IFwiSGlnaGxpZ2h0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2xpZW50QXV0aFwiXSA9IDIyMjQyXSA9IFwiQ2xpZW50QXV0aFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk5vc3RyV2FsbGV0Q29ubmVjdFJlcVwiXSA9IDIzMTk0XSA9IFwiTm9zdHJXYWxsZXRDb25uZWN0UmVxXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTm9zdHJXYWxsZXRDb25uZWN0UmVzXCJdID0gMjMxOTVdID0gXCJOb3N0cldhbGxldENvbm5lY3RSZXNcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJOb3N0ckNvbm5lY3RcIl0gPSAyNDEzM10gPSBcIk5vc3RyQ29ubmVjdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkJsb3Nzb21VcGxvYWRcIl0gPSAyNDI0Ml0gPSBcIkJsb3Nzb21VcGxvYWRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJIdHRwQXV0aFwiXSA9IDI3MjM1XSA9IFwiSHR0cEF1dGhcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJQcm9maWxlQmFkZ2VcIl0gPSAzMDAwOF0gPSBcIlByb2ZpbGVCYWRnZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkJhZGdlRGVmaW5pdGlvblwiXSA9IDMwMDA5XSA9IFwiQmFkZ2VEZWZpbml0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTWFya2V0U3RhbGxcIl0gPSAzMDAxN10gPSBcIk1hcmtldFN0YWxsXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTWFya2V0UHJvZHVjdFwiXSA9IDMwMDE4XSA9IFwiTWFya2V0UHJvZHVjdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkFydGljbGVcIl0gPSAzMDAyM10gPSBcIkFydGljbGVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJBcHBTcGVjaWZpY0RhdGFcIl0gPSAzMDA3OF0gPSBcIkFwcFNwZWNpZmljRGF0YVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNsYXNzaWZpZWRcIl0gPSAzMDQwMl0gPSBcIkNsYXNzaWZpZWRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJIb3Jpem9udGFsVmlkZW9cIl0gPSAzNDIzNV0gPSBcIkhvcml6b250YWxWaWRlb1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlZlcnRpY2FsVmlkZW9cIl0gPSAzNDIzNl0gPSBcIlZlcnRpY2FsVmlkZW9cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJMZWdhY3lDYXNodVdhbGxldFwiXSA9IDM3Mzc1XSA9IFwiTGVnYWN5Q2FzaHVXYWxsZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cE1ldGFkYXRhXCJdID0gMzllM10gPSBcIkdyb3VwTWV0YWRhdGFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cEFkbWluc1wiXSA9IDM5MDAxXSA9IFwiR3JvdXBBZG1pbnNcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cE1lbWJlcnNcIl0gPSAzOTAwMl0gPSBcIkdyb3VwTWVtYmVyc1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkFwcFJlY29tbWVuZGF0aW9uXCJdID0gMzE5ODldID0gXCJBcHBSZWNvbW1lbmRhdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkFwcEhhbmRsZXJcIl0gPSAzMTk5MF0gPSBcIkFwcEhhbmRsZXJcIjtcbiAgcmV0dXJuIE5ES0tpbmQyO1xufSkoTkRLS2luZCB8fCB7fSk7XG52YXIgTkRLTGlzdEtpbmRzID0gW1xuICAxZTQgLyogTXV0ZUxpc3QgKi8sXG4gIDEwMDAxIC8qIFBpbkxpc3QgKi8sXG4gIDEwMDAyIC8qIFJlbGF5TGlzdCAqLyxcbiAgMTAwMDMgLyogQm9va21hcmtMaXN0ICovLFxuICAxMDAwNCAvKiBDb21tdW5pdHlMaXN0ICovLFxuICAxMDAwNSAvKiBQdWJsaWNDaGF0TGlzdCAqLyxcbiAgMTAwMDYgLyogQmxvY2tSZWxheUxpc3QgKi8sXG4gIDEwMDA3IC8qIFNlYXJjaFJlbGF5TGlzdCAqLyxcbiAgMTAwMTUgLyogSW50ZXJlc3RMaXN0ICovLFxuICAxMDAzMCAvKiBFbW9qaUxpc3QgKi8sXG4gIDEwMDUwIC8qIERpcmVjdE1lc3NhZ2VSZWNlaXZlUmVsYXlMaXN0ICovLFxuICAzZTQgLyogRm9sbG93U2V0ICovLFxuICAzMDAwMyAvKiBCb29rbWFya1NldCAqLyxcbiAgMzAwMDEgLyogQ2F0ZWdvcml6ZWRCb29rbWFya0xpc3QgKi8sXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIDMwMDAyIC8qIFJlbGF5U2V0ICovLFxuICAzMDAwNCAvKiBBcnRpY2xlQ3VyYXRpb25TZXQgKi8sXG4gIDMwMDA1IC8qIFZpZGVvQ3VyYXRpb25TZXQgKi8sXG4gIDMwMDE1IC8qIEludGVyZXN0U2V0ICovLFxuICAzMDAzMCAvKiBFbW9qaVNldCAqLyxcbiAgMzk4MDIgLyogSGlnaGxpZ2h0U2V0ICovXG5dO1xuXG4vLyBzcmMvZXZlbnRzL2luZGV4LnRzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgYXMgRXZlbnRFbWl0dGVyMiB9IGZyb20gXCJ0c2VlcFwiO1xuXG4vLyBzcmMvcmVsYXkvc2V0cy9jYWxjdWxhdGUudHNcbmltcG9ydCBjcmVhdGVEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcblxuLy8gc3JjL291dGJveC93cml0ZS50c1xuZnVuY3Rpb24gZ2V0UmVsYXlzRm9yU3luYyhuZGssIGF1dGhvciwgdHlwZSA9IFwid3JpdGVcIikge1xuICBpZiAoIW5kay5vdXRib3hUcmFja2VyKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBpdGVtID0gbmRrLm91dGJveFRyYWNrZXIuZGF0YS5nZXQoYXV0aG9yKTtcbiAgaWYgKCFpdGVtKSByZXR1cm4gdm9pZCAwO1xuICBpZiAodHlwZSA9PT0gXCJ3cml0ZVwiKSB7XG4gICAgcmV0dXJuIGl0ZW0ud3JpdGVSZWxheXM7XG4gIH1cbiAgcmV0dXJuIGl0ZW0ucmVhZFJlbGF5cztcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFdyaXRlUmVsYXlzRm9yKG5kaywgYXV0aG9yLCB0eXBlID0gXCJ3cml0ZVwiKSB7XG4gIGlmICghbmRrLm91dGJveFRyYWNrZXIpIHJldHVybiB2b2lkIDA7XG4gIGlmICghbmRrLm91dGJveFRyYWNrZXIuZGF0YS5oYXMoYXV0aG9yKSkge1xuICAgIGF3YWl0IG5kay5vdXRib3hUcmFja2VyLnRyYWNrVXNlcnMoW2F1dGhvcl0pO1xuICB9XG4gIHJldHVybiBnZXRSZWxheXNGb3JTeW5jKG5kaywgYXV0aG9yLCB0eXBlKTtcbn1cblxuLy8gc3JjL291dGJveC9yZWxheS1yYW5raW5nLnRzXG5mdW5jdGlvbiBnZXRUb3BSZWxheXNGb3JBdXRob3JzKG5kaywgYXV0aG9ycykge1xuICBjb25zdCByZWxheXNXaXRoQ291bnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBhdXRob3JzLmZvckVhY2goKGF1dGhvcikgPT4ge1xuICAgIGNvbnN0IHdyaXRlUmVsYXlzID0gZ2V0UmVsYXlzRm9yU3luYyhuZGssIGF1dGhvcik7XG4gICAgaWYgKHdyaXRlUmVsYXlzKSB7XG4gICAgICB3cml0ZVJlbGF5cy5mb3JFYWNoKChyZWxheSkgPT4ge1xuICAgICAgICBjb25zdCBjb3VudCA9IHJlbGF5c1dpdGhDb3VudC5nZXQocmVsYXkpIHx8IDA7XG4gICAgICAgIHJlbGF5c1dpdGhDb3VudC5zZXQocmVsYXksIGNvdW50ICsgMSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzb3J0ZWRSZWxheXMgPSBBcnJheS5mcm9tKHJlbGF5c1dpdGhDb3VudC5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKTtcbiAgcmV0dXJuIHNvcnRlZFJlbGF5cy5tYXAoKGVudHJ5KSA9PiBlbnRyeVswXSk7XG59XG5cbi8vIHNyYy9vdXRib3gvaW5kZXgudHNcbmZ1bmN0aW9uIGdldEFsbFJlbGF5c0ZvckFsbFB1YmtleXMobmRrLCBwdWJrZXlzLCB0eXBlID0gXCJyZWFkXCIpIHtcbiAgY29uc3QgcHVia2V5c1RvUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgYXV0aG9yc01pc3NpbmdSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBwdWJrZXlzLmZvckVhY2goKHB1YmtleSkgPT4ge1xuICAgIGNvbnN0IHJlbGF5cyA9IGdldFJlbGF5c0ZvclN5bmMobmRrLCBwdWJrZXksIHR5cGUpO1xuICAgIGlmIChyZWxheXMgJiYgcmVsYXlzLnNpemUgPiAwKSB7XG4gICAgICByZWxheXMuZm9yRWFjaCgocmVsYXkpID0+IHtcbiAgICAgICAgY29uc3QgcHVia2V5c0luUmVsYXkgPSBwdWJrZXlzVG9SZWxheXMuZ2V0KHJlbGF5KSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICBwdWJrZXlzSW5SZWxheS5hZGQocHVia2V5KTtcbiAgICAgIH0pO1xuICAgICAgcHVia2V5c1RvUmVsYXlzLnNldChwdWJrZXksIHJlbGF5cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF1dGhvcnNNaXNzaW5nUmVsYXlzLmFkZChwdWJrZXkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7IHB1YmtleXNUb1JlbGF5cywgYXV0aG9yc01pc3NpbmdSZWxheXMgfTtcbn1cbmZ1bmN0aW9uIGNob29zZVJlbGF5Q29tYmluYXRpb25Gb3JQdWJrZXlzKG5kaywgcHVia2V5cywgdHlwZSwgeyBjb3VudCwgcHJlZmVycmVkUmVsYXlzIH0gPSB7fSkge1xuICBjb3VudCA/Pz0gMjtcbiAgcHJlZmVycmVkUmVsYXlzID8/PSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBwb29sID0gbmRrLnBvb2w7XG4gIGNvbnN0IGNvbm5lY3RlZFJlbGF5cyA9IHBvb2wuY29ubmVjdGVkUmVsYXlzKCk7XG4gIGNvbm5lY3RlZFJlbGF5cy5mb3JFYWNoKChyZWxheSkgPT4ge1xuICAgIHByZWZlcnJlZFJlbGF5cz8uYWRkKHJlbGF5LnVybCk7XG4gIH0pO1xuICBjb25zdCByZWxheVRvQXV0aG9yc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHsgcHVia2V5c1RvUmVsYXlzLCBhdXRob3JzTWlzc2luZ1JlbGF5cyB9ID0gZ2V0QWxsUmVsYXlzRm9yQWxsUHVia2V5cyhuZGssIHB1YmtleXMsIHR5cGUpO1xuICBjb25zdCBzb3J0ZWRSZWxheXMgPSBnZXRUb3BSZWxheXNGb3JBdXRob3JzKG5kaywgcHVia2V5cyk7XG4gIGNvbnN0IGFkZEF1dGhvclRvUmVsYXkgPSAoYXV0aG9yLCByZWxheSkgPT4ge1xuICAgIGNvbnN0IGF1dGhvcnNJblJlbGF5ID0gcmVsYXlUb0F1dGhvcnNNYXAuZ2V0KHJlbGF5KSB8fCBbXTtcbiAgICBhdXRob3JzSW5SZWxheS5wdXNoKGF1dGhvcik7XG4gICAgcmVsYXlUb0F1dGhvcnNNYXAuc2V0KHJlbGF5LCBhdXRob3JzSW5SZWxheSk7XG4gIH07XG4gIGZvciAoY29uc3QgW2F1dGhvciwgYXV0aG9yUmVsYXlzXSBvZiBwdWJrZXlzVG9SZWxheXMuZW50cmllcygpKSB7XG4gICAgbGV0IG1pc3NpbmdSZWxheUNvdW50ID0gY291bnQ7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiBjb25uZWN0ZWRSZWxheXMpIHtcbiAgICAgIGlmIChhdXRob3JSZWxheXMuaGFzKHJlbGF5LnVybCkpIHtcbiAgICAgICAgYWRkQXV0aG9yVG9SZWxheShhdXRob3IsIHJlbGF5LnVybCk7XG4gICAgICAgIG1pc3NpbmdSZWxheUNvdW50LS07XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXV0aG9yUmVsYXkgb2YgYXV0aG9yUmVsYXlzKSB7XG4gICAgICBpZiAocmVsYXlUb0F1dGhvcnNNYXAuaGFzKGF1dGhvclJlbGF5KSkge1xuICAgICAgICBhZGRBdXRob3JUb1JlbGF5KGF1dGhvciwgYXV0aG9yUmVsYXkpO1xuICAgICAgICBtaXNzaW5nUmVsYXlDb3VudC0tO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWlzc2luZ1JlbGF5Q291bnQgPD0gMCkgY29udGludWU7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiBzb3J0ZWRSZWxheXMpIHtcbiAgICAgIGlmIChtaXNzaW5nUmVsYXlDb3VudCA8PSAwKSBicmVhaztcbiAgICAgIGlmIChhdXRob3JSZWxheXMuaGFzKHJlbGF5KSkge1xuICAgICAgICBhZGRBdXRob3JUb1JlbGF5KGF1dGhvciwgcmVsYXkpO1xuICAgICAgICBtaXNzaW5nUmVsYXlDb3VudC0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGF1dGhvciBvZiBhdXRob3JzTWlzc2luZ1JlbGF5cykge1xuICAgIHBvb2wucGVybWFuZW50QW5kQ29ubmVjdGVkUmVsYXlzKCkuZm9yRWFjaCgocmVsYXkpID0+IHtcbiAgICAgIGNvbnN0IGF1dGhvcnNJblJlbGF5ID0gcmVsYXlUb0F1dGhvcnNNYXAuZ2V0KHJlbGF5LnVybCkgfHwgW107XG4gICAgICBhdXRob3JzSW5SZWxheS5wdXNoKGF1dGhvcik7XG4gICAgICByZWxheVRvQXV0aG9yc01hcC5zZXQocmVsYXkudXJsLCBhdXRob3JzSW5SZWxheSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlbGF5VG9BdXRob3JzTWFwO1xufVxuXG4vLyBzcmMvb3V0Ym94L3JlYWQvd2l0aC1hdXRob3JzLnRzXG5mdW5jdGlvbiBnZXRSZWxheXNGb3JGaWx0ZXJXaXRoQXV0aG9ycyhuZGssIGF1dGhvcnMsIHJlbGF5R29hbFBlckF1dGhvciA9IDIpIHtcbiAgcmV0dXJuIGNob29zZVJlbGF5Q29tYmluYXRpb25Gb3JQdWJrZXlzKG5kaywgYXV0aG9ycywgXCJ3cml0ZVwiLCB7IGNvdW50OiByZWxheUdvYWxQZXJBdXRob3IgfSk7XG59XG5cbi8vIHNyYy91dGlscy9ub3JtYWxpemUtdXJsLnRzXG5mdW5jdGlvbiB0cnlOb3JtYWxpemVSZWxheVVybCh1cmwpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbm9ybWFsaXplUmVsYXlVcmwodXJsKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplUmVsYXlVcmwodXJsKSB7XG4gIGxldCByID0gbm9ybWFsaXplVXJsKHVybCwge1xuICAgIHN0cmlwQXV0aGVudGljYXRpb246IGZhbHNlLFxuICAgIHN0cmlwV1dXOiBmYWxzZSxcbiAgICBzdHJpcEhhc2g6IHRydWVcbiAgfSk7XG4gIGlmICghci5lbmRzV2l0aChcIi9cIikpIHtcbiAgICByICs9IFwiL1wiO1xuICB9XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplKHVybHMpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgdXJsIG9mIHVybHMpIHtcbiAgICB0cnkge1xuICAgICAgbm9ybWFsaXplZC5hZGQobm9ybWFsaXplUmVsYXlVcmwodXJsKSk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKG5vcm1hbGl6ZWQpO1xufVxudmFyIERBVEFfVVJMX0RFRkFVTFRfTUlNRV9UWVBFID0gXCJ0ZXh0L3BsYWluXCI7XG52YXIgREFUQV9VUkxfREVGQVVMVF9DSEFSU0VUID0gXCJ1cy1hc2NpaVwiO1xudmFyIHRlc3RQYXJhbWV0ZXIgPSAobmFtZSwgZmlsdGVycykgPT4gZmlsdGVycy5zb21lKChmaWx0ZXIpID0+IGZpbHRlciBpbnN0YW5jZW9mIFJlZ0V4cCA/IGZpbHRlci50ZXN0KG5hbWUpIDogZmlsdGVyID09PSBuYW1lKTtcbnZhciBzdXBwb3J0ZWRQcm90b2NvbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJodHRwczpcIiwgXCJodHRwOlwiLCBcImZpbGU6XCJdKTtcbnZhciBoYXNDdXN0b21Qcm90b2NvbCA9ICh1cmxTdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IHByb3RvY29sIH0gPSBuZXcgVVJMKHVybFN0cmluZyk7XG4gICAgcmV0dXJuIHByb3RvY29sLmVuZHNXaXRoKFwiOlwiKSAmJiAhcHJvdG9jb2wuaW5jbHVkZXMoXCIuXCIpICYmICFzdXBwb3J0ZWRQcm90b2NvbHMuaGFzKHByb3RvY29sKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIG5vcm1hbGl6ZURhdGFVUkwgPSAodXJsU3RyaW5nLCB7IHN0cmlwSGFzaCB9KSA9PiB7XG4gIGNvbnN0IG1hdGNoID0gL15kYXRhOig/PHR5cGU+W14sXSo/KSwoPzxkYXRhPlteI10qPykoPzojKD88aGFzaD4uKikpPyQvLmV4ZWModXJsU3RyaW5nKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVUkw6ICR7dXJsU3RyaW5nfWApO1xuICB9XG4gIGNvbnN0IHR5cGUgPSBtYXRjaC5ncm91cHM/LnR5cGUgPz8gXCJcIjtcbiAgY29uc3QgZGF0YSA9IG1hdGNoLmdyb3Vwcz8uZGF0YSA/PyBcIlwiO1xuICBsZXQgaGFzaCA9IG1hdGNoLmdyb3Vwcz8uaGFzaCA/PyBcIlwiO1xuICBjb25zdCBtZWRpYVR5cGUgPSB0eXBlLnNwbGl0KFwiO1wiKTtcbiAgaGFzaCA9IHN0cmlwSGFzaCA/IFwiXCIgOiBoYXNoO1xuICBsZXQgaXNCYXNlNjQgPSBmYWxzZTtcbiAgaWYgKG1lZGlhVHlwZVttZWRpYVR5cGUubGVuZ3RoIC0gMV0gPT09IFwiYmFzZTY0XCIpIHtcbiAgICBtZWRpYVR5cGUucG9wKCk7XG4gICAgaXNCYXNlNjQgPSB0cnVlO1xuICB9XG4gIGNvbnN0IG1pbWVUeXBlID0gbWVkaWFUeXBlLnNoaWZ0KCk/LnRvTG93ZXJDYXNlKCkgPz8gXCJcIjtcbiAgY29uc3QgYXR0cmlidXRlcyA9IG1lZGlhVHlwZS5tYXAoKGF0dHJpYnV0ZSkgPT4ge1xuICAgIGxldCBba2V5LCB2YWx1ZSA9IFwiXCJdID0gYXR0cmlidXRlLnNwbGl0KFwiPVwiKS5tYXAoKHN0cmluZykgPT4gc3RyaW5nLnRyaW0oKSk7XG4gICAgaWYgKGtleSA9PT0gXCJjaGFyc2V0XCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gREFUQV9VUkxfREVGQVVMVF9DSEFSU0VUKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYCR7a2V5fSR7dmFsdWUgPyBgPSR7dmFsdWV9YCA6IFwiXCJ9YDtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBub3JtYWxpemVkTWVkaWFUeXBlID0gWy4uLmF0dHJpYnV0ZXNdO1xuICBpZiAoaXNCYXNlNjQpIHtcbiAgICBub3JtYWxpemVkTWVkaWFUeXBlLnB1c2goXCJiYXNlNjRcIik7XG4gIH1cbiAgaWYgKG5vcm1hbGl6ZWRNZWRpYVR5cGUubGVuZ3RoID4gMCB8fCBtaW1lVHlwZSAmJiBtaW1lVHlwZSAhPT0gREFUQV9VUkxfREVGQVVMVF9NSU1FX1RZUEUpIHtcbiAgICBub3JtYWxpemVkTWVkaWFUeXBlLnVuc2hpZnQobWltZVR5cGUpO1xuICB9XG4gIHJldHVybiBgZGF0YToke25vcm1hbGl6ZWRNZWRpYVR5cGUuam9pbihcIjtcIil9LCR7aXNCYXNlNjQgPyBkYXRhLnRyaW0oKSA6IGRhdGF9JHtoYXNoID8gYCMke2hhc2h9YCA6IFwiXCJ9YDtcbn07XG5mdW5jdGlvbiBub3JtYWxpemVVcmwodXJsU3RyaW5nLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucyA9IHtcbiAgICBkZWZhdWx0UHJvdG9jb2w6IFwiaHR0cFwiLFxuICAgIG5vcm1hbGl6ZVByb3RvY29sOiB0cnVlLFxuICAgIGZvcmNlSHR0cDogZmFsc2UsXG4gICAgZm9yY2VIdHRwczogZmFsc2UsXG4gICAgc3RyaXBBdXRoZW50aWNhdGlvbjogdHJ1ZSxcbiAgICBzdHJpcEhhc2g6IGZhbHNlLFxuICAgIHN0cmlwVGV4dEZyYWdtZW50OiB0cnVlLFxuICAgIHN0cmlwV1dXOiB0cnVlLFxuICAgIHJlbW92ZVF1ZXJ5UGFyYW1ldGVyczogWy9edXRtX1xcdysvaV0sXG4gICAgcmVtb3ZlVHJhaWxpbmdTbGFzaDogdHJ1ZSxcbiAgICByZW1vdmVTaW5nbGVTbGFzaDogdHJ1ZSxcbiAgICByZW1vdmVEaXJlY3RvcnlJbmRleDogZmFsc2UsXG4gICAgcmVtb3ZlRXhwbGljaXRQb3J0OiBmYWxzZSxcbiAgICBzb3J0UXVlcnlQYXJhbWV0ZXJzOiB0cnVlLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmRlZmF1bHRQcm90b2NvbCA9PT0gXCJzdHJpbmdcIiAmJiAhb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wuZW5kc1dpdGgoXCI6XCIpKSB7XG4gICAgb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wgPSBgJHtvcHRpb25zLmRlZmF1bHRQcm90b2NvbH06YDtcbiAgfVxuICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcudHJpbSgpO1xuICBpZiAoL15kYXRhOi9pLnRlc3QodXJsU3RyaW5nKSkge1xuICAgIHJldHVybiBub3JtYWxpemVEYXRhVVJMKHVybFN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGhhc0N1c3RvbVByb3RvY29sKHVybFN0cmluZykpIHtcbiAgICByZXR1cm4gdXJsU3RyaW5nO1xuICB9XG4gIGNvbnN0IGhhc1JlbGF0aXZlUHJvdG9jb2wgPSB1cmxTdHJpbmcuc3RhcnRzV2l0aChcIi8vXCIpO1xuICBjb25zdCBpc1JlbGF0aXZlVXJsID0gIWhhc1JlbGF0aXZlUHJvdG9jb2wgJiYgL15cXC4qXFwvLy50ZXN0KHVybFN0cmluZyk7XG4gIGlmICghaXNSZWxhdGl2ZVVybCkge1xuICAgIHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9eKD8hKD86XFx3KzopP1xcL1xcLyl8XlxcL1xcLy8sIG9wdGlvbnMuZGVmYXVsdFByb3RvY29sKTtcbiAgfVxuICBjb25zdCB1cmxPYmplY3QgPSBuZXcgVVJMKHVybFN0cmluZyk7XG4gIHVybE9iamVjdC5ob3N0bmFtZSA9IHVybE9iamVjdC5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAob3B0aW9ucy5mb3JjZUh0dHAgJiYgb3B0aW9ucy5mb3JjZUh0dHBzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGBmb3JjZUh0dHBgIGFuZCBgZm9yY2VIdHRwc2Agb3B0aW9ucyBjYW5ub3QgYmUgdXNlZCB0b2dldGhlclwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5mb3JjZUh0dHAgJiYgdXJsT2JqZWN0LnByb3RvY29sID09PSBcImh0dHBzOlwiKSB7XG4gICAgdXJsT2JqZWN0LnByb3RvY29sID0gXCJodHRwOlwiO1xuICB9XG4gIGlmIChvcHRpb25zLmZvcmNlSHR0cHMgJiYgdXJsT2JqZWN0LnByb3RvY29sID09PSBcImh0dHA6XCIpIHtcbiAgICB1cmxPYmplY3QucHJvdG9jb2wgPSBcImh0dHBzOlwiO1xuICB9XG4gIGlmIChvcHRpb25zLnN0cmlwQXV0aGVudGljYXRpb24pIHtcbiAgICB1cmxPYmplY3QudXNlcm5hbWUgPSBcIlwiO1xuICAgIHVybE9iamVjdC5wYXNzd29yZCA9IFwiXCI7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RyaXBIYXNoKSB7XG4gICAgdXJsT2JqZWN0Lmhhc2ggPSBcIlwiO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuc3RyaXBUZXh0RnJhZ21lbnQpIHtcbiAgICB1cmxPYmplY3QuaGFzaCA9IHVybE9iamVjdC5oYXNoLnJlcGxhY2UoLyM/On46dGV4dC4qPyQvaSwgXCJcIik7XG4gIH1cbiAgaWYgKHVybE9iamVjdC5wYXRobmFtZSkge1xuICAgIGNvbnN0IHByb3RvY29sUmVnZXggPSAvXFxiW2Etel1bYS16XFxkK1xcLS5dezEsNTB9OlxcL1xcLy9nO1xuICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAoOyA7ICkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBwcm90b2NvbFJlZ2V4LmV4ZWModXJsT2JqZWN0LnBhdGhuYW1lKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm90b2NvbCA9IG1hdGNoWzBdO1xuICAgICAgY29uc3QgcHJvdG9jb2xBdEluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICBjb25zdCBpbnRlcm1lZGlhdGUgPSB1cmxPYmplY3QucGF0aG5hbWUuc2xpY2UobGFzdEluZGV4LCBwcm90b2NvbEF0SW5kZXgpO1xuICAgICAgcmVzdWx0ICs9IGludGVybWVkaWF0ZS5yZXBsYWNlKC9cXC97Mix9L2csIFwiL1wiKTtcbiAgICAgIHJlc3VsdCArPSBwcm90b2NvbDtcbiAgICAgIGxhc3RJbmRleCA9IHByb3RvY29sQXRJbmRleCArIHByb3RvY29sLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVtbmFudCA9IHVybE9iamVjdC5wYXRobmFtZS5zbGljZShsYXN0SW5kZXgsIHVybE9iamVjdC5wYXRobmFtZS5sZW5ndGgpO1xuICAgIHJlc3VsdCArPSByZW1uYW50LnJlcGxhY2UoL1xcL3syLH0vZywgXCIvXCIpO1xuICAgIHVybE9iamVjdC5wYXRobmFtZSA9IHJlc3VsdDtcbiAgfVxuICBpZiAodXJsT2JqZWN0LnBhdGhuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHVybE9iamVjdC5wYXRobmFtZSA9IGRlY29kZVVSSSh1cmxPYmplY3QucGF0aG5hbWUpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5yZW1vdmVEaXJlY3RvcnlJbmRleCA9PT0gdHJ1ZSkge1xuICAgIG9wdGlvbnMucmVtb3ZlRGlyZWN0b3J5SW5kZXggPSBbL15pbmRleFxcLlthLXpdKyQvXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4KSAmJiBvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4Lmxlbmd0aCA+IDApIHtcbiAgICBsZXQgcGF0aENvbXBvbmVudHMgPSB1cmxPYmplY3QucGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuICAgIGNvbnN0IGxhc3RDb21wb25lbnQgPSBwYXRoQ29tcG9uZW50c1twYXRoQ29tcG9uZW50cy5sZW5ndGggLSAxXTtcbiAgICBpZiAodGVzdFBhcmFtZXRlcihsYXN0Q29tcG9uZW50LCBvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4KSkge1xuICAgICAgcGF0aENvbXBvbmVudHMgPSBwYXRoQ29tcG9uZW50cy5zbGljZSgwLCAtMSk7XG4gICAgICB1cmxPYmplY3QucGF0aG5hbWUgPSBgJHtwYXRoQ29tcG9uZW50cy5zbGljZSgxKS5qb2luKFwiL1wiKX0vYDtcbiAgICB9XG4gIH1cbiAgaWYgKHVybE9iamVjdC5ob3N0bmFtZSkge1xuICAgIHVybE9iamVjdC5ob3N0bmFtZSA9IHVybE9iamVjdC5ob3N0bmFtZS5yZXBsYWNlKC9cXC4kLywgXCJcIik7XG4gICAgaWYgKG9wdGlvbnMuc3RyaXBXV1cgJiYgL153d3dcXC4oPyF3d3dcXC4pW2EtelxcLVxcZF17MSw2M31cXC5bYS16LlxcLVxcZF17Miw2M30kLy50ZXN0KHVybE9iamVjdC5ob3N0bmFtZSkpIHtcbiAgICAgIHVybE9iamVjdC5ob3N0bmFtZSA9IHVybE9iamVjdC5ob3N0bmFtZS5yZXBsYWNlKC9ed3d3XFwuLywgXCJcIik7XG4gICAgfVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucmVtb3ZlUXVlcnlQYXJhbWV0ZXJzKSkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFsuLi51cmxPYmplY3Quc2VhcmNoUGFyYW1zLmtleXMoKV0pIHtcbiAgICAgIGlmICh0ZXN0UGFyYW1ldGVyKGtleSwgb3B0aW9ucy5yZW1vdmVRdWVyeVBhcmFtZXRlcnMpKSB7XG4gICAgICAgIHVybE9iamVjdC5zZWFyY2hQYXJhbXMuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmtlZXBRdWVyeVBhcmFtZXRlcnMpICYmIG9wdGlvbnMucmVtb3ZlUXVlcnlQYXJhbWV0ZXJzID09PSB0cnVlKSB7XG4gICAgdXJsT2JqZWN0LnNlYXJjaCA9IFwiXCI7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5rZWVwUXVlcnlQYXJhbWV0ZXJzKSAmJiBvcHRpb25zLmtlZXBRdWVyeVBhcmFtZXRlcnMubGVuZ3RoID4gMCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFsuLi51cmxPYmplY3Quc2VhcmNoUGFyYW1zLmtleXMoKV0pIHtcbiAgICAgIGlmICghdGVzdFBhcmFtZXRlcihrZXksIG9wdGlvbnMua2VlcFF1ZXJ5UGFyYW1ldGVycykpIHtcbiAgICAgICAgdXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuc29ydFF1ZXJ5UGFyYW1ldGVycykge1xuICAgIHVybE9iamVjdC5zZWFyY2hQYXJhbXMuc29ydCgpO1xuICAgIHRyeSB7XG4gICAgICB1cmxPYmplY3Quc2VhcmNoID0gZGVjb2RlVVJJQ29tcG9uZW50KHVybE9iamVjdC5zZWFyY2gpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5yZW1vdmVUcmFpbGluZ1NsYXNoKSB7XG4gICAgdXJsT2JqZWN0LnBhdGhuYW1lID0gdXJsT2JqZWN0LnBhdGhuYW1lLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5yZW1vdmVFeHBsaWNpdFBvcnQgJiYgdXJsT2JqZWN0LnBvcnQpIHtcbiAgICB1cmxPYmplY3QucG9ydCA9IFwiXCI7XG4gIH1cbiAgY29uc3Qgb2xkVXJsU3RyaW5nID0gdXJsU3RyaW5nO1xuICB1cmxTdHJpbmcgPSB1cmxPYmplY3QudG9TdHJpbmcoKTtcbiAgaWYgKCFvcHRpb25zLnJlbW92ZVNpbmdsZVNsYXNoICYmIHVybE9iamVjdC5wYXRobmFtZSA9PT0gXCIvXCIgJiYgIW9sZFVybFN0cmluZy5lbmRzV2l0aChcIi9cIikgJiYgdXJsT2JqZWN0Lmhhc2ggPT09IFwiXCIpIHtcbiAgICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICB9XG4gIGlmICgob3B0aW9ucy5yZW1vdmVUcmFpbGluZ1NsYXNoIHx8IHVybE9iamVjdC5wYXRobmFtZSA9PT0gXCIvXCIpICYmIHVybE9iamVjdC5oYXNoID09PSBcIlwiICYmIG9wdGlvbnMucmVtb3ZlU2luZ2xlU2xhc2gpIHtcbiAgICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICB9XG4gIGlmIChoYXNSZWxhdGl2ZVByb3RvY29sICYmICFvcHRpb25zLm5vcm1hbGl6ZVByb3RvY29sKSB7XG4gICAgdXJsU3RyaW5nID0gdXJsU3RyaW5nLnJlcGxhY2UoL15odHRwOlxcL1xcLy8sIFwiLy9cIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RyaXBQcm90b2NvbCkge1xuICAgIHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9eKD86aHR0cHM/Oik/XFwvXFwvLywgXCJcIik7XG4gIH1cbiAgcmV0dXJuIHVybFN0cmluZztcbn1cblxuLy8gc3JjL3JlbGF5L2luZGV4LnRzXG5pbXBvcnQgZGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tIFwidHNlZXBcIjtcblxuLy8gc3JjL3JlbGF5L2Nvbm5lY3Rpdml0eS50c1xudmFyIE1BWF9SRUNPTk5FQ1RfQVRURU1QVFMgPSA1O1xudmFyIEZMQVBQSU5HX1RIUkVTSE9MRF9NUyA9IDFlMztcbnZhciBOREtSZWxheUNvbm5lY3Rpdml0eSA9IGNsYXNzIHtcbiAgbmRrUmVsYXk7XG4gIHdzO1xuICBfc3RhdHVzO1xuICB0aW1lb3V0TXM7XG4gIGNvbm5lY3RlZEF0O1xuICBfY29ubmVjdGlvblN0YXRzID0ge1xuICAgIGF0dGVtcHRzOiAwLFxuICAgIHN1Y2Nlc3M6IDAsXG4gICAgZHVyYXRpb25zOiBbXVxuICB9O1xuICBkZWJ1ZztcbiAgbmV0RGVidWc7XG4gIGNvbm5lY3RUaW1lb3V0O1xuICByZWNvbm5lY3RUaW1lb3V0O1xuICBuZGs7XG4gIG9wZW5TdWJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgb3BlbkNvdW50UmVxdWVzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBvcGVuRXZlbnRQdWJsaXNoZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzZXJpYWwgPSAwO1xuICBiYXNlRW9zZVRpbWVvdXQgPSA0NDAwO1xuICBjb25zdHJ1Y3RvcihuZGtSZWxheSwgbmRrKSB7XG4gICAgdGhpcy5uZGtSZWxheSA9IG5ka1JlbGF5O1xuICAgIHRoaXMuX3N0YXR1cyA9IDEgLyogRElTQ09OTkVDVEVEICovO1xuICAgIGNvbnN0IHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTMpO1xuICAgIHRoaXMuZGVidWcgPSB0aGlzLm5ka1JlbGF5LmRlYnVnLmV4dGVuZChgY29ubmVjdGl2aXR5JHtyYW5kfWApO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byB0aGUgTkRLIHJlbGF5IGFuZCBoYW5kbGVzIHRoZSBjb25uZWN0aW9uIGxpZmVjeWNsZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgYXR0ZW1wdHMgdG8gZXN0YWJsaXNoIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIE5ESyByZWxheSBzcGVjaWZpZWQgaW4gdGhlIGBuZGtSZWxheWAgb2JqZWN0LlxuICAgKiBJZiB0aGUgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsLCBpdCB1cGRhdGVzIHRoZSBjb25uZWN0aW9uIHN0YXRpc3RpY3MsIHNldHMgdGhlIGNvbm5lY3Rpb24gc3RhdHVzIHRvIGBDT05ORUNURURgLFxuICAgKiBhbmQgZW1pdHMgYGNvbm5lY3RgIGFuZCBgcmVhZHlgIGV2ZW50cyBvbiB0aGUgYG5ka1JlbGF5YCBvYmplY3QuXG4gICAqXG4gICAqIElmIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQgZmFpbHMsIGl0IGhhbmRsZXMgdGhlIGVycm9yIGJ5IGVpdGhlciBpbml0aWF0aW5nIGEgcmVjb25uZWN0aW9uIGF0dGVtcHQgb3IgZW1pdHRpbmcgYVxuICAgKiBgZGVsYXllZC1jb25uZWN0YCBldmVudCBvbiB0aGUgYG5ka1JlbGF5YCBvYmplY3QsIGRlcGVuZGluZyBvbiB0aGUgYHJlY29ubmVjdGAgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0gdGltZW91dE1zIC0gVGhlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgY29ubmVjdGlvbiBhdHRlbXB0LiBJZiBub3QgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IHRpbWVvdXQgZnJvbSB0aGUgYG5ka1JlbGF5YCBvYmplY3QgaXMgdXNlZC5cbiAgICogQHBhcmFtIHJlY29ubmVjdCAtIEluZGljYXRlcyB3aGV0aGVyIGEgcmVjb25uZWN0aW9uIHNob3VsZCBiZSBhdHRlbXB0ZWQgaWYgdGhlIGNvbm5lY3Rpb24gZmFpbHMuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgb3IgcmVqZWN0cyBpZiB0aGUgY29ubmVjdGlvbiBmYWlscy5cbiAgICovXG4gIGFzeW5jIGNvbm5lY3QodGltZW91dE1zLCByZWNvbm5lY3QgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuX3N0YXR1cyAhPT0gMiAvKiBSRUNPTk5FQ1RJTkcgKi8gJiYgdGhpcy5fc3RhdHVzICE9PSAxIC8qIERJU0NPTk5FQ1RFRCAqLyB8fCB0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgIFwiUmVsYXkgcmVxdWVzdGVkIHRvIGJlIGNvbm5lY3RlZCBidXQgd2FzIGluIHN0YXRlICVzIG9yIGl0IGhhZCBhIHJlY29ubmVjdCB0aW1lb3V0XCIsXG4gICAgICAgIHRoaXMuX3N0YXR1c1xuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dCk7XG4gICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0ID0gdm9pZCAwO1xuICAgIH1cbiAgICB0aW1lb3V0TXMgPz89IHRoaXMudGltZW91dE1zO1xuICAgIGlmICghdGhpcy50aW1lb3V0TXMgJiYgdGltZW91dE1zKSB0aGlzLnRpbWVvdXRNcyA9IHRpbWVvdXRNcztcbiAgICBpZiAodGhpcy50aW1lb3V0TXMpIHRoaXMuY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMub25Db25uZWN0aW9uRXJyb3IocmVjb25uZWN0KSwgdGhpcy50aW1lb3V0TXMpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25TdGF0cy5hdHRlbXB0KCk7XG4gICAgICBpZiAodGhpcy5fc3RhdHVzID09PSAxIC8qIERJU0NPTk5FQ1RFRCAqLykgdGhpcy5fc3RhdHVzID0gNCAvKiBDT05ORUNUSU5HICovO1xuICAgICAgZWxzZSB0aGlzLl9zdGF0dXMgPSAyIC8qIFJFQ09OTkVDVElORyAqLztcbiAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHRoaXMubmRrUmVsYXkudXJsKTtcbiAgICAgIHRoaXMud3Mub25vcGVuID0gdGhpcy5vbkNvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMud3Mub25jbG9zZSA9IHRoaXMub25EaXNjb25uZWN0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IHRoaXMub25NZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLndzLm9uZXJyb3IgPSB0aGlzLm9uRXJyb3IuYmluZCh0aGlzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmRlYnVnKGBGYWlsZWQgdG8gY29ubmVjdCB0byAke3RoaXMubmRrUmVsYXkudXJsfWAsIGUpO1xuICAgICAgdGhpcy5fc3RhdHVzID0gMSAvKiBESVNDT05ORUNURUQgKi87XG4gICAgICBpZiAocmVjb25uZWN0KSB0aGlzLmhhbmRsZVJlY29ubmVjdGlvbigpO1xuICAgICAgZWxzZSB0aGlzLm5ka1JlbGF5LmVtaXQoXCJkZWxheWVkLWNvbm5lY3RcIiwgMiAqIDI0ICogNjAgKiA2MCAqIDFlMyk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGlzY29ubmVjdHMgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIHRvIHRoZSBOREsgcmVsYXkuXG4gICAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIGNvbm5lY3Rpb24gc3RhdHVzIHRvIGBOREtSZWxheVN0YXR1cy5ESVNDT05ORUNUSU5HYCxcbiAgICogYXR0ZW1wdHMgdG8gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLCBhbmQgc2V0cyB0aGUgc3RhdHVzIHRvXG4gICAqIGBOREtSZWxheVN0YXR1cy5ESVNDT05ORUNURURgIGlmIHRoZSBkaXNjb25uZWN0IG9wZXJhdGlvbiBmYWlscy5cbiAgICovXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5fc3RhdHVzID0gMCAvKiBESVNDT05ORUNUSU5HICovO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLndzPy5jbG9zZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJGYWlsZWQgdG8gZGlzY29ubmVjdFwiLCBlKTtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IDEgLyogRElTQ09OTkVDVEVEICovO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgZXJyb3IgdGhhdCBvY2N1cnJlZCB3aGVuIGF0dGVtcHRpbmcgdG8gY29ubmVjdCB0byB0aGUgTkRLIHJlbGF5LlxuICAgKiBJZiBgcmVjb25uZWN0YCBpcyBgdHJ1ZWAsIHRoaXMgbWV0aG9kIHdpbGwgaW5pdGlhdGUgYSByZWNvbm5lY3Rpb24gYXR0ZW1wdC5cbiAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIGVtaXQgYSBgZGVsYXllZC1jb25uZWN0YCBldmVudCBvbiB0aGUgYG5ka1JlbGF5YCBvYmplY3QsXG4gICAqIGluZGljYXRpbmcgdGhhdCBhIHJlY29ubmVjdGlvbiBzaG91bGQgYmUgYXR0ZW1wdGVkIGFmdGVyIGEgZGVsYXkuXG4gICAqXG4gICAqIEBwYXJhbSByZWNvbm5lY3QgLSBJbmRpY2F0ZXMgd2hldGhlciBhIHJlY29ubmVjdGlvbiBzaG91bGQgYmUgYXR0ZW1wdGVkLlxuICAgKi9cbiAgb25Db25uZWN0aW9uRXJyb3IocmVjb25uZWN0KSB7XG4gICAgdGhpcy5kZWJ1ZyhgRXJyb3IgY29ubmVjdGluZyB0byAke3RoaXMubmRrUmVsYXkudXJsfWAsIHRoaXMudGltZW91dE1zKTtcbiAgICBpZiAocmVjb25uZWN0ICYmICF0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIHRoaXMuaGFuZGxlUmVjb25uZWN0aW9uKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBjb25uZWN0aW9uIGV2ZW50IHdoZW4gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bGx5IG9wZW5lZC5cbiAgICogSXQgY2xlYXJzIGFueSBleGlzdGluZyBjb25uZWN0aW9uIGFuZCByZWNvbm5lY3Rpb24gdGltZW91dHMsIHVwZGF0ZXMgdGhlIGNvbm5lY3Rpb24gc3RhdGlzdGljcyxcbiAgICogc2V0cyB0aGUgY29ubmVjdGlvbiBzdGF0dXMgdG8gYENPTk5FQ1RFRGAsIGFuZCBlbWl0cyBgY29ubmVjdGAgYW5kIGByZWFkeWAgZXZlbnRzIG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdC5cbiAgICovXG4gIG9uQ29ubmVjdCgpIHtcbiAgICB0aGlzLm5ldERlYnVnPy4oXCJjb25uZWN0ZWRcIiwgdGhpcy5uZGtSZWxheSk7XG4gICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dCk7XG4gICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0ID0gdm9pZCAwO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWQoKTtcbiAgICB0aGlzLl9zdGF0dXMgPSA1IC8qIENPTk5FQ1RFRCAqLztcbiAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJjb25uZWN0XCIpO1xuICAgIHRoaXMubmRrUmVsYXkuZW1pdChcInJlYWR5XCIpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBkaXNjb25uZWN0aW9uIGV2ZW50IHdoZW4gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGNsb3NlZC5cbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWxseSBjbG9zZWQuXG4gICAqIEl0IHVwZGF0ZXMgdGhlIGNvbm5lY3Rpb24gc3RhdGlzdGljcywgc2V0cyB0aGUgY29ubmVjdGlvbiBzdGF0dXMgdG8gYERJU0NPTk5FQ1RFRGAsXG4gICAqIGluaXRpYXRlcyBhIHJlY29ubmVjdGlvbiBhdHRlbXB0IGlmIHdlIGRpZG4ndCBkaXNjb25uZWN0IG91cnNlbHZlcyxcbiAgICogYW5kIGVtaXRzIGEgYGRpc2Nvbm5lY3RgIGV2ZW50IG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdC5cbiAgICovXG4gIG9uRGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLm5ldERlYnVnPy4oXCJkaXNjb25uZWN0ZWRcIiwgdGhpcy5uZGtSZWxheSk7XG4gICAgdGhpcy51cGRhdGVDb25uZWN0aW9uU3RhdHMuZGlzY29ubmVjdGVkKCk7XG4gICAgaWYgKHRoaXMuX3N0YXR1cyA9PT0gNSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgIHRoaXMuaGFuZGxlUmVjb25uZWN0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuX3N0YXR1cyA9IDEgLyogRElTQ09OTkVDVEVEICovO1xuICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImRpc2Nvbm5lY3RcIik7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgaW5jb21pbmcgbWVzc2FnZXMgZnJvbSB0aGUgTkRLIHJlbGF5IFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBtZXNzYWdlIGlzIHJlY2VpdmVkIGZyb20gdGhlIHJlbGF5LlxuICAgKiBJdCBwYXJzZXMgdGhlIG1lc3NhZ2UgZGF0YSBhbmQgZGlzcGF0Y2hlcyB0aGUgYXBwcm9wcmlhdGUgaGFuZGxpbmcgbG9naWMgYmFzZWQgb24gdGhlIG1lc3NhZ2UgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIE1lc3NhZ2VFdmVudCBjb250YWluaW5nIHRoZSByZWNlaXZlZCBtZXNzYWdlIGRhdGEuXG4gICAqL1xuICBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICB0aGlzLm5ldERlYnVnPy4oZXZlbnQuZGF0YSwgdGhpcy5uZGtSZWxheSwgXCJyZWN2XCIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgIGNvbnN0IFtjbWQsIGlkLCAuLi5fcmVzdF0gPSBkYXRhO1xuICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgY2FzZSBcIkVWRU5UXCI6IHtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGlkKTtcbiAgICAgICAgICBjb25zdCBldmVudDIgPSBkYXRhWzJdO1xuICAgICAgICAgIGlmICghc28pIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoYFJlY2VpdmVkIGV2ZW50IGZvciB1bmtub3duIHN1YnNjcmlwdGlvbiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzby5vbmV2ZW50KGV2ZW50Mik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJDT1VOVFwiOiB7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGFbMl07XG4gICAgICAgICAgY29uc3QgY3IgPSB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLmdldChpZCk7XG4gICAgICAgICAgaWYgKGNyKSB7XG4gICAgICAgICAgICBjci5yZXNvbHZlKHBheWxvYWQuY291bnQpO1xuICAgICAgICAgICAgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5kZWxldGUoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkVPU0VcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoaWQpO1xuICAgICAgICAgIGlmICghc28pIHJldHVybjtcbiAgICAgICAgICBzby5vbmVvc2UoaWQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiT0tcIjoge1xuICAgICAgICAgIGNvbnN0IG9rID0gZGF0YVsyXTtcbiAgICAgICAgICBjb25zdCByZWFzb24gPSBkYXRhWzNdO1xuICAgICAgICAgIGNvbnN0IGVwID0gdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZ2V0KGlkKTtcbiAgICAgICAgICBjb25zdCBmaXJzdEVwID0gZXA/LnBvcCgpO1xuICAgICAgICAgIGlmICghZXAgfHwgIWZpcnN0RXApIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoXCJSZWNlaXZlZCBPSyBmb3IgdW5rbm93biBldmVudCBwdWJsaXNoXCIsIGlkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9rKSBmaXJzdEVwLnJlc29sdmUocmVhc29uKTtcbiAgICAgICAgICBlbHNlIGZpcnN0RXAucmVqZWN0KG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICAgICAgICBpZiAoZXAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5kZWxldGUoaWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5zZXQoaWQsIGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJDTE9TRURcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoaWQpO1xuICAgICAgICAgIGlmICghc28pIHJldHVybjtcbiAgICAgICAgICBzby5vbmNsb3NlZChkYXRhWzJdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk5PVElDRVwiOlxuICAgICAgICAgIHRoaXMub25Ob3RpY2UoZGF0YVsxXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwiQVVUSFwiOiB7XG4gICAgICAgICAgdGhpcy5vbkF1dGhSZXF1ZXN0ZWQoZGF0YVsxXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZGVidWcoYEVycm9yIHBhcnNpbmcgbWVzc2FnZSBmcm9tICR7dGhpcy5uZGtSZWxheS51cmx9OiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3I/LnN0YWNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgYW4gYXV0aGVudGljYXRpb24gcmVxdWVzdCBmcm9tIHRoZSBOREsgcmVsYXkuXG4gICAqXG4gICAqIElmIGFuIGF1dGhlbnRpY2F0aW9uIHBvbGljeSBpcyBjb25maWd1cmVkLCBpdCB3aWxsIGJlIHVzZWQgdG8gYXV0aGVudGljYXRlIHRoZSBjb25uZWN0aW9uLlxuICAgKiBPdGhlcndpc2UsIHRoZSBgYXV0aGAgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIHRvIGFsbG93IHRoZSBhcHBsaWNhdGlvbiB0byBoYW5kbGUgdGhlIGF1dGhlbnRpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gY2hhbGxlbmdlIC0gVGhlIGF1dGhlbnRpY2F0aW9uIGNoYWxsZW5nZSBwcm92aWRlZCBieSB0aGUgTkRLIHJlbGF5LlxuICAgKi9cbiAgYXN5bmMgb25BdXRoUmVxdWVzdGVkKGNoYWxsZW5nZSkge1xuICAgIGNvbnN0IGF1dGhQb2xpY3kgPSB0aGlzLm5ka1JlbGF5LmF1dGhQb2xpY3kgPz8gdGhpcy5uZGs/LnJlbGF5QXV0aERlZmF1bHRQb2xpY3k7XG4gICAgdGhpcy5kZWJ1ZyhcIlJlbGF5IHJlcXVlc3RlZCBhdXRoZW50aWNhdGlvblwiLCB7XG4gICAgICBoYXZlUG9saWN5OiAhIWF1dGhQb2xpY3lcbiAgICB9KTtcbiAgICBpZiAodGhpcy5fc3RhdHVzID09PSA3IC8qIEFVVEhFTlRJQ0FUSU5HICovKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiQWxyZWFkeSBhdXRoZW50aWNhdGluZywgaWdub3JpbmdcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3N0YXR1cyA9IDYgLyogQVVUSF9SRVFVRVNURUQgKi87XG4gICAgaWYgKGF1dGhQb2xpY3kpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0dXMgPj0gNSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gNyAvKiBBVVRIRU5USUNBVElORyAqLztcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMgPSBhd2FpdCBhdXRoUG9saWN5KHRoaXMubmRrUmVsYXksIGNoYWxsZW5nZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmRlYnVnKFwiQXV0aGVudGljYXRpb24gcG9saWN5IHRocmV3IGFuIGVycm9yXCIsIGUpO1xuICAgICAgICAgIHJlcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVidWcoXCJBdXRoZW50aWNhdGlvbiBwb2xpY3kgcmV0dXJuZWRcIiwgISFyZXMpO1xuICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgTkRLRXZlbnQgfHwgcmVzID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIE5ES0V2ZW50KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmF1dGgocmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYXV0aGVudGljYXRlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXR1cyA+PSA1IC8qIENPTk5FQ1RFRCAqLyAmJiB0aGlzLl9zdGF0dXMgPCA4IC8qIEFVVEhFTlRJQ0FURUQgKi8pIHtcbiAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGspO1xuICAgICAgICAgICAgICBldmVudC5raW5kID0gMjIyNDIgLyogQ2xpZW50QXV0aCAqLztcbiAgICAgICAgICAgICAgZXZlbnQudGFncyA9IFtcbiAgICAgICAgICAgICAgICBbXCJyZWxheVwiLCB0aGlzLm5ka1JlbGF5LnVybF0sXG4gICAgICAgICAgICAgICAgW1wiY2hhbGxlbmdlXCIsIGNoYWxsZW5nZV1cbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgYXdhaXQgZXZlbnQuc2lnbigpO1xuICAgICAgICAgICAgICB0aGlzLmF1dGgoZXZlbnQpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IDggLyogQVVUSEVOVElDQVRFRCAqLztcbiAgICAgICAgICAgICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJhdXRoZWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIkF1dGhlbnRpY2F0aW9uIHN1Y2Nlc3NmdWxcIik7XG4gICAgICAgICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gNiAvKiBBVVRIX1JFUVVFU1RFRCAqLztcbiAgICAgICAgICAgICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJhdXRoOmZhaWxlZFwiLCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKFwiQXV0aGVudGljYXRpb24gZmFpbGVkXCIsIGUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVidWcoXCJBdXRoZW50aWNhdGlvbiBmYWlsZWQsIGl0IGNoYW5nZWQgc3RhdHVzLCBzdGF0dXMgaXMgJWRcIiwgdGhpcy5fc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChyZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5uZGs/LnNpZ25lcikge1xuICAgICAgICAgICAgICB0aGlzLmRlYnVnKFwiTm8gc2lnbmVyIGF2YWlsYWJsZSBmb3IgYXV0aGVudGljYXRpb24gbG9jYWxob3N0XCIpO1xuICAgICAgICAgICAgICB0aGlzLm5kaz8ub25jZShcInNpZ25lcjpyZWFkeVwiLCBhdXRoZW50aWNhdGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXV0aGVudGljYXRlKCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYXV0aGVudGljYXRpbmdcIiwgZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zdGF0dXMgPSA1IC8qIENPTk5FQ1RFRCAqLztcbiAgICAgICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJhdXRoZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uZGtSZWxheS5lbWl0KFwiYXV0aFwiLCBjaGFsbGVuZ2UpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBlcnJvcnMgdGhhdCBvY2N1ciBvbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIHJlbGF5LlxuICAgKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3Igb3IgZXZlbnQgdGhhdCBvY2N1cnJlZC5cbiAgICovXG4gIG9uRXJyb3IoZXJyb3IpIHtcbiAgICB0aGlzLmRlYnVnKGBXZWJTb2NrZXQgZXJyb3Igb24gJHt0aGlzLm5ka1JlbGF5LnVybH06YCwgZXJyb3IpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgTkRLIHJlbGF5IGNvbm5lY3Rpb24uXG4gICAqIEByZXR1cm5zIHtOREtSZWxheVN0YXR1c30gVGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBOREsgcmVsYXkgY29ubmVjdGlvbi5cbiAgICovXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBOREsgcmVsYXkgY29ubmVjdGlvbiBpcyBjdXJyZW50bHkgYXZhaWxhYmxlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSByZWxheSBjb25uZWN0aW9uIGlzIGluIHRoZSBgQ09OTkVDVEVEYCBzdGF0dXMsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNBdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PT0gNSAvKiBDT05ORUNURUQgKi87XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgTkRLIHJlbGF5IGNvbm5lY3Rpb24gaXMgZmxhcHBpbmcsIHdoaWNoIG1lYW5zIHRoZSBjb25uZWN0aW9uIGlzIHJhcGlkbHlcbiAgICogZGlzY29ubmVjdGluZyBhbmQgcmVjb25uZWN0aW5nLiBUaGlzIGlzIGRldGVybWluZWQgYnkgYW5hbHl6aW5nIHRoZSBkdXJhdGlvbnMgb2YgdGhlXG4gICAqIGxhc3QgdGhyZWUgY29ubmVjdGlvbiBhdHRlbXB0cy4gSWYgdGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgZHVyYXRpb25zIGlzIGxlc3NcbiAgICogdGhhbiAxMDAwIG1pbGxpc2Vjb25kcywgdGhlIGNvbm5lY3Rpb24gaXMgY29uc2lkZXJlZCB0byBiZSBmbGFwcGluZy5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgY29ubmVjdGlvbiBpcyBmbGFwcGluZywgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqL1xuICBpc0ZsYXBwaW5nKCkge1xuICAgIGNvbnN0IGR1cmF0aW9ucyA9IHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5kdXJhdGlvbnM7XG4gICAgaWYgKGR1cmF0aW9ucy5sZW5ndGggJSAzICE9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qgc3VtID0gZHVyYXRpb25zLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICAgIGNvbnN0IGF2ZyA9IHN1bSAvIGR1cmF0aW9ucy5sZW5ndGg7XG4gICAgY29uc3QgdmFyaWFuY2UgPSBkdXJhdGlvbnMubWFwKCh4KSA9PiAoeCAtIGF2ZykgKiogMikucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBkdXJhdGlvbnMubGVuZ3RoO1xuICAgIGNvbnN0IHN0ZERldiA9IE1hdGguc3FydCh2YXJpYW5jZSk7XG4gICAgY29uc3QgaXNGbGFwcGluZyA9IHN0ZERldiA8IEZMQVBQSU5HX1RIUkVTSE9MRF9NUztcbiAgICByZXR1cm4gaXNGbGFwcGluZztcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBhIG5vdGljZSByZWNlaXZlZCBmcm9tIHRoZSBOREsgcmVsYXkuXG4gICAqIElmIHRoZSBub3RpY2UgaW5kaWNhdGVzIHRoZSByZWxheSBpcyBjb21wbGFpbmluZyAoZS5nLiBcInRvbyBtYW55XCIgb3IgXCJtYXhpbXVtXCIpLFxuICAgKiB0aGUgbWV0aG9kIGRpc2Nvbm5lY3RzIGZyb20gdGhlIHJlbGF5IGFuZCBhdHRlbXB0cyB0byByZWNvbm5lY3QgYWZ0ZXIgYSAyLXNlY29uZCBkZWxheS5cbiAgICogQSBkZWJ1ZyBtZXNzYWdlIGlzIGxvZ2dlZCB3aXRoIHRoZSByZWxheSBVUkwgYW5kIHRoZSBub3RpY2UgdGV4dC5cbiAgICogVGhlIFwibm90aWNlXCIgZXZlbnQgaXMgZW1pdHRlZCBvbiB0aGUgbmRrUmVsYXkgaW5zdGFuY2Ugd2l0aCB0aGUgbm90aWNlIHRleHQuXG4gICAqXG4gICAqIEBwYXJhbSBub3RpY2UgLSBUaGUgbm90aWNlIHRleHQgcmVjZWl2ZWQgZnJvbSB0aGUgTkRLIHJlbGF5LlxuICAgKi9cbiAgYXN5bmMgb25Ob3RpY2Uobm90aWNlKSB7XG4gICAgdGhpcy5uZGtSZWxheS5lbWl0KFwibm90aWNlXCIsIG5vdGljZSk7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIHJlY29ubmVjdCB0byB0aGUgTkRLIHJlbGF5IGFmdGVyIGEgY29ubmVjdGlvbiBpcyBsb3N0LlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCByZWN1cnNpdmVseSB0byBoYW5kbGUgbXVsdGlwbGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzLlxuICAgKiBJdCBjaGVja3MgaWYgdGhlIHJlbGF5IGlzIGZsYXBwaW5nIGFuZCBlbWl0cyBhIFwiZmxhcHBpbmdcIiBldmVudCBpZiBzby5cbiAgICogSXQgdGhlbiBjYWxjdWxhdGVzIGEgZGVsYXkgYmVmb3JlIHRoZSBuZXh0IHJlY29ubmVjdGlvbiBhdHRlbXB0IGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgcHJldmlvdXMgYXR0ZW1wdHMuXG4gICAqIFRoZSBmdW5jdGlvbiBzZXRzIGEgdGltZW91dCB0byBleGVjdXRlIHRoZSBuZXh0IHJlY29ubmVjdGlvbiBhdHRlbXB0IGFmdGVyIHRoZSBjYWxjdWxhdGVkIGRlbGF5LlxuICAgKiBJZiB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGlzIHJlYWNoZWQsIGEgZGVidWcgbWVzc2FnZSBpcyBsb2dnZWQuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRlbXB0IC0gVGhlIGN1cnJlbnQgYXR0ZW1wdCBudW1iZXIgKGRlZmF1bHQgaXMgMCkuXG4gICAqL1xuICBoYW5kbGVSZWNvbm5lY3Rpb24oYXR0ZW1wdCA9IDApIHtcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0KSByZXR1cm47XG4gICAgaWYgKHRoaXMuaXNGbGFwcGluZygpKSB7XG4gICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJmbGFwcGluZ1wiLCB0aGlzLl9jb25uZWN0aW9uU3RhdHMpO1xuICAgICAgdGhpcy5fc3RhdHVzID0gMyAvKiBGTEFQUElORyAqLztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVjb25uZWN0RGVsYXkgPSB0aGlzLmNvbm5lY3RlZEF0ID8gTWF0aC5tYXgoMCwgNmU0IC0gKERhdGUubm93KCkgLSB0aGlzLmNvbm5lY3RlZEF0KSkgOiA1ZTMgKiAodGhpcy5fY29ubmVjdGlvblN0YXRzLmF0dGVtcHRzICsgMSk7XG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9zdGF0dXMgPSAyIC8qIFJFQ09OTkVDVElORyAqLztcbiAgICAgIHRoaXMuY29ubmVjdCgpLmNhdGNoKChfZXJyKSA9PiB7XG4gICAgICAgIGlmIChhdHRlbXB0IDwgTUFYX1JFQ09OTkVDVF9BVFRFTVBUUykge1xuICAgICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVjb25uZWN0aW9uKGF0dGVtcHQgKyAxKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAxZTMgKiAoYXR0ZW1wdCArIDEpIF4gNFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZyhcIlJlY29ubmVjdCBmYWlsZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHJlY29ubmVjdERlbGF5KTtcbiAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJkZWxheWVkLWNvbm5lY3RcIiwgcmVjb25uZWN0RGVsYXkpO1xuICAgIHRoaXMuZGVidWcoXCJSZWNvbm5lY3RpbmcgaW5cIiwgcmVjb25uZWN0RGVsYXkpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5uZXh0UmVjb25uZWN0QXQgPSBEYXRlLm5vdygpICsgcmVjb25uZWN0RGVsYXk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgTkRLIHJlbGF5IGlmIHRoZSBjb25uZWN0aW9uIGlzIGluIHRoZSBDT05ORUNURUQgc3RhdGUgYW5kIHRoZSBXZWJTb2NrZXQgaXMgb3Blbi5cbiAgICogSWYgdGhlIGNvbm5lY3Rpb24gaXMgbm90IGluIHRoZSBDT05ORUNURUQgc3RhdGUgb3IgdGhlIFdlYlNvY2tldCBpcyBub3Qgb3BlbiwgbG9ncyBhIGRlYnVnIG1lc3NhZ2UgYW5kIHRocm93cyBhbiBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBzZW5kIHRvIHRoZSBOREsgcmVsYXkuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhdHRlbXB0aW5nIHRvIHNlbmQgb24gYSBjbG9zZWQgcmVsYXkgY29ubmVjdGlvbi5cbiAgICovXG4gIGFzeW5jIHNlbmQobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLl9zdGF0dXMgPj0gNSAvKiBDT05ORUNURUQgKi8gJiYgdGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHRoaXMud3M/LnNlbmQobWVzc2FnZSk7XG4gICAgICB0aGlzLm5ldERlYnVnPy4obWVzc2FnZSwgdGhpcy5uZGtSZWxheSwgXCJzZW5kXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlYnVnKGBOb3QgY29ubmVjdGVkIHRvICR7dGhpcy5uZGtSZWxheS51cmx9ICglZCksIG5vdCBzZW5kaW5nIG1lc3NhZ2UgJHttZXNzYWdlfWAsIHRoaXMuX3N0YXR1cyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBdXRoZW50aWNhdGVzIHRoZSBOREsgZXZlbnQgYnkgc2VuZGluZyBpdCB0byB0aGUgTkRLIHJlbGF5IGFuZCByZXR1cm5pbmcgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgTkRLIGV2ZW50IHRvIGF1dGhlbnRpY2F0ZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgYXV0aGVudGljYXRpb24gcmVzdWx0LlxuICAgKi9cbiAgYXN5bmMgYXV0aChldmVudCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHZhbCA9IHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmdldChldmVudC5pZCkgPz8gW107XG4gICAgICB2YWwucHVzaCh7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChldmVudC5pZCwgdmFsKTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoYFtcIkFVVEhcIiwke0pTT04uc3RyaW5naWZ5KGV2ZW50LnJhd0V2ZW50KCkpfV1gKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoZXMgYW4gTkRLIGV2ZW50IHRvIHRoZSByZWxheSBhbmQgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBOREsgZXZlbnQgdG8gcHVibGlzaC5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBldmVudCBwdWJsaWNhdGlvbi5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIGF0dGVtcHRpbmcgdG8gcHVibGlzaCBvbiBhIGNsb3NlZCByZWxheSBjb25uZWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgcHVibGlzaChldmVudCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHZhbCA9IHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmdldChldmVudC5pZCkgPz8gW107XG4gICAgICBpZiAodmFsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBEdXBsaWNhdGUgZXZlbnQgcHVibGlzaGluZyBkZXRlY3RlZCwgeW91IGFyZSBwdWJsaXNoaW5nIGV2ZW50ICR7ZXZlbnQuaWR9IHR3aWNlYCk7XG4gICAgICB9XG4gICAgICB2YWwucHVzaCh7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChldmVudC5pZCwgdmFsKTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoYFtcIkVWRU5UXCIsJHtKU09OLnN0cmluZ2lmeShldmVudCl9XWApO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgLyoqXG4gICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGV2ZW50cyB0aGF0IG1hdGNoIHRoZSBwcm92aWRlZCBmaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gZmlsdGVycyAtIFRoZSBmaWx0ZXJzIHRvIGFwcGx5IHRvIHRoZSBjb3VudCByZXF1ZXN0LlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IGNvbnRhaW5pbmcgYSBjdXN0b20gaWQgZm9yIHRoZSBjb3VudCByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBudW1iZXIgb2YgbWF0Y2hpbmcgZXZlbnRzLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYXR0ZW1wdGluZyB0byBzZW5kIHRoZSBjb3VudCByZXF1ZXN0IG9uIGEgY2xvc2VkIHJlbGF5IGNvbm5lY3Rpb24uXG4gICAqL1xuICBhc3luYyBjb3VudChmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICB0aGlzLnNlcmlhbCsrO1xuICAgIGNvbnN0IGlkID0gcGFyYW1zPy5pZCB8fCBgY291bnQ6JHt0aGlzLnNlcmlhbH1gO1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuc2V0KGlkLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoYFtcIkNPVU5UXCIsXCIke2lkfVwiLCR7SlNPTi5zdHJpbmdpZnkoZmlsdGVycykuc3Vic3RyaW5nKDEpfWApO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgY2xvc2Uoc3ViSWQsIHJlYXNvbikge1xuICAgIHRoaXMuc2VuZChgW1wiQ0xPU0VcIixcIiR7c3ViSWR9XCJdYCk7XG4gICAgY29uc3Qgc3ViID0gdGhpcy5vcGVuU3Vicy5nZXQoc3ViSWQpO1xuICAgIHRoaXMub3BlblN1YnMuZGVsZXRlKHN1YklkKTtcbiAgICBpZiAoc3ViKSBzdWIub25jbG9zZShyZWFzb24pO1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmVzIHRvIHRoZSBOREsgcmVsYXkgd2l0aCB0aGUgcHJvdmlkZWQgZmlsdGVycyBhbmQgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIGZpbHRlcnMgLSBUaGUgZmlsdGVycyB0byBhcHBseSB0byB0aGUgc3Vic2NyaXB0aW9uLlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHN1YnNjcmlwdGlvbiBwYXJhbWV0ZXJzLCBpbmNsdWRpbmcgYW4gb3B0aW9uYWwgY3VzdG9tIGlkLlxuICAgKiBAcmV0dXJucyBBIG5ldyBOREtSZWxheVN1YnNjcmlwdGlvbiBpbnN0YW5jZS5cbiAgICovXG4gIHJlcShyZWxheVN1Yikge1xuICAgIGAke3RoaXMuc2VuZChgW1wiUkVRXCIsXCIke3JlbGF5U3ViLnN1YklkfVwiLCR7SlNPTi5zdHJpbmdpZnkocmVsYXlTdWIuZXhlY3V0ZUZpbHRlcnMpLnN1YnN0cmluZygxKX1gKX1dYDtcbiAgICB0aGlzLm9wZW5TdWJzLnNldChyZWxheVN1Yi5zdWJJZCwgcmVsYXlTdWIpO1xuICB9XG4gIC8qKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB1cGRhdGUgdGhlIGNvbm5lY3Rpb24gc3RhdHMuXG4gICAqL1xuICB1cGRhdGVDb25uZWN0aW9uU3RhdHMgPSB7XG4gICAgY29ubmVjdGVkOiAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuc3VjY2VzcysrO1xuICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmNvbm5lY3RlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuICAgIGRpc2Nvbm5lY3RlZDogKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuZHVyYXRpb25zLnB1c2goRGF0ZS5ub3coKSAtIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCk7XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0aW9uU3RhdHMuZHVyYXRpb25zLmxlbmd0aCA+IDEwMCkge1xuICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5kdXJhdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmNvbm5lY3RlZEF0ID0gdm9pZCAwO1xuICAgIH0sXG4gICAgYXR0ZW1wdDogKCkgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmF0dGVtcHRzKys7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuY29ubmVjdGVkQXQgPSBEYXRlLm5vdygpO1xuICAgIH1cbiAgfTtcbiAgLyoqIFJldHVybnMgdGhlIGNvbm5lY3Rpb24gc3RhdHMuICovXG4gIGdldCBjb25uZWN0aW9uU3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cztcbiAgfVxuICAvKiogUmV0dXJucyB0aGUgcmVsYXkgVVJMICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMubmRrUmVsYXkudXJsO1xuICB9XG4gIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cyA+PSA1IC8qIENPTk5FQ1RFRCAqLyAmJiB0aGlzLndzPy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTjtcbiAgfVxufTtcblxuLy8gc3JjL3JlbGF5L3B1Ymxpc2hlci50c1xudmFyIE5ES1JlbGF5UHVibGlzaGVyID0gY2xhc3Mge1xuICBuZGtSZWxheTtcbiAgZGVidWc7XG4gIGNvbnN0cnVjdG9yKG5ka1JlbGF5KSB7XG4gICAgdGhpcy5uZGtSZWxheSA9IG5ka1JlbGF5O1xuICAgIHRoaXMuZGVidWcgPSBuZGtSZWxheS5kZWJ1Zy5leHRlbmQoXCJwdWJsaXNoZXJcIik7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2hlZCBhbiBldmVudCB0byB0aGUgcmVsYXk7IGlmIHRoZSByZWxheSBpcyBub3QgY29ubmVjdGVkLCBpdCB3aWxsXG4gICAqIHdhaXQgZm9yIHRoZSByZWxheSB0byBjb25uZWN0IGJlZm9yZSBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAgICpcbiAgICogSWYgdGhlIHJlbGF5IGRvZXMgbm90IGNvbm5lY3Qgd2l0aGluIHRoZSB0aW1lb3V0LCB0aGUgcHVibGlzaCBvcGVyYXRpb25cbiAgICogd2lsbCBmYWlsLlxuICAgKiBAcGFyYW0gZXZlbnQgIFRoZSBldmVudCB0byBwdWJsaXNoXG4gICAqIEBwYXJhbSB0aW1lb3V0TXMgIFRoZSB0aW1lb3V0IGZvciB0aGUgcHVibGlzaCBvcGVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGV2ZW50IGhhcyBiZWVuIHB1Ymxpc2hlZCBvciByZWplY3RzIGlmIHRoZSBvcGVyYXRpb24gdGltZXMgb3V0XG4gICAqL1xuICBhc3luYyBwdWJsaXNoKGV2ZW50LCB0aW1lb3V0TXMgPSAyNTAwKSB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgY29uc3QgcHVibGlzaENvbm5lY3RlZCA9ICgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5wdWJsaXNoRXZlbnQoZXZlbnQpLnRoZW4oKF9yZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcInB1Ymxpc2hlZFwiLCBldmVudCk7XG4gICAgICAgICAgICBldmVudC5lbWl0KFwicmVsYXk6cHVibGlzaGVkXCIsIHRoaXMubmRrUmVsYXkpO1xuICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGltZW91dCA9IHZvaWQgMDtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgVGltZW91dDogJHt0aW1lb3V0TXN9bXNgKSk7XG4gICAgICB9LCB0aW1lb3V0TXMpO1xuICAgIH0pO1xuICAgIGNvbnN0IG9uQ29ubmVjdEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBwdWJsaXNoQ29ubmVjdGVkKCkudGhlbigocmVzdWx0KSA9PiBjb25uZWN0UmVzb2x2ZShyZXN1bHQpKS5jYXRjaCgoZXJyKSA9PiBjb25uZWN0UmVqZWN0KGVycikpO1xuICAgIH07XG4gICAgbGV0IGNvbm5lY3RSZXNvbHZlO1xuICAgIGxldCBjb25uZWN0UmVqZWN0O1xuICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICB0aGlzLm5ka1JlbGF5LmRlYnVnKFwiUHVibGlzaCBmYWlsZWRcIiwgZXJyLCBldmVudC5pZCk7XG4gICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJwdWJsaXNoOmZhaWxlZFwiLCBldmVudCwgZXJyKTtcbiAgICAgIGV2ZW50LmVtaXQoXCJyZWxheTpwdWJsaXNoOmZhaWxlZFwiLCB0aGlzLm5ka1JlbGF5LCBlcnIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH07XG4gICAgY29uc3Qgb25GaW5hbGx5ID0gKCkgPT4ge1xuICAgICAgaWYgKHRpbWVvdXQpIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRoaXMubmRrUmVsYXkucmVtb3ZlTGlzdGVuZXIoXCJjb25uZWN0XCIsIG9uQ29ubmVjdEhhbmRsZXIpO1xuICAgIH07XG4gICAgaWYgKHRoaXMubmRrUmVsYXkuc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtwdWJsaXNoQ29ubmVjdGVkKCksIHRpbWVvdXRQcm9taXNlXSkuY2F0Y2gob25FcnJvcikuZmluYWxseShvbkZpbmFsbHkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZGtSZWxheS5zdGF0dXMgPD0gMSAvKiBESVNDT05ORUNURUQgKi8pIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlJlbGF5IGlzIGRpc2Nvbm5lY3RlZCwgdHJ5aW5nIHRvIGNvbm5lY3QgdG8gcHVibGlzaCBhbiBldmVudFwiLCB0aGlzLm5ka1JlbGF5LnVybCk7XG4gICAgICB0aGlzLm5ka1JlbGF5LmNvbm5lY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiUmVsYXkgbm90IGNvbm5lY3RlZCwgd2FpdGluZyBmb3IgY29ubmVjdGlvbiB0byBwdWJsaXNoIGFuIGV2ZW50XCIsIHRoaXMubmRrUmVsYXkudXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbm5lY3RSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgY29ubmVjdFJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgdGhpcy5uZGtSZWxheS5vbmNlKFwiY29ubmVjdFwiLCBvbkNvbm5lY3RIYW5kbGVyKTtcbiAgICAgIH0pLFxuICAgICAgdGltZW91dFByb21pc2VcbiAgICBdKS5jYXRjaChvbkVycm9yKS5maW5hbGx5KG9uRmluYWxseSk7XG4gIH1cbiAgYXN5bmMgcHVibGlzaEV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMubmRrUmVsYXkuY29ubmVjdGl2aXR5LnB1Ymxpc2goZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9zdWJzY3JpcHRpb24vZ3JvdXBpbmcudHNcbmZ1bmN0aW9uIGZpbHRlckZpbmdlcnByaW50KGZpbHRlcnMsIGNsb3NlT25Fb3NlKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gW107XG4gIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlcnMpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmVudHJpZXMoZmlsdGVyIHx8IHt9KS5tYXAoKFtrZXksIHZhbHVlc10pID0+IHtcbiAgICAgIGlmIChbXCJzaW5jZVwiLCBcInVudGlsXCJdLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGAke2tleX06JHt2YWx1ZXN9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXk7XG4gICAgfSkuc29ydCgpLmpvaW4oXCItXCIpO1xuICAgIGVsZW1lbnRzLnB1c2goa2V5cyk7XG4gIH1cbiAgbGV0IGlkID0gY2xvc2VPbkVvc2UgPyBcIitcIiA6IFwiXCI7XG4gIGlkICs9IGVsZW1lbnRzLmpvaW4oXCJ8XCIpO1xuICByZXR1cm4gaWQ7XG59XG5mdW5jdGlvbiBtZXJnZUZpbHRlcnMoZmlsdGVycykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgbGFzdFJlc3VsdCA9IHt9O1xuICBmaWx0ZXJzLmZpbHRlcigoZikgPT4gISFmLmxpbWl0KS5mb3JFYWNoKChmaWx0ZXJXaXRoTGltaXQpID0+IHJlc3VsdC5wdXNoKGZpbHRlcldpdGhMaW1pdCkpO1xuICBmaWx0ZXJzID0gZmlsdGVycy5maWx0ZXIoKGYpID0+ICFmLmxpbWl0KTtcbiAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzdWx0O1xuICBmaWx0ZXJzLmZvckVhY2goKGZpbHRlcikgPT4ge1xuICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGxhc3RSZXN1bHRba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgbGFzdFJlc3VsdFtrZXldID0gWy4uLnZhbHVlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0UmVzdWx0W2tleV0gPSBBcnJheS5mcm9tKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi5sYXN0UmVzdWx0W2tleV0sIC4uLnZhbHVlXSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0UmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBbLi4ucmVzdWx0LCBsYXN0UmVzdWx0XTtcbn1cblxuLy8gc3JjL3JlbGF5L3N1YnNjcmlwdGlvbi50c1xudmFyIE5ES1JlbGF5U3Vic2NyaXB0aW9uID0gY2xhc3Mge1xuICBmaW5nZXJwcmludDtcbiAgaXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB0b3BTdWJNYW5hZ2VyO1xuICBkZWJ1ZztcbiAgLyoqXG4gICAqIFRyYWNrcyB0aGUgc3RhdHVzIG9mIHRoaXMgUkVRLlxuICAgKi9cbiAgc3RhdHVzID0gMCAvKiBJTklUSUFMICovO1xuICBvbkNsb3NlO1xuICByZWxheTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBzdWJzY3JpcHRpb24gaGFzIHJlYWNoZWQgRU9TRS5cbiAgICovXG4gIGVvc2VkID0gZmFsc2U7XG4gIC8qKlxuICAgKiBUaW1lb3V0IGF0IHdoaWNoIHRoaXMgc3Vic2NyaXB0aW9uIHdpbGxcbiAgICogc3RhcnQgZXhlY3V0aW5nLlxuICAgKi9cbiAgZXhlY3V0aW9uVGltZXI7XG4gIC8qKlxuICAgKiBUcmFjayB0aGUgdGltZSBhdCB3aGljaCB0aGlzIHN1YnNjcmlwdGlvbiB3aWxsIGZpcmUuXG4gICAqL1xuICBmaXJlVGltZTtcbiAgLyoqXG4gICAqIFRoZSBkZWxheSB0eXBlIHRoYXQgdGhlIGN1cnJlbnQgZmlyZVRpbWUgd2FzIGNhbGN1bGF0ZWQgd2l0aC5cbiAgICovXG4gIGRlbGF5VHlwZTtcbiAgLyoqXG4gICAqIFRoZSBmaWx0ZXJzIHRoYXQgaGF2ZSBiZWVuIGV4ZWN1dGVkLlxuICAgKi9cbiAgZXhlY3V0ZUZpbHRlcnM7XG4gIGlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpO1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGZpbmdlcnByaW50IFRoZSBmaW5nZXJwcmludCBvZiB0aGlzIHN1YnNjcmlwdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbGF5LCBmaW5nZXJwcmludCwgdG9wU3ViTWFuYWdlcikge1xuICAgIHRoaXMucmVsYXkgPSByZWxheTtcbiAgICB0aGlzLnRvcFN1Yk1hbmFnZXIgPSB0b3BTdWJNYW5hZ2VyO1xuICAgIHRoaXMuZGVidWcgPSByZWxheS5kZWJ1Zy5leHRlbmQoYHN1Ylske3RoaXMuaWR9XWApO1xuICAgIHRoaXMuZmluZ2VycHJpbnQgPSBmaW5nZXJwcmludCB8fCBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyk7XG4gIH1cbiAgX3N1YklkO1xuICBnZXQgc3ViSWQoKSB7XG4gICAgaWYgKHRoaXMuX3N1YklkKSByZXR1cm4gdGhpcy5fc3ViSWQ7XG4gICAgdGhpcy5fc3ViSWQgPSB0aGlzLmZpbmdlcnByaW50LnNsaWNlKDAsIDE1KTtcbiAgICByZXR1cm4gdGhpcy5fc3ViSWQ7XG4gIH1cbiAgc3ViSWRQYXJ0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGFkZFN1YklkUGFydChwYXJ0KSB7XG4gICAgdGhpcy5zdWJJZFBhcnRzLmFkZChwYXJ0KTtcbiAgfVxuICBhZGRJdGVtKHN1YnNjcmlwdGlvbiwgZmlsdGVycykge1xuICAgIHRoaXMuZGVidWcoXCJBZGRpbmcgaXRlbVwiLCB7XG4gICAgICBmaWx0ZXJzLFxuICAgICAgaW50ZXJuYWxJZDogc3Vic2NyaXB0aW9uLmludGVybmFsSWQsXG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgZmluZ2VycHJpbnQ6IHRoaXMuZmluZ2VycHJpbnQsXG4gICAgICBpZDogdGhpcy5zdWJJZCxcbiAgICAgIGl0ZW1zOiB0aGlzLml0ZW1zLFxuICAgICAgaXRlbXNTaXplOiB0aGlzLml0ZW1zLnNpemVcbiAgICB9KTtcbiAgICBpZiAodGhpcy5pdGVtcy5oYXMoc3Vic2NyaXB0aW9uLmludGVybmFsSWQpKSByZXR1cm47XG4gICAgc3Vic2NyaXB0aW9uLm9uKFwiY2xvc2VcIiwgdGhpcy5yZW1vdmVJdGVtLmJpbmQodGhpcywgc3Vic2NyaXB0aW9uKSk7XG4gICAgdGhpcy5pdGVtcy5zZXQoc3Vic2NyaXB0aW9uLmludGVybmFsSWQsIHsgc3Vic2NyaXB0aW9uLCBmaWx0ZXJzIH0pO1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gMyAvKiBSVU5OSU5HICovKSB7XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uLnN1YklkICYmICghdGhpcy5fc3ViSWQgfHwgdGhpcy5fc3ViSWQubGVuZ3RoIDwgNDgpKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMCAvKiBJTklUSUFMICovIHx8IHRoaXMuc3RhdHVzID09PSAxIC8qIFBFTkRJTkcgKi8pIHtcbiAgICAgICAgICB0aGlzLmFkZFN1YklkUGFydChzdWJzY3JpcHRpb24uc3ViSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5zdGF0dXMpIHtcbiAgICAgIGNhc2UgMCAvKiBJTklUSUFMICovOlxuICAgICAgICB0aGlzLmV2YWx1YXRlRXhlY3V0aW9uUGxhbihzdWJzY3JpcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMyAvKiBSVU5OSU5HICovOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMSAvKiBQRU5ESU5HICovOlxuICAgICAgICB0aGlzLmV2YWx1YXRlRXhlY3V0aW9uUGxhbihzdWJzY3JpcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNCAvKiBDTE9TRUQgKi86XG4gICAgICAgIHRoaXMuZGVidWcoXCJTdWJzY3JpcHRpb24gaXMgY2xvc2VkLCBjYW5ub3QgYWRkIG5ldyBpdGVtcyAlbyAoJW8pXCIsIHN1YnNjcmlwdGlvbiwgZmlsdGVycyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgbmV3IGl0ZW1zIHRvIGEgY2xvc2VkIHN1YnNjcmlwdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEEgc3Vic2NyaXB0aW9uIGhhcyBiZWVuIGNsb3NlZCwgcmVtb3ZlIGl0IGZyb20gdGhlIGxpc3Qgb2YgaXRlbXMuXG4gICAqIEBwYXJhbSBzdWJzY3JpcHRpb25cbiAgICovXG4gIHJlbW92ZUl0ZW0oc3Vic2NyaXB0aW9uKSB7XG4gICAgdGhpcy5pdGVtcy5kZWxldGUoc3Vic2NyaXB0aW9uLmludGVybmFsSWQpO1xuICAgIGlmICh0aGlzLml0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIGlmICghdGhpcy5lb3NlZCkgcmV0dXJuO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfVxuICB9XG4gIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gNCAvKiBDTE9TRUQgKi8pIHJldHVybjtcbiAgICBjb25zdCBwcmV2U3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gICAgdGhpcy5zdGF0dXMgPSA0IC8qIENMT1NFRCAqLztcbiAgICBpZiAocHJldlN0YXR1cyA9PT0gMyAvKiBSVU5OSU5HICovKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnJlbGF5LmNsb3NlKHRoaXMuc3ViSWQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiRXJyb3IgY2xvc2luZyBzdWJzY3JpcHRpb25cIiwgZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVidWcoXCJTdWJzY3JpcHRpb24gd2FudGVkIHRvIGNsb3NlIGJ1dCBpdCB3YXNuJ3QgcnVubmluZywgdGhpcyBpcyBwcm9iYWJseSBva1wiLCB7XG4gICAgICAgIHN1YklkOiB0aGlzLnN1YklkLFxuICAgICAgICBwcmV2U3RhdHVzLFxuICAgICAgICBzdWI6IHRoaXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLmV4ZWN1dGlvblRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5leGVjdXRpb25UaW1lcik7XG4gICAgdGhpcy5yZWxheS5vZmYoXCJyZWFkeVwiLCB0aGlzLmV4ZWN1dGVPblJlbGF5UmVhZHkpO1xuICAgIHRoaXMucmVsYXkub2ZmKFwiYXV0aGVkXCIsIHRoaXMucmVFeGVjdXRlQWZ0ZXJBdXRoKTtcbiAgICBpZiAodGhpcy5vbkNsb3NlKSB0aGlzLm9uQ2xvc2UodGhpcyk7XG4gIH1cbiAgZXZhbHVhdGVFeGVjdXRpb25QbGFuKHN1YnNjcmlwdGlvbikge1xuICAgIGlmICghc3Vic2NyaXB0aW9uLmlzR3JvdXBhYmxlKCkpIHtcbiAgICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgICAgdGhpcy5leGVjdXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdWJzY3JpcHRpb24uZmlsdGVycy5maW5kKChmaWx0ZXIpID0+ICEhZmlsdGVyLmxpbWl0KSkge1xuICAgICAgdGhpcy5leGVjdXRlRmlsdGVycyA9IHRoaXMuY29tcGlsZUZpbHRlcnMoKTtcbiAgICAgIGlmICh0aGlzLmV4ZWN1dGVGaWx0ZXJzLmxlbmd0aCA+PSAxMCkge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IDEgLyogUEVORElORyAqLztcbiAgICAgICAgdGhpcy5leGVjdXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVsYXkgPSBzdWJzY3JpcHRpb24uZ3JvdXBhYmxlRGVsYXk7XG4gICAgY29uc3QgZGVsYXlUeXBlID0gc3Vic2NyaXB0aW9uLmdyb3VwYWJsZURlbGF5VHlwZTtcbiAgICBpZiAoIWRlbGF5KSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ3JvdXAgYSBzdWJzY3JpcHRpb24gd2l0aG91dCBhIGRlbGF5XCIpO1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMCAvKiBJTklUSUFMICovKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlKGRlbGF5LCBkZWxheVR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBleGlzdGluZ0RlbGF5VHlwZSA9IHRoaXMuZGVsYXlUeXBlO1xuICAgICAgY29uc3QgdGltZVVudGlsRmlyZSA9IHRoaXMuZmlyZVRpbWUgLSBEYXRlLm5vdygpO1xuICAgICAgaWYgKGV4aXN0aW5nRGVsYXlUeXBlID09PSBcImF0LWxlYXN0XCIgJiYgZGVsYXlUeXBlID09PSBcImF0LWxlYXN0XCIpIHtcbiAgICAgICAgaWYgKHRpbWVVbnRpbEZpcmUgPCBkZWxheSkge1xuICAgICAgICAgIGlmICh0aGlzLmV4ZWN1dGlvblRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5leGVjdXRpb25UaW1lcik7XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZShkZWxheSwgZGVsYXlUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleGlzdGluZ0RlbGF5VHlwZSA9PT0gXCJhdC1sZWFzdFwiICYmIGRlbGF5VHlwZSA9PT0gXCJhdC1tb3N0XCIpIHtcbiAgICAgICAgaWYgKHRpbWVVbnRpbEZpcmUgPiBkZWxheSkge1xuICAgICAgICAgIGlmICh0aGlzLmV4ZWN1dGlvblRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5leGVjdXRpb25UaW1lcik7XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZShkZWxheSwgZGVsYXlUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleGlzdGluZ0RlbGF5VHlwZSA9PT0gXCJhdC1tb3N0XCIgJiYgZGVsYXlUeXBlID09PSBcImF0LW1vc3RcIikge1xuICAgICAgICBpZiAodGltZVVudGlsRmlyZSA+IGRlbGF5KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmV4ZWN1dGlvblRpbWVyKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlKGRlbGF5LCBkZWxheVR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nRGVsYXlUeXBlID09PSBcImF0LW1vc3RcIiAmJiBkZWxheVR5cGUgPT09IFwiYXQtbGVhc3RcIikge1xuICAgICAgICBpZiAodGltZVVudGlsRmlyZSA+IGRlbGF5KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmV4ZWN1dGlvblRpbWVyKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlKGRlbGF5LCBkZWxheVR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGVsYXkgdHlwZSBjb21iaW5hdGlvbiAke2V4aXN0aW5nRGVsYXlUeXBlfSAke2RlbGF5VHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2NoZWR1bGUoZGVsYXksIGRlbGF5VHlwZSkge1xuICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmZpcmVUaW1lID0gY3VycmVudFRpbWUgKyBkZWxheTtcbiAgICB0aGlzLmRlbGF5VHlwZSA9IGRlbGF5VHlwZTtcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQodGhpcy5leGVjdXRlLmJpbmQodGhpcyksIGRlbGF5KTtcbiAgICBpZiAoZGVsYXlUeXBlID09PSBcImF0LWxlYXN0XCIpIHtcbiAgICAgIHRoaXMuZXhlY3V0aW9uVGltZXIgPSB0aW1lcjtcbiAgICB9XG4gIH1cbiAgZXhlY3V0ZU9uUmVsYXlSZWFkeSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IDIgLyogV0FJVElORyAqLykgcmV0dXJuO1xuICAgIGlmICh0aGlzLml0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuZGVidWcoXCJObyBpdGVtcyB0byBleGVjdXRlOyB0aGlzIHJlbGF5IHdhcyBwcm9iYWJseSB0b28gc2xvdyB0byByZXNwb25kIGFuZCB0aGUgY2FsbGVyIGdhdmUgdXBcIiwge1xuICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICBmaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCxcbiAgICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICAgIGl0ZW1zU2l6ZTogdGhpcy5pdGVtcy5zaXplLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgc3ViSWQ6IHRoaXMuc3ViSWRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGVidWcoXCJFeGVjdXRpbmcgb24gcmVsYXkgcmVhZHlcIiwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIGZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LFxuICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICBpdGVtc1NpemU6IHRoaXMuaXRlbXMuc2l6ZVxuICAgIH0pO1xuICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgIHRoaXMuZXhlY3V0ZSgpO1xuICB9O1xuICBmaW5hbGl6ZVN1YklkKCkge1xuICAgIGlmICh0aGlzLnN1YklkUGFydHMuc2l6ZSA+IDApIHtcbiAgICAgIHRoaXMuX3N1YklkID0gQXJyYXkuZnJvbSh0aGlzLnN1YklkUGFydHMpLmpvaW4oXCItXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdWJJZCA9IHRoaXMuZmluZ2VycHJpbnQuc2xpY2UoMCwgMTUpO1xuICAgIH1cbiAgICB0aGlzLl9zdWJJZCArPSBgLSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDcpfWA7XG4gIH1cbiAgLy8gd2UgZG8gaXQgdGhpcyB3YXkgc28gdGhhdCB3ZSBjYW4gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuICByZUV4ZWN1dGVBZnRlckF1dGggPSAoKCkgPT4ge1xuICAgIGNvbnN0IG9sZFN1YklkID0gdGhpcy5zdWJJZDtcbiAgICB0aGlzLmRlYnVnKFwiUmUtZXhlY3V0aW5nIGFmdGVyIGF1dGhcIiwgdGhpcy5pdGVtcy5zaXplKTtcbiAgICBpZiAodGhpcy5lb3NlZCkge1xuICAgICAgdGhpcy5yZWxheS5jbG9zZSh0aGlzLnN1YklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWJ1ZyhcIldlIGFyZSBhYmFuZG9uaW5nIGFuIG9wZW5lZCBzdWJzY3JpcHRpb24sIG9uY2UgaXQgRU9TRSdzLCB0aGUgaGFuZGxlciB3aWxsIGNsb3NlIGl0XCIsIHtcbiAgICAgICAgb2xkU3ViSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9zdWJJZCA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXR1cyA9IDEgLyogUEVORElORyAqLztcbiAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICB0aGlzLmRlYnVnKFwiUmUtZXhlY3V0ZWQgYWZ0ZXIgYXV0aCAlcyBcXHV7MUY0NDl9ICVzXCIsIG9sZFN1YklkLCB0aGlzLnN1YklkKTtcbiAgfSkuYmluZCh0aGlzKTtcbiAgZXhlY3V0ZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IDEgLyogUEVORElORyAqLykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVsYXkuY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IDIgLyogV0FJVElORyAqLztcbiAgICAgIHRoaXMuZGVidWcoXCJXYWl0aW5nIGZvciByZWxheSB0byBiZSByZWFkeVwiLCB7XG4gICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgIGlkOiB0aGlzLnN1YklkLFxuICAgICAgICBmaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCxcbiAgICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICAgIGl0ZW1zU2l6ZTogdGhpcy5pdGVtcy5zaXplXG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVsYXkub25jZShcInJlYWR5XCIsIHRoaXMuZXhlY3V0ZU9uUmVsYXlSZWFkeSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnJlbGF5LnN0YXR1cyA8IDggLyogQVVUSEVOVElDQVRFRCAqLykge1xuICAgICAgdGhpcy5yZWxheS5vbmNlKFwiYXV0aGVkXCIsIHRoaXMucmVFeGVjdXRlQWZ0ZXJBdXRoKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0dXMgPSAzIC8qIFJVTk5JTkcgKi87XG4gICAgdGhpcy5maW5hbGl6ZVN1YklkKCk7XG4gICAgdGhpcy5leGVjdXRlRmlsdGVycyA9IHRoaXMuY29tcGlsZUZpbHRlcnMoKTtcbiAgICB0aGlzLnJlbGF5LnJlcSh0aGlzKTtcbiAgfVxuICBvbnN0YXJ0KCkge1xuICB9XG4gIG9uZXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLnRvcFN1Yk1hbmFnZXIuZGlzcGF0Y2hFdmVudChldmVudCwgdGhpcy5yZWxheSk7XG4gIH1cbiAgb25lb3NlKHN1YklkKSB7XG4gICAgdGhpcy5lb3NlZCA9IHRydWU7XG4gICAgaWYgKHN1YklkICE9PSB0aGlzLnN1YklkKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiUmVjZWl2ZWQgRU9TRSBmb3IgYW4gYWJhbmRvbmVkIHN1YnNjcmlwdGlvblwiLCBzdWJJZCwgdGhpcy5zdWJJZCk7XG4gICAgICB0aGlzLnJlbGF5LmNsb3NlKHN1YklkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXRlbXMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHsgc3Vic2NyaXB0aW9uIH0gb2YgdGhpcy5pdGVtcy52YWx1ZXMoKSkge1xuICAgICAgc3Vic2NyaXB0aW9uLmVvc2VSZWNlaXZlZCh0aGlzLnJlbGF5KTtcbiAgICAgIGlmIChzdWJzY3JpcHRpb24uY2xvc2VPbkVvc2UpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIlJlbW92aW5nIGl0ZW0gYmVjYXVzZSBvZiBFT1NFXCIsIHtcbiAgICAgICAgICBmaWx0ZXJzOiBzdWJzY3JpcHRpb24uZmlsdGVycyxcbiAgICAgICAgICBpbnRlcm5hbElkOiBzdWJzY3JpcHRpb24uaW50ZXJuYWxJZCxcbiAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgIGZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LFxuICAgICAgICAgIGl0ZW1zOiB0aGlzLml0ZW1zLFxuICAgICAgICAgIGl0ZW1zU2l6ZTogdGhpcy5pdGVtcy5zaXplXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlbW92ZUl0ZW0oc3Vic2NyaXB0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25jbG9zZShfcmVhc29uKSB7XG4gICAgdGhpcy5zdGF0dXMgPSA0IC8qIENMT1NFRCAqLztcbiAgfVxuICBvbmNsb3NlZChyZWFzb24pIHtcbiAgICBpZiAoIXJlYXNvbikgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgeyBzdWJzY3JpcHRpb24gfSBvZiB0aGlzLml0ZW1zLnZhbHVlcygpKSB7XG4gICAgICBzdWJzY3JpcHRpb24uY2xvc2VkUmVjZWl2ZWQodGhpcy5yZWxheSwgcmVhc29uKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdyYWJzIHRoZSBmaWx0ZXJzIGZyb20gYWxsIHRoZSBzdWJzY3JpcHRpb25zXG4gICAqIGFuZCBtZXJnZXMgdGhlbSBpbnRvIGEgc2luZ2xlIGZpbHRlci5cbiAgICovXG4gIGNvbXBpbGVGaWx0ZXJzKCkge1xuICAgIGNvbnN0IG1lcmdlZEZpbHRlcnMgPSBbXTtcbiAgICBjb25zdCBmaWx0ZXJzID0gQXJyYXkuZnJvbSh0aGlzLml0ZW1zLnZhbHVlcygpKS5tYXAoKGl0ZW0pID0+IGl0ZW0uZmlsdGVycyk7XG4gICAgaWYgKCFmaWx0ZXJzWzBdKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiXFx1ezFGNDQwfSBObyBmaWx0ZXJzIHRvIG1lcmdlXCIsIHRoaXMuaXRlbXMpO1xuICAgICAgY29uc29sZS5lcnJvcihcIkJVRzogTm8gZmlsdGVycyB0byBtZXJnZSFcIiwgdGhpcy5pdGVtcyk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlckNvdW50ID0gZmlsdGVyc1swXS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhbGxGaWx0ZXJzQXRJbmRleCA9IGZpbHRlcnMubWFwKChmaWx0ZXIpID0+IGZpbHRlcltpXSk7XG4gICAgICBtZXJnZWRGaWx0ZXJzLnB1c2goLi4ubWVyZ2VGaWx0ZXJzKGFsbEZpbHRlcnNBdEluZGV4KSk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWRGaWx0ZXJzO1xuICB9XG59O1xuXG4vLyBzcmMvcmVsYXkvc3ViLW1hbmFnZXIudHNcbnZhciBOREtSZWxheVN1YnNjcmlwdGlvbk1hbmFnZXIgPSBjbGFzcyB7XG4gIHJlbGF5O1xuICBzdWJzY3JpcHRpb25zO1xuICBnZW5lcmFsU3ViTWFuYWdlcjtcbiAgLyoqXG4gICAqIEBwYXJhbSByZWxheSAtIFRoZSByZWxheSBpbnN0YW5jZS5cbiAgICogQHBhcmFtIGdlbmVyYWxTdWJNYW5hZ2VyIC0gVGhlIHN1YnNjcmlwdGlvbiBtYW5hZ2VyIGluc3RhbmNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVsYXksIGdlbmVyYWxTdWJNYW5hZ2VyKSB7XG4gICAgdGhpcy5yZWxheSA9IHJlbGF5O1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5nZW5lcmFsU3ViTWFuYWdlciA9IGdlbmVyYWxTdWJNYW5hZ2VyO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgc3Vic2NyaXB0aW9uIHRvIHRoZSBtYW5hZ2VyLlxuICAgKi9cbiAgYWRkU3Vic2NyaXB0aW9uKHN1YiwgZmlsdGVycykge1xuICAgIGxldCByZWxheVN1YjtcbiAgICBpZiAoIXN1Yi5pc0dyb3VwYWJsZSgpKSB7XG4gICAgICByZWxheVN1YiA9IHRoaXMuY3JlYXRlU3Vic2NyaXB0aW9uKHN1YiwgZmlsdGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpbHRlckZwID0gZmlsdGVyRmluZ2VycHJpbnQoZmlsdGVycywgc3ViLmNsb3NlT25Fb3NlKTtcbiAgICAgIGlmIChmaWx0ZXJGcCkge1xuICAgICAgICBjb25zdCBleGlzdGluZ1N1YnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KGZpbHRlckZwKTtcbiAgICAgICAgcmVsYXlTdWIgPSAoZXhpc3RpbmdTdWJzIHx8IFtdKS5maW5kKChzdWIyKSA9PiBzdWIyLnN0YXR1cyA8IDMgLyogUlVOTklORyAqLyk7XG4gICAgICB9XG4gICAgICByZWxheVN1YiA/Pz0gdGhpcy5jcmVhdGVTdWJzY3JpcHRpb24oc3ViLCBmaWx0ZXJzLCBmaWx0ZXJGcCk7XG4gICAgfVxuICAgIHJlbGF5U3ViLmFkZEl0ZW0oc3ViLCBmaWx0ZXJzKTtcbiAgfVxuICBjcmVhdGVTdWJzY3JpcHRpb24oX3N1YiwgX2ZpbHRlcnMsIGZpbmdlcnByaW50KSB7XG4gICAgY29uc3QgcmVsYXlTdWIgPSBuZXcgTkRLUmVsYXlTdWJzY3JpcHRpb24odGhpcy5yZWxheSwgZmluZ2VycHJpbnQgfHwgbnVsbCwgdGhpcy5nZW5lcmFsU3ViTWFuYWdlcik7XG4gICAgcmVsYXlTdWIub25DbG9zZSA9IHRoaXMub25SZWxheVN1YnNjcmlwdGlvbkNsb3NlLmJpbmQodGhpcyk7XG4gICAgY29uc3QgY3VycmVudFZhbCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQocmVsYXlTdWIuZmluZ2VycHJpbnQpID8/IFtdO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQocmVsYXlTdWIuZmluZ2VycHJpbnQsIFsuLi5jdXJyZW50VmFsLCByZWxheVN1Yl0pO1xuICAgIHJldHVybiByZWxheVN1YjtcbiAgfVxuICBvblJlbGF5U3Vic2NyaXB0aW9uQ2xvc2Uoc3ViKSB7XG4gICAgbGV0IGN1cnJlbnRWYWwgPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KHN1Yi5maW5nZXJwcmludCkgPz8gW107XG4gICAgaWYgKCFjdXJyZW50VmFsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJVbmV4cGVjdGVkbHkgZGlkIG5vdCBmaW5kIGEgc3Vic2NyaXB0aW9uIHdpdGggZmluZ2VycHJpbnRcIiwgc3ViLmZpbmdlcnByaW50KTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRWYWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1Yi5maW5nZXJwcmludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRWYWwgPSBjdXJyZW50VmFsLmZpbHRlcigocykgPT4gcy5pZCAhPT0gc3ViLmlkKTtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQoc3ViLmZpbmdlcnByaW50LCBjdXJyZW50VmFsKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9yZWxheS9pbmRleC50c1xudmFyIE5ES1JlbGF5U3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoTkRLUmVsYXlTdGF0dXMyKSA9PiB7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJESVNDT05ORUNUSU5HXCJdID0gMF0gPSBcIkRJU0NPTk5FQ1RJTkdcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkRJU0NPTk5FQ1RFRFwiXSA9IDFdID0gXCJESVNDT05ORUNURURcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIlJFQ09OTkVDVElOR1wiXSA9IDJdID0gXCJSRUNPTk5FQ1RJTkdcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkZMQVBQSU5HXCJdID0gM10gPSBcIkZMQVBQSU5HXCI7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJDT05ORUNUSU5HXCJdID0gNF0gPSBcIkNPTk5FQ1RJTkdcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkNPTk5FQ1RFRFwiXSA9IDVdID0gXCJDT05ORUNURURcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkFVVEhfUkVRVUVTVEVEXCJdID0gNl0gPSBcIkFVVEhfUkVRVUVTVEVEXCI7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJBVVRIRU5USUNBVElOR1wiXSA9IDddID0gXCJBVVRIRU5USUNBVElOR1wiO1xuICBOREtSZWxheVN0YXR1czJbTkRLUmVsYXlTdGF0dXMyW1wiQVVUSEVOVElDQVRFRFwiXSA9IDhdID0gXCJBVVRIRU5USUNBVEVEXCI7XG4gIHJldHVybiBOREtSZWxheVN0YXR1czI7XG59KShOREtSZWxheVN0YXR1cyB8fCB7fSk7XG52YXIgTkRLUmVsYXkgPSBjbGFzcyBfTkRLUmVsYXkgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICB1cmw7XG4gIHNjb3JlcztcbiAgY29ubmVjdGl2aXR5O1xuICBzdWJzO1xuICBwdWJsaXNoZXI7XG4gIGF1dGhQb2xpY3k7XG4gIC8qKlxuICAgKiBUaGUgbG93ZXN0IHZhbGlkYXRpb24gcmF0aW8gdGhpcyByZWxheSBjYW4gcmVhY2guXG4gICAqL1xuICBsb3dlc3RWYWxpZGF0aW9uUmF0aW87XG4gIC8qKlxuICAgKiBDdXJyZW50IHZhbGlkYXRpb24gcmF0aW8gdGhpcyByZWxheSBpcyB0YXJnZXRpbmcuXG4gICAqL1xuICB0YXJnZXRWYWxpZGF0aW9uUmF0aW87XG4gIHZhbGlkYXRpb25SYXRpb0ZuO1xuICAvKipcbiAgICogVGhpcyB0cmFja3MgZXZlbnRzIHRoYXQgaGF2ZSBiZWVuIHNlZW4gYnkgdGhpcyByZWxheVxuICAgKiB3aXRoIGEgdmFsaWQgc2lnbmF0dXJlLlxuICAgKi9cbiAgdmFsaWRhdGVkRXZlbnRDb3VudCA9IDA7XG4gIC8qKlxuICAgKiBUaGlzIHRyYWNrcyBldmVudHMgdGhhdCBoYXZlIGJlZW4gc2VlbiBieSB0aGlzIHJlbGF5XG4gICAqIGJ1dCBoYXZlIG5vdCBiZWVuIHZhbGlkYXRlZC5cbiAgICovXG4gIG5vblZhbGlkYXRlZEV2ZW50Q291bnQgPSAwO1xuICAvKipcbiAgICogV2hldGhlciB0aGlzIHJlbGF5IGlzIHRydXN0ZWQuXG4gICAqXG4gICAqIFRydXN0ZWQgcmVsYXkncyBldmVudHMgZG8gbm90IGdldCB0aGVpciBzaWduYXR1cmUgdmVyaWZpZWQuXG4gICAqL1xuICB0cnVzdGVkID0gZmFsc2U7XG4gIGNvbXBsYWluaW5nID0gZmFsc2U7XG4gIGRlYnVnO1xuICBzdGF0aWMgZGVmYXVsdFZhbGlkYXRpb25SYXRpb1VwZGF0ZUZuID0gKHJlbGF5LCB2YWxpZGF0ZWRDb3VudCwgX25vblZhbGlkYXRlZENvdW50KSA9PiB7XG4gICAgaWYgKHJlbGF5Lmxvd2VzdFZhbGlkYXRpb25SYXRpbyA9PT0gdm9pZCAwIHx8IHJlbGF5LnRhcmdldFZhbGlkYXRpb25SYXRpbyA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICBsZXQgbmV3UmF0aW8gPSByZWxheS52YWxpZGF0aW9uUmF0aW87XG4gICAgaWYgKHJlbGF5LnZhbGlkYXRpb25SYXRpbyA+IHJlbGF5LnRhcmdldFZhbGlkYXRpb25SYXRpbykge1xuICAgICAgY29uc3QgZmFjdG9yID0gdmFsaWRhdGVkQ291bnQgLyAxMDA7XG4gICAgICBuZXdSYXRpbyA9IE1hdGgubWF4KHJlbGF5Lmxvd2VzdFZhbGlkYXRpb25SYXRpbywgcmVsYXkudmFsaWRhdGlvblJhdGlvIC0gZmFjdG9yKTtcbiAgICB9XG4gICAgaWYgKG5ld1JhdGlvIDwgcmVsYXkudmFsaWRhdGlvblJhdGlvKSB7XG4gICAgICByZXR1cm4gbmV3UmF0aW87XG4gICAgfVxuICAgIHJldHVybiByZWxheS52YWxpZGF0aW9uUmF0aW87XG4gIH07XG4gIGNvbnN0cnVjdG9yKHVybCwgYXV0aFBvbGljeSwgbmRrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVybCA9IG5vcm1hbGl6ZVJlbGF5VXJsKHVybCk7XG4gICAgdGhpcy5zY29yZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVidWcgPSBkZWJ1ZyhgbmRrOnJlbGF5OiR7dXJsfWApO1xuICAgIHRoaXMuY29ubmVjdGl2aXR5ID0gbmV3IE5ES1JlbGF5Q29ubmVjdGl2aXR5KHRoaXMsIG5kayk7XG4gICAgdGhpcy5jb25uZWN0aXZpdHkubmV0RGVidWcgPSBuZGs/Lm5ldERlYnVnO1xuICAgIHRoaXMucmVxID0gdGhpcy5jb25uZWN0aXZpdHkucmVxLmJpbmQodGhpcy5jb25uZWN0aXZpdHkpO1xuICAgIHRoaXMuY2xvc2UgPSB0aGlzLmNvbm5lY3Rpdml0eS5jbG9zZS5iaW5kKHRoaXMuY29ubmVjdGl2aXR5KTtcbiAgICB0aGlzLnN1YnMgPSBuZXcgTkRLUmVsYXlTdWJzY3JpcHRpb25NYW5hZ2VyKHRoaXMsIG5kay5zdWJNYW5hZ2VyKTtcbiAgICB0aGlzLnB1Ymxpc2hlciA9IG5ldyBOREtSZWxheVB1Ymxpc2hlcih0aGlzKTtcbiAgICB0aGlzLmF1dGhQb2xpY3kgPSBhdXRoUG9saWN5O1xuICAgIHRoaXMudGFyZ2V0VmFsaWRhdGlvblJhdGlvID0gbmRrPy5pbml0aWFsVmFsaWRhdGlvblJhdGlvO1xuICAgIHRoaXMubG93ZXN0VmFsaWRhdGlvblJhdGlvID0gbmRrPy5sb3dlc3RWYWxpZGF0aW9uUmF0aW87XG4gICAgdGhpcy52YWxpZGF0aW9uUmF0aW9GbiA9IChuZGs/LnZhbGlkYXRpb25SYXRpb0ZuID8/IF9OREtSZWxheS5kZWZhdWx0VmFsaWRhdGlvblJhdGlvVXBkYXRlRm4pLmJpbmQodGhpcyk7XG4gICAgdGhpcy51cGRhdGVWYWxpZGF0aW9uUmF0aW8oKTtcbiAgICBpZiAoIW5kaykge1xuICAgICAgY29uc29sZS50cmFjZShcInJlbGF5IGNyZWF0ZWQgd2l0aG91dCBuZGtcIik7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVZhbGlkYXRpb25SYXRpbygpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlVmFsaWRhdGlvblJhdGlvKCk7XG4gICAgfSwgM2U0KTtcbiAgfVxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eS5zdGF0dXM7XG4gIH1cbiAgZ2V0IGNvbm5lY3Rpb25TdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aXZpdHkuY29ubmVjdGlvblN0YXRzO1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byB0aGUgcmVsYXkuXG4gICAqL1xuICBhc3luYyBjb25uZWN0KHRpbWVvdXRNcywgcmVjb25uZWN0ID0gdHJ1ZSkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eS5jb25uZWN0KHRpbWVvdXRNcywgcmVjb25uZWN0KTtcbiAgfVxuICAvKipcbiAgICogRGlzY29ubmVjdHMgZnJvbSB0aGUgcmVsYXkuXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMSAvKiBESVNDT05ORUNURUQgKi8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0aXZpdHkuZGlzY29ubmVjdCgpO1xuICB9XG4gIC8qKlxuICAgKiBRdWV1ZXMgb3IgZXhlY3V0ZXMgdGhlIHN1YnNjcmlwdGlvbiBvZiBhIHNwZWNpZmljIHNldCBvZiBmaWx0ZXJzXG4gICAqIHdpdGhpbiB0aGlzIHJlbGF5LlxuICAgKlxuICAgKiBAcGFyYW0gc3Vic2NyaXB0aW9uIE5ES1N1YnNjcmlwdGlvbiB0aGlzIGZpbHRlcnMgYmVsb25nIHRvLlxuICAgKiBAcGFyYW0gZmlsdGVycyBGaWx0ZXJzIHRvIGV4ZWN1dGVcbiAgICovXG4gIHN1YnNjcmliZShzdWJzY3JpcHRpb24sIGZpbHRlcnMpIHtcbiAgICB0aGlzLnN1YnMuYWRkU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbiwgZmlsdGVycyk7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2hlcyBhbiBldmVudCB0byB0aGUgcmVsYXkgd2l0aCBhbiBvcHRpb25hbCB0aW1lb3V0LlxuICAgKlxuICAgKiBJZiB0aGUgcmVsYXkgaXMgbm90IGNvbm5lY3RlZCwgdGhlIGV2ZW50IHdpbGwgYmUgcHVibGlzaGVkIHdoZW4gdGhlIHJlbGF5IGNvbm5lY3RzLFxuICAgKiB1bmxlc3MgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZCBiZWZvcmUgdGhlIHJlbGF5IGNvbm5lY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHB1Ymxpc2hcbiAgICogQHBhcmFtIHRpbWVvdXRNcyBUaGUgdGltZW91dCBmb3IgdGhlIHB1Ymxpc2ggb3BlcmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBldmVudCBoYXMgYmVlbiBwdWJsaXNoZWQgb3IgcmVqZWN0cyBpZiB0aGUgb3BlcmF0aW9uIHRpbWVzIG91dFxuICAgKi9cbiAgYXN5bmMgcHVibGlzaChldmVudCwgdGltZW91dE1zID0gMjUwMCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5wdWJsaXNoKGV2ZW50LCB0aW1lb3V0TXMpO1xuICB9XG4gIHJlZmVyZW5jZVRhZ3MoKSB7XG4gICAgcmV0dXJuIFtbXCJyXCIsIHRoaXMudXJsXV07XG4gIH1cbiAgYWRkVmFsaWRhdGVkRXZlbnQoKSB7XG4gICAgdGhpcy52YWxpZGF0ZWRFdmVudENvdW50Kys7XG4gIH1cbiAgYWRkTm9uVmFsaWRhdGVkRXZlbnQoKSB7XG4gICAgdGhpcy5ub25WYWxpZGF0ZWRFdmVudENvdW50Kys7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHZhbGlkYXRpb24gcmF0aW8gdGhpcyByZWxheSBoYXMgYWNoaWV2ZWQuXG4gICAqL1xuICBnZXQgdmFsaWRhdGlvblJhdGlvKCkge1xuICAgIGlmICh0aGlzLm5vblZhbGlkYXRlZEV2ZW50Q291bnQgPT09IDApIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZWRFdmVudENvdW50IC8gKHRoaXMudmFsaWRhdGVkRXZlbnRDb3VudCArIHRoaXMubm9uVmFsaWRhdGVkRXZlbnRDb3VudCk7XG4gIH1cbiAgc2hvdWxkVmFsaWRhdGVFdmVudCgpIHtcbiAgICBpZiAodGhpcy50cnVzdGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnRhcmdldFZhbGlkYXRpb25SYXRpbyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGlvblJhdGlvIDwgdGhpcy50YXJnZXRWYWxpZGF0aW9uUmF0aW87XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aXZpdHkuY29ubmVjdGVkO1xuICB9XG4gIHJlcTtcbiAgY2xvc2U7XG59O1xuXG4vLyBzcmMvcmVsYXkvc2V0cy9pbmRleC50c1xudmFyIE5ES1B1Ymxpc2hFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBlcnJvcnM7XG4gIHB1Ymxpc2hlZFRvUmVsYXlzO1xuICAvKipcbiAgICogSW50ZW5kZWQgcmVsYXkgc2V0IHdoZXJlIHRoZSBwdWJsaXNoaW5nIHdhcyBpbnRlbmRlZCB0byBoYXBwZW4uXG4gICAqL1xuICBpbnRlbmRlZFJlbGF5U2V0O1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvcnMsIHB1Ymxpc2hlZFRvUmVsYXlzLCBpbnRlbmRlZFJlbGF5U2V0KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5wdWJsaXNoZWRUb1JlbGF5cyA9IHB1Ymxpc2hlZFRvUmVsYXlzO1xuICAgIHRoaXMuaW50ZW5kZWRSZWxheVNldCA9IGludGVuZGVkUmVsYXlTZXQ7XG4gIH1cbiAgZ2V0IHJlbGF5RXJyb3JzKCkge1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgW3JlbGF5LCBlcnJdIG9mIHRoaXMuZXJyb3JzKSB7XG4gICAgICBlcnJvcnMucHVzaChgJHtyZWxheS51cmx9OiAke2Vycn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycy5qb2luKFwiXFxuXCIpO1xuICB9XG59O1xudmFyIE5ES1JlbGF5U2V0ID0gY2xhc3MgX05ES1JlbGF5U2V0IHtcbiAgcmVsYXlzO1xuICBkZWJ1ZztcbiAgbmRrO1xuICBwb29sO1xuICBjb25zdHJ1Y3RvcihyZWxheXMsIG5kaywgcG9vbCkge1xuICAgIHRoaXMucmVsYXlzID0gcmVsYXlzO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMucG9vbCA9IHBvb2wgPz8gbmRrLnBvb2w7XG4gICAgdGhpcy5kZWJ1ZyA9IG5kay5kZWJ1Zy5leHRlbmQoXCJyZWxheXNldFwiKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHJlbGF5IHRvIHRoaXMgc2V0LlxuICAgKi9cbiAgYWRkUmVsYXkocmVsYXkpIHtcbiAgICB0aGlzLnJlbGF5cy5hZGQocmVsYXkpO1xuICB9XG4gIGdldCByZWxheVVybHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWxheXMpLm1hcCgocikgPT4gci51cmwpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVsYXkgc2V0IGZyb20gYSBsaXN0IG9mIHJlbGF5IFVSTHMuXG4gICAqXG4gICAqIElmIG5vIGNvbm5lY3Rpb24gdG8gdGhlIHJlbGF5IGlzIGZvdW5kIGluIHRoZSBwb29sIGl0IHdpbGwgdGVtcG9yYXJpbHlcbiAgICogY29ubmVjdCB0byBpdC5cbiAgICpcbiAgICogQHBhcmFtIHJlbGF5VXJscyAtIGxpc3Qgb2YgcmVsYXkgVVJMcyB0byBpbmNsdWRlIGluIHRoaXMgc2V0XG4gICAqIEBwYXJhbSBuZGtcbiAgICogQHBhcmFtIGNvbm5lY3QgLSB3aGV0aGVyIHRvIGNvbm5lY3QgdG8gdGhlIHJlbGF5IGltbWVkaWF0ZWx5IGlmIGl0IHdhcyBhbHJlYWR5IGluIHRoZSBwb29sIGJ1dCBub3QgY29ubmVjdGVkXG4gICAqIEByZXR1cm5zIE5ES1JlbGF5U2V0XG4gICAqL1xuICBzdGF0aWMgZnJvbVJlbGF5VXJscyhyZWxheVVybHMsIG5kaywgY29ubmVjdCA9IHRydWUsIHBvb2wpIHtcbiAgICBwb29sID0gcG9vbCA/PyBuZGsucG9vbDtcbiAgICBpZiAoIXBvb2wpIHRocm93IG5ldyBFcnJvcihcIk5vIHBvb2wgcHJvdmlkZWRcIik7XG4gICAgY29uc3QgcmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHVybCBvZiByZWxheVVybHMpIHtcbiAgICAgIGNvbnN0IHJlbGF5ID0gcG9vbC5yZWxheXMuZ2V0KG5vcm1hbGl6ZVJlbGF5VXJsKHVybCkpO1xuICAgICAgaWYgKHJlbGF5KSB7XG4gICAgICAgIGlmIChyZWxheS5zdGF0dXMgPCA1IC8qIENPTk5FQ1RFRCAqLyAmJiBjb25uZWN0KSB7XG4gICAgICAgICAgcmVsYXkuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlbGF5cy5hZGQocmVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGVtcG9yYXJ5UmVsYXkgPSBuZXcgTkRLUmVsYXkobm9ybWFsaXplUmVsYXlVcmwodXJsKSwgbmRrPy5yZWxheUF1dGhEZWZhdWx0UG9saWN5LCBuZGspO1xuICAgICAgICBwb29sLnVzZVRlbXBvcmFyeVJlbGF5KHRlbXBvcmFyeVJlbGF5LCB2b2lkIDAsIGByZXF1ZXN0ZWQgZnJvbSBmcm9tUmVsYXlVcmxzICR7cmVsYXlVcmxzfWApO1xuICAgICAgICByZWxheXMuYWRkKHRlbXBvcmFyeVJlbGF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfTkRLUmVsYXlTZXQobmV3IFNldChyZWxheXMpLCBuZGssIHBvb2wpO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoIGFuIGV2ZW50IHRvIGFsbCByZWxheXMgaW4gdGhpcyByZWxheSBzZXQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgYSByb2J1c3QgbWVjaGFuaXNtIGZvciBwdWJsaXNoaW5nIGV2ZW50cyB0byBtdWx0aXBsZSByZWxheXMgd2l0aFxuICAgKiBidWlsdC1pbiBoYW5kbGluZyBmb3IgcmFjZSBjb25kaXRpb25zLCB0aW1lb3V0cywgYW5kIHBhcnRpYWwgZmFpbHVyZXMuIFRoZSBpbXBsZW1lbnRhdGlvblxuICAgKiB1c2VzIGEgZHVhbC10cmFja2luZyBtZWNoYW5pc20gdG8gZW5zdXJlIGFjY3VyYXRlIHJlcG9ydGluZyBvZiB3aGljaCByZWxheXMgc3VjY2Vzc2Z1bGx5XG4gICAqIHJlY2VpdmVkIGFuIGV2ZW50LlxuICAgKlxuICAgKiBLZXkgYXNwZWN0cyBvZiB0aGlzIGltcGxlbWVudGF0aW9uOlxuICAgKlxuICAgKiAxLiBEVUFMLVRSQUNLSU5HIE1FQ0hBTklTTTpcbiAgICogICAgLSBQcm9taXNlLWJhc2VkIHRyYWNraW5nOiBSZWNvcmRzIHN1Y2Nlc3Nlcy9mYWlsdXJlcyBmcm9tIHRoZSBwcm9taXNlcyByZXR1cm5lZCBieSByZWxheS5wdWJsaXNoKClcbiAgICogICAgLSBFdmVudC1iYXNlZCB0cmFja2luZzogTGlzdGVucyBmb3IgJ3JlbGF5OnB1Ymxpc2hlZCcgZXZlbnRzIHRoYXQgaW5kaWNhdGUgc3VjY2Vzc2Z1bCBwdWJsaXNoaW5nXG4gICAqICAgIFRoaXMgYXBwcm9hY2ggZW5zdXJlcyB3ZSBkb24ndCBtaXNzIHN1Y2Nlc3NmdWwgcHVibGlzaGVzIGV2ZW4gaWYgdGhlcmUgYXJlIHN1YnNlcXVlbnQgZXJyb3JzIGluXG4gICAqICAgIHRoZSBwcm9taXNlIGNoYWluLlxuICAgKlxuICAgKiAyLiBSQUNFIENPTkRJVElPTiBIQU5ETElORzpcbiAgICogICAgLSBJZiBhIHJlbGF5IGVtaXRzIGEgc3VjY2VzcyBldmVudCBidXQgbGF0ZXIgZmFpbHMgaW4gdGhlIHByb21pc2UgY2hhaW4sIHdlIHN0aWxsIGNvdW50IGl0IGFzIGEgc3VjY2Vzc1xuICAgKiAgICAtIElmIGEgcmVsYXkgdGltZXMgb3V0IGFmdGVyIHN1Y2Nlc3NmdWxseSBwdWJsaXNoaW5nLCB3ZSBzdGlsbCBjb3VudCBpdCBhcyBhIHN1Y2Nlc3NcbiAgICogICAgLSBBbGwgcmVsYXkgb3BlcmF0aW9ucyBoYXBwZW4gaW4gcGFyYWxsZWwsIHdpdGggcHJvcGVyIHRyYWNraW5nIHJlZ2FyZGxlc3Mgb2YgY29tcGxldGlvbiBvcmRlclxuICAgKlxuICAgKiAzLiBUSU1FT1VUIE1BTkFHRU1FTlQ6XG4gICAqICAgIC0gSW5kaXZpZHVhbCB0aW1lb3V0cyBmb3IgZWFjaCByZWxheSBvcGVyYXRpb25cbiAgICogICAgLSBQcm9wZXIgY2xlYW51cCBvZiB0aW1lb3V0cyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgKiAgICAtIENsZWFyIHRpbWVvdXQgZXJyb3IgcmVwb3J0aW5nXG4gICAqXG4gICAqIDQuIEVSUk9SIEhBTkRMSU5HOlxuICAgKiAgICAtIERldGFpbGVkIHRyYWNraW5nIG9mIHNwZWNpZmljIGVycm9ycyBmb3IgZWFjaCBmYWlsZWQgcmVsYXlcbiAgICogICAgLSBTcGVjaWFsIGhhbmRsaW5nIGZvciBlcGhlbWVyYWwgZXZlbnRzICh3aGljaCBkb24ndCBleHBlY3QgYWNrbm93bGVkZ2VtZW50KVxuICAgKiAgICAtIFJlcXVpcmVkUmVsYXlDb3VudCBwYXJhbWV0ZXIgdG8gY29udHJvbCB0aGUgbWluaW11bSBzdWNjZXNzIHRocmVzaG9sZFxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgRXZlbnQgdG8gcHVibGlzaFxuICAgKiBAcGFyYW0gdGltZW91dE1zIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciBlYWNoIHJlbGF5IHB1Ymxpc2ggb3BlcmF0aW9uXG4gICAqIEBwYXJhbSByZXF1aXJlZFJlbGF5Q291bnQgVGhlIG1pbmltdW0gbnVtYmVyIG9mIHJlbGF5cyB3ZSBleHBlY3QgdGhlIGV2ZW50IHRvIGJlIHB1Ymxpc2hlZCB0b1xuICAgKiBAcmV0dXJucyBBIHNldCBvZiByZWxheXMgdGhlIGV2ZW50IHdhcyBwdWJsaXNoZWQgdG9cbiAgICogQHRocm93cyB7TkRLUHVibGlzaEVycm9yfSBJZiB0aGUgZXZlbnQgY291bGQgbm90IGJlIHB1Ymxpc2hlZCB0byBhdCBsZWFzdCBgcmVxdWlyZWRSZWxheUNvdW50YCByZWxheXNcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZWxheVNldCA9IG5ldyBOREtSZWxheVNldChuZXcgU2V0KFtyZWxheTEsIHJlbGF5Ml0pLCBuZGspO1xuICAgKiBjb25zdCBwdWJsaXNoZWRUb1JlbGF5cyA9IGF3YWl0IHJlbGF5U2V0LnB1Ymxpc2goZXZlbnQpO1xuICAgKiAvLyBwdWJsaXNoZWRUb1JlbGF5cyBjYW4gY29udGFpbiByZWxheTEsIHJlbGF5MiwgYm90aCwgb3Igbm9uZVxuICAgKiAvLyBkZXBlbmRpbmcgb24gd2hpY2ggcmVsYXlzIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZCB0b1xuICAgKiBpZiAocHVibGlzaGVkVG9SZWxheXMuc2l6ZSA+IDApIHtcbiAgICogICBjb25zb2xlLmxvZyhcIkV2ZW50IHB1Ymxpc2hlZCB0byBhdCBsZWFzdCBvbmUgcmVsYXlcIik7XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBwdWJsaXNoKGV2ZW50LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCA9IDEpIHtcbiAgICBjb25zdCBwdWJsaXNoZWRUb1JlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgZXJyb3JzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBpc0VwaGVtZXJhbDIgPSBldmVudC5pc0VwaGVtZXJhbCgpO1xuICAgIGV2ZW50LnB1Ymxpc2hTdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICBjb25zdCByZWxheVB1Ymxpc2hlZEhhbmRsZXIgPSAocmVsYXkpID0+IHtcbiAgICAgIHB1Ymxpc2hlZFRvUmVsYXlzLmFkZChyZWxheSk7XG4gICAgfTtcbiAgICBldmVudC5vbihcInJlbGF5OnB1Ymxpc2hlZFwiLCByZWxheVB1Ymxpc2hlZEhhbmRsZXIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IEFycmF5LmZyb20odGhpcy5yZWxheXMpLm1hcCgocmVsYXkpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGltZW91dElkID0gdGltZW91dE1zID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXB1Ymxpc2hlZFRvUmVsYXlzLmhhcyhyZWxheSkpIHtcbiAgICAgICAgICAgICAgZXJyb3JzLnNldChyZWxheSwgbmV3IEVycm9yKGBQdWJsaXNoIHRpbWVvdXQgYWZ0ZXIgJHt0aW1lb3V0TXN9bXNgKSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRpbWVvdXRNcykgOiBudWxsO1xuICAgICAgICAgIHJlbGF5LnB1Ymxpc2goZXZlbnQsIHRpbWVvdXRNcykudGhlbigoc3VjY2VzcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXRJZCkgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICBwdWJsaXNoZWRUb1JlbGF5cy5hZGQocmVsYXkpO1xuICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXRJZCkgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICBpZiAoIWlzRXBoZW1lcmFsMikge1xuICAgICAgICAgICAgICBlcnJvcnMuc2V0KHJlbGF5LCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICBpZiAocHVibGlzaGVkVG9SZWxheXMuc2l6ZSA8IHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgICAgICBpZiAoIWlzRXBoZW1lcmFsMikge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IE5ES1B1Ymxpc2hFcnJvcihcbiAgICAgICAgICAgIFwiTm90IGVub3VnaCByZWxheXMgcmVjZWl2ZWQgdGhlIGV2ZW50XCIsXG4gICAgICAgICAgICBlcnJvcnMsXG4gICAgICAgICAgICBwdWJsaXNoZWRUb1JlbGF5cyxcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICApO1xuICAgICAgICAgIGV2ZW50LnB1Ymxpc2hTdGF0dXMgPSBcImVycm9yXCI7XG4gICAgICAgICAgZXZlbnQucHVibGlzaEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgdGhpcy5uZGs/LmVtaXQoXCJldmVudDpwdWJsaXNoLWZhaWxlZFwiLCBldmVudCwgZXJyb3IsIHRoaXMucmVsYXlVcmxzKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZlbnQucHVibGlzaFN0YXR1cyA9IFwic3VjY2Vzc1wiO1xuICAgICAgICBldmVudC5lbWl0KFwicHVibGlzaGVkXCIsIHsgcmVsYXlTZXQ6IHRoaXMsIHB1Ymxpc2hlZFRvUmVsYXlzIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHB1Ymxpc2hlZFRvUmVsYXlzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBldmVudC5vZmYoXCJyZWxheTpwdWJsaXNoZWRcIiwgcmVsYXlQdWJsaXNoZWRIYW5kbGVyKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXlzLnNpemU7XG4gIH1cbn07XG5cbi8vIHNyYy9yZWxheS9zZXRzL2NhbGN1bGF0ZS50c1xudmFyIGQgPSBjcmVhdGVEZWJ1ZyhcIm5kazpvdXRib3g6Y2FsY3VsYXRlXCIpO1xuYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXlTZXRGcm9tRXZlbnQobmRrLCBldmVudCkge1xuICBjb25zdCByZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBhdXRob3JXcml0ZVJlbGF5cyA9IGF3YWl0IGdldFdyaXRlUmVsYXlzRm9yKG5kaywgZXZlbnQucHVia2V5KTtcbiAgaWYgKGF1dGhvcldyaXRlUmVsYXlzKSB7XG4gICAgYXV0aG9yV3JpdGVSZWxheXMuZm9yRWFjaCgocmVsYXlVcmwpID0+IHtcbiAgICAgIGNvbnN0IHJlbGF5ID0gbmRrLnBvb2w/LmdldFJlbGF5KHJlbGF5VXJsKTtcbiAgICAgIGlmIChyZWxheSkgcmVsYXlzLmFkZChyZWxheSk7XG4gICAgfSk7XG4gIH1cbiAgbGV0IHJlbGF5SGludHMgPSBldmVudC50YWdzLmZpbHRlcigodGFnKSA9PiBbXCJhXCIsIFwiZVwiXS5pbmNsdWRlcyh0YWdbMF0pKS5tYXAoKHRhZykgPT4gdGFnWzJdKS5maWx0ZXIoKHVybCkgPT4gdXJsPy5zdGFydHNXaXRoKFwid3NzOi8vXCIpKS5maWx0ZXIoKHVybCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBuZXcgVVJMKHVybCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pLm1hcCgodXJsKSA9PiBub3JtYWxpemVSZWxheVVybCh1cmwpKTtcbiAgcmVsYXlIaW50cyA9IEFycmF5LmZyb20obmV3IFNldChyZWxheUhpbnRzKSkuc2xpY2UoMCwgNSk7XG4gIHJlbGF5SGludHMuZm9yRWFjaCgocmVsYXlVcmwpID0+IHtcbiAgICBjb25zdCByZWxheSA9IG5kay5wb29sPy5nZXRSZWxheShyZWxheVVybCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgaWYgKHJlbGF5KSB7XG4gICAgICBkKFwiQWRkaW5nIHJlbGF5IGhpbnQgJXNcIiwgcmVsYXlVcmwpO1xuICAgICAgcmVsYXlzLmFkZChyZWxheSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgcFRhZ3MgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICBpZiAocFRhZ3MubGVuZ3RoIDwgNSkge1xuICAgIGNvbnN0IHBUYWdnZWRSZWxheXMgPSBBcnJheS5mcm9tKFxuICAgICAgY2hvb3NlUmVsYXlDb21iaW5hdGlvbkZvclB1YmtleXMobmRrLCBwVGFncywgXCJyZWFkXCIsIHtcbiAgICAgICAgcHJlZmVycmVkUmVsYXlzOiBuZXcgU2V0KGF1dGhvcldyaXRlUmVsYXlzKVxuICAgICAgfSkua2V5cygpXG4gICAgKTtcbiAgICBwVGFnZ2VkUmVsYXlzLmZvckVhY2goKHJlbGF5VXJsKSA9PiB7XG4gICAgICBjb25zdCByZWxheSA9IG5kay5wb29sPy5nZXRSZWxheShyZWxheVVybCwgZmFsc2UsIHRydWUpO1xuICAgICAgaWYgKHJlbGF5KSB7XG4gICAgICAgIGQoXCJBZGRpbmcgcC10YWdnZWQgcmVsYXkgJXNcIiwgcmVsYXlVcmwpO1xuICAgICAgICByZWxheXMuYWRkKHJlbGF5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkKFwiVG9vIG1hbnkgcC10YWdzIHRvIGNvbnNpZGVyICVkXCIsIHBUYWdzLmxlbmd0aCk7XG4gIH1cbiAgbmRrLnBvb2w/LnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLmZvckVhY2goKHJlbGF5KSA9PiByZWxheXMuYWRkKHJlbGF5KSk7XG4gIHJldHVybiBuZXcgTkRLUmVsYXlTZXQocmVsYXlzLCBuZGspO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXlTZXRzRnJvbUZpbHRlcihuZGssIGZpbHRlcnMsIHBvb2wpIHtcbiAgY29uc3QgcmVzdWx0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgYXV0aG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZpbHRlcnMuZm9yRWFjaCgoZmlsdGVyKSA9PiB7XG4gICAgaWYgKGZpbHRlci5hdXRob3JzKSB7XG4gICAgICBmaWx0ZXIuYXV0aG9ycy5mb3JFYWNoKChhdXRob3IpID0+IGF1dGhvcnMuYWRkKGF1dGhvcikpO1xuICAgIH1cbiAgfSk7XG4gIGlmIChhdXRob3JzLnNpemUgPiAwKSB7XG4gICAgY29uc3QgYXV0aG9yVG9SZWxheXNNYXAgPSBnZXRSZWxheXNGb3JGaWx0ZXJXaXRoQXV0aG9ycyhuZGssIEFycmF5LmZyb20oYXV0aG9ycykpO1xuICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2YgYXV0aG9yVG9SZWxheXNNYXAua2V5cygpKSB7XG4gICAgICByZXN1bHQuc2V0KHJlbGF5VXJsLCBbXSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlcnMpIHtcbiAgICAgIGlmIChmaWx0ZXIuYXV0aG9ycykge1xuICAgICAgICBmb3IgKGNvbnN0IFtyZWxheVVybCwgYXV0aG9yczJdIG9mIGF1dGhvclRvUmVsYXlzTWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgIGNvbnN0IGF1dGhvckZpbHRlckFuZFJlbGF5UHVia2V5SW50ZXJzZWN0aW9uID0gZmlsdGVyLmF1dGhvcnMuZmlsdGVyKFxuICAgICAgICAgICAgKGF1dGhvcikgPT4gYXV0aG9yczIuaW5jbHVkZXMoYXV0aG9yKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzdWx0LnNldChyZWxheVVybCwgW1xuICAgICAgICAgICAgLi4ucmVzdWx0LmdldChyZWxheVVybCksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLmZpbHRlcixcbiAgICAgICAgICAgICAgLy8gT3ZlcndyaXRlIGF1dGhvcnMgc2VudCB0byB0aGlzIHJlbGF5IHdpdGggdGhlIGF1dGhvcnMgdGhhdCB3ZXJlXG4gICAgICAgICAgICAgIC8vIHByZXNlbnQgaW4gdGhlIGZpbHRlciBhbmQgYXJlIGFsc28gcHJlc2VudCBpbiB0aGUgcmVsYXlcbiAgICAgICAgICAgICAgYXV0aG9yczogYXV0aG9yRmlsdGVyQW5kUmVsYXlQdWJrZXlJbnRlcnNlY3Rpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCByZWxheVVybCBvZiBhdXRob3JUb1JlbGF5c01hcC5rZXlzKCkpIHtcbiAgICAgICAgICByZXN1bHQuc2V0KHJlbGF5VXJsLCBbLi4ucmVzdWx0LmdldChyZWxheVVybCksIGZpbHRlcl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChuZGsuZXhwbGljaXRSZWxheVVybHMpIHtcbiAgICAgIG5kay5leHBsaWNpdFJlbGF5VXJscy5mb3JFYWNoKChyZWxheVVybCkgPT4ge1xuICAgICAgICByZXN1bHQuc2V0KHJlbGF5VXJsLCBmaWx0ZXJzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAocmVzdWx0LnNpemUgPT09IDApIHtcbiAgICBwb29sLnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLnNsaWNlKDAsIDUpLmZvckVhY2goKHJlbGF5KSA9PiB7XG4gICAgICByZXN1bHQuc2V0KHJlbGF5LnVybCwgZmlsdGVycyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlbGF5U2V0c0Zyb21GaWx0ZXJzKG5kaywgZmlsdGVycywgcG9vbCkge1xuICBjb25zdCBhID0gY2FsY3VsYXRlUmVsYXlTZXRzRnJvbUZpbHRlcihuZGssIGZpbHRlcnMsIHBvb2wpO1xuICByZXR1cm4gYTtcbn1cblxuLy8gc3JjL2V2ZW50cy9jb250ZW50LXRhZ2dlci50c1xuaW1wb3J0IHsgbmlwMTkgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbmZ1bmN0aW9uIG1lcmdlVGFncyh0YWdzMSwgdGFnczIpIHtcbiAgY29uc3QgdGFnTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgZ2VuZXJhdGVLZXkgPSAodGFnKSA9PiB0YWcuam9pbihcIixcIik7XG4gIGNvbnN0IGlzQ29udGFpbmVkID0gKHNtYWxsZXIsIGxhcmdlcikgPT4ge1xuICAgIHJldHVybiBzbWFsbGVyLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlID09PSBsYXJnZXJbaW5kZXhdKTtcbiAgfTtcbiAgY29uc3QgcHJvY2Vzc1RhZyA9ICh0YWcpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIGV4aXN0aW5nVGFnXSBvZiB0YWdNYXApIHtcbiAgICAgIGlmIChpc0NvbnRhaW5lZChleGlzdGluZ1RhZywgdGFnKSB8fCBpc0NvbnRhaW5lZCh0YWcsIGV4aXN0aW5nVGFnKSkge1xuICAgICAgICBpZiAodGFnLmxlbmd0aCA+PSBleGlzdGluZ1RhZy5sZW5ndGgpIHtcbiAgICAgICAgICB0YWdNYXAuc2V0KGtleSwgdGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRhZ01hcC5zZXQoZ2VuZXJhdGVLZXkodGFnKSwgdGFnKTtcbiAgfTtcbiAgdGFnczEuY29uY2F0KHRhZ3MyKS5mb3JFYWNoKHByb2Nlc3NUYWcpO1xuICByZXR1cm4gQXJyYXkuZnJvbSh0YWdNYXAudmFsdWVzKCkpO1xufVxuZnVuY3Rpb24gdW5pcXVlVGFnKGEsIGIpIHtcbiAgY29uc3QgYUxlbmd0aCA9IGEubGVuZ3RoO1xuICBjb25zdCBiTGVuZ3RoID0gYi5sZW5ndGg7XG4gIGNvbnN0IHNhbWVMZW5ndGggPSBhTGVuZ3RoID09PSBiTGVuZ3RoO1xuICBpZiAoc2FtZUxlbmd0aCkge1xuICAgIGlmIChhLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBiW2ldKSkge1xuICAgICAgcmV0dXJuIFthXTtcbiAgICB9XG4gICAgcmV0dXJuIFthLCBiXTtcbiAgfVxuICBpZiAoYUxlbmd0aCA+IGJMZW5ndGggJiYgYS5ldmVyeSgodiwgaSkgPT4gdiA9PT0gYltpXSkpIHtcbiAgICByZXR1cm4gW2FdO1xuICB9XG4gIGlmIChiTGVuZ3RoID4gYUxlbmd0aCAmJiBiLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBhW2ldKSkge1xuICAgIHJldHVybiBbYl07XG4gIH1cbiAgcmV0dXJuIFthLCBiXTtcbn1cbnZhciBoYXNodGFnUmVnZXggPSAvKD88PVxcc3xeKSgjW15cXHMhQCMkJV4mKigpPSsuLyxbe1xcXX07OidcIj8+PF0rKS9nO1xuZnVuY3Rpb24gZ2VuZXJhdGVIYXNodGFncyhjb250ZW50KSB7XG4gIGNvbnN0IGhhc2h0YWdzID0gY29udGVudC5tYXRjaChoYXNodGFnUmVnZXgpO1xuICBjb25zdCB0YWdJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCB0YWcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBpZiAoaGFzaHRhZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGhhc2h0YWcgb2YgaGFzaHRhZ3MpIHtcbiAgICAgIGlmICh0YWdJZHMuaGFzKGhhc2h0YWcuc2xpY2UoMSkpKSBjb250aW51ZTtcbiAgICAgIHRhZy5hZGQoaGFzaHRhZy5zbGljZSgxKSk7XG4gICAgICB0YWdJZHMuYWRkKGhhc2h0YWcuc2xpY2UoMSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbSh0YWcpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50VGFncyhjb250ZW50LCB0YWdzID0gW10pIHtcbiAgY29uc3QgdGFnUmVnZXggPSAvKEB8bm9zdHI6KShucHVifG5wcm9maWxlfG5vdGV8bmV2ZW50fG5hZGRyKVthLXpBLVowLTldKy9nO1xuICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICBjb25zdCBhZGRUYWdJZk5ldyA9ICh0KSA9PiB7XG4gICAgaWYgKCF0YWdzLmZpbmQoKHQyKSA9PiBbXCJxXCIsIHRbMF1dLmluY2x1ZGVzKHQyWzBdKSAmJiB0MlsxXSA9PT0gdFsxXSkpIHtcbiAgICAgIHRhZ3MucHVzaCh0KTtcbiAgICB9XG4gIH07XG4gIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UodGFnUmVnZXgsICh0YWcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZW50aXR5ID0gdGFnLnNwbGl0KC8oQHxub3N0cjopLylbMl07XG4gICAgICBjb25zdCB7IHR5cGUsIGRhdGEgfSA9IG5pcDE5LmRlY29kZShlbnRpdHkpO1xuICAgICAgbGV0IHQ7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm5wdWJcIjpcbiAgICAgICAgICB0ID0gW1wicFwiLCBkYXRhXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5wcm9maWxlXCI6XG4gICAgICAgICAgdCA9IFtcInBcIiwgZGF0YS5wdWJrZXldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibm90ZVwiOlxuICAgICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICBhZGRUYWdJZk5ldyhbXCJxXCIsIGRhdGEsIGF3YWl0IG1heWJlR2V0RXZlbnRSZWxheVVybChlbnRpdHkpXSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5ldmVudFwiOlxuICAgICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7IGlkLCBhdXRob3IgfSA9IGRhdGE7XG4gICAgICAgICAgICAgIGxldCB7IHJlbGF5cyB9ID0gZGF0YTtcbiAgICAgICAgICAgICAgaWYgKCFyZWxheXMgfHwgcmVsYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlbGF5cyA9IFthd2FpdCBtYXliZUdldEV2ZW50UmVsYXlVcmwoZW50aXR5KV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYWRkVGFnSWZOZXcoW1wicVwiLCBpZCwgcmVsYXlzWzBdXSk7XG4gICAgICAgICAgICAgIGlmIChhdXRob3IpIGFkZFRhZ0lmTmV3KFtcInBcIiwgYXV0aG9yXSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5hZGRyXCI6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGlkID0gW2RhdGEua2luZCwgZGF0YS5wdWJrZXksIGRhdGEuaWRlbnRpZmllcl0uam9pbihcIjpcIik7XG4gICAgICAgICAgICAgIGxldCByZWxheXMgPSBkYXRhLnJlbGF5cyA/PyBbXTtcbiAgICAgICAgICAgICAgaWYgKHJlbGF5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZWxheXMgPSBbYXdhaXQgbWF5YmVHZXRFdmVudFJlbGF5VXJsKGVudGl0eSldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFkZFRhZ0lmTmV3KFtcInFcIiwgaWQsIHJlbGF5c1swXV0pO1xuICAgICAgICAgICAgICBhZGRUYWdJZk5ldyhbXCJwXCIsIGRhdGEucHVia2V5XSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgfVxuICAgICAgaWYgKHQpIGFkZFRhZ0lmTmV3KHQpO1xuICAgICAgcmV0dXJuIGBub3N0cjoke2VudGl0eX1gO1xuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG4gIH0pO1xuICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIGNvbnN0IG5ld1RhZ3MgPSBnZW5lcmF0ZUhhc2h0YWdzKGNvbnRlbnQpLm1hcCgoaGFzaHRhZykgPT4gW1widFwiLCBoYXNodGFnXSk7XG4gIHRhZ3MgPSBtZXJnZVRhZ3ModGFncywgbmV3VGFncyk7XG4gIHJldHVybiB7IGNvbnRlbnQsIHRhZ3MgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG1heWJlR2V0RXZlbnRSZWxheVVybChfbmlwMTlJZCkge1xuICByZXR1cm4gXCJcIjtcbn1cblxuLy8gc3JjL2V2ZW50cy9lbmNyeXB0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0KHJlY2lwaWVudCwgc2lnbmVyLCBzY2hlbWUgPSBcIm5pcDQ0XCIpIHtcbiAgbGV0IGVuY3J5cHRlZDtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kIVwiKTtcbiAgbGV0IGN1cnJlbnRTaWduZXIgPSBzaWduZXI7XG4gIGlmICghY3VycmVudFNpZ25lcikge1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGN1cnJlbnRTaWduZXIgPSB0aGlzLm5kay5zaWduZXI7XG4gIH1cbiAgaWYgKCFjdXJyZW50U2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBOREsgc2lnbmVyXCIpO1xuICBjb25zdCBjdXJyZW50UmVjaXBpZW50ID0gcmVjaXBpZW50IHx8ICgoKSA9PiB7XG4gICAgY29uc3QgcFRhZ3MgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIik7XG4gICAgaWYgKHBUYWdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVjaXBpZW50IGNvdWxkIGJlIGRldGVybWluZWQgYW5kIG5vIGV4cGxpY2l0IHJlY2lwaWVudCB3YXMgcHJvdmlkZWRcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5OiBwVGFnc1swXVsxXSB9KTtcbiAgfSkoKTtcbiAgaWYgKHNjaGVtZSA9PT0gXCJuaXA0NFwiICYmIGF3YWl0IGlzRW5jcnlwdGlvbkVuYWJsZWQoY3VycmVudFNpZ25lciwgXCJuaXA0NFwiKSkge1xuICAgIGVuY3J5cHRlZCA9IGF3YWl0IGN1cnJlbnRTaWduZXIuZW5jcnlwdChjdXJyZW50UmVjaXBpZW50LCB0aGlzLmNvbnRlbnQsIFwibmlwNDRcIik7XG4gIH1cbiAgaWYgKCghZW5jcnlwdGVkIHx8IHNjaGVtZSA9PT0gXCJuaXAwNFwiKSAmJiBhd2FpdCBpc0VuY3J5cHRpb25FbmFibGVkKGN1cnJlbnRTaWduZXIsIFwibmlwMDRcIikpIHtcbiAgICBlbmNyeXB0ZWQgPSBhd2FpdCBjdXJyZW50U2lnbmVyLmVuY3J5cHQoY3VycmVudFJlY2lwaWVudCwgdGhpcy5jb250ZW50LCBcIm5pcDA0XCIpO1xuICB9XG4gIGlmICghZW5jcnlwdGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZW5jcnlwdCBldmVudC5cIik7XG4gIHRoaXMuY29udGVudCA9IGVuY3J5cHRlZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQoc2VuZGVyLCBzaWduZXIsIHNjaGVtZSkge1xuICBpZiAodGhpcy5uZGs/LmNhY2hlQWRhcHRlcj8uZ2V0RGVjcnlwdGVkRXZlbnQpIHtcbiAgICBsZXQgY2FjaGVkRXZlbnQgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmdldERlY3J5cHRlZEV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNhY2hlZEV2ZW50ID0gdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmdldERlY3J5cHRlZEV2ZW50KHRoaXMuaWQpO1xuICAgIH1cbiAgICBpZiAoY2FjaGVkRXZlbnQpIHtcbiAgICAgIHRoaXMuY29udGVudCA9IGNhY2hlZEV2ZW50LmNvbnRlbnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGxldCBkZWNyeXB0ZWQ7XG4gIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZCFcIik7XG4gIGxldCBjdXJyZW50U2lnbmVyID0gc2lnbmVyO1xuICBpZiAoIWN1cnJlbnRTaWduZXIpIHtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBjdXJyZW50U2lnbmVyID0gdGhpcy5uZGsuc2lnbmVyO1xuICB9XG4gIGlmICghY3VycmVudFNpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwibm8gTkRLIHNpZ25lclwiKTtcbiAgY29uc3QgY3VycmVudFNlbmRlciA9IHNlbmRlciB8fCB0aGlzLmF1dGhvcjtcbiAgaWYgKCFjdXJyZW50U2VuZGVyKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzZW5kZXIgcHJvdmlkZWQgYW5kIG5vIGF1dGhvciBhdmFpbGFibGVcIik7XG4gIGNvbnN0IGN1cnJlbnRTY2hlbWUgPSBzY2hlbWUgfHwgKHRoaXMuY29udGVudC5tYXRjaCgvXFxcXD9pdj0vKSA/IFwibmlwMDRcIiA6IFwibmlwNDRcIik7XG4gIGlmICgoY3VycmVudFNjaGVtZSA9PT0gXCJuaXAwNFwiIHx8IHRoaXMua2luZCA9PT0gNCkgJiYgYXdhaXQgaXNFbmNyeXB0aW9uRW5hYmxlZChjdXJyZW50U2lnbmVyLCBcIm5pcDA0XCIpICYmIHRoaXMuY29udGVudC5zZWFyY2goXCJcXFxcP2l2PVwiKSkge1xuICAgIGRlY3J5cHRlZCA9IGF3YWl0IGN1cnJlbnRTaWduZXIuZGVjcnlwdChjdXJyZW50U2VuZGVyLCB0aGlzLmNvbnRlbnQsIFwibmlwMDRcIik7XG4gIH1cbiAgaWYgKCFkZWNyeXB0ZWQgJiYgY3VycmVudFNjaGVtZSA9PT0gXCJuaXA0NFwiICYmIGF3YWl0IGlzRW5jcnlwdGlvbkVuYWJsZWQoY3VycmVudFNpZ25lciwgXCJuaXA0NFwiKSkge1xuICAgIGRlY3J5cHRlZCA9IGF3YWl0IGN1cnJlbnRTaWduZXIuZGVjcnlwdChjdXJyZW50U2VuZGVyLCB0aGlzLmNvbnRlbnQsIFwibmlwNDRcIik7XG4gIH1cbiAgaWYgKCFkZWNyeXB0ZWQpIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNyeXB0IGV2ZW50LlwiKTtcbiAgdGhpcy5jb250ZW50ID0gZGVjcnlwdGVkO1xuICBpZiAodGhpcy5uZGs/LmNhY2hlQWRhcHRlcj8uYWRkRGVjcnlwdGVkRXZlbnQpIHtcbiAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuYWRkRGVjcnlwdGVkRXZlbnQodGhpcyk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGlzRW5jcnlwdGlvbkVuYWJsZWQoc2lnbmVyLCBzY2hlbWUpIHtcbiAgaWYgKCFzaWduZXIuZW5jcnlwdGlvbkVuYWJsZWQpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFzY2hlbWUpIHJldHVybiB0cnVlO1xuICByZXR1cm4gQm9vbGVhbihhd2FpdCBzaWduZXIuZW5jcnlwdGlvbkVuYWJsZWQoc2NoZW1lKSk7XG59XG5cbi8vIHNyYy90aHJlYWQvaW5kZXgudHNcbmZ1bmN0aW9uIGV2ZW50c0J5U2FtZUF1dGhvcihvcCwgZXZlbnRzKSB7XG4gIGNvbnN0IGV2ZW50c0J5QXV0aG9yID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZXZlbnRzQnlBdXRob3Iuc2V0KG9wLmlkLCBvcCk7XG4gIGV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5wdWJrZXkgPT09IG9wLnB1YmtleSkge1xuICAgICAgZXZlbnRzQnlBdXRob3Iuc2V0KGV2ZW50LmlkLCBldmVudCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGV2ZW50c0J5QXV0aG9yO1xufVxudmFyIGhhc01hcmtlcnMgPSAoZXZlbnQsIHRhZ1R5cGUpID0+IHtcbiAgcmV0dXJuIGV2ZW50LmdldE1hdGNoaW5nVGFncyh0YWdUeXBlKS5zb21lKCh0YWcpID0+IHRhZ1szXSAmJiB0YWdbM10gIT09IFwiXCIpO1xufTtcbmZ1bmN0aW9uIGV2ZW50SXNSZXBseShvcCwgZXZlbnQsIHRocmVhZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIHRhZ1R5cGUpIHtcbiAgdGFnVHlwZSA/Pz0gb3AudGFnVHlwZSgpO1xuICBjb25zdCB0YWdzID0gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKHRhZ1R5cGUpO1xuICB0aHJlYWRJZHMuYWRkKG9wLnRhZ0lkKCkpO1xuICBpZiAodGhyZWFkSWRzLmhhcyhldmVudC50YWdJZCgpKSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBoZWVkRXhwbGljaXRSZXBseU1hcmtlciA9ICgpID0+IHtcbiAgICBsZXQgZXZlbnRJc1RhZ2dlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgIGlmICh0YWdbM10gPT09IFwicmVwbHlcIikgcmV0dXJuIHRocmVhZElkcy5oYXModGFnWzFdKTtcbiAgICAgIGNvbnN0IG1hcmtlcklzRW1wdHkgPSB0YWdbM10gPT09IFwiXCIgfHwgdGFnWzNdID09PSB2b2lkIDA7XG4gICAgICBjb25zdCBtYXJrZXJJc1Jvb3QgPSB0YWdbM10gPT09IFwicm9vdFwiO1xuICAgICAgaWYgKHRhZ1sxXSA9PT0gb3AudGFnSWQoKSAmJiAobWFya2VySXNFbXB0eSB8fCBtYXJrZXJJc1Jvb3QpKSB7XG4gICAgICAgIGV2ZW50SXNUYWdnZWQgPSBtYXJrZXJJc1Jvb3QgPyBcInJvb3RcIiA6IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZXZlbnRJc1RhZ2dlZCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChldmVudElzVGFnZ2VkID09PSBcInJvb3RcIikgcmV0dXJuIHRydWU7XG4gIH07XG4gIGNvbnN0IGV4cGxpY2l0UmVwbHlNYXJrZXIgPSBoZWVkRXhwbGljaXRSZXBseU1hcmtlcigpO1xuICBpZiAoZXhwbGljaXRSZXBseU1hcmtlciAhPT0gdm9pZCAwKSByZXR1cm4gZXhwbGljaXRSZXBseU1hcmtlcjtcbiAgaWYgKGhhc01hcmtlcnMoZXZlbnQsIHRhZ1R5cGUpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGV4cGVjdGVkVGFncyA9IG9wLmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gIGV4cGVjdGVkVGFncy5wdXNoKG9wLmlkKTtcbiAgcmV0dXJuIGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImVcIikuZXZlcnkoKHRhZykgPT4gZXhwZWN0ZWRUYWdzLmluY2x1ZGVzKHRhZ1sxXSkpO1xufVxuZnVuY3Rpb24gZXZlbnRUaHJlYWRzKG9wLCBldmVudHMpIHtcbiAgY29uc3QgZXZlbnRzQnlBdXRob3IgPSBldmVudHNCeVNhbWVBdXRob3Iob3AsIGV2ZW50cyk7XG4gIGNvbnN0IHRocmVhZEV2ZW50cyA9IGV2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiBldmVudElzUGFydE9mVGhyZWFkKG9wLCBldmVudCwgZXZlbnRzQnlBdXRob3IpKTtcbiAgcmV0dXJuIHRocmVhZEV2ZW50cy5zb3J0KChhLCBiKSA9PiBhLmNyZWF0ZWRfYXQgLSBiLmNyZWF0ZWRfYXQpO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRSZXBseUlkKGV2ZW50KSB7XG4gIGNvbnN0IHJlcGx5VGFnID0gZ2V0UmVwbHlUYWcoZXZlbnQpO1xuICBpZiAocmVwbHlUYWcpIHJldHVybiByZXBseVRhZ1sxXTtcbiAgY29uc3Qgcm9vdFRhZyA9IGdldFJvb3RUYWcoZXZlbnQpO1xuICBpZiAocm9vdFRhZykgcmV0dXJuIHJvb3RUYWdbMV07XG59XG5mdW5jdGlvbiBpc0V2ZW50T3JpZ2luYWxQb3N0KGV2ZW50KSB7XG4gIHJldHVybiBnZXRFdmVudFJlcGx5SWQoZXZlbnQpID09PSB2b2lkIDA7XG59XG5mdW5jdGlvbiBldmVudFRocmVhZElkcyhvcCwgZXZlbnRzKSB7XG4gIGNvbnN0IHRocmVhZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHRocmVhZEV2ZW50cyA9IGV2ZW50VGhyZWFkcyhvcCwgZXZlbnRzKTtcbiAgdGhyZWFkRXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB0aHJlYWRJZHMuc2V0KGV2ZW50LmlkLCBldmVudCkpO1xuICByZXR1cm4gdGhyZWFkSWRzO1xufVxuZnVuY3Rpb24gZXZlbnRSZXBsaWVzKG9wLCBldmVudHMsIHRocmVhZEV2ZW50SWRzKSB7XG4gIHRocmVhZEV2ZW50SWRzID8/PSBuZXcgU2V0KGV2ZW50VGhyZWFkSWRzKG9wLCBldmVudHMpLmtleXMoKSk7XG4gIHJldHVybiBldmVudHMuZmlsdGVyKChldmVudCkgPT4gZXZlbnRJc1JlcGx5KG9wLCBldmVudCwgdGhyZWFkRXZlbnRJZHMpKTtcbn1cbmZ1bmN0aW9uIGV2ZW50SXNQYXJ0T2ZUaHJlYWQob3AsIGV2ZW50LCBldmVudHNCeUF1dGhvcikge1xuICBpZiAob3AucHVia2V5ICE9PSBldmVudC5wdWJrZXkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgdGFnZ2VkRXZlbnRJZHMgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJlXCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICBjb25zdCBhbGxUYWdnZWRFdmVudHNBcmVCeU9yaWdpbmFsQXV0aG9yID0gdGFnZ2VkRXZlbnRJZHMuZXZlcnkoKGlkKSA9PiBldmVudHNCeUF1dGhvci5oYXMoaWQpKTtcbiAgcmV0dXJuIGFsbFRhZ2dlZEV2ZW50c0FyZUJ5T3JpZ2luYWxBdXRob3I7XG59XG5mdW5jdGlvbiBldmVudEhhc0VUYWdNYXJrZXJzKGV2ZW50KSB7XG4gIGZvciAoY29uc3QgdGFnIG9mIGV2ZW50LnRhZ3MpIHtcbiAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiAodGFnWzNdID8/IFwiXCIpLmxlbmd0aCA+IDApIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFJvb3RFdmVudElkKGV2ZW50LCBzZWFyY2hUYWcpIHtcbiAgc2VhcmNoVGFnID8/PSBldmVudC50YWdUeXBlKCk7XG4gIGNvbnN0IHJvb3RFdmVudFRhZyA9IGdldFJvb3RUYWcoZXZlbnQsIHNlYXJjaFRhZyk7XG4gIGlmIChyb290RXZlbnRUYWcpIHJldHVybiByb290RXZlbnRUYWdbMV07XG4gIGNvbnN0IHJlcGx5VGFnID0gZ2V0UmVwbHlUYWcoZXZlbnQsIHNlYXJjaFRhZyk7XG4gIHJldHVybiByZXBseVRhZz8uWzFdO1xufVxuZnVuY3Rpb24gZ2V0Um9vdFRhZyhldmVudCwgc2VhcmNoVGFnKSB7XG4gIHNlYXJjaFRhZyA/Pz0gZXZlbnQudGFnVHlwZSgpO1xuICBjb25zdCByb290RXZlbnRUYWcgPSBldmVudC50YWdzLmZpbmQoaXNUYWdSb290VGFnKTtcbiAgaWYgKCFyb290RXZlbnRUYWcpIHtcbiAgICBpZiAoZXZlbnRIYXNFVGFnTWFya2VycyhldmVudCkpIHJldHVybjtcbiAgICBjb25zdCBtYXRjaGluZ1RhZ3MgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3Moc2VhcmNoVGFnKTtcbiAgICBpZiAobWF0Y2hpbmdUYWdzLmxlbmd0aCA8IDMpIHJldHVybiBtYXRjaGluZ1RhZ3NbMF07XG4gIH1cbiAgcmV0dXJuIHJvb3RFdmVudFRhZztcbn1cbnZhciBuaXAyMlJvb3RUYWdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiQVwiLCBcIkVcIiwgXCJJXCJdKTtcbnZhciBuaXAyMlJlcGx5VGFncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImFcIiwgXCJlXCIsIFwiaVwiXSk7XG5mdW5jdGlvbiBnZXRSZXBseVRhZyhldmVudCwgc2VhcmNoVGFnKSB7XG4gIGlmIChldmVudC5raW5kID09PSAxMTExIC8qIEdlbmVyaWNSZXBseSAqLykge1xuICAgIGxldCByZXBseVRhZzI7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgZXZlbnQudGFncykge1xuICAgICAgaWYgKG5pcDIyUm9vdFRhZ3MuaGFzKHRhZ1swXSkpIHJlcGx5VGFnMiA9IHRhZztcbiAgICAgIGVsc2UgaWYgKG5pcDIyUmVwbHlUYWdzLmhhcyh0YWdbMF0pKSB7XG4gICAgICAgIHJlcGx5VGFnMiA9IHRhZztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBseVRhZzI7XG4gIH1cbiAgc2VhcmNoVGFnID8/PSBldmVudC50YWdUeXBlKCk7XG4gIGxldCBoYXNNYXJrZXJzMiA9IGZhbHNlO1xuICBsZXQgcmVwbHlUYWc7XG4gIGZvciAoY29uc3QgdGFnIG9mIGV2ZW50LnRhZ3MpIHtcbiAgICBpZiAodGFnWzBdICE9PSBzZWFyY2hUYWcpIGNvbnRpbnVlO1xuICAgIGlmICgodGFnWzNdID8/IFwiXCIpLmxlbmd0aCA+IDApIGhhc01hcmtlcnMyID0gdHJ1ZTtcbiAgICBpZiAoaGFzTWFya2VyczIgJiYgdGFnWzNdID09PSBcInJlcGx5XCIpIHJldHVybiB0YWc7XG4gICAgaWYgKGhhc01hcmtlcnMyICYmIHRhZ1szXSA9PT0gXCJyb290XCIpIHJlcGx5VGFnID0gdGFnO1xuICAgIGlmICghaGFzTWFya2VyczIpIHJlcGx5VGFnID0gdGFnO1xuICB9XG4gIHJldHVybiByZXBseVRhZztcbn1cbmZ1bmN0aW9uIGlzVGFnUm9vdFRhZyh0YWcpIHtcbiAgcmV0dXJuIHRhZ1swXSA9PT0gXCJFXCIgfHwgdGFnWzNdID09PSBcInJvb3RcIjtcbn1cblxuLy8gc3JjL2V2ZW50cy9mZXRjaC10YWdnZWQtZXZlbnQudHNcbmFzeW5jIGZ1bmN0aW9uIGZldGNoVGFnZ2VkRXZlbnQodGFnLCBtYXJrZXIpIHtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBmb3VuZFwiKTtcbiAgY29uc3QgdCA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKHRhZywgbWFya2VyKTtcbiAgaWYgKHQubGVuZ3RoID09PSAwKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBbXywgaWQsIGhpbnRdID0gdFswXTtcbiAgbGV0IHJlbGF5ID0gaGludCAhPT0gXCJcIiA/IHRoaXMubmRrLnBvb2wuZ2V0UmVsYXkoaGludCkgOiB2b2lkIDA7XG4gIGNvbnN0IGV2ZW50ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudChpZCwge30sIHJlbGF5KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSb290RXZlbnQoc3ViT3B0cykge1xuICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IGZvdW5kXCIpO1xuICBjb25zdCByb290VGFnID0gZ2V0Um9vdFRhZyh0aGlzKTtcbiAgaWYgKCFyb290VGFnKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4gdGhpcy5uZGsuZmV0Y2hFdmVudEZyb21UYWcocm9vdFRhZywgdGhpcywgc3ViT3B0cyk7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFJlcGx5RXZlbnQoc3ViT3B0cykge1xuICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IGZvdW5kXCIpO1xuICBjb25zdCByZXBseVRhZyA9IGdldFJlcGx5VGFnKHRoaXMpO1xuICBpZiAoIXJlcGx5VGFnKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4gdGhpcy5uZGsuZmV0Y2hFdmVudEZyb21UYWcocmVwbHlUYWcsIHRoaXMsIHN1Yk9wdHMpO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmQudHNcbmZ1bmN0aW9uIGlzUmVwbGFjZWFibGUoKSB7XG4gIGlmICh0aGlzLmtpbmQgPT09IHZvaWQgMCkgdGhyb3cgbmV3IEVycm9yKFwiS2luZCBub3Qgc2V0XCIpO1xuICByZXR1cm4gWzAsIDNdLmluY2x1ZGVzKHRoaXMua2luZCkgfHwgdGhpcy5raW5kID49IDFlNCAmJiB0aGlzLmtpbmQgPCAyZTQgfHwgdGhpcy5raW5kID49IDNlNCAmJiB0aGlzLmtpbmQgPCA0ZTQ7XG59XG5mdW5jdGlvbiBpc0VwaGVtZXJhbCgpIHtcbiAgaWYgKHRoaXMua2luZCA9PT0gdm9pZCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJLaW5kIG5vdCBzZXRcIik7XG4gIHJldHVybiB0aGlzLmtpbmQgPj0gMmU0ICYmIHRoaXMua2luZCA8IDNlNDtcbn1cbmZ1bmN0aW9uIGlzUGFyYW1SZXBsYWNlYWJsZSgpIHtcbiAgaWYgKHRoaXMua2luZCA9PT0gdm9pZCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJLaW5kIG5vdCBzZXRcIik7XG4gIHJldHVybiB0aGlzLmtpbmQgPj0gM2U0ICYmIHRoaXMua2luZCA8IDRlNDtcbn1cblxuLy8gc3JjL2V2ZW50cy9uaXAxOS50c1xuaW1wb3J0IHsgbmlwMTkgYXMgbmlwMTkyIH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG52YXIgREVGQVVMVF9SRUxBWV9DT1VOVCA9IDI7XG5mdW5jdGlvbiBlbmNvZGUobWF4UmVsYXlDb3VudCA9IERFRkFVTFRfUkVMQVlfQ09VTlQpIHtcbiAgbGV0IHJlbGF5cyA9IFtdO1xuICBpZiAodGhpcy5vblJlbGF5cy5sZW5ndGggPiAwKSB7XG4gICAgcmVsYXlzID0gdGhpcy5vblJlbGF5cy5tYXAoKHJlbGF5KSA9PiByZWxheS51cmwpO1xuICB9IGVsc2UgaWYgKHRoaXMucmVsYXkpIHtcbiAgICByZWxheXMgPSBbdGhpcy5yZWxheS51cmxdO1xuICB9XG4gIGlmIChyZWxheXMubGVuZ3RoID4gbWF4UmVsYXlDb3VudCkge1xuICAgIHJlbGF5cyA9IHJlbGF5cy5zbGljZSgwLCBtYXhSZWxheUNvdW50KTtcbiAgfVxuICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgIHJldHVybiBuaXAxOTIubmFkZHJFbmNvZGUoe1xuICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgcHVia2V5OiB0aGlzLnB1YmtleSxcbiAgICAgIGlkZW50aWZpZXI6IHRoaXMucmVwbGFjZWFibGVEVGFnKCksXG4gICAgICByZWxheXNcbiAgICB9KTtcbiAgfVxuICBpZiAocmVsYXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gbmlwMTkyLm5ldmVudEVuY29kZSh7XG4gICAgICBpZDogdGhpcy50YWdJZCgpLFxuICAgICAgcmVsYXlzLFxuICAgICAgYXV0aG9yOiB0aGlzLnB1YmtleVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBuaXAxOTIubm90ZUVuY29kZSh0aGlzLnRhZ0lkKCkpO1xufVxuXG4vLyBzcmMvZXZlbnRzL3JlcG9zdC50c1xuYXN5bmMgZnVuY3Rpb24gcmVwb3N0KHB1Ymxpc2ggPSB0cnVlLCBzaWduZXIpIHtcbiAgaWYgKCFzaWduZXIgJiYgcHVibGlzaCkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBzaWduZXIgPSB0aGlzLm5kay5zaWduZXI7XG4gIH1cbiAgY29uc3QgZSA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywge1xuICAgIGtpbmQ6IGdldEtpbmQodGhpcylcbiAgfSk7XG4gIGlmICghdGhpcy5pc1Byb3RlY3RlZCkgZS5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkodGhpcy5yYXdFdmVudCgpKTtcbiAgZS50YWcodGhpcyk7XG4gIGlmICh0aGlzLmtpbmQgIT09IDEgLyogVGV4dCAqLykge1xuICAgIGUudGFncy5wdXNoKFtcImtcIiwgYCR7dGhpcy5raW5kfWBdKTtcbiAgfVxuICBpZiAoc2lnbmVyKSBhd2FpdCBlLnNpZ24oc2lnbmVyKTtcbiAgaWYgKHB1Ymxpc2gpIGF3YWl0IGUucHVibGlzaCgpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGdldEtpbmQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmtpbmQgPT09IDEpIHtcbiAgICByZXR1cm4gNiAvKiBSZXBvc3QgKi87XG4gIH1cbiAgcmV0dXJuIDE2IC8qIEdlbmVyaWNSZXBvc3QgKi87XG59XG5cbi8vIHNyYy9ldmVudHMvc2VyaWFsaXplci50c1xuZnVuY3Rpb24gc2VyaWFsaXplKGluY2x1ZGVTaWcgPSBmYWxzZSwgaW5jbHVkZUlkID0gZmFsc2UpIHtcbiAgY29uc3QgcGF5bG9hZCA9IFswLCB0aGlzLnB1YmtleSwgdGhpcy5jcmVhdGVkX2F0LCB0aGlzLmtpbmQsIHRoaXMudGFncywgdGhpcy5jb250ZW50XTtcbiAgaWYgKGluY2x1ZGVTaWcpIHBheWxvYWQucHVzaCh0aGlzLnNpZyk7XG4gIGlmIChpbmNsdWRlSWQpIHBheWxvYWQucHVzaCh0aGlzLmlkKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZEV2ZW50KSB7XG4gIGNvbnN0IGV2ZW50QXJyYXkgPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWRFdmVudCk7XG4gIGNvbnN0IHJldCA9IHtcbiAgICBwdWJrZXk6IGV2ZW50QXJyYXlbMV0sXG4gICAgY3JlYXRlZF9hdDogZXZlbnRBcnJheVsyXSxcbiAgICBraW5kOiBldmVudEFycmF5WzNdLFxuICAgIHRhZ3M6IGV2ZW50QXJyYXlbNF0sXG4gICAgY29udGVudDogZXZlbnRBcnJheVs1XVxuICB9O1xuICBpZiAoZXZlbnRBcnJheS5sZW5ndGggPj0gNykge1xuICAgIGNvbnN0IGZpcnN0ID0gZXZlbnRBcnJheVs2XTtcbiAgICBjb25zdCBzZWNvbmQgPSBldmVudEFycmF5WzddO1xuICAgIGlmIChmaXJzdCAmJiBmaXJzdC5sZW5ndGggPT09IDEyOCkge1xuICAgICAgcmV0LnNpZyA9IGZpcnN0O1xuICAgICAgaWYgKHNlY29uZCAmJiBzZWNvbmQubGVuZ3RoID09PSA2NCkge1xuICAgICAgICByZXQuaWQgPSBzZWNvbmQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaXJzdCAmJiBmaXJzdC5sZW5ndGggPT09IDY0KSB7XG4gICAgICByZXQuaWQgPSBmaXJzdDtcbiAgICAgIGlmIChzZWNvbmQgJiYgc2Vjb25kLmxlbmd0aCA9PT0gMTI4KSB7XG4gICAgICAgIHJldC5zaWcgPSBzZWNvbmQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIHNyYy9ldmVudHMvdmFsaWRhdGlvbi50c1xuaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5pbXBvcnQgeyBieXRlc1RvSGV4IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IExSVUNhY2hlIH0gZnJvbSBcInR5cGVzY3JpcHQtbHJ1LWNhY2hlXCI7XG5cbi8vIHNyYy9ldmVudHMvc2lnbmF0dXJlLnRzXG52YXIgd29ya2VyO1xudmFyIHByb2Nlc3NpbmdRdWV1ZSA9IHt9O1xuZnVuY3Rpb24gc2lnbmF0dXJlVmVyaWZpY2F0aW9uSW5pdCh3KSB7XG4gIHdvcmtlciA9IHc7XG4gIHdvcmtlci5vbm1lc3NhZ2UgPSAobXNnKSA9PiB7XG4gICAgY29uc3QgW2V2ZW50SWQsIHJlc3VsdF0gPSBtc2cuZGF0YTtcbiAgICBjb25zdCByZWNvcmQgPSBwcm9jZXNzaW5nUXVldWVbZXZlbnRJZF07XG4gICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyByZWNvcmQgZm91bmQgZm9yIGV2ZW50XCIsIGV2ZW50SWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgcHJvY2Vzc2luZ1F1ZXVlW2V2ZW50SWRdO1xuICAgIGZvciAoY29uc3QgcmVzb2x2ZSBvZiByZWNvcmQucmVzb2x2ZXMpIHtcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmVBc3luYyhldmVudCwgX3BlcnNpc3QpIHtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IGV2ZW50LnNlcmlhbGl6ZSgpO1xuICAgIGxldCBlbnF1ZXVlID0gZmFsc2U7XG4gICAgaWYgKCFwcm9jZXNzaW5nUXVldWVbZXZlbnQuaWRdKSB7XG4gICAgICBwcm9jZXNzaW5nUXVldWVbZXZlbnQuaWRdID0geyBldmVudCwgcmVzb2x2ZXM6IFtdIH07XG4gICAgICBlbnF1ZXVlID0gdHJ1ZTtcbiAgICB9XG4gICAgcHJvY2Vzc2luZ1F1ZXVlW2V2ZW50LmlkXS5yZXNvbHZlcy5wdXNoKHJlc29sdmUpO1xuICAgIGlmICghZW5xdWV1ZSkgcmV0dXJuO1xuICAgIHdvcmtlcj8ucG9zdE1lc3NhZ2Uoe1xuICAgICAgc2VyaWFsaXplZCxcbiAgICAgIGlkOiBldmVudC5pZCxcbiAgICAgIHNpZzogZXZlbnQuc2lnLFxuICAgICAgcHVia2V5OiBldmVudC5wdWJrZXlcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBzcmMvZXZlbnRzL3ZhbGlkYXRpb24udHNcbnZhciBQVUJLRVlfUkVHRVggPSAvXlthLWYwLTldezY0fSQvO1xuZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIGlmICh0eXBlb2YgdGhpcy5raW5kICE9PSBcIm51bWJlclwiKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgdGhpcy5jb250ZW50ICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgdGhpcy5jcmVhdGVkX2F0ICE9PSBcIm51bWJlclwiKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgdGhpcy5wdWJrZXkgIT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcbiAgaWYgKCF0aGlzLnB1YmtleS5tYXRjaChQVUJLRVlfUkVHRVgpKSByZXR1cm4gZmFsc2U7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLnRhZ3MpKSByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdzW2ldO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWcpKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YWcubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnW2pdID09PSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxudmFyIHZlcmlmaWVkU2lnbmF0dXJlcyA9IG5ldyBMUlVDYWNoZSh7XG4gIG1heFNpemU6IDFlMyxcbiAgZW50cnlFeHBpcmF0aW9uVGltZUluTVM6IDZlNFxufSk7XG5mdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmUocGVyc2lzdCkge1xuICBpZiAodHlwZW9mIHRoaXMuc2lnbmF0dXJlVmVyaWZpZWQgPT09IFwiYm9vbGVhblwiKSByZXR1cm4gdGhpcy5zaWduYXR1cmVWZXJpZmllZDtcbiAgY29uc3QgcHJldlZlcmlmaWNhdGlvbiA9IHZlcmlmaWVkU2lnbmF0dXJlcy5nZXQodGhpcy5pZCk7XG4gIGlmIChwcmV2VmVyaWZpY2F0aW9uICE9PSBudWxsKSB7XG4gICAgdGhpcy5zaWduYXR1cmVWZXJpZmllZCA9ICEhcHJldlZlcmlmaWNhdGlvbjtcbiAgICByZXR1cm4gdGhpcy5zaWduYXR1cmVWZXJpZmllZDtcbiAgfVxuICB0cnkge1xuICAgIGlmICh0aGlzLm5kaz8uYXN5bmNTaWdWZXJpZmljYXRpb24pIHtcbiAgICAgIHZlcmlmeVNpZ25hdHVyZUFzeW5jKHRoaXMsIHBlcnNpc3QpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAocGVyc2lzdCkge1xuICAgICAgICAgIHRoaXMuc2lnbmF0dXJlVmVyaWZpZWQgPSByZXN1bHQ7XG4gICAgICAgICAgaWYgKHJlc3VsdCkgdmVyaWZpZWRTaWduYXR1cmVzLnNldCh0aGlzLmlkLCB0aGlzLnNpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICB0aGlzLm5kaz8uZW1pdChcImV2ZW50OmludmFsaWQtc2lnXCIsIHRoaXMpO1xuICAgICAgICAgIHZlcmlmaWVkU2lnbmF0dXJlcy5zZXQodGhpcy5pZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGFzaCA9IHNoYTI1NihuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGhpcy5zZXJpYWxpemUoKSkpO1xuICAgICAgY29uc3QgcmVzID0gc2Nobm9yci52ZXJpZnkodGhpcy5zaWcsIGhhc2gsIHRoaXMucHVia2V5KTtcbiAgICAgIGlmIChyZXMpIHZlcmlmaWVkU2lnbmF0dXJlcy5zZXQodGhpcy5pZCwgdGhpcy5zaWcpO1xuICAgICAgZWxzZSB2ZXJpZmllZFNpZ25hdHVyZXMuc2V0KHRoaXMuaWQsIGZhbHNlKTtcbiAgICAgIHRoaXMuc2lnbmF0dXJlVmVyaWZpZWQgPSByZXM7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfSBjYXRjaCAoX2Vycikge1xuICAgIHRoaXMuc2lnbmF0dXJlVmVyaWZpZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEV2ZW50SGFzaCgpIHtcbiAgcmV0dXJuIGdldEV2ZW50SGFzaEZyb21TZXJpYWxpemVkRXZlbnQodGhpcy5zZXJpYWxpemUoKSk7XG59XG5mdW5jdGlvbiBnZXRFdmVudEhhc2hGcm9tU2VyaWFsaXplZEV2ZW50KHNlcmlhbGl6ZWRFdmVudCkge1xuICBjb25zdCBldmVudEhhc2ggPSBzaGEyNTYobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlcmlhbGl6ZWRFdmVudCkpO1xuICByZXR1cm4gYnl0ZXNUb0hleChldmVudEhhc2gpO1xufVxuXG4vLyBzcmMvZXZlbnRzL2luZGV4LnRzXG52YXIgc2tpcENsaWVudFRhZ09uS2luZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIDAgLyogTWV0YWRhdGEgKi8sXG4gIDQgLyogRW5jcnlwdGVkRGlyZWN0TWVzc2FnZSAqLyxcbiAgMTA1OSAvKiBHaWZ0V3JhcCAqLyxcbiAgMTMgLyogR2lmdFdyYXBTZWFsICovLFxuICAzIC8qIENvbnRhY3RzICovLFxuICA5NzM0IC8qIFphcFJlcXVlc3QgKi8sXG4gIDUgLyogRXZlbnREZWxldGlvbiAqL1xuXSk7XG52YXIgTkRLRXZlbnQgPSBjbGFzcyBfTkRLRXZlbnQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIyIHtcbiAgbmRrO1xuICBjcmVhdGVkX2F0O1xuICBjb250ZW50ID0gXCJcIjtcbiAgdGFncyA9IFtdO1xuICBraW5kO1xuICBpZCA9IFwiXCI7XG4gIHNpZztcbiAgcHVia2V5ID0gXCJcIjtcbiAgc2lnbmF0dXJlVmVyaWZpZWQ7XG4gIF9hdXRob3IgPSB2b2lkIDA7XG4gIC8qKlxuICAgKiBUaGUgcmVsYXkgdGhhdCB0aGlzIGV2ZW50IHdhcyBmaXJzdCByZWNlaXZlZCBmcm9tLlxuICAgKi9cbiAgcmVsYXk7XG4gIC8qKlxuICAgKiBUaGUgcmVsYXlzIHRoYXQgdGhpcyBldmVudCB3YXMgcmVjZWl2ZWQgZnJvbSBhbmQvb3Igc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZCB0by5cbiAgICovXG4gIGdldCBvblJlbGF5cygpIHtcbiAgICBsZXQgcmVzID0gW107XG4gICAgaWYgKCF0aGlzLm5kaykge1xuICAgICAgaWYgKHRoaXMucmVsYXkpIHJlcy5wdXNoKHRoaXMucmVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB0aGlzLm5kay5zdWJNYW5hZ2VyLnNlZW5FdmVudHMuZ2V0KHRoaXMuaWQpIHx8IFtdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc3RhdHVzIG9mIHRoZSBwdWJsaXNoIG9wZXJhdGlvbi5cbiAgICovXG4gIHB1Ymxpc2hTdGF0dXMgPSBcInN1Y2Nlc3NcIjtcbiAgcHVibGlzaEVycm9yO1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLmNyZWF0ZWRfYXQgPSBldmVudD8uY3JlYXRlZF9hdDtcbiAgICB0aGlzLmNvbnRlbnQgPSBldmVudD8uY29udGVudCB8fCBcIlwiO1xuICAgIHRoaXMudGFncyA9IGV2ZW50Py50YWdzIHx8IFtdO1xuICAgIHRoaXMuaWQgPSBldmVudD8uaWQgfHwgXCJcIjtcbiAgICB0aGlzLnNpZyA9IGV2ZW50Py5zaWc7XG4gICAgdGhpcy5wdWJrZXkgPSBldmVudD8ucHVia2V5IHx8IFwiXCI7XG4gICAgdGhpcy5raW5kID0gZXZlbnQ/LmtpbmQ7XG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgX05ES0V2ZW50KSB7XG4gICAgICBpZiAodGhpcy5yZWxheSkge1xuICAgICAgICB0aGlzLnJlbGF5ID0gZXZlbnQucmVsYXk7XG4gICAgICAgIHRoaXMubmRrPy5zdWJNYW5hZ2VyLnNlZW5FdmVudChldmVudC5pZCwgdGhpcy5yZWxheSk7XG4gICAgICB9XG4gICAgICB0aGlzLnB1Ymxpc2hTdGF0dXMgPSBldmVudC5wdWJsaXNoU3RhdHVzO1xuICAgICAgdGhpcy5wdWJsaXNoRXJyb3IgPSBldmVudC5wdWJsaXNoRXJyb3I7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBhbiBOREtFdmVudCBmcm9tIGEgc2VyaWFsaXplZCBwYXlsb2FkLlxuICAgKiBAcGFyYW0gbmRrXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RhdGljIGRlc2VyaWFsaXplKG5kaywgZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtFdmVudChuZGssIGRlc2VyaWFsaXplKGV2ZW50KSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGV2ZW50IGFzIGlzLlxuICAgKi9cbiAgcmF3RXZlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZWRfYXQ6IHRoaXMuY3JlYXRlZF9hdCxcbiAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudCxcbiAgICAgIHRhZ3M6IHRoaXMudGFncyxcbiAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgIHB1YmtleTogdGhpcy5wdWJrZXksXG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIHNpZzogdGhpcy5zaWdcbiAgICB9O1xuICB9XG4gIHNldCBhdXRob3IodXNlcikge1xuICAgIHRoaXMucHVia2V5ID0gdXNlci5wdWJrZXk7XG4gICAgdGhpcy5fYXV0aG9yID0gdXNlcjtcbiAgICB0aGlzLl9hdXRob3IubmRrID8/PSB0aGlzLm5kaztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBOREtVc2VyIGZvciB0aGUgYXV0aG9yIG9mIHRoZSBldmVudC5cbiAgICovXG4gIGdldCBhdXRob3IoKSB7XG4gICAgaWYgKHRoaXMuX2F1dGhvcikgcmV0dXJuIHRoaXMuX2F1dGhvcjtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgY29uc3QgdXNlciA9IHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXk6IHRoaXMucHVia2V5IH0pO1xuICAgIHRoaXMuX2F1dGhvciA9IHVzZXI7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgLyoqXG4gICAqIE5JUC03MyB0YWdnaW5nIG9mIGV4dGVybmFsIGVudGl0aWVzXG4gICAqIEBwYXJhbSBlbnRpdHkgdG8gYmUgdGFnZ2VkXG4gICAqIEBwYXJhbSB0eXBlIG9mIHRoZSBlbnRpdHlcbiAgICogQHBhcmFtIG1hcmtlclVybCB0byBiZSB1c2VkIGFzIHRoZSBtYXJrZXIgVVJMXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogZXZlbnQudGFnRXh0ZXJuYWwoXCJodHRwczovL2V4YW1wbGUuY29tL2FydGljbGUvMTIzI25vc3RyXCIsIFwidXJsXCIpO1xuICAgKiBldmVudC50YWdzID0+IFtbXCJpXCIsIFwiaHR0cHM6Ly9leGFtcGxlLmNvbS8xMjNcIl0sIFtcImtcIiwgXCJodHRwczovL2V4YW1wbGUuY29tXCJdXVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGUgdGFnIGEgcG9kY2FzdDppdGVtOmd1aWRcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBldmVudC50YWdFeHRlcm5hbChcImUzMmI0ODkwLWI5ZWEtNGFlZi1hMGJmLTU0Yjc4NzgzM2RjNVwiLCBcInBvZGNhc3Q6aXRlbTpndWlkXCIpO1xuICAgKiBldmVudC50YWdzID0+IFtbXCJpXCIsIFwicG9kY2FzdDppdGVtOmd1aWQ6ZTMyYjQ4OTAtYjllYS00YWVmLWEwYmYtNTRiNzg3ODMzZGM1XCJdLCBbXCJrXCIsIFwicG9kY2FzdDppdGVtOmd1aWRcIl1dXG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzczLm1kXG4gICAqL1xuICB0YWdFeHRlcm5hbChlbnRpdHksIHR5cGUsIG1hcmtlclVybCkge1xuICAgIGNvbnN0IGlUYWcgPSBbXCJpXCJdO1xuICAgIGNvbnN0IGtUYWcgPSBbXCJrXCJdO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcInVybFwiOiB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoZW50aXR5KTtcbiAgICAgICAgdXJsLmhhc2ggPSBcIlwiO1xuICAgICAgICBpVGFnLnB1c2godXJsLnRvU3RyaW5nKCkpO1xuICAgICAgICBrVGFnLnB1c2goYCR7dXJsLnByb3RvY29sfS8vJHt1cmwuaG9zdH1gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiaGFzaHRhZ1wiOlxuICAgICAgICBpVGFnLnB1c2goYCMke2VudGl0eS50b0xvd2VyQ2FzZSgpfWApO1xuICAgICAgICBrVGFnLnB1c2goXCIjXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJnZW9oYXNoXCI6XG4gICAgICAgIGlUYWcucHVzaChgZ2VvOiR7ZW50aXR5LnRvTG93ZXJDYXNlKCl9YCk7XG4gICAgICAgIGtUYWcucHVzaChcImdlb1wiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaXNiblwiOlxuICAgICAgICBpVGFnLnB1c2goYGlzYm46JHtlbnRpdHkucmVwbGFjZSgvLS9nLCBcIlwiKX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwiaXNiblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicG9kY2FzdDpndWlkXCI6XG4gICAgICAgIGlUYWcucHVzaChgcG9kY2FzdDpndWlkOiR7ZW50aXR5fWApO1xuICAgICAgICBrVGFnLnB1c2goXCJwb2RjYXN0Omd1aWRcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvZGNhc3Q6aXRlbTpndWlkXCI6XG4gICAgICAgIGlUYWcucHVzaChgcG9kY2FzdDppdGVtOmd1aWQ6JHtlbnRpdHl9YCk7XG4gICAgICAgIGtUYWcucHVzaChcInBvZGNhc3Q6aXRlbTpndWlkXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb2RjYXN0OnB1Ymxpc2hlcjpndWlkXCI6XG4gICAgICAgIGlUYWcucHVzaChgcG9kY2FzdDpwdWJsaXNoZXI6Z3VpZDoke2VudGl0eX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwicG9kY2FzdDpwdWJsaXNoZXI6Z3VpZFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaXNhblwiOlxuICAgICAgICBpVGFnLnB1c2goYGlzYW46JHtlbnRpdHkuc3BsaXQoXCItXCIpLnNsaWNlKDAsIDQpLmpvaW4oXCItXCIpfWApO1xuICAgICAgICBrVGFnLnB1c2goXCJpc2FuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkb2lcIjpcbiAgICAgICAgaVRhZy5wdXNoKGBkb2k6JHtlbnRpdHkudG9Mb3dlckNhc2UoKX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwiZG9pXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgTklQLTczIGVudGl0eSB0eXBlOiAke3R5cGV9YCk7XG4gICAgfVxuICAgIGlmIChtYXJrZXJVcmwpIHtcbiAgICAgIGlUYWcucHVzaChtYXJrZXJVcmwpO1xuICAgIH1cbiAgICB0aGlzLnRhZ3MucHVzaChpVGFnKTtcbiAgICB0aGlzLnRhZ3MucHVzaChrVGFnKTtcbiAgfVxuICAvKipcbiAgICogVGFnIGEgdXNlciB3aXRoIGFuIG9wdGlvbmFsIG1hcmtlci5cbiAgICogQHBhcmFtIHRhcmdldCBXaGF0IGlzIHRvIGJlIHRhZ2dlZC4gQ2FuIGJlIGFuIE5ES1VzZXIsIE5ES0V2ZW50LCBvciBhbiBOREtUYWcuXG4gICAqIEBwYXJhbSBtYXJrZXIgVGhlIG1hcmtlciB0byB1c2UgaW4gdGhlIHRhZy5cbiAgICogQHBhcmFtIHNraXBBdXRob3JUYWcgV2hldGhlciB0byBleHBsaWNpdGx5IHNraXAgYWRkaW5nIHRoZSBhdXRob3IgdGFnIG9mIHRoZSBldmVudC5cbiAgICogQHBhcmFtIGZvcmNlVGFnIEZvcmNlIGEgc3BlY2lmaWMgdGFnIHRvIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBcImVcIiBvciBcImFcIiB0YWcuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogcmVwbHkudGFnKG9wRXZlbnQsIFwicmVwbHlcIik7XG4gICAqIC8vIHJlcGx5LnRhZ3MgPT4gW1tcImVcIiwgPGlkPiwgPHJlbGF5PiwgXCJyZXBseVwiXV1cbiAgICogYGBgXG4gICAqL1xuICB0YWcodGFyZ2V0LCBtYXJrZXIsIHNraXBBdXRob3JUYWcsIGZvcmNlVGFnKSB7XG4gICAgbGV0IHRhZ3MgPSBbXTtcbiAgICBjb25zdCBpc05ES1VzZXIgPSB0YXJnZXQuZmV0Y2hQcm9maWxlICE9PSB2b2lkIDA7XG4gICAgaWYgKGlzTkRLVXNlcikge1xuICAgICAgZm9yY2VUYWcgPz89IFwicFwiO1xuICAgICAgY29uc3QgdGFnID0gW2ZvcmNlVGFnLCB0YXJnZXQucHVia2V5XTtcbiAgICAgIGlmIChtYXJrZXIpIHRhZy5wdXNoKC4uLltcIlwiLCBtYXJrZXJdKTtcbiAgICAgIHRhZ3MucHVzaCh0YWcpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgX05ES0V2ZW50KSB7XG4gICAgICBjb25zdCBldmVudCA9IHRhcmdldDtcbiAgICAgIHNraXBBdXRob3JUYWcgPz89IGV2ZW50Py5wdWJrZXkgPT09IHRoaXMucHVia2V5O1xuICAgICAgdGFncyA9IGV2ZW50LnJlZmVyZW5jZVRhZ3MobWFya2VyLCBza2lwQXV0aG9yVGFnLCBmb3JjZVRhZyk7XG4gICAgICBmb3IgKGNvbnN0IHBUYWcgb2YgZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKSkge1xuICAgICAgICBpZiAocFRhZ1sxXSA9PT0gdGhpcy5wdWJrZXkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAodGhpcy50YWdzLmZpbmQoKHQpID0+IHRbMF0gPT09IFwicFwiICYmIHRbMV0gPT09IHBUYWdbMV0pKSBjb250aW51ZTtcbiAgICAgICAgdGhpcy50YWdzLnB1c2goW1wicFwiLCBwVGFnWzFdXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgIHRhZ3MgPSBbdGFyZ2V0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiLCB0YXJnZXQpO1xuICAgIH1cbiAgICB0aGlzLnRhZ3MgPSBtZXJnZVRhZ3ModGhpcy50YWdzLCB0YWdzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgTm9zdHJFdmVudCBvYmplY3QsIHRyeWluZyB0byBmaWxsIGluIG1pc3NpbmcgZmllbGRzXG4gICAqIHdoZW4gcG9zc2libGUsIGFkZGluZyB0YWdzIHdoZW4gbmVjZXNzYXJ5LlxuICAgKiBAcGFyYW0gcHVia2V5IHtzdHJpbmd9IFRoZSBwdWJrZXkgb2YgdGhlIHVzZXIgd2hvIHRoZSBldmVudCBiZWxvbmdzIHRvLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOb3N0ckV2ZW50Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBOb3N0ckV2ZW50LlxuICAgKi9cbiAgYXN5bmMgdG9Ob3N0ckV2ZW50KHB1YmtleSkge1xuICAgIGlmICghcHVia2V5ICYmIHRoaXMucHVia2V5ID09PSBcIlwiKSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGs/LnNpZ25lcj8udXNlcigpO1xuICAgICAgdGhpcy5wdWJrZXkgPSB1c2VyPy5wdWJrZXkgfHwgXCJcIjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNyZWF0ZWRfYXQpIHtcbiAgICAgIHRoaXMuY3JlYXRlZF9hdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGVudCwgdGFncyB9ID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVRhZ3MoKTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50IHx8IFwiXCI7XG4gICAgdGhpcy50YWdzID0gdGFncztcbiAgICB0cnkge1xuICAgICAgdGhpcy5pZCA9IHRoaXMuZ2V0RXZlbnRIYXNoKCk7XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmF3RXZlbnQoKTtcbiAgfVxuICBzZXJpYWxpemUgPSBzZXJpYWxpemUuYmluZCh0aGlzKTtcbiAgZ2V0RXZlbnRIYXNoID0gZ2V0RXZlbnRIYXNoLmJpbmQodGhpcyk7XG4gIHZhbGlkYXRlID0gdmFsaWRhdGUuYmluZCh0aGlzKTtcbiAgdmVyaWZ5U2lnbmF0dXJlID0gdmVyaWZ5U2lnbmF0dXJlLmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBJcyB0aGlzIGV2ZW50IHJlcGxhY2VhYmxlICh3aGV0aGVyIHBhcmFtZXRlcml6ZWQgb3Igbm90KT9cbiAgICpcbiAgICogVGhpcyB3aWxsIHJldHVybiB0cnVlIGZvciBraW5kIDAsIDMsIDEway0yMGsgYW5kIDMway00MGtcbiAgICovXG4gIGlzUmVwbGFjZWFibGUgPSBpc1JlcGxhY2VhYmxlLmJpbmQodGhpcyk7XG4gIGlzRXBoZW1lcmFsID0gaXNFcGhlbWVyYWwuYmluZCh0aGlzKTtcbiAgaXNEdm0gPSAoKSA9PiB0aGlzLmtpbmQgJiYgdGhpcy5raW5kID49IDVlMyAmJiB0aGlzLmtpbmQgPD0gN2UzO1xuICAvKipcbiAgICogSXMgdGhpcyBldmVudCBwYXJhbWV0ZXJpemVkIHJlcGxhY2VhYmxlP1xuICAgKlxuICAgKiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgZm9yIGtpbmQgMzBrLTQwa1xuICAgKi9cbiAgaXNQYXJhbVJlcGxhY2VhYmxlID0gaXNQYXJhbVJlcGxhY2VhYmxlLmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBFbmNvZGVzIGEgYmVjaDMyIGlkLlxuICAgKlxuICAgKiBAcGFyYW0gcmVsYXlzIHtzdHJpbmdbXX0gVGhlIHJlbGF5cyB0byBlbmNvZGUgaW4gdGhlIGlkXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gRW5jb2RlZCBuYWRkciwgbm90ZSBvciBuZXZlbnQuXG4gICAqL1xuICBlbmNvZGUgPSBlbmNvZGUuYmluZCh0aGlzKTtcbiAgZW5jcnlwdCA9IGVuY3J5cHQuYmluZCh0aGlzKTtcbiAgZGVjcnlwdCA9IGRlY3J5cHQuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIEdldCBhbGwgdGFncyB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqIEBwYXJhbSB0YWdOYW1lIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSB0YWcgdG8gc2VhcmNoIGZvclxuICAgKiBAcmV0dXJucyB7TkRLVGFnW119IEFuIGFycmF5IG9mIHRoZSBtYXRjaGluZyB0YWdzXG4gICAqL1xuICBnZXRNYXRjaGluZ1RhZ3ModGFnTmFtZSwgbWFya2VyKSB7XG4gICAgY29uc3QgdCA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdID09PSB0YWdOYW1lKTtcbiAgICBpZiAobWFya2VyID09PSB2b2lkIDApIHJldHVybiB0O1xuICAgIHJldHVybiB0LmZpbHRlcigodGFnKSA9PiB0YWdbM10gPT09IG1hcmtlcik7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBldmVudCBoYXMgYSB0YWcgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKiBAcGFyYW0gdGFnTmFtZVxuICAgKiBAcGFyYW0gbWFya2VyXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBoYXNUYWcodGFnTmFtZSwgbWFya2VyKSB7XG4gICAgcmV0dXJuIHRoaXMudGFncy5zb21lKCh0YWcpID0+IHRhZ1swXSA9PT0gdGFnTmFtZSAmJiAoIW1hcmtlciB8fCB0YWdbM10gPT09IG1hcmtlcikpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpcnN0IHRhZyB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqIEBwYXJhbSB0YWdOYW1lIFRhZyBuYW1lIHRvIHNlYXJjaCBmb3JcbiAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCB0YWcgd2l0aCB0aGUgZ2l2ZW4gbmFtZSwgb3IgdW5kZWZpbmVkIGlmIG5vIHN1Y2ggdGFnIGV4aXN0c1xuICAgKi9cbiAgdGFnVmFsdWUodGFnTmFtZSwgbWFya2VyKSB7XG4gICAgY29uc3QgdGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKHRhZ05hbWUsIG1hcmtlcik7XG4gICAgaWYgKHRhZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiB0YWdzWzBdWzFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBOSVAtMzEgXCJhbHRcIiB0YWcgb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgZ2V0IGFsdCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImFsdFwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgTklQLTMxIFwiYWx0XCIgdGFnIG9mIHRoZSBldmVudC4gVXNlIHRoaXMgdG8gc2V0IGFuIGFsdCB0YWcgc29cbiAgICogY2xpZW50cyB0aGF0IGRvbid0IGhhbmRsZSBhIHBhcnRpY3VsYXIgZXZlbnQga2luZCBjYW4gZGlzcGxheSBzb21ldGhpbmdcbiAgICogdXNlZnVsIGZvciB1c2Vycy5cbiAgICovXG4gIHNldCBhbHQoYWx0KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhbHRcIik7XG4gICAgaWYgKGFsdCkgdGhpcy50YWdzLnB1c2goW1wiYWx0XCIsIGFsdF0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBOSVAtMzMgXCJkXCIgdGFnIG9mIHRoZSBldmVudC5cbiAgICovXG4gIGdldCBkVGFnKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZFwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgTklQLTMzIFwiZFwiIHRhZyBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBzZXQgZFRhZyh2YWx1ZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZFwiKTtcbiAgICBpZiAodmFsdWUpIHRoaXMudGFncy5wdXNoKFtcImRcIiwgdmFsdWVdKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGFsbCB0YWdzIHdpdGggdGhlIGdpdmVuIG5hbWUgKGUuZy4gXCJkXCIsIFwiYVwiLCBcInBcIilcbiAgICogQHBhcmFtIHRhZ05hbWUgVGFnIG5hbWUocykgdG8gc2VhcmNoIGZvciBhbmQgcmVtb3ZlXG4gICAqIEBwYXJhbSBtYXJrZXIgT3B0aW9uYWwgbWFya2VyIHRvIGNoZWNrIGZvciB0b29cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogUmVtb3ZlIGEgdGFncyB3aXRoIGEgXCJkZWZlclwiIG1hcmtlclxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGV2ZW50LnRhZ3MgPSBbXG4gICAqICAgW1wiYVwiLCBcIi4uLi5cIiwgXCJkZWZlclwiXSxcbiAgICogICBbXCJhXCIsIFwiLi4uLlwiLCBcIm5vLWRlZmVyXCJdLFxuICAgKiBdXG4gICAqXG4gICAqIGV2ZW50LnJlbW92ZVRhZyhcImFcIiwgXCJkZWZlclwiKTtcbiAgICpcbiAgICogLy8gZXZlbnQudGFncyA9PiBbW1wiYVwiLCBcIi4uLi5cIiwgXCJuby1kZWZlclwiXV1cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICByZW1vdmVUYWcodGFnTmFtZSwgbWFya2VyKSB7XG4gICAgY29uc3QgdGFnTmFtZXMgPSBBcnJheS5pc0FycmF5KHRhZ05hbWUpID8gdGFnTmFtZSA6IFt0YWdOYW1lXTtcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGUgPSB0YWdOYW1lcy5pbmNsdWRlcyh0YWdbMF0pO1xuICAgICAgY29uc3QgaGFzTWFya2VyID0gbWFya2VyID8gdGFnWzNdID09PSBtYXJrZXIgOiB0cnVlO1xuICAgICAgcmV0dXJuICEoaW5jbHVkZSAmJiBoYXNNYXJrZXIpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlIGEgdGFnIHdpdGggYSBuZXcgdmFsdWUuIElmIG5vdCBmb3VuZCwgaXQgd2lsbCBiZSBhZGRlZC5cbiAgICogQHBhcmFtIHRhZyBUaGUgdGFnIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgbmV3IHZhbHVlIGZvciB0aGUgdGFnLlxuICAgKi9cbiAgcmVwbGFjZVRhZyh0YWcpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyh0YWdbMF0pO1xuICAgIHRoaXMudGFncy5wdXNoKHRhZyk7XG4gIH1cbiAgLyoqXG4gICAqIFNpZ24gdGhlIGV2ZW50IGlmIGEgc2lnbmVyIGlzIHByZXNlbnQuXG4gICAqXG4gICAqIEl0IHdpbGwgZ2VuZXJhdGUgdGFncy5cbiAgICogUmVwbGVhY2FibGUgZXZlbnRzIHdpbGwgaGF2ZSB0aGVpciBjcmVhdGVkX2F0IGZpZWxkIHNldCB0byB0aGUgY3VycmVudCB0aW1lLlxuICAgKiBAcGFyYW0gc2lnbmVyIHtOREtTaWduZXJ9IFRoZSBOREtTaWduZXIgdG8gdXNlIHRvIHNpZ24gdGhlIGV2ZW50XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzaWduYXR1cmUgb2YgdGhlIHNpZ25lZCBldmVudC5cbiAgICovXG4gIGFzeW5jIHNpZ24oc2lnbmVyKSB7XG4gICAgaWYgKCFzaWduZXIpIHtcbiAgICAgIHRoaXMubmRrPy5hc3NlcnRTaWduZXIoKTtcbiAgICAgIHNpZ25lciA9IHRoaXMubmRrPy5zaWduZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXV0aG9yID0gYXdhaXQgc2lnbmVyLnVzZXIoKTtcbiAgICB9XG4gICAgY29uc3Qgbm9zdHJFdmVudCA9IGF3YWl0IHRoaXMudG9Ob3N0ckV2ZW50KCk7XG4gICAgdGhpcy5zaWcgPSBhd2FpdCBzaWduZXIuc2lnbihub3N0ckV2ZW50KTtcbiAgICByZXR1cm4gdGhpcy5zaWc7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSByZWxheVNldFxuICAgKiBAcGFyYW0gdGltZW91dE1zXG4gICAqIEBwYXJhbSByZXF1aXJlZFJlbGF5Q291bnRcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIHB1Ymxpc2hSZXBsYWNlYWJsZShyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpIHtcbiAgICB0aGlzLmlkID0gXCJcIjtcbiAgICB0aGlzLmNyZWF0ZWRfYXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpO1xuICAgIHRoaXMuc2lnID0gXCJcIjtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gc2lnbiBhbmQgdGhlbiBwdWJsaXNoIGFuIE5ES0V2ZW50IHRvIGEgZ2l2ZW4gcmVsYXlTZXQuXG4gICAqIElmIG5vIHJlbGF5U2V0IGlzIHByb3ZpZGVkLCB0aGUgcmVsYXlTZXQgd2lsbCBiZSBjYWxjdWxhdGVkIGJ5IE5ESy5cbiAgICogQHBhcmFtIHJlbGF5U2V0IHtOREtSZWxheVNldH0gVGhlIHJlbGF5U2V0IHRvIHB1Ymxpc2ggdGhlIGV2ZW4gdG8uXG4gICAqIEBwYXJhbSB0aW1lb3V0TSB7bnVtYmVyfSBUaGUgdGltZW91dCBmb3IgdGhlIHB1Ymxpc2ggb3BlcmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICogQHBhcmFtIHJlcXVpcmVkUmVsYXlDb3VudCBUaGUgbnVtYmVyIG9mIHJlbGF5cyB0aGF0IG11c3QgcmVjZWl2ZSB0aGUgZXZlbnQgZm9yIHRoZSBwdWJsaXNoIHRvIGJlIGNvbnNpZGVyZWQgc3VjY2Vzc2Z1bC5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlbGF5cyB0aGUgZXZlbnQgd2FzIHB1Ymxpc2hlZCB0by5cbiAgICovXG4gIGFzeW5jIHB1Ymxpc2gocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KSB7XG4gICAgaWYgKCF0aGlzLnNpZykgYXdhaXQgdGhpcy5zaWduKCk7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLRXZlbnQgbXVzdCBiZSBhc3NvY2lhdGVkIHdpdGggYW4gTkRLIGluc3RhbmNlIHRvIHB1Ymxpc2hcIik7XG4gICAgaWYgKCFyZWxheVNldCB8fCByZWxheVNldC5zaXplID09PSAwKSB7XG4gICAgICByZWxheVNldCA9IHRoaXMubmRrLmRldldyaXRlUmVsYXlTZXQgfHwgYXdhaXQgY2FsY3VsYXRlUmVsYXlTZXRGcm9tRXZlbnQodGhpcy5uZGssIHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSA1IC8qIEV2ZW50RGVsZXRpb24gKi8gJiYgdGhpcy5uZGsuY2FjaGVBZGFwdGVyPy5kZWxldGVFdmVudElkcykge1xuICAgICAgY29uc3QgZVRhZ3MgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gICAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZGVsZXRlRXZlbnRJZHMoZVRhZ3MpO1xuICAgIH1cbiAgICBjb25zdCByYXdFdmVudCA9IHRoaXMucmF3RXZlbnQoKTtcbiAgICBpZiAodGhpcy5uZGsuY2FjaGVBZGFwdGVyPy5hZGRVbnB1Ymxpc2hlZEV2ZW50ICYmIHNob3VsZFRyYWNrVW5wdWJsaXNoZWRFdmVudCh0aGlzKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmFkZFVucHVibGlzaGVkRXZlbnQodGhpcywgcmVsYXlTZXQucmVsYXlVcmxzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFkZGluZyB1bnB1Ymxpc2hlZCBldmVudCB0byBjYWNoZVwiLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gNSAvKiBFdmVudERlbGV0aW9uICovICYmIHRoaXMubmRrLmNhY2hlQWRhcHRlcj8uZGVsZXRlRXZlbnRJZHMpIHtcbiAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5kZWxldGVFdmVudElkcyh0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSkpO1xuICAgIH1cbiAgICB0aGlzLm5kay5zdWJNYW5hZ2VyLmRpc3BhdGNoRXZlbnQocmF3RXZlbnQsIHZvaWQgMCwgdHJ1ZSk7XG4gICAgY29uc3QgcmVsYXlzID0gYXdhaXQgcmVsYXlTZXQucHVibGlzaCh0aGlzLCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gICAgcmVsYXlzLmZvckVhY2goKHJlbGF5KSA9PiB0aGlzLm5kaz8uc3ViTWFuYWdlci5zZWVuRXZlbnQodGhpcy5pZCwgcmVsYXkpKTtcbiAgICByZXR1cm4gcmVsYXlzO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGFncyBmb3IgdXNlcnMsIG5vdGVzLCBhbmQgb3RoZXIgZXZlbnRzIHRhZ2dlZCBpbiBjb250ZW50LlxuICAgKiBXaWxsIGFsc28gZ2VuZXJhdGUgcmFuZG9tIFwiZFwiIHRhZyBmb3IgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZSBldmVudHMgd2hlcmUgbmVlZGVkLlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gVGhlIHRhZ3MgYW5kIGNvbnRlbnQgb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVUYWdzKCkge1xuICAgIGxldCB0YWdzID0gW107XG4gICAgY29uc3QgZyA9IGF3YWl0IGdlbmVyYXRlQ29udGVudFRhZ3ModGhpcy5jb250ZW50LCB0aGlzLnRhZ3MpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBnLmNvbnRlbnQ7XG4gICAgdGFncyA9IGcudGFncztcbiAgICBpZiAodGhpcy5raW5kICYmIHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIGNvbnN0IGRUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImRcIilbMF07XG4gICAgICBpZiAoIWRUYWcpIHtcbiAgICAgICAgY29uc3QgdGl0bGUgPSB0aGlzLnRhZ1ZhbHVlKFwidGl0bGVcIik7XG4gICAgICAgIGNvbnN0IHJhbmRMZW5ndGggPSB0aXRsZSA/IDYgOiAxNjtcbiAgICAgICAgbGV0IHN0ciA9IFsuLi5BcnJheShyYW5kTGVuZ3RoKV0ubWFwKCgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpWzJdKS5qb2luKFwiXCIpO1xuICAgICAgICBpZiAodGl0bGUgJiYgdGl0bGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0ciA9IGAke3RpdGxlLnJlcGxhY2UoL1teYS16MC05XSsvZ2ksIFwiLVwiKS5yZXBsYWNlKC9eLXwtJC9nLCBcIlwiKX0tJHtzdHJ9YDtcbiAgICAgICAgfVxuICAgICAgICB0YWdzLnB1c2goW1wiZFwiLCBzdHJdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc2hvdWxkQWRkQ2xpZW50VGFnKSB7XG4gICAgICBjb25zdCBjbGllbnRUYWcgPSBbXCJjbGllbnRcIiwgdGhpcy5uZGs/LmNsaWVudE5hbWUgPz8gXCJcIl07XG4gICAgICBpZiAodGhpcy5uZGs/LmNsaWVudE5pcDg5KSBjbGllbnRUYWcucHVzaCh0aGlzLm5kaz8uY2xpZW50TmlwODkpO1xuICAgICAgdGFncy5wdXNoKGNsaWVudFRhZyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNob3VsZFN0cmlwQ2xpZW50VGFnKSB7XG4gICAgICB0YWdzID0gdGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcImNsaWVudFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29udGVudDogY29udGVudCB8fCBcIlwiLCB0YWdzIH07XG4gIH1cbiAgZ2V0IHNob3VsZEFkZENsaWVudFRhZygpIHtcbiAgICBpZiAoIXRoaXMubmRrPy5jbGllbnROYW1lICYmICF0aGlzLm5kaz8uY2xpZW50TmlwODkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoc2tpcENsaWVudFRhZ09uS2luZHMuaGFzKHRoaXMua2luZCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy5pc0VwaGVtZXJhbCgpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuaXNSZXBsYWNlYWJsZSgpICYmICF0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuaXNEdm0oKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aGlzLmhhc1RhZyhcImNsaWVudFwiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCBzaG91bGRTdHJpcENsaWVudFRhZygpIHtcbiAgICByZXR1cm4gc2tpcENsaWVudFRhZ09uS2luZHMuaGFzKHRoaXMua2luZCk7XG4gIH1cbiAgbXV0ZWQoKSB7XG4gICAgY29uc3QgYXV0aG9yTXV0ZWRFbnRyeSA9IHRoaXMubmRrPy5tdXRlZElkcy5nZXQodGhpcy5wdWJrZXkpO1xuICAgIGlmIChhdXRob3JNdXRlZEVudHJ5ICYmIGF1dGhvck11dGVkRW50cnkgPT09IFwicFwiKSByZXR1cm4gXCJhdXRob3JcIjtcbiAgICBjb25zdCBldmVudFRhZ1JlZmVyZW5jZSA9IHRoaXMudGFnUmVmZXJlbmNlKCk7XG4gICAgY29uc3QgZXZlbnRNdXRlZEVudHJ5ID0gdGhpcy5uZGs/Lm11dGVkSWRzLmdldChldmVudFRhZ1JlZmVyZW5jZVsxXSk7XG4gICAgaWYgKGV2ZW50TXV0ZWRFbnRyeSAmJiBldmVudE11dGVkRW50cnkgPT09IGV2ZW50VGFnUmVmZXJlbmNlWzBdKSByZXR1cm4gXCJldmVudFwiO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBcImRcIiB0YWcgb2YgYSBwYXJhbWV0ZXJpemVkIHJlcGxhY2VhYmxlIGV2ZW50IG9yIHRocm93cyBhbiBlcnJvciBpZiB0aGUgZXZlbnQgaXNuJ3RcbiAgICogYSBwYXJhbWV0ZXJpemVkIHJlcGxhY2VhYmxlIGV2ZW50LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgXCJkXCIgdGFnIG9mIHRoZSBldmVudC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBkVGFnYCBpbnN0ZWFkLlxuICAgKi9cbiAgcmVwbGFjZWFibGVEVGFnKCkge1xuICAgIGlmICh0aGlzLmtpbmQgJiYgdGhpcy5raW5kID49IDNlNCAmJiB0aGlzLmtpbmQgPD0gNGU0KSB7XG4gICAgICBjb25zdCBkVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJkXCIpWzBdO1xuICAgICAgY29uc3QgZFRhZ0lkID0gZFRhZyA/IGRUYWdbMV0gOiBcIlwiO1xuICAgICAgcmV0dXJuIGRUYWdJZDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgaXMgbm90IGEgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZSBldmVudFwiKTtcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgYSBkZWR1cGxpY2F0aW9uIGtleSBmb3IgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBGb3Iga2luZHMgMCwgMywgMTBrLTIwayB0aGlzIHdpbGwgYmUgdGhlIGV2ZW50IDxraW5kPjo8cHVia2V5PlxuICAgKiBGb3Iga2luZHMgMzBrLTQwayB0aGlzIHdpbGwgYmUgdGhlIGV2ZW50IDxraW5kPjo8cHVia2V5Pjo8ZC10YWc+XG4gICAqIEZvciBhbGwgb3RoZXIga2luZHMgdGhpcyB3aWxsIGJlIHRoZSBldmVudCBpZFxuICAgKi9cbiAgZGVkdXBsaWNhdGlvbktleSgpIHtcbiAgICBpZiAodGhpcy5raW5kID09PSAwIHx8IHRoaXMua2luZCA9PT0gMyB8fCB0aGlzLmtpbmQgJiYgdGhpcy5raW5kID49IDFlNCAmJiB0aGlzLmtpbmQgPCAyZTQpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLmtpbmR9OiR7dGhpcy5wdWJrZXl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGFnSWQoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaWQgb2YgdGhlIGV2ZW50IG9yLCBpZiBpdCdzIGEgcGFyYW1ldGVyaXplZCBldmVudCwgdGhlIGdlbmVyYXRlZCBpZCBvZiB0aGUgZXZlbnQgdXNpbmcgXCJkXCIgdGFnLCBwdWJrZXksIGFuZCBraW5kLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgaWRcbiAgICovXG4gIHRhZ0lkKCkge1xuICAgIGlmICh0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWdBZGRyZXNzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlkO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RhYmxlIHJlZmVyZW5jZSB2YWx1ZSBmb3IgYSByZXBsYWNlYWJsZSBldmVudC5cbiAgICpcbiAgICogUGFyYW0gcmVwbGFjZWFibGUgZXZlbnRzIGFyZSByZXR1cm5lZCBpbiB0aGUgZXhwZWN0ZWQgZm9ybWF0IG9mIGA8a2luZD46PHB1YmtleT46PGQtdGFnPmAuXG4gICAqIEtpbmQtcmVwbGFjZWFibGUgZXZlbnRzIGFyZSByZXR1cm5lZCBpbiB0aGUgZm9ybWF0IG9mIGA8a2luZD46PHB1YmtleT46YC5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gQSBzdGFibGUgcmVmZXJlbmNlIHZhbHVlIGZvciByZXBsYWNlYWJsZSBldmVudHNcbiAgICovXG4gIHRhZ0FkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIGNvbnN0IGRUYWdJZCA9IHRoaXMuZFRhZyA/PyBcIlwiO1xuICAgICAgcmV0dXJuIGAke3RoaXMua2luZH06JHt0aGlzLnB1YmtleX06JHtkVGFnSWR9YDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNSZXBsYWNlYWJsZSgpKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5raW5kfToke3RoaXMucHVia2V5fTpgO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBpcyBub3QgYSByZXBsYWNlYWJsZSBldmVudFwiKTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgdHlwZSBvZiB0YWcgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyBldmVudCBmcm9tIGFub3RoZXIgZXZlbnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0YWcgdHlwZVxuICAgKiBAZXhhbXBsZVxuICAgKiBldmVudCA9IG5ldyBOREtFdmVudChuZGssIHsga2luZDogMzAwMDAsIHB1YmtleTogJ3B1YmtleScsIHRhZ3M6IFsgW1wiZFwiLCBcImQtY29kZVwiXSBdIH0pO1xuICAgKiBldmVudC50YWdUeXBlKCk7IC8vIFwiYVwiXG4gICAqL1xuICB0YWdUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpID8gXCJhXCIgOiBcImVcIjtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB0YWcgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyBldmVudCBmcm9tIGFub3RoZXIgZXZlbnQuXG4gICAqXG4gICAqIENvbnNpZGVyIHVzaW5nIHJlZmVyZW5jZVRhZ3MoKSBpbnN0ZWFkICh1bmxlc3MgeW91IGhhdmUgYSBnb29kIHJlYXNvbiB0byB1c2UgdGhpcylcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAzMDAwMCwgcHVia2V5OiAncHVia2V5JywgdGFnczogWyBbXCJkXCIsIFwiZC1jb2RlXCJdIF0gfSk7XG4gICAqICAgICBldmVudC50YWdSZWZlcmVuY2UoKTsgLy8gW1wiYVwiLCBcIjMwMDAwOnB1YmtleTpkLWNvZGVcIl1cbiAgICpcbiAgICogICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAxLCBwdWJrZXk6ICdwdWJrZXknLCBpZDogXCJldmVudGlkXCIgfSk7XG4gICAqICAgICBldmVudC50YWdSZWZlcmVuY2UoKTsgLy8gW1wiZVwiLCBcImV2ZW50aWRcIl1cbiAgICogQHJldHVybnMge05ES1RhZ30gVGhlIE5ES1RhZyBvYmplY3QgcmVmZXJlbmNpbmcgdGhpcyBldmVudFxuICAgKi9cbiAgdGFnUmVmZXJlbmNlKG1hcmtlcikge1xuICAgIGxldCB0YWc7XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHRhZyA9IFtcImFcIiwgdGhpcy50YWdBZGRyZXNzKCldO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWcgPSBbXCJlXCIsIHRoaXMudGFnSWQoKV07XG4gICAgfVxuICAgIGlmICh0aGlzLnJlbGF5KSB7XG4gICAgICB0YWcucHVzaCh0aGlzLnJlbGF5LnVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZy5wdXNoKFwiXCIpO1xuICAgIH1cbiAgICB0YWcucHVzaChtYXJrZXIgPz8gXCJcIik7XG4gICAgaWYgKCF0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSB7XG4gICAgICB0YWcucHVzaCh0aGlzLnB1YmtleSk7XG4gICAgfVxuICAgIHJldHVybiB0YWc7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdGFncyB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGlzIGV2ZW50IGZyb20gYW5vdGhlciBldmVudFxuICAgKiBAcGFyYW0gbWFya2VyIFRoZSBtYXJrZXIgdG8gdXNlIGluIHRoZSB0YWdcbiAgICogQHBhcmFtIHNraXBBdXRob3JUYWcgV2hldGhlciB0byBleHBsaWNpdGx5IHNraXAgYWRkaW5nIHRoZSBhdXRob3IgdGFnIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0gZm9yY2VUYWcgRm9yY2UgYSBzcGVjaWZpYyB0YWcgdG8gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IFwiZVwiIG9yIFwiYVwiIHRhZ1xuICAgKiBAZXhhbXBsZVxuICAgKiAgICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDMwMDAwLCBwdWJrZXk6ICdwdWJrZXknLCB0YWdzOiBbIFtcImRcIiwgXCJkLWNvZGVcIl0gXSB9KTtcbiAgICogICAgIGV2ZW50LnJlZmVyZW5jZVRhZ3MoKTsgLy8gW1tcImFcIiwgXCIzMDAwMDpwdWJrZXk6ZC1jb2RlXCJdLCBbXCJlXCIsIFwicGFyZW50LWlkXCJdXVxuICAgKlxuICAgKiAgICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDEsIHB1YmtleTogJ3B1YmtleScsIGlkOiBcImV2ZW50aWRcIiB9KTtcbiAgICogICAgIGV2ZW50LnJlZmVyZW5jZVRhZ3MoKTsgLy8gW1tcImVcIiwgXCJwYXJlbnQtaWRcIl1dXG4gICAqIEByZXR1cm5zIHtOREtUYWd9IFRoZSBOREtUYWcgb2JqZWN0IHJlZmVyZW5jaW5nIHRoaXMgZXZlbnRcbiAgICovXG4gIHJlZmVyZW5jZVRhZ3MobWFya2VyLCBza2lwQXV0aG9yVGFnLCBmb3JjZVRhZykge1xuICAgIGxldCB0YWdzID0gW107XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHRhZ3MgPSBbXG4gICAgICAgIFtmb3JjZVRhZyA/PyBcImFcIiwgdGhpcy50YWdBZGRyZXNzKCldLFxuICAgICAgICBbZm9yY2VUYWcgPz8gXCJlXCIsIHRoaXMuaWRdXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWdzID0gW1tmb3JjZVRhZyA/PyBcImVcIiwgdGhpcy5pZF1dO1xuICAgIH1cbiAgICB0YWdzID0gdGFncy5tYXAoKHRhZykgPT4ge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgfHwgbWFya2VyKSB7XG4gICAgICAgIHRhZy5wdXNoKHRoaXMucmVsYXk/LnVybCA/PyBcIlwiKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZWxheT8udXJsKSB7XG4gICAgICAgIHRhZy5wdXNoKHRoaXMucmVsYXk/LnVybCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH0pO1xuICAgIHRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIikge1xuICAgICAgICB0YWcucHVzaChtYXJrZXIgPz8gXCJcIik7XG4gICAgICAgIHRhZy5wdXNoKHRoaXMucHVia2V5KTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyKSB7XG4gICAgICAgIHRhZy5wdXNoKG1hcmtlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFncyA9IFsuLi50YWdzLCAuLi50aGlzLmdldE1hdGNoaW5nVGFncyhcImhcIildO1xuICAgIGlmICghc2tpcEF1dGhvclRhZykgdGFncy5wdXNoKC4uLnRoaXMuYXV0aG9yLnJlZmVyZW5jZVRhZ3MoKSk7XG4gICAgcmV0dXJuIHRhZ3M7XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIHRoZSBmaWx0ZXIgdGhhdCB3aWxsIHJldHVybiBtYXRjaGluZyBldmVudHMgZm9yIHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAzMDAwMCwgcHVia2V5OiAncHVia2V5JywgdGFnczogWyBbXCJkXCIsIFwiZC1jb2RlXCJdIF0gfSk7XG4gICAqICAgIGV2ZW50LmZpbHRlcigpOyAvLyB7IFwiI2FcIjogW1wiMzAwMDA6cHVia2V5OmQtY29kZVwiXSB9XG4gICAqIEBleGFtcGxlXG4gICAqICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAxLCBwdWJrZXk6ICdwdWJrZXknLCBpZDogXCJldmVudGlkXCIgfSk7XG4gICAqICAgIGV2ZW50LmZpbHRlcigpOyAvLyB7IFwiI2VcIjogW1wiZXZlbnRpZFwiXSB9XG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBmaWx0ZXIgdGhhdCB3aWxsIHJldHVybiBtYXRjaGluZyBldmVudHMgZm9yIHRoaXMgZXZlbnRcbiAgICovXG4gIGZpbHRlcigpIHtcbiAgICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgICAgcmV0dXJuIHsgXCIjYVwiOiBbdGhpcy50YWdJZCgpXSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBcIiNlXCI6IFt0aGlzLnRhZ0lkKCldIH07XG4gIH1cbiAgbmlwMjJGaWx0ZXIoKSB7XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHJldHVybiB7IFwiI0FcIjogW3RoaXMudGFnSWQoKV0gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgXCIjRVwiOiBbdGhpcy50YWdJZCgpXSB9O1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBkZWxldGlvbiBldmVudCBvZiB0aGUgY3VycmVudCBldmVudFxuICAgKlxuICAgKiBAcGFyYW0gcmVhc29uIFRoZSByZWFzb24gZm9yIHRoZSBkZWxldGlvblxuICAgKiBAcGFyYW0gcHVibGlzaCBXaGV0aGVyIHRvIHB1Ymxpc2ggdGhlIGRlbGV0aW9uIGV2ZW50IGF1dG9tYXRpY2FsbHlcbiAgICogQHJldHVybnMgVGhlIGRlbGV0aW9uIGV2ZW50XG4gICAqL1xuICBhc3luYyBkZWxldGUocmVhc29uLCBwdWJsaXNoID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBjb25zdCBlID0gbmV3IF9OREtFdmVudCh0aGlzLm5kaywge1xuICAgICAga2luZDogNSAvKiBFdmVudERlbGV0aW9uICovLFxuICAgICAgY29udGVudDogcmVhc29uIHx8IFwiXCJcbiAgICB9KTtcbiAgICBlLnRhZyh0aGlzLCB2b2lkIDAsIHRydWUpO1xuICAgIGUudGFncy5wdXNoKFtcImtcIiwgdGhpcy5raW5kPy50b1N0cmluZygpXSk7XG4gICAgaWYgKHB1Ymxpc2gpIHtcbiAgICAgIHRoaXMuZW1pdChcImRlbGV0ZWRcIik7XG4gICAgICBhd2FpdCBlLnB1Ymxpc2goKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgLyoqXG4gICAqIEVzdGFibGlzaGVzIHdoZXRoZXIgdGhpcyBpcyBhIE5JUC03MC1wcm90ZWN0ZWRlIGV2ZW50LlxuICAgKiBAQHNhdGlzZmllcyBOSVAtNzBcbiAgICovXG4gIHNldCBpc1Byb3RlY3RlZCh2YWwpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcIi1cIik7XG4gICAgaWYgKHZhbCkgdGhpcy50YWdzLnB1c2goW1wiLVwiXSk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBpcyBhIE5JUC03MC1wcm90ZWN0ZWQgZXZlbnQuXG4gICAqIEBAc2F0aXNmaWVzIE5JUC03MFxuICAgKi9cbiAgZ2V0IGlzUHJvdGVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc1RhZyhcIi1cIik7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGFuIGV2ZW50IHRhZ2dlZCB3aXRoIHRoZSBnaXZlbiB0YWcgZm9sbG93aW5nIHJlbGF5IGhpbnRzIGlmIHByb3ZpZGVkLlxuICAgKiBAcGFyYW0gdGFnIFRoZSB0YWcgdG8gc2VhcmNoIGZvclxuICAgKiBAcGFyYW0gbWFya2VyIFRoZSBtYXJrZXIgdG8gdXNlIGluIHRoZSB0YWcgKGUuZy4gXCJyb290XCIpXG4gICAqIEByZXR1cm5zIFRoZSBmZXRjaGVkIGV2ZW50IG9yIG51bGwgaWYgbm8gZXZlbnQgd2FzIGZvdW5kLCB1bmRlZmluZWQgaWYgbm8gbWF0Y2hpbmcgdGFnIHdhcyBmb3VuZCBpbiB0aGUgZXZlbnRcbiAgICogKiBAZXhhbXBsZVxuICAgKiBjb25zdCByZXBseUV2ZW50ID0gYXdhaXQgbmRrLmZldGNoRXZlbnQoXCJuZXZlbnQxcXFzOHg4dm55Y3loYTczZ3J2MzgwZ212bHVyeTR3dG14MG5yOWE1ZHMyZG5ncXdndTg3d242Z3B6ZW1oeHVlNjl1aGh5ZXR2djl1anV1cmpkOWtrem1wd2RlamhncTNxbDJ2eWg0N21rMnAwcWxza3U3aGcwdm4yOWZhZWh5OWh5MzR5Z2FjbHBuNjZ1a3FwM2FmcXo0Y3dqZFwiKVxuICAgKiBjb25zdCBvcmlnaW5hbEV2ZW50ID0gYXdhaXQgcmVwbHlFdmVudC5mZXRjaFRhZ2dlZEV2ZW50KFwiZVwiLCBcInJlcGx5XCIpO1xuICAgKiBjb25zb2xlLmxvZyhyZXBseUV2ZW50LmVuY29kZSgpICsgXCIgaXMgYSByZXBseSB0byBldmVudCBcIiArIG9yaWdpbmFsRXZlbnQ/LmVuY29kZSgpKTtcbiAgICovXG4gIGZldGNoVGFnZ2VkRXZlbnQgPSBmZXRjaFRhZ2dlZEV2ZW50LmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgcm9vdCBldmVudCBvZiB0aGUgY3VycmVudCBldmVudC5cbiAgICogQHJldHVybnMgVGhlIGZldGNoZWQgcm9vdCBldmVudCBvciBudWxsIGlmIG5vIGV2ZW50IHdhcyBmb3VuZFxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByZXBseUV2ZW50ID0gYXdhaXQgbmRrLmZldGNoRXZlbnQoXCJuZXZlbnQxcXFzOHg4dm55Y3loYTczZ3J2MzgwZ212bHVyeTR3dG14MG5yOWE1ZHMyZG5ncXdndTg3d242Z3B6ZW1oeHVlNjl1aGh5ZXR2djl1anV1cmpkOWtrem1wd2RlamhncTNxbDJ2eWg0N21rMnAwcWxza3U3aGcwdm4yOWZhZWh5OWh5MzR5Z2FjbHBuNjZ1a3FwM2FmcXo0Y3dqZFwiKVxuICAgKiBjb25zdCByb290RXZlbnQgPSBhd2FpdCByZXBseUV2ZW50LmZldGNoUm9vdEV2ZW50KCk7XG4gICAqIGNvbnNvbGUubG9nKHJlcGx5RXZlbnQuZW5jb2RlKCkgKyBcIiBpcyBhIHJlcGx5IGluIHRoZSB0aHJlYWQgXCIgKyByb290RXZlbnQ/LmVuY29kZSgpKTtcbiAgICovXG4gIGZldGNoUm9vdEV2ZW50ID0gZmV0Y2hSb290RXZlbnQuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIEZldGNoIHRoZSBldmVudCB0aGUgY3VycmVudCBldmVudCBpcyByZXBseWluZyB0by5cbiAgICogQHJldHVybnMgVGhlIGZldGNoZWQgcmVwbHkgZXZlbnQgb3IgbnVsbCBpZiBubyBldmVudCB3YXMgZm91bmRcbiAgICovXG4gIGZldGNoUmVwbHlFdmVudCA9IGZldGNoUmVwbHlFdmVudC5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogTklQLTE4IHJlcG9zdGluZyBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHB1Ymxpc2ggV2hldGhlciB0byBwdWJsaXNoIHRoZSByZXBvc3RlZCBldmVudCBhdXRvbWF0aWNhbGx5IEBkZWZhdWx0IHRydWVcbiAgICogQHBhcmFtIHNpZ25lciBUaGUgc2lnbmVyIHRvIHVzZSBmb3Igc2lnbmluZyB0aGUgcmVwb3N0ZWQgZXZlbnRcbiAgICogQHJldHVybnMgVGhlIHJlcG9zdGVkIGV2ZW50XG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgcmVwb3N0ID0gcmVwb3N0LmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBSZWFjdCB0byBhbiBleGlzdGluZyBldmVudFxuICAgKlxuICAgKiBAcGFyYW0gY29udGVudCBUaGUgY29udGVudCBvZiB0aGUgcmVhY3Rpb25cbiAgICovXG4gIGFzeW5jIHJlYWN0KGNvbnRlbnQsIHB1Ymxpc2ggPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGNvbnN0IGUgPSBuZXcgX05ES0V2ZW50KHRoaXMubmRrLCB7XG4gICAgICBraW5kOiA3IC8qIFJlYWN0aW9uICovLFxuICAgICAgY29udGVudFxuICAgIH0pO1xuICAgIGUudGFnKHRoaXMpO1xuICAgIGlmIChwdWJsaXNoKSBhd2FpdCBlLnB1Ymxpc2goKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGV2ZW50IGlzIHZhbGlkIHBlciB1bmRlcmx5aW5nIE5JUHMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3NlcyB0aGF0IGltcGxlbWVudCBzcGVjaWZpYyBOSVBzXG4gICAqIHRvIGFsbG93IHRoZSBlbmZvcmNlbWVudCBvZiBOSVAtc3BlY2lmaWMgdmFsaWRhdGlvbiBydWxlcy5cbiAgICpcbiAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIG9ubHkgY2hlY2sgZm9yIGJhc2ljIGV2ZW50IHByb3BlcnRpZXMuXG4gICAqXG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZSgpO1xuICB9XG4gIGdldCBpbnNwZWN0KCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnJhd0V2ZW50KCksIG51bGwsIDQpO1xuICB9XG4gIC8qKlxuICAgKiBEdW1wIHRoZSBldmVudCB0byBjb25zb2xlIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG4gICAqIFByaW50cyBhIEpTT04gc3RyaW5naWZpZWQgdmVyc2lvbiBvZiByYXdFdmVudCgpIHdpdGggaW5kZW50YXRpb25cbiAgICogYW5kIGFsc28gbGlzdHMgYWxsIHJlbGF5IFVSTHMgZm9yIG9uUmVsYXlzLlxuICAgKi9cbiAgZHVtcCgpIHtcbiAgICBjb25zb2xlLmRlYnVnKEpTT04uc3RyaW5naWZ5KHRoaXMucmF3RXZlbnQoKSwgbnVsbCwgNCkpO1xuICAgIGNvbnNvbGUuZGVidWcoXCJFdmVudCBvbiByZWxheXM6XCIsIHRoaXMub25SZWxheXMubWFwKChyZWxheSkgPT4gcmVsYXkudXJsKS5qb2luKFwiLCBcIikpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVwbHkgZXZlbnQgZm9yIHRoZSBjdXJyZW50IGV2ZW50LlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdXNlIE5JUC0yMiB3aGVuIGFwcHJvcHJpYXRlIChpLmUuIHJlcGxpZXMgdG8gbm9uLWtpbmQ6MSBldmVudHMpLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGhhdmUgc2lkZS1lZmZlY3RzOyBpdCB3aWxsIGp1c3QgcmV0dXJuIGFuIGV2ZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIHRhZ3NcbiAgICogdG8gZ2VuZXJhdGUgdGhlIHJlcGx5IGV2ZW50OyB0aGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAgICovXG4gIHJlcGx5KCkge1xuICAgIGNvbnN0IHJlcGx5ID0gbmV3IF9OREtFdmVudCh0aGlzLm5kayk7XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMSkge1xuICAgICAgcmVwbHkua2luZCA9IDE7XG4gICAgICBjb25zdCBvcEhhc0VUYWcgPSB0aGlzLmhhc1RhZyhcImVcIik7XG4gICAgICBpZiAob3BIYXNFVGFnKSB7XG4gICAgICAgIHJlcGx5LnRhZ3MgPSBbXG4gICAgICAgICAgLi4ucmVwbHkudGFncyxcbiAgICAgICAgICAuLi50aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIiksXG4gICAgICAgICAgLi4udGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpLFxuICAgICAgICAgIC4uLnRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiYVwiKSxcbiAgICAgICAgICAuLi50aGlzLnJlZmVyZW5jZVRhZ3MoXCJyZXBseVwiKVxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVwbHkudGFnKHRoaXMsIFwicm9vdFwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbHkua2luZCA9IDExMTEgLyogR2VuZXJpY1JlcGx5ICovO1xuICAgICAgY29uc3QgY2FycnlPdmVyVGFncyA9IFtcIkFcIiwgXCJFXCIsIFwiSVwiLCBcIlBcIl07XG4gICAgICBjb25zdCByb290VGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gY2FycnlPdmVyVGFncy5pbmNsdWRlcyh0YWdbMF0pKTtcbiAgICAgIGlmIChyb290VGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJvb3RLaW5kID0gdGhpcy50YWdWYWx1ZShcIktcIik7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaCguLi5yb290VGFncyk7XG4gICAgICAgIGlmIChyb290S2luZCkgcmVwbHkudGFncy5wdXNoKFtcIktcIiwgcm9vdEtpbmRdKTtcbiAgICAgICAgY29uc3QgW3R5cGUsIGlkLCBfLCAuLi5leHRyYV0gPSB0aGlzLnRhZ1JlZmVyZW5jZSgpO1xuICAgICAgICBjb25zdCB0YWcgPSBbdHlwZSwgaWQsIC4uLmV4dHJhXTtcbiAgICAgICAgcmVwbHkudGFncy5wdXNoKHRhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBbdHlwZSwgaWQsIF8sIHJlbGF5SGludF0gPSB0aGlzLnRhZ1JlZmVyZW5jZSgpO1xuICAgICAgICBjb25zdCB0YWcgPSBbdHlwZSwgaWQsIHJlbGF5SGludCA/PyBcIlwiXTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZVwiKSB0YWcucHVzaCh0aGlzLnB1YmtleSk7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaCh0YWcpO1xuICAgICAgICBjb25zdCB1cHBlcmNhc2VUYWcgPSBbLi4udGFnXTtcbiAgICAgICAgdXBwZXJjYXNlVGFnWzBdID0gdXBwZXJjYXNlVGFnWzBdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaCh1cHBlcmNhc2VUYWcpO1xuICAgICAgICByZXBseS50YWdzLnB1c2goW1wiS1wiLCB0aGlzLmtpbmQ/LnRvU3RyaW5nKCldKTtcbiAgICAgICAgcmVwbHkudGFncy5wdXNoKFtcIlBcIiwgdGhpcy5wdWJrZXldKTtcbiAgICAgIH1cbiAgICAgIHJlcGx5LnRhZ3MucHVzaChbXCJrXCIsIHRoaXMua2luZD8udG9TdHJpbmcoKV0pO1xuICAgICAgcmVwbHkudGFncy5wdXNoKC4uLnRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKSk7XG4gICAgICByZXBseS50YWdzLnB1c2goW1wicFwiLCB0aGlzLnB1YmtleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVwbHk7XG4gIH1cbn07XG52YXIgdW50cmFja2VkVW5wdWJsaXNoZWRFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIDI0MTMzIC8qIE5vc3RyQ29ubmVjdCAqLyxcbiAgMTMxOTQgLyogTm9zdHJXYWxldENvbm5lY3RJbmZvICovLFxuICAyMzE5NCAvKiBOb3N0cldhbGxldENvbm5lY3RSZXEgKi8sXG4gIDIzMTk1IC8qIE5vc3RyV2FsbGV0Q29ubmVjdFJlcyAqL1xuXSk7XG5mdW5jdGlvbiBzaG91bGRUcmFja1VucHVibGlzaGVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICF1bnRyYWNrZWRVbnB1Ymxpc2hlZEV2ZW50cy5oYXMoZXZlbnQua2luZCk7XG59XG5cbi8vIHNyYy9yZWxheS9wb29sL2luZGV4LnRzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgYXMgRXZlbnRFbWl0dGVyMyB9IGZyb20gXCJ0c2VlcFwiO1xudmFyIE5ES1Bvb2wgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjMge1xuICAvLyBUT0RPOiBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBhbiBMUlUgY2FjaGVcbiAgX3JlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHN0YXR1cyA9IFwiaWRsZVwiO1xuICBhdXRvQ29ubmVjdFJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHBvb2xCbGFja2xpc3RSZWxheVVybHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBkZWJ1ZztcbiAgdGVtcG9yYXJ5UmVsYXlUaW1lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmbGFwcGluZ1JlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIC8vIEEgbWFwIHRvIHN0b3JlIHRpbWVvdXRzIGZvciBlYWNoIGZsYXBwaW5nIHJlbGF5LlxuICBiYWNrb2ZmVGltZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBuZGs7XG4gIGdldCBibGFja2xpc3RSZWxheVVybHMoKSB7XG4gICAgY29uc3QgdmFsID0gbmV3IFNldCh0aGlzLm5kay5ibGFja2xpc3RSZWxheVVybHMpO1xuICAgIHRoaXMucG9vbEJsYWNrbGlzdFJlbGF5VXJscy5mb3JFYWNoKCh1cmwpID0+IHZhbC5hZGQodXJsKSk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHJlbGF5VXJscyAtIFRoZSBVUkxzIG9mIHRoZSByZWxheXMgdG8gY29ubmVjdCB0by5cbiAgICogQHBhcmFtIGJsYWNrbGlzdGVkUmVsYXlVcmxzIC0gVVJMcyB0byBibGFja2xpc3QgZm9yIHRoaXMgcG9vbCBJTiBBRERJVElPTiB0byB0aG9zZSBibGFja2xpc3RlZCBhdCB0aGUgbmRrLWxldmVsXG4gICAqIEBwYXJhbSBuZGsgLSBUaGUgTkRLIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgZm9yIHRoZSBwb29sLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVsYXlVcmxzLCBibGFja2xpc3RlZFJlbGF5VXJscywgbmRrLCB7XG4gICAgZGVidWc6IGRlYnVnOCxcbiAgICBuYW1lXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnOCA/PyBuZGsuZGVidWcuZXh0ZW5kKFwicG9vbFwiKTtcbiAgICBpZiAobmFtZSkgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgdGhpcy5yZWxheVVybHMgPSByZWxheVVybHM7XG4gICAgdGhpcy5wb29sQmxhY2tsaXN0UmVsYXlVcmxzID0gbmV3IFNldChibGFja2xpc3RlZFJlbGF5VXJscyk7XG4gICAgdGhpcy5uZGsucG9vbHMucHVzaCh0aGlzKTtcbiAgfVxuICBnZXQgcmVsYXlzKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWxheXM7XG4gIH1cbiAgc2V0IHJlbGF5VXJscyh1cmxzKSB7XG4gICAgdGhpcy5fcmVsYXlzLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCByZWxheVVybCBvZiB1cmxzKSB7XG4gICAgICBjb25zdCByZWxheSA9IG5ldyBOREtSZWxheShyZWxheVVybCwgdm9pZCAwLCB0aGlzLm5kayk7XG4gICAgICByZWxheS5jb25uZWN0aXZpdHkubmV0RGVidWcgPSB0aGlzLm5kay5uZXREZWJ1ZztcbiAgICAgIHRoaXMuYWRkUmVsYXkocmVsYXkpO1xuICAgIH1cbiAgfVxuICBfbmFtZSA9IFwidW5uYW1lZFwiO1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgfVxuICBzZXQgbmFtZShuYW1lKSB7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5kZWJ1ZyA9IHRoaXMuZGVidWcuZXh0ZW5kKG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcmVsYXkgdG8gdGhlIHBvb2wsIGFuZCBzZXRzIGEgdGltZXIgdG8gcmVtb3ZlIGl0IGlmIGl0IGlzIG5vdCB1c2VkIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHRpbWUuXG4gICAqIEBwYXJhbSByZWxheSAtIFRoZSByZWxheSB0byBhZGQgdG8gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSByZW1vdmVJZlVudXNlZEFmdGVyIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJlbW92aW5nIHRoZSByZWxheSBmcm9tIHRoZSBwb29sIGFmdGVyIGl0IGlzIG5vIGxvbmdlciB1c2VkLlxuICAgKi9cbiAgdXNlVGVtcG9yYXJ5UmVsYXkocmVsYXksIHJlbW92ZUlmVW51c2VkQWZ0ZXIgPSAzZTQsIGZpbHRlcnMpIHtcbiAgICBjb25zdCByZWxheUFscmVhZHlJblBvb2wgPSB0aGlzLnJlbGF5cy5oYXMocmVsYXkudXJsKTtcbiAgICBpZiAoIXJlbGF5QWxyZWFkeUluUG9vbCkge1xuICAgICAgdGhpcy5hZGRSZWxheShyZWxheSk7XG4gICAgICB0aGlzLmRlYnVnKFwiQWRkaW5nIHRlbXBvcmFyeSByZWxheSAlcyBmb3IgZmlsdGVycyAlb1wiLCByZWxheS51cmwsIGZpbHRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ1RpbWVyID0gdGhpcy50ZW1wb3JhcnlSZWxheVRpbWVycy5nZXQocmVsYXkudXJsKTtcbiAgICBpZiAoZXhpc3RpbmdUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KGV4aXN0aW5nVGltZXIpO1xuICAgIH1cbiAgICBpZiAoIXJlbGF5QWxyZWFkeUluUG9vbCB8fCBleGlzdGluZ1RpbWVyKSB7XG4gICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5uZGsuZXhwbGljaXRSZWxheVVybHM/LmluY2x1ZGVzKHJlbGF5LnVybCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5yZW1vdmVSZWxheShyZWxheS51cmwpO1xuICAgICAgfSwgcmVtb3ZlSWZVbnVzZWRBZnRlcik7XG4gICAgICB0aGlzLnRlbXBvcmFyeVJlbGF5VGltZXJzLnNldChyZWxheS51cmwsIHRpbWVyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSByZWxheSB0byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHBhcmFtIHJlbGF5IC0gVGhlIHJlbGF5IHRvIGFkZCB0byB0aGUgcG9vbC5cbiAgICogQHBhcmFtIGNvbm5lY3QgLSBXaGV0aGVyIG9yIG5vdCB0byBjb25uZWN0IHRvIHRoZSByZWxheS5cbiAgICovXG4gIGFkZFJlbGF5KHJlbGF5LCBjb25uZWN0ID0gdHJ1ZSkge1xuICAgIGNvbnN0IGlzQWxyZWFkeUluUG9vbCA9IHRoaXMucmVsYXlzLmhhcyhyZWxheS51cmwpO1xuICAgIGNvbnN0IGlzQmxhY2tsaXN0ZWQgPSB0aGlzLmJsYWNrbGlzdFJlbGF5VXJscz8uaGFzKHJlbGF5LnVybCk7XG4gICAgY29uc3QgaXNDdXN0b21SZWxheVVybCA9IHJlbGF5LnVybC5pbmNsdWRlcyhcIi9ucHViMVwiKTtcbiAgICBsZXQgcmVjb25uZWN0ID0gdHJ1ZTtcbiAgICBjb25zdCByZWxheVVybCA9IHJlbGF5LnVybDtcbiAgICBpZiAoaXNBbHJlYWR5SW5Qb29sKSByZXR1cm47XG4gICAgaWYgKGlzQmxhY2tsaXN0ZWQpIHtcbiAgICAgIHRoaXMuZGVidWcoYFJlZnVzaW5nIHRvIGFkZCByZWxheSAke3JlbGF5VXJsfTogYmxhY2tsaXN0ZWRgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzQ3VzdG9tUmVsYXlVcmwpIHtcbiAgICAgIHRoaXMuZGVidWcoYFJlZnVzaW5nIHRvIGFkZCByZWxheSAke3JlbGF5VXJsfTogaXMgYSBmaWx0ZXIgcmVsYXlgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlcj8uZ2V0UmVsYXlTdGF0dXMpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZ2V0UmVsYXlTdGF0dXMocmVsYXlVcmwpO1xuICAgICAgaWYgKGluZm8/LmRvbnRDb25uZWN0QmVmb3JlKSB7XG4gICAgICAgIGlmIChpbmZvLmRvbnRDb25uZWN0QmVmb3JlID4gRGF0ZS5ub3coKSkge1xuICAgICAgICAgIGNvbnN0IGRlbGF5ID0gaW5mby5kb250Q29ubmVjdEJlZm9yZSAtIERhdGUubm93KCk7XG4gICAgICAgICAgdGhpcy5kZWJ1ZyhgUmVmdXNpbmcgdG8gYWRkIHJlbGF5ICR7cmVsYXlVcmx9OiBkZWxheWVkIGNvbm5lY3QgZm9yICR7ZGVsYXl9bXNgKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkUmVsYXkocmVsYXksIGNvbm5lY3QpO1xuICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vdGljZUhhbmRsZXIgPSAobm90aWNlKSA9PiB0aGlzLmVtaXQoXCJub3RpY2VcIiwgcmVsYXksIG5vdGljZSk7XG4gICAgY29uc3QgY29ubmVjdEhhbmRsZXIgPSAoKSA9PiB0aGlzLmhhbmRsZVJlbGF5Q29ubmVjdChyZWxheVVybCk7XG4gICAgY29uc3QgcmVhZHlIYW5kbGVyID0gKCkgPT4gdGhpcy5oYW5kbGVSZWxheVJlYWR5KHJlbGF5KTtcbiAgICBjb25zdCBkaXNjb25uZWN0SGFuZGxlciA9ICgpID0+IHRoaXMuZW1pdChcInJlbGF5OmRpc2Nvbm5lY3RcIiwgcmVsYXkpO1xuICAgIGNvbnN0IGZsYXBwaW5nSGFuZGxlciA9ICgpID0+IHRoaXMuaGFuZGxlRmxhcHBpbmcocmVsYXkpO1xuICAgIGNvbnN0IGF1dGhIYW5kbGVyID0gKGNoYWxsZW5nZSkgPT4gdGhpcy5lbWl0KFwicmVsYXk6YXV0aFwiLCByZWxheSwgY2hhbGxlbmdlKTtcbiAgICBjb25zdCBhdXRoZWRIYW5kbGVyID0gKCkgPT4gdGhpcy5lbWl0KFwicmVsYXk6YXV0aGVkXCIsIHJlbGF5KTtcbiAgICByZWxheS5vZmYoXCJub3RpY2VcIiwgbm90aWNlSGFuZGxlcik7XG4gICAgcmVsYXkub2ZmKFwiY29ubmVjdFwiLCBjb25uZWN0SGFuZGxlcik7XG4gICAgcmVsYXkub2ZmKFwicmVhZHlcIiwgcmVhZHlIYW5kbGVyKTtcbiAgICByZWxheS5vZmYoXCJkaXNjb25uZWN0XCIsIGRpc2Nvbm5lY3RIYW5kbGVyKTtcbiAgICByZWxheS5vZmYoXCJmbGFwcGluZ1wiLCBmbGFwcGluZ0hhbmRsZXIpO1xuICAgIHJlbGF5Lm9mZihcImF1dGhcIiwgYXV0aEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9mZihcImF1dGhlZFwiLCBhdXRoZWRIYW5kbGVyKTtcbiAgICByZWxheS5vbihcIm5vdGljZVwiLCBub3RpY2VIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImNvbm5lY3RcIiwgY29ubmVjdEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwicmVhZHlcIiwgcmVhZHlIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImRpc2Nvbm5lY3RcIiwgZGlzY29ubmVjdEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwiZmxhcHBpbmdcIiwgZmxhcHBpbmdIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImF1dGhcIiwgYXV0aEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwiYXV0aGVkXCIsIGF1dGhlZEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwiZGVsYXllZC1jb25uZWN0XCIsIChkZWxheSkgPT4ge1xuICAgICAgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlcj8udXBkYXRlUmVsYXlTdGF0dXMpIHtcbiAgICAgICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLnVwZGF0ZVJlbGF5U3RhdHVzKHJlbGF5LnVybCwge1xuICAgICAgICAgIGRvbnRDb25uZWN0QmVmb3JlOiBEYXRlLm5vdygpICsgZGVsYXlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fcmVsYXlzLnNldChyZWxheVVybCwgcmVsYXkpO1xuICAgIGlmIChjb25uZWN0KSB0aGlzLmF1dG9Db25uZWN0UmVsYXlzLmFkZChyZWxheVVybCk7XG4gICAgaWYgKGNvbm5lY3QgJiYgdGhpcy5zdGF0dXMgPT09IFwiYWN0aXZlXCIpIHtcbiAgICAgIHRoaXMuZW1pdChcInJlbGF5OmNvbm5lY3RpbmdcIiwgcmVsYXkpO1xuICAgICAgcmVsYXkuY29ubmVjdCh2b2lkIDAsIHJlY29ubmVjdCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhgRmFpbGVkIHRvIGNvbm5lY3QgdG8gcmVsYXkgJHtyZWxheVVybH1gLCBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhIHJlbGF5IGZyb20gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSByZWxheVVybCAtIFRoZSBVUkwgb2YgdGhlIHJlbGF5IHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHJlbGF5IHdhcyByZW1vdmVkLCBmYWxzZSBpZiBpdCB3YXMgbm90IGZvdW5kLlxuICAgKi9cbiAgcmVtb3ZlUmVsYXkocmVsYXlVcmwpIHtcbiAgICBjb25zdCByZWxheSA9IHRoaXMucmVsYXlzLmdldChyZWxheVVybCk7XG4gICAgaWYgKHJlbGF5KSB7XG4gICAgICByZWxheS5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLnJlbGF5cy5kZWxldGUocmVsYXlVcmwpO1xuICAgICAgdGhpcy5hdXRvQ29ubmVjdFJlbGF5cy5kZWxldGUocmVsYXlVcmwpO1xuICAgICAgdGhpcy5lbWl0KFwicmVsYXk6ZGlzY29ubmVjdFwiLCByZWxheSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdUaW1lciA9IHRoaXMudGVtcG9yYXJ5UmVsYXlUaW1lcnMuZ2V0KHJlbGF5VXJsKTtcbiAgICBpZiAoZXhpc3RpbmdUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KGV4aXN0aW5nVGltZXIpO1xuICAgICAgdGhpcy50ZW1wb3JhcnlSZWxheVRpbWVycy5kZWxldGUocmVsYXlVcmwpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGEgcmVsYXkgaXMgYWxyZWFkeSBjb25uZWN0ZWQgaW4gdGhlIHBvb2wuXG4gICAqL1xuICBpc1JlbGF5Q29ubmVjdGVkKHVybCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRVcmwgPSBub3JtYWxpemVSZWxheVVybCh1cmwpO1xuICAgIGNvbnN0IHJlbGF5ID0gdGhpcy5yZWxheXMuZ2V0KG5vcm1hbGl6ZWRVcmwpO1xuICAgIGlmICghcmVsYXkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gcmVsYXkuc3RhdHVzID09PSA1IC8qIENPTk5FQ1RFRCAqLztcbiAgfVxuICAvKipcbiAgICogRmV0Y2hlcyBhIHJlbGF5IGZyb20gdGhlIHBvb2wsIG9yIGNyZWF0ZXMgYSBuZXcgb25lIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBOZXcgcmVsYXlzIHdpbGwgYmUgYXR0ZW1wdGVkIHRvIGJlIGNvbm5lY3RlZC5cbiAgICovXG4gIGdldFJlbGF5KHVybCwgY29ubmVjdCA9IHRydWUsIHRlbXBvcmFyeSA9IGZhbHNlLCBmaWx0ZXJzKSB7XG4gICAgbGV0IHJlbGF5ID0gdGhpcy5yZWxheXMuZ2V0KG5vcm1hbGl6ZVJlbGF5VXJsKHVybCkpO1xuICAgIGlmICghcmVsYXkpIHtcbiAgICAgIHJlbGF5ID0gbmV3IE5ES1JlbGF5KHVybCwgdm9pZCAwLCB0aGlzLm5kayk7XG4gICAgICByZWxheS5jb25uZWN0aXZpdHkubmV0RGVidWcgPSB0aGlzLm5kay5uZXREZWJ1ZztcbiAgICAgIGlmICh0ZW1wb3JhcnkpIHtcbiAgICAgICAgdGhpcy51c2VUZW1wb3JhcnlSZWxheShyZWxheSwgM2U0LCBmaWx0ZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkUmVsYXkocmVsYXksIGNvbm5lY3QpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbiAgaGFuZGxlUmVsYXlDb25uZWN0KHJlbGF5VXJsKSB7XG4gICAgY29uc3QgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQocmVsYXlVcmwpO1xuICAgIGlmICghcmVsYXkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJOREsgQlVHOiByZWxheSBub3QgZm91bmQgaW4gcG9vbFwiLCB7IHJlbGF5VXJsIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJyZWxheTpjb25uZWN0XCIsIHJlbGF5KTtcbiAgICBpZiAodGhpcy5zdGF0cygpLmNvbm5lY3RlZCA9PT0gdGhpcy5yZWxheXMuc2l6ZSkge1xuICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdFwiKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlUmVsYXlSZWFkeShyZWxheSkge1xuICAgIHRoaXMuZW1pdChcInJlbGF5OnJlYWR5XCIsIHJlbGF5KTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB0byBlYWNoIHJlbGF5IGluIHRoZSBwb29sLlxuICAgKlxuICAgKiBAYXN5bmNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0TXNdIC0gT3B0aW9uYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIGVhY2ggY29ubmVjdGlvbiBhdHRlbXB0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgY29ubmVjdGlvbiBhdHRlbXB0cyBoYXZlIGNvbXBsZXRlZC5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIGFueSBvZiB0aGUgY29ubmVjdGlvbiBhdHRlbXB0cyByZXN1bHQgaW4gYW4gZXJyb3Igb3IgdGltZW91dC5cbiAgICovXG4gIGFzeW5jIGNvbm5lY3QodGltZW91dE1zKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICB0aGlzLnN0YXR1cyA9IFwiYWN0aXZlXCI7XG4gICAgdGhpcy5kZWJ1ZyhgQ29ubmVjdGluZyB0byAke3RoaXMucmVsYXlzLnNpemV9IHJlbGF5cyR7dGltZW91dE1zID8gYCwgdGltZW91dCAke3RpbWVvdXRNc30uLi5gIDogXCJcIn1gKTtcbiAgICBjb25zdCByZWxheXNUb0Nvbm5lY3QgPSBuZXcgU2V0KHRoaXMuYXV0b0Nvbm5lY3RSZWxheXMua2V5cygpKTtcbiAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIHJlbGF5c1RvQ29ubmVjdCkge1xuICAgICAgY29uc3QgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQocmVsYXlVcmwpO1xuICAgICAgaWYgKCFyZWxheSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbm5lY3RQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoXCJyZWxheTpjb25uZWN0aW5nXCIsIHJlbGF5KTtcbiAgICAgICAgcmV0dXJuIHJlbGF5LmNvbm5lY3QodGltZW91dE1zKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aW1lb3V0TXMpIHtcbiAgICAgICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QoYFRpbWVkIG91dCBhZnRlciAke3RpbWVvdXRNc31tc2ApLCB0aW1lb3V0TXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICBQcm9taXNlLnJhY2UoW2Nvbm5lY3RQcm9taXNlLCB0aW1lb3V0UHJvbWlzZV0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKGBGYWlsZWQgdG8gY29ubmVjdCB0byByZWxheSAke3JlbGF5LnVybH06ICR7ZSA/PyBcIk5vIHJlYXNvbiBzcGVjaWZpZWRcIn1gKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChjb25uZWN0UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1heWJlRW1pdENvbm5lY3QgPSAoKSA9PiB7XG4gICAgICBjb25zdCBhbGxDb25uZWN0ZWQgPSB0aGlzLnN0YXRzKCkuY29ubmVjdGVkID09PSB0aGlzLnJlbGF5cy5zaXplO1xuICAgICAgY29uc3Qgc29tZUNvbm5lY3RlZCA9IHRoaXMuc3RhdHMoKS5jb25uZWN0ZWQgPiAwO1xuICAgICAgaWYgKCFhbGxDb25uZWN0ZWQgJiYgc29tZUNvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0XCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHRpbWVvdXRNcykgc2V0VGltZW91dChtYXliZUVtaXRDb25uZWN0LCB0aW1lb3V0TXMpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICBtYXliZUVtaXRDb25uZWN0KCk7XG4gIH1cbiAgY2hlY2tPbkZsYXBwaW5nUmVsYXlzKCkge1xuICAgIGNvbnN0IGZsYXBwaW5nUmVsYXlzQ291bnQgPSB0aGlzLmZsYXBwaW5nUmVsYXlzLnNpemU7XG4gICAgY29uc3QgdG90YWxSZWxheXMgPSB0aGlzLnJlbGF5cy5zaXplO1xuICAgIGlmIChmbGFwcGluZ1JlbGF5c0NvdW50IC8gdG90YWxSZWxheXMgPj0gMC44KSB7XG4gICAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIHRoaXMuZmxhcHBpbmdSZWxheXMpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZXMuc2V0KHJlbGF5VXJsLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlRmxhcHBpbmcocmVsYXkpIHtcbiAgICB0aGlzLmRlYnVnKGBSZWxheSAke3JlbGF5LnVybH0gaXMgZmxhcHBpbmdgKTtcbiAgICBsZXQgY3VycmVudEJhY2tvZmYgPSB0aGlzLmJhY2tvZmZUaW1lcy5nZXQocmVsYXkudXJsKSB8fCA1ZTM7XG4gICAgY3VycmVudEJhY2tvZmYgPSBjdXJyZW50QmFja29mZiAqIDI7XG4gICAgdGhpcy5iYWNrb2ZmVGltZXMuc2V0KHJlbGF5LnVybCwgY3VycmVudEJhY2tvZmYpO1xuICAgIHRoaXMuZGVidWcoYEJhY2tvZmYgdGltZSBmb3IgJHtyZWxheS51cmx9IGlzICR7Y3VycmVudEJhY2tvZmZ9bXNgKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZGVidWcoYEF0dGVtcHRpbmcgdG8gcmVjb25uZWN0IHRvICR7cmVsYXkudXJsfWApO1xuICAgICAgdGhpcy5lbWl0KFwicmVsYXk6Y29ubmVjdGluZ1wiLCByZWxheSk7XG4gICAgICByZWxheS5jb25uZWN0KCk7XG4gICAgICB0aGlzLmNoZWNrT25GbGFwcGluZ1JlbGF5cygpO1xuICAgIH0sIGN1cnJlbnRCYWNrb2ZmKTtcbiAgICByZWxheS5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5lbWl0KFwiZmxhcHBpbmdcIiwgcmVsYXkpO1xuICB9XG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXlzLnNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXR1cyBvZiBlYWNoIHJlbGF5IGluIHRoZSBwb29sLlxuICAgKiBAcmV0dXJucyB7TkRLUG9vbFN0YXRzfSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbnVtYmVyIG9mIHJlbGF5cyBpbiBlYWNoIHN0YXR1cy5cbiAgICovXG4gIHN0YXRzKCkge1xuICAgIGNvbnN0IHN0YXRzID0ge1xuICAgICAgdG90YWw6IDAsXG4gICAgICBjb25uZWN0ZWQ6IDAsXG4gICAgICBkaXNjb25uZWN0ZWQ6IDAsXG4gICAgICBjb25uZWN0aW5nOiAwXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHRoaXMucmVsYXlzLnZhbHVlcygpKSB7XG4gICAgICBzdGF0cy50b3RhbCsrO1xuICAgICAgaWYgKHJlbGF5LnN0YXR1cyA9PT0gNSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgICAgc3RhdHMuY29ubmVjdGVkKys7XG4gICAgICB9IGVsc2UgaWYgKHJlbGF5LnN0YXR1cyA9PT0gMSAvKiBESVNDT05ORUNURUQgKi8pIHtcbiAgICAgICAgc3RhdHMuZGlzY29ubmVjdGVkKys7XG4gICAgICB9IGVsc2UgaWYgKHJlbGF5LnN0YXR1cyA9PT0gNCAvKiBDT05ORUNUSU5HICovKSB7XG4gICAgICAgIHN0YXRzLmNvbm5lY3RpbmcrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRzO1xuICB9XG4gIGNvbm5lY3RlZFJlbGF5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlbGF5cy52YWx1ZXMoKSkuZmlsdGVyKChyZWxheSkgPT4gcmVsYXkuc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovKTtcbiAgfVxuICBwZXJtYW5lbnRBbmRDb25uZWN0ZWRSZWxheXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWxheXMudmFsdWVzKCkpLmZpbHRlcihcbiAgICAgIChyZWxheSkgPT4gcmVsYXkuc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovICYmICF0aGlzLnRlbXBvcmFyeVJlbGF5VGltZXJzLmhhcyhyZWxheS51cmwpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBhbGwgcmVsYXkgdXJscyBpbiB0aGUgcG9vbC5cbiAgICovXG4gIHVybHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWxheXMua2V5cygpKTtcbiAgfVxufTtcblxuLy8gc3JjL3VzZXIvaW5kZXgudHNcbmltcG9ydCB7IG5pcDE5IGFzIG5pcDE5NSB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL251dHphcC9taW50LWxpc3QudHNcbnZhciBOREtDYXNodU1pbnRMaXN0ID0gY2xhc3MgX05ES0Nhc2h1TWludExpc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMTAwMTkgLyogQ2FzaHVNaW50TGlzdCAqLztcbiAgc3RhdGljIGtpbmRzID0gWzEwMDE5IC8qIENhc2h1TWludExpc3QgKi9dO1xuICBfcDJwaztcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMTAwMTkgLyogQ2FzaHVNaW50TGlzdCAqLztcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0Nhc2h1TWludExpc3QoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgc2V0IHJlbGF5cyh1cmxzKSB7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gdFswXSAhPT0gXCJyZWxheVwiKTtcbiAgICBmb3IgKGNvbnN0IHVybCBvZiB1cmxzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJyZWxheVwiLCB1cmxdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlbGF5cygpIHtcbiAgICBjb25zdCByID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcInJlbGF5XCIpIHtcbiAgICAgICAgci5wdXNoKHRhZ1sxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHNldCBtaW50cyh1cmxzKSB7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gdFswXSAhPT0gXCJtaW50XCIpO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIHVybHMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcIm1pbnRcIiwgdXJsXSk7XG4gICAgfVxuICB9XG4gIGdldCBtaW50cygpIHtcbiAgICBjb25zdCByID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcIm1pbnRcIikge1xuICAgICAgICByLnB1c2godGFnWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChyKSk7XG4gIH1cbiAgZ2V0IHAycGsoKSB7XG4gICAgaWYgKHRoaXMuX3AycGspIHtcbiAgICAgIHJldHVybiB0aGlzLl9wMnBrO1xuICAgIH1cbiAgICB0aGlzLl9wMnBrID0gdGhpcy50YWdWYWx1ZShcInB1YmtleVwiKSA/PyB0aGlzLnB1YmtleTtcbiAgICByZXR1cm4gdGhpcy5fcDJwaztcbiAgfVxuICBzZXQgcDJwayhwdWJrZXkpIHtcbiAgICB0aGlzLl9wMnBrID0gcHVia2V5O1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicHVia2V5XCIpO1xuICAgIGlmIChwdWJrZXkpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInB1YmtleVwiLCBwdWJrZXldKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlbGF5U2V0KCkge1xuICAgIHJldHVybiBOREtSZWxheVNldC5mcm9tUmVsYXlVcmxzKHRoaXMucmVsYXlzLCB0aGlzLm5kayk7XG4gIH1cbn07XG5cbi8vIHNyYy9zdWJzY3JpcHRpb24vaW5kZXgudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI0IH0gZnJvbSBcInRzZWVwXCI7XG5cbi8vIHNyYy9ldmVudHMva2luZHMvYXJ0aWNsZS50c1xudmFyIE5ES0FydGljbGUgPSBjbGFzcyBfTkRLQXJ0aWNsZSBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGtpbmQgPSAzMDAyMyAvKiBBcnRpY2xlICovO1xuICBzdGF0aWMga2luZHMgPSBbMzAwMjMgLyogQXJ0aWNsZSAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMwMDIzIC8qIEFydGljbGUgKi87XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOREtBcnRpY2xlIGZyb20gYW4gZXhpc3RpbmcgTkRLRXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBOREtFdmVudCB0byBjcmVhdGUgdGhlIE5ES0FydGljbGUgZnJvbS5cbiAgICogQHJldHVybnMgTkRLQXJ0aWNsZVxuICAgKi9cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtBcnRpY2xlKGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRpdGxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBhcnRpY2xlIHRpdGxlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRpdGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gdGl0bGUgLSBUaGUgdGl0bGUgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZS5cbiAgICovXG4gIHNldCB0aXRsZSh0aXRsZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHRpdGxlKSB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB0aXRsZV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIGltYWdlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBhcnRpY2xlIGltYWdlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBpbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImltYWdlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIGltYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gaW1hZ2UgLSBUaGUgaW1hZ2UgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZS5cbiAgICovXG4gIHNldCBpbWFnZShpbWFnZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiaW1hZ2VcIik7XG4gICAgaWYgKGltYWdlKSB0aGlzLnRhZ3MucHVzaChbXCJpbWFnZVwiLCBpbWFnZV0pO1xuICB9XG4gIGdldCBzdW1tYXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwic3VtbWFyeVwiKTtcbiAgfVxuICBzZXQgc3VtbWFyeShzdW1tYXJ5KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJzdW1tYXJ5XCIpO1xuICAgIGlmIChzdW1tYXJ5KSB0aGlzLnRhZ3MucHVzaChbXCJzdW1tYXJ5XCIsIHN1bW1hcnldKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYXJ0aWNsZSdzIHB1YmxpY2F0aW9uIHRpbWVzdGFtcC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH0gLSBUaGUgVW5peCB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgYXJ0aWNsZSB3YXMgcHVibGlzaGVkIG9yIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBwdWJsaXNoZWRfYXQoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdWYWx1ZShcInB1Ymxpc2hlZF9hdFwiKTtcbiAgICBpZiAodGFnKSB7XG4gICAgICBsZXQgdmFsID0gTnVtYmVyLnBhcnNlSW50KHRhZyk7XG4gICAgICBpZiAodmFsID4gMWUxMikge1xuICAgICAgICB2YWwgPSBNYXRoLmZsb29yKHZhbCAvIDFlMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlJ3MgcHVibGljYXRpb24gdGltZXN0YW1wLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gdGltZXN0YW1wIC0gVGhlIFVuaXggdGltZXN0YW1wIHRvIHNldCBmb3IgdGhlIGFydGljbGUncyBwdWJsaWNhdGlvbiBkYXRlLlxuICAgKi9cbiAgc2V0IHB1Ymxpc2hlZF9hdCh0aW1lc3RhbXApIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInB1Ymxpc2hlZF9hdFwiKTtcbiAgICBpZiAodGltZXN0YW1wICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInB1Ymxpc2hlZF9hdFwiLCB0aW1lc3RhbXAudG9TdHJpbmcoKV0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvbnRlbnQgdGFncyBmb3IgdGhlIGFydGljbGUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGZpcnN0IGNoZWNrcyBhbmQgc2V0cyB0aGUgcHVibGljYXRpb24gZGF0ZSBpZiBub3QgYXZhaWxhYmxlLFxuICAgKiBhbmQgdGhlbiBnZW5lcmF0ZXMgY29udGVudCB0YWdzIGJhc2VkIG9uIHRoZSBiYXNlIE5ES0V2ZW50IGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gLSBUaGUgZ2VuZXJhdGVkIGNvbnRlbnQgdGFncy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlVGFncygpIHtcbiAgICBzdXBlci5nZW5lcmF0ZVRhZ3MoKTtcbiAgICBpZiAoIXRoaXMucHVibGlzaGVkX2F0KSB7XG4gICAgICB0aGlzLnB1Ymxpc2hlZF9hdCA9IHRoaXMuY3JlYXRlZF9hdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlJ3MgVVJMLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBhcnRpY2xlJ3MgVVJMIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ1cmxcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGFydGljbGUncyBVUkwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSB1cmwgLSBUaGUgVVJMIHRvIHNldCBmb3IgdGhlIGFydGljbGUuXG4gICAqL1xuICBzZXQgdXJsKHVybCkge1xuICAgIGlmICh1cmwpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInVybFwiLCB1cmxdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVUYWcoXCJ1cmxcIik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2Nhc2h1L3Rva2VuLnRzXG5mdW5jdGlvbiBwcm9vZnNUb3RhbEJhbGFuY2UocHJvb2ZzKSB7XG4gIHJldHVybiBwcm9vZnMucmVkdWNlKChhY2MsIHByb29mKSA9PiB7XG4gICAgaWYgKHByb29mLmFtb3VudCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInByb29mIGFtb3VudCBpcyBuZWdhdGl2ZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYyArIHByb29mLmFtb3VudDtcbiAgfSwgMCk7XG59XG52YXIgTkRLQ2FzaHVUb2tlbiA9IGNsYXNzIF9OREtDYXNodVRva2VuIGV4dGVuZHMgTkRLRXZlbnQge1xuICBfcHJvb2ZzID0gW107XG4gIF9taW50O1xuICBzdGF0aWMga2luZCA9IDczNzUgLyogQ2FzaHVUb2tlbiAqLztcbiAgc3RhdGljIGtpbmRzID0gWzczNzUgLyogQ2FzaHVUb2tlbiAqL107XG4gIC8qKlxuICAgKiBUb2tlbnMgdGhhdCB0aGlzIHRva2VuIHN1cGVyc2VlZHNcbiAgICovXG4gIF9kZWxldGVzID0gW107XG4gIG9yaWdpbmFsO1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIobmRrLCBldmVudCk7XG4gICAgdGhpcy5raW5kID8/PSA3Mzc1IC8qIENhc2h1VG9rZW4gKi87XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb20oZXZlbnQpIHtcbiAgICBjb25zdCB0b2tlbiA9IG5ldyBfTkRLQ2FzaHVUb2tlbihldmVudC5uZGssIGV2ZW50KTtcbiAgICB0b2tlbi5vcmlnaW5hbCA9IGV2ZW50O1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0b2tlbi5kZWNyeXB0KCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0b2tlbi5jb250ZW50ID0gdG9rZW4ub3JpZ2luYWwuY29udGVudDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBKU09OLnBhcnNlKHRva2VuLmNvbnRlbnQpO1xuICAgICAgdG9rZW4ucHJvb2ZzID0gY29udGVudC5wcm9vZnM7XG4gICAgICB0b2tlbi5taW50ID0gY29udGVudC5taW50ID8/IHRva2VuLnRhZ1ZhbHVlKFwibWludFwiKTtcbiAgICAgIHRva2VuLmRlbGV0ZWRUb2tlbnMgPSBjb250ZW50LmRlbCA/PyBbXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0b2tlbi5wcm9vZnMpKSByZXR1cm47XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG4gIGdldCBwcm9vZnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb29mcztcbiAgfVxuICBzZXQgcHJvb2ZzKHByb29mcykge1xuICAgIGNvbnN0IGNzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLl9wcm9vZnMgPSBwcm9vZnMuZmlsdGVyKChwcm9vZikgPT4ge1xuICAgICAgaWYgKGNzLmhhcyhwcm9vZi5DKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJQYXNzZWQgaW4gcHJvb2ZzIGhhZCBkdXBsaWNhdGVzLCBpZ25vcmluZ1wiLCBwcm9vZi5DKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHByb29mLmFtb3VudCA8IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCBwcm9vZiB3aXRoIG5lZ2F0aXZlIGFtb3VudFwiLCBwcm9vZik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNzLmFkZChwcm9vZi5DKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pLm1hcCh0aGlzLmNsZWFuUHJvb2YpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbWluaW1hbCBwcm9vZiBvYmplY3Qgd2l0aCBvbmx5IGVzc2VudGlhbCBwcm9wZXJ0aWVzXG4gICAqL1xuICBjbGVhblByb29mKHByb29mKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBwcm9vZi5pZCxcbiAgICAgIGFtb3VudDogcHJvb2YuYW1vdW50LFxuICAgICAgQzogcHJvb2YuQyxcbiAgICAgIHNlY3JldDogcHJvb2Yuc2VjcmV0XG4gICAgfTtcbiAgfVxuICBhc3luYyB0b05vc3RyRXZlbnQocHVia2V5KSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwibm8gbmRrXCIpO1xuICAgIGlmICghdGhpcy5uZGsuc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBzaWduZXJcIik7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIHByb29mczogdGhpcy5wcm9vZnMubWFwKHRoaXMuY2xlYW5Qcm9vZiksXG4gICAgICBtaW50OiB0aGlzLm1pbnQsXG4gICAgICBkZWw6IHRoaXMuZGVsZXRlZFRva2VucyA/PyBbXVxuICAgIH07XG4gICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci51c2VyKCk7XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIsIHZvaWQgMCwgXCJuaXA0NFwiKTtcbiAgICByZXR1cm4gc3VwZXIudG9Ob3N0ckV2ZW50KHB1YmtleSk7XG4gIH1cbiAgc2V0IG1pbnQobWludCkge1xuICAgIHRoaXMuX21pbnQgPSBtaW50O1xuICB9XG4gIGdldCBtaW50KCkge1xuICAgIHJldHVybiB0aGlzLl9taW50O1xuICB9XG4gIC8qKlxuICAgKiBUb2tlbnMgdGhhdCB3ZXJlIGRlbGV0ZWQgYnkgdGhlIGNyZWF0aW9uIG9mIHRoaXMgdG9rZW4uXG4gICAqL1xuICBnZXQgZGVsZXRlZFRva2VucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVsZXRlcztcbiAgfVxuICAvKipcbiAgICogTWFya3MgdG9rZW5zIHRoYXQgd2VyZSBkZWxldGVkIGJ5IHRoZSBjcmVhdGlvbiBvZiB0aGlzIHRva2VuLlxuICAgKi9cbiAgc2V0IGRlbGV0ZWRUb2tlbnModG9rZW5JZHMpIHtcbiAgICB0aGlzLl9kZWxldGVzID0gdG9rZW5JZHM7XG4gIH1cbiAgZ2V0IGFtb3VudCgpIHtcbiAgICByZXR1cm4gcHJvb2ZzVG90YWxCYWxhbmNlKHRoaXMucHJvb2ZzKTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgIGlmICh0aGlzLm9yaWdpbmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbC5wdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvaGlnaGxpZ2h0LnRzXG5pbXBvcnQgeyBuaXAxOSBhcyBuaXAxOTMgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbnZhciBOREtIaWdobGlnaHQgPSBjbGFzcyBfTkRLSGlnaGxpZ2h0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBfYXJ0aWNsZTtcbiAgc3RhdGljIGtpbmQgPSA5ODAyIC8qIEhpZ2hsaWdodCAqLztcbiAgc3RhdGljIGtpbmRzID0gWzk4MDIgLyogSGlnaGxpZ2h0ICovXTtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gOTgwMiAvKiBIaWdobGlnaHQgKi87XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtIaWdobGlnaHQoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInJcIik7XG4gIH1cbiAgLyoqXG4gICAqIENvbnRleHQgdGFnLlxuICAgKi9cbiAgc2V0IGNvbnRleHQoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKFt0YWcsIF92YWx1ZV0pID0+IHRhZyAhPT0gXCJjb250ZXh0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKChbdGFnLCBfdmFsdWVdKSA9PiB0YWcgIT09IFwiY29udGV4dFwiKTtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcImNvbnRleHRcIiwgY29udGV4dF0pO1xuICAgIH1cbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbmQoKFt0YWcsIF92YWx1ZV0pID0+IHRhZyA9PT0gXCJjb250ZXh0XCIpPy5bMV0gPz8gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBXaWxsIHJldHVybiB0aGUgYXJ0aWNsZSBVUkwgb3IgTkRLRXZlbnQgaWYgdGhleSBoYXZlIGFscmVhZHkgYmVlblxuICAgKiBzZXQgKGl0IHdvbid0IGF0dGVtcHQgdG8gbG9hZCByZW1vdGUgZXZlbnRzKVxuICAgKi9cbiAgZ2V0IGFydGljbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FydGljbGU7XG4gIH1cbiAgLyoqXG4gICAqIEFydGljbGUgdGhlIGhpZ2hsaWdodCBpcyBjb21pbmcgZnJvbS5cbiAgICpcbiAgICogQHBhcmFtIGFydGljbGUgQXJ0aWNsZSBVUkwgb3IgTkRLRXZlbnQuXG4gICAqL1xuICBzZXQgYXJ0aWNsZShhcnRpY2xlKSB7XG4gICAgdGhpcy5fYXJ0aWNsZSA9IGFydGljbGU7XG4gICAgaWYgKHR5cGVvZiBhcnRpY2xlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJyXCIsIGFydGljbGVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWcoYXJ0aWNsZSk7XG4gICAgfVxuICB9XG4gIGdldEFydGljbGVUYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiYVwiKVswXSB8fCB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIilbMF0gfHwgdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJyXCIpWzBdO1xuICB9XG4gIGFzeW5jIGdldEFydGljbGUoKSB7XG4gICAgaWYgKHRoaXMuX2FydGljbGUgIT09IHZvaWQgMCkgcmV0dXJuIHRoaXMuX2FydGljbGU7XG4gICAgbGV0IHRhZ2dlZEJlY2gzMjtcbiAgICBjb25zdCBhcnRpY2xlVGFnID0gdGhpcy5nZXRBcnRpY2xlVGFnKCk7XG4gICAgaWYgKCFhcnRpY2xlVGFnKSByZXR1cm4gdm9pZCAwO1xuICAgIHN3aXRjaCAoYXJ0aWNsZVRhZ1swXSkge1xuICAgICAgY2FzZSBcImFcIjoge1xuICAgICAgICBjb25zdCBba2luZCwgcHVia2V5LCBpZGVudGlmaWVyXSA9IGFydGljbGVUYWdbMV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICB0YWdnZWRCZWNoMzIgPSBuaXAxOTMubmFkZHJFbmNvZGUoe1xuICAgICAgICAgIGtpbmQ6IE51bWJlci5wYXJzZUludChraW5kKSxcbiAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgaWRlbnRpZmllclxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZVwiOlxuICAgICAgICB0YWdnZWRCZWNoMzIgPSBuaXAxOTMubm90ZUVuY29kZShhcnRpY2xlVGFnWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiclwiOlxuICAgICAgICB0aGlzLl9hcnRpY2xlID0gYXJ0aWNsZVRhZ1sxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0YWdnZWRCZWNoMzIpIHtcbiAgICAgIGxldCBhID0gYXdhaXQgdGhpcy5uZGs/LmZldGNoRXZlbnQodGFnZ2VkQmVjaDMyKTtcbiAgICAgIGlmIChhKSB7XG4gICAgICAgIGlmIChhLmtpbmQgPT09IDMwMDIzIC8qIEFydGljbGUgKi8pIHtcbiAgICAgICAgICBhID0gTkRLQXJ0aWNsZS5mcm9tKGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FydGljbGUgPSBhO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYXJ0aWNsZTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2ltZXRhLnRzXG5mdW5jdGlvbiBtYXBJbWV0YVRhZyh0YWcpIHtcbiAgY29uc3QgZGF0YSA9IHt9O1xuICBpZiAodGFnLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IHBhcnRzID0gdGFnWzFdLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCBrZXkgPSBwYXJ0c1tpXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcGFydHNbaSArIDFdO1xuICAgICAgaWYgKGtleSA9PT0gXCJmYWxsYmFja1wiKSB7XG4gICAgICAgIGlmICghZGF0YS5mYWxsYmFjaykgZGF0YS5mYWxsYmFjayA9IFtdO1xuICAgICAgICBkYXRhLmZhbGxiYWNrLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGNvbnN0IHRhZ3MgPSB0YWcuc2xpY2UoMSk7XG4gIGZvciAoY29uc3QgdmFsIG9mIHRhZ3MpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHZhbC5zcGxpdChcIiBcIik7XG4gICAgY29uc3Qga2V5ID0gcGFydHNbMF07XG4gICAgY29uc3QgdmFsdWUgPSBwYXJ0cy5zbGljZSgxKS5qb2luKFwiIFwiKTtcbiAgICBpZiAoa2V5ID09PSBcImZhbGxiYWNrXCIpIHtcbiAgICAgIGlmICghZGF0YS5mYWxsYmFjaykgZGF0YS5mYWxsYmFjayA9IFtdO1xuICAgICAgZGF0YS5mYWxsYmFjay5wdXNoKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gaW1ldGFUYWdUb1RhZyhpbWV0YSkge1xuICBjb25zdCB0YWcgPSBbXCJpbWV0YVwiXTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW1ldGEpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgdGFnLnB1c2goYCR7a2V5fSAke3Z9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgdGFnLnB1c2goYCR7a2V5fSAke3ZhbHVlfWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFnO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2ltYWdlLnRzXG52YXIgTkRLSW1hZ2UgPSBjbGFzcyBfTkRLSW1hZ2UgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMjAgLyogSW1hZ2UgKi87XG4gIHN0YXRpYyBraW5kcyA9IFsyMCAvKiBJbWFnZSAqL107XG4gIF9pbWV0YXM7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDIwIC8qIEltYWdlICovO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTkRLSW1hZ2UgZnJvbSBhbiBleGlzdGluZyBOREtFdmVudC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IE5ES0V2ZW50IHRvIGNyZWF0ZSB0aGUgTkRLSW1hZ2UgZnJvbS5cbiAgICogQHJldHVybnMgTkRLSW1hZ2VcbiAgICovXG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLSW1hZ2UoZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWV0YXMubGVuZ3RoID4gMDtcbiAgfVxuICBnZXQgaW1ldGFzKCkge1xuICAgIGlmICh0aGlzLl9pbWV0YXMpIHJldHVybiB0aGlzLl9pbWV0YXM7XG4gICAgdGhpcy5faW1ldGFzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiaW1ldGFcIikubWFwKG1hcEltZXRhVGFnKS5maWx0ZXIoKGltZXRhKSA9PiAhIWltZXRhLnVybCk7XG4gICAgcmV0dXJuIHRoaXMuX2ltZXRhcztcbiAgfVxuICBzZXQgaW1ldGFzKHRhZ3MpIHtcbiAgICB0aGlzLl9pbWV0YXMgPSB0YWdzO1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcImltZXRhXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKC4uLnRhZ3MubWFwKGltZXRhVGFnVG9UYWcpKTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9saXN0cy9pbmRleC50c1xudmFyIE5ES0xpc3QgPSBjbGFzcyBfTkRLTGlzdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgX2VuY3J5cHRlZFRhZ3M7XG4gIHN0YXRpYyBraW5kcyA9IFtcbiAgICAxMDA2MyAvKiBCbG9zc29tTGlzdCAqLyxcbiAgICAzMDAwMSAvKiBDYXRlZ29yaXplZEJvb2ttYXJrTGlzdCAqLyxcbiAgICAxMDAwNCAvKiBDb21tdW5pdHlMaXN0ICovLFxuICAgIDEwMDUwIC8qIERpcmVjdE1lc3NhZ2VSZWNlaXZlUmVsYXlMaXN0ICovLFxuICAgIDEwMDMwIC8qIEVtb2ppTGlzdCAqLyxcbiAgICAxMDAxNSAvKiBJbnRlcmVzdExpc3QgKi8sXG4gICAgMTAwMDEgLyogUGluTGlzdCAqLyxcbiAgICAxMDAwMiAvKiBSZWxheUxpc3QgKi8sXG4gICAgMTAwMDcgLyogU2VhcmNoUmVsYXlMaXN0ICovLFxuICAgIDEwMDA2IC8qIEJsb2NrUmVsYXlMaXN0ICovLFxuICAgIDEwMDAzIC8qIEJvb2ttYXJrTGlzdCAqL1xuICBdO1xuICAvKipcbiAgICogU3RvcmVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGNvbnRlbnQgd2FzIGJlZm9yZSBkZWNyeXB0aW9uXG4gICAqIHRvIGV4cGlyZSB0aGUgY2FjaGUgd2hlbiB0aGUgY29udGVudCBjaGFuZ2VzLlxuICAgKi9cbiAgZW5jcnlwdGVkVGFnc0xlbmd0aDtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzAwMDEgLyogQ2F0ZWdvcml6ZWRCb29rbWFya0xpc3QgKi87XG4gIH1cbiAgLyoqXG4gICAqIFdyYXAgYSBOREtFdmVudCBpbnRvIGEgTkRLTGlzdFxuICAgKi9cbiAgc3RhdGljIGZyb20obmRrRXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtMaXN0KG5ka0V2ZW50Lm5kaywgbmRrRXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0aXRsZSBvZiB0aGUgbGlzdC4gRmFsbHMgYmFjayBvbiBmZXRjaGluZyB0aGUgbmFtZSB0YWcgdmFsdWUuXG4gICAqL1xuICBnZXQgdGl0bGUoKSB7XG4gICAgY29uc3QgdGl0bGVUYWcgPSB0aGlzLnRhZ1ZhbHVlKFwidGl0bGVcIikgfHwgdGhpcy50YWdWYWx1ZShcIm5hbWVcIik7XG4gICAgaWYgKHRpdGxlVGFnKSByZXR1cm4gdGl0bGVUYWc7XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMyAvKiBDb250YWN0cyAqLykge1xuICAgICAgcmV0dXJuIFwiQ29udGFjdHNcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMWU0IC8qIE11dGVMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJNdXRlXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDAxIC8qIFBpbkxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIlBpbm5lZCBOb3Rlc1wiO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSAxMDAwMiAvKiBSZWxheUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIlJlbGF5IE1ldGFkYXRhXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDAzIC8qIEJvb2ttYXJrTGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiQm9va21hcmtzXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDA0IC8qIENvbW11bml0eUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIkNvbW11bml0aWVzXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDA1IC8qIFB1YmxpY0NoYXRMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJQdWJsaWMgQ2hhdHNcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMTAwMDYgLyogQmxvY2tSZWxheUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIkJsb2NrZWQgUmVsYXlzXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDA3IC8qIFNlYXJjaFJlbGF5TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiU2VhcmNoIFJlbGF5c1wiO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSAxMDA1MCAvKiBEaXJlY3RNZXNzYWdlUmVjZWl2ZVJlbGF5TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiRGlyZWN0IE1lc3NhZ2UgUmVjZWl2ZSBSZWxheXNcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMTAwMTUgLyogSW50ZXJlc3RMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJJbnRlcmVzdHNcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMTAwMzAgLyogRW1vamlMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJFbW9qaXNcIjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0aXRsZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIHNldCB0aXRsZSh0aXRsZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFtcInRpdGxlXCIsIFwibmFtZVwiXSk7XG4gICAgaWYgKHRpdGxlKSB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB0aXRsZV0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBsaXN0LlxuICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIFwidGl0bGVcIiBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5hbWUgb2YgdGhlIGxpc3QuXG4gICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgXCJ0aXRsZVwiIGluc3RlYWQuIFRoaXMgbWV0aG9kIHdpbGwgdXNlIHRoZSBgdGl0bGVgIHRhZyBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0IG5hbWUobmFtZSkge1xuICAgIHRoaXMudGl0bGUgPSBuYW1lO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImRlc2NyaXB0aW9uXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgbGlzdC5cbiAgICovXG4gIHNldCBkZXNjcmlwdGlvbihuYW1lKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkZXNjcmlwdGlvblwiKTtcbiAgICBpZiAobmFtZSkgdGhpcy50YWdzLnB1c2goW1wiZGVzY3JpcHRpb25cIiwgbmFtZV0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbWFnZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGdldCBpbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImltYWdlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbWFnZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIHNldCBpbWFnZShuYW1lKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJpbWFnZVwiKTtcbiAgICBpZiAobmFtZSkgdGhpcy50YWdzLnB1c2goW1wiaW1hZ2VcIiwgbmFtZV0pO1xuICB9XG4gIGlzRW5jcnlwdGVkVGFnc0NhY2hlVmFsaWQoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuX2VuY3J5cHRlZFRhZ3MgJiYgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID09PSB0aGlzLmNvbnRlbnQubGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVjcnlwdGVkIGNvbnRlbnQgb2YgdGhlIGxpc3QuXG4gICAqL1xuICBhc3luYyBlbmNyeXB0ZWRUYWdzKHVzZUNhY2hlID0gdHJ1ZSkge1xuICAgIGlmICh1c2VDYWNoZSAmJiB0aGlzLmlzRW5jcnlwdGVkVGFnc0NhY2hlVmFsaWQoKSkgcmV0dXJuIHRoaXMuX2VuY3J5cHRlZFRhZ3M7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBzZXRcIik7XG4gICAgaWYgKCF0aGlzLm5kay5zaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5ESyBzaWduZXIgbm90IHNldFwiKTtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLnVzZXIoKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZGVjcnlwdGVkQ29udGVudCA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci5kZWNyeXB0KHVzZXIsIHRoaXMuY29udGVudCk7XG4gICAgICAgICAgY29uc3QgYSA9IEpTT04ucGFyc2UoZGVjcnlwdGVkQ29udGVudCk7XG4gICAgICAgICAgaWYgKGE/LlswXSkge1xuICAgICAgICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmNyeXB0ZWRUYWdzID0gYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZW5jcnlwdGVkVGFncyA9IFtdO1xuICAgICAgICB9IGNhdGNoIChfZSkge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGVuIHRvIHZhbGlkYXRlIHRoYXQgYSB0YWcgaXMgdmFsaWQgZm9yIHRoaXMgbGlzdC5cbiAgICpcbiAgICogKGkuZS4gdGhlIE5ES1BlcnNvbkxpc3QgY2FuIHZhbGlkYXRlIHRoYXQgaXRlbXMgYXJlIE5ES1VzZXIgaW5zdGFuY2VzKVxuICAgKi9cbiAgdmFsaWRhdGVUYWcoX3RhZ1ZhbHVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0SXRlbXModHlwZSkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gdHlwZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVuZWNyeXB0ZWQgaXRlbXMgaW4gdGhpcyBsaXN0LlxuICAgKi9cbiAgZ2V0IGl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0KSA9PiB7XG4gICAgICByZXR1cm4gIVtcbiAgICAgICAgXCJkXCIsXG4gICAgICAgIFwiTFwiLFxuICAgICAgICBcImxcIixcbiAgICAgICAgXCJ0aXRsZVwiLFxuICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiLFxuICAgICAgICBcInB1Ymxpc2hlZF9hdFwiLFxuICAgICAgICBcInN1bW1hcnlcIixcbiAgICAgICAgXCJpbWFnZVwiLFxuICAgICAgICBcInRodW1iXCIsXG4gICAgICAgIFwiYWx0XCIsXG4gICAgICAgIFwiZXhwaXJhdGlvblwiLFxuICAgICAgICBcInN1YmplY3RcIixcbiAgICAgICAgXCJjbGllbnRcIlxuICAgICAgXS5pbmNsdWRlcyh0WzBdKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG5ldyBpdGVtIHRvIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0gcmVsYXkgUmVsYXkgdG8gYWRkXG4gICAqIEBwYXJhbSBtYXJrIE9wdGlvbmFsIG1hcmsgdG8gYWRkIHRvIHRoZSBpdGVtXG4gICAqIEBwYXJhbSBlbmNyeXB0ZWQgV2hldGhlciB0byBlbmNyeXB0IHRoZSBpdGVtXG4gICAqIEBwYXJhbSBwb3NpdGlvbiBXaGVyZSB0byBhZGQgdGhlIGl0ZW0gaW4gdGhlIGxpc3QgKHRvcCBvciBib3R0b20pXG4gICAqL1xuICBhc3luYyBhZGRJdGVtKGl0ZW0sIG1hcmsgPSB2b2lkIDAsIGVuY3J5cHRlZCA9IGZhbHNlLCBwb3NpdGlvbiA9IFwiYm90dG9tXCIpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IHNldFwiKTtcbiAgICBpZiAoIXRoaXMubmRrLnNpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwiTkRLIHNpZ25lciBub3Qgc2V0XCIpO1xuICAgIGxldCB0YWdzO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICAgIHRhZ3MgPSBbaXRlbS50YWdSZWZlcmVuY2UobWFyayldO1xuICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES1VzZXIpIHtcbiAgICAgIHRhZ3MgPSBpdGVtLnJlZmVyZW5jZVRhZ3MoKTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtSZWxheSkge1xuICAgICAgdGFncyA9IGl0ZW0ucmVmZXJlbmNlVGFncygpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgdGFncyA9IFtpdGVtXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvYmplY3QgdHlwZVwiKTtcbiAgICB9XG4gICAgaWYgKG1hcmspIHRhZ3NbMF0ucHVzaChtYXJrKTtcbiAgICBpZiAoZW5jcnlwdGVkKSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLnVzZXIoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRMaXN0ID0gYXdhaXQgdGhpcy5lbmNyeXB0ZWRUYWdzKCk7XG4gICAgICBpZiAocG9zaXRpb24gPT09IFwidG9wXCIpIGN1cnJlbnRMaXN0LnVuc2hpZnQoLi4udGFncyk7XG4gICAgICBlbHNlIGN1cnJlbnRMaXN0LnB1c2goLi4udGFncyk7XG4gICAgICB0aGlzLl9lbmNyeXB0ZWRUYWdzID0gY3VycmVudExpc3Q7XG4gICAgICB0aGlzLmVuY3J5cHRlZFRhZ3NMZW5ndGggPSB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoY3VycmVudExpc3QpO1xuICAgICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09IFwidG9wXCIpIHRoaXMudGFncy51bnNoaWZ0KC4uLnRhZ3MpO1xuICAgICAgZWxzZSB0aGlzLnRhZ3MucHVzaCguLi50YWdzKTtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVkX2F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBsaXN0IGZyb20gYm90aCB0aGUgZW5jcnlwdGVkIGFuZCB1bmVuY3J5cHRlZCBsaXN0cy5cbiAgICogQHBhcmFtIHZhbHVlIHZhbHVlIG9mIGl0ZW0gdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3RcbiAgICogQHBhcmFtIHB1Ymxpc2ggd2hldGhlciB0byBwdWJsaXNoIHRoZSBjaGFuZ2VcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIHJlbW92ZUl0ZW1CeVZhbHVlKHZhbHVlLCBwdWJsaXNoID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3Qgc2V0XCIpO1xuICAgIGlmICghdGhpcy5uZGsuc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgc2lnbmVyIG5vdCBzZXRcIik7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnRhZ3MuZmluZEluZGV4KCh0YWcpID0+IHRhZ1sxXSA9PT0gdmFsdWUpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLnRhZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3QgZW5jcnlwdGVkVGFncyA9IGF3YWl0IHRoaXMuZW5jcnlwdGVkVGFncygpO1xuICAgIGNvbnN0IGVuY3J5cHRlZEluZGV4ID0gZW5jcnlwdGVkVGFncy5maW5kSW5kZXgoKHRhZykgPT4gdGFnWzFdID09PSB2YWx1ZSk7XG4gICAgaWYgKGVuY3J5cHRlZEluZGV4ID49IDApIHtcbiAgICAgIGVuY3J5cHRlZFRhZ3Muc3BsaWNlKGVuY3J5cHRlZEluZGV4LCAxKTtcbiAgICAgIHRoaXMuX2VuY3J5cHRlZFRhZ3MgPSBlbmNyeXB0ZWRUYWdzO1xuICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGVuY3J5cHRlZFRhZ3MpO1xuICAgICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIpO1xuICAgIH1cbiAgICBpZiAocHVibGlzaCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVibGlzaFJlcGxhY2VhYmxlKCk7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlZF9hdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgaXRlbSB0byByZW1vdmUuXG4gICAqIEBwYXJhbSBlbmNyeXB0ZWQgV2hldGhlciB0byByZW1vdmUgZnJvbSB0aGUgZW5jcnlwdGVkIGxpc3Qgb3Igbm90LlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlSXRlbShpbmRleCwgZW5jcnlwdGVkKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBzZXRcIik7XG4gICAgaWYgKCF0aGlzLm5kay5zaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5ESyBzaWduZXIgbm90IHNldFwiKTtcbiAgICBpZiAoZW5jcnlwdGVkKSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLnVzZXIoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRMaXN0ID0gYXdhaXQgdGhpcy5lbmNyeXB0ZWRUYWdzKCk7XG4gICAgICBjdXJyZW50TGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdGhpcy5fZW5jcnlwdGVkVGFncyA9IGN1cnJlbnRMaXN0O1xuICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRMaXN0KTtcbiAgICAgIGF3YWl0IHRoaXMuZW5jcnlwdCh1c2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlZF9hdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGhhcyhpdGVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMuc29tZSgodGFnKSA9PiB0YWdbMV0gPT09IGl0ZW0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZmlsdGVyIHRoYXQgd2lsbCByZXN1bHQgaW4gZmV0Y2hpbmdcbiAgICogdGhlIGl0ZW1zIG9mIHRoaXMgbGlzdFxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBsaXN0ID0gbmV3IE5ES0xpc3QoLi4uKTtcbiAgICogY29uc3QgZmlsdGVycyA9IGxpc3QuZmlsdGVyRm9ySXRlbXMoKTtcbiAgICogY29uc3QgZXZlbnRzID0gYXdhaXQgbmRrLmZldGNoRXZlbnRzKGZpbHRlcnMpO1xuICAgKi9cbiAgZmlsdGVyRm9ySXRlbXMoKSB7XG4gICAgY29uc3QgaWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBuaXAzM1F1ZXJpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiB0YWdbMV0pIHtcbiAgICAgICAgaWRzLmFkZCh0YWdbMV0pO1xuICAgICAgfSBlbHNlIGlmICh0YWdbMF0gPT09IFwiYVwiICYmIHRhZ1sxXSkge1xuICAgICAgICBjb25zdCBba2luZCwgcHVia2V5LCBkVGFnXSA9IHRhZ1sxXS5zcGxpdChcIjpcIik7XG4gICAgICAgIGlmICgha2luZCB8fCAhcHVia2V5KSBjb250aW51ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gYCR7a2luZH06JHtwdWJrZXl9YDtcbiAgICAgICAgY29uc3QgaXRlbSA9IG5pcDMzUXVlcmllcy5nZXQoa2V5KSB8fCBbXTtcbiAgICAgICAgaXRlbS5wdXNoKGRUYWcgfHwgXCJcIik7XG4gICAgICAgIG5pcDMzUXVlcmllcy5zZXQoa2V5LCBpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlkcy5zaXplID4gMCkge1xuICAgICAgZmlsdGVycy5wdXNoKHsgaWRzOiBBcnJheS5mcm9tKGlkcykgfSk7XG4gICAgfVxuICAgIGlmIChuaXAzM1F1ZXJpZXMuc2l6ZSA+IDApIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVzXSBvZiBuaXAzM1F1ZXJpZXMuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IFtraW5kLCBwdWJrZXldID0ga2V5LnNwbGl0KFwiOlwiKTtcbiAgICAgICAgZmlsdGVycy5wdXNoKHtcbiAgICAgICAgICBraW5kczogW051bWJlci5wYXJzZUludChraW5kKV0sXG4gICAgICAgICAgYXV0aG9yczogW3B1YmtleV0sXG4gICAgICAgICAgXCIjZFwiOiB2YWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJzO1xuICB9XG59O1xudmFyIGxpc3RzX2RlZmF1bHQgPSBOREtMaXN0O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL251dHphcC9pbmRleC50c1xuaW1wb3J0IGRlYnVnMiBmcm9tIFwiZGVidWdcIjtcbnZhciBOREtOdXR6YXAgPSBjbGFzcyBfTkRLTnV0emFwIGV4dGVuZHMgTkRLRXZlbnQge1xuICBkZWJ1ZztcbiAgX3Byb29mcyA9IFtdO1xuICBzdGF0aWMga2luZCA9IDkzMjEgLyogTnV0emFwICovO1xuICBzdGF0aWMga2luZHMgPSBbX05ES051dHphcC5raW5kXTtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gOTMyMSAvKiBOdXR6YXAgKi87XG4gICAgdGhpcy5kZWJ1ZyA9IG5kaz8uZGVidWcuZXh0ZW5kKFwibnV0emFwXCIpID8/IGRlYnVnMihcIm5kazpudXR6YXBcIik7XG4gICAgaWYgKCF0aGlzLmFsdCkgdGhpcy5hbHQgPSBcIlRoaXMgaXMgYSBudXR6YXBcIjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvb2ZUYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwcm9vZlwiKTtcbiAgICAgIGlmIChwcm9vZlRhZ3MubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3Byb29mcyA9IHByb29mVGFncy5tYXAoKHRhZykgPT4gSlNPTi5wYXJzZSh0YWdbMV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Byb29mcyA9IEpTT04ucGFyc2UodGhpcy5jb250ZW50KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICBjb25zdCBlID0gbmV3IF9OREtOdXR6YXAoZXZlbnQubmRrLCBldmVudCk7XG4gICAgaWYgKCFlLl9wcm9vZnMgfHwgIWUuX3Byb29mcy5sZW5ndGgpIHJldHVybjtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBzZXQgY29tbWVudChjb21tZW50KSB7XG4gICAgdGhpcy5jb250ZW50ID0gY29tbWVudCA/PyBcIlwiO1xuICB9XG4gIGdldCBjb21tZW50KCkge1xuICAgIGNvbnN0IGMgPSB0aGlzLnRhZ1ZhbHVlKFwiY29tbWVudFwiKTtcbiAgICBpZiAoYykgcmV0dXJuIGM7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgfVxuICBzZXQgcHJvb2ZzKHByb29mcykge1xuICAgIHRoaXMuX3Byb29mcyA9IHByb29mcztcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSAhPT0gXCJwcm9vZlwiKTtcbiAgICBmb3IgKGNvbnN0IHByb29mIG9mIHByb29mcykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicHJvb2ZcIiwgSlNPTi5zdHJpbmdpZnkocHJvb2YpXSk7XG4gICAgfVxuICB9XG4gIGdldCBwcm9vZnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb29mcztcbiAgfVxuICBnZXQgcmF3UDJwaygpIHtcbiAgICBjb25zdCBmaXJzdFByb29mID0gdGhpcy5wcm9vZnNbMF07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlY3JldCA9IEpTT04ucGFyc2UoZmlyc3RQcm9vZi5zZWNyZXQpO1xuICAgICAgbGV0IHBheWxvYWQ7XG4gICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShzZWNyZXQpO1xuICAgICAgICB0aGlzLmRlYnVnKFwic3RyaW5naWZpZWQgcGF5bG9hZFwiLCBmaXJzdFByb29mLnNlY3JldCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWNyZXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcGF5bG9hZCA9IHNlY3JldDtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpICYmIHBheWxvYWRbMF0gPT09IFwiUDJQS1wiICYmIHBheWxvYWQubGVuZ3RoID4gMSAmJiB0eXBlb2YgcGF5bG9hZFsxXSA9PT0gXCJvYmplY3RcIiAmJiBwYXlsb2FkWzFdICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkWzFdLmRhdGE7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09IFwib2JqZWN0XCIgJiYgcGF5bG9hZCAhPT0gbnVsbCAmJiB0eXBlb2YgcGF5bG9hZFsxXT8uZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gcGF5bG9hZFsxXS5kYXRhO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJlcnJvciBwYXJzaW5nIHAycGsgcHVia2V5XCIsIGUsIHRoaXMucHJvb2ZzWzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcDJwayBwdWJrZXkgdGhhdCBpcyBlbWJlZGRlZCBpbiB0aGUgZmlyc3QgcHJvb2YuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgYSBub3N0ciBwdWJrZXksIG5vdCBhIGNhc2h1IHB1YmtleSAobm8gXCIwMlwiIHByZWZpeClcbiAgICovXG4gIGdldCBwMnBrKCkge1xuICAgIGNvbnN0IHJhd1AycGsgPSB0aGlzLnJhd1AycGs7XG4gICAgaWYgKCFyYXdQMnBrKSByZXR1cm47XG4gICAgcmV0dXJuIHJhd1AycGsuc3RhcnRzV2l0aChcIjAyXCIpID8gcmF3UDJway5zbGljZSgyKSA6IHJhd1AycGs7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbWludCB3aGVyZSB0aGlzIG51dHphcCBwcm9vZnMgZXhpc3RcbiAgICovXG4gIGdldCBtaW50KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwidVwiKTtcbiAgfVxuICBzZXQgbWludCh2YWx1ZSkge1xuICAgIHRoaXMucmVwbGFjZVRhZyhbXCJ1XCIsIHZhbHVlXSk7XG4gIH1cbiAgZ2V0IHVuaXQoKSB7XG4gICAgbGV0IF91bml0ID0gdGhpcy50YWdWYWx1ZShcInVuaXRcIikgPz8gXCJzYXRcIjtcbiAgICBpZiAoX3VuaXQ/LnN0YXJ0c1dpdGgoXCJtc2F0XCIpKSBfdW5pdCA9IFwic2F0XCI7XG4gICAgcmV0dXJuIF91bml0O1xuICB9XG4gIHNldCB1bml0KHZhbHVlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJ1bml0XCIpO1xuICAgIGlmICh2YWx1ZT8uc3RhcnRzV2l0aChcIm1zYXRcIikpIHRocm93IG5ldyBFcnJvcihcIm1zYXQgaXMgbm90IGFsbG93ZWQsIHVzZSBzYXQgZGVub21pbmF0aW9uIGluc3RlYWRcIik7XG4gICAgaWYgKHZhbHVlKSB0aGlzLnRhZyhbXCJ1bml0XCIsIHZhbHVlXSk7XG4gIH1cbiAgZ2V0IGFtb3VudCgpIHtcbiAgICBjb25zdCBhbW91bnQgPSB0aGlzLnByb29mcy5yZWR1Y2UoKHRvdGFsLCBwcm9vZikgPT4gdG90YWwgKyBwcm9vZi5hbW91bnQsIDApO1xuICAgIHJldHVybiBhbW91bnQ7XG4gIH1cbiAgc2VuZGVyID0gdGhpcy5hdXRob3I7XG4gIC8qKlxuICAgKiBTZXQgdGhlIHRhcmdldCBvZiB0aGUgbnV0emFwXG4gICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvZiB0aGUgbnV0emFwIChhIHVzZXIgb3IgYW4gZXZlbnQpXG4gICAqL1xuICBzZXQgdGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+IHRbMF0gIT09IFwicFwiKTtcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKHRhcmdldC50YWdSZWZlcmVuY2UoKSk7XG4gICAgfVxuICB9XG4gIHNldCByZWNpcGllbnRQdWJrZXkocHVia2V5KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwXCIpO1xuICAgIHRoaXMudGFnKFtcInBcIiwgcHVia2V5XSk7XG4gIH1cbiAgZ2V0IHJlY2lwaWVudFB1YmtleSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInBcIik7XG4gIH1cbiAgZ2V0IHJlY2lwaWVudCgpIHtcbiAgICBjb25zdCBwdWJrZXkgPSB0aGlzLnJlY2lwaWVudFB1YmtleTtcbiAgICBpZiAodGhpcy5uZGspIHJldHVybiB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5IH0pO1xuICAgIHJldHVybiBuZXcgTkRLVXNlcih7IHB1YmtleSB9KTtcbiAgfVxuICBhc3luYyB0b05vc3RyRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMudW5pdCA9PT0gXCJtc2F0XCIpIHtcbiAgICAgIHRoaXMudW5pdCA9IFwic2F0XCI7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlVGFnKFwiYW1vdW50XCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImFtb3VudFwiLCB0aGlzLmFtb3VudC50b1N0cmluZygpXSk7XG4gICAgY29uc3QgZXZlbnQgPSBhd2FpdCBzdXBlci50b05vc3RyRXZlbnQoKTtcbiAgICBldmVudC5jb250ZW50ID0gdGhpcy5jb21tZW50O1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIG51dHphcCBjb25mb3JtcyB0byBOSVAtNjFcbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIGxldCBlVGFnQ291bnQgPSAwO1xuICAgIGxldCBwVGFnQ291bnQgPSAwO1xuICAgIGxldCBtaW50VGFnQ291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIpIGVUYWdDb3VudCsrO1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJwXCIpIHBUYWdDb3VudCsrO1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJ1XCIpIG1pbnRUYWdDb3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgLy8gZXhhY3RseSBvbmUgcmVjaXBpZW50IGFuZCBtaW50XG4gICAgICBwVGFnQ291bnQgPT09IDEgJiYgbWludFRhZ0NvdW50ID09PSAxICYmIC8vIG11c3QgaGF2ZSBhdCBtb3N0IG9uZSBlIHRhZ1xuICAgICAgZVRhZ0NvdW50IDw9IDEgJiYgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBwcm9vZlxuICAgICAgdGhpcy5wcm9vZnMubGVuZ3RoID4gMFxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBwcm9vZlAycGsocHJvb2YpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZWNyZXQgPSBKU09OLnBhcnNlKHByb29mLnNlY3JldCk7XG4gICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2Uoc2VjcmV0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWNyZXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHBheWxvYWQgPSBzZWNyZXQ7XG4gICAgfVxuICAgIGNvbnN0IGlzUDJQS0xvY2tlZCA9IHBheWxvYWRbMF0gPT09IFwiUDJQS1wiICYmIHBheWxvYWRbMV0/LmRhdGE7XG4gICAgaWYgKGlzUDJQS0xvY2tlZCkge1xuICAgICAgcmV0dXJuIHBheWxvYWRbMV0uZGF0YTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiZXJyb3IgcGFyc2luZyBwMnBrIHB1YmtleVwiLCBlLCBwcm9vZik7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb29mUDJwa05vc3RyKHByb29mKSB7XG4gIGNvbnN0IHAycGsgPSBwcm9vZlAycGsocHJvb2YpO1xuICBpZiAoIXAycGspIHJldHVybjtcbiAgaWYgKHAycGsuc3RhcnRzV2l0aChcIjAyXCIpICYmIHAycGsubGVuZ3RoID09PSA2NikgcmV0dXJuIHAycGsuc2xpY2UoMik7XG4gIHJldHVybiBwMnBrO1xufVxuZnVuY3Rpb24gY2FzaHVQdWJrZXlUb05vc3RyUHVia2V5KGNhc2h1UHVia2V5KSB7XG4gIGlmIChjYXNodVB1YmtleS5zdGFydHNXaXRoKFwiMDJcIikgJiYgY2FzaHVQdWJrZXkubGVuZ3RoID09PSA2NikgcmV0dXJuIGNhc2h1UHVia2V5LnNsaWNlKDIpO1xuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3NpbXBsZS1ncm91cC9tZW1iZXItbGlzdC50c1xudmFyIE5ES1NpbXBsZUdyb3VwTWVtYmVyTGlzdCA9IGNsYXNzIF9OREtTaW1wbGVHcm91cE1lbWJlckxpc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHJlbGF5U2V0O1xuICBtZW1iZXJTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBzdGF0aWMga2luZCA9IDM5MDAyIC8qIEdyb3VwTWVtYmVycyAqLztcbiAgc3RhdGljIGtpbmRzID0gWzM5MDAyIC8qIEdyb3VwTWVtYmVycyAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDM5MDAyIC8qIEdyb3VwTWVtYmVycyAqLztcbiAgICB0aGlzLm1lbWJlclNldCA9IG5ldyBTZXQodGhpcy5tZW1iZXJzKTtcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1NpbXBsZUdyb3VwTWVtYmVyTGlzdChldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICBnZXQgbWVtYmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICB9XG4gIGhhc01lbWJlcihtZW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5tZW1iZXJTZXQuaGFzKG1lbWJlcik7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpIHtcbiAgICByZWxheVNldCA/Pz0gdGhpcy5yZWxheVNldDtcbiAgICByZXR1cm4gc3VwZXIucHVibGlzaFJlcGxhY2VhYmxlKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc2ltcGxlLWdyb3VwL21ldGFkYXRhLnRzXG52YXIgTkRLU2ltcGxlR3JvdXBNZXRhZGF0YSA9IGNsYXNzIF9OREtTaW1wbGVHcm91cE1ldGFkYXRhIGV4dGVuZHMgTkRLRXZlbnQge1xuICBzdGF0aWMga2luZCA9IDM5ZTMgLyogR3JvdXBNZXRhZGF0YSAqLztcbiAgc3RhdGljIGtpbmRzID0gWzM5ZTMgLyogR3JvdXBNZXRhZGF0YSAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDM5ZTMgLyogR3JvdXBNZXRhZGF0YSAqLztcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1NpbXBsZUdyb3VwTWV0YWRhdGEoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJuYW1lXCIpO1xuICB9XG4gIGdldCBwaWN0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwicGljdHVyZVwiKTtcbiAgfVxuICBnZXQgYWJvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJhYm91dFwiKTtcbiAgfVxuICBnZXQgc2NvcGUoKSB7XG4gICAgaWYgKHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicHVibGljXCIpLmxlbmd0aCA+IDApIHJldHVybiBcInB1YmxpY1wiO1xuICAgIGlmICh0aGlzLmdldE1hdGNoaW5nVGFncyhcInB1YmxpY1wiKS5sZW5ndGggPiAwKSByZXR1cm4gXCJwcml2YXRlXCI7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBzZXQgc2NvcGUoc2NvcGUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInB1YmxpY1wiKTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInByaXZhdGVcIik7XG4gICAgaWYgKHNjb3BlID09PSBcInB1YmxpY1wiKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwdWJsaWNcIiwgXCJcIl0pO1xuICAgIH0gZWxzZSBpZiAoc2NvcGUgPT09IFwicHJpdmF0ZVwiKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwcml2YXRlXCIsIFwiXCJdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFjY2VzcygpIHtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJvcGVuXCIpLmxlbmd0aCA+IDApIHJldHVybiBcIm9wZW5cIjtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJjbG9zZWRcIikubGVuZ3RoID4gMCkgcmV0dXJuIFwiY2xvc2VkXCI7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBzZXQgYWNjZXNzKGFjY2Vzcykge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwib3BlblwiKTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImNsb3NlZFwiKTtcbiAgICBpZiAoYWNjZXNzID09PSBcIm9wZW5cIikge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wib3BlblwiLCBcIlwiXSk7XG4gICAgfSBlbHNlIGlmIChhY2Nlc3MgPT09IFwiY2xvc2VkXCIpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcImNsb3NlZFwiLCBcIlwiXSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3N0b3J5LnRzXG52YXIgTkRLU3RvcnlTdGlja2VyVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ES1N0b3J5U3RpY2tlclR5cGUyKSA9PiB7XG4gIE5ES1N0b3J5U3RpY2tlclR5cGUyW1wiUHVia2V5XCJdID0gXCJwdWJrZXlcIjtcbiAgTkRLU3RvcnlTdGlja2VyVHlwZTJbXCJFdmVudFwiXSA9IFwiZXZlbnRcIjtcbiAgTkRLU3RvcnlTdGlja2VyVHlwZTJbXCJQcm9tcHRcIl0gPSBcInByb21wdFwiO1xuICBOREtTdG9yeVN0aWNrZXJUeXBlMltcIlRleHRcIl0gPSBcInRleHRcIjtcbiAgTkRLU3RvcnlTdGlja2VyVHlwZTJbXCJDb3VudGRvd25cIl0gPSBcImNvdW50ZG93blwiO1xuICByZXR1cm4gTkRLU3RvcnlTdGlja2VyVHlwZTI7XG59KShOREtTdG9yeVN0aWNrZXJUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIHN0clRvUG9zaXRpb24ocG9zaXRpb25TdHIpIHtcbiAgY29uc3QgW3gsIHldID0gcG9zaXRpb25TdHIuc3BsaXQoXCIsXCIpLm1hcChOdW1iZXIpO1xuICByZXR1cm4geyB4LCB5IH07XG59XG5mdW5jdGlvbiBzdHJUb0RpbWVuc2lvbihkaW1lbnNpb25TdHIpIHtcbiAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gZGltZW5zaW9uU3RyLnNwbGl0KFwieFwiKS5tYXAoTnVtYmVyKTtcbiAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCB9O1xufVxudmFyIE5ES1N0b3J5U3RpY2tlciA9IGNsYXNzIF9OREtTdG9yeVN0aWNrZXIge1xuICBzdGF0aWMgVGV4dCA9IFwidGV4dFwiIC8qIFRleHQgKi87XG4gIHN0YXRpYyBQdWJrZXkgPSBcInB1YmtleVwiIC8qIFB1YmtleSAqLztcbiAgc3RhdGljIEV2ZW50ID0gXCJldmVudFwiIC8qIEV2ZW50ICovO1xuICBzdGF0aWMgUHJvbXB0ID0gXCJwcm9tcHRcIiAvKiBQcm9tcHQgKi87XG4gIHN0YXRpYyBDb3VudGRvd24gPSBcImNvdW50ZG93blwiIC8qIENvdW50ZG93biAqLztcbiAgdHlwZTtcbiAgdmFsdWU7XG4gIHBvc2l0aW9uO1xuICBkaW1lbnNpb247XG4gIHByb3BlcnRpZXM7XG4gIGNvbnN0cnVjdG9yKGFyZykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgIGNvbnN0IHRhZyA9IGFyZztcbiAgICAgIGlmICh0YWdbMF0gIT09IFwic3RpY2tlclwiIHx8IHRhZy5sZW5ndGggPCA1KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RpY2tlciB0YWdcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnR5cGUgPSB0YWdbMV07XG4gICAgICB0aGlzLnZhbHVlID0gdGFnWzJdO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IHN0clRvUG9zaXRpb24odGFnWzNdKTtcbiAgICAgIHRoaXMuZGltZW5zaW9uID0gc3RyVG9EaW1lbnNpb24odGFnWzRdKTtcbiAgICAgIGNvbnN0IHByb3BzID0ge307XG4gICAgICBmb3IgKGxldCBpID0gNTsgaSA8IHRhZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHRhZ1tpXS5zcGxpdChcIiBcIik7XG4gICAgICAgIHByb3BzW2tleV0gPSByZXN0LmpvaW4oXCIgXCIpO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnR5cGUgPSBhcmc7XG4gICAgICB0aGlzLnZhbHVlID0gdm9pZCAwO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgdGhpcy5kaW1lbnNpb24gPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb21UYWcodGFnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgX05ES1N0b3J5U3RpY2tlcih0YWcpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGdldCBzdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzPy5zdHlsZTtcbiAgfVxuICBzZXQgc3R5bGUoc3R5bGUpIHtcbiAgICBpZiAoc3R5bGUpIHRoaXMucHJvcGVydGllcyA9IHsgLi4udGhpcy5wcm9wZXJ0aWVzLCBzdHlsZSB9O1xuICAgIGVsc2UgZGVsZXRlIHRoaXMucHJvcGVydGllcz8uc3R5bGU7XG4gIH1cbiAgZ2V0IHJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXM/LnJvdCA/IE51bWJlci5wYXJzZUZsb2F0KHRoaXMucHJvcGVydGllcy5yb3QpIDogdm9pZCAwO1xuICB9XG4gIHNldCByb3RhdGlvbihyb3RhdGlvbikge1xuICAgIGlmIChyb3RhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IC4uLnRoaXMucHJvcGVydGllcywgcm90OiByb3RhdGlvbi50b1N0cmluZygpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnByb3BlcnRpZXM/LnJvdDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgc3RpY2tlciBpcyB2YWxpZC5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgc3RpY2tlciBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzVmFsaWREaW1lbnNpb25zKCkgJiYgdGhpcy5oYXNWYWxpZFBvc2l0aW9uKCk7XG4gIH1cbiAgaGFzVmFsaWREaW1lbnNpb25zID0gKCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5kaW1lbnNpb24ud2lkdGggPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHRoaXMuZGltZW5zaW9uLmhlaWdodCA9PT0gXCJudW1iZXJcIiAmJiAhTnVtYmVyLmlzTmFOKHRoaXMuZGltZW5zaW9uLndpZHRoKSAmJiAhTnVtYmVyLmlzTmFOKHRoaXMuZGltZW5zaW9uLmhlaWdodCk7XG4gIH07XG4gIGhhc1ZhbGlkUG9zaXRpb24gPSAoKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLnBvc2l0aW9uLnggPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHRoaXMucG9zaXRpb24ueSA9PT0gXCJudW1iZXJcIiAmJiAhTnVtYmVyLmlzTmFOKHRoaXMucG9zaXRpb24ueCkgJiYgIU51bWJlci5pc05hTih0aGlzLnBvc2l0aW9uLnkpO1xuICB9O1xuICB0b1RhZygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgY29uc3QgZXJyb3JzID0gW1xuICAgICAgICAhdGhpcy5oYXNWYWxpZERpbWVuc2lvbnMoKSA/IFwiZGltZW5zaW9ucyBpcyBpbnZhbGlkXCIgOiB2b2lkIDAsXG4gICAgICAgICF0aGlzLmhhc1ZhbGlkUG9zaXRpb24oKSA/IFwicG9zaXRpb24gaXMgaW52YWxpZFwiIDogdm9pZCAwXG4gICAgICBdLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGlja2VyOiAke2Vycm9ycy5qb2luKFwiLCBcIil9YCk7XG4gICAgfVxuICAgIGxldCB2YWx1ZTtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSBcImV2ZW50XCIgLyogRXZlbnQgKi86XG4gICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZS50YWdJZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwdWJrZXlcIiAvKiBQdWJrZXkgKi86XG4gICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZS5wdWJrZXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICBjb25zdCB0YWcgPSBbXCJzdGlja2VyXCIsIHRoaXMudHlwZSwgdmFsdWUsIGNvb3JkaW5hdGVzKHRoaXMucG9zaXRpb24pLCBkaW1lbnNpb24odGhpcy5kaW1lbnNpb24pXTtcbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHByb3BWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5wcm9wZXJ0aWVzKSkge1xuICAgICAgICB0YWcucHVzaChgJHtrZXl9ICR7cHJvcFZhbHVlfWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFnO1xuICB9XG59O1xudmFyIE5ES1N0b3J5ID0gY2xhc3MgX05ES1N0b3J5IGV4dGVuZHMgTkRLRXZlbnQge1xuICBzdGF0aWMga2luZCA9IDIzIC8qIFN0b3J5ICovO1xuICBzdGF0aWMga2luZHMgPSBbMjMgLyogU3RvcnkgKi9dO1xuICBfaW1ldGE7XG4gIF9kaW1lbnNpb25zO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAyMyAvKiBTdG9yeSAqLztcbiAgICBpZiAocmF3RXZlbnQpIHtcbiAgICAgIGZvciAoY29uc3QgdGFnIG9mIHJhd0V2ZW50LnRhZ3MpIHtcbiAgICAgICAgc3dpdGNoICh0YWdbMF0pIHtcbiAgICAgICAgICBjYXNlIFwiaW1ldGFcIjpcbiAgICAgICAgICAgIHRoaXMuX2ltZXRhID0gbWFwSW1ldGFUYWcodGFnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJkaW1cIjpcbiAgICAgICAgICAgIHRoaXMuZGltZW5zaW9ucyA9IHN0clRvRGltZW5zaW9uKHRhZ1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIE5ES1N0b3J5IGZyb20gYW4gZXhpc3RpbmcgTkRLRXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBOREtFdmVudCB0byBjcmVhdGUgdGhlIE5ES1N0b3J5IGZyb20uXG4gICAqIEByZXR1cm5zIE5ES1N0b3J5XG4gICAqL1xuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1N0b3J5KGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHN0b3J5IGlzIHZhbGlkIChoYXMgZXhhY3RseSBvbmUgaW1ldGEgdGFnKS5cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiAhIXRoaXMuaW1ldGE7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGZpcnN0IGltZXRhIHRhZyAodGhlcmUgc2hvdWxkIG9ubHkgYmUgb25lKS5cbiAgICovXG4gIGdldCBpbWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW1ldGE7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYSBzaW5nbGUgaW1ldGEgdGFnLCByZXBsYWNpbmcgYW55IGV4aXN0aW5nIG9uZXMuXG4gICAqL1xuICBzZXQgaW1ldGEodGFnKSB7XG4gICAgdGhpcy5faW1ldGEgPSB0YWc7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gdFswXSAhPT0gXCJpbWV0YVwiKTtcbiAgICBpZiAodGFnKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChpbWV0YVRhZ1RvVGFnKHRhZykpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgc3RvcnkgZGltZW5zaW9ucy5cbiAgICpcbiAgICogQHJldHVybnMge05ES1N0b3J5RGltZW5zaW9uIHwgdW5kZWZpbmVkfSAtIFRoZSBzdG9yeSBkaW1lbnNpb25zIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBkaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IGRpbVRhZyA9IHRoaXMudGFnVmFsdWUoXCJkaW1cIik7XG4gICAgaWYgKCFkaW1UYWcpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIHN0clRvRGltZW5zaW9uKGRpbVRhZyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIHN0b3J5IGRpbWVuc2lvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7TkRLU3RvcnlEaW1lbnNpb24gfCB1bmRlZmluZWR9IGRpbWVuc2lvbnMgLSBUaGUgZGltZW5zaW9ucyB0byBzZXQgZm9yIHRoZSBzdG9yeS5cbiAgICovXG4gIHNldCBkaW1lbnNpb25zKGRpbWVuc2lvbnMpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImRpbVwiKTtcbiAgICBpZiAoZGltZW5zaW9ucykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiZGltXCIsIGAke2RpbWVuc2lvbnMud2lkdGh9eCR7ZGltZW5zaW9ucy5oZWlnaHR9YF0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgc3RvcnkgZHVyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9IC0gVGhlIHN0b3J5IGR1cmF0aW9uIGluIHNlY29uZHMgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIGNvbnN0IGR1clRhZyA9IHRoaXMudGFnVmFsdWUoXCJkdXJcIik7XG4gICAgaWYgKCFkdXJUYWcpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIE51bWJlci5wYXJzZUludChkdXJUYWcpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBzdG9yeSBkdXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGR1cmF0aW9uIC0gVGhlIGR1cmF0aW9uIGluIHNlY29uZHMgdG8gc2V0IGZvciB0aGUgc3RvcnkuXG4gICAqL1xuICBzZXQgZHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImR1clwiKTtcbiAgICBpZiAoZHVyYXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiZHVyXCIsIGR1cmF0aW9uLnRvU3RyaW5nKCldKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYWxsIHN0aWNrZXJzIGZyb20gdGhlIHN0b3J5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7TkRLU3RvcnlTdGlja2VyW119IC0gQXJyYXkgb2Ygc3RpY2tlcnMgaW4gdGhlIHN0b3J5LlxuICAgKi9cbiAgZ2V0IHN0aWNrZXJzKCkge1xuICAgIGNvbnN0IHN0aWNrZXJzID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICBpZiAodGFnWzBdICE9PSBcInN0aWNrZXJcIiB8fCB0YWcubGVuZ3RoIDwgNSkgY29udGludWU7XG4gICAgICBjb25zdCBzdGlja2VyID0gTkRLU3RvcnlTdGlja2VyLmZyb21UYWcodGFnKTtcbiAgICAgIGlmIChzdGlja2VyKSBzdGlja2Vycy5wdXNoKHN0aWNrZXIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RpY2tlcnM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBzdGlja2VyIHRvIHRoZSBzdG9yeS5cbiAgICpcbiAgICogQHBhcmFtIHtOREtTdG9yeVN0aWNrZXJ8U3RvcnlTdGlja2VyfSBzdGlja2VyIC0gVGhlIHN0aWNrZXIgdG8gYWRkLlxuICAgKi9cbiAgYWRkU3RpY2tlcihzdGlja2VyKSB7XG4gICAgbGV0IHN0aWNrZXJUb0FkZDtcbiAgICBpZiAoc3RpY2tlciBpbnN0YW5jZW9mIE5ES1N0b3J5U3RpY2tlcikge1xuICAgICAgc3RpY2tlclRvQWRkID0gc3RpY2tlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFnID0gW1xuICAgICAgICBcInN0aWNrZXJcIixcbiAgICAgICAgc3RpY2tlci50eXBlLFxuICAgICAgICB0eXBlb2Ygc3RpY2tlci52YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHN0aWNrZXIudmFsdWUgOiBcIlwiLFxuICAgICAgICBjb29yZGluYXRlcyhzdGlja2VyLnBvc2l0aW9uKSxcbiAgICAgICAgZGltZW5zaW9uKHN0aWNrZXIuZGltZW5zaW9uKVxuICAgICAgXTtcbiAgICAgIGlmIChzdGlja2VyLnByb3BlcnRpZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc3RpY2tlci5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgIHRhZy5wdXNoKGAke2tleX0gJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RpY2tlclRvQWRkID0gbmV3IE5ES1N0b3J5U3RpY2tlcih0YWcpO1xuICAgICAgc3RpY2tlclRvQWRkLnZhbHVlID0gc3RpY2tlci52YWx1ZTtcbiAgICB9XG4gICAgaWYgKHN0aWNrZXJUb0FkZC50eXBlID09PSBcInB1YmtleVwiIC8qIFB1YmtleSAqLykge1xuICAgICAgdGhpcy50YWcoc3RpY2tlclRvQWRkLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHN0aWNrZXJUb0FkZC50eXBlID09PSBcImV2ZW50XCIgLyogRXZlbnQgKi8pIHtcbiAgICAgIHRoaXMudGFnKHN0aWNrZXJUb0FkZC52YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMudGFncy5wdXNoKHN0aWNrZXJUb0FkZC50b1RhZygpKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhIHN0aWNrZXIgZnJvbSB0aGUgc3RvcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgc3RpY2tlciB0byByZW1vdmUuXG4gICAqL1xuICByZW1vdmVTdGlja2VyKGluZGV4KSB7XG4gICAgY29uc3Qgc3RpY2tlcnMgPSB0aGlzLnN0aWNrZXJzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc3RpY2tlcnMubGVuZ3RoKSByZXR1cm47XG4gICAgbGV0IHN0aWNrZXJDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLnRhZ3NbaV1bMF0gPT09IFwic3RpY2tlclwiKSB7XG4gICAgICAgIGlmIChzdGlja2VyQ291bnQgPT09IGluZGV4KSB7XG4gICAgICAgICAgdGhpcy50YWdzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGlja2VyQ291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgY29vcmRpbmF0ZXMgPSAocG9zaXRpb24pID0+IGAke3Bvc2l0aW9uLnh9LCR7cG9zaXRpb24ueX1gO1xudmFyIGRpbWVuc2lvbiA9IChkaW1lbnNpb24yKSA9PiBgJHtkaW1lbnNpb24yLndpZHRofXgke2RpbWVuc2lvbjIuaGVpZ2h0fWA7XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc3Vic2NyaXB0aW9ucy9hbW91bnQudHNcbnZhciBwb3NzaWJsZUludGVydmFsRnJlcXVlbmNpZXMgPSBbXG4gIFwiZGFpbHlcIixcbiAgXCJ3ZWVrbHlcIixcbiAgXCJtb250aGx5XCIsXG4gIFwicXVhcnRlcmx5XCIsXG4gIFwieWVhcmx5XCJcbl07XG5mdW5jdGlvbiBjYWxjdWxhdGVUZXJtRHVyYXRpb25JblNlY29uZHModGVybSkge1xuICBzd2l0Y2ggKHRlcm0pIHtcbiAgICBjYXNlIFwiZGFpbHlcIjpcbiAgICAgIHJldHVybiAyNCAqIDYwICogNjA7XG4gICAgY2FzZSBcIndlZWtseVwiOlxuICAgICAgcmV0dXJuIDcgKiAyNCAqIDYwICogNjA7XG4gICAgY2FzZSBcIm1vbnRobHlcIjpcbiAgICAgIHJldHVybiAzMCAqIDI0ICogNjAgKiA2MDtcbiAgICBjYXNlIFwicXVhcnRlcmx5XCI6XG4gICAgICByZXR1cm4gMyAqIDMwICogMjQgKiA2MCAqIDYwO1xuICAgIGNhc2UgXCJ5ZWFybHlcIjpcbiAgICAgIHJldHVybiAzNjUgKiAyNCAqIDYwICogNjA7XG4gIH1cbn1cbmZ1bmN0aW9uIG5ld0Ftb3VudChhbW91bnQsIGN1cnJlbmN5LCB0ZXJtKSB7XG4gIHJldHVybiBbXCJhbW91bnRcIiwgYW1vdW50LnRvU3RyaW5nKCksIGN1cnJlbmN5LCB0ZXJtXTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGFnVG9TdWJzY3JpcHRpb25BbW91bnQodGFnKSB7XG4gIGNvbnN0IGFtb3VudCA9IE51bWJlci5wYXJzZUludCh0YWdbMV0pO1xuICBpZiAoTnVtYmVyLmlzTmFOKGFtb3VudCkgfHwgYW1vdW50ID09PSB2b2lkIDAgfHwgYW1vdW50ID09PSBudWxsIHx8IGFtb3VudCA8PSAwKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBjdXJyZW5jeSA9IHRhZ1syXTtcbiAgaWYgKGN1cnJlbmN5ID09PSB2b2lkIDAgfHwgY3VycmVuY3kgPT09IFwiXCIpIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IHRlcm0gPSB0YWdbM107XG4gIGlmICh0ZXJtID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7XG4gIGlmICghcG9zc2libGVJbnRlcnZhbEZyZXF1ZW5jaWVzLmluY2x1ZGVzKHRlcm0pKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4ge1xuICAgIGFtb3VudCxcbiAgICBjdXJyZW5jeSxcbiAgICB0ZXJtXG4gIH07XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc3Vic2NyaXB0aW9ucy90aWVyLnRzXG52YXIgTkRLU3Vic2NyaXB0aW9uVGllciA9IGNsYXNzIF9OREtTdWJzY3JpcHRpb25UaWVyIGV4dGVuZHMgTkRLQXJ0aWNsZSB7XG4gIHN0YXRpYyBraW5kID0gMzcwMDEgLyogU3Vic2NyaXB0aW9uVGllciAqLztcbiAgc3RhdGljIGtpbmRzID0gWzM3MDAxIC8qIFN1YnNjcmlwdGlvblRpZXIgKi9dO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgY29uc3QgayA9IHJhd0V2ZW50Py5raW5kID8/IDM3MDAxIC8qIFN1YnNjcmlwdGlvblRpZXIgKi87XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID0gaztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBOREtTdWJzY3JpcHRpb25UaWVyIGZyb20gYW4gZXZlbnRcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEByZXR1cm5zIE5ES1N1YnNjcmlwdGlvblRpZXJcbiAgICovXG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLU3Vic2NyaXB0aW9uVGllcihldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwZXJrcyBmb3IgdGhpcyB0aWVyXG4gICAqL1xuICBnZXQgcGVya3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicGVya1wiKS5tYXAoKHRhZykgPT4gdGFnWzFdKS5maWx0ZXIoKHBlcmspID0+IHBlcmsgIT09IHZvaWQgMCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBwZXJrIHRvIHRoaXMgdGllclxuICAgKi9cbiAgYWRkUGVyayhwZXJrKSB7XG4gICAgdGhpcy50YWdzLnB1c2goW1wicGVya1wiLCBwZXJrXSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFtb3VudCBmb3IgdGhpcyB0aWVyXG4gICAqL1xuICBnZXQgYW1vdW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhbW91bnRcIikubWFwKCh0YWcpID0+IHBhcnNlVGFnVG9TdWJzY3JpcHRpb25BbW91bnQodGFnKSkuZmlsdGVyKChhKSA9PiBhICE9PSB2b2lkIDApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIGFtb3VudCB0byB0aGlzIHRpZXJcbiAgICogQHBhcmFtIGFtb3VudCBBbW91bnQgaW4gdGhlIHNtYWxsZXN0IHVuaXQgb2YgdGhlIGN1cnJlbmN5IChlLmcuIGNlbnRzLCBtc2F0cylcbiAgICogQHBhcmFtIGN1cnJlbmN5IEN1cnJlbmN5IGNvZGUuIFVzZSBtc2F0IGZvciBtaWxsaXNhdG9zaGlzXG4gICAqIEBwYXJhbSB0ZXJtIE9uZSBvZiBkYWlseSwgd2Vla2x5LCBtb250aGx5LCBxdWFydGVybHksIHllYXJseVxuICAgKi9cbiAgYWRkQW1vdW50KGFtb3VudCwgY3VycmVuY3ksIHRlcm0pIHtcbiAgICB0aGlzLnRhZ3MucHVzaChuZXdBbW91bnQoYW1vdW50LCBjdXJyZW5jeSwgdGVybSkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgcmVsYXkgd2hlcmUgY29udGVudCByZWxhdGVkIHRvIHRoaXMgdGllciBjYW4gYmUgZm91bmRcbiAgICogQHBhcmFtIHJlbGF5VXJsIFVSTCBvZiB0aGUgcmVsYXlcbiAgICovXG4gIHNldCByZWxheVVybChyZWxheVVybCkge1xuICAgIHRoaXMudGFncy5wdXNoKFtcInJcIiwgcmVsYXlVcmxdKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVsYXkgVVJMcyBmb3IgdGhpcyB0aWVyXG4gICAqL1xuICBnZXQgcmVsYXlVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVGFncyhcInJcIikubWFwKCh0YWcpID0+IHRhZ1sxXSkuZmlsdGVyKChyZWxheSkgPT4gcmVsYXkgIT09IHZvaWQgMCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZlcmlmaWVyIHB1YmtleSBmb3IgdGhpcyB0aWVyLiBUaGlzIGlzIHRoZSBwdWJrZXkgdGhhdCB3aWxsIGdlbmVyYXRlXG4gICAqIHN1YnNjcmlwdGlvbiBwYXltZW50IHJlY2VpcHRzXG4gICAqL1xuICBnZXQgdmVyaWZpZXJQdWJrZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJwXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2ZXJpZmllciBwdWJrZXkgZm9yIHRoaXMgdGllci5cbiAgICovXG4gIHNldCB2ZXJpZmllclB1YmtleShwdWJrZXkpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInBcIik7XG4gICAgaWYgKHB1YmtleSkgdGhpcy50YWdzLnB1c2goW1wicFwiLCBwdWJrZXldKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgdGllciBpcyB2YWxpZFxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGl0bGUgIT09IHZvaWQgMCAmJiAvLyBNdXN0IGhhdmUgYSB0aXRsZVxuICAgIHRoaXMuYW1vdW50cy5sZW5ndGggPiAwO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3ZpZGVvLnRzXG52YXIgTkRLVmlkZW8gPSBjbGFzcyBfTkRLVmlkZW8gZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMjEgLyogVmlkZW8gKi87XG4gIHN0YXRpYyBraW5kcyA9IFszNDIzNSAvKiBIb3Jpem9udGFsVmlkZW8gKi8sIDM0MjM2IC8qIFZlcnRpY2FsVmlkZW8gKi8sIDIyIC8qIFNob3J0VmlkZW8gKi8sIDIxIC8qIFZpZGVvICovXTtcbiAgX2ltZXRhcztcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOREtBcnRpY2xlIGZyb20gYW4gZXhpc3RpbmcgTkRLRXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBOREtFdmVudCB0byBjcmVhdGUgdGhlIE5ES0FydGljbGUgZnJvbS5cbiAgICogQHJldHVybnMgTkRLQXJ0aWNsZVxuICAgKi9cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtWaWRlbyhldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRpdGxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBhcnRpY2xlIHRpdGxlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRpdGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gdGl0bGUgLSBUaGUgdGl0bGUgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZS5cbiAgICovXG4gIHNldCB0aXRsZSh0aXRsZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHRpdGxlKSB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB0aXRsZV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRodW1ibmFpbC5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gLSBUaGUgYXJ0aWNsZSB0aHVtYm5haWwgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHRodW1ibmFpbCgpIHtcbiAgICBsZXQgdGh1bWJuYWlsO1xuICAgIGlmICh0aGlzLmltZXRhcyAmJiB0aGlzLmltZXRhcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHVtYm5haWwgPSB0aGlzLmltZXRhc1swXS5pbWFnZT8uWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdGh1bWJuYWlsID8/IHRoaXMudGFnVmFsdWUoXCJ0aHVtYlwiKTtcbiAgfVxuICBnZXQgaW1ldGFzKCkge1xuICAgIGlmICh0aGlzLl9pbWV0YXMpIHJldHVybiB0aGlzLl9pbWV0YXM7XG4gICAgdGhpcy5faW1ldGFzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiaW1ldGFcIikubWFwKG1hcEltZXRhVGFnKTtcbiAgICByZXR1cm4gdGhpcy5faW1ldGFzO1xuICB9XG4gIHNldCBpbWV0YXModGFncykge1xuICAgIHRoaXMuX2ltZXRhcyA9IHRhZ3M7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwiaW1ldGFcIik7XG4gICAgdGhpcy50YWdzLnB1c2goLi4udGFncy5tYXAoaW1ldGFUYWdUb1RhZykpO1xuICB9XG4gIGdldCB1cmwoKSB7XG4gICAgaWYgKHRoaXMuaW1ldGFzICYmIHRoaXMuaW1ldGFzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmltZXRhc1swXS51cmw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwidXJsXCIpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlJ3MgcHVibGljYXRpb24gdGltZXN0YW1wLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfSAtIFRoZSBVbml4IHRpbWVzdGFtcCBvZiB3aGVuIHRoZSBhcnRpY2xlIHdhcyBwdWJsaXNoZWQgb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHB1Ymxpc2hlZF9hdCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwicHVibGlzaGVkX2F0XCIpO1xuICAgIGlmICh0YWcpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQodGFnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvbnRlbnQgdGFncyBmb3IgdGhlIGFydGljbGUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGZpcnN0IGNoZWNrcyBhbmQgc2V0cyB0aGUgcHVibGljYXRpb24gZGF0ZSBpZiBub3QgYXZhaWxhYmxlLFxuICAgKiBhbmQgdGhlbiBnZW5lcmF0ZXMgY29udGVudCB0YWdzIGJhc2VkIG9uIHRoZSBiYXNlIE5ES0V2ZW50IGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gLSBUaGUgZ2VuZXJhdGVkIGNvbnRlbnQgdGFncy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlVGFncygpIHtcbiAgICBzdXBlci5nZW5lcmF0ZVRhZ3MoKTtcbiAgICBpZiAoIXRoaXMua2luZCkge1xuICAgICAgaWYgKHRoaXMuaW1ldGFzPy5bMF0/LmRpbSkge1xuICAgICAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLmltZXRhc1swXS5kaW0uc3BsaXQoXCJ4XCIpO1xuICAgICAgICBjb25zdCBpc1BvcnRyYWl0ID0gd2lkdGggJiYgaGVpZ2h0ICYmIE51bWJlci5wYXJzZUludCh3aWR0aCkgPCBOdW1iZXIucGFyc2VJbnQoaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgaXNTaG9ydCA9IHRoaXMuZHVyYXRpb24gJiYgdGhpcy5kdXJhdGlvbiA8IDEyMDtcbiAgICAgICAgaWYgKGlzU2hvcnQgJiYgaXNQb3J0cmFpdCkgdGhpcy5raW5kID0gMjIgLyogU2hvcnRWaWRlbyAqLztcbiAgICAgICAgZWxzZSB0aGlzLmtpbmQgPSAyMSAvKiBWaWRlbyAqLztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICB9XG4gIGdldCBkdXJhdGlvbigpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwiZHVyYXRpb25cIik7XG4gICAgaWYgKHRhZykge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludCh0YWcpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSB2aWRlbydzIGR1cmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBkdXJhdGlvbiAtIFRoZSBkdXJhdGlvbiB0byBzZXQgZm9yIHRoZSB2aWRlbyAoaW4gc2Vjb25kcylcbiAgICovXG4gIHNldCBkdXJhdGlvbihkdXIpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImR1cmF0aW9uXCIpO1xuICAgIGlmIChkdXIgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiZHVyYXRpb25cIiwgTWF0aC5mbG9vcihkdXIpLnRvU3RyaW5nKCldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvd2lraS50c1xudmFyIE5ES1dpa2kgPSBjbGFzcyBfTkRLV2lraSBleHRlbmRzIE5ES0FydGljbGUge1xuICBzdGF0aWMga2luZCA9IDMwODE4IC8qIFdpa2kgKi87XG4gIHN0YXRpYyBraW5kcyA9IFszMDgxOCAvKiBXaWtpICovXTtcbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtXaWtpKGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgZ2V0IGlzRGVmZXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNUYWcoXCJhXCIsIFwiZGVmZXJcIik7XG4gIH1cbiAgZ2V0IGRlZmVyZWRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImFcIiwgXCJkZWZlclwiKTtcbiAgfVxuICAvKipcbiAgICogRGVmZXJzIHRoZSBhdXRob3IncyB3aWtpIGV2ZW50IHRvIGFub3RoZXIgd2lraSBldmVudC5cbiAgICpcbiAgICogV2lraS1ldmVudHMgY2FuIHRhZyBvdGhlciB3aWtpLWV2ZW50cyB3aXRoIGEgYGRlZmVyYCBtYXJrZXIgdG8gaW5kaWNhdGUgdGhhdCBpdCBjb25zaWRlcnMgc29tZW9uZSBlbHNlJ3MgZW50cnkgYXMgYSBcImJldHRlclwiIHZlcnNpb24gb2YgaXRzZWxmLiBJZiB1c2luZyBhIGBkZWZlcmAgbWFya2VyIGJvdGggYGFgIGFuZCBgZWAgdGFncyBTSE9VTEQgYmUgdXNlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbXlXaWtpLmRlZmVyID0gYmV0dGVyV2lraUVudHJ5T25UaGVTYW1lVG9waWM7XG4gICAqIG15V2lraS5wdWJsaXNoUmVwbGFjZWFibGUoKVxuICAgKi9cbiAgc2V0IGRlZmVyKGRlZmVyZWRUbykge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiYVwiLCBcImRlZmVyXCIpO1xuICAgIHRoaXMudGFnKGRlZmVyZWRUbywgXCJkZWZlclwiKTtcbiAgfVxufTtcbnZhciBOREtXaWtpTWVyZ2VSZXF1ZXN0ID0gY2xhc3MgX05ES1dpa2lNZXJnZVJlcXVlc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gODE4IC8qIFdpa2lNZXJnZVJlcXVlc3QgKi87XG4gIHN0YXRpYyBraW5kcyA9IFs4MTggLyogV2lraU1lcmdlUmVxdWVzdCAqL107XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLV2lraU1lcmdlUmVxdWVzdChldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IElEICg8a2luZDpwdWJrZXk6ZC10YWc+KSBvZiB0aGUgd2lraSBldmVudCB0byBtZXJnZSBpbnRvLlxuICAgKi9cbiAgZ2V0IHRhcmdldElkKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiYVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGFyZ2V0IElEICg8a2luZDpwdWJrZXk6ZC10YWc+KSBvZiB0aGUgd2lraSBldmVudCB0byBtZXJnZSBpbnRvLlxuICAgKi9cbiAgc2V0IHRhcmdldCh0YXJnZXRFdmVudCkge1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4ge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJhXCIpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgJiYgdGFnWzNdICE9PSBcInNvdXJjZVwiKSByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICB0aGlzLnRhZyh0YXJnZXRFdmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzb3VyY2UgSUQgb2YgdGhlIHdpa2kgZXZlbnQgdG8gbWVyZ2UgZnJvbS5cbiAgICovXG4gIGdldCBzb3VyY2VJZCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImVcIiwgXCJzb3VyY2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGV2ZW50IHdlIGFyZSBhc2tpbmcgdG8gZ2V0IG1lcmdlZCBpbnRvIHRoZSB0YXJnZXQuXG4gICAqL1xuICBzZXQgc291cmNlKHNvdXJjZUV2ZW50KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJlXCIsIFwic291cmNlXCIpO1xuICAgIHRoaXMudGFnKHNvdXJjZUV2ZW50LCBcInNvdXJjZVwiLCBmYWxzZSwgXCJlXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL3dyYXAudHNcbmZ1bmN0aW9uIHdyYXBFdmVudChldmVudCkge1xuICBjb25zdCBldmVudFdyYXBwaW5nTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBrbGFzczIgb2YgW1xuICAgIE5ES0ltYWdlLFxuICAgIE5ES1ZpZGVvLFxuICAgIE5ES0Nhc2h1TWludExpc3QsXG4gICAgTkRLQXJ0aWNsZSxcbiAgICBOREtIaWdobGlnaHQsXG4gICAgTkRLV2lraSxcbiAgICBOREtOdXR6YXAsXG4gICAgTkRLU2ltcGxlR3JvdXBNZW1iZXJMaXN0LFxuICAgIE5ES1NpbXBsZUdyb3VwTWV0YWRhdGEsXG4gICAgTkRLU3Vic2NyaXB0aW9uVGllcixcbiAgICBOREtDYXNodVRva2VuLFxuICAgIE5ES0xpc3QsXG4gICAgTkRLU3RvcnlcbiAgXSkge1xuICAgIGZvciAoY29uc3Qga2luZCBvZiBrbGFzczIua2luZHMpIHtcbiAgICAgIGV2ZW50V3JhcHBpbmdNYXAuc2V0KGtpbmQsIGtsYXNzMik7XG4gICAgfVxuICB9XG4gIGNvbnN0IGtsYXNzID0gZXZlbnRXcmFwcGluZ01hcC5nZXQoZXZlbnQua2luZCk7XG4gIGlmIChrbGFzcykgcmV0dXJuIGtsYXNzLmZyb20oZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8vIHNyYy9zdWJzY3JpcHRpb24vdXRpbHMudHNcbmltcG9ydCB7IG5pcDE5IGFzIG5pcDE5NCB9IGZyb20gXCJub3N0ci10b29sc1wiO1xudmFyIE1BWF9TVUJJRF9MRU5HVEggPSAyMDtcbmZ1bmN0aW9uIHF1ZXJ5RnVsbHlGaWxsZWQoc3Vic2NyaXB0aW9uKSB7XG4gIGlmIChmaWx0ZXJJbmNsdWRlc0lkcyhzdWJzY3JpcHRpb24uZmlsdGVyKSkge1xuICAgIGlmIChyZXN1bHRIYXNBbGxSZXF1ZXN0ZWRJZHMoc3Vic2NyaXB0aW9uKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVGaWx0ZXIoZmlsdGVyMSwgZmlsdGVyMikge1xuICBpZiAoT2JqZWN0LmtleXMoZmlsdGVyMSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhmaWx0ZXIyKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmlsdGVyMSkpIHtcbiAgICBjb25zdCB2YWx1ZXNJbkZpbHRlcjIgPSBmaWx0ZXIyW2tleV07XG4gICAgaWYgKCF2YWx1ZXNJbkZpbHRlcjIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZXNJbkZpbHRlcjIpKSB7XG4gICAgICBjb25zdCB2ID0gdmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlSW5GaWx0ZXIyIG9mIHZhbHVlc0luRmlsdGVyMikge1xuICAgICAgICBjb25zdCB2YWwgPSB2YWx1ZUluRmlsdGVyMjtcbiAgICAgICAgaWYgKCF2LmluY2x1ZGVzKHZhbCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlc0luRmlsdGVyMiAhPT0gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBmaWx0ZXJJbmNsdWRlc0lkcyhmaWx0ZXIpIHtcbiAgcmV0dXJuICEhZmlsdGVyLmlkcztcbn1cbmZ1bmN0aW9uIHJlc3VsdEhhc0FsbFJlcXVlc3RlZElkcyhzdWJzY3JpcHRpb24pIHtcbiAgY29uc3QgaWRzID0gc3Vic2NyaXB0aW9uLmZpbHRlci5pZHM7XG4gIHJldHVybiAhIWlkcyAmJiBpZHMubGVuZ3RoID09PSBzdWJzY3JpcHRpb24uZXZlbnRGaXJzdFNlZW4uc2l6ZTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU3ViSWQoc3Vic2NyaXB0aW9ucywgZmlsdGVycykge1xuICBjb25zdCBzdWJJZHMgPSBzdWJzY3JpcHRpb25zLm1hcCgoc3ViKSA9PiBzdWIuc3ViSWQpLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3Qgc3ViSWRQYXJ0cyA9IFtdO1xuICBjb25zdCBmaWx0ZXJOb25LaW5kS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGZpbHRlcktpbmRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgaWYgKHN1Yklkcy5sZW5ndGggPiAwKSB7XG4gICAgc3ViSWRQYXJ0cy5wdXNoKEFycmF5LmZyb20obmV3IFNldChzdWJJZHMpKS5qb2luKFwiLFwiKSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgZmlsdGVycykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZmlsdGVyKSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcImtpbmRzXCIpIHtcbiAgICAgICAgICBmaWx0ZXIua2luZHM/LmZvckVhY2goKGspID0+IGZpbHRlcktpbmRzLmFkZChrKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsdGVyTm9uS2luZEtleXMuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpbHRlcktpbmRzLnNpemUgPiAwKSB7XG4gICAgICBzdWJJZFBhcnRzLnB1c2goYGtpbmRzOiR7QXJyYXkuZnJvbShmaWx0ZXJLaW5kcykuam9pbihcIixcIil9YCk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJOb25LaW5kS2V5cy5zaXplID4gMCkge1xuICAgICAgc3ViSWRQYXJ0cy5wdXNoKEFycmF5LmZyb20oZmlsdGVyTm9uS2luZEtleXMpLmpvaW4oXCIsXCIpKTtcbiAgICB9XG4gIH1cbiAgbGV0IHN1YklkID0gc3ViSWRQYXJ0cy5qb2luKFwiLVwiKTtcbiAgaWYgKHN1YklkLmxlbmd0aCA+IE1BWF9TVUJJRF9MRU5HVEgpIHN1YklkID0gc3ViSWQuc3Vic3RyaW5nKDAsIE1BWF9TVUJJRF9MRU5HVEgpO1xuICBzdWJJZCArPSBgLSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogOTk5KS50b1N0cmluZygpfWA7XG4gIHJldHVybiBzdWJJZDtcbn1cbmZ1bmN0aW9uIGZpbHRlckZvckV2ZW50c1RhZ2dpbmdJZChpZCkge1xuICB0cnkge1xuICAgIGNvbnN0IGRlY29kZWQgPSBuaXAxOTQuZGVjb2RlKGlkKTtcbiAgICBzd2l0Y2ggKGRlY29kZWQudHlwZSkge1xuICAgICAgY2FzZSBcIm5hZGRyXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgXCIjYVwiOiBbYCR7ZGVjb2RlZC5kYXRhLmtpbmR9OiR7ZGVjb2RlZC5kYXRhLnB1YmtleX06JHtkZWNvZGVkLmRhdGEuaWRlbnRpZmllcn1gXVxuICAgICAgICB9O1xuICAgICAgY2FzZSBcIm5ldmVudFwiOlxuICAgICAgICByZXR1cm4geyBcIiNlXCI6IFtkZWNvZGVkLmRhdGEuaWRdIH07XG4gICAgICBjYXNlIFwibm90ZVwiOlxuICAgICAgICByZXR1cm4geyBcIiNlXCI6IFtkZWNvZGVkLmRhdGFdIH07XG4gICAgICBjYXNlIFwibnByb2ZpbGVcIjpcbiAgICAgICAgcmV0dXJuIHsgXCIjcFwiOiBbZGVjb2RlZC5kYXRhLnB1YmtleV0gfTtcbiAgICAgIGNhc2UgXCJucHViXCI6XG4gICAgICAgIHJldHVybiB7IFwiI3BcIjogW2RlY29kZWQuZGF0YV0gfTtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICB9XG59XG5mdW5jdGlvbiBmaWx0ZXJBbmRSZWxheVNldEZyb21CZWNoMzIoYmVjaGUyLCBuZGspIHtcbiAgY29uc3QgZmlsdGVyID0gZmlsdGVyRnJvbUlkKGJlY2hlMik7XG4gIGNvbnN0IHJlbGF5cyA9IHJlbGF5c0Zyb21CZWNoMzIoYmVjaGUyLCBuZGspO1xuICBpZiAocmVsYXlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHsgZmlsdGVyIH07XG4gIHJldHVybiB7XG4gICAgZmlsdGVyLFxuICAgIHJlbGF5U2V0OiBuZXcgTkRLUmVsYXlTZXQobmV3IFNldChyZWxheXMpLCBuZGspXG4gIH07XG59XG5mdW5jdGlvbiBmaWx0ZXJGcm9tSWQoaWQpIHtcbiAgbGV0IGRlY29kZWQ7XG4gIGlmIChpZC5tYXRjaChOSVAzM19BX1JFR0VYKSkge1xuICAgIGNvbnN0IFtraW5kLCBwdWJrZXksIGlkZW50aWZpZXJdID0gaWQuc3BsaXQoXCI6XCIpO1xuICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgIGF1dGhvcnM6IFtwdWJrZXldLFxuICAgICAga2luZHM6IFtOdW1iZXIucGFyc2VJbnQoa2luZCldXG4gICAgfTtcbiAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgZmlsdGVyW1wiI2RcIl0gPSBbaWRlbnRpZmllcl07XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXI7XG4gIH1cbiAgaWYgKGlkLm1hdGNoKEJFQ0gzMl9SRUdFWCkpIHtcbiAgICB0cnkge1xuICAgICAgZGVjb2RlZCA9IG5pcDE5NC5kZWNvZGUoaWQpO1xuICAgICAgc3dpdGNoIChkZWNvZGVkLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm5ldmVudFwiOiB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyID0geyBpZHM6IFtkZWNvZGVkLmRhdGEuaWRdIH07XG4gICAgICAgICAgaWYgKGRlY29kZWQuZGF0YS5hdXRob3IpIGZpbHRlci5hdXRob3JzID0gW2RlY29kZWQuZGF0YS5hdXRob3JdO1xuICAgICAgICAgIGlmIChkZWNvZGVkLmRhdGEua2luZCkgZmlsdGVyLmtpbmRzID0gW2RlY29kZWQuZGF0YS5raW5kXTtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICAgICAgcmV0dXJuIHsgaWRzOiBbZGVjb2RlZC5kYXRhXSB9O1xuICAgICAgICBjYXNlIFwibmFkZHJcIjoge1xuICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICAgIGF1dGhvcnM6IFtkZWNvZGVkLmRhdGEucHVia2V5XSxcbiAgICAgICAgICAgIGtpbmRzOiBbZGVjb2RlZC5kYXRhLmtpbmRdXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoZGVjb2RlZC5kYXRhLmlkZW50aWZpZXIpIGZpbHRlcltcIiNkXCJdID0gW2RlY29kZWQuZGF0YS5pZGVudGlmaWVyXTtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRlY29kaW5nXCIsIGlkLCBlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgaWRzOiBbaWRdIH07XG59XG5mdW5jdGlvbiBpc05pcDMzQVZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5tYXRjaChOSVAzM19BX1JFR0VYKSAhPT0gbnVsbDtcbn1cbnZhciBOSVAzM19BX1JFR0VYID0gL14oXFxkKyk6KFswLTlBLUZhLWZdKykoPzo6KC4qKSk/JC87XG52YXIgQkVDSDMyX1JFR0VYID0gL15uKGV2ZW50fG90ZXxwcm9maWxlfHB1YnxhZGRyKTFbXFxkXFx3XSskLztcbmZ1bmN0aW9uIHJlbGF5c0Zyb21CZWNoMzIoYmVjaDMyMiwgbmRrKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IG5pcDE5NC5kZWNvZGUoYmVjaDMyMik7XG4gICAgaWYgKFtcIm5hZGRyXCIsIFwibmV2ZW50XCJdLmluY2x1ZGVzKGRlY29kZWQ/LnR5cGUpKSB7XG4gICAgICBjb25zdCBkYXRhID0gZGVjb2RlZC5kYXRhO1xuICAgICAgaWYgKGRhdGE/LnJlbGF5cykge1xuICAgICAgICByZXR1cm4gZGF0YS5yZWxheXMubWFwKChyKSA9PiBuZXcgTkRLUmVsYXkociwgbmRrLnJlbGF5QXV0aERlZmF1bHRQb2xpY3ksIG5kaykpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoX2UpIHtcbiAgfVxuICByZXR1cm4gW107XG59XG5cbi8vIHNyYy9zdWJzY3JpcHRpb24vaW5kZXgudHNcbnZhciBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlID0gLyogQF9fUFVSRV9fICovICgoTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTIpID0+IHtcbiAgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTJbXCJPTkxZX0NBQ0hFXCJdID0gXCJPTkxZX0NBQ0hFXCI7XG4gIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UyW1wiQ0FDSEVfRklSU1RcIl0gPSBcIkNBQ0hFX0ZJUlNUXCI7XG4gIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UyW1wiUEFSQUxMRUxcIl0gPSBcIlBBUkFMTEVMXCI7XG4gIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UyW1wiT05MWV9SRUxBWVwiXSA9IFwiT05MWV9SRUxBWVwiO1xuICByZXR1cm4gTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTI7XG59KShOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlIHx8IHt9KTtcbnZhciBkZWZhdWx0T3B0cyA9IHtcbiAgY2xvc2VPbkVvc2U6IGZhbHNlLFxuICBjYWNoZVVzYWdlOiBcIkNBQ0hFX0ZJUlNUXCIgLyogQ0FDSEVfRklSU1QgKi8sXG4gIGRvbnRTYXZlVG9DYWNoZTogZmFsc2UsXG4gIGdyb3VwYWJsZTogdHJ1ZSxcbiAgZ3JvdXBhYmxlRGVsYXk6IDEwMCxcbiAgZ3JvdXBhYmxlRGVsYXlUeXBlOiBcImF0LW1vc3RcIixcbiAgY2FjaGVVbmNvbnN0cmFpbkZpbHRlcjogW1wibGltaXRcIiwgXCJzaW5jZVwiLCBcInVudGlsXCJdXG59O1xudmFyIE5ES1N1YnNjcmlwdGlvbiA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyNCB7XG4gIHN1YklkO1xuICBmaWx0ZXJzO1xuICBvcHRzO1xuICBwb29sO1xuICBza2lwVmVyaWZpY2F0aW9uID0gZmFsc2U7XG4gIHNraXBWYWxpZGF0aW9uID0gZmFsc2U7XG4gIC8qKlxuICAgKiBUcmFja3MgdGhlIGZpbHRlcnMgYXMgdGhleSBhcmUgZXhlY3V0ZWQgb24gZWFjaCByZWxheVxuICAgKi9cbiAgcmVsYXlGaWx0ZXJzO1xuICByZWxheVNldDtcbiAgbmRrO1xuICBkZWJ1ZztcbiAgLyoqXG4gICAqIEV2ZW50cyB0aGF0IGhhdmUgYmVlbiBzZWVuIGJ5IHRoZSBzdWJzY3JpcHRpb24sIHdpdGggdGhlIHRpbWUgdGhleSB3ZXJlIGZpcnN0IHNlZW4uXG4gICAqL1xuICBldmVudEZpcnN0U2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8qKlxuICAgKiBSZWxheXMgdGhhdCBoYXZlIHNlbnQgYW4gRU9TRS5cbiAgICovXG4gIGVvc2VzU2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIC8qKlxuICAgKiBUaGUgdGltZSB0aGUgbGFzdCBldmVudCB3YXMgcmVjZWl2ZWQgYnkgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICogVGhpcyBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB3aGVuIEVPU0Ugc2hvdWxkIGJlIGVtaXR0ZWQuXG4gICAqL1xuICBsYXN0RXZlbnRSZWNlaXZlZEF0O1xuICAvKipcbiAgICogVGhlIG1vc3QgcmVjZW50IGV2ZW50IHRpbWVzdGFtcCBmcm9tIGNhY2hlIHJlc3VsdHMuXG4gICAqIFRoaXMgaXMgdXNlZCBmb3IgYWRkU2luY2VGcm9tQ2FjaGUgZnVuY3Rpb25hbGl0eS5cbiAgICovXG4gIG1vc3RSZWNlbnRDYWNoZUV2ZW50VGltZXN0YW1wO1xuICBpbnRlcm5hbElkO1xuICAvKipcbiAgICogV2hldGhlciB0aGUgc3Vic2NyaXB0aW9uIHNob3VsZCBjbG9zZSB3aGVuIGFsbCByZWxheXMgaGF2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGV2ZW50IHN0cmVhbS5cbiAgICovXG4gIGNsb3NlT25Fb3NlO1xuICAvKipcbiAgICogUG9vbCBtb25pdG9yIGNhbGxiYWNrXG4gICAqL1xuICBwb29sTW9uaXRvcjtcbiAgc2tpcE9wdGltaXN0aWNQdWJsaXNoRXZlbnQgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEZpbHRlcnMgdG8gcmVtb3ZlIHdoZW4gcXVlcnlpbmcgdGhlIGNhY2hlLlxuICAgKi9cbiAgY2FjaGVVbmNvbnN0cmFpbkZpbHRlcjtcbiAgY29uc3RydWN0b3IobmRrLCBmaWx0ZXJzLCBvcHRzLCBzdWJJZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0cywgLi4ub3B0cyB8fCB7fSB9O1xuICAgIHRoaXMucG9vbCA9IHRoaXMub3B0cy5wb29sIHx8IG5kay5wb29sO1xuICAgIHRoaXMuZmlsdGVycyA9IEFycmF5LmlzQXJyYXkoZmlsdGVycykgPyBmaWx0ZXJzIDogW2ZpbHRlcnNdO1xuICAgIHRoaXMuc3ViSWQgPSBzdWJJZCB8fCB0aGlzLm9wdHMuc3ViSWQ7XG4gICAgdGhpcy5pbnRlcm5hbElkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpO1xuICAgIHRoaXMuZGVidWcgPSBuZGsuZGVidWcuZXh0ZW5kKGBzdWJzY3JpcHRpb25bJHt0aGlzLm9wdHMuc3ViSWQgPz8gdGhpcy5pbnRlcm5hbElkfV1gKTtcbiAgICBpZiAodGhpcy5vcHRzLnJlbGF5U2V0KSB7XG4gICAgICB0aGlzLnJlbGF5U2V0ID0gdGhpcy5vcHRzLnJlbGF5U2V0O1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLnJlbGF5VXJscykge1xuICAgICAgdGhpcy5yZWxheVNldCA9IE5ES1JlbGF5U2V0LmZyb21SZWxheVVybHModGhpcy5vcHRzLnJlbGF5VXJscywgdGhpcy5uZGspO1xuICAgIH1cbiAgICB0aGlzLnNraXBWZXJpZmljYXRpb24gPSB0aGlzLm9wdHMuc2tpcFZlcmlmaWNhdGlvbiB8fCBmYWxzZTtcbiAgICB0aGlzLnNraXBWYWxpZGF0aW9uID0gdGhpcy5vcHRzLnNraXBWYWxpZGF0aW9uIHx8IGZhbHNlO1xuICAgIHRoaXMuY2xvc2VPbkVvc2UgPSB0aGlzLm9wdHMuY2xvc2VPbkVvc2UgfHwgZmFsc2U7XG4gICAgdGhpcy5za2lwT3B0aW1pc3RpY1B1Ymxpc2hFdmVudCA9IHRoaXMub3B0cy5za2lwT3B0aW1pc3RpY1B1Ymxpc2hFdmVudCB8fCBmYWxzZTtcbiAgICB0aGlzLmNhY2hlVW5jb25zdHJhaW5GaWx0ZXIgPSB0aGlzLm9wdHMuY2FjaGVVbmNvbnN0cmFpbkZpbHRlcjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVsYXlzIHRoYXQgaGF2ZSBub3QgeWV0IHNlbnQgYW4gRU9TRS5cbiAgICovXG4gIHJlbGF5c01pc3NpbmdFb3NlKCkge1xuICAgIGlmICghdGhpcy5yZWxheUZpbHRlcnMpIHJldHVybiBbXTtcbiAgICBjb25zdCByZWxheXNNaXNzaW5nRW9zZSA9IEFycmF5LmZyb20odGhpcy5yZWxheUZpbHRlcnM/LmtleXMoKSkuZmlsdGVyKFxuICAgICAgKHVybCkgPT4gIXRoaXMuZW9zZXNTZWVuLmhhcyh0aGlzLnBvb2wuZ2V0UmVsYXkodXJsLCBmYWxzZSwgZmFsc2UpKVxuICAgICk7XG4gICAgcmV0dXJuIHJlbGF5c01pc3NpbmdFb3NlO1xuICB9XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGZpcnN0IGZpbHRlciBvZiB0aGUgc3Vic2NyaXB0aW9uIGZvclxuICAgKiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICovXG4gIGdldCBmaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyc1swXTtcbiAgfVxuICBnZXQgZ3JvdXBhYmxlRGVsYXkoKSB7XG4gICAgaWYgKCF0aGlzLmlzR3JvdXBhYmxlKCkpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIHRoaXMub3B0cz8uZ3JvdXBhYmxlRGVsYXk7XG4gIH1cbiAgZ2V0IGdyb3VwYWJsZURlbGF5VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRzPy5ncm91cGFibGVEZWxheVR5cGUgfHwgXCJhdC1tb3N0XCI7XG4gIH1cbiAgaXNHcm91cGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0cz8uZ3JvdXBhYmxlIHx8IGZhbHNlO1xuICB9XG4gIHNob3VsZFF1ZXJ5Q2FjaGUoKSB7XG4gICAgaWYgKHRoaXMub3B0cy5hZGRTaW5jZUZyb21DYWNoZSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMub3B0cz8uY2FjaGVVc2FnZSA9PT0gXCJPTkxZX1JFTEFZXCIgLyogT05MWV9SRUxBWSAqLykgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGhhc05vbkVwaGVtZXJhbEtpbmQgPSB0aGlzLmZpbHRlcnMuc29tZSgoZikgPT4gZi5raW5kcz8uc29tZSgoaykgPT4ga2luZElzRXBoZW1lcmFsKGspKSk7XG4gICAgaWYgKGhhc05vbkVwaGVtZXJhbEtpbmQpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNob3VsZFF1ZXJ5UmVsYXlzKCkge1xuICAgIHJldHVybiB0aGlzLm9wdHM/LmNhY2hlVXNhZ2UgIT09IFwiT05MWV9DQUNIRVwiIC8qIE9OTFlfQ0FDSEUgKi87XG4gIH1cbiAgc2hvdWxkV2FpdEZvckNhY2hlKCkge1xuICAgIGlmICh0aGlzLm9wdHMuYWRkU2luY2VGcm9tQ2FjaGUpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiAoXG4gICAgICAvLyBNdXN0IHdhbnQgdG8gY2xvc2Ugb24gRU9TRTsgc3Vic2NyaXB0aW9uc1xuICAgICAgLy8gdGhhdCB3YW50IHRvIHJlY2VpdmUgZnVydGhlciB1cGRhdGVzIG11c3RcbiAgICAgIC8vIGFsd2F5cyBoaXQgdGhlIHJlbGF5XG4gICAgICAhIXRoaXMub3B0cy5jbG9zZU9uRW9zZSAmJiAvLyBDYWNoZSBhZGFwdGVyIG11c3QgY2xhaW0gdG8gYmUgZmFzdFxuICAgICAgISF0aGlzLm5kay5jYWNoZUFkYXB0ZXI/LmxvY2tpbmcgJiYgLy8gSWYgZXhwbGljaXRseSB0b2xkIHRvIHJ1biBpbiBwYXJhbGxlbCwgdGhlblxuICAgICAgLy8gd2Ugc2hvdWxkIG5vdCB3YWl0IGZvciB0aGUgY2FjaGVcbiAgICAgIHRoaXMub3B0cy5jYWNoZVVzYWdlICE9PSBcIlBBUkFMTEVMXCIgLyogUEFSQUxMRUwgKi9cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCB0aGUgc3Vic2NyaXB0aW9uLiBUaGlzIGlzIHRoZSBtYWluIG1ldGhvZCB0aGF0IHNob3VsZCBiZSBjYWxsZWRcbiAgICogYWZ0ZXIgY3JlYXRpbmcgYSBzdWJzY3JpcHRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBlbWl0Q2FjaGVkRXZlbnRzIC0gV2hldGhlciB0byBlbWl0IGV2ZW50cyBjb21pbmcgZnJvbSBhIHN5bmNocm9ub3VzIGNhY2hlXG4gICAqXG4gICAqIFdoZW4gdXNpbmcgYSBzeW5jaHJvbm91cyBjYWNoZSwgdGhlIGV2ZW50cyB3aWxsIGJlIHJldHVybmVkIGltbWVkaWF0ZWx5XG4gICAqIGJ5IHRoaXMgZnVuY3Rpb24uIElmIHlvdSB3aWxsIHVzZSB0aG9zZSByZXR1cm5lZCBldmVudHMsIHlvdSBzaG91bGRcbiAgICogc2V0IGVtaXRDYWNoZWRFdmVudHMgdG8gZmFsc2UgdG8gcHJldmVudCBzZWVpbmcgdGhlbSBhcyBkdXBsaWNhdGUgZXZlbnRzLlxuICAgKi9cbiAgc3RhcnQoZW1pdENhY2hlZEV2ZW50cyA9IHRydWUpIHtcbiAgICBsZXQgY2FjaGVSZXN1bHQ7XG4gICAgY29uc3QgdXBkYXRlU3RhdGVGcm9tQ2FjaGVSZXN1bHRzID0gKGV2ZW50cykgPT4ge1xuICAgICAgaWYgKGVtaXRDYWNoZWRFdmVudHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMubW9zdFJlY2VudENhY2hlRXZlbnRUaW1lc3RhbXAgfHwgZXZlbnQuY3JlYXRlZF9hdCA+IHRoaXMubW9zdFJlY2VudENhY2hlRXZlbnRUaW1lc3RhbXApIHtcbiAgICAgICAgICAgIHRoaXMubW9zdFJlY2VudENhY2hlRXZlbnRUaW1lc3RhbXAgPSBldmVudC5jcmVhdGVkX2F0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmV2ZW50UmVjZWl2ZWQoZXZlbnQsIHZvaWQgMCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICAgIGlmICghdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCB8fCBldmVudC5jcmVhdGVkX2F0ID4gdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCkge1xuICAgICAgICAgICAgdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCA9IGV2ZW50LmNyZWF0ZWRfYXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV2ZW50Lm5kayA9IHRoaXMubmRrO1xuICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLm9wdHMud3JhcCA/IHdyYXBFdmVudChldmVudCkgOiBldmVudDtcbiAgICAgICAgICBpZiAoIWUpIGJyZWFrO1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgZS50aGVuKCh3cmFwcGVkRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoZmFsc2UsIHdyYXBwZWRFdmVudCwgdm9pZCAwLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmV2ZW50Rmlyc3RTZWVuLnNldChlLmlkLCBEYXRlLm5vdygpKTtcbiAgICAgICAgICBjYWNoZVJlc3VsdC5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsb2FkRnJvbVJlbGF5cyA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNob3VsZFF1ZXJ5UmVsYXlzKCkpIHtcbiAgICAgICAgdGhpcy5zdGFydFdpdGhSZWxheXMoKTtcbiAgICAgICAgdGhpcy5zdGFydFBvb2xNb25pdG9yKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoXCJlb3NlXCIsIHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHRoaXMuc2hvdWxkUXVlcnlDYWNoZSgpKSB7XG4gICAgICBjYWNoZVJlc3VsdCA9IHRoaXMuc3RhcnRXaXRoQ2FjaGUoKTtcbiAgICAgIGlmIChjYWNoZVJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkV2FpdEZvckNhY2hlKCkpIHtcbiAgICAgICAgICBjYWNoZVJlc3VsdC50aGVuKChldmVudHMpID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlRnJvbUNhY2hlUmVzdWx0cyhldmVudHMpO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5RnVsbHlGaWxsZWQodGhpcykpIHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZW9zZVwiLCB0aGlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9hZEZyb21SZWxheXMoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZVJlc3VsdC50aGVuKChldmVudHMpID0+IHtcbiAgICAgICAgICB1cGRhdGVTdGF0ZUZyb21DYWNoZVJlc3VsdHMoZXZlbnRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxvYWRGcm9tUmVsYXlzKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdXBkYXRlU3RhdGVGcm9tQ2FjaGVSZXN1bHRzKGNhY2hlUmVzdWx0KTtcbiAgICAgIGlmIChxdWVyeUZ1bGx5RmlsbGVkKHRoaXMpKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImVvc2VcIiwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkRnJvbVJlbGF5cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlUmVzdWx0O1xuICAgIH1cbiAgICBsb2FkRnJvbVJlbGF5cygpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBXZSB3YW50IHRvIG1vbml0b3IgZm9yIG5ldyByZWxheXMgdGhhdCBhcmUgY29taW5nIG9ubGluZSwgaW4gY2FzZVxuICAgKiB0aGV5IHNob3VsZCBiZSBwYXJ0IG9mIHRoaXMgc3Vic2NyaXB0aW9uLlxuICAgKi9cbiAgc3RhcnRQb29sTW9uaXRvcigpIHtcbiAgICBjb25zdCBfZCA9IHRoaXMuZGVidWcuZXh0ZW5kKFwicG9vbC1tb25pdG9yXCIpO1xuICAgIHRoaXMucG9vbE1vbml0b3IgPSAocmVsYXkpID0+IHtcbiAgICAgIGlmICh0aGlzLnJlbGF5RmlsdGVycz8uaGFzKHJlbGF5LnVybCkpIHJldHVybjtcbiAgICAgIGNvbnN0IGNhbGMgPSBjYWxjdWxhdGVSZWxheVNldHNGcm9tRmlsdGVycyh0aGlzLm5kaywgdGhpcy5maWx0ZXJzLCB0aGlzLnBvb2wpO1xuICAgICAgaWYgKGNhbGMuZ2V0KHJlbGF5LnVybCkpIHtcbiAgICAgICAgdGhpcy5yZWxheUZpbHRlcnM/LnNldChyZWxheS51cmwsIHRoaXMuZmlsdGVycyk7XG4gICAgICAgIHJlbGF5LnN1YnNjcmliZSh0aGlzLCB0aGlzLmZpbHRlcnMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5wb29sLm9uKFwicmVsYXk6Y29ubmVjdFwiLCB0aGlzLnBvb2xNb25pdG9yKTtcbiAgfVxuICBvblN0b3BwZWQ7XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5lbWl0KFwiY2xvc2VcIiwgdGhpcyk7XG4gICAgdGhpcy5wb29sTW9uaXRvciAmJiB0aGlzLnBvb2wub2ZmKFwicmVsYXk6Y29ubmVjdFwiLCB0aGlzLnBvb2xNb25pdG9yKTtcbiAgICB0aGlzLm9uU3RvcHBlZD8uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHN1YnNjcmlwdGlvbiBoYXMgYW4gYXV0aG9ycyBmaWx0ZXIuXG4gICAqL1xuICBoYXNBdXRob3JzRmlsdGVyKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcnMuc29tZSgoZikgPT4gZi5hdXRob3JzPy5sZW5ndGgpO1xuICB9XG4gIHN0YXJ0V2l0aENhY2hlKCkge1xuICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXI/LnF1ZXJ5KSB7XG4gICAgICByZXR1cm4gdGhpcy5uZGsuY2FjaGVBZGFwdGVyLnF1ZXJ5KHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgYXZhaWxhYmxlIHJlbGF5cyB0aGF0IHNob3VsZCBiZSBwYXJ0IG9mIHRoaXMgc3Vic2NyaXB0aW9uIGFuZCBleGVjdXRlIGluIHRoZW0uXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIGlzIGV4ZWN1dGVkIGluIGFkZGl0aW9uIHRvIHVzaW5nIHRoZSBwb29sIG1vbml0b3IsIHNvIGV2ZW4gaWYgdGhlIHJlbGF5IHNldFxuICAgKiB0aGF0IGlzIGNvbXB1dGVkIChpLmUuIHdlIGRvbid0IGhhdmUgYW55IHJlbGF5cyBhdmFpbGFibGUpLCB3aGVuIHJlbGF5cyBjb21lIG9ubGluZSwgd2Ugd2lsbFxuICAgKiBjaGVjayBpZiB3ZSBuZWVkIHRvIGV4ZWN1dGUgaW4gdGhlbS5cbiAgICovXG4gIHN0YXJ0V2l0aFJlbGF5cygpIHtcbiAgICBsZXQgZmlsdGVycyA9IHRoaXMuZmlsdGVycztcbiAgICBpZiAodGhpcy5vcHRzLmFkZFNpbmNlRnJvbUNhY2hlICYmIHRoaXMubW9zdFJlY2VudENhY2hlRXZlbnRUaW1lc3RhbXApIHtcbiAgICAgIGNvbnN0IHNpbmNlVGltZXN0YW1wID0gdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCArIDE7XG4gICAgICBmaWx0ZXJzID0gZmlsdGVycy5tYXAoKGZpbHRlcikgPT4gKHtcbiAgICAgICAgLi4uZmlsdGVyLFxuICAgICAgICBzaW5jZTogTWF0aC5tYXgoZmlsdGVyLnNpbmNlIHx8IDAsIHNpbmNlVGltZXN0YW1wKVxuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVsYXlTZXQgfHwgdGhpcy5yZWxheVNldC5yZWxheXMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5yZWxheUZpbHRlcnMgPSBjYWxjdWxhdGVSZWxheVNldHNGcm9tRmlsdGVycyh0aGlzLm5kaywgZmlsdGVycywgdGhpcy5wb29sKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWxheUZpbHRlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCByZWxheSBvZiB0aGlzLnJlbGF5U2V0LnJlbGF5cykge1xuICAgICAgICB0aGlzLnJlbGF5RmlsdGVycy5zZXQocmVsYXkudXJsLCBmaWx0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbcmVsYXlVcmwsIGZpbHRlcnMyXSBvZiB0aGlzLnJlbGF5RmlsdGVycykge1xuICAgICAgY29uc3QgcmVsYXkgPSB0aGlzLnBvb2wuZ2V0UmVsYXkocmVsYXlVcmwsIHRydWUsIHRydWUsIGZpbHRlcnMyKTtcbiAgICAgIHJlbGF5LnN1YnNjcmliZSh0aGlzLCBmaWx0ZXJzMik7XG4gICAgfVxuICB9XG4gIC8vIEVWRU5UIGhhbmRsaW5nXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhbiBldmVudCBpcyByZWNlaXZlZCBmcm9tIGEgcmVsYXkgb3IgdGhlIGNhY2hlXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcGFyYW0gcmVsYXlcbiAgICogQHBhcmFtIGZyb21DYWNoZSBXaGV0aGVyIHRoZSBldmVudCB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgY2FjaGVcbiAgICogQHBhcmFtIG9wdGltaXN0aWNQdWJsaXNoIFdoZXRoZXIgdGhpcyBldmVudCBpcyBjb21pbmcgZnJvbSBhbiBvcHRpbWlzdGljIHB1Ymxpc2hcbiAgICovXG4gIGV2ZW50UmVjZWl2ZWQoZXZlbnQsIHJlbGF5LCBmcm9tQ2FjaGUgPSBmYWxzZSwgb3B0aW1pc3RpY1B1Ymxpc2ggPSBmYWxzZSkge1xuICAgIGNvbnN0IGV2ZW50SWQgPSBldmVudC5pZDtcbiAgICBjb25zdCBldmVudEFscmVhZHlTZWVuID0gdGhpcy5ldmVudEZpcnN0U2Vlbi5oYXMoZXZlbnRJZCk7XG4gICAgbGV0IG5ka0V2ZW50O1xuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIE5ES0V2ZW50KSBuZGtFdmVudCA9IGV2ZW50O1xuICAgIGlmICghZXZlbnRBbHJlYWR5U2Vlbikge1xuICAgICAgbmRrRXZlbnQgPz89IG5ldyBOREtFdmVudCh0aGlzLm5kaywgZXZlbnQpO1xuICAgICAgbmRrRXZlbnQubmRrID0gdGhpcy5uZGs7XG4gICAgICBuZGtFdmVudC5yZWxheSA9IHJlbGF5O1xuICAgICAgaWYgKCFmcm9tQ2FjaGUgJiYgIW9wdGltaXN0aWNQdWJsaXNoKSB7XG4gICAgICAgIGlmICghdGhpcy5za2lwVmFsaWRhdGlvbikge1xuICAgICAgICAgIGlmICghbmRrRXZlbnQuaXNWYWxpZCkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIkV2ZW50IGZhaWxlZCB2YWxpZGF0aW9uICVzIGZyb20gcmVsYXkgJXNcIiwgZXZlbnRJZCwgcmVsYXk/LnVybCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxheSkge1xuICAgICAgICAgIGlmIChyZWxheT8uc2hvdWxkVmFsaWRhdGVFdmVudCgpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNraXBWZXJpZmljYXRpb24pIHtcbiAgICAgICAgICAgICAgaWYgKCFuZGtFdmVudC52ZXJpZnlTaWduYXR1cmUodHJ1ZSkgJiYgIXRoaXMubmRrLmFzeW5jU2lnVmVyaWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIkV2ZW50IGZhaWxlZCBzaWduYXR1cmUgdmFsaWRhdGlvblwiLCBldmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZWxheSkge1xuICAgICAgICAgICAgICAgIHJlbGF5LmFkZFZhbGlkYXRlZEV2ZW50KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVsYXkuYWRkTm9uVmFsaWRhdGVkRXZlbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlciAmJiAhdGhpcy5vcHRzLmRvbnRTYXZlVG9DYWNoZSkge1xuICAgICAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5zZXRFdmVudChuZGtFdmVudCwgdGhpcy5maWx0ZXJzLCByZWxheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW1pc3RpY1B1Ymxpc2ggfHwgdGhpcy5za2lwT3B0aW1pc3RpY1B1Ymxpc2hFdmVudCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVtaXRFdmVudCh0aGlzLm9wdHM/LndyYXAgPz8gZmFsc2UsIG5ka0V2ZW50LCByZWxheSwgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCk7XG4gICAgICAgIHRoaXMuZXZlbnRGaXJzdFNlZW4uc2V0KGV2ZW50SWQsIERhdGUubm93KCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0aW1lU2luY2VGaXJzdFNlZW4gPSBEYXRlLm5vdygpIC0gKHRoaXMuZXZlbnRGaXJzdFNlZW4uZ2V0KGV2ZW50SWQpIHx8IDApO1xuICAgICAgdGhpcy5lbWl0KFwiZXZlbnQ6ZHVwXCIsIGV2ZW50LCByZWxheSwgdGltZVNpbmNlRmlyc3RTZWVuLCB0aGlzLCBmcm9tQ2FjaGUsIG9wdGltaXN0aWNQdWJsaXNoKTtcbiAgICAgIGlmIChyZWxheSkge1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB2ZXJpZmllZFNpZ25hdHVyZXMuZ2V0KGV2ZW50SWQpO1xuICAgICAgICBpZiAoc2lnbmF0dXJlICYmIHR5cGVvZiBzaWduYXR1cmUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuc2lnID09PSBzaWduYXR1cmUpIHtcbiAgICAgICAgICAgIHJlbGF5LmFkZFZhbGlkYXRlZEV2ZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGFzdEV2ZW50UmVjZWl2ZWRBdCA9IERhdGUubm93KCk7XG4gIH1cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgd3JhcHMsIHN5bmMgb3IgYXN5bmMsIGFuZCBlbWl0cyB0aGUgZXZlbnQgKGlmIG9uZSBjb21lcyBiYWNrIGZyb20gdGhlIHdyYXBwZXIpXG4gICAqL1xuICBlbWl0RXZlbnQod3JhcCwgZXZ0LCByZWxheSwgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCkge1xuICAgIGNvbnN0IHdyYXBwZWQgPSB3cmFwID8gd3JhcEV2ZW50KGV2dCkgOiBldnQ7XG4gICAgaWYgKHdyYXBwZWQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICB3cmFwcGVkLnRoZW4oKGUpID0+IHRoaXMuZW1pdEV2ZW50KGZhbHNlLCBlLCByZWxheSwgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCkpO1xuICAgIH0gZWxzZSBpZiAod3JhcHBlZCkge1xuICAgICAgdGhpcy5lbWl0KFwiZXZlbnRcIiwgd3JhcHBlZCwgcmVsYXksIHRoaXMsIGZyb21DYWNoZSwgb3B0aW1pc3RpY1B1Ymxpc2gpO1xuICAgIH1cbiAgfVxuICBjbG9zZWRSZWNlaXZlZChyZWxheSwgcmVhc29uKSB7XG4gICAgdGhpcy5lbWl0KFwiY2xvc2VkXCIsIHJlbGF5LCByZWFzb24pO1xuICB9XG4gIC8vIEVPU0UgaGFuZGxpbmdcbiAgZW9zZVRpbWVvdXQ7XG4gIGVvc2VkID0gZmFsc2U7XG4gIGVvc2VSZWNlaXZlZChyZWxheSkge1xuICAgIHRoaXMuZGVidWcoXCJFT1NFIHJlY2VpdmVkIGZyb20gJXNcIiwgcmVsYXkudXJsKTtcbiAgICB0aGlzLmVvc2VzU2Vlbi5hZGQocmVsYXkpO1xuICAgIGxldCBsYXN0RXZlbnRTZWVuID0gdGhpcy5sYXN0RXZlbnRSZWNlaXZlZEF0ID8gRGF0ZS5ub3coKSAtIHRoaXMubGFzdEV2ZW50UmVjZWl2ZWRBdCA6IHZvaWQgMDtcbiAgICBjb25zdCBoYXNTZWVuQWxsRW9zZXMgPSB0aGlzLmVvc2VzU2Vlbi5zaXplID09PSB0aGlzLnJlbGF5RmlsdGVycz8uc2l6ZTtcbiAgICBjb25zdCBxdWVyeUZpbGxlZCA9IHF1ZXJ5RnVsbHlGaWxsZWQodGhpcyk7XG4gICAgY29uc3QgcGVyZm9ybUVvc2UgPSAocmVhc29uKSA9PiB7XG4gICAgICB0aGlzLmRlYnVnKFwiUGVyZm9ybWluZyBFT1NFOiAlcyAlZFwiLCByZWFzb24sIHRoaXMuZW9zZWQpO1xuICAgICAgaWYgKHRoaXMuZW9zZWQpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmVvc2VUaW1lb3V0KSBjbGVhclRpbWVvdXQodGhpcy5lb3NlVGltZW91dCk7XG4gICAgICB0aGlzLmVtaXQoXCJlb3NlXCIsIHRoaXMpO1xuICAgICAgdGhpcy5lb3NlZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5vcHRzPy5jbG9zZU9uRW9zZSkgdGhpcy5zdG9wKCk7XG4gICAgfTtcbiAgICBpZiAocXVlcnlGaWxsZWQgfHwgaGFzU2VlbkFsbEVvc2VzKSB7XG4gICAgICBwZXJmb3JtRW9zZShcInF1ZXJ5IGZpbGxlZCBvciBzZWVuIGFsbFwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVsYXlGaWx0ZXJzKSB7XG4gICAgICBsZXQgdGltZVRvV2FpdEZvck5leHRFb3NlID0gMWUzO1xuICAgICAgY29uc3QgY29ubmVjdGVkUmVsYXlzID0gbmV3IFNldCh0aGlzLnBvb2wuY29ubmVjdGVkUmVsYXlzKCkubWFwKChyKSA9PiByLnVybCkpO1xuICAgICAgY29uc3QgY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMgPSBBcnJheS5mcm9tKHRoaXMucmVsYXlGaWx0ZXJzLmtleXMoKSkuZmlsdGVyKFxuICAgICAgICAodXJsKSA9PiBjb25uZWN0ZWRSZWxheXMuaGFzKHVybClcbiAgICAgICk7XG4gICAgICBpZiAoY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgICAgXCJObyBjb25uZWN0ZWQgcmVsYXlzLCB3YWl0aW5nIGZvciBhbGwgcmVsYXlzIHRvIGNvbm5lY3RcIixcbiAgICAgICAgICBBcnJheS5mcm9tKHRoaXMucmVsYXlGaWx0ZXJzLmtleXMoKSkuam9pbihcIiwgXCIpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2VPZlJlbGF5c1RoYXRIYXZlU2VudEVvc2UgPSB0aGlzLmVvc2VzU2Vlbi5zaXplIC8gY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMubGVuZ3RoO1xuICAgICAgdGhpcy5kZWJ1ZyhcIlBlcmNlbnRhZ2Ugb2YgcmVsYXlzIHRoYXQgaGF2ZSBzZW50IEVPU0VcIiwge1xuICAgICAgICBzdWJJZDogdGhpcy5zdWJJZCxcbiAgICAgICAgcGVyY2VudGFnZU9mUmVsYXlzVGhhdEhhdmVTZW50RW9zZSxcbiAgICAgICAgc2VlbjogdGhpcy5lb3Nlc1NlZW4uc2l6ZSxcbiAgICAgICAgdG90YWw6IGNvbm5lY3RlZFJlbGF5c1dpdGhGaWx0ZXJzLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5lb3Nlc1NlZW4uc2l6ZSA+PSAyICYmIHBlcmNlbnRhZ2VPZlJlbGF5c1RoYXRIYXZlU2VudEVvc2UgPj0gMC41KSB7XG4gICAgICAgIHRpbWVUb1dhaXRGb3JOZXh0RW9zZSA9IHRpbWVUb1dhaXRGb3JOZXh0RW9zZSAqICgxIC0gcGVyY2VudGFnZU9mUmVsYXlzVGhhdEhhdmVTZW50RW9zZSk7XG4gICAgICAgIGlmICh0aW1lVG9XYWl0Rm9yTmV4dEVvc2UgPT09IDApIHtcbiAgICAgICAgICBwZXJmb3JtRW9zZShcInRpbWUgdG8gd2FpdCB3YXMgMFwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW9zZVRpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLmVvc2VUaW1lb3V0KTtcbiAgICAgICAgY29uc3Qgc2VuZEVvc2VUaW1lb3V0ID0gKCkgPT4ge1xuICAgICAgICAgIGxhc3RFdmVudFNlZW4gPSB0aGlzLmxhc3RFdmVudFJlY2VpdmVkQXQgPyBEYXRlLm5vdygpIC0gdGhpcy5sYXN0RXZlbnRSZWNlaXZlZEF0IDogdm9pZCAwO1xuICAgICAgICAgIGlmIChsYXN0RXZlbnRTZWVuICE9PSB2b2lkIDAgJiYgbGFzdEV2ZW50U2VlbiA8IDIwKSB7XG4gICAgICAgICAgICB0aGlzLmVvc2VUaW1lb3V0ID0gc2V0VGltZW91dChzZW5kRW9zZVRpbWVvdXQsIHRpbWVUb1dhaXRGb3JOZXh0RW9zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlcmZvcm1Fb3NlKGBzZW5kIGVvc2UgdGltZW91dDogJHt0aW1lVG9XYWl0Rm9yTmV4dEVvc2V9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVvc2VUaW1lb3V0ID0gc2V0VGltZW91dChzZW5kRW9zZVRpbWVvdXQsIHRpbWVUb1dhaXRGb3JOZXh0RW9zZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIGtpbmRJc0VwaGVtZXJhbCA9IChraW5kKSA9PiBraW5kID49IDJlNCAmJiBraW5kIDwgM2U0O1xuXG4vLyBzcmMvdXNlci9mb2xsb3dzLnRzXG5hc3luYyBmdW5jdGlvbiBmb2xsb3dzKG9wdHMsIG91dGJveCwga2luZCA9IDMgLyogQ29udGFjdHMgKi8pIHtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIG5vdCBzZXRcIik7XG4gIGNvbnN0IGNvbnRhY3RMaXN0RXZlbnQgPSBhd2FpdCB0aGlzLm5kay5mZXRjaEV2ZW50KFxuICAgIHsga2luZHM6IFtraW5kXSwgYXV0aG9yczogW3RoaXMucHVia2V5XSB9LFxuICAgIG9wdHMgfHwgeyBncm91cGFibGU6IGZhbHNlIH1cbiAgKTtcbiAgaWYgKGNvbnRhY3RMaXN0RXZlbnQpIHtcbiAgICBjb25zdCBwdWJrZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb250YWN0TGlzdEV2ZW50LnRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICBpZiAodGFnWzBdID09PSBcInBcIikgcHVia2V5cy5hZGQodGFnWzFdKTtcbiAgICB9KTtcbiAgICBpZiAob3V0Ym94KSB7XG4gICAgICB0aGlzLm5kaz8ub3V0Ym94VHJhY2tlcj8udHJhY2tVc2VycyhBcnJheS5mcm9tKHB1YmtleXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIFsuLi5wdWJrZXlzXS5yZWR1Y2UoKGFjYywgcHVia2V5KSA9PiB7XG4gICAgICBjb25zdCB1c2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXkgfSk7XG4gICAgICB1c2VyLm5kayA9IHRoaXMubmRrO1xuICAgICAgYWNjLmFkZCh1c2VyKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG59XG5cbi8vIHNyYy91c2VyL25pcDA1LnRzXG52YXIgTklQMDVfUkVHRVggPSAvXig/OihbXFx3ListXSspQCk/KFtcXHcuLV0rKSQvO1xuYXN5bmMgZnVuY3Rpb24gZ2V0TmlwMDVGb3IobmRrLCBmdWxsbmFtZSwgX2ZldGNoID0gZmV0Y2gsIGZldGNoT3B0cyA9IHt9KSB7XG4gIHJldHVybiBhd2FpdCBuZGsucXVldWVzTmlwMDUuYWRkKHtcbiAgICBpZDogZnVsbG5hbWUsXG4gICAgZnVuYzogYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKG5kay5jYWNoZUFkYXB0ZXI/LmxvYWROaXAwNSkge1xuICAgICAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgbmRrLmNhY2hlQWRhcHRlci5sb2FkTmlwMDUoZnVsbG5hbWUpO1xuICAgICAgICBpZiAocHJvZmlsZSAhPT0gXCJtaXNzaW5nXCIpIHtcbiAgICAgICAgICBpZiAocHJvZmlsZSkge1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHtcbiAgICAgICAgICAgICAgcHVia2V5OiBwcm9maWxlLnB1YmtleSxcbiAgICAgICAgICAgICAgcmVsYXlVcmxzOiBwcm9maWxlLnJlbGF5cyxcbiAgICAgICAgICAgICAgbmlwNDZVcmxzOiBwcm9maWxlLm5pcDQ2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVzZXIubmRrID0gbmRrO1xuICAgICAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmZXRjaE9wdHMuY2FjaGUgIT09IFwibm8tY2FjaGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBtYXRjaCA9IGZ1bGxuYW1lLm1hdGNoKE5JUDA1X1JFR0VYKTtcbiAgICAgIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgW18sIG5hbWUgPSBcIl9cIiwgZG9tYWluXSA9IG1hdGNoO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgX2ZldGNoKGBodHRwczovLyR7ZG9tYWlufS8ud2VsbC1rbm93bi9ub3N0ci5qc29uP25hbWU9JHtuYW1lfWAsIGZldGNoT3B0cyk7XG4gICAgICAgIGNvbnN0IHsgbmFtZXMsIHJlbGF5cywgbmlwNDYgfSA9IHBhcnNlTklQMDVSZXN1bHQoYXdhaXQgcmVzLmpzb24oKSk7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IG5hbWVzW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGxldCBwcm9maWxlID0gbnVsbDtcbiAgICAgICAgaWYgKHB1YmtleSkge1xuICAgICAgICAgIHByb2ZpbGUgPSB7IHB1YmtleSwgcmVsYXlzOiByZWxheXM/LltwdWJrZXldLCBuaXA0NjogbmlwNDY/LltwdWJrZXldIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5kaz8uY2FjaGVBZGFwdGVyPy5zYXZlTmlwMDUpIHtcbiAgICAgICAgICBuZGsuY2FjaGVBZGFwdGVyLnNhdmVOaXAwNShmdWxsbmFtZSwgcHJvZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2ZpbGU7XG4gICAgICB9IGNhdGNoIChfZSkge1xuICAgICAgICBpZiAobmRrPy5jYWNoZUFkYXB0ZXI/LnNhdmVOaXAwNSkge1xuICAgICAgICAgIG5kaz8uY2FjaGVBZGFwdGVyLnNhdmVOaXAwNShmdWxsbmFtZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBOSVAwNSBmb3JcIiwgZnVsbG5hbWUsIF9lKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlTklQMDVSZXN1bHQoanNvbikge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgbmFtZXM6IHt9XG4gIH07XG4gIGZvciAoY29uc3QgW25hbWUsIHB1YmtleV0gb2YgT2JqZWN0LmVudHJpZXMoanNvbi5uYW1lcykpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHB1YmtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVzdWx0Lm5hbWVzW25hbWUudG9Mb3dlckNhc2UoKV0gPSBwdWJrZXk7XG4gICAgfVxuICB9XG4gIGlmIChqc29uLnJlbGF5cykge1xuICAgIHJlc3VsdC5yZWxheXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtwdWJrZXksIHJlbGF5c10gb2YgT2JqZWN0LmVudHJpZXMoanNvbi5yZWxheXMpKSB7XG4gICAgICBpZiAodHlwZW9mIHB1YmtleSA9PT0gXCJzdHJpbmdcIiAmJiBBcnJheS5pc0FycmF5KHJlbGF5cykpIHtcbiAgICAgICAgcmVzdWx0LnJlbGF5c1twdWJrZXldID0gcmVsYXlzLmZpbHRlcigocmVsYXkpID0+IHR5cGVvZiByZWxheSA9PT0gXCJzdHJpbmdcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChqc29uLm5pcDQ2KSB7XG4gICAgcmVzdWx0Lm5pcDQ2ID0ge307XG4gICAgZm9yIChjb25zdCBbcHVia2V5LCBuaXA0Nl0gb2YgT2JqZWN0LmVudHJpZXMoanNvbi5uaXA0NikpIHtcbiAgICAgIGlmICh0eXBlb2YgcHVia2V5ID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkobmlwNDYpKSB7XG4gICAgICAgIHJlc3VsdC5uaXA0NltwdWJrZXldID0gbmlwNDYuZmlsdGVyKChyZWxheSkgPT4gdHlwZW9mIHJlbGF5ID09PSBcInN0cmluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3VzZXIvcHJvZmlsZS50c1xuZnVuY3Rpb24gcHJvZmlsZUZyb21FdmVudChldmVudCkge1xuICBjb25zdCBwcm9maWxlID0ge307XG4gIGxldCBwYXlsb2FkO1xuICB0cnkge1xuICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGV2ZW50LmNvbnRlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHByb2ZpbGUgZXZlbnQ6ICR7ZXJyb3J9YCk7XG4gIH1cbiAgcHJvZmlsZS5wcm9maWxlRXZlbnQgPSBKU09OLnN0cmluZ2lmeShldmVudC5yYXdFdmVudCgpKTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGF5bG9hZCkpIHtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgcHJvZmlsZS5uYW1lID0gcGF5bG9hZC5uYW1lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXNwbGF5X25hbWVcIjpcbiAgICAgICAgcHJvZmlsZS5kaXNwbGF5TmFtZSA9IHBheWxvYWQuZGlzcGxheV9uYW1lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgY2FzZSBcInBpY3R1cmVcIjpcbiAgICAgICAgcHJvZmlsZS5waWN0dXJlID0gcGF5bG9hZC5waWN0dXJlIHx8IHBheWxvYWQuaW1hZ2U7XG4gICAgICAgIHByb2ZpbGUuaW1hZ2UgPSBwcm9maWxlLnBpY3R1cmU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJhbm5lclwiOlxuICAgICAgICBwcm9maWxlLmJhbm5lciA9IHBheWxvYWQuYmFubmVyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJiaW9cIjpcbiAgICAgICAgcHJvZmlsZS5iaW8gPSBwYXlsb2FkLmJpbztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibmlwMDVcIjpcbiAgICAgICAgcHJvZmlsZS5uaXAwNSA9IHBheWxvYWQubmlwMDU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImx1ZDA2XCI6XG4gICAgICAgIHByb2ZpbGUubHVkMDYgPSBwYXlsb2FkLmx1ZDA2O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsdWQxNlwiOlxuICAgICAgICBwcm9maWxlLmx1ZDE2ID0gcGF5bG9hZC5sdWQxNjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYWJvdXRcIjpcbiAgICAgICAgcHJvZmlsZS5hYm91dCA9IHBheWxvYWQuYWJvdXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIndlYnNpdGVcIjpcbiAgICAgICAgcHJvZmlsZS53ZWJzaXRlID0gcGF5bG9hZC53ZWJzaXRlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHByb2ZpbGVba2V5XSA9IHBheWxvYWRba2V5XTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHByb2ZpbGUuY3JlYXRlZF9hdCA9IGV2ZW50LmNyZWF0ZWRfYXQ7XG4gIHJldHVybiBwcm9maWxlO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplUHJvZmlsZShwcm9maWxlKSB7XG4gIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHByb2ZpbGUpKSB7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgXCJ1c2VybmFtZVwiOlxuICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgcGF5bG9hZC5uYW1lID0gdmFsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXNwbGF5TmFtZVwiOlxuICAgICAgICBwYXlsb2FkLmRpc3BsYXlfbmFtZSA9IHZhbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgIGNhc2UgXCJwaWN0dXJlXCI6XG4gICAgICAgIHBheWxvYWQucGljdHVyZSA9IHZhbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmlvXCI6XG4gICAgICBjYXNlIFwiYWJvdXRcIjpcbiAgICAgICAgcGF5bG9hZC5hYm91dCA9IHZhbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBwYXlsb2FkW2tleV0gPSB2YWw7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG59XG5cbi8vIHNyYy91c2VyL2luZGV4LnRzXG52YXIgTkRLVXNlciA9IGNsYXNzIF9OREtVc2VyIHtcbiAgbmRrO1xuICBwcm9maWxlO1xuICBwcm9maWxlRXZlbnQ7XG4gIF9ucHViO1xuICBfcHVia2V5O1xuICByZWxheVVybHMgPSBbXTtcbiAgbmlwNDZVcmxzID0gW107XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBpZiAob3B0cy5ucHViKSB0aGlzLl9ucHViID0gb3B0cy5ucHViO1xuICAgIGlmIChvcHRzLmhleHB1YmtleSkgdGhpcy5fcHVia2V5ID0gb3B0cy5oZXhwdWJrZXk7XG4gICAgaWYgKG9wdHMucHVia2V5KSB0aGlzLl9wdWJrZXkgPSBvcHRzLnB1YmtleTtcbiAgICBpZiAob3B0cy5yZWxheVVybHMpIHRoaXMucmVsYXlVcmxzID0gb3B0cy5yZWxheVVybHM7XG4gICAgaWYgKG9wdHMubmlwNDZVcmxzKSB0aGlzLm5pcDQ2VXJscyA9IG9wdHMubmlwNDZVcmxzO1xuICAgIGlmIChvcHRzLm5wcm9maWxlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gbmlwMTk1LmRlY29kZShvcHRzLm5wcm9maWxlKTtcbiAgICAgICAgaWYgKGRlY29kZWQudHlwZSA9PT0gXCJucHJvZmlsZVwiKSB7XG4gICAgICAgICAgdGhpcy5fcHVia2V5ID0gZGVjb2RlZC5kYXRhLnB1YmtleTtcbiAgICAgICAgICBpZiAoZGVjb2RlZC5kYXRhLnJlbGF5cyAmJiBkZWNvZGVkLmRhdGEucmVsYXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVsYXlVcmxzLnB1c2goLi4uZGVjb2RlZC5kYXRhLnJlbGF5cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZGVjb2RlIG5wcm9maWxlXCIsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgbnB1YigpIHtcbiAgICBpZiAoIXRoaXMuX25wdWIpIHtcbiAgICAgIGlmICghdGhpcy5fcHVia2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMuX25wdWIgPSBuaXAxOTUubnB1YkVuY29kZSh0aGlzLnB1YmtleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ucHViO1xuICB9XG4gIGdldCBucHJvZmlsZSgpIHtcbiAgICBjb25zdCByZWxheXMgPSB0aGlzLnByb2ZpbGVFdmVudD8ub25SZWxheXM/Lm1hcCgocikgPT4gci51cmwpO1xuICAgIHJldHVybiBuaXAxOTUubnByb2ZpbGVFbmNvZGUoe1xuICAgICAgcHVia2V5OiB0aGlzLnB1YmtleSxcbiAgICAgIHJlbGF5c1xuICAgIH0pO1xuICB9XG4gIHNldCBucHViKG5wdWIyKSB7XG4gICAgdGhpcy5fbnB1YiA9IG5wdWIyO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIncyBwdWJrZXlcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHVzZXIncyBwdWJrZXlcbiAgICovXG4gIGdldCBwdWJrZXkoKSB7XG4gICAgaWYgKCF0aGlzLl9wdWJrZXkpIHtcbiAgICAgIGlmICghdGhpcy5fbnB1YikgdGhyb3cgbmV3IEVycm9yKFwibnB1YiBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5fcHVia2V5ID0gbmlwMTk1LmRlY29kZSh0aGlzLm5wdWIpLmRhdGE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wdWJrZXk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgdXNlcidzIHB1YmtleVxuICAgKiBAcGFyYW0gcHVia2V5IHtzdHJpbmd9IFRoZSB1c2VyJ3MgcHVia2V5XG4gICAqL1xuICBzZXQgcHVia2V5KHB1YmtleSkge1xuICAgIHRoaXMuX3B1YmtleSA9IHB1YmtleTtcbiAgfVxuICAvKipcbiAgICogRXF1aXZhbGVudCB0byBOREtFdmVudC5maWx0ZXJzKCkuXG4gICAqIEByZXR1cm5zIHtOREtGaWx0ZXJ9XG4gICAqL1xuICBmaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHsgXCIjcFwiOiBbdGhpcy5wdWJrZXldIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgTklQLTU3IGFuZCBOSVAtNjEgaW5mb3JtYXRpb24gdGhhdCB0aGlzIHVzZXIgaGFzIHNpZ25hbGVkXG4gICAqXG4gICAqIEBwYXJhbSBnZXRBbGwge2Jvb2xlYW59IFdoZXRoZXIgdG8gZ2V0IGFsbCB6YXAgaW5mbyBvciBqdXN0IHRoZSBmaXJzdCBvbmVcbiAgICovXG4gIGFzeW5jIGdldFphcEluZm8odGltZW91dE1zKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIGNvbnN0IHByb21pc2VXaXRoVGltZW91dCA9IGFzeW5jIChwcm9taXNlKSA9PiB7XG4gICAgICBpZiAoIXRpbWVvdXRNcykgcmV0dXJuIHByb21pc2U7XG4gICAgICBsZXQgdGltZW91dElkO1xuICAgICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcihcIlRpbWVvdXRcIikpLCB0aW1lb3V0TXMpO1xuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW3Byb21pc2UsIHRpbWVvdXRQcm9taXNlXSk7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZSA9PT0gXCJUaW1lb3V0XCIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSBjYXRjaCAoX29yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBbdXNlclByb2ZpbGUsIG1pbnRMaXN0RXZlbnRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgcHJvbWlzZVdpdGhUaW1lb3V0KHRoaXMuZmV0Y2hQcm9maWxlKCkpLFxuICAgICAgcHJvbWlzZVdpdGhUaW1lb3V0KHRoaXMubmRrLmZldGNoRXZlbnQoeyBraW5kczogWzEwMDE5IC8qIENhc2h1TWludExpc3QgKi9dLCBhdXRob3JzOiBbdGhpcy5wdWJrZXldIH0pKVxuICAgIF0pO1xuICAgIGNvbnN0IHJlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKG1pbnRMaXN0RXZlbnQpIHtcbiAgICAgIGNvbnN0IG1pbnRMaXN0ID0gTkRLQ2FzaHVNaW50TGlzdC5mcm9tKG1pbnRMaXN0RXZlbnQpO1xuICAgICAgaWYgKG1pbnRMaXN0Lm1pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzLnNldChcIm5pcDYxXCIsIHtcbiAgICAgICAgICBtaW50czogbWludExpc3QubWludHMsXG4gICAgICAgICAgcmVsYXlzOiBtaW50TGlzdC5yZWxheXMsXG4gICAgICAgICAgcDJwazogbWludExpc3QucDJwa1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVzZXJQcm9maWxlKSB7XG4gICAgICBjb25zdCB7IGx1ZDA2LCBsdWQxNiB9ID0gdXNlclByb2ZpbGU7XG4gICAgICByZXMuc2V0KFwibmlwNTdcIiwgeyBsdWQwNiwgbHVkMTYgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIGFuIE5ES1VzZXIgZnJvbSBhIE5JUC0wNSBzdHJpbmdcbiAgICogQHBhcmFtIG5pcDA1SWQge3N0cmluZ30gVGhlIHVzZXIncyBOSVAtMDVcbiAgICogQHBhcmFtIG5kayB7TkRLfSBBbiBOREsgaW5zdGFuY2VcbiAgICogQHBhcmFtIHNraXBDYWNoZSB7Ym9vbGVhbn0gV2hldGhlciB0byBza2lwIHRoZSBjYWNoZSBvciBub3RcbiAgICogQHJldHVybnMge05ES1VzZXIgfCB1bmRlZmluZWR9IEFuIE5ES1VzZXIgaWYgb25lIGlzIGZvdW5kIGZvciB0aGUgZ2l2ZW4gTklQLTA1LCB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21OaXAwNShuaXAwNUlkLCBuZGssIHNraXBDYWNoZSA9IGZhbHNlKSB7XG4gICAgaWYgKCFuZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICBjb25zdCBvcHRzID0ge307XG4gICAgaWYgKHNraXBDYWNoZSkgb3B0cy5jYWNoZSA9IFwibm8tY2FjaGVcIjtcbiAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgZ2V0TmlwMDVGb3IobmRrLCBuaXAwNUlkLCBuZGs/Lmh0dHBGZXRjaCwgb3B0cyk7XG4gICAgaWYgKHByb2ZpbGUpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBuZXcgX05ES1VzZXIoe1xuICAgICAgICBwdWJrZXk6IHByb2ZpbGUucHVia2V5LFxuICAgICAgICByZWxheVVybHM6IHByb2ZpbGUucmVsYXlzLFxuICAgICAgICBuaXA0NlVybHM6IHByb2ZpbGUubmlwNDZcbiAgICAgIH0pO1xuICAgICAgdXNlci5uZGsgPSBuZGs7XG4gICAgICByZXR1cm4gdXNlcjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgdXNlcidzIHByb2ZpbGVcbiAgICogQHBhcmFtIG9wdHMge05ES1N1YnNjcmlwdGlvbk9wdGlvbnN9IEEgc2V0IG9mIE5ES1N1YnNjcmlwdGlvbk9wdGlvbnNcbiAgICogQHBhcmFtIHN0b3JlUHJvZmlsZUV2ZW50IHtib29sZWFufSBXaGV0aGVyIHRvIHN0b3JlIHRoZSBwcm9maWxlIGV2ZW50IG9yIG5vdFxuICAgKiBAcmV0dXJucyBVc2VyIFByb2ZpbGVcbiAgICovXG4gIGFzeW5jIGZldGNoUHJvZmlsZShvcHRzLCBzdG9yZVByb2ZpbGVFdmVudCA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIG5vdCBzZXRcIik7XG4gICAgbGV0IHNldE1ldGFkYXRhRXZlbnQgPSBudWxsO1xuICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXIgJiYgKHRoaXMubmRrLmNhY2hlQWRhcHRlci5mZXRjaFByb2ZpbGUgfHwgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmZldGNoUHJvZmlsZVN5bmMpICYmIG9wdHM/LmNhY2hlVXNhZ2UgIT09IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi8pIHtcbiAgICAgIGxldCBwcm9maWxlID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZmV0Y2hQcm9maWxlU3luYykge1xuICAgICAgICBwcm9maWxlID0gdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmZldGNoUHJvZmlsZVN5bmModGhpcy5wdWJrZXkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZmV0Y2hQcm9maWxlKSB7XG4gICAgICAgIHByb2ZpbGUgPSBhd2FpdCB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZmV0Y2hQcm9maWxlKHRoaXMucHVia2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9maWxlKSB7XG4gICAgICAgIHRoaXMucHJvZmlsZSA9IHByb2ZpbGU7XG4gICAgICAgIHJldHVybiBwcm9maWxlO1xuICAgICAgfVxuICAgIH1cbiAgICBvcHRzID8/PSB7fTtcbiAgICBvcHRzLmNhY2hlVXNhZ2UgPz89IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi87XG4gICAgb3B0cy5jbG9zZU9uRW9zZSA/Pz0gdHJ1ZTtcbiAgICBvcHRzLmdyb3VwYWJsZSA/Pz0gdHJ1ZTtcbiAgICBvcHRzLmdyb3VwYWJsZURlbGF5ID8/PSAyNTA7XG4gICAgaWYgKCFzZXRNZXRhZGF0YUV2ZW50KSB7XG4gICAgICBzZXRNZXRhZGF0YUV2ZW50ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudCh7IGtpbmRzOiBbMF0sIGF1dGhvcnM6IFt0aGlzLnB1YmtleV0gfSwgb3B0cyk7XG4gICAgfVxuICAgIGlmICghc2V0TWV0YWRhdGFFdmVudCkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5wcm9maWxlID0gcHJvZmlsZUZyb21FdmVudChzZXRNZXRhZGF0YUV2ZW50KTtcbiAgICBpZiAoc3RvcmVQcm9maWxlRXZlbnQgJiYgdGhpcy5wcm9maWxlICYmIHRoaXMubmRrLmNhY2hlQWRhcHRlciAmJiB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuc2F2ZVByb2ZpbGUpIHtcbiAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5zYXZlUHJvZmlsZSh0aGlzLnB1YmtleSwgdGhpcy5wcm9maWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvZmlsZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNldCBvZiB1c2VycyB0aGF0IHRoaXMgdXNlciBmb2xsb3dzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZm9sbG93U2V0IGluc3RlYWRcbiAgICovXG4gIGZvbGxvd3MgPSBmb2xsb3dzLmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2V0IG9mIHB1YmtleXMgdGhhdCB0aGlzIHVzZXIgZm9sbG93cy5cbiAgICpcbiAgICogQHBhcmFtIG9wdHMgLSBOREtTdWJzY3JpcHRpb25PcHRpb25zXG4gICAqIEBwYXJhbSBvdXRib3ggLSBib29sZWFuXG4gICAqIEBwYXJhbSBraW5kIC0gbnVtYmVyXG4gICAqL1xuICBhc3luYyBmb2xsb3dTZXQob3B0cywgb3V0Ym94LCBraW5kID0gMyAvKiBDb250YWN0cyAqLykge1xuICAgIGNvbnN0IGZvbGxvd3MyID0gYXdhaXQgdGhpcy5mb2xsb3dzKG9wdHMsIG91dGJveCwga2luZCk7XG4gICAgcmV0dXJuIG5ldyBTZXQoQXJyYXkuZnJvbShmb2xsb3dzMikubWFwKChmKSA9PiBmLnB1YmtleSkpO1xuICB9XG4gIC8qKiBAZGVwcmVjYXRlZCBVc2UgcmVmZXJlbmNlVGFncyBpbnN0ZWFkLiAqL1xuICAvKipcbiAgICogR2V0IHRoZSB0YWcgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyB1c2VyIGluIGFuIGV2ZW50XG4gICAqIEByZXR1cm5zIHtOREtUYWd9IGFuIE5ES1RhZ1xuICAgKi9cbiAgdGFnUmVmZXJlbmNlKCkge1xuICAgIHJldHVybiBbXCJwXCIsIHRoaXMucHVia2V5XTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB0YWdzIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVmZXJlbmNlIHRoaXMgdXNlciBpbiBhbiBldmVudFxuICAgKiBAcmV0dXJucyB7TkRLVGFnW119IGFuIGFycmF5IG9mIE5ES1RhZ1xuICAgKi9cbiAgcmVmZXJlbmNlVGFncyhtYXJrZXIpIHtcbiAgICBjb25zdCB0YWcgPSBbW1wicFwiLCB0aGlzLnB1YmtleV1dO1xuICAgIGlmICghbWFya2VyKSByZXR1cm4gdGFnO1xuICAgIHRhZ1swXS5wdXNoKFwiXCIsIG1hcmtlcik7XG4gICAgcmV0dXJuIHRhZztcbiAgfVxuICAvKipcbiAgICogUHVibGlzaGVzIHRoZSBjdXJyZW50IHByb2ZpbGUuXG4gICAqL1xuICBhc3luYyBwdWJsaXNoKCkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICBpZiAoIXRoaXMucHJvZmlsZSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gcHJvZmlsZSBhdmFpbGFibGVcIik7XG4gICAgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IDAsXG4gICAgICBjb250ZW50OiBzZXJpYWxpemVQcm9maWxlKHRoaXMucHJvZmlsZSlcbiAgICB9KTtcbiAgICBhd2FpdCBldmVudC5wdWJsaXNoKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIGZvbGxvdyB0byB0aGlzIHVzZXIncyBjb250YWN0IGxpc3RcbiAgICpcbiAgICogQHBhcmFtIG5ld0ZvbGxvdyB7TkRLVXNlcn0gVGhlIHVzZXIgdG8gZm9sbG93XG4gICAqIEBwYXJhbSBjdXJyZW50Rm9sbG93TGlzdCB7U2V0PE5ES1VzZXI+fSBUaGUgY3VycmVudCBmb2xsb3cgbGlzdFxuICAgKiBAcGFyYW0ga2luZCB7TkRLS2luZH0gVGhlIGtpbmQgdG8gdXNlIGZvciB0aGlzIGNvbnRhY3QgbGlzdCAoZGVmYXVsdHMgdG8gYDNgKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gVHJ1ZSBpZiB0aGUgZm9sbG93IHdhcyBhZGRlZCwgZmFsc2UgaWYgdGhlIGZvbGxvdyBhbHJlYWR5IGV4aXN0c1xuICAgKi9cbiAgYXN5bmMgZm9sbG93KG5ld0ZvbGxvdywgY3VycmVudEZvbGxvd0xpc3QsIGtpbmQgPSAzIC8qIENvbnRhY3RzICovKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGlmICghY3VycmVudEZvbGxvd0xpc3QpIHtcbiAgICAgIGN1cnJlbnRGb2xsb3dMaXN0ID0gYXdhaXQgdGhpcy5mb2xsb3dzKHZvaWQgMCwgdm9pZCAwLCBraW5kKTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRGb2xsb3dMaXN0LmhhcyhuZXdGb2xsb3cpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGN1cnJlbnRGb2xsb3dMaXN0LmFkZChuZXdGb2xsb3cpO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KHRoaXMubmRrLCB7IGtpbmQgfSk7XG4gICAgZm9yIChjb25zdCBmb2xsb3cgb2YgY3VycmVudEZvbGxvd0xpc3QpIHtcbiAgICAgIGV2ZW50LnRhZyhmb2xsb3cpO1xuICAgIH1cbiAgICBhd2FpdCBldmVudC5wdWJsaXNoKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGZvbGxvdyBmcm9tIHRoaXMgdXNlcidzIGNvbnRhY3QgbGlzdFxuICAgKlxuICAgKiBAcGFyYW0gdXNlciB7TkRLVXNlcn0gVGhlIHVzZXIgdG8gdW5mb2xsb3dcbiAgICogQHBhcmFtIGN1cnJlbnRGb2xsb3dMaXN0IHtTZXQ8TkRLVXNlcj59IFRoZSBjdXJyZW50IGZvbGxvdyBsaXN0XG4gICAqIEBwYXJhbSBraW5kIHtOREtLaW5kfSBUaGUga2luZCB0byB1c2UgZm9yIHRoaXMgY29udGFjdCBsaXN0IChkZWZhdWx0cyB0byBgM2ApXG4gICAqIEByZXR1cm5zIFRoZSByZWxheXMgd2VyZSB0aGUgZm9sbG93IGxpc3Qgd2FzIHB1Ymxpc2hlZCBvciBmYWxzZSBpZiB0aGUgdXNlciB3YXNuJ3QgZm91bmRcbiAgICovXG4gIGFzeW5jIHVuZm9sbG93KHVzZXIsIGN1cnJlbnRGb2xsb3dMaXN0LCBraW5kID0gMyAvKiBDb250YWN0cyAqLykge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBpZiAoIWN1cnJlbnRGb2xsb3dMaXN0KSB7XG4gICAgICBjdXJyZW50Rm9sbG93TGlzdCA9IGF3YWl0IHRoaXMuZm9sbG93cyh2b2lkIDAsIHZvaWQgMCwga2luZCk7XG4gICAgfVxuICAgIGNvbnN0IG5ld1VzZXJGb2xsb3dMaXN0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgZm91bmRVc2VyID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBmb2xsb3cgb2YgY3VycmVudEZvbGxvd0xpc3QpIHtcbiAgICAgIGlmIChmb2xsb3cucHVia2V5ICE9PSB1c2VyLnB1YmtleSkge1xuICAgICAgICBuZXdVc2VyRm9sbG93TGlzdC5hZGQoZm9sbG93KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kVXNlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm91bmRVc2VyKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHsga2luZCB9KTtcbiAgICBmb3IgKGNvbnN0IGZvbGxvdyBvZiBuZXdVc2VyRm9sbG93TGlzdCkge1xuICAgICAgZXZlbnQudGFnKGZvbGxvdyk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBldmVudC5wdWJsaXNoKCk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGEgdXNlcidzIE5JUC0wNSBpZGVudGlmaWVyICh1c3VhbGx5IGZldGNoZWQgZnJvbSB0aGVpciBraW5kOjAgcHJvZmlsZSBkYXRhKVxuICAgKlxuICAgKiBAcGFyYW0gbmlwMDVJZCBUaGUgTklQLTA1IHN0cmluZyB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuIHwgbnVsbD59IFRydWUgaWYgdGhlIE5JUC0wNSBpcyBmb3VuZCBhbmQgbWF0Y2hlcyB0aGlzIHVzZXIncyBwdWJrZXksXG4gICAqIEZhbHNlIGlmIHRoZSBOSVAtMDUgaXMgZm91bmQgYnV0IGRvZXNuJ3QgbWF0Y2ggdGhpcyB1c2VyJ3MgcHVia2V5LFxuICAgKiBudWxsIGlmIHRoZSBOSVAtMDUgaXNuJ3QgZm91bmQgb24gdGhlIGRvbWFpbiBvciB3ZSdyZSB1bmFibGUgdG8gdmVyaWZ5IChiZWNhdXNlIG9mIG5ldHdvcmsgaXNzdWVzLCBldGMuKVxuICAgKi9cbiAgYXN5bmMgdmFsaWRhdGVOaXAwNShuaXAwNUlkKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIGNvbnN0IHByb2ZpbGVQb2ludGVyID0gYXdhaXQgZ2V0TmlwMDVGb3IodGhpcy5uZGssIG5pcDA1SWQpO1xuICAgIGlmIChwcm9maWxlUG9pbnRlciA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHByb2ZpbGVQb2ludGVyLnB1YmtleSA9PT0gdGhpcy5wdWJrZXk7XG4gIH1cbn07XG5cbi8vIHNyYy91c2VyL3Bpbi50c1xuYXN5bmMgZnVuY3Rpb24gcGluRXZlbnQodXNlciwgZXZlbnQsIHBpbkV2ZW50MiwgcHVibGlzaCkge1xuICBjb25zdCBraW5kID0gMTAwMDEgLyogUGluTGlzdCAqLztcbiAgaWYgKCF1c2VyLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICB1c2VyLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgaWYgKCFwaW5FdmVudDIpIHtcbiAgICBjb25zdCBldmVudHMgPSBhd2FpdCB1c2VyLm5kay5mZXRjaEV2ZW50cyhcbiAgICAgIHsga2luZHM6IFtraW5kXSwgYXV0aG9yczogW3VzZXIucHVia2V5XSB9LFxuICAgICAgeyBjYWNoZVVzYWdlOiBcIk9OTFlfUkVMQVlcIiAvKiBPTkxZX1JFTEFZICovIH1cbiAgICApO1xuICAgIGlmIChldmVudHMuc2l6ZSA+IDApIHtcbiAgICAgIHBpbkV2ZW50MiA9IGxpc3RzX2RlZmF1bHQuZnJvbShBcnJheS5mcm9tKGV2ZW50cylbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwaW5FdmVudDIgPSBuZXcgTkRLRXZlbnQodXNlci5uZGssIHtcbiAgICAgICAga2luZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHBpbkV2ZW50Mi50YWcoZXZlbnQpO1xuICBpZiAocHVibGlzaCkge1xuICAgIGF3YWl0IHBpbkV2ZW50Mi5wdWJsaXNoKCk7XG4gIH1cbiAgcmV0dXJuIHBpbkV2ZW50Mjtcbn1cblxuLy8gc3JjL2V2ZW50cy9raW5kcy9jbGFzc2lmaWVkLnRzXG52YXIgTkRLQ2xhc3NpZmllZCA9IGNsYXNzIF9OREtDbGFzc2lmaWVkIGV4dGVuZHMgTkRLRXZlbnQge1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzMDQwMiAvKiBDbGFzc2lmaWVkICovO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTkRLQ2xhc3NpZmllZCBmcm9tIGFuIGV4aXN0aW5nIE5ES0V2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgTkRLRXZlbnQgdG8gY3JlYXRlIHRoZSBOREtDbGFzc2lmaWVkIGZyb20uXG4gICAqIEByZXR1cm5zIE5ES0NsYXNzaWZpZWRcbiAgICovXG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLQ2xhc3NpZmllZChldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCB0aXRsZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gLSBUaGUgY2xhc3NpZmllZCB0aXRsZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgdGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ0aXRsZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCB0aXRsZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHRpdGxlIC0gVGhlIHRpdGxlIHRvIHNldCBmb3IgdGhlIGNsYXNzaWZpZWQuXG4gICAqL1xuICBzZXQgdGl0bGUodGl0bGUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInRpdGxlXCIpO1xuICAgIGlmICh0aXRsZSkgdGhpcy50YWdzLnB1c2goW1widGl0bGVcIiwgdGl0bGVdKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCBzdW1tYXJ5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBjbGFzc2lmaWVkIHN1bW1hcnkgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHN1bW1hcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJzdW1tYXJ5XCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIHN1bW1hcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBzdW1tYXJ5IC0gVGhlIHN1bW1hcnkgdG8gc2V0IGZvciB0aGUgY2xhc3NpZmllZC5cbiAgICovXG4gIHNldCBzdW1tYXJ5KHN1bW1hcnkpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInN1bW1hcnlcIik7XG4gICAgaWYgKHN1bW1hcnkpIHRoaXMudGFncy5wdXNoKFtcInN1bW1hcnlcIiwgc3VtbWFyeV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkJ3MgcHVibGljYXRpb24gdGltZXN0YW1wLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfSAtIFRoZSBVbml4IHRpbWVzdGFtcCBvZiB3aGVuIHRoZSBjbGFzc2lmaWVkIHdhcyBwdWJsaXNoZWQgb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHB1Ymxpc2hlZF9hdCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwicHVibGlzaGVkX2F0XCIpO1xuICAgIGlmICh0YWcpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQodGFnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCdzIHB1YmxpY2F0aW9uIHRpbWVzdGFtcC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IHRpbWVzdGFtcCAtIFRoZSBVbml4IHRpbWVzdGFtcCB0byBzZXQgZm9yIHRoZSBjbGFzc2lmaWVkJ3MgcHVibGljYXRpb24gZGF0ZS5cbiAgICovXG4gIHNldCBwdWJsaXNoZWRfYXQodGltZXN0YW1wKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwdWJsaXNoZWRfYXRcIik7XG4gICAgaWYgKHRpbWVzdGFtcCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwdWJsaXNoZWRfYXRcIiwgdGltZXN0YW1wLnRvU3RyaW5nKCldKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgbG9jYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGNsYXNzaWZpZWQgbG9jYXRpb24gaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IGxvY2F0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwibG9jYXRpb25cIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgbG9jYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiB0byBzZXQgZm9yIHRoZSBjbGFzc2lmaWVkLlxuICAgKi9cbiAgc2V0IGxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJsb2NhdGlvblwiKTtcbiAgICBpZiAobG9jYXRpb24pIHRoaXMudGFncy5wdXNoKFtcImxvY2F0aW9uXCIsIGxvY2F0aW9uXSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgcHJpY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtOREtDbGFzc2lmaWVkUHJpY2VUYWcgfCB1bmRlZmluZWR9IC0gVGhlIGNsYXNzaWZpZWQgcHJpY2UgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHByaWNlKCkge1xuICAgIGNvbnN0IHByaWNlVGFnID0gdGhpcy50YWdzLmZpbmQoKHRhZykgPT4gdGFnWzBdID09PSBcInByaWNlXCIpO1xuICAgIGlmIChwcmljZVRhZykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYW1vdW50OiBOdW1iZXIucGFyc2VGbG9hdChwcmljZVRhZ1sxXSksXG4gICAgICAgIGN1cnJlbmN5OiBwcmljZVRhZ1syXSxcbiAgICAgICAgZnJlcXVlbmN5OiBwcmljZVRhZ1szXVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCBwcmljZS5cbiAgICpcbiAgICogQHBhcmFtIHByaWNlIC0gVGhlIHByaWNlIHRvIHNldCBmb3IgdGhlIGNsYXNzaWZpZWQuXG4gICAqL1xuICBzZXQgcHJpY2UocHJpY2VUYWcpIHtcbiAgICBpZiAodHlwZW9mIHByaWNlVGFnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwcmljZVRhZyA9IHtcbiAgICAgICAgYW1vdW50OiBOdW1iZXIucGFyc2VGbG9hdChwcmljZVRhZylcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChwcmljZVRhZz8uYW1vdW50KSB7XG4gICAgICBjb25zdCB0YWcgPSBbXCJwcmljZVwiLCBwcmljZVRhZy5hbW91bnQudG9TdHJpbmcoKV07XG4gICAgICBpZiAocHJpY2VUYWcuY3VycmVuY3kpIHRhZy5wdXNoKHByaWNlVGFnLmN1cnJlbmN5KTtcbiAgICAgIGlmIChwcmljZVRhZy5mcmVxdWVuY3kpIHRhZy5wdXNoKHByaWNlVGFnLmZyZXF1ZW5jeSk7XG4gICAgICB0aGlzLnRhZ3MucHVzaCh0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZVRhZyhcInByaWNlXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvbnRlbnQgdGFncyBmb3IgdGhlIGNsYXNzaWZpZWQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGZpcnN0IGNoZWNrcyBhbmQgc2V0cyB0aGUgcHVibGljYXRpb24gZGF0ZSBpZiBub3QgYXZhaWxhYmxlLFxuICAgKiBhbmQgdGhlbiBnZW5lcmF0ZXMgY29udGVudCB0YWdzIGJhc2VkIG9uIHRoZSBiYXNlIE5ES0V2ZW50IGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gLSBUaGUgZ2VuZXJhdGVkIGNvbnRlbnQgdGFncy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlVGFncygpIHtcbiAgICBzdXBlci5nZW5lcmF0ZVRhZ3MoKTtcbiAgICBpZiAoIXRoaXMucHVibGlzaGVkX2F0KSB7XG4gICAgICB0aGlzLnB1Ymxpc2hlZF9hdCA9IHRoaXMuY3JlYXRlZF9hdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2RyYWZ0cy50c1xudmFyIE5ES0RyYWZ0ID0gY2xhc3MgX05ES0RyYWZ0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBfZXZlbnQ7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMxMjM0IC8qIERyYWZ0ICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLRHJhZnQoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYW4gaWRlbnRpZmllciAoaS5lLiBkLXRhZylcbiAgICovXG4gIHNldCBpZGVudGlmaWVyKGlkKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImRcIiwgaWRdKTtcbiAgfVxuICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5kVGFnO1xuICB9XG4gIC8qKlxuICAgKiBFdmVudCB0aGF0IGlzIHRvIGJlIHNhdmVkLlxuICAgKi9cbiAgc2V0IGV2ZW50KGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIE5ES0V2ZW50KSB0aGlzLl9ldmVudCA9IGUucmF3RXZlbnQoKTtcbiAgICBlbHNlIHRoaXMuX2V2ZW50ID0gZTtcbiAgICB0aGlzLnByZXBhcmVFdmVudCgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBldmVudC5cbiAgICogQHBhcmFtIHBhcmFtMFxuICAgKiBAcmV0dXJucyBOREtFdmVudCBvZiB0aGUgZHJhZnQgZXZlbnQgb3IgbnVsbCBpZiB0aGUgZHJhZnQgZXZlbnQgaGFzIGJlZW4gZGVsZXRlZCAoZW1wdGllZCkuXG4gICAqL1xuICBhc3luYyBnZXRFdmVudChzaWduZXIpIHtcbiAgICBpZiAodGhpcy5fZXZlbnQpIHJldHVybiBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHRoaXMuX2V2ZW50KTtcbiAgICBzaWduZXIgPz89IHRoaXMubmRrPy5zaWduZXI7XG4gICAgaWYgKCFzaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHNpZ25lci51c2VyKCk7XG4gICAgaWYgKHRoaXMuY29udGVudCAmJiB0aGlzLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5kZWNyeXB0KHVzZXIsIHNpZ25lcik7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgICAgIHRoaXMuX2V2ZW50ID0gcGF5bG9hZDtcbiAgICAgICAgcmV0dXJuIG5ldyBOREtFdmVudCh0aGlzLm5kaywgcGF5bG9hZCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBwcmVwYXJlRXZlbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gZXZlbnQgaGFzIGJlZW4gcHJvdmlkZWRcIik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJrXCIpO1xuICAgIGlmICh0aGlzLl9ldmVudC5raW5kKSB0aGlzLnRhZ3MucHVzaChbXCJrXCIsIHRoaXMuX2V2ZW50LmtpbmQudG9TdHJpbmcoKV0pO1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHRoaXMuX2V2ZW50KTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGRyYWZ0IGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gc2lnbmVyOiBPcHRpb25hbCBzaWduZXIgdG8gZW5jcnlwdCB3aXRoXG4gICAqIEBwYXJhbSBwdWJsaXNoOiBXaGV0aGVyIHRvIHB1Ymxpc2gsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyByZWxheVNldCB0byBwdWJsaXNoIHRvXG4gICAqL1xuICBhc3luYyBzYXZlKHsgc2lnbmVyLCBwdWJsaXNoLCByZWxheVNldCB9KSB7XG4gICAgc2lnbmVyID8/PSB0aGlzLm5kaz8uc2lnbmVyO1xuICAgIGlmICghc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBzaWduZXIudXNlcigpO1xuICAgIGF3YWl0IHRoaXMuZW5jcnlwdCh1c2VyLCBzaWduZXIpO1xuICAgIGlmIChwdWJsaXNoID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2gocmVsYXlTZXQpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2R2bS9mZWVkYmFjay50c1xudmFyIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMyKSA9PiB7XG4gIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzMltcIlByb2Nlc3NpbmdcIl0gPSBcInByb2Nlc3NpbmdcIjtcbiAgTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMyW1wiU3VjY2Vzc1wiXSA9IFwic3VjY2Vzc1wiO1xuICBOREtEdm1Kb2JGZWVkYmFja1N0YXR1czJbXCJTY2hlZHVsZWRcIl0gPSBcInNjaGVkdWxlZFwiO1xuICBOREtEdm1Kb2JGZWVkYmFja1N0YXR1czJbXCJQYXlSZXFcIl0gPSBcInBheW1lbnRfcmVxdWlyZWRcIjtcbiAgcmV0dXJuIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzMjtcbn0pKE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzIHx8IHt9KTtcbnZhciBOREtEVk1Kb2JGZWVkYmFjayA9IGNsYXNzIF9OREtEVk1Kb2JGZWVkYmFjayBleHRlbmRzIE5ES0V2ZW50IHtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gN2UzIC8qIERWTUpvYkZlZWRiYWNrICovO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tKGV2ZW50KSB7XG4gICAgY29uc3QgZSA9IG5ldyBfTkRLRFZNSm9iRmVlZGJhY2soZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgICBpZiAoZS5lbmNyeXB0ZWQpIGF3YWl0IGUuZHZtRGVjcnlwdCgpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJzdGF0dXNcIik7XG4gIH1cbiAgc2V0IHN0YXR1cyhzdGF0dXMpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInN0YXR1c1wiKTtcbiAgICBpZiAoc3RhdHVzICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInN0YXR1c1wiLCBzdGF0dXNdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGVuY3J5cHRlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldE1hdGNoaW5nVGFncyhcImVuY3J5cHRlZFwiKVswXTtcbiAgfVxuICBhc3luYyBkdm1EZWNyeXB0KCkge1xuICAgIGF3YWl0IHRoaXMuZGVjcnlwdCgpO1xuICAgIGNvbnN0IGRlY3J5cHRlZENvbnRlbnQgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgdGhpcy50YWdzLnB1c2goLi4uZGVjcnlwdGVkQ29udGVudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvZHZtL3JlcXVlc3QudHNcbnZhciBOREtEVk1SZXF1ZXN0ID0gY2xhc3MgX05ES0RWTVJlcXVlc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLRFZNUmVxdWVzdChldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIHNldCBiaWQobXNhdEFtb3VudCkge1xuICAgIGlmIChtc2F0QW1vdW50ID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVtb3ZlVGFnKFwiYmlkXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJiaWRcIiwgbXNhdEFtb3VudC50b1N0cmluZygpXSk7XG4gICAgfVxuICB9XG4gIGdldCBiaWQoKSB7XG4gICAgY29uc3QgdiA9IHRoaXMudGFnVmFsdWUoXCJiaWRcIik7XG4gICAgaWYgKHYgPT09IHZvaWQgMCkgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHYpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGlucHV0IHRvIHRoZSBqb2JcbiAgICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3VtZW50cyB0byB0aGUgaW5wdXRcbiAgICovXG4gIGFkZElucHV0KC4uLmFyZ3MpIHtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJpXCIsIC4uLmFyZ3NdKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG5ldyBwYXJhbWV0ZXIgdG8gdGhlIGpvYlxuICAgKi9cbiAgYWRkUGFyYW0oLi4uYXJncykge1xuICAgIHRoaXMudGFncy5wdXNoKFtcInBhcmFtXCIsIC4uLmFyZ3NdKTtcbiAgfVxuICBzZXQgb3V0cHV0KG91dHB1dCkge1xuICAgIGlmIChvdXRwdXQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW1vdmVUYWcoXCJvdXRwdXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygb3V0cHV0ID09PSBcInN0cmluZ1wiKSBvdXRwdXQgPSBbb3V0cHV0XTtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcIm91dHB1dFwiLCAuLi5vdXRwdXRdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG91dHB1dCgpIHtcbiAgICBjb25zdCBvdXRwdXRUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcIm91dHB1dFwiKVswXTtcbiAgICByZXR1cm4gb3V0cHV0VGFnID8gb3V0cHV0VGFnLnNsaWNlKDEpIDogdm9pZCAwO1xuICB9XG4gIGdldCBwYXJhbXMoKSB7XG4gICAgY29uc3QgcGFyYW1UYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwYXJhbVwiKTtcbiAgICByZXR1cm4gcGFyYW1UYWdzLm1hcCgodCkgPT4gdC5zbGljZSgxKSk7XG4gIH1cbiAgZ2V0UGFyYW0obmFtZSkge1xuICAgIGNvbnN0IHBhcmFtVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwYXJhbVwiKS5maW5kKCh0KSA9PiB0WzFdID09PSBuYW1lKTtcbiAgICByZXR1cm4gcGFyYW1UYWcgPyBwYXJhbVRhZ1syXSA6IHZvaWQgMDtcbiAgfVxuICBjcmVhdGVGZWVkYmFjayhzdGF0dXMpIHtcbiAgICBjb25zdCBmZWVkYmFjayA9IG5ldyBOREtEVk1Kb2JGZWVkYmFjayh0aGlzLm5kayk7XG4gICAgZmVlZGJhY2sudGFnKHRoaXMsIFwiam9iXCIpO1xuICAgIGZlZWRiYWNrLnN0YXR1cyA9IHN0YXR1cztcbiAgICByZXR1cm4gZmVlZGJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgam9iIGVuY3J5cHRpb24gZm9yIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIGR2bSBEVk0gdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBzaWduZXIgU2lnbmVyIHRvIHVzZSBmb3IgZW5jcnlwdGlvblxuICAgKi9cbiAgYXN5bmMgZW5jcnlwdGlvbihkdm0sIHNpZ25lcikge1xuICAgIGNvbnN0IGR2bVRhZ3MgPSBbXCJpXCIsIFwicGFyYW1cIiwgXCJvdXRwdXRcIiwgXCJyZWxheXNcIiwgXCJiaWRcIl07XG4gICAgY29uc3QgdGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+IGR2bVRhZ3MuaW5jbHVkZXModFswXSkpO1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+ICFkdm1UYWdzLmluY2x1ZGVzKHRbMF0pKTtcbiAgICB0aGlzLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0YWdzKTtcbiAgICB0aGlzLnRhZyhkdm0pO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImVuY3J5cHRlZFwiXSk7XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0KGR2bSwgc2lnbmVyKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgRFZNIHRoYXQgd2lsbCByZWNlaXZlIHRoZSBldmVudFxuICAgKi9cbiAgc2V0IGR2bShkdm0pIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInBcIik7XG4gICAgaWYgKGR2bSkgdGhpcy50YWcoZHZtKTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9kdm0vTkRLVHJhbnNjcmlwdGlvbkRWTS50c1xudmFyIE5ES1RyYW5zY3JpcHRpb25EVk0gPSBjbGFzcyBfTkRLVHJhbnNjcmlwdGlvbkRWTSBleHRlbmRzIE5ES0RWTVJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIobmRrLCBldmVudCk7XG4gICAgdGhpcy5raW5kID0gNWUzIC8qIERWTVJlcVRleHRFeHRyYWN0aW9uICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLVHJhbnNjcmlwdGlvbkRWTShldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2Ugb2YgdGhlIHRyYW5zY3JpcHRpb25cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgY29uc3QgaW5wdXRUYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJpXCIpO1xuICAgIGlmIChpbnB1dFRhZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRUYWdzWzBdWzFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSB0aXRsZSB0YWdcbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSB0aXRsZSB0YWdcbiAgICovXG4gIHNldCB0aXRsZSh2YWx1ZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB2YWx1ZV0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgaW1hZ2UgdGFnXG4gICAqL1xuICBnZXQgaW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJpbWFnZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgaW1hZ2UgdGFnXG4gICAqL1xuICBzZXQgaW1hZ2UodmFsdWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImltYWdlXCIpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiaW1hZ2VcIiwgdmFsdWVdKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvZHZtL3Jlc3VsdC50c1xudmFyIE5ES0RWTUpvYlJlc3VsdCA9IGNsYXNzIF9OREtEVk1Kb2JSZXN1bHQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLRFZNSm9iUmVzdWx0KGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgc2V0QW1vdW50KG1zYXQsIGludm9pY2UpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImFtb3VudFwiKTtcbiAgICBjb25zdCB0YWcgPSBbXCJhbW91bnRcIiwgbXNhdC50b1N0cmluZygpXTtcbiAgICBpZiAoaW52b2ljZSkgdGFnLnB1c2goaW52b2ljZSk7XG4gICAgdGhpcy50YWdzLnB1c2godGFnKTtcbiAgfVxuICBzZXQgcmVzdWx0KHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5jb250ZW50ID0gXCJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250ZW50ID0gcmVzdWx0O1xuICAgIH1cbiAgfVxuICBnZXQgcmVzdWx0KCkge1xuICAgIGlmICh0aGlzLmNvbnRlbnQgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gIH1cbiAgc2V0IHN0YXR1cyhzdGF0dXMpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInN0YXR1c1wiKTtcbiAgICBpZiAoc3RhdHVzICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInN0YXR1c1wiLCBzdGF0dXNdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInN0YXR1c1wiKTtcbiAgfVxuICBnZXQgam9iUmVxdWVzdElkKCkge1xuICAgIGZvciAoY29uc3QgZVRhZyBvZiB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIikpIHtcbiAgICAgIGlmIChlVGFnWzJdID09PSBcImpvYlwiKSByZXR1cm4gZVRhZ1sxXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuam9iUmVxdWVzdCkgcmV0dXJuIHRoaXMuam9iUmVxdWVzdC5pZDtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImVcIik7XG4gIH1cbiAgc2V0IGpvYlJlcXVlc3QoZXZlbnQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInJlcXVlc3RcIik7XG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICB0aGlzLmtpbmQgPSBldmVudC5raW5kICsgMWUzO1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicmVxdWVzdFwiLCBKU09OLnN0cmluZ2lmeShldmVudC5yYXdFdmVudCgpKV0pO1xuICAgICAgdGhpcy50YWcoZXZlbnQpO1xuICAgIH1cbiAgfVxuICBnZXQgam9iUmVxdWVzdCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwicmVxdWVzdFwiKTtcbiAgICBpZiAodGFnID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTkRLRXZlbnQodGhpcy5uZGssIEpTT04ucGFyc2UodGFnKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvY2FzaHUvdHgudHNcbnZhciBNQVJLRVJTID0ge1xuICBSRURFRU1FRDogXCJyZWRlZW1lZFwiLFxuICBDUkVBVEVEOiBcImNyZWF0ZWRcIixcbiAgREVTVFJPWUVEOiBcImRlc3Ryb3llZFwiLFxuICBSRVNFUlZFRDogXCJyZXNlcnZlZFwiXG59O1xudmFyIE5ES0Nhc2h1V2FsbGV0VHggPSBjbGFzcyBfTkRLQ2FzaHVXYWxsZXRUeCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIE1BUktFUlMgPSBNQVJLRVJTO1xuICBzdGF0aWMga2luZCA9IDczNzYgLyogQ2FzaHVXYWxsZXRUeCAqLztcbiAgc3RhdGljIGtpbmRzID0gWzczNzYgLyogQ2FzaHVXYWxsZXRUeCAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcihuZGssIGV2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDczNzYgLyogQ2FzaHVXYWxsZXRUeCAqLztcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbShldmVudCkge1xuICAgIGNvbnN0IHdhbGxldENoYW5nZSA9IG5ldyBfTkRLQ2FzaHVXYWxsZXRUeChldmVudC5uZGssIGV2ZW50KTtcbiAgICBjb25zdCBwcmV2Q29udGVudCA9IHdhbGxldENoYW5nZS5jb250ZW50O1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB3YWxsZXRDaGFuZ2UuZGVjcnlwdCgpO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICB3YWxsZXRDaGFuZ2UuY29udGVudCA/Pz0gcHJldkNvbnRlbnQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb250ZW50VGFncyA9IEpTT04ucGFyc2Uod2FsbGV0Q2hhbmdlLmNvbnRlbnQpO1xuICAgICAgd2FsbGV0Q2hhbmdlLnRhZ3MgPSBbLi4uY29udGVudFRhZ3MsIC4uLndhbGxldENoYW5nZS50YWdzXTtcbiAgICB9IGNhdGNoIChfZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gd2FsbGV0Q2hhbmdlO1xuICB9XG4gIHNldCBkaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkaXJlY3Rpb25cIik7XG4gICAgaWYgKGRpcmVjdGlvbikgdGhpcy50YWdzLnB1c2goW1wiZGlyZWN0aW9uXCIsIGRpcmVjdGlvbl0pO1xuICB9XG4gIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJkaXJlY3Rpb25cIik7XG4gIH1cbiAgc2V0IGFtb3VudChhbW91bnQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImFtb3VudFwiKTtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJhbW91bnRcIiwgYW1vdW50LnRvU3RyaW5nKCldKTtcbiAgfVxuICBnZXQgYW1vdW50KCkge1xuICAgIGNvbnN0IHZhbCA9IHRoaXMudGFnVmFsdWUoXCJhbW91bnRcIik7XG4gICAgaWYgKHZhbCA9PT0gdm9pZCAwKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBOdW1iZXIodmFsKTtcbiAgfVxuICBzZXQgZmVlKGZlZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZmVlXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImZlZVwiLCBmZWUudG9TdHJpbmcoKV0pO1xuICB9XG4gIGdldCBmZWUoKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy50YWdWYWx1ZShcImZlZVwiKTtcbiAgICBpZiAodmFsID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIE51bWJlcih2YWwpO1xuICB9XG4gIHNldCB1bml0KHVuaXQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInVuaXRcIik7XG4gICAgaWYgKHVuaXQpIHRoaXMudGFncy5wdXNoKFtcInVuaXRcIiwgdW5pdC50b1N0cmluZygpXSk7XG4gIH1cbiAgZ2V0IHVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ1bml0XCIpO1xuICB9XG4gIHNldCBkZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZGVzY3JpcHRpb25cIik7XG4gICAgaWYgKGRlc2NyaXB0aW9uKSB0aGlzLnRhZ3MucHVzaChbXCJkZXNjcmlwdGlvblwiLCBkZXNjcmlwdGlvbi50b1N0cmluZygpXSk7XG4gIH1cbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZGVzY3JpcHRpb25cIik7XG4gIH1cbiAgc2V0IG1pbnQobWludCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwibWludFwiKTtcbiAgICBpZiAobWludCkgdGhpcy50YWdzLnB1c2goW1wibWludFwiLCBtaW50LnRvU3RyaW5nKCldKTtcbiAgfVxuICBnZXQgbWludCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcIm1pbnRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFRhZ3MgdG9rZW5zIHRoYXQgd2VyZSBjcmVhdGVkIGluIHRoaXMgaGlzdG9yeSBldmVudFxuICAgKi9cbiAgc2V0IGRlc3Ryb3llZFRva2VucyhldmVudHMpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goZXZlbnQudGFnUmVmZXJlbmNlKE1BUktFUlMuREVTVFJPWUVEKSk7XG4gICAgfVxuICB9XG4gIHNldCBkZXN0cm95ZWRUb2tlbklkcyhpZHMpIHtcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiZVwiLCBpZCwgXCJcIiwgTUFSS0VSUy5ERVNUUk9ZRURdKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRhZ3MgdG9rZW5zIHRoYXQgd2VyZSBjcmVhdGVkIGluIHRoaXMgaGlzdG9yeSBldmVudFxuICAgKi9cbiAgc2V0IGNyZWF0ZWRUb2tlbnMoZXZlbnRzKSB7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKGV2ZW50LnRhZ1JlZmVyZW5jZShNQVJLRVJTLkNSRUFURUQpKTtcbiAgICB9XG4gIH1cbiAgc2V0IHJlc2VydmVkVG9rZW5zKGV2ZW50cykge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChldmVudC50YWdSZWZlcmVuY2UoTUFSS0VSUy5SRVNFUlZFRCkpO1xuICAgIH1cbiAgfVxuICBhZGRSZWRlZW1lZE51dHphcChldmVudCkge1xuICAgIHRoaXMudGFnKGV2ZW50LCBNQVJLRVJTLlJFREVFTUVEKTtcbiAgfVxuICBhc3luYyB0b05vc3RyRXZlbnQocHVia2V5KSB7XG4gICAgY29uc3QgZW5jcnlwdGVkVGFncyA9IFtdO1xuICAgIGNvbnN0IHVuZW5jcnlwdGVkVGFncyA9IFtdO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgaWYgKCF0aGlzLnNob3VsZEVuY3J5cHRUYWcodGFnKSkge1xuICAgICAgICB1bmVuY3J5cHRlZFRhZ3MucHVzaCh0YWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5jcnlwdGVkVGFncy5wdXNoKHRhZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudGFncyA9IHVuZW5jcnlwdGVkVGFncy5maWx0ZXIoKHQpID0+IHRbMF0gIT09IFwiY2xpZW50XCIpO1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGVuY3J5cHRlZFRhZ3MpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5kaz8uc2lnbmVyPy51c2VyKCk7XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIsIHZvaWQgMCwgXCJuaXA0NFwiKTtcbiAgICByZXR1cm4gc3VwZXIudG9Ob3N0ckV2ZW50KHB1YmtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBlbnRyeSBpbmNsdWRlcyBhIHJlZGVtcHRpb24gb2YgYSBOdXR6YXBcbiAgICovXG4gIGdldCBoYXNOdXR6YXBSZWRlbXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIiwgTUFSS0VSUy5SRURFRU1FRCkubGVuZ3RoID4gMDtcbiAgfVxuICBzaG91bGRFbmNyeXB0VGFnKHRhZykge1xuICAgIGNvbnN0IHVuZW5jcnlwdGVkVGFnTmFtZXMgPSBbXCJjbGllbnRcIl07XG4gICAgaWYgKHVuZW5jcnlwdGVkVGFnTmFtZXMuaW5jbHVkZXModGFnWzBdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiB0YWdbM10gPT09IE1BUktFUlMuUkVERUVNRUQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRhZ1swXSA9PT0gXCJwXCIpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9OREtSZWxheUxpc3QudHNcbnZhciBSRUFEX01BUktFUiA9IFwicmVhZFwiO1xudmFyIFdSSVRFX01BUktFUiA9IFwid3JpdGVcIjtcbnZhciBOREtSZWxheUxpc3QgPSBjbGFzcyBfTkRLUmVsYXlMaXN0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAxMDAwMiAvKiBSZWxheUxpc3QgKi87XG4gIH1cbiAgc3RhdGljIGZyb20obmRrRXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtSZWxheUxpc3QobmRrRXZlbnQubmRrLCBuZGtFdmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICBnZXQgcmVhZFJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiclwiIHx8IHRhZ1swXSA9PT0gXCJyZWxheVwiKS5maWx0ZXIoKHRhZykgPT4gIXRhZ1syXSB8fCB0YWdbMl0gJiYgdGFnWzJdID09PSBSRUFEX01BUktFUikubWFwKCh0YWcpID0+IHRyeU5vcm1hbGl6ZVJlbGF5VXJsKHRhZ1sxXSkpLmZpbHRlcigodXJsKSA9PiAhIXVybCk7XG4gIH1cbiAgc2V0IHJlYWRSZWxheVVybHMocmVsYXlzKSB7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiByZWxheXMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInJcIiwgcmVsYXksIFJFQURfTUFSS0VSXSk7XG4gICAgfVxuICB9XG4gIGdldCB3cml0ZVJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiclwiIHx8IHRhZ1swXSA9PT0gXCJyZWxheVwiKS5maWx0ZXIoKHRhZykgPT4gIXRhZ1syXSB8fCB0YWdbMl0gJiYgdGFnWzJdID09PSBXUklURV9NQVJLRVIpLm1hcCgodGFnKSA9PiB0cnlOb3JtYWxpemVSZWxheVVybCh0YWdbMV0pKS5maWx0ZXIoKHVybCkgPT4gISF1cmwpO1xuICB9XG4gIHNldCB3cml0ZVJlbGF5VXJscyhyZWxheXMpIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHJlbGF5cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiclwiLCByZWxheSwgV1JJVEVfTUFSS0VSXSk7XG4gICAgfVxuICB9XG4gIGdldCBib3RoUmVsYXlVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJyXCIgfHwgdGFnWzBdID09PSBcInJlbGF5XCIpLmZpbHRlcigodGFnKSA9PiAhdGFnWzJdKS5tYXAoKHRhZykgPT4gdGFnWzFdKTtcbiAgfVxuICBzZXQgYm90aFJlbGF5VXJscyhyZWxheXMpIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHJlbGF5cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiclwiLCByZWxheV0pO1xuICAgIH1cbiAgfVxuICBnZXQgcmVsYXlzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJyXCIgfHwgdGFnWzBdID09PSBcInJlbGF5XCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICB9XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIHJlbGF5U2V0IGZvciB0aGUgcmVsYXlzIGluIHRoaXMgbGlzdC5cbiAgICovXG4gIGdldCByZWxheVNldCgpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREtSZWxheUxpc3QgaGFzIG5vIE5ESyBpbnN0YW5jZVwiKTtcbiAgICByZXR1cm4gbmV3IE5ES1JlbGF5U2V0KFxuICAgICAgbmV3IFNldCh0aGlzLnJlbGF5cy5tYXAoKHUpID0+IHRoaXMubmRrPy5wb29sLmdldFJlbGF5KHUpKS5maWx0ZXIoKHIpID0+ICEhcikpLFxuICAgICAgdGhpcy5uZGtcbiAgICApO1xuICB9XG59O1xuZnVuY3Rpb24gcmVsYXlMaXN0RnJvbUtpbmQzKG5kaywgY29udGFjdExpc3QpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjb250ZW50ID0gSlNPTi5wYXJzZShjb250YWN0TGlzdC5jb250ZW50KTtcbiAgICBjb25zdCByZWxheUxpc3QgPSBuZXcgTkRLUmVsYXlMaXN0KG5kayk7XG4gICAgY29uc3QgcmVhZFJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgd3JpdGVSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IFtrZXksIGNvbmZpZ10gb2YgT2JqZWN0LmVudHJpZXMoY29udGVudCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZVJlbGF5VXJsKGtleSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICByZWFkUmVsYXlzLmFkZChrZXkpO1xuICAgICAgICB3cml0ZVJlbGF5cy5hZGQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlbGF5Q29uZmlnID0gY29uZmlnO1xuICAgICAgICBpZiAocmVsYXlDb25maWcud3JpdGUpIHdyaXRlUmVsYXlzLmFkZChrZXkpO1xuICAgICAgICBpZiAocmVsYXlDb25maWcucmVhZCkgcmVhZFJlbGF5cy5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVsYXlMaXN0LnJlYWRSZWxheVVybHMgPSBBcnJheS5mcm9tKHJlYWRSZWxheXMpO1xuICAgIHJlbGF5TGlzdC53cml0ZVJlbGF5VXJscyA9IEFycmF5LmZyb20od3JpdGVSZWxheXMpO1xuICAgIHJldHVybiByZWxheUxpc3Q7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvbmlwODkvYXBwLWhhbmRsZXIudHNcbnZhciBOREtBcHBIYW5kbGVyRXZlbnQgPSBjbGFzcyBfTkRLQXBwSGFuZGxlckV2ZW50IGV4dGVuZHMgTkRLRXZlbnQge1xuICBwcm9maWxlO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzMTk5MCAvKiBBcHBIYW5kbGVyICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKG5ka0V2ZW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgX05ES0FwcEhhbmRsZXJFdmVudChuZGtFdmVudC5uZGssIG5ka0V2ZW50LnJhd0V2ZW50KCkpO1xuICAgIGlmIChldmVudC5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIGNvbnN0IGNvbWJpbmF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgY29tYmluYXRpb25Gcm9tVGFnID0gKHRhZykgPT4gW3RhZ1swXSwgdGFnWzJdXS5qb2luKFwiOlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHRhZ3NUb0luc3BlY3QgPSBbXCJ3ZWJcIiwgXCJhbmRyb2lkXCIsIFwiaW9zXCJdO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgaWYgKHRhZ3NUb0luc3BlY3QuaW5jbHVkZXModGFnWzBdKSkge1xuICAgICAgICBjb25zdCBjb21iaW5hdGlvbiA9IGNvbWJpbmF0aW9uRnJvbVRhZyh0YWcpO1xuICAgICAgICBpZiAoY29tYmluYXRpb25zLmhhcyhjb21iaW5hdGlvbikpIHtcbiAgICAgICAgICBpZiAoY29tYmluYXRpb25zLmdldChjb21iaW5hdGlvbikgIT09IHRhZ1sxXS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbWJpbmF0aW9ucy5zZXQoY29tYmluYXRpb24sIHRhZ1sxXS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoZXMgYXBwIGhhbmRsZXIgaW5mb3JtYXRpb25cbiAgICogSWYgbm8gYXBwIGluZm9ybWF0aW9uIGlzIGF2YWlsYWJsZSBvbiB0aGUga2luZDozMTk5MCxcbiAgICogd2UgZmV0Y2ggdGhlIGV2ZW50J3MgYXV0aG9yJ3MgcHJvZmlsZSBhbmQgcmV0dXJuIHRoYXQgaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGZldGNoUHJvZmlsZSgpIHtcbiAgICBpZiAodGhpcy5wcm9maWxlID09PSB2b2lkIDAgJiYgdGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHByb2ZpbGUgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgICAgIGlmIChwcm9maWxlPy5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2ZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9maWxlID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICAgIHRoaXMucHJvZmlsZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBhdXRob3IgPSB0aGlzLmF1dGhvcjtcbiAgICAgIGF1dGhvci5mZXRjaFByb2ZpbGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShhdXRob3IucHJvZmlsZSk7XG4gICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3JlcG9zdC50c1xudmFyIE5ES1JlcG9zdCA9IGNsYXNzIF9OREtSZXBvc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIF9yZXBvc3RlZEV2ZW50cztcbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtSZXBvc3QoZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgcmVwb3N0ZWQgZXZlbnRzIGJ5IHRoZSBjdXJyZW50IGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ga2xhc3MgT3B0aW9uYWwgY2xhc3MgdG8gY29udmVydCB0aGUgZXZlbnRzIHRvLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgcmVwb3N0ZWRFdmVudHMoa2xhc3MsIG9wdHMpIHtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3Qgc2V0XCIpO1xuICAgIGlmICh0aGlzLl9yZXBvc3RlZEV2ZW50cyAhPT0gdm9pZCAwKSByZXR1cm4gdGhpcy5fcmVwb3N0ZWRFdmVudHM7XG4gICAgZm9yIChjb25zdCBldmVudElkIG9mIHRoaXMucmVwb3N0ZWRFdmVudElkcygpKSB7XG4gICAgICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJGb3JJZChldmVudElkKTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudChmaWx0ZXIsIG9wdHMpO1xuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGl0ZW1zLnB1c2goa2xhc3MgPyBrbGFzcy5mcm9tKGV2ZW50KSA6IGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXBvc3RlZCBldmVudCBJRHMuXG4gICAqL1xuICByZXBvc3RlZEV2ZW50SWRzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0KSA9PiB0WzBdID09PSBcImVcIiB8fCB0WzBdID09PSBcImFcIikubWFwKCh0KSA9PiB0WzFdKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZpbHRlckZvcklkKGlkKSB7XG4gIGlmIChpZC5tYXRjaCgvOi8pKSB7XG4gICAgY29uc3QgW2tpbmQsIHB1YmtleSwgaWRlbnRpZmllcl0gPSBpZC5zcGxpdChcIjpcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmRzOiBbTnVtYmVyLnBhcnNlSW50KGtpbmQpXSxcbiAgICAgIGF1dGhvcnM6IFtwdWJrZXldLFxuICAgICAgXCIjZFwiOiBbaWRlbnRpZmllcl1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7IGlkczogW2lkXSB9O1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3N1YnNjcmlwdGlvbnMvcmVjZWlwdC50c1xuaW1wb3J0IGRlYnVnMyBmcm9tIFwiZGVidWdcIjtcbnZhciBOREtTdWJzY3JpcHRpb25SZWNlaXB0ID0gY2xhc3MgX05ES1N1YnNjcmlwdGlvblJlY2VpcHQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGRlYnVnO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSA3MDAzIC8qIFN1YnNjcmlwdGlvblJlY2VpcHQgKi87XG4gICAgdGhpcy5kZWJ1ZyA9IG5kaz8uZGVidWcuZXh0ZW5kKFwic3Vic2NyaXB0aW9uLXN0YXJ0XCIpID8/IGRlYnVnMyhcIm5kazpzdWJzY3JpcHRpb24tc3RhcnRcIik7XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtTdWJzY3JpcHRpb25SZWNlaXB0KGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIHBlcnNvbiBiZWluZyBzdWJzY3JpYmVkIHRvXG4gICAqL1xuICBnZXQgcmVjaXBpZW50KCkge1xuICAgIGNvbnN0IHBUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIik/LlswXTtcbiAgICBpZiAoIXBUYWcpIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBwVGFnWzFdIH0pO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIHNldCByZWNpcGllbnQodXNlcikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicFwiKTtcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJwXCIsIHVzZXIucHVia2V5XSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIHBlcnNvbiBzdWJzY3JpYmluZ1xuICAgKi9cbiAgZ2V0IHN1YnNjcmliZXIoKSB7XG4gICAgY29uc3QgUFRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiUFwiKT8uWzBdO1xuICAgIGlmICghUFRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCB1c2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXk6IFBUYWdbMV0gfSk7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgc2V0IHN1YnNjcmliZXIodXNlcikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiUFwiKTtcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJQXCIsIHVzZXIucHVia2V5XSk7XG4gIH1cbiAgc2V0IHN1YnNjcmlwdGlvblN0YXJ0KGV2ZW50KSB7XG4gICAgdGhpcy5kZWJ1ZyhgYmVmb3JlIHNldHRpbmcgc3Vic2NyaXB0aW9uIHN0YXJ0OiAke3RoaXMucmF3RXZlbnR9YCk7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJlXCIpO1xuICAgIHRoaXMudGFnKGV2ZW50LCBcInN1YnNjcmlwdGlvblwiLCB0cnVlKTtcbiAgICB0aGlzLmRlYnVnKGBhZnRlciBzZXR0aW5nIHN1YnNjcmlwdGlvbiBzdGFydDogJHt0aGlzLnJhd0V2ZW50fWApO1xuICB9XG4gIGdldCB0aWVyTmFtZSgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInRpZXJcIik/LlswXTtcbiAgICByZXR1cm4gdGFnPy5bMV07XG4gIH1cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgY29uc3QgcGVyaW9kID0gdGhpcy52YWxpZFBlcmlvZDtcbiAgICBpZiAoIXBlcmlvZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGVyaW9kLnN0YXJ0ID4gcGVyaW9kLmVuZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwVGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKTtcbiAgICBjb25zdCBQVGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiUFwiKTtcbiAgICBpZiAocFRhZ3MubGVuZ3RoICE9PSAxIHx8IFBUYWdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXQgdmFsaWRQZXJpb2QoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJ2YWxpZFwiKT8uWzBdO1xuICAgIGlmICghdGFnKSByZXR1cm4gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogbmV3IERhdGUoTnVtYmVyLnBhcnNlSW50KHRhZ1sxXSkgKiAxZTMpLFxuICAgICAgICBlbmQ6IG5ldyBEYXRlKE51bWJlci5wYXJzZUludCh0YWdbMl0pICogMWUzKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHNldCB2YWxpZFBlcmlvZChwZXJpb2QpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInZhbGlkXCIpO1xuICAgIGlmICghcGVyaW9kKSByZXR1cm47XG4gICAgdGhpcy50YWdzLnB1c2goW1xuICAgICAgXCJ2YWxpZFwiLFxuICAgICAgTWF0aC5mbG9vcihwZXJpb2Quc3RhcnQuZ2V0VGltZSgpIC8gMWUzKS50b1N0cmluZygpLFxuICAgICAgTWF0aC5mbG9vcihwZXJpb2QuZW5kLmdldFRpbWUoKSAvIDFlMykudG9TdHJpbmcoKVxuICAgIF0pO1xuICB9XG4gIGdldCBzdGFydFBlcmlvZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZFBlcmlvZD8uc3RhcnQ7XG4gIH1cbiAgZ2V0IGVuZFBlcmlvZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZFBlcmlvZD8uZW5kO1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdWJzY3JpcHRpb24gaXMgY3VycmVudGx5IGFjdGl2ZVxuICAgKi9cbiAgaXNBY3RpdmUodGltZSkge1xuICAgIHRpbWUgPz89IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IHBlcmlvZCA9IHRoaXMudmFsaWRQZXJpb2Q7XG4gICAgaWYgKCFwZXJpb2QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGltZSA8IHBlcmlvZC5zdGFydCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aW1lID4gcGVyaW9kLmVuZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3N1YnNjcmlwdGlvbnMvc3Vic2NyaXB0aW9uLXN0YXJ0LnRzXG5pbXBvcnQgZGVidWc0IGZyb20gXCJkZWJ1Z1wiO1xudmFyIE5ES1N1YnNjcmlwdGlvblN0YXJ0ID0gY2xhc3MgX05ES1N1YnNjcmlwdGlvblN0YXJ0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBkZWJ1ZztcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gNzAwMSAvKiBTdWJzY3JpYmUgKi87XG4gICAgdGhpcy5kZWJ1ZyA9IG5kaz8uZGVidWcuZXh0ZW5kKFwic3Vic2NyaXB0aW9uLXN0YXJ0XCIpID8/IGRlYnVnNChcIm5kazpzdWJzY3JpcHRpb24tc3RhcnRcIik7XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtTdWJzY3JpcHRpb25TdGFydChldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWNpcGllbnQgb2YgdGhlIHN1YnNjcmlwdGlvbi4gSS5lLiBUaGUgYXV0aG9yIG9mIHRoaXMgZXZlbnQgc3Vic2NyaWJlcyB0byB0aGlzIHVzZXIuXG4gICAqL1xuICBnZXQgcmVjaXBpZW50KCkge1xuICAgIGNvbnN0IHBUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIik/LlswXTtcbiAgICBpZiAoIXBUYWcpIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBwVGFnWzFdIH0pO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIHNldCByZWNpcGllbnQodXNlcikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicFwiKTtcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJwXCIsIHVzZXIucHVia2V5XSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICovXG4gIGdldCBhbW91bnQoKSB7XG4gICAgY29uc3QgYW1vdW50VGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhbW91bnRcIik/LlswXTtcbiAgICBpZiAoIWFtb3VudFRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gcGFyc2VUYWdUb1N1YnNjcmlwdGlvbkFtb3VudChhbW91bnRUYWcpO1xuICB9XG4gIHNldCBhbW91bnQoYW1vdW50KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhbW91bnRcIik7XG4gICAgaWYgKCFhbW91bnQpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChuZXdBbW91bnQoYW1vdW50LmFtb3VudCwgYW1vdW50LmN1cnJlbmN5LCBhbW91bnQudGVybSkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgaWQgb3IgTklQLTMzIHRhZyBpZCBvZiB0aGUgdGllciB0aGF0IHRoZSB1c2VyIGlzIHN1YnNjcmliaW5nIHRvLlxuICAgKi9cbiAgZ2V0IHRpZXJJZCgpIHtcbiAgICBjb25zdCBlVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJlXCIpPy5bMF07XG4gICAgY29uc3QgYVRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiYVwiKT8uWzBdO1xuICAgIGlmICghZVRhZyB8fCAhYVRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gZVRhZ1sxXSA/PyBhVGFnWzFdO1xuICB9XG4gIHNldCB0aWVyKHRpZXIpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImVcIik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhXCIpO1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZXZlbnRcIik7XG4gICAgaWYgKCF0aWVyKSByZXR1cm47XG4gICAgdGhpcy50YWcodGllcik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcInBcIiwgdGllci5wdWJrZXldKTtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJldmVudFwiLCBKU09OLnN0cmluZ2lmeSh0aWVyLnJhd0V2ZW50KCkpXSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoZXMgdGhlIHRpZXIgdGhhdCB0aGUgdXNlciBpcyBzdWJzY3JpYmluZyB0by5cbiAgICovXG4gIGFzeW5jIGZldGNoVGllcigpIHtcbiAgICBjb25zdCBldmVudFRhZyA9IHRoaXMudGFnVmFsdWUoXCJldmVudFwiKTtcbiAgICBpZiAoZXZlbnRUYWcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEV2ZW50ID0gSlNPTi5wYXJzZShldmVudFRhZyk7XG4gICAgICAgIHJldHVybiBuZXcgTkRLU3Vic2NyaXB0aW9uVGllcih0aGlzLm5kaywgcGFyc2VkRXZlbnQpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJGYWlsZWQgdG8gcGFyc2UgZXZlbnQgdGFnXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0aWVySWQgPSB0aGlzLnRpZXJJZDtcbiAgICBpZiAoIXRpZXJJZCkgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5uZGs/LmZldGNoRXZlbnQodGllcklkKTtcbiAgICBpZiAoIWUpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIE5ES1N1YnNjcmlwdGlvblRpZXIuZnJvbShlKTtcbiAgfVxuICBnZXQgaXNWYWxpZCgpIHtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhbW91bnRcIikubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiSW52YWxpZCAjIG9mIGFtb3VudCB0YWdcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5hbW91bnQpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJJbnZhbGlkIGFtb3VudCB0YWdcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIikubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiSW52YWxpZCAjIG9mIHAgdGFnXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVjaXBpZW50KSB7XG4gICAgICB0aGlzLmRlYnVnKFwiSW52YWxpZCBwIHRhZ1wiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMvZ2lmdC13cmFwcGluZy50c1xuaW1wb3J0IHsgZ2V0RXZlbnRIYXNoIGFzIGdldEV2ZW50SGFzaDIgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcblxuLy8gc3JjL3NpZ25lcnMvcHJpdmF0ZS1rZXkvaW5kZXgudHNcbmltcG9ydCB7IGZpbmFsaXplRXZlbnQsIGdlbmVyYXRlU2VjcmV0S2V5LCBnZXRQdWJsaWNLZXksIG5pcDA0LCBuaXA0NCB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4MiwgaGV4VG9CeXRlcyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBuaXAxOSBhcyBuaXAxOTYgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbnZhciBOREtQcml2YXRlS2V5U2lnbmVyID0gY2xhc3MgX05ES1ByaXZhdGVLZXlTaWduZXIge1xuICBfdXNlcjtcbiAgX3ByaXZhdGVLZXk7XG4gIF9wdWJrZXk7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgc2lnbmVyIGZyb20gYSBwcml2YXRlIGtleS5cbiAgICogQHBhcmFtIHByaXZhdGVLZXkgLSBUaGUgcHJpdmF0ZSBrZXkgdG8gdXNlIGluIGhleCBmb3JtIG9yIG5zZWMuXG4gICAqIEBwYXJhbSBuZGsgLSBUaGUgTkRLIGluc3RhbmNlIHRvIHVzZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGVLZXlPck5zZWMsIG5kaykge1xuICAgIGlmICh0eXBlb2YgcHJpdmF0ZUtleU9yTnNlYyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHByaXZhdGVLZXlPck5zZWMuc3RhcnRzV2l0aChcIm5zZWMxXCIpKSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgZGF0YSB9ID0gbmlwMTk2LmRlY29kZShwcml2YXRlS2V5T3JOc2VjKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwibnNlY1wiKSB0aGlzLl9wcml2YXRlS2V5ID0gZGF0YTtcbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByaXZhdGUga2V5IHByb3ZpZGVkLlwiKTtcbiAgICAgIH0gZWxzZSBpZiAocHJpdmF0ZUtleU9yTnNlYy5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVLZXkgPSBoZXhUb0J5dGVzKHByaXZhdGVLZXlPck5zZWMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcml2YXRlIGtleSBwcm92aWRlZC5cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3ByaXZhdGVLZXkgPSBwcml2YXRlS2V5T3JOc2VjO1xuICAgIH1cbiAgICB0aGlzLl9wdWJrZXkgPSBnZXRQdWJsaWNLZXkodGhpcy5fcHJpdmF0ZUtleSk7XG4gICAgaWYgKG5kaykgdGhpcy5fdXNlciA9IG5kay5nZXRVc2VyKHsgcHVia2V5OiB0aGlzLl9wdWJrZXkgfSk7XG4gICAgdGhpcy5fdXNlciA/Pz0gbmV3IE5ES1VzZXIoeyBwdWJrZXk6IHRoaXMuX3B1YmtleSB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBwcml2YXRlIGtleSBpbiBoZXggZm9ybS5cbiAgICovXG4gIGdldCBwcml2YXRlS2V5KCkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSkgdGhyb3cgbmV3IEVycm9yKFwiTm90IHJlYWR5XCIpO1xuICAgIHJldHVybiBieXRlc1RvSGV4Mih0aGlzLl9wcml2YXRlS2V5KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBwdWJsaWMga2V5IGluIGhleCBmb3JtLlxuICAgKi9cbiAgZ2V0IHB1YmtleSgpIHtcbiAgICBpZiAoIXRoaXMuX3B1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiTm90IHJlYWR5XCIpO1xuICAgIHJldHVybiB0aGlzLl9wdWJrZXk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJpdmF0ZSBrZXkgaW4gbnNlYyBmb3JtLlxuICAgKi9cbiAgZ2V0IG5zZWMoKSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlS2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgcmVhZHlcIik7XG4gICAgcmV0dXJuIG5pcDE5Ni5uc2VjRW5jb2RlKHRoaXMuX3ByaXZhdGVLZXkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1YmxpYyBrZXkgaW4gbnB1YiBmb3JtLlxuICAgKi9cbiAgZ2V0IG5wdWIoKSB7XG4gICAgaWYgKCF0aGlzLl9wdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIk5vdCByZWFkeVwiKTtcbiAgICByZXR1cm4gbmlwMTk2Lm5wdWJFbmNvZGUodGhpcy5fcHVia2V5KTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgYSBuZXcgcHJpdmF0ZSBrZXkuXG4gICAqL1xuICBzdGF0aWMgZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGdlbmVyYXRlU2VjcmV0S2V5KCk7XG4gICAgcmV0dXJuIG5ldyBfTkRLUHJpdmF0ZUtleVNpZ25lcihwcml2YXRlS2V5KTtcbiAgfVxuICAvKipcbiAgICogTm9vcCBpbiBOREtQcml2YXRlS2V5U2lnbmVyLlxuICAgKi9cbiAgYXN5bmMgYmxvY2tVbnRpbFJlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIuXG4gICAqL1xuICBhc3luYyB1c2VyKCkge1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIuXG4gICAqL1xuICBnZXQgdXNlclN5bmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXI7XG4gIH1cbiAgYXN5bmMgc2lnbihldmVudCkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gc2lnbiB3aXRob3V0IGEgcHJpdmF0ZSBrZXlcIik7XG4gICAgfVxuICAgIHJldHVybiBmaW5hbGl6ZUV2ZW50KGV2ZW50LCB0aGlzLl9wcml2YXRlS2V5KS5zaWc7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdGlvbkVuYWJsZWQoc2NoZW1lKSB7XG4gICAgY29uc3QgZW5hYmxlZCA9IFtdO1xuICAgIGlmICghc2NoZW1lIHx8IHNjaGVtZSA9PT0gXCJuaXAwNFwiKSBlbmFibGVkLnB1c2goXCJuaXAwNFwiKTtcbiAgICBpZiAoIXNjaGVtZSB8fCBzY2hlbWUgPT09IFwibmlwNDRcIikgZW5hYmxlZC5wdXNoKFwibmlwNDRcIik7XG4gICAgcmV0dXJuIGVuYWJsZWQ7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdChyZWNpcGllbnQsIHZhbHVlLCBzY2hlbWUpIHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGVLZXkgfHwgIXRoaXMucHJpdmF0ZUtleSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gZW5jcnlwdCB3aXRob3V0IGEgcHJpdmF0ZSBrZXlcIik7XG4gICAgfVxuICAgIGNvbnN0IHJlY2lwaWVudEhleFB1YktleSA9IHJlY2lwaWVudC5wdWJrZXk7XG4gICAgaWYgKHNjaGVtZSA9PT0gXCJuaXA0NFwiKSB7XG4gICAgICBjb25zdCBjb252ZXJzYXRpb25LZXkgPSBuaXA0NC52Mi51dGlscy5nZXRDb252ZXJzYXRpb25LZXkodGhpcy5fcHJpdmF0ZUtleSwgcmVjaXBpZW50SGV4UHViS2V5KTtcbiAgICAgIHJldHVybiBhd2FpdCBuaXA0NC52Mi5lbmNyeXB0KHZhbHVlLCBjb252ZXJzYXRpb25LZXkpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgbmlwMDQuZW5jcnlwdCh0aGlzLl9wcml2YXRlS2V5LCByZWNpcGllbnRIZXhQdWJLZXksIHZhbHVlKTtcbiAgfVxuICBhc3luYyBkZWNyeXB0KHNlbmRlciwgdmFsdWUsIHNjaGVtZSkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSB8fCAhdGhpcy5wcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkF0dGVtcHRlZCB0byBkZWNyeXB0IHdpdGhvdXQgYSBwcml2YXRlIGtleVwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2VuZGVySGV4UHViS2V5ID0gc2VuZGVyLnB1YmtleTtcbiAgICBpZiAoc2NoZW1lID09PSBcIm5pcDQ0XCIpIHtcbiAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbktleSA9IG5pcDQ0LnYyLnV0aWxzLmdldENvbnZlcnNhdGlvbktleSh0aGlzLl9wcml2YXRlS2V5LCBzZW5kZXJIZXhQdWJLZXkpO1xuICAgICAgcmV0dXJuIGF3YWl0IG5pcDQ0LnYyLmRlY3J5cHQodmFsdWUsIGNvbnZlcnNhdGlvbktleSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBuaXAwNC5kZWNyeXB0KHRoaXMuX3ByaXZhdGVLZXksIHNlbmRlckhleFB1YktleSwgdmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBzaWduZXIncyBwcml2YXRlIGtleSBpbnRvIGEgc3RvcmFibGUgZm9ybWF0LlxuICAgKiBAcmV0dXJucyBBIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHR5cGUgYW5kIHRoZSBoZXggcHJpdmF0ZSBrZXkuXG4gICAqL1xuICB0b1BheWxvYWQoKSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlS2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJQcml2YXRlIGtleSBub3QgYXZhaWxhYmxlXCIpO1xuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICB0eXBlOiBcInByaXZhdGUta2V5XCIsXG4gICAgICBwYXlsb2FkOiB0aGlzLnByaXZhdGVLZXlcbiAgICAgIC8vIFVzZSB0aGUgaGV4IHByaXZhdGUga2V5XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gIH1cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplcyB0aGUgc2lnbmVyIGZyb20gYSBwYXlsb2FkIHN0cmluZy5cbiAgICogQHBhcmFtIHBheWxvYWRTdHJpbmcgVGhlIEpTT04gc3RyaW5nIG9idGFpbmVkIGZyb20gdG9QYXlsb2FkKCkuXG4gICAqIEBwYXJhbSBuZGsgT3B0aW9uYWwgTkRLIGluc3RhbmNlLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBOREtQcml2YXRlS2V5U2lnbmVyLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21QYXlsb2FkKHBheWxvYWRTdHJpbmcsIG5kaykge1xuICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKHBheWxvYWRTdHJpbmcpO1xuICAgIGlmIChwYXlsb2FkLnR5cGUgIT09IFwicHJpdmF0ZS1rZXlcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBheWxvYWQgdHlwZTogZXhwZWN0ZWQgJ3ByaXZhdGUta2V5JywgZ290ICR7cGF5bG9hZC50eXBlfWApO1xuICAgIH1cbiAgICBpZiAoIXBheWxvYWQucGF5bG9hZCB8fCB0eXBlb2YgcGF5bG9hZC5wYXlsb2FkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBheWxvYWQgY29udGVudCBmb3IgcHJpdmF0ZS1rZXkgc2lnbmVyXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9OREtQcml2YXRlS2V5U2lnbmVyKHBheWxvYWQucGF5bG9hZCwgbmRrKTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9naWZ0LXdyYXBwaW5nLnRzXG5hc3luYyBmdW5jdGlvbiBnaWZ0V3JhcChldmVudCwgcmVjaXBpZW50LCBzaWduZXIsIHBhcmFtcyA9IHt9KSB7XG4gIGxldCBfc2lnbmVyID0gc2lnbmVyO1xuICBwYXJhbXMuc2NoZW1lID8/PSBcIm5pcDQ0XCI7XG4gIGlmICghX3NpZ25lcikge1xuICAgIGlmICghZXZlbnQubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBzaWduZXIgYXZhaWxhYmxlIGZvciBnaWZ0V3JhcFwiKTtcbiAgICBfc2lnbmVyID0gZXZlbnQubmRrLnNpZ25lcjtcbiAgfVxuICBpZiAoIV9zaWduZXIpIHRocm93IG5ldyBFcnJvcihcIm5vIHNpZ25lclwiKTtcbiAgaWYgKCFfc2lnbmVyLmVuY3J5cHRpb25FbmFibGVkIHx8ICFfc2lnbmVyLmVuY3J5cHRpb25FbmFibGVkKHBhcmFtcy5zY2hlbWUpKVxuICAgIHRocm93IG5ldyBFcnJvcihcInNpZ25lciBpcyBub3QgYWJsZSB0byBnaWZ0V3JhcFwiKTtcbiAgY29uc3QgcnVtb3IgPSBnZXRSdW1vckV2ZW50KGV2ZW50LCBwYXJhbXM/LnJ1bW9yS2luZCk7XG4gIGNvbnN0IHNlYWwgPSBhd2FpdCBnZXRTZWFsRXZlbnQocnVtb3IsIHJlY2lwaWVudCwgX3NpZ25lciwgcGFyYW1zLnNjaGVtZSk7XG4gIGNvbnN0IHdyYXAgPSBhd2FpdCBnZXRXcmFwRXZlbnQoc2VhbCwgcmVjaXBpZW50LCBwYXJhbXMpO1xuICByZXR1cm4gbmV3IE5ES0V2ZW50KGV2ZW50Lm5kaywgd3JhcCk7XG59XG5hc3luYyBmdW5jdGlvbiBnaWZ0VW53cmFwKGV2ZW50LCBzZW5kZXIsIHNpZ25lciwgc2NoZW1lID0gXCJuaXA0NFwiKSB7XG4gIGNvbnN0IF9zZW5kZXIgPSBzZW5kZXIgfHwgbmV3IE5ES1VzZXIoeyBwdWJrZXk6IGV2ZW50LnB1YmtleSB9KTtcbiAgbGV0IF9zaWduZXIgPSBzaWduZXI7XG4gIGlmICghX3NpZ25lcikge1xuICAgIGlmICghZXZlbnQubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBzaWduZXIgYXZhaWxhYmxlIGZvciBnaWZ0VW53cmFwXCIpO1xuICAgIF9zaWduZXIgPSBldmVudC5uZGsuc2lnbmVyO1xuICB9XG4gIGlmICghc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBzaWduZXJcIik7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2VhbCA9IEpTT04ucGFyc2UoYXdhaXQgc2lnbmVyLmRlY3J5cHQoX3NlbmRlciwgZXZlbnQuY29udGVudCwgc2NoZW1lKSk7XG4gICAgaWYgKCFzZWFsKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVjcnlwdCB3cmFwcGVyXCIpO1xuICAgIGlmICghbmV3IE5ES0V2ZW50KHZvaWQgMCwgc2VhbCkudmVyaWZ5U2lnbmF0dXJlKGZhbHNlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkdpZnRTZWFsIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkIVwiKTtcbiAgICBjb25zdCBydW1vclNlbmRlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBzZWFsLnB1YmtleSB9KTtcbiAgICBjb25zdCBydW1vciA9IEpTT04ucGFyc2UoYXdhaXQgc2lnbmVyLmRlY3J5cHQocnVtb3JTZW5kZXIsIHNlYWwuY29udGVudCwgc2NoZW1lKSk7XG4gICAgaWYgKCFydW1vcikgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY3J5cHQgc2VhbFwiKTtcbiAgICBpZiAocnVtb3IucHVia2V5ICE9PSBzZWFsLnB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBHaWZ0V3JhcCwgc2VuZGVyIHZhbGlkYXRpb24gZmFpbGVkIVwiKTtcbiAgICByZXR1cm4gbmV3IE5ES0V2ZW50KGV2ZW50Lm5kaywgcnVtb3IpO1xuICB9IGNhdGNoIChfZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIkdvdCBlcnJvciB1bndyYXBwaW5nIGV2ZW50ISBTZWUgY29uc29sZSBsb2cuXCIpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSdW1vckV2ZW50KGV2ZW50LCBraW5kKSB7XG4gIGNvbnN0IHJ1bW9yID0gZXZlbnQucmF3RXZlbnQoKTtcbiAgcnVtb3Iua2luZCA9IGtpbmQgfHwgcnVtb3Iua2luZCB8fCAxNCAvKiBQcml2YXRlRGlyZWN0TWVzc2FnZSAqLztcbiAgcnVtb3Iuc2lnID0gdm9pZCAwO1xuICBydW1vci5pZCA9IGdldEV2ZW50SGFzaDIocnVtb3IpO1xuICByZXR1cm4gbmV3IE5ES0V2ZW50KGV2ZW50Lm5kaywgcnVtb3IpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U2VhbEV2ZW50KHJ1bW9yLCByZWNpcGllbnQsIHNpZ25lciwgc2NoZW1lID0gXCJuaXA0NFwiKSB7XG4gIGNvbnN0IHNlYWwgPSBuZXcgTkRLRXZlbnQocnVtb3IubmRrKTtcbiAgc2VhbC5raW5kID0gMTMgLyogR2lmdFdyYXBTZWFsICovO1xuICBzZWFsLmNyZWF0ZWRfYXQgPSBhcHByb3hpbWF0ZU5vdyg1KTtcbiAgc2VhbC5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkocnVtb3IucmF3RXZlbnQoKSk7XG4gIGF3YWl0IHNlYWwuZW5jcnlwdChyZWNpcGllbnQsIHNpZ25lciwgc2NoZW1lKTtcbiAgYXdhaXQgc2VhbC5zaWduKHNpZ25lcik7XG4gIHJldHVybiBzZWFsO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0V3JhcEV2ZW50KHNlYWxlZCwgcmVjaXBpZW50LCBwYXJhbXMsIHNjaGVtZSA9IFwibmlwNDRcIikge1xuICBjb25zdCBzaWduZXIgPSBOREtQcml2YXRlS2V5U2lnbmVyLmdlbmVyYXRlKCk7XG4gIGNvbnN0IHdyYXAgPSBuZXcgTkRLRXZlbnQoc2VhbGVkLm5kayk7XG4gIHdyYXAua2luZCA9IDEwNTkgLyogR2lmdFdyYXAgKi87XG4gIHdyYXAuY3JlYXRlZF9hdCA9IGFwcHJveGltYXRlTm93KDUpO1xuICBpZiAocGFyYW1zPy53cmFwVGFncykgd3JhcC50YWdzID0gcGFyYW1zLndyYXBUYWdzO1xuICB3cmFwLnRhZyhyZWNpcGllbnQpO1xuICB3cmFwLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShzZWFsZWQucmF3RXZlbnQoKSk7XG4gIGF3YWl0IHdyYXAuZW5jcnlwdChyZWNpcGllbnQsIHNpZ25lciwgc2NoZW1lKTtcbiAgYXdhaXQgd3JhcC5zaWduKHNpZ25lcik7XG4gIHJldHVybiB3cmFwO1xufVxuZnVuY3Rpb24gYXBwcm94aW1hdGVOb3coZHJpZnQgPSAwKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxZTMgLSBNYXRoLnJhbmRvbSgpICogMTAgKiogZHJpZnQpO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3NpbXBsZS1ncm91cC9pbmRleC50c1xudmFyIE5ES1NpbXBsZUdyb3VwID0gY2xhc3MgX05ES1NpbXBsZUdyb3VwIHtcbiAgbmRrO1xuICBncm91cElkO1xuICByZWxheVNldDtcbiAgZmV0Y2hpbmdNZXRhZGF0YTtcbiAgbWV0YWRhdGE7XG4gIG1lbWJlckxpc3Q7XG4gIGFkbWluTGlzdDtcbiAgY29uc3RydWN0b3IobmRrLCByZWxheVNldCwgZ3JvdXBJZCkge1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMuZ3JvdXBJZCA9IGdyb3VwSWQgPz8gcmFuZG9tSWQoMjQpO1xuICAgIHRoaXMucmVsYXlTZXQgPSByZWxheVNldDtcbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXBJZDtcbiAgfVxuICByZWxheVVybHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXlTZXQ/LnJlbGF5VXJscztcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRhZGF0YT8ubmFtZTtcbiAgfVxuICBnZXQgYWJvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGE/LmFib3V0O1xuICB9XG4gIGdldCBwaWN0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhPy5waWN0dXJlO1xuICB9XG4gIGdldCBtZW1iZXJzKCkge1xuICAgIHJldHVybiB0aGlzLm1lbWJlckxpc3Q/Lm1lbWJlcnMgPz8gW107XG4gIH1cbiAgZ2V0IGFkbWlucygpIHtcbiAgICByZXR1cm4gdGhpcy5hZG1pbkxpc3Q/Lm1lbWJlcnMgPz8gW107XG4gIH1cbiAgYXN5bmMgZ2V0TWV0YWRhdGEoKSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVNZXRhZGF0YUV2ZW50KCk7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGdyb3VwIGJ5IHB1Ymxpc2hpbmcgYSBraW5kOjkwMDcgZXZlbnQuXG4gICAqIEBwYXJhbSBzaWduZXJcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUdyb3VwKHNpZ25lcikge1xuICAgIHNpZ25lciA/Pz0gdGhpcy5uZGsuc2lnbmVyO1xuICAgIGlmICghc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBzaWduZXIudXNlcigpO1xuICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKFwiTm8gdXNlciBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGspO1xuICAgIGV2ZW50LmtpbmQgPSA5MDA3IC8qIEdyb3VwQWRtaW5DcmVhdGVHcm91cCAqLztcbiAgICBldmVudC50YWdzLnB1c2goW1wiaFwiLCB0aGlzLmdyb3VwSWRdKTtcbiAgICBhd2FpdCBldmVudC5zaWduKHNpZ25lcik7XG4gICAgcmV0dXJuIGV2ZW50LnB1Ymxpc2godGhpcy5yZWxheVNldCk7XG4gIH1cbiAgYXN5bmMgc2V0TWV0YWRhdGEoeyBuYW1lLCBhYm91dCwgcGljdHVyZSB9KSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGspO1xuICAgIGV2ZW50LmtpbmQgPSA5MDAyIC8qIEdyb3VwQWRtaW5FZGl0TWV0YWRhdGEgKi87XG4gICAgZXZlbnQudGFncy5wdXNoKFtcImhcIiwgdGhpcy5ncm91cElkXSk7XG4gICAgaWYgKG5hbWUpIGV2ZW50LnRhZ3MucHVzaChbXCJuYW1lXCIsIG5hbWVdKTtcbiAgICBpZiAoYWJvdXQpIGV2ZW50LnRhZ3MucHVzaChbXCJhYm91dFwiLCBhYm91dF0pO1xuICAgIGlmIChwaWN0dXJlKSBldmVudC50YWdzLnB1c2goW1wicGljdHVyZVwiLCBwaWN0dXJlXSk7XG4gICAgYXdhaXQgZXZlbnQuc2lnbigpO1xuICAgIHJldHVybiBldmVudC5wdWJsaXNoKHRoaXMucmVsYXlTZXQpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgdXNlciB0byB0aGUgZ3JvdXAgdXNpbmcgYSBraW5kOjkwMDAgZXZlbnRcbiAgICogQHBhcmFtIHVzZXIgdXNlciB0byBhZGRcbiAgICogQHBhcmFtIG9wdHMgb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgYWRkVXNlcih1c2VyKSB7XG4gICAgY29uc3QgYWRkVXNlckV2ZW50ID0gX05ES1NpbXBsZUdyb3VwLmdlbmVyYXRlQWRkVXNlckV2ZW50KHVzZXIucHVia2V5LCB0aGlzLmdyb3VwSWQpO1xuICAgIGFkZFVzZXJFdmVudC5uZGsgPSB0aGlzLm5kaztcbiAgICByZXR1cm4gYWRkVXNlckV2ZW50O1xuICB9XG4gIGFzeW5jIGdldE1lbWJlckxpc3RFdmVudCgpIHtcbiAgICBjb25zdCBtZW1iZXJMaXN0ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudChcbiAgICAgIHtcbiAgICAgICAga2luZHM6IFszOTAwMiAvKiBHcm91cE1lbWJlcnMgKi9dLFxuICAgICAgICBcIiNkXCI6IFt0aGlzLmdyb3VwSWRdXG4gICAgICB9LFxuICAgICAgdm9pZCAwLFxuICAgICAgdGhpcy5yZWxheVNldFxuICAgICk7XG4gICAgaWYgKCFtZW1iZXJMaXN0KSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTkRLU2ltcGxlR3JvdXBNZW1iZXJMaXN0LmZyb20obWVtYmVyTGlzdCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBsaXN0IG9mIHVzZXJzIHRoYXQgYmVsb25nIHRvIHRoaXMgZ3JvdXBcbiAgICovXG4gIGFzeW5jIGdldE1lbWJlcnMoKSB7XG4gICAgY29uc3QgbWVtYmVycyA9IFtdO1xuICAgIGNvbnN0IG1lbWJlclB1YmtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IG1lbWJlckxpc3RFdmVudCA9IGF3YWl0IHRoaXMuZ2V0TWVtYmVyTGlzdEV2ZW50KCk7XG4gICAgaWYgKCFtZW1iZXJMaXN0RXZlbnQpIHJldHVybiBbXTtcbiAgICBmb3IgKGNvbnN0IHBUYWcgb2YgbWVtYmVyTGlzdEV2ZW50LmdldE1hdGNoaW5nVGFncyhcInBcIikpIHtcbiAgICAgIGNvbnN0IHB1YmtleSA9IHBUYWdbMV07XG4gICAgICBpZiAobWVtYmVyUHVia2V5cy5oYXMocHVia2V5KSkgY29udGludWU7XG4gICAgICBtZW1iZXJQdWJrZXlzLmFkZChwdWJrZXkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWVtYmVycy5wdXNoKHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXkgfSkpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZW1iZXJzO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gZXZlbnQgdGhhdCBsaXN0cyB0aGUgbWVtYmVycyBvZiBhIGdyb3VwLlxuICAgKiBAcGFyYW0gZ3JvdXBJZFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlVXNlckxpc3RFdmVudChncm91cElkKSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodm9pZCAwLCB7XG4gICAgICBraW5kOiAzOTAwMiAvKiBHcm91cE1lbWJlcnMgKi8sXG4gICAgICB0YWdzOiBbXG4gICAgICAgIFtcImhcIiwgZ3JvdXBJZF0sXG4gICAgICAgIFtcImFsdFwiLCBcIkdyb3VwIE1lbWJlciBMaXN0XCJdXG4gICAgICBdXG4gICAgfSk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gZXZlbnQgdGhhdCBhZGRzIGEgdXNlciB0byBhIGdyb3VwLlxuICAgKiBAcGFyYW0gdXNlclB1YmtleSBwdWJrZXkgb2YgdGhlIHVzZXIgdG8gYWRkXG4gICAqIEBwYXJhbSBncm91cElkIGdyb3VwIHRvIGFkZCB0aGUgdXNlciB0b1xuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlQWRkVXNlckV2ZW50KHVzZXJQdWJrZXksIGdyb3VwSWQpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh2b2lkIDAsIHtcbiAgICAgIGtpbmQ6IDllMyAvKiBHcm91cEFkbWluQWRkVXNlciAqLyxcbiAgICAgIHRhZ3M6IFtbXCJoXCIsIGdyb3VwSWRdXVxuICAgIH0pO1xuICAgIGV2ZW50LnRhZ3MucHVzaChbXCJwXCIsIHVzZXJQdWJrZXldKTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdFRvSm9pbihfcHVia2V5LCBjb250ZW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IDkwMjEgLyogR3JvdXBBZG1pblJlcXVlc3RKb2luICovLFxuICAgICAgY29udGVudDogY29udGVudCA/PyBcIlwiLFxuICAgICAgdGFnczogW1tcImhcIiwgdGhpcy5ncm91cElkXV1cbiAgICB9KTtcbiAgICByZXR1cm4gZXZlbnQucHVibGlzaCh0aGlzLnJlbGF5U2V0KTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgc3VyZSB0aGF0IGEgbWV0YWRhdGEgZXZlbnQgZXhpc3RzIGxvY2FsbHlcbiAgICovXG4gIGFzeW5jIGVuc3VyZU1ldGFkYXRhRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMubWV0YWRhdGEpIHJldHVybjtcbiAgICBpZiAodGhpcy5mZXRjaGluZ01ldGFkYXRhKSByZXR1cm4gdGhpcy5mZXRjaGluZ01ldGFkYXRhO1xuICAgIHRoaXMuZmV0Y2hpbmdNZXRhZGF0YSA9IHRoaXMubmRrLmZldGNoRXZlbnQoXG4gICAgICB7XG4gICAgICAgIGtpbmRzOiBbMzllMyAvKiBHcm91cE1ldGFkYXRhICovXSxcbiAgICAgICAgXCIjZFwiOiBbdGhpcy5ncm91cElkXVxuICAgICAgfSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHRoaXMucmVsYXlTZXRcbiAgICApLnRoZW4oKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IE5ES1NpbXBsZUdyb3VwTWV0YWRhdGEuZnJvbShldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbmV3IE5ES1NpbXBsZUdyb3VwTWV0YWRhdGEodGhpcy5uZGspO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLmRUYWcgPSB0aGlzLmdyb3VwSWQ7XG4gICAgICB9XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICB0aGlzLmZldGNoaW5nTWV0YWRhdGEgPSB2b2lkIDA7XG4gICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggbWV0YWRhdGEgZm9yIGdyb3VwICR7dGhpcy5ncm91cElkfWApO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmZldGNoaW5nTWV0YWRhdGE7XG4gIH1cbn07XG5mdW5jdGlvbiByYW5kb21JZChsZW5ndGgpIHtcbiAgY29uc3QgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCI7XG4gIGNvbnN0IGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdCArPSBjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnNMZW5ndGgpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvYXBwLXNldHRpbmdzL2luZGV4LnRzXG52YXIgTkRLQXBwU2V0dGluZ3MgPSBjbGFzcyBfTkRLQXBwU2V0dGluZ3MgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGFwcE5hbWU7XG4gIHNldHRpbmdzID0ge307XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMwMDc4IC8qIEFwcFNwZWNpZmljRGF0YSAqLztcbiAgICB0aGlzLmRUYWcgPz89IHRoaXMuYXBwTmFtZTtcbiAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcGFyc2luZyBhcHAgc2V0dGluZ3NcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0FwcFNldHRpbmdzKGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSB2YWx1ZSBmb3IgYSBnaXZlbiBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuc2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSB2YWx1ZSBmb3IgYSBnaXZlbiBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR0aW5nc1trZXldO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2hSZXBsYWNlYWJsZShyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnNldHRpbmdzKTtcbiAgICByZXR1cm4gc3VwZXIucHVibGlzaFJlcGxhY2VhYmxlKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9yZWxheS9hdXRoLXBvbGljaWVzLnRzXG5pbXBvcnQgY3JlYXRlRGVidWcyIGZyb20gXCJkZWJ1Z1wiO1xuZnVuY3Rpb24gZGlzY29ubmVjdChwb29sLCBkZWJ1ZzgpIHtcbiAgZGVidWc4ID8/PSBjcmVhdGVEZWJ1ZzIoXCJuZGs6cmVsYXk6YXV0aC1wb2xpY2llczpkaXNjb25uZWN0XCIpO1xuICByZXR1cm4gYXN5bmMgKHJlbGF5KSA9PiB7XG4gICAgZGVidWc4Py4oYFJlbGF5ICR7cmVsYXkudXJsfSByZXF1ZXN0ZWQgYXV0aGVudGljYXRpb24sIGRpc2Nvbm5lY3RpbmdgKTtcbiAgICBwb29sLnJlbW92ZVJlbGF5KHJlbGF5LnVybCk7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBzaWduQW5kQXV0aChldmVudCwgcmVsYXksIHNpZ25lciwgZGVidWc4LCByZXNvbHZlLCByZWplY3QpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBldmVudC5zaWduKHNpZ25lcik7XG4gICAgcmVzb2x2ZShldmVudCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1Zzg/LihgRmFpbGVkIHRvIHB1Ymxpc2ggYXV0aCBldmVudCB0byByZWxheSAke3JlbGF5LnVybH1gLCBlKTtcbiAgICByZWplY3QoZXZlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBzaWduSW4oeyBuZGssIHNpZ25lciwgZGVidWc6IGRlYnVnOCB9ID0ge30pIHtcbiAgZGVidWc4ID8/PSBjcmVhdGVEZWJ1ZzIoXCJuZGs6YXV0aC1wb2xpY2llczpzaWduSW5cIik7XG4gIHJldHVybiBhc3luYyAocmVsYXksIGNoYWxsZW5nZSkgPT4ge1xuICAgIGRlYnVnOD8uKGBSZWxheSAke3JlbGF5LnVybH0gcmVxdWVzdGVkIGF1dGhlbnRpY2F0aW9uLCBzaWduaW5nIGluYCk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrKTtcbiAgICBldmVudC5raW5kID0gMjIyNDIgLyogQ2xpZW50QXV0aCAqLztcbiAgICBldmVudC50YWdzID0gW1xuICAgICAgW1wicmVsYXlcIiwgcmVsYXkudXJsXSxcbiAgICAgIFtcImNoYWxsZW5nZVwiLCBjaGFsbGVuZ2VdXG4gICAgXTtcbiAgICBzaWduZXIgPz89IG5kaz8uc2lnbmVyO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoc2lnbmVyKSB7XG4gICAgICAgIGF3YWl0IHNpZ25BbmRBdXRoKGV2ZW50LCByZWxheSwgc2lnbmVyLCBkZWJ1ZzgsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZGs/Lm9uY2UoXCJzaWduZXI6cmVhZHlcIiwgYXN5bmMgKHNpZ25lcjIpID0+IHtcbiAgICAgICAgICBhd2FpdCBzaWduQW5kQXV0aChldmVudCwgcmVsYXksIHNpZ25lcjIsIGRlYnVnOCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG52YXIgTkRLUmVsYXlBdXRoUG9saWNpZXMgPSB7XG4gIGRpc2Nvbm5lY3QsXG4gIHNpZ25JblxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwMDcvaW5kZXgudHNcbmltcG9ydCBkZWJ1ZzUgZnJvbSBcImRlYnVnXCI7XG52YXIgTkRLTmlwMDdTaWduZXIgPSBjbGFzcyBfTkRLTmlwMDdTaWduZXIge1xuICBfdXNlclByb21pc2U7XG4gIGVuY3J5cHRpb25RdWV1ZSA9IFtdO1xuICBlbmNyeXB0aW9uUHJvY2Vzc2luZyA9IGZhbHNlO1xuICBkZWJ1ZztcbiAgd2FpdFRpbWVvdXQ7XG4gIF9wdWJrZXk7XG4gIG5kaztcbiAgX3VzZXI7XG4gIC8qKlxuICAgKiBAcGFyYW0gd2FpdFRpbWVvdXQgLSBUaGUgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgdGhlIE5JUC0wNyB0byBiZWNvbWUgYXZhaWxhYmxlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3YWl0VGltZW91dCA9IDFlMywgbmRrKSB7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnNShcIm5kazpuaXAwN1wiKTtcbiAgICB0aGlzLndhaXRUaW1lb3V0ID0gd2FpdFRpbWVvdXQ7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gIH1cbiAgZ2V0IHB1YmtleSgpIHtcbiAgICBpZiAoIXRoaXMuX3B1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiTm90IHJlYWR5XCIpO1xuICAgIHJldHVybiB0aGlzLl9wdWJrZXk7XG4gIH1cbiAgYXN5bmMgYmxvY2tVbnRpbFJlYWR5KCkge1xuICAgIGF3YWl0IHRoaXMud2FpdEZvckV4dGVuc2lvbigpO1xuICAgIGNvbnN0IHB1YmtleSA9IGF3YWl0IHdpbmRvdy5ub3N0cj8uZ2V0UHVibGljS2V5KCk7XG4gICAgaWYgKCFwdWJrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgcmVqZWN0ZWQgYWNjZXNzXCIpO1xuICAgIH1cbiAgICB0aGlzLl9wdWJrZXkgPSBwdWJrZXk7XG4gICAgbGV0IHVzZXI7XG4gICAgaWYgKHRoaXMubmRrKSB1c2VyID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleSB9KTtcbiAgICBlbHNlIHVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleSB9KTtcbiAgICB0aGlzLl91c2VyID0gdXNlcjtcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgdXNlciBwcm9wZXJ0eS5cbiAgICogQHJldHVybnMgVGhlIE5ES1VzZXIgaW5zdGFuY2UuXG4gICAqL1xuICBhc3luYyB1c2VyKCkge1xuICAgIGlmICghdGhpcy5fdXNlclByb21pc2UpIHtcbiAgICAgIHRoaXMuX3VzZXJQcm9taXNlID0gdGhpcy5ibG9ja1VudGlsUmVhZHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJQcm9taXNlO1xuICB9XG4gIGdldCB1c2VyU3luYygpIHtcbiAgICBpZiAoIXRoaXMuX3VzZXIpIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IHJlYWR5XCIpO1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIC8qKlxuICAgKiBTaWducyB0aGUgZ2l2ZW4gTm9zdHIgZXZlbnQuXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBOb3N0ciBldmVudCB0byBiZSBzaWduZWQuXG4gICAqIEByZXR1cm5zIFRoZSBzaWduYXR1cmUgb2YgdGhlIHNpZ25lZCBldmVudC5cbiAgICogQHRocm93cyBFcnJvciBpZiB0aGUgTklQLTA3IGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAqL1xuICBhc3luYyBzaWduKGV2ZW50KSB7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3Qgc2lnbmVkRXZlbnQgPSBhd2FpdCB3aW5kb3cubm9zdHI/LnNpZ25FdmVudChldmVudCk7XG4gICAgaWYgKCFzaWduZWRFdmVudCkgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHNpZ24gZXZlbnRcIik7XG4gICAgcmV0dXJuIHNpZ25lZEV2ZW50LnNpZztcbiAgfVxuICBhc3luYyByZWxheXMobmRrKSB7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3QgcmVsYXlzID0gYXdhaXQgd2luZG93Lm5vc3RyPy5nZXRSZWxheXM/LigpIHx8IHt9O1xuICAgIGNvbnN0IGFjdGl2ZVJlbGF5cyA9IFtdO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIE9iamVjdC5rZXlzKHJlbGF5cykpIHtcbiAgICAgIGlmIChyZWxheXNbdXJsXS5yZWFkICYmIHJlbGF5c1t1cmxdLndyaXRlKSB7XG4gICAgICAgIGFjdGl2ZVJlbGF5cy5wdXNoKHVybCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVSZWxheXMubWFwKCh1cmwpID0+IG5ldyBOREtSZWxheSh1cmwsIG5kaz8ucmVsYXlBdXRoRGVmYXVsdFBvbGljeSwgbmRrKSk7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdGlvbkVuYWJsZWQobmlwKSB7XG4gICAgY29uc3QgZW5hYmxlZCA9IFtdO1xuICAgIGlmICgoIW5pcCB8fCBuaXAgPT09IFwibmlwMDRcIikgJiYgQm9vbGVhbih3aW5kb3cubm9zdHI/Lm5pcDA0KSkgZW5hYmxlZC5wdXNoKFwibmlwMDRcIik7XG4gICAgaWYgKCghbmlwIHx8IG5pcCA9PT0gXCJuaXA0NFwiKSAmJiBCb29sZWFuKHdpbmRvdy5ub3N0cj8ubmlwNDQpKSBlbmFibGVkLnB1c2goXCJuaXA0NFwiKTtcbiAgICByZXR1cm4gZW5hYmxlZDtcbiAgfVxuICBhc3luYyBlbmNyeXB0KHJlY2lwaWVudCwgdmFsdWUsIG5pcCA9IFwibmlwMDRcIikge1xuICAgIGlmICghYXdhaXQgdGhpcy5lbmNyeXB0aW9uRW5hYmxlZChuaXApKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25pcH1lbmNyeXB0aW9uIGlzIG5vdCBhdmFpbGFibGUgZnJvbSB5b3VyIGJyb3dzZXIgZXh0ZW5zaW9uYCk7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3QgcmVjaXBpZW50SGV4UHViS2V5ID0gcmVjaXBpZW50LnB1YmtleTtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZUVuY3J5cHRpb24obmlwLCBcImVuY3J5cHRcIiwgcmVjaXBpZW50SGV4UHViS2V5LCB2YWx1ZSk7XG4gIH1cbiAgYXN5bmMgZGVjcnlwdChzZW5kZXIsIHZhbHVlLCBuaXAgPSBcIm5pcDA0XCIpIHtcbiAgICBpZiAoIWF3YWl0IHRoaXMuZW5jcnlwdGlvbkVuYWJsZWQobmlwKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuaXB9ZW5jcnlwdGlvbiBpcyBub3QgYXZhaWxhYmxlIGZyb20geW91ciBicm93c2VyIGV4dGVuc2lvbmApO1xuICAgIGF3YWl0IHRoaXMud2FpdEZvckV4dGVuc2lvbigpO1xuICAgIGNvbnN0IHNlbmRlckhleFB1YktleSA9IHNlbmRlci5wdWJrZXk7XG4gICAgcmV0dXJuIHRoaXMucXVldWVFbmNyeXB0aW9uKG5pcCwgXCJkZWNyeXB0XCIsIHNlbmRlckhleFB1YktleSwgdmFsdWUpO1xuICB9XG4gIGFzeW5jIHF1ZXVlRW5jcnlwdGlvbihzY2hlbWUsIG1ldGhvZCwgY291bnRlcnBhcnR5SGV4cHVia2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmVuY3J5cHRpb25RdWV1ZS5wdXNoKHtcbiAgICAgICAgc2NoZW1lLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIGNvdW50ZXJwYXJ0eUhleHB1YmtleSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHJlc29sdmUsXG4gICAgICAgIHJlamVjdFxuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMuZW5jcnlwdGlvblByb2Nlc3NpbmcpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzRW5jcnlwdGlvblF1ZXVlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0VuY3J5cHRpb25RdWV1ZShpdGVtLCByZXRyaWVzID0gMCkge1xuICAgIGlmICghaXRlbSAmJiB0aGlzLmVuY3J5cHRpb25RdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmNyeXB0aW9uUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgY29uc3QgY3VycmVudEl0ZW0gPSBpdGVtIHx8IHRoaXMuZW5jcnlwdGlvblF1ZXVlLnNoaWZ0KCk7XG4gICAgaWYgKCFjdXJyZW50SXRlbSkge1xuICAgICAgdGhpcy5lbmNyeXB0aW9uUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHNjaGVtZSwgbWV0aG9kLCBjb3VudGVycGFydHlIZXhwdWJrZXksIHZhbHVlLCByZXNvbHZlLCByZWplY3QgfSA9IGN1cnJlbnRJdGVtO1xuICAgIHRoaXMuZGVidWcoXCJQcm9jZXNzaW5nIGVuY3J5cHRpb24gcXVldWUgaXRlbVwiLCB7XG4gICAgICBtZXRob2QsXG4gICAgICBjb3VudGVycGFydHlIZXhwdWJrZXksXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3aW5kb3cubm9zdHI/LltzY2hlbWVdPy5bbWV0aG9kXShjb3VudGVycGFydHlIZXhwdWJrZXksIHZhbHVlKTtcbiAgICAgIGlmICghcmVzdWx0KSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZW5jcnlwdC9kZWNyeXB0XCIpO1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICBpZiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKFwiY2FsbCBhbHJlYWR5IGV4ZWN1dGluZ1wiKSAmJiByZXRyaWVzIDwgNSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiUmV0cnlpbmcgZW5jcnlwdGlvbiBxdWV1ZSBpdGVtXCIsIHtcbiAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgY291bnRlcnBhcnR5SGV4cHVia2V5LFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHJldHJpZXNcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMucHJvY2Vzc0VuY3J5cHRpb25RdWV1ZShjdXJyZW50SXRlbSwgcmV0cmllcyArIDEpO1xuICAgICAgICB9LCA1MCAqIHJldHJpZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZWplY3QoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yTWVzc2FnZSkpO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NFbmNyeXB0aW9uUXVldWUoKTtcbiAgfVxuICB3YWl0Rm9yRXh0ZW5zaW9uKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAod2luZG93Lm5vc3RyKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHRpbWVySWQ7XG4gICAgICBjb25zdCBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBpZiAod2luZG93Lm5vc3RyKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDApO1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKFwiTklQLTA3IGV4dGVuc2lvbiBub3QgYXZhaWxhYmxlXCIpKTtcbiAgICAgIH0sIHRoaXMud2FpdFRpbWVvdXQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBzaWduZXIgdHlwZSBpbnRvIGEgc3RvcmFibGUgZm9ybWF0LlxuICAgKiBOSVAtMDcgc2lnbmVycyBkb24ndCBoYXZlIHBlcnNpc3RlbnQgc3RhdGUgdG8gc2VyaWFsaXplIGJleW9uZCB0aGVpciB0eXBlLlxuICAgKiBAcmV0dXJucyBBIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHR5cGUuXG4gICAqL1xuICB0b1BheWxvYWQoKSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIHR5cGU6IFwibmlwMDdcIixcbiAgICAgIHBheWxvYWQ6IFwiXCJcbiAgICAgIC8vIE5vIHNwZWNpZmljIHBheWxvYWQgbmVlZGVkIGZvciBOSVAtMDdcbiAgICB9O1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgfVxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBzaWduZXIgZnJvbSBhIHBheWxvYWQgc3RyaW5nLlxuICAgKiBDcmVhdGVzIGEgbmV3IE5ES05pcDA3U2lnbmVyIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gcGF5bG9hZFN0cmluZyBUaGUgSlNPTiBzdHJpbmcgb2J0YWluZWQgZnJvbSB0b1BheWxvYWQoKS5cbiAgICogQHBhcmFtIG5kayBPcHRpb25hbCBOREsgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIE5ES05pcDA3U2lnbmVyLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21QYXlsb2FkKHBheWxvYWRTdHJpbmcsIG5kaykge1xuICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKHBheWxvYWRTdHJpbmcpO1xuICAgIGlmIChwYXlsb2FkLnR5cGUgIT09IFwibmlwMDdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBheWxvYWQgdHlwZTogZXhwZWN0ZWQgJ25pcDA3JywgZ290ICR7cGF5bG9hZC50eXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9OREtOaXAwN1NpZ25lcih2b2lkIDAsIG5kayk7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvaW5kZXgudHNcbmltcG9ydCB7IGhleFRvQnl0ZXMgYXMgaGV4VG9CeXRlczIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9ycGMudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI1IH0gZnJvbSBcInRzZWVwXCI7XG52YXIgTkRLTm9zdHJScGMgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjUge1xuICBuZGs7XG4gIHNpZ25lcjtcbiAgcmVsYXlTZXQ7XG4gIGRlYnVnO1xuICBlbmNyeXB0aW9uVHlwZSA9IFwibmlwMDRcIjtcbiAgcG9vbDtcbiAgY29uc3RydWN0b3IobmRrLCBzaWduZXIsIGRlYnVnOCwgcmVsYXlVcmxzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLnNpZ25lciA9IHNpZ25lcjtcbiAgICBpZiAocmVsYXlVcmxzKSB7XG4gICAgICB0aGlzLnBvb2wgPSBuZXcgTkRLUG9vbChyZWxheVVybHMsIFtdLCBuZGssIHtcbiAgICAgICAgZGVidWc6IGRlYnVnOC5leHRlbmQoXCJycGMtcG9vbFwiKSxcbiAgICAgICAgbmFtZTogXCJOb3N0ciBSUENcIlxuICAgICAgfSk7XG4gICAgICB0aGlzLnJlbGF5U2V0ID0gbmV3IE5ES1JlbGF5U2V0KC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIG5kaywgdGhpcy5wb29sKTtcbiAgICAgIGZvciAoY29uc3QgdXJsIG9mIHJlbGF5VXJscykge1xuICAgICAgICBjb25zdCByZWxheSA9IHRoaXMucG9vbC5nZXRSZWxheSh1cmwsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIHJlbGF5LmF1dGhQb2xpY3kgPSBOREtSZWxheUF1dGhQb2xpY2llcy5zaWduSW4oeyBuZGssIHNpZ25lciwgZGVidWc6IGRlYnVnOCB9KTtcbiAgICAgICAgdGhpcy5yZWxheVNldC5hZGRSZWxheShyZWxheSk7XG4gICAgICAgIHJlbGF5LmNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnOC5leHRlbmQoXCJycGNcIik7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byBhIGZpbHRlci4gVGhpcyBmdW5jdGlvbiB3aWxsIHJlc29sdmUgb25jZSB0aGUgc3Vic2NyaXB0aW9uIGlzIHJlYWR5LlxuICAgKi9cbiAgc3Vic2NyaWJlKGZpbHRlcikge1xuICAgIGNvbnN0IHN1YiA9IHRoaXMubmRrLnN1YnNjcmliZShcbiAgICAgIGZpbHRlcixcbiAgICAgIHtcbiAgICAgICAgY2xvc2VPbkVvc2U6IGZhbHNlLFxuICAgICAgICBncm91cGFibGU6IGZhbHNlLFxuICAgICAgICBjYWNoZVVzYWdlOiBcIk9OTFlfUkVMQVlcIiAvKiBPTkxZX1JFTEFZICovLFxuICAgICAgICBwb29sOiB0aGlzLnBvb2wsXG4gICAgICAgIHJlbGF5U2V0OiB0aGlzLnJlbGF5U2V0XG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHN1Yi5vbihcImV2ZW50XCIsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkRXZlbnQgPSBhd2FpdCB0aGlzLnBhcnNlRXZlbnQoZXZlbnQpO1xuICAgICAgICBpZiAocGFyc2VkRXZlbnQubWV0aG9kKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KFwicmVxdWVzdFwiLCBwYXJzZWRFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbWl0KGByZXNwb25zZS0ke3BhcnNlZEV2ZW50LmlkfWAsIHBhcnNlZEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiZXJyb3IgcGFyc2luZyBldmVudFwiLCBlLCBldmVudC5yYXdFdmVudCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHN1Yi5vbihcImVvc2VcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmRlYnVnKFwiZW9zZWRcIik7XG4gICAgICAgIHJlc29sdmUoc3ViKTtcbiAgICAgIH0pO1xuICAgICAgc3ViLnN0YXJ0KCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcGFyc2VFdmVudChldmVudCkge1xuICAgIGlmICh0aGlzLmVuY3J5cHRpb25UeXBlID09PSBcIm5pcDQ0XCIgJiYgZXZlbnQuY29udGVudC5pbmNsdWRlcyhcIj9pdj1cIikpIHtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblR5cGUgPSBcIm5pcDA0XCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVuY3J5cHRpb25UeXBlID09PSBcIm5pcDA0XCIgJiYgIWV2ZW50LmNvbnRlbnQuaW5jbHVkZXMoXCI/aXY9XCIpKSB7XG4gICAgICB0aGlzLmVuY3J5cHRpb25UeXBlID0gXCJuaXA0NFwiO1xuICAgIH1cbiAgICBjb25zdCByZW1vdGVVc2VyID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogZXZlbnQucHVia2V5IH0pO1xuICAgIHJlbW90ZVVzZXIubmRrID0gdGhpcy5uZGs7XG4gICAgbGV0IGRlY3J5cHRlZENvbnRlbnQ7XG4gICAgdHJ5IHtcbiAgICAgIGRlY3J5cHRlZENvbnRlbnQgPSBhd2FpdCB0aGlzLnNpZ25lci5kZWNyeXB0KHJlbW90ZVVzZXIsIGV2ZW50LmNvbnRlbnQsIHRoaXMuZW5jcnlwdGlvblR5cGUpO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICBjb25zdCBvdGhlckVuY3J5cHRpb25UeXBlID0gdGhpcy5lbmNyeXB0aW9uVHlwZSA9PT0gXCJuaXAwNFwiID8gXCJuaXA0NFwiIDogXCJuaXAwNFwiO1xuICAgICAgZGVjcnlwdGVkQ29udGVudCA9IGF3YWl0IHRoaXMuc2lnbmVyLmRlY3J5cHQocmVtb3RlVXNlciwgZXZlbnQuY29udGVudCwgb3RoZXJFbmNyeXB0aW9uVHlwZSk7XG4gICAgICB0aGlzLmVuY3J5cHRpb25UeXBlID0gb3RoZXJFbmNyeXB0aW9uVHlwZTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkQ29udGVudCA9IEpTT04ucGFyc2UoZGVjcnlwdGVkQ29udGVudCk7XG4gICAgY29uc3QgeyBpZCwgbWV0aG9kLCBwYXJhbXMsIHJlc3VsdCwgZXJyb3IgfSA9IHBhcnNlZENvbnRlbnQ7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgcmV0dXJuIHsgaWQsIHB1YmtleTogZXZlbnQucHVia2V5LCBtZXRob2QsIHBhcmFtcywgZXZlbnQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaWQsIHJlc3VsdCwgZXJyb3IsIGV2ZW50IH07XG4gIH1cbiAgYXN5bmMgc2VuZFJlc3BvbnNlKGlkLCByZW1vdGVQdWJrZXksIHJlc3VsdCwga2luZCA9IDI0MTMzIC8qIE5vc3RyQ29ubmVjdCAqLywgZXJyb3IpIHtcbiAgICBjb25zdCByZXMgPSB7IGlkLCByZXN1bHQgfTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJlcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbFVzZXIgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3QgcmVtb3RlVXNlciA9IHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXk6IHJlbW90ZVB1YmtleSB9KTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywge1xuICAgICAga2luZCxcbiAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHJlcyksXG4gICAgICB0YWdzOiBbW1wicFwiLCByZW1vdGVQdWJrZXldXSxcbiAgICAgIHB1YmtleTogbG9jYWxVc2VyLnB1YmtleVxuICAgIH0pO1xuICAgIGV2ZW50LmNvbnRlbnQgPSBhd2FpdCB0aGlzLnNpZ25lci5lbmNyeXB0KHJlbW90ZVVzZXIsIGV2ZW50LmNvbnRlbnQsIHRoaXMuZW5jcnlwdGlvblR5cGUpO1xuICAgIGF3YWl0IGV2ZW50LnNpZ24odGhpcy5zaWduZXIpO1xuICAgIGF3YWl0IGV2ZW50LnB1Ymxpc2godGhpcy5yZWxheVNldCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmVxdWVzdC5cbiAgICogQHBhcmFtIHJlbW90ZVB1YmtleVxuICAgKiBAcGFyYW0gbWV0aG9kXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGtpbmRcbiAgICogQHBhcmFtIGlkXG4gICAqL1xuICBhc3luYyBzZW5kUmVxdWVzdChyZW1vdGVQdWJrZXksIG1ldGhvZCwgcGFyYW1zID0gW10sIGtpbmQgPSAyNDEzMywgY2IpIHtcbiAgICBjb25zdCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KTtcbiAgICBjb25zdCBsb2NhbFVzZXIgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3QgcmVtb3RlVXNlciA9IHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXk6IHJlbW90ZVB1YmtleSB9KTtcbiAgICBjb25zdCByZXF1ZXN0ID0geyBpZCwgbWV0aG9kLCBwYXJhbXMgfTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKCkgPT4ge1xuICAgICAgY29uc3QgcmVzcG9uc2VIYW5kbGVyID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5yZXN1bHQgPT09IFwiYXV0aF91cmxcIikge1xuICAgICAgICAgIHRoaXMub25jZShgcmVzcG9uc2UtJHtpZH1gLCByZXNwb25zZUhhbmRsZXIpO1xuICAgICAgICAgIHRoaXMuZW1pdChcImF1dGhVcmxcIiwgcmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICAgICAgY2IocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmNlKGByZXNwb25zZS0ke2lkfWAsIHJlc3BvbnNlSGFuZGxlcik7XG4gICAgfSk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQsXG4gICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSxcbiAgICAgIHRhZ3M6IFtbXCJwXCIsIHJlbW90ZVB1YmtleV1dLFxuICAgICAgcHVia2V5OiBsb2NhbFVzZXIucHVia2V5XG4gICAgfSk7XG4gICAgZXZlbnQuY29udGVudCA9IGF3YWl0IHRoaXMuc2lnbmVyLmVuY3J5cHQocmVtb3RlVXNlciwgZXZlbnQuY29udGVudCwgdGhpcy5lbmNyeXB0aW9uVHlwZSk7XG4gICAgYXdhaXQgZXZlbnQuc2lnbih0aGlzLnNpZ25lcik7XG4gICAgYXdhaXQgZXZlbnQucHVibGlzaCh0aGlzLnJlbGF5U2V0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9jb25uZWN0LnRzXG52YXIgQ29ubmVjdEV2ZW50SGFuZGxpbmdTdHJhdGVneSA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtfLCB0b2tlbl0gPSBwYXJhbXM7XG4gICAgY29uc3QgZGVidWc4ID0gYmFja2VuZC5kZWJ1Zy5leHRlbmQoXCJjb25uZWN0XCIpO1xuICAgIGRlYnVnOChgY29ubmVjdGlvbiByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9YCk7XG4gICAgaWYgKHRva2VuICYmIGJhY2tlbmQuYXBwbHlUb2tlbikge1xuICAgICAgZGVidWc4KFwiYXBwbHlpbmcgdG9rZW5cIik7XG4gICAgICBhd2FpdCBiYWNrZW5kLmFwcGx5VG9rZW4ocmVtb3RlUHVia2V5LCB0b2tlbik7XG4gICAgfVxuICAgIGlmIChhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgICAgaWQsXG4gICAgICBwdWJrZXk6IHJlbW90ZVB1YmtleSxcbiAgICAgIG1ldGhvZDogXCJjb25uZWN0XCIsXG4gICAgICBwYXJhbXM6IHRva2VuXG4gICAgfSkpIHtcbiAgICAgIGRlYnVnOChgY29ubmVjdGlvbiByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IGFsbG93ZWRgKTtcbiAgICAgIHJldHVybiBcImFja1wiO1xuICAgIH1cbiAgICBkZWJ1ZzgoYGNvbm5lY3Rpb24gcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSByZWplY3RlZGApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvZ2V0LXB1YmxpYy1rZXkudHNcbnZhciBHZXRQdWJsaWNLZXlIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgX2lkLCBfcmVtb3RlUHVia2V5LCBfcGFyYW1zKSB7XG4gICAgcmV0dXJuIGJhY2tlbmQubG9jYWxVc2VyPy5wdWJrZXk7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvbmlwMDQtZGVjcnlwdC50c1xudmFyIE5pcDA0RGVjcnlwdEhhbmRsaW5nU3RyYXRlZ3kgPSBjbGFzcyB7XG4gIGFzeW5jIGhhbmRsZShiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBwYXJhbXMpIHtcbiAgICBjb25zdCBbc2VuZGVyUHVia2V5LCBwYXlsb2FkXSA9IHBhcmFtcztcbiAgICBjb25zdCBzZW5kZXJVc2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXk6IHNlbmRlclB1YmtleSB9KTtcbiAgICBjb25zdCBkZWNyeXB0ZWRQYXlsb2FkID0gYXdhaXQgZGVjcnlwdDIoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgc2VuZGVyVXNlciwgcGF5bG9hZCk7XG4gICAgcmV0dXJuIGRlY3J5cHRlZFBheWxvYWQ7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0MihiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBzZW5kZXJVc2VyLCBwYXlsb2FkKSB7XG4gIGlmICghYXdhaXQgYmFja2VuZC5wdWJrZXlBbGxvd2VkKHtcbiAgICBpZCxcbiAgICBwdWJrZXk6IHJlbW90ZVB1YmtleSxcbiAgICBtZXRob2Q6IFwibmlwMDRfZGVjcnlwdFwiLFxuICAgIHBhcmFtczogcGF5bG9hZFxuICB9KSkge1xuICAgIGJhY2tlbmQuZGVidWcoYGRlY3J5cHQgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSByZWplY3RlZGApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IGJhY2tlbmQuc2lnbmVyLmRlY3J5cHQoc2VuZGVyVXNlciwgcGF5bG9hZCwgXCJuaXAwNFwiKTtcbn1cblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9uaXAwNC1lbmNyeXB0LnRzXG52YXIgTmlwMDRFbmNyeXB0SGFuZGxpbmdTdHJhdGVneSA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtyZWNpcGllbnRQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlY2lwaWVudFVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogcmVjaXBpZW50UHVia2V5IH0pO1xuICAgIGNvbnN0IGVuY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBlbmNyeXB0MihiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCByZWNpcGllbnRVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZW5jcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHQyKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHJlY2lwaWVudFVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXAwNF9lbmNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZW5jcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZW5jcnlwdChyZWNpcGllbnRVc2VyLCBwYXlsb2FkLCBcIm5pcDA0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL25pcDQ0LWRlY3J5cHQudHNcbnZhciBOaXAwNERlY3J5cHRIYW5kbGluZ1N0cmF0ZWd5MiA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtzZW5kZXJQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHNlbmRlclVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogc2VuZGVyUHVia2V5IH0pO1xuICAgIGNvbnN0IGRlY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBkZWNyeXB0MyhiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBzZW5kZXJVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZGVjcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQzKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHNlbmRlclVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXA0NF9kZWNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZGVjcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZGVjcnlwdChzZW5kZXJVc2VyLCBwYXlsb2FkLCBcIm5pcDQ0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL25pcDQ0LWVuY3J5cHQudHNcbnZhciBOaXAwNEVuY3J5cHRIYW5kbGluZ1N0cmF0ZWd5MiA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtyZWNpcGllbnRQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlY2lwaWVudFVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogcmVjaXBpZW50UHVia2V5IH0pO1xuICAgIGNvbnN0IGVuY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBlbmNyeXB0MyhiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCByZWNpcGllbnRVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZW5jcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHQzKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHJlY2lwaWVudFVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXA0NF9lbmNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZW5jcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZW5jcnlwdChyZWNpcGllbnRVc2VyLCBwYXlsb2FkLCBcIm5pcDQ0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL3BpbmcudHNcbnZhciBQaW5nRXZlbnRIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgX3BhcmFtcykge1xuICAgIGNvbnN0IGRlYnVnOCA9IGJhY2tlbmQuZGVidWcuZXh0ZW5kKFwicGluZ1wiKTtcbiAgICBkZWJ1ZzgoYHBpbmcgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fWApO1xuICAgIGlmIChhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoeyBpZCwgcHVia2V5OiByZW1vdGVQdWJrZXksIG1ldGhvZDogXCJwaW5nXCIgfSkpIHtcbiAgICAgIGRlYnVnOChgY29ubmVjdGlvbiByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IGFsbG93ZWRgKTtcbiAgICAgIHJldHVybiBcInBvbmdcIjtcbiAgICB9XG4gICAgZGVidWc4KGBjb25uZWN0aW9uIHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gcmVqZWN0ZWRgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL3NpZ24tZXZlbnQudHNcbnZhciBTaWduRXZlbnRIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gICAgY29uc3QgZXZlbnQgPSBhd2FpdCBzaWduRXZlbnQoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKTtcbiAgICBpZiAoIWV2ZW50KSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhd2FpdCBldmVudC50b05vc3RyRXZlbnQoKSk7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBzaWduRXZlbnQoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gIGNvbnN0IFtldmVudFN0cmluZ10gPSBwYXJhbXM7XG4gIGJhY2tlbmQuZGVidWcoYHNpZ24gZXZlbnQgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fWApO1xuICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudChiYWNrZW5kLm5kaywgSlNPTi5wYXJzZShldmVudFN0cmluZykpO1xuICBiYWNrZW5kLmRlYnVnKFwiZXZlbnQgdG8gc2lnblwiLCBldmVudC5yYXdFdmVudCgpKTtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJzaWduX2V2ZW50XCIsXG4gICAgcGFyYW1zOiBldmVudFxuICB9KSkge1xuICAgIGJhY2tlbmQuZGVidWcoYHNpZ24gZXZlbnQgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSByZWplY3RlZGApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgYmFja2VuZC5kZWJ1Zyhgc2lnbiBldmVudCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IGFsbG93ZWRgKTtcbiAgYXdhaXQgZXZlbnQuc2lnbihiYWNrZW5kLnNpZ25lcik7XG4gIHJldHVybiBldmVudDtcbn1cblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9pbmRleC50c1xudmFyIE5ES05pcDQ2QmFja2VuZCA9IGNsYXNzIHtcbiAgbmRrO1xuICBzaWduZXI7XG4gIGxvY2FsVXNlcjtcbiAgZGVidWc7XG4gIHJwYztcbiAgcGVybWl0Q2FsbGJhY2s7XG4gIHJlbGF5VXJscztcbiAgLyoqXG4gICAqIEBwYXJhbSBuZGsgVGhlIE5ESyBpbnN0YW5jZSB0byB1c2VcbiAgICogQHBhcmFtIHByaXZhdGVLZXlPclNpZ25lciBUaGUgcHJpdmF0ZSBrZXkgb3Igc2lnbmVyIG9mIHRoZSBucHViIHRoYXQgd2FudHMgdG8gYmUgcHVibGlzaGVkIGFzXG4gICAqIEBwYXJhbSBwZXJtaXRDYWxsYmFjayBDYWxsYmFjayBleGVjdXRlZCB3aGVuIHBlcm1pc3Npb24gaXMgcmVxdWVzdGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuZGssIHByaXZhdGVLZXlPclNpZ25lciwgcGVybWl0Q2FsbGJhY2ssIHJlbGF5VXJscykge1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIGlmIChwcml2YXRlS2V5T3JTaWduZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICB0aGlzLnNpZ25lciA9IG5ldyBOREtQcml2YXRlS2V5U2lnbmVyKHByaXZhdGVLZXlPclNpZ25lcik7XG4gICAgfSBlbHNlIGlmIChwcml2YXRlS2V5T3JTaWduZXIgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgIHRoaXMuc2lnbmVyID0gbmV3IE5ES1ByaXZhdGVLZXlTaWduZXIoaGV4VG9CeXRlczIocHJpdmF0ZUtleU9yU2lnbmVyKSk7XG4gICAgfSBlbHNlIGlmIChwcml2YXRlS2V5T3JTaWduZXIgaW5zdGFuY2VvZiBOREtQcml2YXRlS2V5U2lnbmVyKSB7XG4gICAgICB0aGlzLnNpZ25lciA9IHByaXZhdGVLZXlPclNpZ25lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduZXJcIik7XG4gICAgfVxuICAgIHRoaXMuZGVidWcgPSBuZGsuZGVidWcuZXh0ZW5kKFwibmlwNDY6YmFja2VuZFwiKTtcbiAgICB0aGlzLnJlbGF5VXJscyA9IHJlbGF5VXJscyA/PyBBcnJheS5mcm9tKG5kay5wb29sLnJlbGF5cy5rZXlzKCkpO1xuICAgIHRoaXMucnBjID0gbmV3IE5ES05vc3RyUnBjKG5kaywgdGhpcy5zaWduZXIsIHRoaXMuZGVidWcsIHRoaXMucmVsYXlVcmxzKTtcbiAgICB0aGlzLnBlcm1pdENhbGxiYWNrID0gcGVybWl0Q2FsbGJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHN0YXJ0cyB0aGUgYmFja2VuZCwgd2hpY2ggd2lsbCBzdGFydCBsaXN0ZW5pbmcgZm9yIGluY29taW5nXG4gICAqIHJlcXVlc3RzLlxuICAgKi9cbiAgYXN5bmMgc3RhcnQoKSB7XG4gICAgdGhpcy5sb2NhbFVzZXIgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3Qgc3ViID0gdGhpcy5uZGsuc3Vic2NyaWJlKFxuICAgICAge1xuICAgICAgICBraW5kczogWzI0MTMzXSxcbiAgICAgICAgXCIjcFwiOiBbdGhpcy5sb2NhbFVzZXIucHVia2V5XVxuICAgICAgfSxcbiAgICAgIHsgY2xvc2VPbkVvc2U6IGZhbHNlIH1cbiAgICApO1xuICAgIHN1Yi5vbihcImV2ZW50XCIsIChlKSA9PiB0aGlzLmhhbmRsZUluY29taW5nRXZlbnQoZSkpO1xuICB9XG4gIGhhbmRsZXJzID0ge1xuICAgIGNvbm5lY3Q6IG5ldyBDb25uZWN0RXZlbnRIYW5kbGluZ1N0cmF0ZWd5KCksXG4gICAgc2lnbl9ldmVudDogbmV3IFNpZ25FdmVudEhhbmRsaW5nU3RyYXRlZ3koKSxcbiAgICBuaXAwNF9lbmNyeXB0OiBuZXcgTmlwMDRFbmNyeXB0SGFuZGxpbmdTdHJhdGVneSgpLFxuICAgIG5pcDA0X2RlY3J5cHQ6IG5ldyBOaXAwNERlY3J5cHRIYW5kbGluZ1N0cmF0ZWd5KCksXG4gICAgbmlwNDRfZW5jcnlwdDogbmV3IE5pcDA0RW5jcnlwdEhhbmRsaW5nU3RyYXRlZ3kyKCksXG4gICAgbmlwNDRfZGVjcnlwdDogbmV3IE5pcDA0RGVjcnlwdEhhbmRsaW5nU3RyYXRlZ3kyKCksXG4gICAgZ2V0X3B1YmxpY19rZXk6IG5ldyBHZXRQdWJsaWNLZXlIYW5kbGluZ1N0cmF0ZWd5KCksXG4gICAgcGluZzogbmV3IFBpbmdFdmVudEhhbmRsaW5nU3RyYXRlZ3koKVxuICB9O1xuICAvKipcbiAgICogRW5hYmxlcyB0aGUgdXNlciB0byBzZXQgYSBjdXN0b20gc3RyYXRlZ3kgZm9yIGhhbmRsaW5nIGluY29taW5nIGV2ZW50cy5cbiAgICogQHBhcmFtIG1ldGhvZCAtIFRoZSBtZXRob2QgdG8gc2V0IHRoZSBzdHJhdGVneSBmb3JcbiAgICogQHBhcmFtIHN0cmF0ZWd5IC0gVGhlIHN0cmF0ZWd5IHRvIHNldFxuICAgKi9cbiAgc2V0U3RyYXRlZ3kobWV0aG9kLCBzdHJhdGVneSkge1xuICAgIHRoaXMuaGFuZGxlcnNbbWV0aG9kXSA9IHN0cmF0ZWd5O1xuICB9XG4gIC8qKlxuICAgKiBPdmVybG9hZCB0aGlzIG1ldGhvZCB0byBhcHBseSB0b2tlbnMsIHdoaWNoIGNhblxuICAgKiB3cmFwIHBlcm1pc3Npb24gc2V0cyB0byBiZSBhcHBsaWVkIHRvIGEgcHVia2V5LlxuICAgKiBAcGFyYW0gcHVia2V5IHB1YmxpYyBrZXkgdG8gYXBwbHkgdG9rZW4gdG9cbiAgICogQHBhcmFtIHRva2VuIHRva2VuIHRvIGFwcGx5XG4gICAqL1xuICBhc3luYyBhcHBseVRva2VuKF9wdWJrZXksIF90b2tlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvbm5lY3Rpb24gdG9rZW4gbm90IHN1cHBvcnRlZFwiKTtcbiAgfVxuICBhc3luYyBoYW5kbGVJbmNvbWluZ0V2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgeyBpZCwgbWV0aG9kLCBwYXJhbXMgfSA9IGF3YWl0IHRoaXMucnBjLnBhcnNlRXZlbnQoZXZlbnQpO1xuICAgIGNvbnN0IHJlbW90ZVB1YmtleSA9IGV2ZW50LnB1YmtleTtcbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgdGhpcy5kZWJ1ZyhcImluY29taW5nIGV2ZW50XCIsIHsgaWQsIG1ldGhvZCwgcGFyYW1zIH0pO1xuICAgIGlmICghZXZlbnQudmVyaWZ5U2lnbmF0dXJlKGZhbHNlKSkge1xuICAgICAgdGhpcy5kZWJ1ZyhcImludmFsaWQgc2lnbmF0dXJlXCIsIGV2ZW50LnJhd0V2ZW50KCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdHJhdGVneSA9IHRoaXMuaGFuZGxlcnNbbWV0aG9kXTtcbiAgICBpZiAoc3RyYXRlZ3kpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgc3RyYXRlZ3kuaGFuZGxlKHRoaXMsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJlcnJvciBoYW5kbGluZyBldmVudFwiLCBlLCB7IGlkLCBtZXRob2QsIHBhcmFtcyB9KTtcbiAgICAgICAgdGhpcy5ycGMuc2VuZFJlc3BvbnNlKGlkLCByZW1vdGVQdWJrZXksIFwiZXJyb3JcIiwgdm9pZCAwLCBlLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlYnVnKFwidW5zdXBwb3J0ZWQgbWV0aG9kXCIsIHsgbWV0aG9kLCBwYXJhbXMgfSk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgdGhpcy5kZWJ1Zyhgc2VuZGluZyByZXNwb25zZSB0byAke3JlbW90ZVB1YmtleX1gLCByZXNwb25zZSk7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVzcG9uc2UoaWQsIHJlbW90ZVB1YmtleSwgcmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVzcG9uc2UoaWQsIHJlbW90ZVB1YmtleSwgXCJlcnJvclwiLCB2b2lkIDAsIFwiTm90IGF1dGhvcml6ZWRcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGVuIGJ5IHRoZSB1c2VyIHRvIGFsbG93IG9yIHJlamVjdCBpbmNvbWluZ1xuICAgKiBjb25uZWN0aW9ucy5cbiAgICovXG4gIGFzeW5jIHB1YmtleUFsbG93ZWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMucGVybWl0Q2FsbGJhY2socGFyYW1zKTtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvaW5kZXgudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI2IH0gZnJvbSBcInRzZWVwXCI7XG5cbi8vIHNyYy9zaWduZXJzL2Rlc2VyaWFsaXphdGlvbi50c1xudmFyIHNpZ25lclJlZ2lzdHJ5ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbnNpZ25lclJlZ2lzdHJ5LnNldChcInByaXZhdGUta2V5XCIsIE5ES1ByaXZhdGVLZXlTaWduZXIpO1xuc2lnbmVyUmVnaXN0cnkuc2V0KFwibmlwMDdcIiwgTkRLTmlwMDdTaWduZXIpO1xuc2lnbmVyUmVnaXN0cnkuc2V0KFwibmlwNDZcIiwgTkRLTmlwNDZTaWduZXIpO1xuYXN5bmMgZnVuY3Rpb24gbmRrU2lnbmVyRnJvbVBheWxvYWQocGF5bG9hZFN0cmluZywgbmRrKSB7XG4gIGxldCBwYXJzZWQ7XG4gIHRyeSB7XG4gICAgcGFyc2VkID0gSlNPTi5wYXJzZShwYXlsb2FkU3RyaW5nKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHNpZ25lciBwYXlsb2FkOiAke2UgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKX1gKTtcbiAgfVxuICBjb25zdCBTaWduZXJDbGFzcyA9IHNpZ25lclJlZ2lzdHJ5LmdldChwYXJzZWQudHlwZSk7XG4gIGlmICghU2lnbmVyQ2xhc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc2lnbmVyIHR5cGU6ICR7cGFyc2VkLnR5cGV9YCk7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgU2lnbmVyQ2xhc3MuZnJvbVBheWxvYWQocGF5bG9hZFN0cmluZywgbmRrKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnN0IGVycm9yTXNnID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpO1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlc2VyaWFsaXplIHNpZ25lciB0eXBlICR7cGFyc2VkLnR5cGV9OiAke2Vycm9yTXNnfWApO1xuICB9XG59XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2luZGV4LnRzXG52YXIgTkRLTmlwNDZTaWduZXIgPSBjbGFzcyBfTkRLTmlwNDZTaWduZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXI2IHtcbiAgbmRrO1xuICBfdXNlcjtcbiAgLyoqXG4gICAqIFRoZSBwdWJrZXkgb2YgdGhlIGJ1bmtlciB0aGF0IHdpbGwgYmUgcHJvdmlkaW5nIHNpZ25hdHVyZXNcbiAgICovXG4gIGJ1bmtlclB1YmtleTtcbiAgLyoqXG4gICAqIFRoZSBwdWJrZXkgb2YgdGhlIHVzZXIgdGhhdCBldmVudHMgd2lsbCBiZSBwdWJsaXNoZWQgYXNcbiAgICovXG4gIHVzZXJQdWJrZXk7XG4gIGdldCBwdWJrZXkoKSB7XG4gICAgaWYgKCF0aGlzLnVzZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIk5vdCByZWFkeVwiKTtcbiAgICByZXR1cm4gdGhpcy51c2VyUHVia2V5O1xuICB9XG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBzZWNyZXQgdmFsdWUgcHJvdmlkZWQgdG8gY29ubmVjdCB0byB0aGUgYnVua2VyXG4gICAqL1xuICBzZWNyZXQ7XG4gIGxvY2FsU2lnbmVyO1xuICBuaXAwNTtcbiAgcnBjO1xuICBkZWJ1ZztcbiAgcmVsYXlVcmxzO1xuICBzdWJzY3JpcHRpb247XG4gIC8qKlxuICAgKiBAcGFyYW0gbmRrIC0gVGhlIE5ESyBpbnN0YW5jZSB0byB1c2VcbiAgICogQHBhcmFtIHVzZXJPckNvbm5lY3Rpb25Ub2tlbiAtIFRoZSBwdWJsaWMga2V5LCBvciBhIGNvbm5lY3Rpb24gdG9rZW4sIG9mIHRoZSBucHViIHRoYXQgd2FudHMgdG8gYmUgcHVibGlzaGVkIGFzXG4gICAqIEBwYXJhbSBsb2NhbFNpZ25lciAtIFRoZSBzaWduZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmVxdWVzdCBldmVudHMgdG8gYmUgc2lnbmVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuZGssIHVzZXJPckNvbm5lY3Rpb25Ub2tlbiwgbG9jYWxTaWduZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMuZGVidWcgPSBuZGsuZGVidWcuZXh0ZW5kKFwibmlwNDY6c2lnbmVyXCIpO1xuICAgIGlmICh1c2VyT3JDb25uZWN0aW9uVG9rZW4uc3RhcnRzV2l0aChcImJ1bmtlcjovL1wiKSkge1xuICAgICAgdGhpcy5jb25uZWN0aW9uVG9rZW5Jbml0KHVzZXJPckNvbm5lY3Rpb25Ub2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmlwMDVJbml0KHVzZXJPckNvbm5lY3Rpb25Ub2tlbik7XG4gICAgfVxuICAgIGlmICghbG9jYWxTaWduZXIpIHtcbiAgICAgIHRoaXMubG9jYWxTaWduZXIgPSBOREtQcml2YXRlS2V5U2lnbmVyLmdlbmVyYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9jYWxTaWduZXIgPSBsb2NhbFNpZ25lcjtcbiAgICB9XG4gICAgdGhpcy5ycGMgPSBuZXcgTkRLTm9zdHJScGModGhpcy5uZGssIHRoaXMubG9jYWxTaWduZXIsIHRoaXMuZGVidWcsIHRoaXMucmVsYXlVcmxzKTtcbiAgfVxuICBjb25uZWN0aW9uVG9rZW5Jbml0KGNvbm5lY3Rpb25Ub2tlbikge1xuICAgIGNvbnN0IGJ1bmtlclVybCA9IG5ldyBVUkwoY29ubmVjdGlvblRva2VuKTtcbiAgICBjb25zdCBidW5rZXJQdWJrZXkgPSBidW5rZXJVcmwuaG9zdG5hbWUgfHwgYnVua2VyVXJsLnBhdGhuYW1lLnJlcGxhY2UoL15cXC9cXC8vLCBcIlwiKTtcbiAgICBjb25zdCB1c2VyUHVia2V5ID0gYnVua2VyVXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJwdWJrZXlcIik7XG4gICAgY29uc3QgcmVsYXlVcmxzID0gYnVua2VyVXJsLnNlYXJjaFBhcmFtcy5nZXRBbGwoXCJyZWxheVwiKTtcbiAgICBjb25zdCBzZWNyZXQgPSBidW5rZXJVcmwuc2VhcmNoUGFyYW1zLmdldChcInNlY3JldFwiKTtcbiAgICB0aGlzLmJ1bmtlclB1YmtleSA9IGJ1bmtlclB1YmtleTtcbiAgICB0aGlzLnVzZXJQdWJrZXkgPSB1c2VyUHVia2V5O1xuICAgIHRoaXMucmVsYXlVcmxzID0gcmVsYXlVcmxzO1xuICAgIHRoaXMuc2VjcmV0ID0gc2VjcmV0O1xuICB9XG4gIG5pcDA1SW5pdChuaXAwNSkge1xuICAgIHRoaXMubmlwMDUgPSBuaXAwNTtcbiAgfVxuICAvKipcbiAgICogV2Ugc3RhcnQgbGlzdGVuaW5nIGZvciBldmVudHMgZnJvbSB0aGUgYnVua2VyXG4gICAqL1xuICBhc3luYyBzdGFydExpc3RlbmluZygpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHJldHVybjtcbiAgICBjb25zdCBsb2NhbFVzZXIgPSBhd2FpdCB0aGlzLmxvY2FsU2lnbmVyLnVzZXIoKTtcbiAgICBpZiAoIWxvY2FsVXNlcikgdGhyb3cgbmV3IEVycm9yKFwiTG9jYWwgc2lnbmVyIG5vdCByZWFkeVwiKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IGF3YWl0IHRoaXMucnBjLnN1YnNjcmliZSh7XG4gICAgICBraW5kczogWzI0MTMzIC8qIE5vc3RyQ29ubmVjdCAqL10sXG4gICAgICBcIiNwXCI6IFtsb2NhbFVzZXIucHVia2V5XVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIgdGhhdCBpcyBiZWluZyBwdWJsaXNoZWQgYXNcbiAgICovXG4gIGFzeW5jIHVzZXIoKSB7XG4gICAgaWYgKHRoaXMuX3VzZXIpIHJldHVybiB0aGlzLl91c2VyO1xuICAgIHJldHVybiB0aGlzLmJsb2NrVW50aWxSZWFkeSgpO1xuICB9XG4gIGdldCB1c2VyU3luYygpIHtcbiAgICBpZiAoIXRoaXMuX3VzZXIpIHRocm93IG5ldyBFcnJvcihcIlJlbW90ZSB1c2VyIG5vdCByZWFkeSBzeW5jaHJvbm91c2x5XCIpO1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIGFzeW5jIGJsb2NrVW50aWxSZWFkeSgpIHtcbiAgICBpZiAodGhpcy5uaXAwNSAmJiAhdGhpcy51c2VyUHVia2V5KSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgTkRLVXNlci5mcm9tTmlwMDUodGhpcy5uaXAwNSwgdGhpcy5uZGspO1xuICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgdGhpcy5fdXNlciA9IHVzZXI7XG4gICAgICAgIHRoaXMudXNlclB1YmtleSA9IHVzZXIucHVia2V5O1xuICAgICAgICB0aGlzLnJlbGF5VXJscyA9IHVzZXIubmlwNDZVcmxzO1xuICAgICAgICB0aGlzLnJwYyA9IG5ldyBOREtOb3N0clJwYyh0aGlzLm5kaywgdGhpcy5sb2NhbFNpZ25lciwgdGhpcy5kZWJ1ZywgdGhpcy5yZWxheVVybHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuYnVua2VyUHVia2V5ICYmIHRoaXMudXNlclB1YmtleSkge1xuICAgICAgdGhpcy5idW5rZXJQdWJrZXkgPSB0aGlzLnVzZXJQdWJrZXk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5zdGFydExpc3RlbmluZygpO1xuICAgIHRoaXMucnBjLm9uKFwiYXV0aFVybFwiLCAoLi4ucHJvcHMpID0+IHtcbiAgICAgIHRoaXMuZW1pdChcImF1dGhVcmxcIiwgLi4ucHJvcHMpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjb25uZWN0UGFyYW1zID0gW3RoaXMudXNlclB1YmtleSA/PyBcIlwiXTtcbiAgICAgIGlmICh0aGlzLnNlY3JldCkgY29ubmVjdFBhcmFtcy5wdXNoKHRoaXMuc2VjcmV0KTtcbiAgICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KHRoaXMuYnVua2VyUHVia2V5LCBcImNvbm5lY3RcIiwgY29ubmVjdFBhcmFtcywgMjQxMzMsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2UucmVzdWx0ID09PSBcImFja1wiKSB7XG4gICAgICAgICAgdGhpcy5nZXRQdWJsaWNLZXkoKS50aGVuKChwdWJrZXkpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXNlclB1YmtleSA9IHB1YmtleTtcbiAgICAgICAgICAgIHRoaXMuX3VzZXIgPSB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5IH0pO1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLl91c2VyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXRQdWJsaWNLZXkoKSB7XG4gICAgaWYgKHRoaXMudXNlclB1YmtleSkgcmV0dXJuIHRoaXMudXNlclB1YmtleTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIF9yZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KHRoaXMuYnVua2VyUHVia2V5LCBcImdldF9wdWJsaWNfa2V5XCIsIFtdLCAyNDEzMywgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIHJlc29sdmUocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGVuY3J5cHRpb25FbmFibGVkKHNjaGVtZSkge1xuICAgIGlmIChzY2hlbWUpIHJldHVybiBbc2NoZW1lXTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtcIm5pcDA0XCIsIFwibmlwNDRcIl0pO1xuICB9XG4gIGFzeW5jIGVuY3J5cHQocmVjaXBpZW50LCB2YWx1ZSwgc2NoZW1lID0gXCJuaXAwNFwiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvbihyZWNpcGllbnQsIHZhbHVlLCBzY2hlbWUsIFwiZW5jcnlwdFwiKTtcbiAgfVxuICBhc3luYyBkZWNyeXB0KHNlbmRlciwgdmFsdWUsIHNjaGVtZSA9IFwibmlwMDRcIikge1xuICAgIHJldHVybiB0aGlzLmVuY3J5cHRpb24oc2VuZGVyLCB2YWx1ZSwgc2NoZW1lLCBcImRlY3J5cHRcIik7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdGlvbihwZWVyLCB2YWx1ZSwgc2NoZW1lLCBtZXRob2QpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmJ1bmtlclB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiQnVua2VyIHB1YmtleSBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QoXG4gICAgICAgIHRoaXMuYnVua2VyUHVia2V5LFxuICAgICAgICBgJHtzY2hlbWV9XyR7bWV0aG9kfWAsXG4gICAgICAgIFtwZWVyLnB1YmtleSwgdmFsdWVdLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBhc3luYyBzaWduKGV2ZW50KSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KFxuICAgICAgICB0aGlzLmJ1bmtlclB1YmtleSxcbiAgICAgICAgXCJzaWduX2V2ZW50XCIsXG4gICAgICAgIFtKU09OLnN0cmluZ2lmeShldmVudCldLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgICAgIHJlc29sdmUoanNvbi5zaWcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIGNyZWF0aW5nIGEgbmV3IGFjY291bnQgb24gdGhlIHJlbW90ZSBzZXJ2ZXIuXG4gICAqIEBwYXJhbSB1c2VybmFtZSBEZXNpcmVkIHVzZXJuYW1lIGZvciB0aGUgTklQLTA1XG4gICAqIEBwYXJhbSBkb21haW4gRGVzaXJlZCBkb21haW4gZm9yIHRoZSBOSVAtMDVcbiAgICogQHBhcmFtIGVtYWlsIEVtYWlsIGFkZHJlc3MgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBhY2NvdW50IC0tIFJlbW90ZSBzZXJ2ZXJzIG1heSB1c2UgdGhpcyBmb3IgcmVjb3ZlcnlcbiAgICogQHJldHVybnMgVGhlIHB1YmxpYyBrZXkgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgYWNjb3VudFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQWNjb3VudCh1c2VybmFtZSwgZG9tYWluLCBlbWFpbCkge1xuICAgIGF3YWl0IHRoaXMuc3RhcnRMaXN0ZW5pbmcoKTtcbiAgICBjb25zdCByZXEgPSBbXTtcbiAgICBpZiAodXNlcm5hbWUpIHJlcS5wdXNoKHVzZXJuYW1lKTtcbiAgICBpZiAoZG9tYWluKSByZXEucHVzaChkb21haW4pO1xuICAgIGlmIChlbWFpbCkgcmVxLnB1c2goZW1haWwpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMuYnVua2VyUHVia2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJCdW5rZXIgcHVia2V5IG5vdCBzZXRcIik7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVxdWVzdChcbiAgICAgICAgdGhpcy5idW5rZXJQdWJrZXksXG4gICAgICAgIFwiY3JlYXRlX2FjY291bnRcIixcbiAgICAgICAgcmVxLFxuICAgICAgICAyNDEzMyAvKiBOb3N0ckNvbm5lY3QgKi8sXG4gICAgICAgIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGlmICghcmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YmtleSA9IHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgIHJlc29sdmUocHVia2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIHNpZ25lcidzIGNvbm5lY3Rpb24gZGV0YWlscyBhbmQgbG9jYWwgc2lnbmVyIHN0YXRlLlxuICAgKiBAcmV0dXJucyBBIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHR5cGUsIGNvbm5lY3Rpb24gaW5mbywgYW5kIGxvY2FsIHNpZ25lciBwYXlsb2FkLlxuICAgKi9cbiAgdG9QYXlsb2FkKCkge1xuICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkgfHwgIXRoaXMudXNlclB1YmtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTklQLTQ2IHNpZ25lciBpcyBub3QgZnVsbHkgaW5pdGlhbGl6ZWQgZm9yIHNlcmlhbGl6YXRpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICB0eXBlOiBcIm5pcDQ2XCIsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGJ1bmtlclB1YmtleTogdGhpcy5idW5rZXJQdWJrZXksXG4gICAgICAgIHVzZXJQdWJrZXk6IHRoaXMudXNlclB1YmtleSxcbiAgICAgICAgcmVsYXlVcmxzOiB0aGlzLnJlbGF5VXJscyxcbiAgICAgICAgc2VjcmV0OiB0aGlzLnNlY3JldCxcbiAgICAgICAgbG9jYWxTaWduZXJQYXlsb2FkOiB0aGlzLmxvY2FsU2lnbmVyLnRvUGF5bG9hZCgpLFxuICAgICAgICAvLyBTdG9yZSBuaXAwNSBpZiBpdCB3YXMgdXNlZCBmb3IgaW5pdGlhbGl6YXRpb24sIG90aGVyd2lzZSBudWxsXG4gICAgICAgIG5pcDA1OiB0aGlzLm5pcDA1IHx8IG51bGxcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgfVxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBzaWduZXIgZnJvbSBhIHBheWxvYWQgc3RyaW5nLlxuICAgKiBAcGFyYW0gcGF5bG9hZFN0cmluZyBUaGUgSlNPTiBzdHJpbmcgb2J0YWluZWQgZnJvbSB0b1BheWxvYWQoKS5cbiAgICogQHBhcmFtIG5kayBUaGUgTkRLIGluc3RhbmNlLCByZXF1aXJlZCBmb3IgTklQLTQ2LlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBOREtOaXA0NlNpZ25lci5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBmcm9tUGF5bG9hZChwYXlsb2FkU3RyaW5nLCBuZGspIHtcbiAgICBpZiAoIW5kaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIGlzIHJlcXVpcmVkIHRvIGRlc2VyaWFsaXplIE5JUC00NiBzaWduZXJcIik7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UocGF5bG9hZFN0cmluZyk7XG4gICAgaWYgKHBhcnNlZC50eXBlICE9PSBcIm5pcDQ2XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXlsb2FkIHR5cGU6IGV4cGVjdGVkICduaXA0NicsIGdvdCAke3BhcnNlZC50eXBlfWApO1xuICAgIH1cbiAgICBjb25zdCBwYXlsb2FkID0gcGFyc2VkLnBheWxvYWQ7XG4gICAgaWYgKCFwYXlsb2FkIHx8IHR5cGVvZiBwYXlsb2FkICE9PSBcIm9iamVjdFwiIHx8ICFwYXlsb2FkLmxvY2FsU2lnbmVyUGF5bG9hZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXlsb2FkIGNvbnRlbnQgZm9yIG5pcDQ2IHNpZ25lclwiKTtcbiAgICB9XG4gICAgY29uc3QgbG9jYWxTaWduZXIgPSBhd2FpdCBuZGtTaWduZXJGcm9tUGF5bG9hZChwYXlsb2FkLmxvY2FsU2lnbmVyUGF5bG9hZCwgbmRrKTtcbiAgICBpZiAoIWxvY2FsU2lnbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVzZXJpYWxpemUgbG9jYWwgc2lnbmVyIGZvciBOSVAtNDZcIik7XG4gICAgfVxuICAgIGxldCBzaWduZXI7XG4gICAgaWYgKHBheWxvYWQubmlwMDUpIHtcbiAgICAgIHNpZ25lciA9IG5ldyBfTkRLTmlwNDZTaWduZXIobmRrLCBwYXlsb2FkLm5pcDA1LCBsb2NhbFNpZ25lcik7XG4gICAgICBzaWduZXIudXNlclB1YmtleSA9IHBheWxvYWQudXNlclB1YmtleTtcbiAgICAgIHNpZ25lci5idW5rZXJQdWJrZXkgPSBwYXlsb2FkLmJ1bmtlclB1YmtleTtcbiAgICAgIHNpZ25lci5yZWxheVVybHMgPSBwYXlsb2FkLnJlbGF5VXJscztcbiAgICAgIHNpZ25lci5zZWNyZXQgPSBwYXlsb2FkLnNlY3JldDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2lnbmVyID0gbmV3IF9OREtOaXA0NlNpZ25lcihuZGssIHBheWxvYWQudXNlclB1YmtleSwgbG9jYWxTaWduZXIpO1xuICAgICAgc2lnbmVyLmJ1bmtlclB1YmtleSA9IHBheWxvYWQuYnVua2VyUHVia2V5O1xuICAgICAgc2lnbmVyLnJlbGF5VXJscyA9IHBheWxvYWQucmVsYXlVcmxzO1xuICAgICAgc2lnbmVyLnNlY3JldCA9IHBheWxvYWQuc2VjcmV0O1xuICAgIH1cbiAgICByZXR1cm4gc2lnbmVyO1xuICB9XG59O1xuXG4vLyBzcmMvZHZtL3NjaGVkdWxlLnRzXG5mdW5jdGlvbiBhZGRSZWxheXMoZXZlbnQsIHJlbGF5cykge1xuICBjb25zdCB0YWdzID0gW107XG4gIGlmICghcmVsYXlzIHx8IHJlbGF5cy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zdCBwb29sUmVsYXlzID0gZXZlbnQubmRrPy5wb29sLnJlbGF5cztcbiAgICByZWxheXMgPSBwb29sUmVsYXlzID8gT2JqZWN0LmtleXMocG9vbFJlbGF5cykgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKHJlbGF5cyAmJiByZWxheXMubGVuZ3RoID4gMCkgdGFncy5wdXNoKFtcInJlbGF5c1wiLCAuLi5yZWxheXNdKTtcbiAgcmV0dXJuIHRhZ3M7XG59XG5hc3luYyBmdW5jdGlvbiBkdm1TY2hlZHVsZShldmVudHMsIGR2bSwgcmVsYXlzLCBlbmNyeXB0ZWQgPSB0cnVlLCB3YWl0Rm9yQ29uZmlybWF0aW9uRm9yTXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV2ZW50cykpIHtcbiAgICBldmVudHMgPSBbZXZlbnRzXTtcbiAgfVxuICBjb25zdCBuZGsgPSBldmVudHNbMF0ubmRrO1xuICBpZiAoIW5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIG5vdCBzZXRcIik7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgaWYgKCFldmVudC5zaWcpIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IG5vdCBzaWduZWRcIik7XG4gICAgaWYgKCFldmVudC5jcmVhdGVkX2F0KSB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBoYXMgbm8gZGF0ZVwiKTtcbiAgICBpZiAoIWR2bSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gRFZNIHNwZWNpZmllZFwiKTtcbiAgICBpZiAoZXZlbnQuY3JlYXRlZF9hdCA8PSBEYXRlLm5vdygpIC8gMWUzKSB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBuZWVkcyB0byBiZSBpbiB0aGUgZnV0dXJlXCIpO1xuICB9XG4gIGNvbnN0IHNjaGVkdWxlRXZlbnQgPSBuZXcgTkRLRFZNUmVxdWVzdChuZGssIHtcbiAgICBraW5kOiA1OTA1IC8qIERWTUV2ZW50U2NoZWR1bGUgKi9cbiAgfSk7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgc2NoZWR1bGVFdmVudC5hZGRJbnB1dChKU09OLnN0cmluZ2lmeShldmVudC5yYXdFdmVudCgpKSwgXCJ0ZXh0XCIpO1xuICB9XG4gIHNjaGVkdWxlRXZlbnQudGFncy5wdXNoKC4uLmFkZFJlbGF5cyhldmVudHNbMF0sIHJlbGF5cykpO1xuICBpZiAoZW5jcnlwdGVkKSB7XG4gICAgYXdhaXQgc2NoZWR1bGVFdmVudC5lbmNyeXB0aW9uKGR2bSk7XG4gIH0gZWxzZSB7XG4gICAgc2NoZWR1bGVFdmVudC5kdm0gPSBkdm07XG4gIH1cbiAgYXdhaXQgc2NoZWR1bGVFdmVudC5zaWduKCk7XG4gIGxldCByZXM7XG4gIGlmICh3YWl0Rm9yQ29uZmlybWF0aW9uRm9yTXMpIHtcbiAgICByZXMgPSBuZGsuc3Vic2NyaWJlKFxuICAgICAge1xuICAgICAgICBraW5kczogWzU5MDUgLyogRFZNRXZlbnRTY2hlZHVsZSAqLyArIDFlMywgN2UzIC8qIERWTUpvYkZlZWRiYWNrICovXSxcbiAgICAgICAgLi4uc2NoZWR1bGVFdmVudC5maWx0ZXIoKVxuICAgICAgfSxcbiAgICAgIHsgZ3JvdXBhYmxlOiBmYWxzZSwgY2xvc2VPbkVvc2U6IGZhbHNlIH1cbiAgICApO1xuICB9XG4gIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlamVjdCkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVzPy5zdG9wKCk7XG4gICAgICByZWplY3QoXCJUaW1lb3V0IHdhaXRpbmcgZm9yIGFuIGFuc3dlciBmcm9tIHRoZSBEVk1cIik7XG4gICAgfSwgd2FpdEZvckNvbmZpcm1hdGlvbkZvck1zKTtcbiAgfSk7XG4gIGNvbnN0IHNjaGVkdWxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAod2FpdEZvckNvbmZpcm1hdGlvbkZvck1zKSB7XG4gICAgICByZXM/Lm9uKFwiZXZlbnRcIiwgYXN5bmMgKGUpID0+IHtcbiAgICAgICAgcmVzPy5zdG9wKCk7XG4gICAgICAgIGlmIChlLmtpbmQgPT09IDdlMyAvKiBEVk1Kb2JGZWVkYmFjayAqLykge1xuICAgICAgICAgIGNvbnN0IGZlZWRiYWNrID0gYXdhaXQgTkRLRFZNSm9iRmVlZGJhY2suZnJvbShlKTtcbiAgICAgICAgICBpZiAoZmVlZGJhY2suc3RhdHVzID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c1RhZyA9IGZlZWRiYWNrLmdldE1hdGNoaW5nVGFncyhcInN0YXR1c1wiKTtcbiAgICAgICAgICAgIHJlamVjdChzdGF0dXNUYWc/LlsyXSA/PyBmZWVkYmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoZmVlZGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKGUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNjaGVkdWxlRXZlbnQucHVibGlzaCgpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKCF3YWl0Rm9yQ29uZmlybWF0aW9uRm9yTXMpIHJlc29sdmUodm9pZCAwKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKHdhaXRGb3JDb25maXJtYXRpb25Gb3JNcykge1xuICAgICAgUHJvbWlzZS5yYWNlKFt0aW1lb3V0UHJvbWlzZSwgc2NoZWR1bGVQcm9taXNlXSkudGhlbigoZSkgPT4ge1xuICAgICAgICByZXNvbHZlKGUpO1xuICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVQcm9taXNlLnRoZW4ocmVzb2x2ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL25kay9pbmRleC50c1xuaW1wb3J0IGRlYnVnNyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI4IH0gZnJvbSBcInRzZWVwXCI7XG5cbi8vIHNyYy9ldmVudHMvZGVkdXAudHNcbmZ1bmN0aW9uIGRlZHVwKGV2ZW50MSwgZXZlbnQyKSB7XG4gIGlmIChldmVudDEuY3JlYXRlZF9hdCA+IGV2ZW50Mi5jcmVhdGVkX2F0KSB7XG4gICAgcmV0dXJuIGV2ZW50MTtcbiAgfVxuICByZXR1cm4gZXZlbnQyO1xufVxuXG4vLyBzcmMvb3V0Ym94L3RyYWNrZXIudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI3IH0gZnJvbSBcInRzZWVwXCI7XG5pbXBvcnQgeyBMUlVDYWNoZSBhcyBMUlVDYWNoZTIgfSBmcm9tIFwidHlwZXNjcmlwdC1scnUtY2FjaGVcIjtcblxuLy8gc3JjL3V0aWxzL2dldC11c2Vycy1yZWxheS1saXN0LnRzXG5hc3luYyBmdW5jdGlvbiBnZXRSZWxheUxpc3RGb3JVc2VyKHB1YmtleSwgbmRrKSB7XG4gIGNvbnN0IGxpc3QgPSBhd2FpdCBnZXRSZWxheUxpc3RGb3JVc2VycyhbcHVia2V5XSwgbmRrKTtcbiAgcmV0dXJuIGxpc3QuZ2V0KHB1YmtleSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRSZWxheUxpc3RGb3JVc2VycyhwdWJrZXlzLCBuZGssIHNraXBDYWNoZSA9IGZhbHNlLCB0aW1lb3V0ID0gMWUzKSB7XG4gIGNvbnN0IHBvb2wgPSBuZGsub3V0Ym94UG9vbCB8fCBuZGsucG9vbDtcbiAgY29uc3Qgc2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCByZWxheSBvZiBwb29sLnJlbGF5cy52YWx1ZXMoKSkgc2V0LmFkZChyZWxheSk7XG4gIGNvbnN0IHJlbGF5TGlzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBmcm9tQ29udGFjdExpc3QgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCByZWxheVNldCA9IG5ldyBOREtSZWxheVNldChzZXQsIG5kayk7XG4gIGlmIChuZGsuY2FjaGVBZGFwdGVyPy5sb2NraW5nICYmICFza2lwQ2FjaGUpIHtcbiAgICBjb25zdCBjYWNoZWRMaXN0ID0gYXdhaXQgbmRrLmZldGNoRXZlbnRzKFxuICAgICAgeyBraW5kczogWzMsIDEwMDAyXSwgYXV0aG9yczogQXJyYXkuZnJvbShuZXcgU2V0KHB1YmtleXMpKSB9LFxuICAgICAgeyBjYWNoZVVzYWdlOiBcIk9OTFlfQ0FDSEVcIiAvKiBPTkxZX0NBQ0hFICovLCBzdWJJZDogXCJuZGstcmVsYXktbGlzdC1mZXRjaFwiIH1cbiAgICApO1xuICAgIGZvciAoY29uc3QgcmVsYXlMaXN0IG9mIGNhY2hlZExpc3QpIHtcbiAgICAgIGlmIChyZWxheUxpc3Qua2luZCA9PT0gMTAwMDIpIHJlbGF5TGlzdHMuc2V0KHJlbGF5TGlzdC5wdWJrZXksIE5ES1JlbGF5TGlzdC5mcm9tKHJlbGF5TGlzdCkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHJlbGF5TGlzdCBvZiBjYWNoZWRMaXN0KSB7XG4gICAgICBpZiAocmVsYXlMaXN0LmtpbmQgPT09IDMpIHtcbiAgICAgICAgaWYgKHJlbGF5TGlzdHMuaGFzKHJlbGF5TGlzdC5wdWJrZXkpKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbGlzdCA9IHJlbGF5TGlzdEZyb21LaW5kMyhuZGssIHJlbGF5TGlzdCk7XG4gICAgICAgIGlmIChsaXN0KSBmcm9tQ29udGFjdExpc3Quc2V0KHJlbGF5TGlzdC5wdWJrZXksIGxpc3QpO1xuICAgICAgfVxuICAgIH1cbiAgICBwdWJrZXlzID0gcHVia2V5cy5maWx0ZXIoKHB1YmtleSkgPT4gIXJlbGF5TGlzdHMuaGFzKHB1YmtleSkgJiYgIWZyb21Db250YWN0TGlzdC5oYXMocHVia2V5KSk7XG4gIH1cbiAgaWYgKHB1YmtleXMubGVuZ3RoID09PSAwKSByZXR1cm4gcmVsYXlMaXN0cztcbiAgY29uc3QgcmVsYXlMaXN0RXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgY29udGFjdExpc3RFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBoYW5kbGVTdWJzY3JpcHRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdWJzY3JpYmVPcHRzID0ge1xuICAgICAgICBjbG9zZU9uRW9zZTogdHJ1ZSxcbiAgICAgICAgcG9vbCxcbiAgICAgICAgZ3JvdXBhYmxlOiB0cnVlLFxuICAgICAgICBzdWJJZDogXCJuZGstcmVsYXktbGlzdC1mZXRjaFwiLFxuICAgICAgICBhZGRTaW5jZUZyb21DYWNoZTogdHJ1ZSxcbiAgICAgICAgcmVsYXlTZXRcbiAgICAgIH07XG4gICAgICBpZiAocmVsYXlTZXQpIHN1YnNjcmliZU9wdHMucmVsYXlTZXQgPSByZWxheVNldDtcbiAgICAgIG5kay5zdWJzY3JpYmUoeyBraW5kczogWzMsIDEwMDAyXSwgYXV0aG9yczogcHVia2V5cyB9LCBzdWJzY3JpYmVPcHRzLCB7XG4gICAgICAgIG9uRXZlbnQ6IChldmVudCkgPT4ge1xuICAgICAgICAgIGlmIChldmVudC5raW5kID09PSAxMDAwMiAvKiBSZWxheUxpc3QgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRXZlbnQgPSByZWxheUxpc3RFdmVudHMuZ2V0KGV2ZW50LnB1YmtleSk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdFdmVudCAmJiBleGlzdGluZ0V2ZW50LmNyZWF0ZWRfYXQgPiBldmVudC5jcmVhdGVkX2F0KSByZXR1cm47XG4gICAgICAgICAgICByZWxheUxpc3RFdmVudHMuc2V0KGV2ZW50LnB1YmtleSwgZXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2luZCA9PT0gMyAvKiBDb250YWN0cyAqLykge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdFdmVudCA9IGNvbnRhY3RMaXN0RXZlbnRzLmdldChldmVudC5wdWJrZXkpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRXZlbnQgJiYgZXhpc3RpbmdFdmVudC5jcmVhdGVkX2F0ID4gZXZlbnQuY3JlYXRlZF9hdCkgcmV0dXJuO1xuICAgICAgICAgICAgY29udGFjdExpc3RFdmVudHMuc2V0KGV2ZW50LnB1YmtleSwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Fb3NlOiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiByZWxheUxpc3RFdmVudHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHJlbGF5TGlzdHMuc2V0KGV2ZW50LnB1YmtleSwgTkRLUmVsYXlMaXN0LmZyb20oZXZlbnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBwdWJrZXkgb2YgcHVia2V5cykge1xuICAgICAgICAgICAgaWYgKHJlbGF5TGlzdHMuaGFzKHB1YmtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgY29udGFjdExpc3QgPSBjb250YWN0TGlzdEV2ZW50cy5nZXQocHVia2V5KTtcbiAgICAgICAgICAgIGlmICghY29udGFjdExpc3QpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgbGlzdCA9IHJlbGF5TGlzdEZyb21LaW5kMyhuZGssIGNvbnRhY3RMaXN0KTtcbiAgICAgICAgICAgIGlmIChsaXN0KSByZWxheUxpc3RzLnNldChwdWJrZXksIGxpc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlbGF5TGlzdHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZXNvbHZlKHJlbGF5TGlzdHMpO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgfTtcbiAgICBoYW5kbGVTdWJzY3JpcHRpb24oKTtcbiAgfSk7XG59XG5cbi8vIHNyYy9vdXRib3gvdHJhY2tlci50c1xudmFyIE91dGJveEl0ZW0gPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBUeXBlIG9mIGl0ZW1cbiAgICovXG4gIHR5cGU7XG4gIC8qKlxuICAgKiBUaGUgcmVsYXkgVVJMcyB0aGF0IGFyZSBvZiBpbnRlcmVzdCB0byB0aGlzIGl0ZW1cbiAgICovXG4gIHJlbGF5VXJsU2NvcmVzO1xuICByZWFkUmVsYXlzO1xuICB3cml0ZVJlbGF5cztcbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5yZWxheVVybFNjb3JlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5yZWFkUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLndyaXRlUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgfVxufTtcbnZhciBPdXRib3hUcmFja2VyID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXI3IHtcbiAgZGF0YTtcbiAgbmRrO1xuICBkZWJ1ZztcbiAgY29uc3RydWN0b3IobmRrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLmRlYnVnID0gbmRrLmRlYnVnLmV4dGVuZChcIm91dGJveC10cmFja2VyXCIpO1xuICAgIHRoaXMuZGF0YSA9IG5ldyBMUlVDYWNoZTIoe1xuICAgICAgbWF4U2l6ZTogMWU1LFxuICAgICAgZW50cnlFeHBpcmF0aW9uVGltZUluTVM6IDIgKiA2MCAqIDFlM1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbGlzdCBvZiB1c2VycyB0byB0aGUgdHJhY2tlci5cbiAgICogQHBhcmFtIGl0ZW1zXG4gICAqIEBwYXJhbSBza2lwQ2FjaGVcbiAgICovXG4gIGFzeW5jIHRyYWNrVXNlcnMoaXRlbXMsIHNraXBDYWNoZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSA0MDApIHtcbiAgICAgIGNvbnN0IHNsaWNlID0gaXRlbXMuc2xpY2UoaSwgaSArIDQwMCk7XG4gICAgICBjb25zdCBwdWJrZXlzID0gc2xpY2UubWFwKChpdGVtKSA9PiBnZXRLZXlGcm9tSXRlbShpdGVtKSkuZmlsdGVyKChwdWJrZXkpID0+ICF0aGlzLmRhdGEuaGFzKHB1YmtleSkpO1xuICAgICAgaWYgKHB1YmtleXMubGVuZ3RoID09PSAwKSBjb250aW51ZTtcbiAgICAgIGZvciAoY29uc3QgcHVia2V5IG9mIHB1YmtleXMpIHtcbiAgICAgICAgdGhpcy5kYXRhLnNldChwdWJrZXksIG5ldyBPdXRib3hJdGVtKFwidXNlclwiKSk7XG4gICAgICB9XG4gICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIGdldFJlbGF5TGlzdEZvclVzZXJzKHB1YmtleXMsIHRoaXMubmRrLCBza2lwQ2FjaGUpLnRoZW4oKHJlbGF5TGlzdHMpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3B1YmtleSwgcmVsYXlMaXN0XSBvZiByZWxheUxpc3RzKSB7XG4gICAgICAgICAgICAgIGxldCBvdXRib3hJdGVtID0gdGhpcy5kYXRhLmdldChwdWJrZXkpO1xuICAgICAgICAgICAgICBvdXRib3hJdGVtID8/PSBuZXcgT3V0Ym94SXRlbShcInVzZXJcIik7XG4gICAgICAgICAgICAgIGlmIChyZWxheUxpc3QpIHtcbiAgICAgICAgICAgICAgICBvdXRib3hJdGVtLnJlYWRSZWxheXMgPSBuZXcgU2V0KG5vcm1hbGl6ZShyZWxheUxpc3QucmVhZFJlbGF5VXJscykpO1xuICAgICAgICAgICAgICAgIG91dGJveEl0ZW0ud3JpdGVSZWxheXMgPSBuZXcgU2V0KG5vcm1hbGl6ZShyZWxheUxpc3Qud3JpdGVSZWxheVVybHMpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIG91dGJveEl0ZW0ucmVhZFJlbGF5cykge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmRrLnBvb2wuYmxhY2tsaXN0UmVsYXlVcmxzLmhhcyhyZWxheVVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0Ym94SXRlbS5yZWFkUmVsYXlzLmRlbGV0ZShyZWxheVVybCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2Ygb3V0Ym94SXRlbS53cml0ZVJlbGF5cykge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmRrLnBvb2wuYmxhY2tsaXN0UmVsYXlVcmxzLmhhcyhyZWxheVVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0Ym94SXRlbS53cml0ZVJlbGF5cy5kZWxldGUocmVsYXlVcmwpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuc2V0KHB1YmtleSwgb3V0Ym94SXRlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5maW5hbGx5KHJlc29sdmUpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gc2NvcmVcbiAgICovXG4gIHRyYWNrKGl0ZW0sIHR5cGUsIF9za2lwQ2FjaGUgPSB0cnVlKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5RnJvbUl0ZW0oaXRlbSk7XG4gICAgdHlwZSA/Pz0gZ2V0VHlwZUZyb21JdGVtKGl0ZW0pO1xuICAgIGxldCBvdXRib3hJdGVtID0gdGhpcy5kYXRhLmdldChrZXkpO1xuICAgIGlmICghb3V0Ym94SXRlbSkge1xuICAgICAgb3V0Ym94SXRlbSA9IG5ldyBPdXRib3hJdGVtKHR5cGUpO1xuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtVc2VyKSB7XG4gICAgICAgIHRoaXMudHJhY2tVc2VycyhbaXRlbV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0Ym94SXRlbTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldEtleUZyb21JdGVtKGl0ZW0pIHtcbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtVc2VyKSB7XG4gICAgcmV0dXJuIGl0ZW0ucHVia2V5O1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuZnVuY3Rpb24gZ2V0VHlwZUZyb21JdGVtKGl0ZW0pIHtcbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtVc2VyKSB7XG4gICAgcmV0dXJuIFwidXNlclwiO1xuICB9XG4gIHJldHVybiBcImtpbmRcIjtcbn1cblxuLy8gc3JjL3JlbGF5L3NldHMvdXRpbHMudHNcbmZ1bmN0aW9uIGNvcnJlY3RSZWxheVNldChyZWxheVNldCwgcG9vbCkge1xuICBjb25zdCBjb25uZWN0ZWRSZWxheXMgPSBwb29sLmNvbm5lY3RlZFJlbGF5cygpO1xuICBjb25zdCBpbmNsdWRlc0Nvbm5lY3RlZFJlbGF5ID0gQXJyYXkuZnJvbShyZWxheVNldC5yZWxheXMpLnNvbWUoKHJlbGF5KSA9PiB7XG4gICAgcmV0dXJuIGNvbm5lY3RlZFJlbGF5cy5tYXAoKHIpID0+IHIudXJsKS5pbmNsdWRlcyhyZWxheS51cmwpO1xuICB9KTtcbiAgaWYgKCFpbmNsdWRlc0Nvbm5lY3RlZFJlbGF5KSB7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiBjb25uZWN0ZWRSZWxheXMpIHtcbiAgICAgIHJlbGF5U2V0LmFkZFJlbGF5KHJlbGF5KTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbm5lY3RlZFJlbGF5cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHBvb2wucmVsYXlzLnZhbHVlcygpKSB7XG4gICAgICByZWxheVNldC5hZGRSZWxheShyZWxheSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWxheVNldDtcbn1cblxuLy8gc3JjL3N1YnNjcmlwdGlvbi9tYW5hZ2VyLnRzXG5pbXBvcnQgeyBtYXRjaEZpbHRlcnMgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbnZhciBOREtTdWJzY3JpcHRpb25NYW5hZ2VyID0gY2xhc3Mge1xuICBzdWJzY3JpcHRpb25zO1xuICBzZWVuRXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBhZGQoc3ViKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChzdWIuaW50ZXJuYWxJZCwgc3ViKTtcbiAgICBpZiAoc3ViLm9uU3RvcHBlZCkge1xuICAgIH1cbiAgICBzdWIub25TdG9wcGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmRlbGV0ZShzdWIuaW50ZXJuYWxJZCk7XG4gICAgfTtcbiAgICBzdWIub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1Yi5pbnRlcm5hbElkKTtcbiAgICB9KTtcbiAgfVxuICBzZWVuRXZlbnQoZXZlbnRJZCwgcmVsYXkpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5zZWVuRXZlbnRzLmdldChldmVudElkKSB8fCBbXTtcbiAgICBjdXJyZW50LnB1c2gocmVsYXkpO1xuICAgIHRoaXMuc2VlbkV2ZW50cy5zZXQoZXZlbnRJZCwgY3VycmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZW5ldmVyIGFuIGV2ZW50IGNvbWVzIGluLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICogVGhpcyBmdW5jdGlvbiBtYXRjaGVzIHRoZSByZWNlaXZlZCBldmVudCBhZ2FpbnN0IGFsbCB0aGVcbiAgICoga25vd24gKGkuZS4gYWN0aXZlKSBOREtTdWJzY3JpcHRpb25zLCBhbmQgaWYgaXQgbWF0Y2hlcyxcbiAgICogaXQgc2VuZHMgdGhlIGV2ZW50IHRvIHRoZSBzdWJzY3JpcHRpb24uXG4gICAqXG4gICAqIFRoaXMgaXMgdGhlIHNpbmdsZSBwbGFjZSBpbiB0aGUgY29kZWJhc2UgdGhhdCBtYXRjaGVzXG4gICAqIGluY29taW5nIGV2ZW50cyB3aXRoIHBhcnRpZXMgaW50ZXJlc3RlZCBpbiB0aGUgZXZlbnQuXG4gICAqXG4gICAqIFRoaXMgaXMgYWxzbyB3aGF0IGFsbG93cyBmb3IgcmVhY3Rpdml0eSBpbiBOREsgYXBwcywgc3VjaCB0aGF0XG4gICAqIHdoZW5ldmVyIGFuIGFjdGl2ZSBzdWJzY3JpcHRpb24gcmVjZWl2ZXMgYW4gZXZlbnQgdGhhdCBzb21lXG4gICAqIG90aGVyIGFjdGl2ZSBzdWJzY3JpcHRpb24gd291bGQgd2FudCB0byByZWNlaXZlLCBib3RoIHJlY2VpdmUgaXQuXG4gICAqXG4gICAqIFRPRE8gVGhpcyBhbHNvIGFsbG93cyBmb3Igc3Vic2NyaXB0aW9ucyB0aGF0IG92ZXJsYXAgaW4gbWVhbmluZ1xuICAgKiB0byBiZSBjb2xsYXBzZWQgaW50byBvbmUuXG4gICAqXG4gICAqIEkuZS4gaWYgYSBzdWJzY3JpcHRpb24gd2l0aCBmaWx0ZXI6IGtpbmRzOiBbMV0sIGF1dGhvcnM6IFthbGljZV1cbiAgICogaXMgY3JlYXRlZCBhbmQgRU9TRXMsIGFuZCB0aGVuIGEgc3Vic2VxdWVudCBzdWJzY3JpcHRpb24gd2l0aFxuICAgKiBraW5kczogWzFdLCBhdXRob3JzOiBbYWxpY2VdIGlzIGNyZWF0ZWQsIG9uY2UgdGhlIHNlY29uZCBzdWJzY3JpcHRpb25cbiAgICogRU9TRXMgd2UgY2FuIHNhZmVseSBjbG9zZSBpdCwgaW5jcmVtZW50IGl0cyByZWZDb3VudCBhbmQgY2xvc2UgaXQsXG4gICAqIGFuZCB3aGVuIHRoZSBmaXJzdCBzdWJzY3JpcHRpb24gcmVjZWl2ZXMgYSBuZXcgZXZlbnQgZnJvbSBBbGljZSB0aGlzXG4gICAqIGNvZGUgd2lsbCBtYWtlIHRoZSBzZWNvbmQgc3Vic2NyaXB0aW9uIHJlY2VpdmUgdGhlIGV2ZW50IGV2ZW4gdGhvdWdoXG4gICAqIGl0IGhhcyBubyBhY3RpdmUgc3Vic2NyaXB0aW9uIG9uIGEgcmVsYXkuXG4gICAqIEBwYXJhbSBldmVudCBSYXcgZXZlbnQgcmVjZWl2ZWQgZnJvbSBhIHJlbGF5XG4gICAqIEBwYXJhbSByZWxheSBSZWxheSB0aGF0IHNlbnQgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBvcHRpbWlzdGljUHVibGlzaCBXaGV0aGVyIHRoZSBldmVudCBpcyBjb21pbmcgZnJvbSBhbiBvcHRpbWlzdGljIHB1Ymxpc2hcbiAgICovXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnQsIHJlbGF5LCBvcHRpbWlzdGljUHVibGlzaCA9IGZhbHNlKSB7XG4gICAgaWYgKHJlbGF5KSB0aGlzLnNlZW5FdmVudChldmVudC5pZCwgcmVsYXkpO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMudmFsdWVzKCk7XG4gICAgY29uc3QgbWF0Y2hpbmdTdWJzID0gW107XG4gICAgZm9yIChjb25zdCBzdWIgb2Ygc3Vic2NyaXB0aW9ucykge1xuICAgICAgaWYgKG1hdGNoRmlsdGVycyhzdWIuZmlsdGVycywgZXZlbnQpKSB7XG4gICAgICAgIG1hdGNoaW5nU3Vicy5wdXNoKHN1Yik7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3ViIG9mIG1hdGNoaW5nU3Vicykge1xuICAgICAgc3ViLmV2ZW50UmVjZWl2ZWQoZXZlbnQsIHJlbGF5LCBmYWxzZSwgb3B0aW1pc3RpY1B1Ymxpc2gpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL25kay9hY3RpdmUtdXNlci50c1xuaW1wb3J0IGNyZWF0ZURlYnVnMyBmcm9tIFwiZGVidWdcIjtcbnZhciBkZWJ1ZzYgPSBjcmVhdGVEZWJ1ZzMoXCJuZGs6YWN0aXZlLXVzZXJcIik7XG5hc3luYyBmdW5jdGlvbiBnZXRVc2VyUmVsYXlMaXN0KHVzZXIpIHtcbiAgaWYgKCF0aGlzLmF1dG9Db25uZWN0VXNlclJlbGF5cykgcmV0dXJuO1xuICBjb25zdCB1c2VyUmVsYXlzID0gYXdhaXQgZ2V0UmVsYXlMaXN0Rm9yVXNlcih1c2VyLnB1YmtleSwgdGhpcyk7XG4gIGlmICghdXNlclJlbGF5cykgcmV0dXJuO1xuICBmb3IgKGNvbnN0IHVybCBvZiB1c2VyUmVsYXlzLnJlbGF5cykge1xuICAgIGxldCByZWxheSA9IHRoaXMucG9vbC5yZWxheXMuZ2V0KHVybCk7XG4gICAgaWYgKCFyZWxheSkge1xuICAgICAgcmVsYXkgPSBuZXcgTkRLUmVsYXkodXJsLCB0aGlzLnJlbGF5QXV0aERlZmF1bHRQb2xpY3ksIHRoaXMpO1xuICAgICAgdGhpcy5wb29sLmFkZFJlbGF5KHJlbGF5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVzZXJSZWxheXM7XG59XG5hc3luYyBmdW5jdGlvbiBzZXRBY3RpdmVVc2VyKHVzZXIpIHtcbiAgY29uc3QgcG9vbCA9IHRoaXMub3V0Ym94UG9vbCB8fCB0aGlzLnBvb2w7XG4gIGlmIChwb29sLmNvbm5lY3RlZFJlbGF5cy5sZW5ndGggPiAwKSB7XG4gICAgc2V0QWN0aXZlVXNlckNvbm5lY3RlZC5jYWxsKHRoaXMsIHVzZXIpO1xuICB9IGVsc2Uge1xuICAgIHBvb2wub25jZShcImNvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgc2V0QWN0aXZlVXNlckNvbm5lY3RlZC5jYWxsKHRoaXMsIHVzZXIpO1xuICAgIH0pO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBzZXRBY3RpdmVVc2VyQ29ubmVjdGVkKHVzZXIpIHtcbiAgY29uc3QgdXNlclJlbGF5cyA9IGF3YWl0IGdldFVzZXJSZWxheUxpc3QuY2FsbCh0aGlzLCB1c2VyKTtcbiAgY29uc3QgZmlsdGVycyA9IFtcbiAgICB7XG4gICAgICBraW5kczogWzEwMDA2IC8qIEJsb2NrUmVsYXlMaXN0ICovXSxcbiAgICAgIGF1dGhvcnM6IFt1c2VyLnB1YmtleV1cbiAgICB9XG4gIF07XG4gIGlmICh0aGlzLmF1dG9GZXRjaFVzZXJNdXRlbGlzdCkge1xuICAgIGZpbHRlcnNbMF0ua2luZHM/LnB1c2goMWU0IC8qIE11dGVMaXN0ICovKTtcbiAgfVxuICBjb25zdCBldmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCByZWxheVNldCA9IHVzZXJSZWxheXMgPyB1c2VyUmVsYXlzLnJlbGF5U2V0IDogdm9pZCAwO1xuICB0aGlzLnN1YnNjcmliZShcbiAgICBmaWx0ZXJzLFxuICAgIHsgc3ViSWQ6IFwiYWN0aXZlLXVzZXItc2V0dGluZ3NcIiwgY2xvc2VPbkVvc2U6IHRydWUsIHJlbGF5U2V0IH0sXG4gICAge1xuICAgICAgb25FdmVudDogKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZFdmVudCA9IGV2ZW50cy5nZXQoZXZlbnQua2luZCk7XG4gICAgICAgIGlmIChwcmV2RXZlbnQgJiYgcHJldkV2ZW50LmNyZWF0ZWRfYXQgPj0gZXZlbnQuY3JlYXRlZF9hdCkgcmV0dXJuO1xuICAgICAgICBldmVudHMuc2V0KGV2ZW50LmtpbmQsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBvbkVvc2U6ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMudmFsdWVzKCkpIHtcbiAgICAgICAgICBwcm9jZXNzRXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzRXZlbnQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmtpbmQgPT09IDEwMDA2IC8qIEJsb2NrUmVsYXlMaXN0ICovKSB7XG4gICAgcHJvY2Vzc0Jsb2NrUmVsYXlMaXN0LmNhbGwodGhpcywgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGV2ZW50LmtpbmQgPT09IDFlNCAvKiBNdXRlTGlzdCAqLykge1xuICAgIHByb2Nlc3NNdXRlTGlzdC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrUmVsYXlMaXN0KGV2ZW50KSB7XG4gIGNvbnN0IGxpc3QgPSBsaXN0c19kZWZhdWx0LmZyb20oZXZlbnQpO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgbGlzdC5pdGVtcykge1xuICAgIHRoaXMucG9vbC5ibGFja2xpc3RSZWxheVVybHMuYWRkKGl0ZW1bMF0pO1xuICB9XG4gIGRlYnVnNihcIkFkZGVkICVkIHJlbGF5cyB0byByZWxheSBibGFja2xpc3RcIiwgbGlzdC5pdGVtcy5sZW5ndGgpO1xufVxuZnVuY3Rpb24gcHJvY2Vzc011dGVMaXN0KG11dGVMaXN0KSB7XG4gIGNvbnN0IGxpc3QgPSBsaXN0c19kZWZhdWx0LmZyb20obXV0ZUxpc3QpO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgbGlzdC5pdGVtcykge1xuICAgIHRoaXMubXV0ZWRJZHMuc2V0KGl0ZW1bMV0sIGl0ZW1bMF0pO1xuICB9XG4gIGRlYnVnNihcIkFkZGVkICVkIHVzZXJzIHRvIG11dGUgbGlzdFwiLCBsaXN0Lml0ZW1zLmxlbmd0aCk7XG59XG5cbi8vIHNyYy9uZGsvZW50aXR5LnRzXG5pbXBvcnQgeyBuaXAxOSBhcyBuaXAxOTcgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbmZ1bmN0aW9uIGdldEVudGl0eShlbnRpdHkpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkZWNvZGVkID0gbmlwMTk3LmRlY29kZShlbnRpdHkpO1xuICAgIGlmIChkZWNvZGVkLnR5cGUgPT09IFwibnB1YlwiKSByZXR1cm4gbnB1Yih0aGlzLCBkZWNvZGVkLmRhdGEpO1xuICAgIGlmIChkZWNvZGVkLnR5cGUgPT09IFwibnByb2ZpbGVcIikgcmV0dXJuIG5wcm9maWxlKHRoaXMsIGRlY29kZWQuZGF0YSk7XG4gICAgcmV0dXJuIGRlY29kZWQ7XG4gIH0gY2F0Y2ggKF9lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIG5wdWIobmRrLCBwdWJrZXkpIHtcbiAgcmV0dXJuIG5kay5nZXRVc2VyKHsgcHVia2V5IH0pO1xufVxuZnVuY3Rpb24gbnByb2ZpbGUobmRrLCBwcm9maWxlKSB7XG4gIGNvbnN0IHVzZXIgPSBuZGsuZ2V0VXNlcih7IHB1YmtleTogcHJvZmlsZS5wdWJrZXkgfSk7XG4gIGlmIChwcm9maWxlLnJlbGF5cykgdXNlci5yZWxheVVybHMgPSBwcm9maWxlLnJlbGF5cztcbiAgcmV0dXJuIHVzZXI7XG59XG5cbi8vIHNyYy9uZGsvZmV0Y2gtZXZlbnQtZnJvbS10YWcudHNcbmZ1bmN0aW9uIGlzVmFsaWRIaW50KGhpbnQpIHtcbiAgaWYgKCFoaW50IHx8IGhpbnQgPT09IFwiXCIpIHJldHVybiBmYWxzZTtcbiAgdHJ5IHtcbiAgICBuZXcgVVJMKGhpbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChfZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hFdmVudEZyb21UYWcodGFnLCBvcmlnaW5hbEV2ZW50LCBzdWJPcHRzLCBmYWxsYmFjayA9IHtcbiAgdHlwZTogXCJ0aW1lb3V0XCJcbn0pIHtcbiAgY29uc3QgZDQgPSB0aGlzLmRlYnVnLmV4dGVuZChcImZldGNoLWV2ZW50LWZyb20tdGFnXCIpO1xuICBjb25zdCBbXywgaWQsIGhpbnRdID0gdGFnO1xuICBzdWJPcHRzID0ge307XG4gIGQ0KFwiZmV0Y2hpbmcgZXZlbnQgZnJvbSB0YWdcIiwgdGFnLCBzdWJPcHRzLCBmYWxsYmFjayk7XG4gIGNvbnN0IGF1dGhvclJlbGF5cyA9IGdldFJlbGF5c0ZvclN5bmModGhpcywgb3JpZ2luYWxFdmVudC5wdWJrZXkpO1xuICBpZiAoYXV0aG9yUmVsYXlzICYmIGF1dGhvclJlbGF5cy5zaXplID4gMCkge1xuICAgIGQ0KFwiZmV0Y2hpbmcgZXZlbnQgZnJvbSBhdXRob3IgcmVsYXlzICVvXCIsIEFycmF5LmZyb20oYXV0aG9yUmVsYXlzKSk7XG4gICAgY29uc3QgcmVsYXlTZXQyID0gTkRLUmVsYXlTZXQuZnJvbVJlbGF5VXJscyhBcnJheS5mcm9tKGF1dGhvclJlbGF5cyksIHRoaXMpO1xuICAgIGNvbnN0IGV2ZW50MiA9IGF3YWl0IHRoaXMuZmV0Y2hFdmVudChpZCwgc3ViT3B0cywgcmVsYXlTZXQyKTtcbiAgICBpZiAoZXZlbnQyKSByZXR1cm4gZXZlbnQyO1xuICB9IGVsc2Uge1xuICAgIGQ0KFwibm8gYXV0aG9yIHJlbGF5cyBmb3VuZCBmb3IgJXNcIiwgb3JpZ2luYWxFdmVudC5wdWJrZXksIG9yaWdpbmFsRXZlbnQpO1xuICB9XG4gIGNvbnN0IHJlbGF5U2V0ID0gY2FsY3VsYXRlUmVsYXlTZXRzRnJvbUZpbHRlcnModGhpcywgW3sgaWRzOiBbaWRdIH1dLCB0aGlzLnBvb2wpO1xuICBkNChcImZldGNoaW5nIGV2ZW50IHdpdGhvdXQgcmVsYXkgaGludFwiLCByZWxheVNldCk7XG4gIGNvbnN0IGV2ZW50ID0gYXdhaXQgdGhpcy5mZXRjaEV2ZW50KGlkLCBzdWJPcHRzKTtcbiAgaWYgKGV2ZW50KSByZXR1cm4gZXZlbnQ7XG4gIGlmIChoaW50ICYmIGhpbnQgIT09IFwiXCIpIHtcbiAgICBjb25zdCBldmVudDIgPSBhd2FpdCB0aGlzLmZldGNoRXZlbnQoaWQsIHN1Yk9wdHMsIHRoaXMucG9vbC5nZXRSZWxheShoaW50LCB0cnVlLCB0cnVlLCBbeyBpZHM6IFtpZF0gfV0pKTtcbiAgICBpZiAoZXZlbnQyKSByZXR1cm4gZXZlbnQyO1xuICB9XG4gIGxldCByZXN1bHQgPSB2b2lkIDA7XG4gIGNvbnN0IHJlbGF5ID0gaXNWYWxpZEhpbnQoaGludCkgPyB0aGlzLnBvb2wuZ2V0UmVsYXkoaGludCwgZmFsc2UsIHRydWUsIFt7IGlkczogW2lkXSB9XSkgOiB2b2lkIDA7XG4gIGNvbnN0IGZldGNoTWF5YmVXaXRoUmVsYXlIaW50ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICB0aGlzLmZldGNoRXZlbnQoaWQsIHN1Yk9wdHMsIHJlbGF5KS50aGVuKHJlc29sdmUpO1xuICB9KTtcbiAgaWYgKCFpc1ZhbGlkSGludChoaW50KSB8fCBmYWxsYmFjay50eXBlID09PSBcIm5vbmVcIikge1xuICAgIHJldHVybiBmZXRjaE1heWJlV2l0aFJlbGF5SGludDtcbiAgfVxuICBjb25zdCBmYWxsYmFja0ZldGNoUHJvbWlzZSA9IG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgZmFsbGJhY2tSZWxheVNldCA9IGZhbGxiYWNrLnJlbGF5U2V0O1xuICAgIGNvbnN0IHRpbWVvdXQgPSBmYWxsYmFjay50aW1lb3V0ID8/IDE1MDA7XG4gICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZTIpID0+IHNldFRpbWVvdXQocmVzb2x2ZTIsIHRpbWVvdXQpKTtcbiAgICBpZiAoZmFsbGJhY2sudHlwZSA9PT0gXCJ0aW1lb3V0XCIpIGF3YWl0IHRpbWVvdXRQcm9taXNlO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZDQoXCJmYWxsYmFjayBmZXRjaCB0cmlnZ2VyZWRcIik7XG4gICAgICBjb25zdCBmYWxsYmFja0V2ZW50ID0gYXdhaXQgdGhpcy5mZXRjaEV2ZW50KGlkLCBzdWJPcHRzLCBmYWxsYmFja1JlbGF5U2V0KTtcbiAgICAgIHJlc29sdmUoZmFsbGJhY2tFdmVudCk7XG4gICAgfVxuICB9KTtcbiAgc3dpdGNoIChmYWxsYmFjay50eXBlKSB7XG4gICAgY2FzZSBcInRpbWVvdXRcIjpcbiAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2ZldGNoTWF5YmVXaXRoUmVsYXlIaW50LCBmYWxsYmFja0ZldGNoUHJvbWlzZV0pO1xuICAgIGNhc2UgXCJlb3NlXCI6XG4gICAgICByZXN1bHQgPSBhd2FpdCBmZXRjaE1heWJlV2l0aFJlbGF5SGludDtcbiAgICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICByZXR1cm4gZmFsbGJhY2tGZXRjaFByb21pc2U7XG4gIH1cbn1cblxuLy8gc3JjL25kay9xdWV1ZS9pbmRleC50c1xudmFyIFF1ZXVlID0gY2xhc3Mge1xuICBxdWV1ZSA9IFtdO1xuICBtYXhDb25jdXJyZW5jeTtcbiAgcHJvY2Vzc2luZyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHByb21pc2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IoX25hbWUsIG1heENvbmN1cnJlbmN5KSB7XG4gICAgdGhpcy5tYXhDb25jdXJyZW5jeSA9IG1heENvbmN1cnJlbmN5O1xuICB9XG4gIGFkZChpdGVtKSB7XG4gICAgaWYgKHRoaXMucHJvbWlzZXMuaGFzKGl0ZW0uaWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9taXNlcy5nZXQoaXRlbS5pZCk7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goe1xuICAgICAgICAuLi5pdGVtLFxuICAgICAgICBmdW5jOiAoKSA9PiBpdGVtLmZ1bmMoKS50aGVuKFxuICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9jZXNzKCk7XG4gICAgfSk7XG4gICAgdGhpcy5wcm9taXNlcy5zZXQoaXRlbS5pZCwgcHJvbWlzZSk7XG4gICAgcHJvbWlzZS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMucHJvbWlzZXMuZGVsZXRlKGl0ZW0uaWQpO1xuICAgICAgdGhpcy5wcm9jZXNzaW5nLmRlbGV0ZShpdGVtLmlkKTtcbiAgICAgIHRoaXMucHJvY2VzcygpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIHByb2Nlc3MoKSB7XG4gICAgaWYgKHRoaXMucHJvY2Vzc2luZy5zaXplID49IHRoaXMubWF4Q29uY3VycmVuY3kgfHwgdGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICBpZiAoIWl0ZW0gfHwgdGhpcy5wcm9jZXNzaW5nLmhhcyhpdGVtLmlkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NpbmcuYWRkKGl0ZW0uaWQpO1xuICAgIGl0ZW0uZnVuYygpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgfVxuICBjbGVhclByb2Nlc3NpbmcoKSB7XG4gICAgdGhpcy5wcm9jZXNzaW5nLmNsZWFyKCk7XG4gIH1cbiAgY2xlYXJBbGwoKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMuY2xlYXJQcm9jZXNzaW5nKCk7XG4gIH1cbiAgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlLmxlbmd0aDtcbiAgfVxufTtcblxuLy8gc3JjL25kay9pbmRleC50c1xudmFyIERFRkFVTFRfT1VUQk9YX1JFTEFZUyA9IFtcIndzczovL3B1cnBsZXBhZy5lcy9cIiwgXCJ3c3M6Ly9ub3MubG9sL1wiXTtcbnZhciBERUZBVUxUX0JMQUNLTElTVEVEX1JFTEFZUyA9IFtcbiAgXCJ3c3M6Ly9icmIuaW8vXCIsXG4gIC8vIEJSQlxuICBcIndzczovL25vc3RyLm11dGlueXdhbGxldC5jb20vXCJcbiAgLy8gRG9uJ3QgdHJ5IHRvIHJlYWQgZnJvbSB0aGlzIHJlbGF5IHNpbmNlIGl0J3MgYSB3cml0ZS1vbmx5IHJlbGF5XG4gIC8vIFwid3NzOi8vcHVycGxlcGFnLmVzL1wiLCAvLyBUaGlzIGlzIGEgaGFjaywgc2luY2UgdGhpcyBpcyBhIG1vc3RseSByZWFkLW9ubHkgcmVsYXksIGJ1dCBub3QgZnVsbHkuIE9uY2Ugd2UgaGF2ZSByZWxheSByb3V0aW5nIHRoaXMgY2FuIGJlIHJlbW92ZWQgc28gaXQgb25seSByZWNlaXZlcyB0aGUgc3VwcG9ydGVkIGtpbmRzXG5dO1xudmFyIE5ESyA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyOCB7XG4gIF9leHBsaWNpdFJlbGF5VXJscztcbiAgYmxhY2tsaXN0UmVsYXlVcmxzO1xuICBwb29sO1xuICBvdXRib3hQb29sO1xuICBfc2lnbmVyO1xuICBfYWN0aXZlVXNlcjtcbiAgY2FjaGVBZGFwdGVyO1xuICBkZWJ1ZztcbiAgZGV2V3JpdGVSZWxheVNldDtcbiAgb3V0Ym94VHJhY2tlcjtcbiAgbXV0ZWRJZHM7XG4gIGNsaWVudE5hbWU7XG4gIGNsaWVudE5pcDg5O1xuICBxdWV1ZXNaYXBDb25maWc7XG4gIHF1ZXVlc05pcDA1O1xuICBhc3luY1NpZ1ZlcmlmaWNhdGlvbiA9IGZhbHNlO1xuICBpbml0aWFsVmFsaWRhdGlvblJhdGlvID0gMTtcbiAgbG93ZXN0VmFsaWRhdGlvblJhdGlvID0gMTtcbiAgdmFsaWRhdGlvblJhdGlvRm47XG4gIHN1Yk1hbmFnZXI7XG4gIHB1Ymxpc2hpbmdGYWlsdXJlSGFuZGxlZCA9IGZhbHNlO1xuICBwb29scyA9IFtdO1xuICAvKipcbiAgICogRGVmYXVsdCByZWxheS1hdXRoIHBvbGljeSB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIGEgcmVsYXkgcmVxdWVzdHMgYXV0aGVudGljYXRpb24sXG4gICAqIGlmIG5vIG90aGVyIHBvbGljeSBpcyBzcGVjaWZpZWQgZm9yIHRoYXQgcmVsYXkuXG4gICAqXG4gICAqIEBleGFtcGxlIERpc2Nvbm5lY3QgZnJvbSByZWxheXMgdGhhdCByZXF1ZXN0IGF1dGhlbnRpY2F0aW9uOlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIG5kay5yZWxheUF1dGhEZWZhdWx0UG9saWN5ID0gTkRLQXV0aFBvbGljaWVzLmRpc2Nvbm5lY3QobmRrLnBvb2wpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGUgU2lnbiBpbiB0byByZWxheXMgdGhhdCByZXF1ZXN0IGF1dGhlbnRpY2F0aW9uOlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIG5kay5yZWxheUF1dGhEZWZhdWx0UG9saWN5ID0gTkRLQXV0aFBvbGljaWVzLnNpZ25Jbih7bmRrfSlcbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlIFNpZ24gaW4gdG8gcmVsYXlzIHRoYXQgcmVxdWVzdCBhdXRoZW50aWNhdGlvbiwgYXNraW5nIHRoZSB1c2VyIGZvciBjb25maXJtYXRpb246XG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogbmRrLnJlbGF5QXV0aERlZmF1bHRQb2xpY3kgPSAocmVsYXk6IE5ES1JlbGF5KSA9PiB7XG4gICAqICAgICBjb25zdCBzaWduSW4gPSBOREtBdXRoUG9saWNpZXMuc2lnbkluKHtuZGt9KTtcbiAgICogICAgIGlmIChjb25maXJtKGBSZWxheSAke3JlbGF5LnVybH0gaXMgcmVxdWVzdGluZyBhdXRoZW50aWNhdGlvbiwgZG8geW91IHdhbnQgdG8gc2lnbiBpbj9gKSkge1xuICAgKiAgICAgICAgc2lnbkluKHJlbGF5KTtcbiAgICogICAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIHJlbGF5QXV0aERlZmF1bHRQb2xpY3k7XG4gIC8qKlxuICAgKiBGZXRjaCBmdW5jdGlvbiB0byB1c2UgZm9yIEhUVFAgcmVxdWVzdHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogaW1wb3J0IGZldGNoIGZyb20gXCJub2RlLWZldGNoXCI7XG4gICAqXG4gICAqIG5kay5odHRwRmV0Y2ggPSBmZXRjaDtcbiAgICogYGBgXG4gICAqL1xuICBodHRwRmV0Y2g7XG4gIC8qKlxuICAgKiBQcm92aWRlIGEgY2FsbGVyIGZ1bmN0aW9uIHRvIHJlY2VpdmUgYWxsIG5ldHdvcmtpbmcgdHJhZmZpYyBmcm9tIHJlbGF5c1xuICAgKi9cbiAgbmV0RGVidWc7XG4gIGF1dG9Db25uZWN0VXNlclJlbGF5cyA9IHRydWU7XG4gIGF1dG9GZXRjaFVzZXJNdXRlbGlzdCA9IHRydWU7XG4gIHdhbGxldENvbmZpZztcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRlYnVnID0gb3B0cy5kZWJ1ZyB8fCBkZWJ1ZzcoXCJuZGtcIik7XG4gICAgdGhpcy5uZXREZWJ1ZyA9IG9wdHMubmV0RGVidWc7XG4gICAgdGhpcy5fZXhwbGljaXRSZWxheVVybHMgPSBvcHRzLmV4cGxpY2l0UmVsYXlVcmxzIHx8IFtdO1xuICAgIHRoaXMuYmxhY2tsaXN0UmVsYXlVcmxzID0gb3B0cy5ibGFja2xpc3RSZWxheVVybHMgfHwgREVGQVVMVF9CTEFDS0xJU1RFRF9SRUxBWVM7XG4gICAgdGhpcy5zdWJNYW5hZ2VyID0gbmV3IE5ES1N1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgICB0aGlzLnBvb2wgPSBuZXcgTkRLUG9vbChvcHRzLmV4cGxpY2l0UmVsYXlVcmxzIHx8IFtdLCBbXSwgdGhpcyk7XG4gICAgdGhpcy5wb29sLm5hbWUgPSBcIk1haW5cIjtcbiAgICB0aGlzLnBvb2wub24oXCJyZWxheTphdXRoXCIsIGFzeW5jIChyZWxheSwgY2hhbGxlbmdlKSA9PiB7XG4gICAgICBpZiAodGhpcy5yZWxheUF1dGhEZWZhdWx0UG9saWN5KSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVsYXlBdXRoRGVmYXVsdFBvbGljeShyZWxheSwgY2hhbGxlbmdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmF1dG9Db25uZWN0VXNlclJlbGF5cyA9IG9wdHMuYXV0b0Nvbm5lY3RVc2VyUmVsYXlzID8/IHRydWU7XG4gICAgdGhpcy5hdXRvRmV0Y2hVc2VyTXV0ZWxpc3QgPSBvcHRzLmF1dG9GZXRjaFVzZXJNdXRlbGlzdCA/PyB0cnVlO1xuICAgIHRoaXMuY2xpZW50TmFtZSA9IG9wdHMuY2xpZW50TmFtZTtcbiAgICB0aGlzLmNsaWVudE5pcDg5ID0gb3B0cy5jbGllbnROaXA4OTtcbiAgICB0aGlzLnJlbGF5QXV0aERlZmF1bHRQb2xpY3kgPSBvcHRzLnJlbGF5QXV0aERlZmF1bHRQb2xpY3k7XG4gICAgaWYgKG9wdHMuZW5hYmxlT3V0Ym94TW9kZWwpIHtcbiAgICAgIHRoaXMub3V0Ym94UG9vbCA9IG5ldyBOREtQb29sKG9wdHMub3V0Ym94UmVsYXlVcmxzIHx8IERFRkFVTFRfT1VUQk9YX1JFTEFZUywgW10sIHRoaXMsIHtcbiAgICAgICAgZGVidWc6IHRoaXMuZGVidWcuZXh0ZW5kKFwib3V0Ym94LXBvb2xcIiksXG4gICAgICAgIG5hbWU6IFwiT3V0Ym94IFBvb2xcIlxuICAgICAgfSk7XG4gICAgICB0aGlzLm91dGJveFRyYWNrZXIgPSBuZXcgT3V0Ym94VHJhY2tlcih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5zaWduZXIgPSBvcHRzLnNpZ25lcjtcbiAgICB0aGlzLmNhY2hlQWRhcHRlciA9IG9wdHMuY2FjaGVBZGFwdGVyO1xuICAgIHRoaXMubXV0ZWRJZHMgPSBvcHRzLm11dGVkSWRzIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKG9wdHMuZGV2V3JpdGVSZWxheVVybHMpIHtcbiAgICAgIHRoaXMuZGV2V3JpdGVSZWxheVNldCA9IE5ES1JlbGF5U2V0LmZyb21SZWxheVVybHMob3B0cy5kZXZXcml0ZVJlbGF5VXJscywgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMucXVldWVzWmFwQ29uZmlnID0gbmV3IFF1ZXVlKFwiemFwc1wiLCAzKTtcbiAgICB0aGlzLnF1ZXVlc05pcDA1ID0gbmV3IFF1ZXVlKFwibmlwMDVcIiwgMTApO1xuICAgIHRoaXMuc2lnbmF0dXJlVmVyaWZpY2F0aW9uV29ya2VyID0gb3B0cy5zaWduYXR1cmVWZXJpZmljYXRpb25Xb3JrZXI7XG4gICAgdGhpcy5pbml0aWFsVmFsaWRhdGlvblJhdGlvID0gb3B0cy5pbml0aWFsVmFsaWRhdGlvblJhdGlvIHx8IDE7XG4gICAgdGhpcy5sb3dlc3RWYWxpZGF0aW9uUmF0aW8gPSBvcHRzLmxvd2VzdFZhbGlkYXRpb25SYXRpbyB8fCAxO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmh0dHBGZXRjaCA9IGZldGNoO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICBzZXQgZXhwbGljaXRSZWxheVVybHModXJscykge1xuICAgIHRoaXMuX2V4cGxpY2l0UmVsYXlVcmxzID0gdXJscy5tYXAobm9ybWFsaXplUmVsYXlVcmwpO1xuICAgIHRoaXMucG9vbC5yZWxheVVybHMgPSB1cmxzO1xuICB9XG4gIGdldCBleHBsaWNpdFJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy5fZXhwbGljaXRSZWxheVVybHMgfHwgW107XG4gIH1cbiAgc2V0IHNpZ25hdHVyZVZlcmlmaWNhdGlvbldvcmtlcih3b3JrZXIyKSB7XG4gICAgdGhpcy5hc3luY1NpZ1ZlcmlmaWNhdGlvbiA9ICEhd29ya2VyMjtcbiAgICBpZiAod29ya2VyMikge1xuICAgICAgc2lnbmF0dXJlVmVyaWZpY2F0aW9uSW5pdCh3b3JrZXIyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gZXhwbGljaXQgcmVsYXkgdG8gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSB1cmxcbiAgICogQHBhcmFtIHJlbGF5QXV0aFBvbGljeSBBdXRoZW50aWNhdGlvbiBwb2xpY3kgdG8gdXNlIGlmIGRpZmZlcmVudCBmcm9tIHRoZSBkZWZhdWx0XG4gICAqIEBwYXJhbSBjb25uZWN0IFdoZXRoZXIgdG8gY29ubmVjdCB0byB0aGUgcmVsYXkgYXV0b21hdGljYWxseVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYWRkRXhwbGljaXRSZWxheSh1cmxPclJlbGF5LCByZWxheUF1dGhQb2xpY3ksIGNvbm5lY3QgPSB0cnVlKSB7XG4gICAgbGV0IHJlbGF5O1xuICAgIGlmICh0eXBlb2YgdXJsT3JSZWxheSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVsYXkgPSBuZXcgTkRLUmVsYXkodXJsT3JSZWxheSwgcmVsYXlBdXRoUG9saWN5LCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVsYXkgPSB1cmxPclJlbGF5O1xuICAgIH1cbiAgICB0aGlzLnBvb2wuYWRkUmVsYXkocmVsYXksIGNvbm5lY3QpO1xuICAgIHRoaXMuZXhwbGljaXRSZWxheVVybHM/LnB1c2gocmVsYXkudXJsKTtcbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7IHJlbGF5Q291bnQ6IHRoaXMucG9vbC5yZWxheXMuc2l6ZSB9LnRvU3RyaW5nKCk7XG4gIH1cbiAgZ2V0IGFjdGl2ZVVzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVVzZXI7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFjdGl2ZSB1c2VyIGZvciB0aGlzIE5ESyBpbnN0YW5jZSwgdHlwaWNhbGx5IHRoaXMgd2lsbCBiZVxuICAgKiBjYWxsZWQgd2hlbiBhc3NpZ25pbmcgYSBzaWduZXIgdG8gdGhlIE5ESyBpbnN0YW5jZS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgY29ubmVjdCB0byB0aGUgdXNlcidzIHJlbGF5cyBpZlxuICAgKiBgYXV0b0Nvbm5lY3RVc2VyUmVsYXlzYCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICpcbiAgICogSXQgd2lsbCBhbHNvIGZldGNoIHRoZSB1c2VyJ3MgbXV0ZWxpc3QgaWYgYGF1dG9GZXRjaFVzZXJNdXRlbGlzdGAgaXMgc2V0IHRvIHRydWUuXG4gICAqL1xuICBzZXQgYWN0aXZlVXNlcih1c2VyKSB7XG4gICAgY29uc3QgZGlmZmVyZW50VXNlciA9IHRoaXMuX2FjdGl2ZVVzZXI/LnB1YmtleSAhPT0gdXNlcj8ucHVia2V5O1xuICAgIHRoaXMuX2FjdGl2ZVVzZXIgPSB1c2VyO1xuICAgIGlmICh1c2VyICYmIGRpZmZlcmVudFVzZXIpIHtcbiAgICAgIHNldEFjdGl2ZVVzZXIuY2FsbCh0aGlzLCB1c2VyKTtcbiAgICB9IGVsc2UgaWYgKCF1c2VyKSB7XG4gICAgICB0aGlzLm11dGVkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNpZ25lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lnbmVyO1xuICB9XG4gIHNldCBzaWduZXIobmV3U2lnbmVyKSB7XG4gICAgdGhpcy5fc2lnbmVyID0gbmV3U2lnbmVyO1xuICAgIGlmIChuZXdTaWduZXIpIHRoaXMuZW1pdChcInNpZ25lcjpyZWFkeVwiLCBuZXdTaWduZXIpO1xuICAgIG5ld1NpZ25lcj8udXNlcigpLnRoZW4oKHVzZXIpID0+IHtcbiAgICAgIHVzZXIubmRrID0gdGhpcztcbiAgICAgIHRoaXMuYWN0aXZlVXNlciA9IHVzZXI7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3QgdG8gcmVsYXlzIHdpdGggb3B0aW9uYWwgdGltZW91dC5cbiAgICogSWYgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZCwgdGhlIGNvbm5lY3Rpb24gd2lsbCBiZSBjb250aW51ZWQgdG8gYmUgZXN0YWJsaXNoZWQgaW4gdGhlIGJhY2tncm91bmQuXG4gICAqL1xuICBhc3luYyBjb25uZWN0KHRpbWVvdXRNcykge1xuICAgIGlmICh0aGlzLl9zaWduZXIgJiYgdGhpcy5hdXRvQ29ubmVjdFVzZXJSZWxheXMpIHtcbiAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgIFwiQXR0ZW1wdGluZyB0byBjb25uZWN0IHRvIHVzZXIgcmVsYXlzIHNwZWNpZmllZCBieSBzaWduZXIgJW9cIixcbiAgICAgICAgYXdhaXQgdGhpcy5fc2lnbmVyLnJlbGF5cz8uKHRoaXMpXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuX3NpZ25lci5yZWxheXMpIHtcbiAgICAgICAgY29uc3QgcmVsYXlzID0gYXdhaXQgdGhpcy5fc2lnbmVyLnJlbGF5cyh0aGlzKTtcbiAgICAgICAgcmVsYXlzLmZvckVhY2goKHJlbGF5KSA9PiB0aGlzLnBvb2wuYWRkUmVsYXkocmVsYXkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvbnMgPSBbdGhpcy5wb29sLmNvbm5lY3QodGltZW91dE1zKV07XG4gICAgaWYgKHRoaXMub3V0Ym94UG9vbCkge1xuICAgICAgY29ubmVjdGlvbnMucHVzaCh0aGlzLm91dGJveFBvb2wuY29ubmVjdCh0aW1lb3V0TXMpKTtcbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyhcIkNvbm5lY3RpbmcgdG8gcmVsYXlzICVvXCIsIHsgdGltZW91dE1zIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbFNldHRsZWQoY29ubmVjdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBOREtVc2VyIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gb3B0c1xuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0VXNlcihvcHRzKSB7XG4gICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKG9wdHMpO1xuICAgIHVzZXIubmRrID0gdGhpcztcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgTkRLVXNlciBmcm9tIGEgTklQMDVcbiAgICogQHBhcmFtIG5pcDA1IE5JUC0wNSBJRFxuICAgKiBAcGFyYW0gc2tpcENhY2hlIFNraXAgY2FjaGVcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGdldFVzZXJGcm9tTmlwMDUobmlwMDUsIHNraXBDYWNoZSA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIE5ES1VzZXIuZnJvbU5pcDA1KG5pcDA1LCB0aGlzLCBza2lwQ2FjaGUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBzdGFydHMgYSBuZXcgc3Vic2NyaXB0aW9uLlxuICAgKlxuICAgKiBTdWJzY3JpcHRpb25zIGF1dG9tYXRpY2FsbHkgc3RhcnQgdW5sZXNzIGBhdXRvU3RhcnRgIGlzIHNldCB0byBgZmFsc2VgLlxuICAgKiBZb3UgY2FuIGNvbnRyb2wgYXV0b21hdGljIGNsb3Npbmcgb24gRU9TRSB2aWEgYG9wdHMuY2xvc2VPbkVvc2VgLlxuICAgKlxuICAgKiBAcGFyYW0gZmlsdGVycyAtIEEgc2luZ2xlIE5ES0ZpbHRlciBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgZmlsdGVycy5cbiAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25hbCBOREtTdWJzY3JpcHRpb25PcHRpb25zIHRvIGN1c3RvbWl6ZSBiZWhhdmlvciAoZS5nLiwgY2FjaGluZywgZ3JvdXBpbmcpLlxuICAgKiBAcGFyYW0gaGFuZGxlcnMgLSBPcHRpb25hbCBoYW5kbGVycyBmb3Igc3Vic2NyaXB0aW9uIGV2ZW50cy4gUGFzc2luZyBoYW5kbGVycyBpcyB0aGUgcHJlZmVycmVkIG1ldGhvZCBvZiB1c2luZyBuZGsuc3Vic2NyaWJlLlxuICAgKiAgIC0gYG9uRXZlbnRgOiBDYWxsZWQgZm9yIGVhY2ggZXZlbnQgcmVjZWl2ZWQuXG4gICAqICAtIGBvbkV2ZW50c2A6IENhbGxlZCBvbmNlIHdpdGggYW4gYXJyYXkgb2YgZXZlbnRzIHdoZW4gdGhlIHN1YnNjcmlwdGlvbiBzdGFydHMgKGZyb20gdGhlIGNhY2hlKS5cbiAgICogIC0gYG9uRW9zZWA6IENhbGxlZCB3aGVuIHRoZSBzdWJzY3JpcHRpb24gcmVjZWl2ZXMgRU9TRS5cbiAgICogIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgdGhpcyB0aGlyZCBwYXJhbWV0ZXIgYWxzbyBhY2NlcHRzIGEgcmVsYXlTZXQsIHRoZSByZWxheVNldCBzaG91bGQgYmUgcGFzc2VkIHZpYSBgb3B0cy5yZWxheVNldGAuXG4gICAqXG4gICAqIEBwYXJhbSBfYXV0b1N0YXJ0IC0gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB0aGlzIGNhbiBiZSBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIHN0YXJ0IHRoZSBzdWJzY3JpcHRpb24gaW1tZWRpYXRlbHkuXG4gICAqICBUaGlzIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cbiAgICogICAtIGBmYWxzZWA6IENyZWF0ZXMgdGhlIHN1YnNjcmlwdGlvbiBidXQgZG9lcyBub3Qgc3RhcnQgaXQgKGNhbGwgYHN1YnNjcmlwdGlvbi5zdGFydCgpYCBtYW51YWxseSkuXG4gICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIE5ES1N1YnNjcmlwdGlvbiBpbnN0YW5jZS5cbiAgICpcbiAgICogQGV4YW1wbGUgQmFzaWMgc3Vic2NyaXB0aW9uXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3Qgc3ViID0gbmRrLnN1YnNjcmliZSh7IGtpbmRzOiBbMV0sIGF1dGhvcnM6IFtwdWJrZXldIH0pO1xuICAgKiBzdWIub24oXCJldmVudFwiLCAoZXZlbnQpID0+IGNvbnNvbGUubG9nKFwiS2luZCAxIGV2ZW50OlwiLCBldmVudC5jb250ZW50KSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZSBTdWJzY3JpcHRpb24gd2l0aCBvcHRpb25zIGFuZCBkaXJlY3QgaGFuZGxlcnNcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBzdWIgPSBuZGsuc3Vic2NyaWJlKFxuICAgKiAgIHsga2luZHM6IFswXSwgYXV0aG9yczogW3B1YmtleV0gfSxcbiAgICogICB7IGNsb3NlT25Fb3NlOiB0cnVlLCBjYWNoZVVzYWdlOiBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlLlBBUkFMTEVMIH0sXG4gICAqICAgdW5kZWZpbmVkLCAvLyBVc2UgZGVmYXVsdCByZWxheSBzZXQgY2FsY3VsYXRpb25cbiAgICogICB7XG4gICAqICAgICBvbkV2ZW50czogKGV2ZW50cykgPT4geyAvLyBSZW5hbWVkIHBhcmFtZXRlclxuICAgKiAgICAgICBpZiAoZXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICogICAgICAgICBjb25zb2xlLmxvZyhgR290ICR7ZXZlbnRzLmxlbmd0aH0gcHJvZmlsZSBldmVudHMgZnJvbSBjYWNoZTpgLCBldmVudHNbMF0uY29udGVudCk7XG4gICAqICAgICAgIH1cbiAgICogICAgIH0sXG4gICAqICAgICBvbkV2ZW50OiAoZXZlbnQpID0+IHsgLy8gUmVuYW1lZCBwYXJhbWV0ZXJcbiAgICogICAgICAgY29uc29sZS5sb2coXCJHb3QgcHJvZmlsZSB1cGRhdGUgZnJvbSByZWxheTpcIiwgZXZlbnQuY29udGVudCk7IC8vIENsYXJpZmllZCBzb3VyY2VcbiAgICogICAgIH0sXG4gICAqICAgICBvbkVvc2U6ICgpID0+IGNvbnNvbGUubG9nKFwiUHJvZmlsZSBzdWJzY3JpcHRpb24gZmluaXNoZWQuXCIpXG4gICAqICAgfVxuICAgKiApO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHNpbmNlIDIuMTMuMCBgcmVsYXlTZXRgIHBhcmFtZXRlciByZW1vdmVkOyBwYXNzIGByZWxheVNldGAgb3IgYHJlbGF5VXJsc2AgdmlhIGBvcHRzYC5cbiAgICovXG4gIHN1YnNjcmliZShmaWx0ZXJzLCBvcHRzLCBhdXRvU3RhcnRPclJlbGF5U2V0ID0gdHJ1ZSwgX2F1dG9TdGFydCA9IHRydWUpIHtcbiAgICBsZXQgX3JlbGF5U2V0ID0gb3B0cz8ucmVsYXlTZXQ7XG4gICAgbGV0IGF1dG9TdGFydCA9IF9hdXRvU3RhcnQ7XG4gICAgaWYgKGF1dG9TdGFydE9yUmVsYXlTZXQgaW5zdGFuY2VvZiBOREtSZWxheVNldCkge1xuICAgICAgY29uc29sZS53YXJuKFwicmVsYXlTZXQgaXMgZGVwcmVjYXRlZCwgdXNlIG9wdHMucmVsYXlTZXQgaW5zdGVhZC4gVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiB2Mi4xNC4wXCIpO1xuICAgICAgX3JlbGF5U2V0ID0gYXV0b1N0YXJ0T3JSZWxheVNldDtcbiAgICAgIGF1dG9TdGFydCA9IF9hdXRvU3RhcnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXV0b1N0YXJ0T3JSZWxheVNldCA9PT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIGF1dG9TdGFydE9yUmVsYXlTZXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGF1dG9TdGFydCA9IGF1dG9TdGFydE9yUmVsYXlTZXQ7XG4gICAgfVxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG5ldyBOREtTdWJzY3JpcHRpb24odGhpcywgZmlsdGVycywgeyByZWxheVNldDogX3JlbGF5U2V0LCAuLi5vcHRzIH0pO1xuICAgIHRoaXMuc3ViTWFuYWdlci5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICBjb25zdCBwb29sID0gc3Vic2NyaXB0aW9uLnBvb2w7XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5yZWxheVNldCkge1xuICAgICAgZm9yIChjb25zdCByZWxheSBvZiBzdWJzY3JpcHRpb24ucmVsYXlTZXQucmVsYXlzKSB7XG4gICAgICAgIHBvb2wudXNlVGVtcG9yYXJ5UmVsYXkocmVsYXksIHZvaWQgMCwgc3Vic2NyaXB0aW9uLmZpbHRlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5vdXRib3hQb29sICYmIHN1YnNjcmlwdGlvbi5oYXNBdXRob3JzRmlsdGVyKCkpIHtcbiAgICAgIGNvbnN0IGF1dGhvcnMgPSBzdWJzY3JpcHRpb24uZmlsdGVycy5maWx0ZXIoKGZpbHRlcikgPT4gZmlsdGVyLmF1dGhvcnMgJiYgZmlsdGVyLmF1dGhvcnM/Lmxlbmd0aCA+IDApLmZsYXRNYXAoKGZpbHRlcikgPT4gZmlsdGVyLmF1dGhvcnMpO1xuICAgICAgdGhpcy5vdXRib3hUcmFja2VyPy50cmFja1VzZXJzKGF1dGhvcnMpO1xuICAgIH1cbiAgICBpZiAoYXV0b1N0YXJ0KSB7XG4gICAgICBsZXQgZXZlbnRzSGFuZGxlcjtcbiAgICAgIGlmICh0eXBlb2YgYXV0b1N0YXJ0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChhdXRvU3RhcnQub25FdmVudCkgc3Vic2NyaXB0aW9uLm9uKFwiZXZlbnRcIiwgYXV0b1N0YXJ0Lm9uRXZlbnQpO1xuICAgICAgICBpZiAoYXV0b1N0YXJ0Lm9uRW9zZSkgc3Vic2NyaXB0aW9uLm9uKFwiZW9zZVwiLCBhdXRvU3RhcnQub25Fb3NlKTtcbiAgICAgICAgaWYgKGF1dG9TdGFydC5vbkV2ZW50cykgZXZlbnRzSGFuZGxlciA9IGF1dG9TdGFydC5vbkV2ZW50cztcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBjYWNoZWRFdmVudHMgPSBzdWJzY3JpcHRpb24uc3RhcnQoIWV2ZW50c0hhbmRsZXIpO1xuICAgICAgICBpZiAoY2FjaGVkRXZlbnRzICYmIGNhY2hlZEV2ZW50cy5sZW5ndGggPiAwICYmICEhZXZlbnRzSGFuZGxlcikgZXZlbnRzSGFuZGxlcihjYWNoZWRFdmVudHMpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYW4gZXZlbnQgdG8gYSByZWxheVxuICAgKiBAcGFyYW0gZXZlbnQgZXZlbnQgdG8gcHVibGlzaFxuICAgKiBAcGFyYW0gcmVsYXlTZXQgZXhwbGljaXQgcmVsYXkgc2V0IHRvIHVzZVxuICAgKiBAcGFyYW0gdGltZW91dE1zIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIHRoZSBldmVudCB0byBiZSBwdWJsaXNoZWRcbiAgICogQHJldHVybnMgVGhlIHJlbGF5cyB0aGUgZXZlbnQgd2FzIHB1Ymxpc2hlZCB0b1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYGV2ZW50LnB1Ymxpc2goKWAgaW5zdGVhZFxuICAgKi9cbiAgYXN5bmMgcHVibGlzaChldmVudCwgcmVsYXlTZXQsIHRpbWVvdXRNcykge1xuICAgIHRoaXMuZGVidWcoXCJEZXByZWNhdGVkOiBVc2UgYGV2ZW50LnB1Ymxpc2goKWAgaW5zdGVhZFwiKTtcbiAgICByZXR1cm4gZXZlbnQucHVibGlzaChyZWxheVNldCwgdGltZW91dE1zKTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZmV0Y2ggYW4gZXZlbnQgZnJvbSBhIHRhZywgZm9sbG93aW5nIHJlbGF5IGhpbnRzIGFuZFxuICAgKiBvdGhlciBiZXN0IHByYWN0aWNlcy5cbiAgICogQHBhcmFtIHRhZyBUYWcgdG8gZmV0Y2ggdGhlIGV2ZW50IGZyb21cbiAgICogQHBhcmFtIG9yaWdpbmFsRXZlbnQgRXZlbnQgd2hlcmUgdGhlIHRhZyBjYW1lIGZyb21cbiAgICogQHBhcmFtIHN1Yk9wdHMgU3Vic2NyaXB0aW9uIG9wdGlvbnMgdG8gdXNlIHdoZW4gZmV0Y2hpbmcgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBmYWxsYmFjayBGYWxsYmFjayBvcHRpb25zIHRvIHVzZSB3aGVuIHRoZSBoaW50IHJlbGF5IGRvZXNuJ3QgcmVzcG9uZFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZmV0Y2hFdmVudEZyb21UYWcgPSBmZXRjaEV2ZW50RnJvbVRhZy5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogRmV0Y2ggYW4gZXZlbnQgZnJvbSB0aGUgY2FjaGUgc3luY2hyb25vdXNseS5cbiAgICogQHBhcmFtIGlkT3JGaWx0ZXIgZXZlbnQgaWQgaW4gYmVjaDMyIGZvcm1hdCBvciBmaWx0ZXJcbiAgICogQHJldHVybnMgZXZlbnRzIGZyb20gdGhlIGNhY2hlIG9yIG51bGwgaWYgdGhlIGNhY2hlIGlzIGVtcHR5XG4gICAqL1xuICBmZXRjaEV2ZW50U3luYyhpZE9yRmlsdGVyKSB7XG4gICAgaWYgKCF0aGlzLmNhY2hlQWRhcHRlcikgdGhyb3cgbmV3IEVycm9yKFwiQ2FjaGUgYWRhcHRlciBub3Qgc2V0XCIpO1xuICAgIGxldCBmaWx0ZXJzO1xuICAgIGlmICh0eXBlb2YgaWRPckZpbHRlciA9PT0gXCJzdHJpbmdcIikgZmlsdGVycyA9IFtmaWx0ZXJGcm9tSWQoaWRPckZpbHRlcildO1xuICAgIGVsc2UgZmlsdGVycyA9IGlkT3JGaWx0ZXI7XG4gICAgY29uc3Qgc3ViID0gbmV3IE5ES1N1YnNjcmlwdGlvbih0aGlzLCBmaWx0ZXJzKTtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLmNhY2hlQWRhcHRlci5xdWVyeShzdWIpO1xuICAgIGlmIChldmVudHMgaW5zdGFuY2VvZiBQcm9taXNlKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWNoZSBhZGFwdGVyIGlzIGFzeW5jXCIpO1xuICAgIHJldHVybiBldmVudHMubWFwKChlKSA9PiB7XG4gICAgICBlLm5kayA9IHRoaXM7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBzaW5nbGUgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBpZE9yRmlsdGVyIGV2ZW50IGlkIGluIGJlY2gzMiBmb3JtYXQgb3IgZmlsdGVyXG4gICAqIEBwYXJhbSBvcHRzIHN1YnNjcmlwdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSByZWxheVNldE9yUmVsYXkgZXhwbGljaXQgcmVsYXkgc2V0IHRvIHVzZVxuICAgKi9cbiAgYXN5bmMgZmV0Y2hFdmVudChpZE9yRmlsdGVyLCBvcHRzLCByZWxheVNldE9yUmVsYXkpIHtcbiAgICBsZXQgZmlsdGVycztcbiAgICBsZXQgcmVsYXlTZXQ7XG4gICAgaWYgKHJlbGF5U2V0T3JSZWxheSBpbnN0YW5jZW9mIE5ES1JlbGF5KSB7XG4gICAgICByZWxheVNldCA9IG5ldyBOREtSZWxheVNldCgvKiBAX19QVVJFX18gKi8gbmV3IFNldChbcmVsYXlTZXRPclJlbGF5XSksIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAocmVsYXlTZXRPclJlbGF5IGluc3RhbmNlb2YgTkRLUmVsYXlTZXQpIHtcbiAgICAgIHJlbGF5U2V0ID0gcmVsYXlTZXRPclJlbGF5O1xuICAgIH1cbiAgICBpZiAoIXJlbGF5U2V0T3JSZWxheSAmJiB0eXBlb2YgaWRPckZpbHRlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKCFpc05pcDMzQVZhbHVlKGlkT3JGaWx0ZXIpKSB7XG4gICAgICAgIGNvbnN0IHJlbGF5cyA9IHJlbGF5c0Zyb21CZWNoMzIoaWRPckZpbHRlciwgdGhpcyk7XG4gICAgICAgIGlmIChyZWxheXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlbGF5U2V0ID0gbmV3IE5ES1JlbGF5U2V0KG5ldyBTZXQocmVsYXlzKSwgdGhpcyk7XG4gICAgICAgICAgcmVsYXlTZXQgPSBjb3JyZWN0UmVsYXlTZXQocmVsYXlTZXQsIHRoaXMucG9vbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpZE9yRmlsdGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBmaWx0ZXJzID0gW2ZpbHRlckZyb21JZChpZE9yRmlsdGVyKV07XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlkT3JGaWx0ZXIpKSB7XG4gICAgICBmaWx0ZXJzID0gaWRPckZpbHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsdGVycyA9IFtpZE9yRmlsdGVyXTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmlsdGVyOiAke0pTT04uc3RyaW5naWZ5KGlkT3JGaWx0ZXIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxldCBmZXRjaGVkRXZlbnQgPSBudWxsO1xuICAgICAgY29uc3Qgc3Vic2NyaWJlT3B0cyA9IHtcbiAgICAgICAgLi4ub3B0cyB8fCB7fSxcbiAgICAgICAgY2xvc2VPbkVvc2U6IHRydWVcbiAgICAgIH07XG4gICAgICBpZiAocmVsYXlTZXQpIHN1YnNjcmliZU9wdHMucmVsYXlTZXQgPSByZWxheVNldDtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLnN1YnNjcmliZShcbiAgICAgICAgZmlsdGVycyxcbiAgICAgICAgc3Vic2NyaWJlT3B0cyxcbiAgICAgICAgLy8gcmVsYXlTZXQsIC8vIFJlbW92ZWQ6IFBhc3NlZCB2aWEgb3B0c1xuICAgICAgICBmYWxzZVxuICAgICAgICAvLyBhdXRvU3RhcnQgPSBmYWxzZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHQyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHMuc3RvcCgpO1xuICAgICAgICByZXNvbHZlKGZldGNoZWRFdmVudCk7XG4gICAgICB9LCAxZTQpO1xuICAgICAgcy5vbihcImV2ZW50XCIsIChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5uZGsgPSB0aGlzO1xuICAgICAgICBpZiAoIWV2ZW50LmlzUmVwbGFjZWFibGUoKSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0Mik7XG4gICAgICAgICAgcmVzb2x2ZShldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWZldGNoZWRFdmVudCB8fCBmZXRjaGVkRXZlbnQuY3JlYXRlZF9hdCA8IGV2ZW50LmNyZWF0ZWRfYXQpIHtcbiAgICAgICAgICBmZXRjaGVkRXZlbnQgPSBldmVudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0Mik7XG4gICAgICAgIHJlc29sdmUoZmV0Y2hlZEV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgcy5zdGFydCgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBldmVudHNcbiAgICovXG4gIGFzeW5jIGZldGNoRXZlbnRzKGZpbHRlcnMsIG9wdHMsIHJlbGF5U2V0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBldmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3Qgc3Vic2NyaWJlT3B0cyA9IHtcbiAgICAgICAgLi4ub3B0cyB8fCB7fSxcbiAgICAgICAgY2xvc2VPbkVvc2U6IHRydWVcbiAgICAgIH07XG4gICAgICBpZiAocmVsYXlTZXQpIHN1YnNjcmliZU9wdHMucmVsYXlTZXQgPSByZWxheVNldDtcbiAgICAgIGNvbnN0IHJlbGF5U2V0U3Vic2NyaXB0aW9uID0gdGhpcy5zdWJzY3JpYmUoXG4gICAgICAgIGZpbHRlcnMsXG4gICAgICAgIHN1YnNjcmliZU9wdHMsXG4gICAgICAgIC8vIHJlbGF5U2V0LCAvLyBSZW1vdmVkOiBQYXNzZWQgdmlhIG9wdHNcbiAgICAgICAgZmFsc2VcbiAgICAgICAgLy8gYXV0b1N0YXJ0ID0gZmFsc2VcbiAgICAgICk7XG4gICAgICBjb25zdCBvbkV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGxldCBfZXZlbnQ7XG4gICAgICAgIGlmICghKGV2ZW50IGluc3RhbmNlb2YgTkRLRXZlbnQpKSBfZXZlbnQgPSBuZXcgTkRLRXZlbnQodm9pZCAwLCBldmVudCk7XG4gICAgICAgIGVsc2UgX2V2ZW50ID0gZXZlbnQ7XG4gICAgICAgIGNvbnN0IGRlZHVwS2V5ID0gX2V2ZW50LmRlZHVwbGljYXRpb25LZXkoKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdFdmVudCA9IGV2ZW50cy5nZXQoZGVkdXBLZXkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdFdmVudCkge1xuICAgICAgICAgIF9ldmVudCA9IGRlZHVwKGV4aXN0aW5nRXZlbnQsIF9ldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgX2V2ZW50Lm5kayA9IHRoaXM7XG4gICAgICAgIGV2ZW50cy5zZXQoZGVkdXBLZXksIF9ldmVudCk7XG4gICAgICB9O1xuICAgICAgcmVsYXlTZXRTdWJzY3JpcHRpb24ub24oXCJldmVudFwiLCBvbkV2ZW50KTtcbiAgICAgIHJlbGF5U2V0U3Vic2NyaXB0aW9uLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUobmV3IFNldChldmVudHMudmFsdWVzKCkpKTtcbiAgICAgIH0pO1xuICAgICAgcmVsYXlTZXRTdWJzY3JpcHRpb24uc3RhcnQoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IGEgc2lnbmVyIGlzIGF2YWlsYWJsZSB0byBzaWduIGFuIGV2ZW50LlxuICAgKi9cbiAgYXNzZXJ0U2lnbmVyKCkge1xuICAgIGlmICghdGhpcy5zaWduZXIpIHtcbiAgICAgIHRoaXMuZW1pdChcInNpZ25lcjpyZXF1aXJlZFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ25lciByZXF1aXJlZFwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0RW50aXR5ID0gZ2V0RW50aXR5LmJpbmQodGhpcyk7XG4gIHNldCB3YWxsZXQod2FsbGV0KSB7XG4gICAgaWYgKCF3YWxsZXQpIHtcbiAgICAgIHRoaXMud2FsbGV0Q29uZmlnID0gdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLndhbGxldENvbmZpZyA/Pz0ge307XG4gICAgdGhpcy53YWxsZXRDb25maWcubG5QYXkgPSB3YWxsZXQ/LmxuUGF5Py5iaW5kKHdhbGxldCk7XG4gICAgdGhpcy53YWxsZXRDb25maWcuY2FzaHVQYXkgPSB3YWxsZXQ/LmNhc2h1UGF5Py5iaW5kKHdhbGxldCk7XG4gIH1cbn07XG5cbi8vIHNyYy96YXAvaW52b2ljZS50c1xuaW1wb3J0IHsgZGVjb2RlIH0gZnJvbSBcImxpZ2h0LWJvbHQxMS1kZWNvZGVyXCI7XG5mdW5jdGlvbiB6YXBJbnZvaWNlRnJvbUV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwiZGVzY3JpcHRpb25cIilbMF07XG4gIGNvbnN0IGJvbHQxMSA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImJvbHQxMVwiKVswXTtcbiAgbGV0IGRlY29kZWRJbnZvaWNlO1xuICBsZXQgemFwUmVxdWVzdDtcbiAgaWYgKCFkZXNjcmlwdGlvbiB8fCAhYm9sdDExIHx8ICFib2x0MTFbMV0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIGxldCB6YXBSZXF1ZXN0UGF5bG9hZCA9IGRlc2NyaXB0aW9uWzFdO1xuICAgIGlmICh6YXBSZXF1ZXN0UGF5bG9hZC5zdGFydHNXaXRoKFwiJVwiKSkge1xuICAgICAgemFwUmVxdWVzdFBheWxvYWQgPSBkZWNvZGVVUklDb21wb25lbnQoemFwUmVxdWVzdFBheWxvYWQpO1xuICAgIH1cbiAgICBpZiAoemFwUmVxdWVzdFBheWxvYWQgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB6YXBSZXF1ZXN0ID0gSlNPTi5wYXJzZSh6YXBSZXF1ZXN0UGF5bG9hZCk7XG4gICAgZGVjb2RlZEludm9pY2UgPSBkZWNvZGUoYm9sdDExWzFdKTtcbiAgfSBjYXRjaCAoX2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBhbW91bnRTZWN0aW9uID0gZGVjb2RlZEludm9pY2Uuc2VjdGlvbnMuZmluZCgocykgPT4gcy5uYW1lID09PSBcImFtb3VudFwiKTtcbiAgaWYgKCFhbW91bnRTZWN0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYW1vdW50ID0gTnVtYmVyLnBhcnNlSW50KGFtb3VudFNlY3Rpb24udmFsdWUpO1xuICBpZiAoIWFtb3VudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGNvbnRlbnQgPSB6YXBSZXF1ZXN0LmNvbnRlbnQ7XG4gIGNvbnN0IHNlbmRlciA9IHphcFJlcXVlc3QucHVia2V5O1xuICBjb25zdCByZWNpcGllbnRUYWcgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpWzBdO1xuICBjb25zdCByZWNpcGllbnQgPSByZWNpcGllbnRUYWdbMV07XG4gIGxldCB6YXBwZWRFdmVudCA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImVcIilbMF07XG4gIGlmICghemFwcGVkRXZlbnQpIHtcbiAgICB6YXBwZWRFdmVudCA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImFcIilbMF07XG4gIH1cbiAgY29uc3QgemFwcGVkRXZlbnRJZCA9IHphcHBlZEV2ZW50ID8gemFwcGVkRXZlbnRbMV0gOiB2b2lkIDA7XG4gIGNvbnN0IHphcEludm9pY2UgPSB7XG4gICAgaWQ6IGV2ZW50LmlkLFxuICAgIHphcHBlcjogZXZlbnQucHVia2V5LFxuICAgIHphcHBlZTogc2VuZGVyLFxuICAgIHphcHBlZDogcmVjaXBpZW50LFxuICAgIHphcHBlZEV2ZW50OiB6YXBwZWRFdmVudElkLFxuICAgIGFtb3VudCxcbiAgICBjb21tZW50OiBjb250ZW50XG4gIH07XG4gIHJldHVybiB6YXBJbnZvaWNlO1xufVxuXG4vLyBzcmMvemFwcGVyL2luZGV4LnRzXG5pbXBvcnQgY3JlYXRlRGVidWc1IGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjkgfSBmcm9tIFwidHNlZXBcIjtcblxuLy8gc3JjL3phcHBlci9sbi50c1xuaW1wb3J0IHsgYmVjaDMyIH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG5pbXBvcnQgY3JlYXRlRGVidWc0IGZyb20gXCJkZWJ1Z1wiO1xudmFyIGQyID0gY3JlYXRlRGVidWc0KFwibmRrOnphcHBlcjpsblwiKTtcbmFzeW5jIGZ1bmN0aW9uIGdldE5pcDU3WmFwU3BlY0Zyb21MdWQoeyBsdWQwNiwgbHVkMTYgfSwgbmRrKSB7XG4gIGxldCB6YXBFbmRwb2ludDtcbiAgaWYgKGx1ZDE2ICYmICFsdWQxNi5zdGFydHNXaXRoKFwiTE5VUkxcIikpIHtcbiAgICBjb25zdCBbbmFtZSwgZG9tYWluXSA9IGx1ZDE2LnNwbGl0KFwiQFwiKTtcbiAgICB6YXBFbmRwb2ludCA9IGBodHRwczovLyR7ZG9tYWlufS8ud2VsbC1rbm93bi9sbnVybHAvJHtuYW1lfWA7XG4gIH0gZWxzZSBpZiAobHVkMDYpIHtcbiAgICBjb25zdCB7IHdvcmRzIH0gPSBiZWNoMzIuZGVjb2RlKGx1ZDA2LCAxZTMpO1xuICAgIGNvbnN0IGRhdGEgPSBiZWNoMzIuZnJvbVdvcmRzKHdvcmRzKTtcbiAgICBjb25zdCB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuICAgIHphcEVuZHBvaW50ID0gdXRmOERlY29kZXIuZGVjb2RlKGRhdGEpO1xuICB9XG4gIGlmICghemFwRW5kcG9pbnQpIHtcbiAgICBkMihcIk5vIHphcCBlbmRwb2ludCBmb3VuZCAlb1wiLCB7IGx1ZDA2LCBsdWQxNiB9KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB6YXAgZW5kcG9pbnQgZm91bmRcIik7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBfZmV0Y2ggPSBuZGsuaHR0cEZldGNoIHx8IGZldGNoO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2ZldGNoKHphcEVuZHBvaW50KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmZXRjaCB6YXAgZW5kcG9pbnQgJHt6YXBFbmRwb2ludH06ICR7dGV4dH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZldGNoIHphcCBlbmRwb2ludCAke3phcEVuZHBvaW50fTogJHtlfWApO1xuICB9XG59XG5cbi8vIHNyYy96YXBwZXIvbmlwNTcudHNcbmltcG9ydCB7IG5pcDU3IH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVphcFJlcXVlc3QodGFyZ2V0LCBuZGssIGRhdGEsIHB1YmtleSwgYW1vdW50LCByZWxheXMsIGNvbW1lbnQsIHRhZ3MsIHNpZ25lcikge1xuICBjb25zdCB6YXBFbmRwb2ludCA9IGRhdGEuY2FsbGJhY2s7XG4gIGNvbnN0IHphcFJlcXVlc3QgPSBuaXA1Ny5tYWtlWmFwUmVxdWVzdCh7XG4gICAgcHJvZmlsZTogcHVia2V5LFxuICAgIC8vIHNldCB0aGUgZXZlbnQgdG8gbnVsbCBzaW5jZSBub3N0ci10b29scyBkb2Vzbid0IHN1cHBvcnQgbmlwLTMzIHphcHNcbiAgICBldmVudDogbnVsbCxcbiAgICBhbW91bnQsXG4gICAgY29tbWVudDogY29tbWVudCB8fCBcIlwiLFxuICAgIHJlbGF5czogcmVsYXlzLnNsaWNlKDAsIDQpXG4gIH0pO1xuICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICBjb25zdCB0YWdzMiA9IHRhcmdldC5yZWZlcmVuY2VUYWdzKCk7XG4gICAgY29uc3Qgbm9uUFRhZ3MgPSB0YWdzMi5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcInBcIik7XG4gICAgemFwUmVxdWVzdC50YWdzLnB1c2goLi4ubm9uUFRhZ3MpO1xuICB9XG4gIHphcFJlcXVlc3QudGFncy5wdXNoKFtcImxudXJsXCIsIHphcEVuZHBvaW50XSk7XG4gIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgemFwUmVxdWVzdCk7XG4gIGlmICh0YWdzKSB7XG4gICAgZXZlbnQudGFncyA9IGV2ZW50LnRhZ3MuY29uY2F0KHRhZ3MpO1xuICB9XG4gIGNvbnN0IGVUYWdnZWRFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBhVGFnZ2VkRXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCB0YWcgb2YgZXZlbnQudGFncykge1xuICAgIGlmICh0YWdbMF0gPT09IFwiZVwiKSB7XG4gICAgICBlVGFnZ2VkRXZlbnRzLmFkZCh0YWdbMV0pO1xuICAgIH0gZWxzZSBpZiAodGFnWzBdID09PSBcImFcIikge1xuICAgICAgYVRhZ2dlZEV2ZW50cy5hZGQodGFnWzFdKTtcbiAgICB9XG4gIH1cbiAgaWYgKGVUYWdnZWRFdmVudHMuc2l6ZSA+IDEpIHRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGUtdGFnIGlzIGFsbG93ZWRcIik7XG4gIGlmIChhVGFnZ2VkRXZlbnRzLnNpemUgPiAxKSB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBhLXRhZyBpcyBhbGxvd2VkXCIpO1xuICBldmVudC50YWdzID0gZXZlbnQudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcInBcIik7XG4gIGV2ZW50LnRhZ3MucHVzaChbXCJwXCIsIHB1YmtleV0pO1xuICBhd2FpdCBldmVudC5zaWduKHNpZ25lcik7XG4gIHJldHVybiBldmVudDtcbn1cblxuLy8gc3JjL3phcHBlci9pbmRleC50c1xudmFyIGQzID0gY3JlYXRlRGVidWc1KFwibmRrOnphcHBlclwiKTtcbnZhciBOREtaYXBwZXIgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjkge1xuICB0YXJnZXQ7XG4gIG5kaztcbiAgY29tbWVudDtcbiAgYW1vdW50O1xuICB1bml0O1xuICB0YWdzO1xuICBzaWduZXI7XG4gIHphcE1ldGhvZDtcbiAgbnV0emFwQXNGYWxsYmFjaztcbiAgbG5QYXk7XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIGNhc2h1IHBheW1lbnQgaXMgdG8gYmUgbWFkZS5cbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgc3dhcC9taW50IHByb29mcyBmb3IgdGhlIHJlcXVpcmVkIGFtb3VudCwgaW4gdGhlIHJlcXVpcmVkIHVuaXQsXG4gICAqIGluIGFueSBvZiB0aGUgcHJvdmlkZWQgbWludHMgYW5kIHJldHVybiB0aGUgcHJvb2ZzIGFuZCBtaW50IHVzZWQuXG4gICAqL1xuICBjYXNodVBheTtcbiAgb25Db21wbGV0ZTtcbiAgbWF4UmVsYXlzID0gMztcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvZiB0aGUgemFwXG4gICAqIEBwYXJhbSBhbW91bnQgVGhlIGFtb3VudCB0byBzZW5kIGluZGljYXRlZCBpbiB0aGUgdW5pdFxuICAgKiBAcGFyYW0gdW5pdCBUaGUgdW5pdCBvZiB0aGUgYW1vdW50XG4gICAqIEBwYXJhbSBvcHRzIE9wdGlvbnMgZm9yIHRoZSB6YXBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhcmdldCwgYW1vdW50LCB1bml0ID0gXCJtc2F0XCIsIG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5uZGsgPSBvcHRzLm5kayB8fCB0YXJnZXQubmRrO1xuICAgIGlmICghdGhpcy5uZGspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBwcm92aWRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5hbW91bnQgPSBhbW91bnQ7XG4gICAgdGhpcy5jb21tZW50ID0gb3B0cy5jb21tZW50O1xuICAgIHRoaXMudW5pdCA9IHVuaXQ7XG4gICAgdGhpcy50YWdzID0gb3B0cy50YWdzO1xuICAgIHRoaXMuc2lnbmVyID0gb3B0cy5zaWduZXI7XG4gICAgdGhpcy5udXR6YXBBc0ZhbGxiYWNrID0gb3B0cy5udXR6YXBBc0ZhbGxiYWNrID8/IGZhbHNlO1xuICAgIHRoaXMubG5QYXkgPSBvcHRzLmxuUGF5IHx8IHRoaXMubmRrLndhbGxldENvbmZpZz8ubG5QYXk7XG4gICAgdGhpcy5jYXNodVBheSA9IG9wdHMuY2FzaHVQYXkgfHwgdGhpcy5uZGsud2FsbGV0Q29uZmlnPy5jYXNodVBheTtcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBvcHRzLm9uQ29tcGxldGUgfHwgdGhpcy5uZGsud2FsbGV0Q29uZmlnPy5vblBheW1lbnRDb21wbGV0ZTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGUgemFwcGluZyBwcm9jZXNzXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBjYWxjdWxhdGUgdGhlIHNwbGl0cyBmb3IgdGhpcyB6YXAgYW5kIGluaXRpYXRlIGVhY2ggemFwIHNwbGl0LlxuICAgKi9cbiAgYXN5bmMgemFwKG1ldGhvZHMpIHtcbiAgICBjb25zdCBzcGxpdHMgPSB0aGlzLmdldFphcFNwbGl0cygpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgc3BsaXRzLm1hcChhc3luYyAoc3BsaXQpID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnphcFNwbGl0KHNwbGl0LCBtZXRob2RzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyBFcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcInNwbGl0OmNvbXBsZXRlXCIsIHNwbGl0LCByZXN1bHQpO1xuICAgICAgICByZXN1bHRzLnNldChzcGxpdCwgcmVzdWx0KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLmVtaXQoXCJjb21wbGV0ZVwiLCByZXN1bHRzKTtcbiAgICBpZiAodGhpcy5vbkNvbXBsZXRlKSB0aGlzLm9uQ29tcGxldGUocmVzdWx0cyk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgYXN5bmMgemFwTmlwNTcoc3BsaXQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMubG5QYXkpIHRocm93IG5ldyBFcnJvcihcIk5vIGxuUGF5IGZ1bmN0aW9uIGF2YWlsYWJsZVwiKTtcbiAgICBjb25zdCB6YXBTcGVjID0gYXdhaXQgZ2V0TmlwNTdaYXBTcGVjRnJvbUx1ZChkYXRhLCB0aGlzLm5kayk7XG4gICAgaWYgKCF6YXBTcGVjKSB0aHJvdyBuZXcgRXJyb3IoXCJObyB6YXAgc3BlYyBhdmFpbGFibGUgZm9yIHJlY2lwaWVudFwiKTtcbiAgICBjb25zdCByZWxheXMgPSBhd2FpdCB0aGlzLnJlbGF5cyhzcGxpdC5wdWJrZXkpO1xuICAgIGNvbnN0IHphcFJlcXVlc3QgPSBhd2FpdCBnZW5lcmF0ZVphcFJlcXVlc3QoXG4gICAgICB0aGlzLnRhcmdldCxcbiAgICAgIHRoaXMubmRrLFxuICAgICAgemFwU3BlYyxcbiAgICAgIHNwbGl0LnB1YmtleSxcbiAgICAgIHNwbGl0LmFtb3VudCxcbiAgICAgIHJlbGF5cyxcbiAgICAgIHRoaXMuY29tbWVudCxcbiAgICAgIHRoaXMudGFncyxcbiAgICAgIHRoaXMuc2lnbmVyXG4gICAgKTtcbiAgICBpZiAoIXphcFJlcXVlc3QpIHtcbiAgICAgIGQzKFwiVW5hYmxlIHRvIGdlbmVyYXRlIHphcCByZXF1ZXN0XCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGdlbmVyYXRlIHphcCByZXF1ZXN0XCIpO1xuICAgIH1cbiAgICBjb25zdCBwciA9IGF3YWl0IHRoaXMuZ2V0TG5JbnZvaWNlKHphcFJlcXVlc3QsIHNwbGl0LmFtb3VudCwgemFwU3BlYyk7XG4gICAgaWYgKCFwcikge1xuICAgICAgZDMoXCJVbmFibGUgdG8gZ2V0IHBheW1lbnQgcmVxdWVzdFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBnZXQgcGF5bWVudCByZXF1ZXN0XCIpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJsbl9pbnZvaWNlXCIsIHtcbiAgICAgIGFtb3VudDogc3BsaXQuYW1vdW50LFxuICAgICAgcmVjaXBpZW50UHVia2V5OiBzcGxpdC5wdWJrZXksXG4gICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICBuaXA1N1phcFJlcXVlc3Q6IHphcFJlcXVlc3QsXG4gICAgICBwcixcbiAgICAgIHR5cGU6IFwibmlwNTdcIlxuICAgIH0pO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMubG5QYXkoe1xuICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCxcbiAgICAgIHJlY2lwaWVudFB1YmtleTogc3BsaXQucHVia2V5LFxuICAgICAgcGF5bWVudERlc2NyaXB0aW9uOiBcIk5JUC01NyBaYXBcIixcbiAgICAgIHByLFxuICAgICAgYW1vdW50OiBzcGxpdC5hbW91bnQsXG4gICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICBuaXA1N1phcFJlcXVlc3Q6IHphcFJlcXVlc3RcbiAgICB9KTtcbiAgICBpZiAocmVzPy5wcmVpbWFnZSkge1xuICAgICAgdGhpcy5lbWl0KFwibG5fcGF5bWVudFwiLCB7XG4gICAgICAgIHByZWltYWdlOiByZXMucHJlaW1hZ2UsXG4gICAgICAgIGFtb3VudDogc3BsaXQuYW1vdW50LFxuICAgICAgICByZWNpcGllbnRQdWJrZXk6IHNwbGl0LnB1YmtleSxcbiAgICAgICAgcHIsXG4gICAgICAgIHVuaXQ6IHRoaXMudW5pdCxcbiAgICAgICAgbmlwNTdaYXBSZXF1ZXN0OiB6YXBSZXF1ZXN0LFxuICAgICAgICB0eXBlOiBcIm5pcDU3XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaGVzIGluZm9ybWF0aW9uIGFib3V0IGEgTklQLTYxIHphcCBhbmQgYXNrcyB0aGUgY2FsbGVyIHRvIGNyZWF0ZSBjYXNodSBwcm9vZnMgZm9yIHRoZSB6YXAuXG4gICAqXG4gICAqIChub3RlIHRoYXQgdGhlIGNhc2h1UGF5IGZ1bmN0aW9uIGNhbiB1c2UgYW55IG1ldGhvZCB0byBjcmVhdGUgdGhlIHByb29mcywgaW5jbHVkaW5nIHVzaW5nIGxpZ2h0bmluZ1xuICAgKiB0byBtaW50IHByb29mcyBpbiB0aGUgc3BlY2lmaWVkIG1pbnQsIHRoZSByZXNwb25zaWJpbGl0eSBvZiBtaW50aW5nIHRoZSBwcm9vZnMgaXMgZGVsZWdhdGVkIHRvIHRoZSBjYWxsZXIgKGUuZy4gbmRrLXdhbGxldCkpXG4gICAqL1xuICBhc3luYyB6YXBOaXA2MShzcGxpdCwgZGF0YSkge1xuICAgIGlmICghdGhpcy5jYXNodVBheSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2FzaHVQYXkgZnVuY3Rpb24gYXZhaWxhYmxlXCIpO1xuICAgIGxldCByZXQ7XG4gICAgcmV0ID0gYXdhaXQgdGhpcy5jYXNodVBheShcbiAgICAgIHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCxcbiAgICAgICAgcmVjaXBpZW50UHVia2V5OiBzcGxpdC5wdWJrZXksXG4gICAgICAgIHBheW1lbnREZXNjcmlwdGlvbjogXCJOSVAtNjEgWmFwXCIsXG4gICAgICAgIGFtb3VudDogc3BsaXQuYW1vdW50LFxuICAgICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICAgIC4uLmRhdGEgPz8ge31cbiAgICAgIH0sXG4gICAgICAocHIpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFwibG5faW52b2ljZVwiLCB7XG4gICAgICAgICAgcHIsXG4gICAgICAgICAgYW1vdW50OiBzcGxpdC5hbW91bnQsXG4gICAgICAgICAgcmVjaXBpZW50UHVia2V5OiBzcGxpdC5wdWJrZXksXG4gICAgICAgICAgdW5pdDogdGhpcy51bml0LFxuICAgICAgICAgIHR5cGU6IFwibmlwNjFcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICAgIGQzKFwiTklQLTYxIFphcCByZXN1bHQ6ICVvXCIsIHJldCk7XG4gICAgaWYgKHJldCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBpZiAocmV0KSB7XG4gICAgICBjb25zdCB7IHByb29mcywgbWludCB9ID0gcmV0O1xuICAgICAgaWYgKCFwcm9vZnMgfHwgIW1pbnQpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB6YXAgY29uZmlybWF0aW9uOiBtaXNzaW5nIHByb29mcyBvciBtaW50OiAke3JldH1gKTtcbiAgICAgIGNvbnN0IHJlbGF5cyA9IGF3YWl0IHRoaXMucmVsYXlzKHNwbGl0LnB1YmtleSk7XG4gICAgICBjb25zdCByZWxheVNldCA9IE5ES1JlbGF5U2V0LmZyb21SZWxheVVybHMocmVsYXlzLCB0aGlzLm5kayk7XG4gICAgICBjb25zdCBudXR6YXAgPSBuZXcgTkRLTnV0emFwKHRoaXMubmRrKTtcbiAgICAgIG51dHphcC50YWdzID0gWy4uLm51dHphcC50YWdzLCAuLi50aGlzLnRhZ3MgfHwgW11dO1xuICAgICAgbnV0emFwLnByb29mcyA9IHByb29mcztcbiAgICAgIG51dHphcC5taW50ID0gbWludDtcbiAgICAgIG51dHphcC50YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgIG51dHphcC5jb21tZW50ID0gdGhpcy5jb21tZW50O1xuICAgICAgbnV0emFwLnVuaXQgPSBcInNhdFwiO1xuICAgICAgbnV0emFwLnJlY2lwaWVudFB1YmtleSA9IHNwbGl0LnB1YmtleTtcbiAgICAgIGF3YWl0IG51dHphcC5zaWduKHRoaXMuc2lnbmVyKTtcbiAgICAgIG51dHphcC5wdWJsaXNoKHJlbGF5U2V0KTtcbiAgICAgIHJldHVybiBudXR6YXA7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHphcCBtZXRob2RzIGF2YWlsYWJsZSBmb3IgdGhlIHJlY2lwaWVudCBhbmQgaW5pdGlhdGVzIHRoZSB6YXBcbiAgICogaW4gdGhlIGRlc2lyZWQgbWV0aG9kLlxuICAgKiBAcGFyYW0gc3BsaXRcbiAgICogQHBhcmFtIG1ldGhvZHMgLSBUaGUgbWV0aG9kcyB0byB0cnksIGlmIG5vdCBwcm92aWRlZCwgYWxsIG1ldGhvZHMgd2lsbCBiZSB0cmllZC5cbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIHphcFNwbGl0KHNwbGl0LCBtZXRob2RzKSB7XG4gICAgY29uc3QgcmVjaXBpZW50ID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogc3BsaXQucHVia2V5IH0pO1xuICAgIGNvbnN0IHphcE1ldGhvZHMgPSBhd2FpdCByZWNpcGllbnQuZ2V0WmFwSW5mbygyNTAwKTtcbiAgICBsZXQgcmV0VmFsO1xuICAgIGNvbnN0IGNhbkZhbGxiYWNrVG9OaXA2MSA9IHRoaXMubnV0emFwQXNGYWxsYmFjayAmJiB0aGlzLmNhc2h1UGF5O1xuICAgIGlmICh6YXBNZXRob2RzLnNpemUgPT09IDAgJiYgIWNhbkZhbGxiYWNrVG9OaXA2MSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHphcCBtZXRob2QgYXZhaWxhYmxlIGZvciByZWNpcGllbnQgYW5kIE5JUC02MSBmYWxsYmFjayBpcyBkaXNhYmxlZFwiKTtcbiAgICBjb25zdCBuaXA2MUZhbGxiYWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLm51dHphcEFzRmFsbGJhY2spIHJldHVybjtcbiAgICAgIGNvbnN0IHJlbGF5TGlzdHMgPSBhd2FpdCBnZXRSZWxheUxpc3RGb3JVc2Vycyhbc3BsaXQucHVia2V5XSwgdGhpcy5uZGspO1xuICAgICAgbGV0IHJlbGF5VXJscyA9IHJlbGF5TGlzdHMuZ2V0KHNwbGl0LnB1YmtleSk/LnJlYWRSZWxheVVybHM7XG4gICAgICByZWxheVVybHMgPSB0aGlzLm5kay5wb29sLmNvbm5lY3RlZFJlbGF5cygpLm1hcCgocikgPT4gci51cmwpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuemFwTmlwNjEoc3BsaXQsIHtcbiAgICAgICAgLy8gdXNlIHRoZSB1c2VyJ3MgcmVsYXkgbGlzdFxuICAgICAgICByZWxheXM6IHJlbGF5VXJscyxcbiAgICAgICAgLy8gbG9jayB0byB0aGUgdXNlcidzIGFjdHVhbCBwdWJrZXlcbiAgICAgICAgcDJwazogc3BsaXQucHVia2V5LFxuICAgICAgICAvLyBhbGxvdyBpbnRyYW1pbnQgZmFsbGJhY2tcbiAgICAgICAgYWxsb3dJbnRyYW1pbnRGYWxsYmFjazogISFjYW5GYWxsYmFja1RvTmlwNjFcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgY2FuVXNlTmlwNjEgPSAhbWV0aG9kcyB8fCBtZXRob2RzLmluY2x1ZGVzKFwibmlwNjFcIik7XG4gICAgY29uc3QgY2FuVXNlTmlwNTcgPSAhbWV0aG9kcyB8fCBtZXRob2RzLmluY2x1ZGVzKFwibmlwNTdcIik7XG4gICAgY29uc3QgbmlwNjFNZXRob2QgPSB6YXBNZXRob2RzLmdldChcIm5pcDYxXCIpO1xuICAgIGlmIChuaXA2MU1ldGhvZCAmJiBjYW5Vc2VOaXA2MSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0VmFsID0gYXdhaXQgdGhpcy56YXBOaXA2MShzcGxpdCwgbmlwNjFNZXRob2QpO1xuICAgICAgICBpZiAocmV0VmFsIGluc3RhbmNlb2YgTkRLTnV0emFwKSByZXR1cm4gcmV0VmFsO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJub3RpY2VcIiwgYE5JUC02MSBhdHRlbXB0IGZhaWxlZDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5pcDU3TWV0aG9kID0gemFwTWV0aG9kcy5nZXQoXCJuaXA1N1wiKTtcbiAgICBpZiAobmlwNTdNZXRob2QgJiYgY2FuVXNlTmlwNTcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldFZhbCA9IGF3YWl0IHRoaXMuemFwTmlwNTcoc3BsaXQsIG5pcDU3TWV0aG9kKTtcbiAgICAgICAgaWYgKCEocmV0VmFsIGluc3RhbmNlb2YgRXJyb3IpKSByZXR1cm4gcmV0VmFsO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJub3RpY2VcIiwgYE5JUC01NyBhdHRlbXB0IGZhaWxlZDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjYW5GYWxsYmFja1RvTmlwNjEpIHtcbiAgICAgIHJldFZhbCA9IGF3YWl0IG5pcDYxRmFsbGJhY2soKTtcbiAgICAgIGlmIChyZXRWYWwgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgcmV0VmFsO1xuICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwibm90aWNlXCIsIFwiWmFwIG1ldGhvZHMgZXhoYXVzdGVkIGFuZCB0aGVyZSB3YXMgbm8gZmFsbGJhY2sgdG8gTklQLTYxXCIpO1xuICAgIGlmIChyZXRWYWwgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgcmV0VmFsO1xuICAgIHJldHVybiByZXRWYWw7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBib2x0MTEgZm9yIGEgbmlwNTcgemFwXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcGFyYW0gYW1vdW50XG4gICAqIEBwYXJhbSB6YXBFbmRwb2ludFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgZ2V0TG5JbnZvaWNlKHphcFJlcXVlc3QsIGFtb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHphcEVuZHBvaW50ID0gZGF0YS5jYWxsYmFjaztcbiAgICBjb25zdCBldmVudFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeSh6YXBSZXF1ZXN0LnJhd0V2ZW50KCkpO1xuICAgIGQzKFxuICAgICAgYEZldGNoaW5nIGludm9pY2UgZnJvbSAke3phcEVuZHBvaW50fT8ke25ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhbW91bnQ6IGFtb3VudC50b1N0cmluZygpLFxuICAgICAgICBub3N0cjogZXZlbnRQYXlsb2FkXG4gICAgICB9KX1gXG4gICAgKTtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHphcEVuZHBvaW50KTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImFtb3VudFwiLCBhbW91bnQudG9TdHJpbmcoKSk7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJub3N0clwiLCBldmVudFBheWxvYWQpO1xuICAgIGQzKGBGZXRjaGluZyBpbnZvaWNlIGZyb20gJHt1cmwudG9TdHJpbmcoKX1gKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpKTtcbiAgICBkMyhgR290IHJlc3BvbnNlIGZyb20gemFwIGVuZHBvaW50OiAke3phcEVuZHBvaW50fWAsIHsgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICBkMyhgUmVjZWl2ZWQgbm9uLTIwMCBzdGF0dXMgZnJvbSB6YXAgZW5kcG9pbnQ6ICR7emFwRW5kcG9pbnR9YCwge1xuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgYW1vdW50LFxuICAgICAgICBub3N0cjogZXZlbnRQYXlsb2FkXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmZXRjaCB6YXAgZW5kcG9pbnQgJHt6YXBFbmRwb2ludH06ICR7dGV4dH1gKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gYm9keS5wcjtcbiAgfVxuICBnZXRaYXBTcGxpdHMoKSB7XG4gICAgaWYgKHRoaXMudGFyZ2V0IGluc3RhbmNlb2YgTkRLVXNlcikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHB1YmtleTogdGhpcy50YXJnZXQucHVia2V5LFxuICAgICAgICAgIGFtb3VudDogdGhpcy5hbW91bnRcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgY29uc3QgemFwVGFncyA9IHRoaXMudGFyZ2V0LmdldE1hdGNoaW5nVGFncyhcInphcFwiKTtcbiAgICBpZiAoemFwVGFncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICBwdWJrZXk6IHRoaXMudGFyZ2V0LnB1YmtleSxcbiAgICAgICAgICBhbW91bnQ6IHRoaXMuYW1vdW50XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0IHNwbGl0cyA9IFtdO1xuICAgIGNvbnN0IHRvdGFsID0gemFwVGFncy5yZWR1Y2UoKGFjYywgdGFnKSA9PiBhY2MgKyBOdW1iZXIucGFyc2VJbnQodGFnWzJdKSwgMCk7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgemFwVGFncykge1xuICAgICAgY29uc3QgcHVia2V5ID0gdGFnWzFdO1xuICAgICAgY29uc3QgYW1vdW50ID0gTWF0aC5mbG9vcihOdW1iZXIucGFyc2VJbnQodGFnWzJdKSAvIHRvdGFsICogdGhpcy5hbW91bnQpO1xuICAgICAgc3BsaXRzLnB1c2goeyBwdWJrZXksIGFtb3VudCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNwbGl0cztcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgemFwIG1ldGhvZCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHphcCBhIHB1YmJrZXlcbiAgICogQHBhcmFtIG5ka1xuICAgKiBAcGFyYW0gcHVia2V5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBnZXRaYXBNZXRob2RzKG5kaywgcmVjaXBpZW50LCB0aW1lb3V0ID0gMjUwMCkge1xuICAgIGNvbnN0IHVzZXIgPSBuZGsuZ2V0VXNlcih7IHB1YmtleTogcmVjaXBpZW50IH0pO1xuICAgIHJldHVybiBhd2FpdCB1c2VyLmdldFphcEluZm8odGltZW91dCk7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIHRoZSByZWxheXMgdG8gdXNlIGZvciB0aGUgemFwIHJlcXVlc3RcbiAgICovXG4gIGFzeW5jIHJlbGF5cyhwdWJrZXkpIHtcbiAgICBsZXQgciA9IFtdO1xuICAgIGlmICh0aGlzLm5kaz8uYWN0aXZlVXNlcikge1xuICAgICAgY29uc3QgcmVsYXlMaXN0cyA9IGF3YWl0IGdldFJlbGF5TGlzdEZvclVzZXJzKFt0aGlzLm5kay5hY3RpdmVVc2VyLnB1YmtleSwgcHVia2V5XSwgdGhpcy5uZGspO1xuICAgICAgY29uc3QgcmVsYXlTY29yZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCByZWxheUxpc3Qgb2YgcmVsYXlMaXN0cy52YWx1ZXMoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHVybCBvZiByZWxheUxpc3QucmVhZFJlbGF5VXJscykge1xuICAgICAgICAgIGNvbnN0IHNjb3JlID0gcmVsYXlTY29yZXMuZ2V0KHVybCkgfHwgMDtcbiAgICAgICAgICByZWxheVNjb3Jlcy5zZXQodXJsLCBzY29yZSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByID0gQXJyYXkuZnJvbShyZWxheVNjb3Jlcy5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKS5tYXAoKFt1cmxdKSA9PiB1cmwpLnNsaWNlKDAsIHRoaXMubWF4UmVsYXlzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmRrPy5wb29sPy5wZXJtYW5lbnRBbmRDb25uZWN0ZWRSZWxheXMoKS5sZW5ndGgpIHtcbiAgICAgIHIgPSB0aGlzLm5kay5wb29sLnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLm1hcCgocmVsYXkpID0+IHJlbGF5LnVybCk7XG4gICAgfVxuICAgIGlmICghci5sZW5ndGgpIHtcbiAgICAgIHIgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9maWx0ZXIudHNcbmZ1bmN0aW9uIG1hdGNoRmlsdGVyKGZpbHRlciwgZXZlbnQpIHtcbiAgaWYgKGZpbHRlci5pZHMgJiYgZmlsdGVyLmlkcy5pbmRleE9mKGV2ZW50LmlkKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbHRlci5raW5kcyAmJiBmaWx0ZXIua2luZHMuaW5kZXhPZihldmVudC5raW5kKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbHRlci5hdXRob3JzICYmIGZpbHRlci5hdXRob3JzLmluZGV4T2YoZXZlbnQucHVia2V5KSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBmIGluIGZpbHRlcikge1xuICAgIGlmIChmWzBdID09PSBcIiNcIikge1xuICAgICAgY29uc3QgdGFnTmFtZSA9IGYuc2xpY2UoMSk7XG4gICAgICBpZiAodGFnTmFtZSA9PT0gXCJ0XCIpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZmlsdGVyW2AjJHt0YWdOYW1lfWBdPy5tYXAoKHYpID0+IHYudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmICh2YWx1ZXMgJiYgIWV2ZW50LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSB0YWdOYW1lICYmIHZhbHVlcz8uaW5kZXhPZih2LnRvTG93ZXJDYXNlKCkpICE9PSAtMSkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZmlsdGVyW2AjJHt0YWdOYW1lfWBdO1xuICAgICAgICBpZiAodmFsdWVzICYmICFldmVudC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gdGFnTmFtZSAmJiB2YWx1ZXM/LmluZGV4T2YodikgIT09IC0xKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZmlsdGVyLnNpbmNlICYmIGV2ZW50LmNyZWF0ZWRfYXQgPCBmaWx0ZXIuc2luY2UpIHJldHVybiBmYWxzZTtcbiAgaWYgKGZpbHRlci51bnRpbCAmJiBldmVudC5jcmVhdGVkX2F0ID4gZmlsdGVyLnVudGlsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IHtcbiAgQkVDSDMyX1JFR0VYLFxuICBOREtBcHBIYW5kbGVyRXZlbnQsXG4gIE5ES0FwcFNldHRpbmdzLFxuICBOREtBcnRpY2xlLFxuICBOREtDYXNodU1pbnRMaXN0LFxuICBOREtDYXNodVRva2VuLFxuICBOREtDYXNodVdhbGxldFR4LFxuICBOREtDbGFzc2lmaWVkLFxuICBOREtEVk1Kb2JGZWVkYmFjayxcbiAgTkRLRFZNSm9iUmVzdWx0LFxuICBOREtEVk1SZXF1ZXN0LFxuICBOREtEcmFmdCxcbiAgTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMsXG4gIE5ES0V2ZW50LFxuICBOREtIaWdobGlnaHQsXG4gIE5ES0ltYWdlLFxuICBOREtLaW5kLFxuICBOREtMaXN0LFxuICBOREtMaXN0S2luZHMsXG4gIE5ES05pcDA3U2lnbmVyLFxuICBOREtOaXA0NkJhY2tlbmQsXG4gIE5ES05pcDQ2U2lnbmVyLFxuICBOREtOb3N0clJwYyxcbiAgTkRLTnV0emFwLFxuICBOREtQb29sLFxuICBOREtQcml2YXRlS2V5U2lnbmVyLFxuICBOREtQdWJsaXNoRXJyb3IsXG4gIE5ES1JlbGF5LFxuICBOREtSZWxheUF1dGhQb2xpY2llcyxcbiAgTkRLUmVsYXlMaXN0LFxuICBOREtSZWxheVNldCxcbiAgTkRLUmVsYXlTdGF0dXMsXG4gIE5ES1JlcG9zdCxcbiAgTkRLU2ltcGxlR3JvdXAsXG4gIE5ES1NpbXBsZUdyb3VwTWVtYmVyTGlzdCxcbiAgTkRLU2ltcGxlR3JvdXBNZXRhZGF0YSxcbiAgTkRLU3RvcnksXG4gIE5ES1N0b3J5U3RpY2tlcixcbiAgTkRLU3RvcnlTdGlja2VyVHlwZSxcbiAgTkRLU3Vic2NyaXB0aW9uLFxuICBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlLFxuICBOREtTdWJzY3JpcHRpb25SZWNlaXB0LFxuICBOREtTdWJzY3JpcHRpb25TdGFydCxcbiAgTkRLU3Vic2NyaXB0aW9uVGllcixcbiAgTkRLVHJhbnNjcmlwdGlvbkRWTSxcbiAgTkRLVXNlcixcbiAgTkRLVmlkZW8sXG4gIE5ES1dpa2ksXG4gIE5ES1dpa2lNZXJnZVJlcXVlc3QsXG4gIE5ES1phcHBlcixcbiAgTklQMzNfQV9SRUdFWCxcbiAgTmRrTnV0emFwU3RhdHVzLFxuICBjYWxjdWxhdGVSZWxheVNldEZyb21FdmVudCxcbiAgY2FsY3VsYXRlVGVybUR1cmF0aW9uSW5TZWNvbmRzLFxuICBjYXNodVB1YmtleVRvTm9zdHJQdWJrZXksXG4gIGNvbXBhcmVGaWx0ZXIsXG4gIE5ESyBhcyBkZWZhdWx0LFxuICBkZWZhdWx0T3B0cyxcbiAgZGVzZXJpYWxpemUsXG4gIGR2bVNjaGVkdWxlLFxuICBldmVudEhhc0VUYWdNYXJrZXJzLFxuICBldmVudElzUGFydE9mVGhyZWFkLFxuICBldmVudElzUmVwbHksXG4gIGV2ZW50UmVwbGllcyxcbiAgZXZlbnRUaHJlYWRJZHMsXG4gIGV2ZW50VGhyZWFkcyxcbiAgZXZlbnRzQnlTYW1lQXV0aG9yLFxuICBmaWx0ZXJBbmRSZWxheVNldEZyb21CZWNoMzIsXG4gIGZpbHRlckZpbmdlcnByaW50LFxuICBmaWx0ZXJGb3JFdmVudHNUYWdnaW5nSWQsXG4gIGZpbHRlckZyb21JZCxcbiAgZ2VuZXJhdGVDb250ZW50VGFncyxcbiAgZ2VuZXJhdGVIYXNodGFncyxcbiAgZ2VuZXJhdGVTdWJJZCxcbiAgZ2VuZXJhdGVaYXBSZXF1ZXN0LFxuICBnZXRFdmVudFJlcGx5SWQsXG4gIGdldE5pcDU3WmFwU3BlY0Zyb21MdWQsXG4gIGdldFJlbGF5TGlzdEZvclVzZXIsXG4gIGdldFJlbGF5TGlzdEZvclVzZXJzLFxuICBnZXRSZXBseVRhZyxcbiAgZ2V0Um9vdEV2ZW50SWQsXG4gIGdldFJvb3RUYWcsXG4gIGdpZnRVbndyYXAsXG4gIGdpZnRXcmFwLFxuICBpbWV0YVRhZ1RvVGFnLFxuICBpc0V2ZW50T3JpZ2luYWxQb3N0LFxuICBpc05pcDMzQVZhbHVlLFxuICBtYXBJbWV0YVRhZyxcbiAgbWF0Y2hGaWx0ZXIsXG4gIG1lcmdlRmlsdGVycyxcbiAgbWVyZ2VUYWdzLFxuICBuZGtTaWduZXJGcm9tUGF5bG9hZCxcbiAgbmV3QW1vdW50LFxuICBub3JtYWxpemUsXG4gIG5vcm1hbGl6ZVJlbGF5VXJsLFxuICBub3JtYWxpemVVcmwsXG4gIHBhcnNlVGFnVG9TdWJzY3JpcHRpb25BbW91bnQsXG4gIHBpbkV2ZW50LFxuICBwb3NzaWJsZUludGVydmFsRnJlcXVlbmNpZXMsXG4gIHByb2ZpbGVGcm9tRXZlbnQsXG4gIHByb29mUDJwayxcbiAgcHJvb2ZQMnBrTm9zdHIsXG4gIHByb29mc1RvdGFsQmFsYW5jZSxcbiAgcXVlcnlGdWxseUZpbGxlZCxcbiAgcmVsYXlMaXN0RnJvbUtpbmQzLFxuICByZWxheXNGcm9tQmVjaDMyLFxuICBzZXJpYWxpemUsXG4gIHNlcmlhbGl6ZVByb2ZpbGUsXG4gIHNpZ25lclJlZ2lzdHJ5LFxuICBzdHJUb0RpbWVuc2lvbixcbiAgc3RyVG9Qb3NpdGlvbixcbiAgdHJ5Tm9ybWFsaXplUmVsYXlVcmwsXG4gIHVuaXF1ZVRhZyxcbiAgd3JhcEV2ZW50LFxuICB6YXBJbnZvaWNlRnJvbUV2ZW50XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/@nostr-dev-kit/ndk/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/lib/esm/index.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/lib/esm/index.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Relay: () => (/* binding */ Relay),\n/* harmony export */   SimplePool: () => (/* binding */ SimplePool),\n/* harmony export */   finalizeEvent: () => (/* binding */ finalizeEvent),\n/* harmony export */   fj: () => (/* binding */ fakejson_exports),\n/* harmony export */   generateSecretKey: () => (/* binding */ generateSecretKey),\n/* harmony export */   getEventHash: () => (/* binding */ getEventHash),\n/* harmony export */   getFilterLimit: () => (/* binding */ getFilterLimit),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   kinds: () => (/* binding */ kinds_exports),\n/* harmony export */   matchFilter: () => (/* binding */ matchFilter),\n/* harmony export */   matchFilters: () => (/* binding */ matchFilters),\n/* harmony export */   mergeFilters: () => (/* binding */ mergeFilters),\n/* harmony export */   nip04: () => (/* binding */ nip04_exports),\n/* harmony export */   nip05: () => (/* binding */ nip05_exports),\n/* harmony export */   nip10: () => (/* binding */ nip10_exports),\n/* harmony export */   nip11: () => (/* binding */ nip11_exports),\n/* harmony export */   nip13: () => (/* binding */ nip13_exports),\n/* harmony export */   nip17: () => (/* binding */ nip17_exports),\n/* harmony export */   nip18: () => (/* binding */ nip18_exports),\n/* harmony export */   nip19: () => (/* binding */ nip19_exports),\n/* harmony export */   nip21: () => (/* binding */ nip21_exports),\n/* harmony export */   nip25: () => (/* binding */ nip25_exports),\n/* harmony export */   nip27: () => (/* binding */ nip27_exports),\n/* harmony export */   nip28: () => (/* binding */ nip28_exports),\n/* harmony export */   nip30: () => (/* binding */ nip30_exports),\n/* harmony export */   nip39: () => (/* binding */ nip39_exports),\n/* harmony export */   nip42: () => (/* binding */ nip42_exports),\n/* harmony export */   nip44: () => (/* binding */ nip44_exports),\n/* harmony export */   nip47: () => (/* binding */ nip47_exports),\n/* harmony export */   nip54: () => (/* binding */ nip54_exports),\n/* harmony export */   nip57: () => (/* binding */ nip57_exports),\n/* harmony export */   nip59: () => (/* binding */ nip59_exports),\n/* harmony export */   nip98: () => (/* binding */ nip98_exports),\n/* harmony export */   parseReferences: () => (/* binding */ parseReferences),\n/* harmony export */   serializeEvent: () => (/* binding */ serializeEvent),\n/* harmony export */   sortEvents: () => (/* binding */ sortEvents),\n/* harmony export */   utils: () => (/* binding */ utils_exports),\n/* harmony export */   validateEvent: () => (/* binding */ validateEvent),\n/* harmony export */   verifiedSymbol: () => (/* binding */ verifiedSymbol),\n/* harmony export */   verifyEvent: () => (/* binding */ verifyEvent)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var _noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/ciphers/aes */ \"(ssr)/./node_modules/@noble/ciphers/esm/aes.js\");\n/* harmony import */ var _noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/ciphers/chacha */ \"(ssr)/./node_modules/@noble/ciphers/esm/chacha.js\");\n/* harmony import */ var _noble_ciphers_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @noble/ciphers/utils */ \"(ssr)/./node_modules/@noble/ciphers/esm/utils.js\");\n/* harmony import */ var _noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/hkdf */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js\");\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// pure.ts\n\n\n\n// core.ts\nvar verifiedSymbol = Symbol(\"verified\");\nvar isRecord = (obj) => obj instanceof Object;\nfunction validateEvent(event) {\n  if (!isRecord(event))\n    return false;\n  if (typeof event.kind !== \"number\")\n    return false;\n  if (typeof event.content !== \"string\")\n    return false;\n  if (typeof event.created_at !== \"number\")\n    return false;\n  if (typeof event.pubkey !== \"string\")\n    return false;\n  if (!event.pubkey.match(/^[a-f0-9]{64}$/))\n    return false;\n  if (!Array.isArray(event.tags))\n    return false;\n  for (let i2 = 0; i2 < event.tags.length; i2++) {\n    let tag = event.tags[i2];\n    if (!Array.isArray(tag))\n      return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\")\n        return false;\n    }\n  }\n  return true;\n}\nfunction sortEvents(events) {\n  return events.sort((a, b) => {\n    if (a.created_at !== b.created_at) {\n      return b.created_at - a.created_at;\n    }\n    return a.id.localeCompare(b.id);\n  });\n}\n\n// pure.ts\n\n\n// utils.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  Queue: () => Queue,\n  QueueNode: () => QueueNode,\n  binarySearch: () => binarySearch,\n  insertEventIntoAscendingList: () => insertEventIntoAscendingList,\n  insertEventIntoDescendingList: () => insertEventIntoDescendingList,\n  normalizeURL: () => normalizeURL,\n  utf8Decoder: () => utf8Decoder,\n  utf8Encoder: () => utf8Encoder\n});\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nvar utf8Encoder = new TextEncoder();\nfunction normalizeURL(url) {\n  if (url.indexOf(\"://\") === -1)\n    url = \"wss://\" + url;\n  let p = new URL(url);\n  p.pathname = p.pathname.replace(/\\/+/g, \"/\");\n  if (p.pathname.endsWith(\"/\"))\n    p.pathname = p.pathname.slice(0, -1);\n  if (p.port === \"80\" && p.protocol === \"ws:\" || p.port === \"443\" && p.protocol === \"wss:\")\n    p.port = \"\";\n  p.searchParams.sort();\n  p.hash = \"\";\n  return p.toString();\n}\nfunction insertEventIntoDescendingList(sortedArray, event) {\n  const [idx, found] = binarySearch(sortedArray, (b) => {\n    if (event.id === b.id)\n      return 0;\n    if (event.created_at === b.created_at)\n      return -1;\n    return b.created_at - event.created_at;\n  });\n  if (!found) {\n    sortedArray.splice(idx, 0, event);\n  }\n  return sortedArray;\n}\nfunction insertEventIntoAscendingList(sortedArray, event) {\n  const [idx, found] = binarySearch(sortedArray, (b) => {\n    if (event.id === b.id)\n      return 0;\n    if (event.created_at === b.created_at)\n      return -1;\n    return event.created_at - b.created_at;\n  });\n  if (!found) {\n    sortedArray.splice(idx, 0, event);\n  }\n  return sortedArray;\n}\nfunction binarySearch(arr, compare) {\n  let start = 0;\n  let end = arr.length - 1;\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2);\n    const cmp = compare(arr[mid]);\n    if (cmp === 0) {\n      return [mid, true];\n    }\n    if (cmp < 0) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n  return [start, false];\n}\nvar QueueNode = class {\n  value;\n  next = null;\n  prev = null;\n  constructor(message) {\n    this.value = message;\n  }\n};\nvar Queue = class {\n  first;\n  last;\n  constructor() {\n    this.first = null;\n    this.last = null;\n  }\n  enqueue(value) {\n    const newNode = new QueueNode(value);\n    if (!this.last) {\n      this.first = newNode;\n      this.last = newNode;\n    } else if (this.last === this.first) {\n      this.last = newNode;\n      this.last.prev = this.first;\n      this.first.next = newNode;\n    } else {\n      newNode.prev = this.last;\n      this.last.next = newNode;\n      this.last = newNode;\n    }\n    return true;\n  }\n  dequeue() {\n    if (!this.first)\n      return null;\n    if (this.first === this.last) {\n      const target2 = this.first;\n      this.first = null;\n      this.last = null;\n      return target2.value;\n    }\n    const target = this.first;\n    this.first = target.next;\n    return target.value;\n  }\n};\n\n// pure.ts\nvar JS = class {\n  generateSecretKey() {\n    return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.utils.randomPrivateKey();\n  }\n  getPublicKey(secretKey) {\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.getPublicKey(secretKey));\n  }\n  finalizeEvent(t, secretKey) {\n    const event = t;\n    event.pubkey = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.getPublicKey(secretKey));\n    event.id = getEventHash(event);\n    event.sig = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.sign(getEventHash(event), secretKey));\n    event[verifiedSymbol] = true;\n    return event;\n  }\n  verifyEvent(event) {\n    if (typeof event[verifiedSymbol] === \"boolean\")\n      return event[verifiedSymbol];\n    const hash = getEventHash(event);\n    if (hash !== event.id) {\n      event[verifiedSymbol] = false;\n      return false;\n    }\n    try {\n      const valid = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.verify(event.sig, hash, event.pubkey);\n      event[verifiedSymbol] = valid;\n      return valid;\n    } catch (err) {\n      event[verifiedSymbol] = false;\n      return false;\n    }\n  }\n};\nfunction serializeEvent(evt) {\n  if (!validateEvent(evt))\n    throw new Error(\"can't serialize event with wrong or missing properties\");\n  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);\n}\nfunction getEventHash(event) {\n  let eventHash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(serializeEvent(event)));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(eventHash);\n}\nvar i = new JS();\nvar generateSecretKey = i.generateSecretKey;\nvar getPublicKey = i.getPublicKey;\nvar finalizeEvent = i.finalizeEvent;\nvar verifyEvent = i.verifyEvent;\n\n// kinds.ts\nvar kinds_exports = {};\n__export(kinds_exports, {\n  Application: () => Application,\n  BadgeAward: () => BadgeAward,\n  BadgeDefinition: () => BadgeDefinition,\n  BlockedRelaysList: () => BlockedRelaysList,\n  BookmarkList: () => BookmarkList,\n  Bookmarksets: () => Bookmarksets,\n  Calendar: () => Calendar,\n  CalendarEventRSVP: () => CalendarEventRSVP,\n  ChannelCreation: () => ChannelCreation,\n  ChannelHideMessage: () => ChannelHideMessage,\n  ChannelMessage: () => ChannelMessage,\n  ChannelMetadata: () => ChannelMetadata,\n  ChannelMuteUser: () => ChannelMuteUser,\n  ClassifiedListing: () => ClassifiedListing,\n  ClientAuth: () => ClientAuth,\n  CommunitiesList: () => CommunitiesList,\n  CommunityDefinition: () => CommunityDefinition,\n  CommunityPostApproval: () => CommunityPostApproval,\n  Contacts: () => Contacts,\n  CreateOrUpdateProduct: () => CreateOrUpdateProduct,\n  CreateOrUpdateStall: () => CreateOrUpdateStall,\n  Curationsets: () => Curationsets,\n  Date: () => Date2,\n  DirectMessageRelaysList: () => DirectMessageRelaysList,\n  DraftClassifiedListing: () => DraftClassifiedListing,\n  DraftLong: () => DraftLong,\n  Emojisets: () => Emojisets,\n  EncryptedDirectMessage: () => EncryptedDirectMessage,\n  EventDeletion: () => EventDeletion,\n  FileMetadata: () => FileMetadata,\n  FileServerPreference: () => FileServerPreference,\n  Followsets: () => Followsets,\n  GenericRepost: () => GenericRepost,\n  Genericlists: () => Genericlists,\n  GiftWrap: () => GiftWrap,\n  HTTPAuth: () => HTTPAuth,\n  Handlerinformation: () => Handlerinformation,\n  Handlerrecommendation: () => Handlerrecommendation,\n  Highlights: () => Highlights,\n  InterestsList: () => InterestsList,\n  Interestsets: () => Interestsets,\n  JobFeedback: () => JobFeedback,\n  JobRequest: () => JobRequest,\n  JobResult: () => JobResult,\n  Label: () => Label,\n  LightningPubRPC: () => LightningPubRPC,\n  LiveChatMessage: () => LiveChatMessage,\n  LiveEvent: () => LiveEvent,\n  LongFormArticle: () => LongFormArticle,\n  Metadata: () => Metadata,\n  Mutelist: () => Mutelist,\n  NWCWalletInfo: () => NWCWalletInfo,\n  NWCWalletRequest: () => NWCWalletRequest,\n  NWCWalletResponse: () => NWCWalletResponse,\n  NostrConnect: () => NostrConnect,\n  OpenTimestamps: () => OpenTimestamps,\n  Pinlist: () => Pinlist,\n  PrivateDirectMessage: () => PrivateDirectMessage,\n  ProblemTracker: () => ProblemTracker,\n  ProfileBadges: () => ProfileBadges,\n  PublicChatsList: () => PublicChatsList,\n  Reaction: () => Reaction,\n  RecommendRelay: () => RecommendRelay,\n  RelayList: () => RelayList,\n  Relaysets: () => Relaysets,\n  Report: () => Report,\n  Reporting: () => Reporting,\n  Repost: () => Repost,\n  Seal: () => Seal,\n  SearchRelaysList: () => SearchRelaysList,\n  ShortTextNote: () => ShortTextNote,\n  Time: () => Time,\n  UserEmojiList: () => UserEmojiList,\n  UserStatuses: () => UserStatuses,\n  Zap: () => Zap,\n  ZapGoal: () => ZapGoal,\n  ZapRequest: () => ZapRequest,\n  classifyKind: () => classifyKind,\n  isAddressableKind: () => isAddressableKind,\n  isEphemeralKind: () => isEphemeralKind,\n  isKind: () => isKind,\n  isParameterizedReplaceableKind: () => isParameterizedReplaceableKind,\n  isRegularKind: () => isRegularKind,\n  isReplaceableKind: () => isReplaceableKind\n});\nfunction isRegularKind(kind) {\n  return 1e3 <= kind && kind < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(kind);\n}\nfunction isReplaceableKind(kind) {\n  return [0, 3].includes(kind) || 1e4 <= kind && kind < 2e4;\n}\nfunction isEphemeralKind(kind) {\n  return 2e4 <= kind && kind < 3e4;\n}\nfunction isAddressableKind(kind) {\n  return 3e4 <= kind && kind < 4e4;\n}\nvar isParameterizedReplaceableKind = isAddressableKind;\nfunction classifyKind(kind) {\n  if (isRegularKind(kind))\n    return \"regular\";\n  if (isReplaceableKind(kind))\n    return \"replaceable\";\n  if (isEphemeralKind(kind))\n    return \"ephemeral\";\n  if (isAddressableKind(kind))\n    return \"parameterized\";\n  return \"unknown\";\n}\nfunction isKind(event, kind) {\n  const kindAsArray = kind instanceof Array ? kind : [kind];\n  return validateEvent(event) && kindAsArray.includes(event.kind) || false;\n}\nvar Metadata = 0;\nvar ShortTextNote = 1;\nvar RecommendRelay = 2;\nvar Contacts = 3;\nvar EncryptedDirectMessage = 4;\nvar EventDeletion = 5;\nvar Repost = 6;\nvar Reaction = 7;\nvar BadgeAward = 8;\nvar Seal = 13;\nvar PrivateDirectMessage = 14;\nvar GenericRepost = 16;\nvar ChannelCreation = 40;\nvar ChannelMetadata = 41;\nvar ChannelMessage = 42;\nvar ChannelHideMessage = 43;\nvar ChannelMuteUser = 44;\nvar OpenTimestamps = 1040;\nvar GiftWrap = 1059;\nvar FileMetadata = 1063;\nvar LiveChatMessage = 1311;\nvar ProblemTracker = 1971;\nvar Report = 1984;\nvar Reporting = 1984;\nvar Label = 1985;\nvar CommunityPostApproval = 4550;\nvar JobRequest = 5999;\nvar JobResult = 6999;\nvar JobFeedback = 7e3;\nvar ZapGoal = 9041;\nvar ZapRequest = 9734;\nvar Zap = 9735;\nvar Highlights = 9802;\nvar Mutelist = 1e4;\nvar Pinlist = 10001;\nvar RelayList = 10002;\nvar BookmarkList = 10003;\nvar CommunitiesList = 10004;\nvar PublicChatsList = 10005;\nvar BlockedRelaysList = 10006;\nvar SearchRelaysList = 10007;\nvar InterestsList = 10015;\nvar UserEmojiList = 10030;\nvar DirectMessageRelaysList = 10050;\nvar FileServerPreference = 10096;\nvar NWCWalletInfo = 13194;\nvar LightningPubRPC = 21e3;\nvar ClientAuth = 22242;\nvar NWCWalletRequest = 23194;\nvar NWCWalletResponse = 23195;\nvar NostrConnect = 24133;\nvar HTTPAuth = 27235;\nvar Followsets = 3e4;\nvar Genericlists = 30001;\nvar Relaysets = 30002;\nvar Bookmarksets = 30003;\nvar Curationsets = 30004;\nvar ProfileBadges = 30008;\nvar BadgeDefinition = 30009;\nvar Interestsets = 30015;\nvar CreateOrUpdateStall = 30017;\nvar CreateOrUpdateProduct = 30018;\nvar LongFormArticle = 30023;\nvar DraftLong = 30024;\nvar Emojisets = 30030;\nvar Application = 30078;\nvar LiveEvent = 30311;\nvar UserStatuses = 30315;\nvar ClassifiedListing = 30402;\nvar DraftClassifiedListing = 30403;\nvar Date2 = 31922;\nvar Time = 31923;\nvar Calendar = 31924;\nvar CalendarEventRSVP = 31925;\nvar Handlerrecommendation = 31989;\nvar Handlerinformation = 31990;\nvar CommunityDefinition = 34550;\n\n// filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    return false;\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {\n    return false;\n  }\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    return false;\n  }\n  for (let f in filter) {\n    if (f[0] === \"#\") {\n      let tagName = f.slice(1);\n      let values = filter[`#${tagName}`];\n      if (values && !event.tags.find(([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1))\n        return false;\n    }\n  }\n  if (filter.since && event.created_at < filter.since)\n    return false;\n  if (filter.until && event.created_at > filter.until)\n    return false;\n  return true;\n}\nfunction matchFilters(filters, event) {\n  for (let i2 = 0; i2 < filters.length; i2++) {\n    if (matchFilter(filters[i2], event)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction mergeFilters(...filters) {\n  let result = {};\n  for (let i2 = 0; i2 < filters.length; i2++) {\n    let filter = filters[i2];\n    Object.entries(filter).forEach(([property, values]) => {\n      if (property === \"kinds\" || property === \"ids\" || property === \"authors\" || property[0] === \"#\") {\n        result[property] = result[property] || [];\n        for (let v = 0; v < values.length; v++) {\n          let value = values[v];\n          if (!result[property].includes(value))\n            result[property].push(value);\n        }\n      }\n    });\n    if (filter.limit && (!result.limit || filter.limit > result.limit))\n      result.limit = filter.limit;\n    if (filter.until && (!result.until || filter.until > result.until))\n      result.until = filter.until;\n    if (filter.since && (!result.since || filter.since < result.since))\n      result.since = filter.since;\n  }\n  return result;\n}\nfunction getFilterLimit(filter) {\n  if (filter.ids && !filter.ids.length)\n    return 0;\n  if (filter.kinds && !filter.kinds.length)\n    return 0;\n  if (filter.authors && !filter.authors.length)\n    return 0;\n  for (const [key, value] of Object.entries(filter)) {\n    if (key[0] === \"#\" && Array.isArray(value) && !value.length)\n      return 0;\n  }\n  return Math.min(\n    Math.max(0, filter.limit ?? Infinity),\n    filter.ids?.length ?? Infinity,\n    filter.authors?.length && filter.kinds?.every((kind) => isReplaceableKind(kind)) ? filter.authors.length * filter.kinds.length : Infinity,\n    filter.authors?.length && filter.kinds?.every((kind) => isAddressableKind(kind)) && filter[\"#d\"]?.length ? filter.authors.length * filter.kinds.length * filter[\"#d\"].length : Infinity\n  );\n}\n\n// fakejson.ts\nvar fakejson_exports = {};\n__export(fakejson_exports, {\n  getHex64: () => getHex64,\n  getInt: () => getInt,\n  getSubscriptionId: () => getSubscriptionId,\n  matchEventId: () => matchEventId,\n  matchEventKind: () => matchEventKind,\n  matchEventPubkey: () => matchEventPubkey\n});\nfunction getHex64(json, field) {\n  let len = field.length + 3;\n  let idx = json.indexOf(`\"${field}\":`) + len;\n  let s = json.slice(idx).indexOf(`\"`) + idx + 1;\n  return json.slice(s, s + 64);\n}\nfunction getInt(json, field) {\n  let len = field.length;\n  let idx = json.indexOf(`\"${field}\":`) + len + 3;\n  let sliced = json.slice(idx);\n  let end = Math.min(sliced.indexOf(\",\"), sliced.indexOf(\"}\"));\n  return parseInt(sliced.slice(0, end), 10);\n}\nfunction getSubscriptionId(json) {\n  let idx = json.slice(0, 22).indexOf(`\"EVENT\"`);\n  if (idx === -1)\n    return null;\n  let pstart = json.slice(idx + 7 + 1).indexOf(`\"`);\n  if (pstart === -1)\n    return null;\n  let start = idx + 7 + 1 + pstart;\n  let pend = json.slice(start + 1, 80).indexOf(`\"`);\n  if (pend === -1)\n    return null;\n  let end = start + 1 + pend;\n  return json.slice(start + 1, end);\n}\nfunction matchEventId(json, id) {\n  return id === getHex64(json, \"id\");\n}\nfunction matchEventPubkey(json, pubkey) {\n  return pubkey === getHex64(json, \"pubkey\");\n}\nfunction matchEventKind(json, kind) {\n  return kind === getInt(json, \"kind\");\n}\n\n// nip42.ts\nvar nip42_exports = {};\n__export(nip42_exports, {\n  makeAuthEvent: () => makeAuthEvent\n});\nfunction makeAuthEvent(relayURL, challenge) {\n  return {\n    kind: ClientAuth,\n    created_at: Math.floor(Date.now() / 1e3),\n    tags: [\n      [\"relay\", relayURL],\n      [\"challenge\", challenge]\n    ],\n    content: \"\"\n  };\n}\n\n// helpers.ts\nasync function yieldThread() {\n  return new Promise((resolve) => {\n    const ch = new MessageChannel();\n    const handler = () => {\n      ch.port1.removeEventListener(\"message\", handler);\n      resolve();\n    };\n    ch.port1.addEventListener(\"message\", handler);\n    ch.port2.postMessage(0);\n    ch.port1.start();\n  });\n}\nvar alwaysTrue = (t) => {\n  t[verifiedSymbol] = true;\n  return true;\n};\n\n// abstract-relay.ts\nvar AbstractRelay = class {\n  url;\n  _connected = false;\n  onclose = null;\n  onnotice = (msg) => console.debug(`NOTICE from ${this.url}: ${msg}`);\n  _onauth = null;\n  baseEoseTimeout = 4400;\n  connectionTimeout = 4400;\n  publishTimeout = 4400;\n  openSubs = /* @__PURE__ */ new Map();\n  connectionTimeoutHandle;\n  connectionPromise;\n  openCountRequests = /* @__PURE__ */ new Map();\n  openEventPublishes = /* @__PURE__ */ new Map();\n  ws;\n  incomingMessageQueue = new Queue();\n  queueRunning = false;\n  challenge;\n  authPromise;\n  serial = 0;\n  verifyEvent;\n  _WebSocket;\n  constructor(url, opts) {\n    this.url = normalizeURL(url);\n    this.verifyEvent = opts.verifyEvent;\n    this._WebSocket = opts.websocketImplementation || WebSocket;\n  }\n  static async connect(url, opts) {\n    const relay = new AbstractRelay(url, opts);\n    await relay.connect();\n    return relay;\n  }\n  closeAllSubscriptions(reason) {\n    for (let [_, sub] of this.openSubs) {\n      sub.close(reason);\n    }\n    this.openSubs.clear();\n    for (let [_, ep] of this.openEventPublishes) {\n      ep.reject(new Error(reason));\n    }\n    this.openEventPublishes.clear();\n    for (let [_, cr] of this.openCountRequests) {\n      cr.reject(new Error(reason));\n    }\n    this.openCountRequests.clear();\n  }\n  get connected() {\n    return this._connected;\n  }\n  async connect() {\n    if (this.connectionPromise)\n      return this.connectionPromise;\n    this.challenge = void 0;\n    this.authPromise = void 0;\n    this.connectionPromise = new Promise((resolve, reject) => {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        reject(\"connection timed out\");\n        this.connectionPromise = void 0;\n        this.onclose?.();\n        this.closeAllSubscriptions(\"relay connection timed out\");\n      }, this.connectionTimeout);\n      try {\n        this.ws = new this._WebSocket(this.url);\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      this.ws.onopen = () => {\n        clearTimeout(this.connectionTimeoutHandle);\n        this._connected = true;\n        resolve();\n      };\n      this.ws.onerror = (ev) => {\n        reject(ev.message || \"websocket error\");\n        if (this._connected) {\n          this._connected = false;\n          this.connectionPromise = void 0;\n          this.onclose?.();\n          this.closeAllSubscriptions(\"relay connection errored\");\n        }\n      };\n      this.ws.onclose = async () => {\n        if (this._connected) {\n          this._connected = false;\n          this.connectionPromise = void 0;\n          this.onclose?.();\n          this.closeAllSubscriptions(\"relay connection closed\");\n        }\n      };\n      this.ws.onmessage = this._onmessage.bind(this);\n    });\n    return this.connectionPromise;\n  }\n  async runQueue() {\n    this.queueRunning = true;\n    while (true) {\n      if (false === this.handleNext()) {\n        break;\n      }\n      await yieldThread();\n    }\n    this.queueRunning = false;\n  }\n  handleNext() {\n    const json = this.incomingMessageQueue.dequeue();\n    if (!json) {\n      return false;\n    }\n    const subid = getSubscriptionId(json);\n    if (subid) {\n      const so = this.openSubs.get(subid);\n      if (!so) {\n        return;\n      }\n      const id = getHex64(json, \"id\");\n      const alreadyHave = so.alreadyHaveEvent?.(id);\n      so.receivedEvent?.(this, id);\n      if (alreadyHave) {\n        return;\n      }\n    }\n    try {\n      let data = JSON.parse(json);\n      switch (data[0]) {\n        case \"EVENT\": {\n          const so = this.openSubs.get(data[1]);\n          const event = data[2];\n          if (this.verifyEvent(event) && matchFilters(so.filters, event)) {\n            so.onevent(event);\n          }\n          return;\n        }\n        case \"COUNT\": {\n          const id = data[1];\n          const payload = data[2];\n          const cr = this.openCountRequests.get(id);\n          if (cr) {\n            cr.resolve(payload.count);\n            this.openCountRequests.delete(id);\n          }\n          return;\n        }\n        case \"EOSE\": {\n          const so = this.openSubs.get(data[1]);\n          if (!so)\n            return;\n          so.receivedEose();\n          return;\n        }\n        case \"OK\": {\n          const id = data[1];\n          const ok = data[2];\n          const reason = data[3];\n          const ep = this.openEventPublishes.get(id);\n          if (ep) {\n            clearTimeout(ep.timeout);\n            if (ok)\n              ep.resolve(reason);\n            else\n              ep.reject(new Error(reason));\n            this.openEventPublishes.delete(id);\n          }\n          return;\n        }\n        case \"CLOSED\": {\n          const id = data[1];\n          const so = this.openSubs.get(id);\n          if (!so)\n            return;\n          so.closed = true;\n          so.close(data[2]);\n          return;\n        }\n        case \"NOTICE\":\n          this.onnotice(data[1]);\n          return;\n        case \"AUTH\": {\n          this.challenge = data[1];\n          this.authPromise = void 0;\n          this._onauth?.(data[1]);\n          return;\n        }\n      }\n    } catch (err) {\n      return;\n    }\n  }\n  async send(message) {\n    if (!this.connectionPromise)\n      throw new Error(\"sending on closed connection\");\n    this.connectionPromise.then(() => {\n      this.ws?.send(message);\n    });\n  }\n  async auth(signAuthEvent) {\n    if (!this.challenge)\n      throw new Error(\"can't perform auth, no challenge was received\");\n    if (this.authPromise)\n      return this.authPromise;\n    const evt = await signAuthEvent(makeAuthEvent(this.url, this.challenge));\n    this.authPromise = new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        const ep = this.openEventPublishes.get(evt.id);\n        if (ep) {\n          ep.reject(new Error(\"auth timed out\"));\n          this.openEventPublishes.delete(evt.id);\n        }\n      }, this.publishTimeout);\n      this.openEventPublishes.set(evt.id, { resolve, reject, timeout });\n    });\n    this.send('[\"AUTH\",' + JSON.stringify(evt) + \"]\");\n    return this.authPromise;\n  }\n  async publish(event) {\n    const ret = new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        const ep = this.openEventPublishes.get(event.id);\n        if (ep) {\n          ep.reject(new Error(\"publish timed out\"));\n          this.openEventPublishes.delete(event.id);\n        }\n      }, this.publishTimeout);\n      this.openEventPublishes.set(event.id, { resolve, reject, timeout });\n    });\n    this.send('[\"EVENT\",' + JSON.stringify(event) + \"]\");\n    return ret;\n  }\n  async count(filters, params) {\n    this.serial++;\n    const id = params?.id || \"count:\" + this.serial;\n    const ret = new Promise((resolve, reject) => {\n      this.openCountRequests.set(id, { resolve, reject });\n    });\n    this.send('[\"COUNT\",\"' + id + '\",' + JSON.stringify(filters).substring(1));\n    return ret;\n  }\n  subscribe(filters, params) {\n    const subscription = this.prepareSubscription(filters, params);\n    subscription.fire();\n    return subscription;\n  }\n  prepareSubscription(filters, params) {\n    this.serial++;\n    const id = params.id || (params.label ? params.label + \":\" : \"sub:\") + this.serial;\n    const subscription = new Subscription(this, id, filters, params);\n    this.openSubs.set(id, subscription);\n    return subscription;\n  }\n  close() {\n    this.closeAllSubscriptions(\"relay connection closed by us\");\n    this._connected = false;\n    this.ws?.close();\n  }\n  _onmessage(ev) {\n    this.incomingMessageQueue.enqueue(ev.data);\n    if (!this.queueRunning) {\n      this.runQueue();\n    }\n  }\n};\nvar Subscription = class {\n  relay;\n  id;\n  closed = false;\n  eosed = false;\n  filters;\n  alreadyHaveEvent;\n  receivedEvent;\n  onevent;\n  oneose;\n  onclose;\n  eoseTimeout;\n  eoseTimeoutHandle;\n  constructor(relay, id, filters, params) {\n    this.relay = relay;\n    this.filters = filters;\n    this.id = id;\n    this.alreadyHaveEvent = params.alreadyHaveEvent;\n    this.receivedEvent = params.receivedEvent;\n    this.eoseTimeout = params.eoseTimeout || relay.baseEoseTimeout;\n    this.oneose = params.oneose;\n    this.onclose = params.onclose;\n    this.onevent = params.onevent || ((event) => {\n      console.warn(\n        `onevent() callback not defined for subscription '${this.id}' in relay ${this.relay.url}. event received:`,\n        event\n      );\n    });\n  }\n  fire() {\n    this.relay.send('[\"REQ\",\"' + this.id + '\",' + JSON.stringify(this.filters).substring(1));\n    this.eoseTimeoutHandle = setTimeout(this.receivedEose.bind(this), this.eoseTimeout);\n  }\n  receivedEose() {\n    if (this.eosed)\n      return;\n    clearTimeout(this.eoseTimeoutHandle);\n    this.eosed = true;\n    this.oneose?.();\n  }\n  close(reason = \"closed by caller\") {\n    if (!this.closed && this.relay.connected) {\n      this.relay.send('[\"CLOSE\",' + JSON.stringify(this.id) + \"]\");\n      this.closed = true;\n    }\n    this.relay.openSubs.delete(this.id);\n    this.onclose?.(reason);\n  }\n};\n\n// relay.ts\nvar _WebSocket;\ntry {\n  _WebSocket = WebSocket;\n} catch {\n}\nvar Relay = class extends AbstractRelay {\n  constructor(url) {\n    super(url, { verifyEvent, websocketImplementation: _WebSocket });\n  }\n  static async connect(url) {\n    const relay = new Relay(url);\n    await relay.connect();\n    return relay;\n  }\n};\n\n// abstract-pool.ts\nvar AbstractSimplePool = class {\n  relays = /* @__PURE__ */ new Map();\n  seenOn = /* @__PURE__ */ new Map();\n  trackRelays = false;\n  verifyEvent;\n  trustedRelayURLs = /* @__PURE__ */ new Set();\n  _WebSocket;\n  constructor(opts) {\n    this.verifyEvent = opts.verifyEvent;\n    this._WebSocket = opts.websocketImplementation;\n  }\n  async ensureRelay(url, params) {\n    url = normalizeURL(url);\n    let relay = this.relays.get(url);\n    if (!relay) {\n      relay = new AbstractRelay(url, {\n        verifyEvent: this.trustedRelayURLs.has(url) ? alwaysTrue : this.verifyEvent,\n        websocketImplementation: this._WebSocket\n      });\n      if (params?.connectionTimeout)\n        relay.connectionTimeout = params.connectionTimeout;\n      this.relays.set(url, relay);\n    }\n    await relay.connect();\n    return relay;\n  }\n  close(relays) {\n    relays.map(normalizeURL).forEach((url) => {\n      this.relays.get(url)?.close();\n    });\n  }\n  subscribe(relays, filter, params) {\n    return this.subscribeMap(\n      relays.map((url) => ({ url, filter })),\n      params\n    );\n  }\n  subscribeMany(relays, filters, params) {\n    return this.subscribeMap(\n      relays.flatMap((url) => filters.map((filter) => ({ url, filter }))),\n      params\n    );\n  }\n  subscribeMap(requests, params) {\n    if (this.trackRelays) {\n      params.receivedEvent = (relay, id) => {\n        let set = this.seenOn.get(id);\n        if (!set) {\n          set = /* @__PURE__ */ new Set();\n          this.seenOn.set(id, set);\n        }\n        set.add(relay);\n      };\n    }\n    const _knownIds = /* @__PURE__ */ new Set();\n    const subs = [];\n    const eosesReceived = [];\n    let handleEose = (i2) => {\n      if (eosesReceived[i2])\n        return;\n      eosesReceived[i2] = true;\n      if (eosesReceived.filter((a) => a).length === requests.length) {\n        params.oneose?.();\n        handleEose = () => {\n        };\n      }\n    };\n    const closesReceived = [];\n    let handleClose = (i2, reason) => {\n      if (closesReceived[i2])\n        return;\n      handleEose(i2);\n      closesReceived[i2] = reason;\n      if (closesReceived.filter((a) => a).length === requests.length) {\n        params.onclose?.(closesReceived);\n        handleClose = () => {\n        };\n      }\n    };\n    const localAlreadyHaveEventHandler = (id) => {\n      if (params.alreadyHaveEvent?.(id)) {\n        return true;\n      }\n      const have = _knownIds.has(id);\n      _knownIds.add(id);\n      return have;\n    };\n    const allOpened = Promise.all(\n      requests.map(async ({ url, filter }, i2) => {\n        url = normalizeURL(url);\n        let relay;\n        try {\n          relay = await this.ensureRelay(url, {\n            connectionTimeout: params.maxWait ? Math.max(params.maxWait * 0.8, params.maxWait - 1e3) : void 0\n          });\n        } catch (err) {\n          handleClose(i2, err?.message || String(err));\n          return;\n        }\n        let subscription = relay.subscribe([filter], {\n          ...params,\n          oneose: () => handleEose(i2),\n          onclose: (reason) => {\n            if (reason.startsWith(\"auth-required:\") && params.doauth) {\n              relay.auth(params.doauth).then(() => {\n                relay.subscribe([filter], {\n                  ...params,\n                  oneose: () => handleEose(i2),\n                  onclose: (reason2) => {\n                    handleClose(i2, reason2);\n                  },\n                  alreadyHaveEvent: localAlreadyHaveEventHandler,\n                  eoseTimeout: params.maxWait\n                });\n              }).catch((err) => {\n                handleClose(i2, `auth was required and attempted, but failed with: ${err}`);\n              });\n            } else {\n              handleClose(i2, reason);\n            }\n          },\n          alreadyHaveEvent: localAlreadyHaveEventHandler,\n          eoseTimeout: params.maxWait\n        });\n        subs.push(subscription);\n      })\n    );\n    return {\n      async close() {\n        await allOpened;\n        subs.forEach((sub) => {\n          sub.close();\n        });\n      }\n    };\n  }\n  subscribeManyMap(requests, params) {\n    if (this.trackRelays) {\n      params.receivedEvent = (relay, id) => {\n        let set = this.seenOn.get(id);\n        if (!set) {\n          set = /* @__PURE__ */ new Set();\n          this.seenOn.set(id, set);\n        }\n        set.add(relay);\n      };\n    }\n    const _knownIds = /* @__PURE__ */ new Set();\n    const subs = [];\n    const relaysLength = Object.keys(requests).length;\n    const eosesReceived = [];\n    let handleEose = (i2) => {\n      if (eosesReceived[i2])\n        return;\n      eosesReceived[i2] = true;\n      if (eosesReceived.filter((a) => a).length === relaysLength) {\n        params.oneose?.();\n        handleEose = () => {\n        };\n      }\n    };\n    const closesReceived = [];\n    let handleClose = (i2, reason) => {\n      if (closesReceived[i2])\n        return;\n      handleEose(i2);\n      closesReceived[i2] = reason;\n      if (closesReceived.filter((a) => a).length === relaysLength) {\n        params.onclose?.(closesReceived);\n        handleClose = () => {\n        };\n      }\n    };\n    const localAlreadyHaveEventHandler = (id) => {\n      if (params.alreadyHaveEvent?.(id)) {\n        return true;\n      }\n      const have = _knownIds.has(id);\n      _knownIds.add(id);\n      return have;\n    };\n    const allOpened = Promise.all(\n      Object.entries(requests).map(async (req, i2, arr) => {\n        if (arr.indexOf(req) !== i2) {\n          handleClose(i2, \"duplicate url\");\n          return;\n        }\n        let [url, filters] = req;\n        url = normalizeURL(url);\n        let relay;\n        try {\n          relay = await this.ensureRelay(url, {\n            connectionTimeout: params.maxWait ? Math.max(params.maxWait * 0.8, params.maxWait - 1e3) : void 0\n          });\n        } catch (err) {\n          handleClose(i2, err?.message || String(err));\n          return;\n        }\n        let subscription = relay.subscribe(filters, {\n          ...params,\n          oneose: () => handleEose(i2),\n          onclose: (reason) => {\n            if (reason.startsWith(\"auth-required:\") && params.doauth) {\n              relay.auth(params.doauth).then(() => {\n                relay.subscribe(filters, {\n                  ...params,\n                  oneose: () => handleEose(i2),\n                  onclose: (reason2) => {\n                    handleClose(i2, reason2);\n                  },\n                  alreadyHaveEvent: localAlreadyHaveEventHandler,\n                  eoseTimeout: params.maxWait\n                });\n              }).catch((err) => {\n                handleClose(i2, `auth was required and attempted, but failed with: ${err}`);\n              });\n            } else {\n              handleClose(i2, reason);\n            }\n          },\n          alreadyHaveEvent: localAlreadyHaveEventHandler,\n          eoseTimeout: params.maxWait\n        });\n        subs.push(subscription);\n      })\n    );\n    return {\n      async close() {\n        await allOpened;\n        subs.forEach((sub) => {\n          sub.close();\n        });\n      }\n    };\n  }\n  subscribeEose(relays, filter, params) {\n    const subcloser = this.subscribe(relays, filter, {\n      ...params,\n      oneose() {\n        subcloser.close();\n      }\n    });\n    return subcloser;\n  }\n  subscribeManyEose(relays, filters, params) {\n    const subcloser = this.subscribeMany(relays, filters, {\n      ...params,\n      oneose() {\n        subcloser.close();\n      }\n    });\n    return subcloser;\n  }\n  async querySync(relays, filter, params) {\n    return new Promise(async (resolve) => {\n      const events = [];\n      this.subscribeEose(relays, filter, {\n        ...params,\n        onevent(event) {\n          events.push(event);\n        },\n        onclose(_) {\n          resolve(events);\n        }\n      });\n    });\n  }\n  async get(relays, filter, params) {\n    filter.limit = 1;\n    const events = await this.querySync(relays, filter, params);\n    events.sort((a, b) => b.created_at - a.created_at);\n    return events[0] || null;\n  }\n  publish(relays, event) {\n    return relays.map(normalizeURL).map(async (url, i2, arr) => {\n      if (arr.indexOf(url) !== i2) {\n        return Promise.reject(\"duplicate url\");\n      }\n      let r = await this.ensureRelay(url);\n      return r.publish(event).then((reason) => {\n        if (this.trackRelays) {\n          let set = this.seenOn.get(event.id);\n          if (!set) {\n            set = /* @__PURE__ */ new Set();\n            this.seenOn.set(event.id, set);\n          }\n          set.add(r);\n        }\n        return reason;\n      });\n    });\n  }\n  listConnectionStatus() {\n    const map = /* @__PURE__ */ new Map();\n    this.relays.forEach((relay, url) => map.set(url, relay.connected));\n    return map;\n  }\n  destroy() {\n    this.relays.forEach((conn) => conn.close());\n    this.relays = /* @__PURE__ */ new Map();\n  }\n};\n\n// pool.ts\nvar _WebSocket2;\ntry {\n  _WebSocket2 = WebSocket;\n} catch {\n}\nvar SimplePool = class extends AbstractSimplePool {\n  constructor() {\n    super({ verifyEvent, websocketImplementation: _WebSocket2 });\n  }\n};\n\n// nip19.ts\nvar nip19_exports = {};\n__export(nip19_exports, {\n  BECH32_REGEX: () => BECH32_REGEX,\n  Bech32MaxSize: () => Bech32MaxSize,\n  NostrTypeGuard: () => NostrTypeGuard,\n  decode: () => decode,\n  decodeNostrURI: () => decodeNostrURI,\n  encodeBytes: () => encodeBytes,\n  naddrEncode: () => naddrEncode,\n  neventEncode: () => neventEncode,\n  noteEncode: () => noteEncode,\n  nprofileEncode: () => nprofileEncode,\n  npubEncode: () => npubEncode,\n  nsecEncode: () => nsecEncode\n});\n\n\nvar NostrTypeGuard = {\n  isNProfile: (value) => /^nprofile1[a-z\\d]+$/.test(value || \"\"),\n  isNEvent: (value) => /^nevent1[a-z\\d]+$/.test(value || \"\"),\n  isNAddr: (value) => /^naddr1[a-z\\d]+$/.test(value || \"\"),\n  isNSec: (value) => /^nsec1[a-z\\d]{58}$/.test(value || \"\"),\n  isNPub: (value) => /^npub1[a-z\\d]{58}$/.test(value || \"\"),\n  isNote: (value) => /^note1[a-z\\d]+$/.test(value || \"\"),\n  isNcryptsec: (value) => /^ncryptsec1[a-z\\d]+$/.test(value || \"\")\n};\nvar Bech32MaxSize = 5e3;\nvar BECH32_REGEX = /[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;\nfunction integerToUint8Array(number) {\n  const uint8Array = new Uint8Array(4);\n  uint8Array[0] = number >> 24 & 255;\n  uint8Array[1] = number >> 16 & 255;\n  uint8Array[2] = number >> 8 & 255;\n  uint8Array[3] = number & 255;\n  return uint8Array;\n}\nfunction decodeNostrURI(nip19code) {\n  try {\n    if (nip19code.startsWith(\"nostr:\"))\n      nip19code = nip19code.substring(6);\n    return decode(nip19code);\n  } catch (_err) {\n    return { type: \"invalid\", data: null };\n  }\n}\nfunction decode(nip19) {\n  let { prefix, words } = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.decode(nip19, Bech32MaxSize);\n  let data = new Uint8Array(_scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.fromWords(words));\n  switch (prefix) {\n    case \"nprofile\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nprofile\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      return {\n        type: \"nprofile\",\n        data: {\n          pubkey: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nevent\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nevent\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      if (tlv[2] && tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (tlv[3] && tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"nevent\",\n        data: {\n          id: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],\n          author: tlv[2]?.[0] ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[2][0]) : void 0,\n          kind: tlv[3]?.[0] ? parseInt((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[3][0]), 16) : void 0\n        }\n      };\n    }\n    case \"naddr\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for naddr\");\n      if (!tlv[2]?.[0])\n        throw new Error(\"missing TLV 2 for naddr\");\n      if (tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (!tlv[3]?.[0])\n        throw new Error(\"missing TLV 3 for naddr\");\n      if (tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"naddr\",\n        data: {\n          identifier: utf8Decoder.decode(tlv[0][0]),\n          pubkey: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[2][0]),\n          kind: parseInt((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[3][0]), 16),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nsec\":\n      return { type: prefix, data };\n    case \"npub\":\n    case \"note\":\n      return { type: prefix, data: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(data) };\n    default:\n      throw new Error(`unknown prefix ${prefix}`);\n  }\n}\nfunction parseTLV(data) {\n  let result = {};\n  let rest = data;\n  while (rest.length > 0) {\n    let t = rest[0];\n    let l = rest[1];\n    let v = rest.slice(2, 2 + l);\n    rest = rest.slice(2 + l);\n    if (v.length < l)\n      throw new Error(`not enough data to read on TLV ${t}`);\n    result[t] = result[t] || [];\n    result[t].push(v);\n  }\n  return result;\n}\nfunction nsecEncode(key) {\n  return encodeBytes(\"nsec\", key);\n}\nfunction npubEncode(hex) {\n  return encodeBytes(\"npub\", (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(hex));\n}\nfunction noteEncode(hex) {\n  return encodeBytes(\"note\", (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(hex));\n}\nfunction encodeBech32(prefix, data) {\n  let words = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.toWords(data);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.encode(prefix, words, Bech32MaxSize);\n}\nfunction encodeBytes(prefix, bytes) {\n  return encodeBech32(prefix, bytes);\n}\nfunction nprofileEncode(profile) {\n  let data = encodeTLV({\n    0: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(profile.pubkey)],\n    1: (profile.relays || []).map((url) => utf8Encoder.encode(url))\n  });\n  return encodeBech32(\"nprofile\", data);\n}\nfunction neventEncode(event) {\n  let kindArray;\n  if (event.kind !== void 0) {\n    kindArray = integerToUint8Array(event.kind);\n  }\n  let data = encodeTLV({\n    0: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(event.id)],\n    1: (event.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: event.author ? [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(event.author)] : [],\n    3: kindArray ? [new Uint8Array(kindArray)] : []\n  });\n  return encodeBech32(\"nevent\", data);\n}\nfunction naddrEncode(addr) {\n  let kind = new ArrayBuffer(4);\n  new DataView(kind).setUint32(0, addr.kind, false);\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(addr.identifier)],\n    1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(addr.pubkey)],\n    3: [new Uint8Array(kind)]\n  });\n  return encodeBech32(\"naddr\", data);\n}\nfunction encodeTLV(tlv) {\n  let entries = [];\n  Object.entries(tlv).reverse().forEach(([t, vs]) => {\n    vs.forEach((v) => {\n      let entry = new Uint8Array(v.length + 2);\n      entry.set([parseInt(t)], 0);\n      entry.set([v.length], 1);\n      entry.set(v, 2);\n      entries.push(entry);\n    });\n  });\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...entries);\n}\n\n// references.ts\nvar mentionRegex = /\\bnostr:((note|npub|naddr|nevent|nprofile)1\\w+)\\b|#\\[(\\d+)\\]/g;\nfunction parseReferences(evt) {\n  let references = [];\n  for (let ref of evt.content.matchAll(mentionRegex)) {\n    if (ref[2]) {\n      try {\n        let { type, data } = decode(ref[1]);\n        switch (type) {\n          case \"npub\": {\n            references.push({\n              text: ref[0],\n              profile: { pubkey: data, relays: [] }\n            });\n            break;\n          }\n          case \"nprofile\": {\n            references.push({\n              text: ref[0],\n              profile: data\n            });\n            break;\n          }\n          case \"note\": {\n            references.push({\n              text: ref[0],\n              event: { id: data, relays: [] }\n            });\n            break;\n          }\n          case \"nevent\": {\n            references.push({\n              text: ref[0],\n              event: data\n            });\n            break;\n          }\n          case \"naddr\": {\n            references.push({\n              text: ref[0],\n              address: data\n            });\n            break;\n          }\n        }\n      } catch (err) {\n      }\n    } else if (ref[3]) {\n      let idx = parseInt(ref[3], 10);\n      let tag = evt.tags[idx];\n      if (!tag)\n        continue;\n      switch (tag[0]) {\n        case \"p\": {\n          references.push({\n            text: ref[0],\n            profile: { pubkey: tag[1], relays: tag[2] ? [tag[2]] : [] }\n          });\n          break;\n        }\n        case \"e\": {\n          references.push({\n            text: ref[0],\n            event: { id: tag[1], relays: tag[2] ? [tag[2]] : [] }\n          });\n          break;\n        }\n        case \"a\": {\n          try {\n            let [kind, pubkey, identifier] = tag[1].split(\":\");\n            references.push({\n              text: ref[0],\n              address: {\n                identifier,\n                pubkey,\n                kind: parseInt(kind, 10),\n                relays: tag[2] ? [tag[2]] : []\n              }\n            });\n          } catch (err) {\n          }\n          break;\n        }\n      }\n    }\n  }\n  return references;\n}\n\n// nip04.ts\nvar nip04_exports = {};\n__export(nip04_exports, {\n  decrypt: () => decrypt,\n  encrypt: () => encrypt\n});\n\n\n\n\nfunction encrypt(secretKey, pubkey, text) {\n  const privkey = secretKey instanceof Uint8Array ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(secretKey) : secretKey;\n  const key = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret(privkey, \"02\" + pubkey);\n  const normalizedKey = getNormalizedX(key);\n  let iv = Uint8Array.from((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(16));\n  let plaintext = utf8Encoder.encode(text);\n  let ciphertext = (0,_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_4__.cbc)(normalizedKey, iv).encrypt(plaintext);\n  let ctb64 = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(new Uint8Array(ciphertext));\n  let ivb64 = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(new Uint8Array(iv.buffer));\n  return `${ctb64}?iv=${ivb64}`;\n}\nfunction decrypt(secretKey, pubkey, data) {\n  const privkey = secretKey instanceof Uint8Array ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(secretKey) : secretKey;\n  let [ctb64, ivb64] = data.split(\"?iv=\");\n  let key = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret(privkey, \"02\" + pubkey);\n  let normalizedKey = getNormalizedX(key);\n  let iv = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(ivb64);\n  let ciphertext = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(ctb64);\n  let plaintext = (0,_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_4__.cbc)(normalizedKey, iv).decrypt(ciphertext);\n  return utf8Decoder.decode(plaintext);\n}\nfunction getNormalizedX(key) {\n  return key.slice(1, 33);\n}\n\n// nip05.ts\nvar nip05_exports = {};\n__export(nip05_exports, {\n  NIP05_REGEX: () => NIP05_REGEX,\n  isNip05: () => isNip05,\n  isValid: () => isValid,\n  queryProfile: () => queryProfile,\n  searchDomain: () => searchDomain,\n  useFetchImplementation: () => useFetchImplementation\n});\nvar NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w_-]+(\\.[\\w_-]+)+)$/;\nvar isNip05 = (value) => NIP05_REGEX.test(value || \"\");\nvar _fetch;\ntry {\n  _fetch = fetch;\n} catch (_) {\n  null;\n}\nfunction useFetchImplementation(fetchImplementation) {\n  _fetch = fetchImplementation;\n}\nasync function searchDomain(domain, query = \"\") {\n  try {\n    const url = `https://${domain}/.well-known/nostr.json?name=${query}`;\n    const res = await _fetch(url, { redirect: \"manual\" });\n    if (res.status !== 200) {\n      throw Error(\"Wrong response code\");\n    }\n    const json = await res.json();\n    return json.names;\n  } catch (_) {\n    return {};\n  }\n}\nasync function queryProfile(fullname) {\n  const match = fullname.match(NIP05_REGEX);\n  if (!match)\n    return null;\n  const [, name = \"_\", domain] = match;\n  try {\n    const url = `https://${domain}/.well-known/nostr.json?name=${name}`;\n    const res = await _fetch(url, { redirect: \"manual\" });\n    if (res.status !== 200) {\n      throw Error(\"Wrong response code\");\n    }\n    const json = await res.json();\n    const pubkey = json.names[name];\n    return pubkey ? { pubkey, relays: json.relays?.[pubkey] } : null;\n  } catch (_e) {\n    return null;\n  }\n}\nasync function isValid(pubkey, nip05) {\n  const res = await queryProfile(nip05);\n  return res ? res.pubkey === pubkey : false;\n}\n\n// nip10.ts\nvar nip10_exports = {};\n__export(nip10_exports, {\n  parse: () => parse\n});\nfunction parse(event) {\n  const result = {\n    reply: void 0,\n    root: void 0,\n    mentions: [],\n    profiles: [],\n    quotes: []\n  };\n  let maybeParent;\n  let maybeRoot;\n  for (let i2 = event.tags.length - 1; i2 >= 0; i2--) {\n    const tag = event.tags[i2];\n    if (tag[0] === \"e\" && tag[1]) {\n      const [_, eTagEventId, eTagRelayUrl, eTagMarker, eTagAuthor] = tag;\n      const eventPointer = {\n        id: eTagEventId,\n        relays: eTagRelayUrl ? [eTagRelayUrl] : [],\n        author: eTagAuthor\n      };\n      if (eTagMarker === \"root\") {\n        result.root = eventPointer;\n        continue;\n      }\n      if (eTagMarker === \"reply\") {\n        result.reply = eventPointer;\n        continue;\n      }\n      if (eTagMarker === \"mention\") {\n        result.mentions.push(eventPointer);\n        continue;\n      }\n      if (!maybeParent) {\n        maybeParent = eventPointer;\n      } else {\n        maybeRoot = eventPointer;\n      }\n      result.mentions.push(eventPointer);\n      continue;\n    }\n    if (tag[0] === \"q\" && tag[1]) {\n      const [_, eTagEventId, eTagRelayUrl] = tag;\n      result.quotes.push({\n        id: eTagEventId,\n        relays: eTagRelayUrl ? [eTagRelayUrl] : []\n      });\n    }\n    if (tag[0] === \"p\" && tag[1]) {\n      result.profiles.push({\n        pubkey: tag[1],\n        relays: tag[2] ? [tag[2]] : []\n      });\n      continue;\n    }\n  }\n  if (!result.root) {\n    result.root = maybeRoot || maybeParent || result.reply;\n  }\n  if (!result.reply) {\n    result.reply = maybeParent || result.root;\n  }\n  ;\n  [result.reply, result.root].forEach((ref) => {\n    if (!ref)\n      return;\n    let idx = result.mentions.indexOf(ref);\n    if (idx !== -1) {\n      result.mentions.splice(idx, 1);\n    }\n    if (ref.author) {\n      let author = result.profiles.find((p) => p.pubkey === ref.author);\n      if (author && author.relays) {\n        if (!ref.relays) {\n          ref.relays = [];\n        }\n        author.relays.forEach((url) => {\n          if (ref.relays?.indexOf(url) === -1)\n            ref.relays.push(url);\n        });\n        author.relays = ref.relays;\n      }\n    }\n  });\n  result.mentions.forEach((ref) => {\n    if (ref.author) {\n      let author = result.profiles.find((p) => p.pubkey === ref.author);\n      if (author && author.relays) {\n        if (!ref.relays) {\n          ref.relays = [];\n        }\n        author.relays.forEach((url) => {\n          if (ref.relays.indexOf(url) === -1)\n            ref.relays.push(url);\n        });\n        author.relays = ref.relays;\n      }\n    }\n  });\n  return result;\n}\n\n// nip11.ts\nvar nip11_exports = {};\n__export(nip11_exports, {\n  fetchRelayInformation: () => fetchRelayInformation,\n  useFetchImplementation: () => useFetchImplementation2\n});\nvar _fetch2;\ntry {\n  _fetch2 = fetch;\n} catch {\n}\nfunction useFetchImplementation2(fetchImplementation) {\n  _fetch2 = fetchImplementation;\n}\nasync function fetchRelayInformation(url) {\n  return await (await fetch(url.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\"), {\n    headers: { Accept: \"application/nostr+json\" }\n  })).json();\n}\n\n// nip13.ts\nvar nip13_exports = {};\n__export(nip13_exports, {\n  fastEventHash: () => fastEventHash,\n  getPow: () => getPow,\n  minePow: () => minePow\n});\n\n\nfunction getPow(hex) {\n  let count = 0;\n  for (let i2 = 0; i2 < 64; i2 += 8) {\n    const nibble = parseInt(hex.substring(i2, i2 + 8), 16);\n    if (nibble === 0) {\n      count += 32;\n    } else {\n      count += Math.clz32(nibble);\n      break;\n    }\n  }\n  return count;\n}\nfunction minePow(unsigned, difficulty) {\n  let count = 0;\n  const event = unsigned;\n  const tag = [\"nonce\", count.toString(), difficulty.toString()];\n  event.tags.push(tag);\n  while (true) {\n    const now2 = Math.floor(new Date().getTime() / 1e3);\n    if (now2 !== event.created_at) {\n      count = 0;\n      event.created_at = now2;\n    }\n    tag[1] = (++count).toString();\n    event.id = fastEventHash(event);\n    if (getPow(event.id) >= difficulty) {\n      break;\n    }\n  }\n  return event;\n}\nfunction fastEventHash(evt) {\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(\n    (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content])))\n  );\n}\n\n// nip17.ts\nvar nip17_exports = {};\n__export(nip17_exports, {\n  unwrapEvent: () => unwrapEvent2,\n  unwrapManyEvents: () => unwrapManyEvents2,\n  wrapEvent: () => wrapEvent2,\n  wrapManyEvents: () => wrapManyEvents2\n});\n\n// nip59.ts\nvar nip59_exports = {};\n__export(nip59_exports, {\n  createRumor: () => createRumor,\n  createSeal: () => createSeal,\n  createWrap: () => createWrap,\n  unwrapEvent: () => unwrapEvent,\n  unwrapManyEvents: () => unwrapManyEvents,\n  wrapEvent: () => wrapEvent,\n  wrapManyEvents: () => wrapManyEvents\n});\n\n// nip44.ts\nvar nip44_exports = {};\n__export(nip44_exports, {\n  decrypt: () => decrypt2,\n  encrypt: () => encrypt2,\n  getConversationKey: () => getConversationKey,\n  v2: () => v2\n});\n\n\n\n\n\n\n\n\nvar minPlaintextSize = 1;\nvar maxPlaintextSize = 65535;\nfunction getConversationKey(privkeyA, pubkeyB) {\n  const sharedX = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret(privkeyA, \"02\" + pubkeyB).subarray(1, 33);\n  return (0,_noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_5__.extract)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, sharedX, \"nip44-v2\");\n}\nfunction getMessageKeys(conversationKey, nonce) {\n  const keys = (0,_noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_5__.expand)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, conversationKey, nonce, 76);\n  return {\n    chacha_key: keys.subarray(0, 32),\n    chacha_nonce: keys.subarray(32, 44),\n    hmac_key: keys.subarray(44, 76)\n  };\n}\nfunction calcPaddedLen(len) {\n  if (!Number.isSafeInteger(len) || len < 1)\n    throw new Error(\"expected positive integer\");\n  if (len <= 32)\n    return 32;\n  const nextPower = 1 << Math.floor(Math.log2(len - 1)) + 1;\n  const chunk = nextPower <= 256 ? 32 : nextPower / 8;\n  return chunk * (Math.floor((len - 1) / chunk) + 1);\n}\nfunction writeU16BE(num) {\n  if (!Number.isSafeInteger(num) || num < minPlaintextSize || num > maxPlaintextSize)\n    throw new Error(\"invalid plaintext size: must be between 1 and 65535 bytes\");\n  const arr = new Uint8Array(2);\n  new DataView(arr.buffer).setUint16(0, num, false);\n  return arr;\n}\nfunction pad(plaintext) {\n  const unpadded = utf8Encoder.encode(plaintext);\n  const unpaddedLen = unpadded.length;\n  const prefix = writeU16BE(unpaddedLen);\n  const suffix = new Uint8Array(calcPaddedLen(unpaddedLen) - unpaddedLen);\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(prefix, unpadded, suffix);\n}\nfunction unpad(padded) {\n  const unpaddedLen = new DataView(padded.buffer).getUint16(0);\n  const unpadded = padded.subarray(2, 2 + unpaddedLen);\n  if (unpaddedLen < minPlaintextSize || unpaddedLen > maxPlaintextSize || unpadded.length !== unpaddedLen || padded.length !== 2 + calcPaddedLen(unpaddedLen))\n    throw new Error(\"invalid padding\");\n  return utf8Decoder.decode(unpadded);\n}\nfunction hmacAad(key, message, aad) {\n  if (aad.length !== 32)\n    throw new Error(\"AAD associated data must be 32 bytes\");\n  const combined = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(aad, message);\n  return (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_6__.hmac)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, key, combined);\n}\nfunction decodePayload(payload) {\n  if (typeof payload !== \"string\")\n    throw new Error(\"payload must be a valid string\");\n  const plen = payload.length;\n  if (plen < 132 || plen > 87472)\n    throw new Error(\"invalid payload length: \" + plen);\n  if (payload[0] === \"#\")\n    throw new Error(\"unknown encryption version\");\n  let data;\n  try {\n    data = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(payload);\n  } catch (error) {\n    throw new Error(\"invalid base64: \" + error.message);\n  }\n  const dlen = data.length;\n  if (dlen < 99 || dlen > 65603)\n    throw new Error(\"invalid data length: \" + dlen);\n  const vers = data[0];\n  if (vers !== 2)\n    throw new Error(\"unknown encryption version \" + vers);\n  return {\n    nonce: data.subarray(1, 33),\n    ciphertext: data.subarray(33, -32),\n    mac: data.subarray(-32)\n  };\n}\nfunction encrypt2(plaintext, conversationKey, nonce = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(32)) {\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);\n  const padded = pad(plaintext);\n  const ciphertext = (0,_noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__.chacha20)(chacha_key, chacha_nonce, padded);\n  const mac = hmacAad(hmac_key, ciphertext, nonce);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(new Uint8Array([2]), nonce, ciphertext, mac));\n}\nfunction decrypt2(payload, conversationKey) {\n  const { nonce, ciphertext, mac } = decodePayload(payload);\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);\n  const calculatedMac = hmacAad(hmac_key, ciphertext, nonce);\n  if (!(0,_noble_ciphers_utils__WEBPACK_IMPORTED_MODULE_8__.equalBytes)(calculatedMac, mac))\n    throw new Error(\"invalid MAC\");\n  const padded = (0,_noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__.chacha20)(chacha_key, chacha_nonce, ciphertext);\n  return unpad(padded);\n}\nvar v2 = {\n  utils: {\n    getConversationKey,\n    calcPaddedLen\n  },\n  encrypt: encrypt2,\n  decrypt: decrypt2\n};\n\n// nip59.ts\nvar TWO_DAYS = 2 * 24 * 60 * 60;\nvar now = () => Math.round(Date.now() / 1e3);\nvar randomNow = () => Math.round(now() - Math.random() * TWO_DAYS);\nvar nip44ConversationKey = (privateKey, publicKey) => getConversationKey(privateKey, publicKey);\nvar nip44Encrypt = (data, privateKey, publicKey) => encrypt2(JSON.stringify(data), nip44ConversationKey(privateKey, publicKey));\nvar nip44Decrypt = (data, privateKey) => JSON.parse(decrypt2(data.content, nip44ConversationKey(privateKey, data.pubkey)));\nfunction createRumor(event, privateKey) {\n  const rumor = {\n    created_at: now(),\n    content: \"\",\n    tags: [],\n    ...event,\n    pubkey: getPublicKey(privateKey)\n  };\n  rumor.id = getEventHash(rumor);\n  return rumor;\n}\nfunction createSeal(rumor, privateKey, recipientPublicKey) {\n  return finalizeEvent(\n    {\n      kind: Seal,\n      content: nip44Encrypt(rumor, privateKey, recipientPublicKey),\n      created_at: randomNow(),\n      tags: []\n    },\n    privateKey\n  );\n}\nfunction createWrap(seal, recipientPublicKey) {\n  const randomKey = generateSecretKey();\n  return finalizeEvent(\n    {\n      kind: GiftWrap,\n      content: nip44Encrypt(seal, randomKey, recipientPublicKey),\n      created_at: randomNow(),\n      tags: [[\"p\", recipientPublicKey]]\n    },\n    randomKey\n  );\n}\nfunction wrapEvent(event, senderPrivateKey, recipientPublicKey) {\n  const rumor = createRumor(event, senderPrivateKey);\n  const seal = createSeal(rumor, senderPrivateKey, recipientPublicKey);\n  return createWrap(seal, recipientPublicKey);\n}\nfunction wrapManyEvents(event, senderPrivateKey, recipientsPublicKeys) {\n  if (!recipientsPublicKeys || recipientsPublicKeys.length === 0) {\n    throw new Error(\"At least one recipient is required.\");\n  }\n  const senderPublicKey = getPublicKey(senderPrivateKey);\n  const wrappeds = [wrapEvent(event, senderPrivateKey, senderPublicKey)];\n  recipientsPublicKeys.forEach((recipientPublicKey) => {\n    wrappeds.push(wrapEvent(event, senderPrivateKey, recipientPublicKey));\n  });\n  return wrappeds;\n}\nfunction unwrapEvent(wrap, recipientPrivateKey) {\n  const unwrappedSeal = nip44Decrypt(wrap, recipientPrivateKey);\n  return nip44Decrypt(unwrappedSeal, recipientPrivateKey);\n}\nfunction unwrapManyEvents(wrappedEvents, recipientPrivateKey) {\n  let unwrappedEvents = [];\n  wrappedEvents.forEach((e) => {\n    unwrappedEvents.push(unwrapEvent(e, recipientPrivateKey));\n  });\n  unwrappedEvents.sort((a, b) => a.created_at - b.created_at);\n  return unwrappedEvents;\n}\n\n// nip17.ts\nfunction createEvent(recipients, message, conversationTitle, replyTo) {\n  const baseEvent = {\n    created_at: Math.ceil(Date.now() / 1e3),\n    kind: PrivateDirectMessage,\n    tags: [],\n    content: message\n  };\n  const recipientsArray = Array.isArray(recipients) ? recipients : [recipients];\n  recipientsArray.forEach(({ publicKey, relayUrl }) => {\n    baseEvent.tags.push(relayUrl ? [\"p\", publicKey, relayUrl] : [\"p\", publicKey]);\n  });\n  if (replyTo) {\n    baseEvent.tags.push([\"e\", replyTo.eventId, replyTo.relayUrl || \"\", \"reply\"]);\n  }\n  if (conversationTitle) {\n    baseEvent.tags.push([\"subject\", conversationTitle]);\n  }\n  return baseEvent;\n}\nfunction wrapEvent2(senderPrivateKey, recipient, message, conversationTitle, replyTo) {\n  const event = createEvent(recipient, message, conversationTitle, replyTo);\n  return wrapEvent(event, senderPrivateKey, recipient.publicKey);\n}\nfunction wrapManyEvents2(senderPrivateKey, recipients, message, conversationTitle, replyTo) {\n  if (!recipients || recipients.length === 0) {\n    throw new Error(\"At least one recipient is required.\");\n  }\n  const senderPublicKey = getPublicKey(senderPrivateKey);\n  return [{ publicKey: senderPublicKey }, ...recipients].map(\n    (recipient) => wrapEvent2(senderPrivateKey, recipient, message, conversationTitle, replyTo)\n  );\n}\nvar unwrapEvent2 = unwrapEvent;\nvar unwrapManyEvents2 = unwrapManyEvents;\n\n// nip18.ts\nvar nip18_exports = {};\n__export(nip18_exports, {\n  finishRepostEvent: () => finishRepostEvent,\n  getRepostedEvent: () => getRepostedEvent,\n  getRepostedEventPointer: () => getRepostedEventPointer\n});\nfunction finishRepostEvent(t, reposted, relayUrl, privateKey) {\n  let kind;\n  const tags = [...t.tags ?? [], [\"e\", reposted.id, relayUrl], [\"p\", reposted.pubkey]];\n  if (reposted.kind === ShortTextNote) {\n    kind = Repost;\n  } else {\n    kind = GenericRepost;\n    tags.push([\"k\", String(reposted.kind)]);\n  }\n  return finalizeEvent(\n    {\n      kind,\n      tags,\n      content: t.content === \"\" || reposted.tags?.find((tag) => tag[0] === \"-\") ? \"\" : JSON.stringify(reposted),\n      created_at: t.created_at\n    },\n    privateKey\n  );\n}\nfunction getRepostedEventPointer(event) {\n  if (![Repost, GenericRepost].includes(event.kind)) {\n    return void 0;\n  }\n  let lastETag;\n  let lastPTag;\n  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {\n    const tag = event.tags[i2];\n    if (tag.length >= 2) {\n      if (tag[0] === \"e\" && lastETag === void 0) {\n        lastETag = tag;\n      } else if (tag[0] === \"p\" && lastPTag === void 0) {\n        lastPTag = tag;\n      }\n    }\n  }\n  if (lastETag === void 0) {\n    return void 0;\n  }\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag?.[2]].filter((x) => typeof x === \"string\"),\n    author: lastPTag?.[1]\n  };\n}\nfunction getRepostedEvent(event, { skipVerification } = {}) {\n  const pointer = getRepostedEventPointer(event);\n  if (pointer === void 0 || event.content === \"\") {\n    return void 0;\n  }\n  let repostedEvent;\n  try {\n    repostedEvent = JSON.parse(event.content);\n  } catch (error) {\n    return void 0;\n  }\n  if (repostedEvent.id !== pointer.id) {\n    return void 0;\n  }\n  if (!skipVerification && !verifyEvent(repostedEvent)) {\n    return void 0;\n  }\n  return repostedEvent;\n}\n\n// nip21.ts\nvar nip21_exports = {};\n__export(nip21_exports, {\n  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,\n  parse: () => parse2,\n  test: () => test\n});\nvar NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);\nfunction test(value) {\n  return typeof value === \"string\" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(value);\n}\nfunction parse2(uri) {\n  const match = uri.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));\n  if (!match)\n    throw new Error(`Invalid Nostr URI: ${uri}`);\n  return {\n    uri: match[0],\n    value: match[1],\n    decoded: decode(match[1])\n  };\n}\n\n// nip25.ts\nvar nip25_exports = {};\n__export(nip25_exports, {\n  finishReactionEvent: () => finishReactionEvent,\n  getReactedEventPointer: () => getReactedEventPointer\n});\nfunction finishReactionEvent(t, reacted, privateKey) {\n  const inheritedTags = reacted.tags.filter((tag) => tag.length >= 2 && (tag[0] === \"e\" || tag[0] === \"p\"));\n  return finalizeEvent(\n    {\n      ...t,\n      kind: Reaction,\n      tags: [...t.tags ?? [], ...inheritedTags, [\"e\", reacted.id], [\"p\", reacted.pubkey]],\n      content: t.content ?? \"+\"\n    },\n    privateKey\n  );\n}\nfunction getReactedEventPointer(event) {\n  if (event.kind !== Reaction) {\n    return void 0;\n  }\n  let lastETag;\n  let lastPTag;\n  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {\n    const tag = event.tags[i2];\n    if (tag.length >= 2) {\n      if (tag[0] === \"e\" && lastETag === void 0) {\n        lastETag = tag;\n      } else if (tag[0] === \"p\" && lastPTag === void 0) {\n        lastPTag = tag;\n      }\n    }\n  }\n  if (lastETag === void 0 || lastPTag === void 0) {\n    return void 0;\n  }\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag[2]].filter((x) => x !== void 0),\n    author: lastPTag[1]\n  };\n}\n\n// nip27.ts\nvar nip27_exports = {};\n__export(nip27_exports, {\n  parse: () => parse3\n});\nvar noCharacter = /\\W/m;\nvar noURLCharacter = /\\W |\\W$|$|,| /m;\nfunction* parse3(content) {\n  const max = content.length;\n  let prevIndex = 0;\n  let index = 0;\n  while (index < max) {\n    let u = content.indexOf(\":\", index);\n    if (u === -1) {\n      break;\n    }\n    if (content.substring(u - 5, u) === \"nostr\") {\n      const m = content.substring(u + 60).match(noCharacter);\n      const end = m ? u + 60 + m.index : max;\n      try {\n        let pointer;\n        let { data, type } = decode(content.substring(u + 1, end));\n        switch (type) {\n          case \"npub\":\n            pointer = { pubkey: data };\n            break;\n          case \"nsec\":\n          case \"note\":\n            index = end + 1;\n            continue;\n          default:\n            pointer = data;\n        }\n        if (prevIndex !== u - 5) {\n          yield { type: \"text\", text: content.substring(prevIndex, u - 5) };\n        }\n        yield { type: \"reference\", pointer };\n        index = end;\n        prevIndex = index;\n        continue;\n      } catch (_err) {\n        index = u + 1;\n        continue;\n      }\n    } else if (content.substring(u - 5, u) === \"https\" || content.substring(u - 4, u) === \"http\") {\n      const m = content.substring(u + 4).match(noURLCharacter);\n      const end = m ? u + 4 + m.index : max;\n      const prefixLen = content[u - 1] === \"s\" ? 5 : 4;\n      try {\n        let url = new URL(content.substring(u - prefixLen, end));\n        if (url.hostname.indexOf(\".\") === -1) {\n          throw new Error(\"invalid url\");\n        }\n        if (prevIndex !== u - prefixLen) {\n          yield { type: \"text\", text: content.substring(prevIndex, u - prefixLen) };\n        }\n        if (url.pathname.endsWith(\".png\") || url.pathname.endsWith(\".jpg\") || url.pathname.endsWith(\".jpeg\") || url.pathname.endsWith(\".gif\") || url.pathname.endsWith(\".webp\")) {\n          yield { type: \"image\", url: url.toString() };\n          index = end;\n          prevIndex = index;\n          continue;\n        }\n        if (url.pathname.endsWith(\".mp4\") || url.pathname.endsWith(\".avi\") || url.pathname.endsWith(\".webm\") || url.pathname.endsWith(\".mkv\")) {\n          yield { type: \"video\", url: url.toString() };\n          index = end;\n          prevIndex = index;\n          continue;\n        }\n        if (url.pathname.endsWith(\".mp3\") || url.pathname.endsWith(\".aac\") || url.pathname.endsWith(\".ogg\") || url.pathname.endsWith(\".opus\")) {\n          yield { type: \"audio\", url: url.toString() };\n          index = end;\n          prevIndex = index;\n          continue;\n        }\n        yield { type: \"url\", url: url.toString() };\n        index = end;\n        prevIndex = index;\n        continue;\n      } catch (_err) {\n        index = end + 1;\n        continue;\n      }\n    } else if (content.substring(u - 3, u) === \"wss\" || content.substring(u - 2, u) === \"ws\") {\n      const m = content.substring(u + 4).match(noURLCharacter);\n      const end = m ? u + 4 + m.index : max;\n      const prefixLen = content[u - 1] === \"s\" ? 3 : 2;\n      try {\n        let url = new URL(content.substring(u - prefixLen, end));\n        if (url.hostname.indexOf(\".\") === -1) {\n          throw new Error(\"invalid ws url\");\n        }\n        if (prevIndex !== u - prefixLen) {\n          yield { type: \"text\", text: content.substring(prevIndex, u - prefixLen) };\n        }\n        yield { type: \"relay\", url: url.toString() };\n        index = end;\n        prevIndex = index;\n        continue;\n      } catch (_err) {\n        index = end + 1;\n        continue;\n      }\n    } else {\n      index = u + 1;\n      continue;\n    }\n  }\n  if (prevIndex !== max) {\n    yield { type: \"text\", text: content.substring(prevIndex) };\n  }\n}\n\n// nip28.ts\nvar nip28_exports = {};\n__export(nip28_exports, {\n  channelCreateEvent: () => channelCreateEvent,\n  channelHideMessageEvent: () => channelHideMessageEvent,\n  channelMessageEvent: () => channelMessageEvent,\n  channelMetadataEvent: () => channelMetadataEvent,\n  channelMuteUserEvent: () => channelMuteUserEvent\n});\nvar channelCreateEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelCreation,\n      tags: [...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMetadataEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMetadata,\n      tags: [[\"e\", t.channel_create_event_id], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMessageEvent = (t, privateKey) => {\n  const tags = [[\"e\", t.channel_create_event_id, t.relay_url, \"root\"]];\n  if (t.reply_to_channel_message_event_id) {\n    tags.push([\"e\", t.reply_to_channel_message_event_id, t.relay_url, \"reply\"]);\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMessage,\n      tags: [...tags, ...t.tags ?? []],\n      content: t.content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelHideMessageEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelHideMessage,\n      tags: [[\"e\", t.channel_message_event_id], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMuteUserEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMuteUser,\n      tags: [[\"p\", t.pubkey_to_mute], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\n\n// nip30.ts\nvar nip30_exports = {};\n__export(nip30_exports, {\n  EMOJI_SHORTCODE_REGEX: () => EMOJI_SHORTCODE_REGEX,\n  matchAll: () => matchAll,\n  regex: () => regex,\n  replaceAll: () => replaceAll\n});\nvar EMOJI_SHORTCODE_REGEX = /:(\\w+):/;\nvar regex = () => new RegExp(`\\\\B${EMOJI_SHORTCODE_REGEX.source}\\\\B`, \"g\");\nfunction* matchAll(content) {\n  const matches = content.matchAll(regex());\n  for (const match of matches) {\n    try {\n      const [shortcode, name] = match;\n      yield {\n        shortcode,\n        name,\n        start: match.index,\n        end: match.index + shortcode.length\n      };\n    } catch (_e) {\n    }\n  }\n}\nfunction replaceAll(content, replacer) {\n  return content.replaceAll(regex(), (shortcode, name) => {\n    return replacer({\n      shortcode,\n      name\n    });\n  });\n}\n\n// nip39.ts\nvar nip39_exports = {};\n__export(nip39_exports, {\n  useFetchImplementation: () => useFetchImplementation3,\n  validateGithub: () => validateGithub\n});\nvar _fetch3;\ntry {\n  _fetch3 = fetch;\n} catch {\n}\nfunction useFetchImplementation3(fetchImplementation) {\n  _fetch3 = fetchImplementation;\n}\nasync function validateGithub(pubkey, username, proof) {\n  try {\n    let res = await (await _fetch3(`https://gist.github.com/${username}/${proof}/raw`)).text();\n    return res === `Verifying that I control the following Nostr public key: ${pubkey}`;\n  } catch (_) {\n    return false;\n  }\n}\n\n// nip47.ts\nvar nip47_exports = {};\n__export(nip47_exports, {\n  makeNwcRequestEvent: () => makeNwcRequestEvent,\n  parseConnectionString: () => parseConnectionString\n});\nfunction parseConnectionString(connectionString) {\n  const { pathname, searchParams } = new URL(connectionString);\n  const pubkey = pathname;\n  const relay = searchParams.get(\"relay\");\n  const secret = searchParams.get(\"secret\");\n  if (!pubkey || !relay || !secret) {\n    throw new Error(\"invalid connection string\");\n  }\n  return { pubkey, relay, secret };\n}\nasync function makeNwcRequestEvent(pubkey, secretKey, invoice) {\n  const content = {\n    method: \"pay_invoice\",\n    params: {\n      invoice\n    }\n  };\n  const encryptedContent = await encrypt(secretKey, pubkey, JSON.stringify(content));\n  const eventTemplate = {\n    kind: NWCWalletRequest,\n    created_at: Math.round(Date.now() / 1e3),\n    content: encryptedContent,\n    tags: [[\"p\", pubkey]]\n  };\n  return finalizeEvent(eventTemplate, secretKey);\n}\n\n// nip54.ts\nvar nip54_exports = {};\n__export(nip54_exports, {\n  normalizeIdentifier: () => normalizeIdentifier\n});\nfunction normalizeIdentifier(name) {\n  name = name.trim().toLowerCase();\n  name = name.normalize(\"NFKC\");\n  return Array.from(name).map((char) => {\n    if (/\\p{Letter}/u.test(char) || /\\p{Number}/u.test(char)) {\n      return char;\n    }\n    return \"-\";\n  }).join(\"\");\n}\n\n// nip57.ts\nvar nip57_exports = {};\n__export(nip57_exports, {\n  getZapEndpoint: () => getZapEndpoint,\n  makeZapReceipt: () => makeZapReceipt,\n  makeZapRequest: () => makeZapRequest,\n  useFetchImplementation: () => useFetchImplementation4,\n  validateZapRequest: () => validateZapRequest\n});\n\nvar _fetch4;\ntry {\n  _fetch4 = fetch;\n} catch {\n}\nfunction useFetchImplementation4(fetchImplementation) {\n  _fetch4 = fetchImplementation;\n}\nasync function getZapEndpoint(metadata) {\n  try {\n    let lnurl = \"\";\n    let { lud06, lud16 } = JSON.parse(metadata.content);\n    if (lud06) {\n      let { words } = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.decode(lud06, 1e3);\n      let data = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.fromWords(words);\n      lnurl = utf8Decoder.decode(data);\n    } else if (lud16) {\n      let [name, domain] = lud16.split(\"@\");\n      lnurl = new URL(`/.well-known/lnurlp/${name}`, `https://${domain}`).toString();\n    } else {\n      return null;\n    }\n    let res = await _fetch4(lnurl);\n    let body = await res.json();\n    if (body.allowsNostr && body.nostrPubkey) {\n      return body.callback;\n    }\n  } catch (err) {\n  }\n  return null;\n}\nfunction makeZapRequest({\n  profile,\n  event,\n  amount,\n  relays,\n  comment = \"\"\n}) {\n  if (!amount)\n    throw new Error(\"amount not given\");\n  if (!profile)\n    throw new Error(\"profile not given\");\n  let zr = {\n    kind: 9734,\n    created_at: Math.round(Date.now() / 1e3),\n    content: comment,\n    tags: [\n      [\"p\", profile],\n      [\"amount\", amount.toString()],\n      [\"relays\", ...relays]\n    ]\n  };\n  if (event && typeof event === \"string\") {\n    zr.tags.push([\"e\", event]);\n  }\n  if (event && typeof event === \"object\") {\n    if (isReplaceableKind(event.kind)) {\n      const a = [\"a\", `${event.kind}:${event.pubkey}:`];\n      zr.tags.push(a);\n    } else if (isAddressableKind(event.kind)) {\n      let d = event.tags.find(([t, v]) => t === \"d\" && v);\n      if (!d)\n        throw new Error(\"d tag not found or is empty\");\n      const a = [\"a\", `${event.kind}:${event.pubkey}:${d[1]}`];\n      zr.tags.push(a);\n    }\n  }\n  return zr;\n}\nfunction validateZapRequest(zapRequestString) {\n  let zapRequest;\n  try {\n    zapRequest = JSON.parse(zapRequestString);\n  } catch (err) {\n    return \"Invalid zap request JSON.\";\n  }\n  if (!validateEvent(zapRequest))\n    return \"Zap request is not a valid Nostr event.\";\n  if (!verifyEvent(zapRequest))\n    return \"Invalid signature on zap request.\";\n  let p = zapRequest.tags.find(([t, v]) => t === \"p\" && v);\n  if (!p)\n    return \"Zap request doesn't have a 'p' tag.\";\n  if (!p[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'p' tag is not valid hex.\";\n  let e = zapRequest.tags.find(([t, v]) => t === \"e\" && v);\n  if (e && !e[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'e' tag is not valid hex.\";\n  let relays = zapRequest.tags.find(([t, v]) => t === \"relays\" && v);\n  if (!relays)\n    return \"Zap request doesn't have a 'relays' tag.\";\n  return null;\n}\nfunction makeZapReceipt({\n  zapRequest,\n  preimage,\n  bolt11,\n  paidAt\n}) {\n  let zr = JSON.parse(zapRequest);\n  let tagsFromZapRequest = zr.tags.filter(([t]) => t === \"e\" || t === \"p\" || t === \"a\");\n  let zap = {\n    kind: 9735,\n    created_at: Math.round(paidAt.getTime() / 1e3),\n    content: \"\",\n    tags: [...tagsFromZapRequest, [\"P\", zr.pubkey], [\"bolt11\", bolt11], [\"description\", zapRequest]]\n  };\n  if (preimage) {\n    zap.tags.push([\"preimage\", preimage]);\n  }\n  return zap;\n}\n\n// nip98.ts\nvar nip98_exports = {};\n__export(nip98_exports, {\n  getToken: () => getToken,\n  hashPayload: () => hashPayload,\n  unpackEventFromToken: () => unpackEventFromToken,\n  validateEvent: () => validateEvent2,\n  validateEventKind: () => validateEventKind,\n  validateEventMethodTag: () => validateEventMethodTag,\n  validateEventPayloadTag: () => validateEventPayloadTag,\n  validateEventTimestamp: () => validateEventTimestamp,\n  validateEventUrlTag: () => validateEventUrlTag,\n  validateToken: () => validateToken\n});\n\n\n\nvar _authorizationScheme = \"Nostr \";\nasync function getToken(loginUrl, httpMethod, sign, includeAuthorizationScheme = false, payload) {\n  const event = {\n    kind: HTTPAuth,\n    tags: [\n      [\"u\", loginUrl],\n      [\"method\", httpMethod]\n    ],\n    created_at: Math.round(new Date().getTime() / 1e3),\n    content: \"\"\n  };\n  if (payload) {\n    event.tags.push([\"payload\", hashPayload(payload)]);\n  }\n  const signedEvent = await sign(event);\n  const authorizationScheme = includeAuthorizationScheme ? _authorizationScheme : \"\";\n  return authorizationScheme + _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(utf8Encoder.encode(JSON.stringify(signedEvent)));\n}\nasync function validateToken(token, url, method) {\n  const event = await unpackEventFromToken(token).catch((error) => {\n    throw error;\n  });\n  const valid = await validateEvent2(event, url, method).catch((error) => {\n    throw error;\n  });\n  return valid;\n}\nasync function unpackEventFromToken(token) {\n  if (!token) {\n    throw new Error(\"Missing token\");\n  }\n  token = token.replace(_authorizationScheme, \"\");\n  const eventB64 = utf8Decoder.decode(_scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(token));\n  if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith(\"{\")) {\n    throw new Error(\"Invalid token\");\n  }\n  const event = JSON.parse(eventB64);\n  return event;\n}\nfunction validateEventTimestamp(event) {\n  if (!event.created_at) {\n    return false;\n  }\n  return Math.round(new Date().getTime() / 1e3) - event.created_at < 60;\n}\nfunction validateEventKind(event) {\n  return event.kind === HTTPAuth;\n}\nfunction validateEventUrlTag(event, url) {\n  const urlTag = event.tags.find((t) => t[0] === \"u\");\n  if (!urlTag) {\n    return false;\n  }\n  return urlTag.length > 0 && urlTag[1] === url;\n}\nfunction validateEventMethodTag(event, method) {\n  const methodTag = event.tags.find((t) => t[0] === \"method\");\n  if (!methodTag) {\n    return false;\n  }\n  return methodTag.length > 0 && methodTag[1].toLowerCase() === method.toLowerCase();\n}\nfunction hashPayload(payload) {\n  const hash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(JSON.stringify(payload)));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(hash);\n}\nfunction validateEventPayloadTag(event, payload) {\n  const payloadTag = event.tags.find((t) => t[0] === \"payload\");\n  if (!payloadTag) {\n    return false;\n  }\n  const payloadHash = hashPayload(payload);\n  return payloadTag.length > 0 && payloadTag[1] === payloadHash;\n}\nasync function validateEvent2(event, url, method, body) {\n  if (!verifyEvent(event)) {\n    throw new Error(\"Invalid nostr event, signature invalid\");\n  }\n  if (!validateEventKind(event)) {\n    throw new Error(\"Invalid nostr event, kind invalid\");\n  }\n  if (!validateEventTimestamp(event)) {\n    throw new Error(\"Invalid nostr event, created_at timestamp invalid\");\n  }\n  if (!validateEventUrlTag(event, url)) {\n    throw new Error(\"Invalid nostr event, url tag invalid\");\n  }\n  if (!validateEventMethodTag(event, method)) {\n    throw new Error(\"Invalid nostr event, method tag invalid\");\n  }\n  if (Boolean(body) && typeof body === \"object\" && Object.keys(body).length > 0) {\n    if (!validateEventPayloadTag(event, body)) {\n      throw new Error(\"Invalid nostr event, payload tag does not match request body hash\");\n    }\n  }\n  return true;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ2tEO0FBQ0Q7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsR0FBRztBQUN4QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQzhDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDREQUFPO0FBQ2xCO0FBQ0E7QUFDQSxXQUFXLCtEQUFVLENBQUMsNERBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtEQUFVLENBQUMsNERBQU87QUFDckM7QUFDQSxnQkFBZ0IsK0RBQVUsQ0FBQyw0REFBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNERBQU87QUFDM0I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDREQUFNO0FBQ3hCLFNBQVMsK0RBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVMsSUFBSSxJQUFJO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw0Q0FBNEMsMEJBQTBCO0FBQ3RFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsbUNBQW1DLDZCQUE2QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMENFIiwic291cmNlcyI6WyIvVXNlcnMvcGFibG9mZXJuYW5kZXovdGVzdDEyMy9URU5FWC1wZmttYzkvbWFpbi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9saWIvZXNtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHB1cmUudHNcbmltcG9ydCB7IHNjaG5vcnIgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGJ5dGVzVG9IZXggfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuXG4vLyBjb3JlLnRzXG52YXIgdmVyaWZpZWRTeW1ib2wgPSBTeW1ib2woXCJ2ZXJpZmllZFwiKTtcbnZhciBpc1JlY29yZCA9IChvYmopID0+IG9iaiBpbnN0YW5jZW9mIE9iamVjdDtcbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnQoZXZlbnQpIHtcbiAgaWYgKCFpc1JlY29yZChldmVudCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LmtpbmQgIT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LmNvbnRlbnQgIT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LmNyZWF0ZWRfYXQgIT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LnB1YmtleSAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICghZXZlbnQucHVia2V5Lm1hdGNoKC9eW2EtZjAtOV17NjR9JC8pKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV2ZW50LnRhZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGV2ZW50LnRhZ3MubGVuZ3RoOyBpMisrKSB7XG4gICAgbGV0IHRhZyA9IGV2ZW50LnRhZ3NbaTJdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWcpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFnLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAodHlwZW9mIHRhZ1tqXSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNvcnRFdmVudHMoZXZlbnRzKSB7XG4gIHJldHVybiBldmVudHMuc29ydCgoYSwgYikgPT4ge1xuICAgIGlmIChhLmNyZWF0ZWRfYXQgIT09IGIuY3JlYXRlZF9hdCkge1xuICAgICAgcmV0dXJuIGIuY3JlYXRlZF9hdCAtIGEuY3JlYXRlZF9hdDtcbiAgICB9XG4gICAgcmV0dXJuIGEuaWQubG9jYWxlQ29tcGFyZShiLmlkKTtcbiAgfSk7XG59XG5cbi8vIHB1cmUudHNcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiO1xuXG4vLyB1dGlscy50c1xudmFyIHV0aWxzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHV0aWxzX2V4cG9ydHMsIHtcbiAgUXVldWU6ICgpID0+IFF1ZXVlLFxuICBRdWV1ZU5vZGU6ICgpID0+IFF1ZXVlTm9kZSxcbiAgYmluYXJ5U2VhcmNoOiAoKSA9PiBiaW5hcnlTZWFyY2gsXG4gIGluc2VydEV2ZW50SW50b0FzY2VuZGluZ0xpc3Q6ICgpID0+IGluc2VydEV2ZW50SW50b0FzY2VuZGluZ0xpc3QsXG4gIGluc2VydEV2ZW50SW50b0Rlc2NlbmRpbmdMaXN0OiAoKSA9PiBpbnNlcnRFdmVudEludG9EZXNjZW5kaW5nTGlzdCxcbiAgbm9ybWFsaXplVVJMOiAoKSA9PiBub3JtYWxpemVVUkwsXG4gIHV0ZjhEZWNvZGVyOiAoKSA9PiB1dGY4RGVjb2RlcixcbiAgdXRmOEVuY29kZXI6ICgpID0+IHV0ZjhFbmNvZGVyXG59KTtcbnZhciB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xudmFyIHV0ZjhFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5mdW5jdGlvbiBub3JtYWxpemVVUkwodXJsKSB7XG4gIGlmICh1cmwuaW5kZXhPZihcIjovL1wiKSA9PT0gLTEpXG4gICAgdXJsID0gXCJ3c3M6Ly9cIiArIHVybDtcbiAgbGV0IHAgPSBuZXcgVVJMKHVybCk7XG4gIHAucGF0aG5hbWUgPSBwLnBhdGhuYW1lLnJlcGxhY2UoL1xcLysvZywgXCIvXCIpO1xuICBpZiAocC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikpXG4gICAgcC5wYXRobmFtZSA9IHAucGF0aG5hbWUuc2xpY2UoMCwgLTEpO1xuICBpZiAocC5wb3J0ID09PSBcIjgwXCIgJiYgcC5wcm90b2NvbCA9PT0gXCJ3czpcIiB8fCBwLnBvcnQgPT09IFwiNDQzXCIgJiYgcC5wcm90b2NvbCA9PT0gXCJ3c3M6XCIpXG4gICAgcC5wb3J0ID0gXCJcIjtcbiAgcC5zZWFyY2hQYXJhbXMuc29ydCgpO1xuICBwLmhhc2ggPSBcIlwiO1xuICByZXR1cm4gcC50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gaW5zZXJ0RXZlbnRJbnRvRGVzY2VuZGluZ0xpc3Qoc29ydGVkQXJyYXksIGV2ZW50KSB7XG4gIGNvbnN0IFtpZHgsIGZvdW5kXSA9IGJpbmFyeVNlYXJjaChzb3J0ZWRBcnJheSwgKGIpID0+IHtcbiAgICBpZiAoZXZlbnQuaWQgPT09IGIuaWQpXG4gICAgICByZXR1cm4gMDtcbiAgICBpZiAoZXZlbnQuY3JlYXRlZF9hdCA9PT0gYi5jcmVhdGVkX2F0KVxuICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiBiLmNyZWF0ZWRfYXQgLSBldmVudC5jcmVhdGVkX2F0O1xuICB9KTtcbiAgaWYgKCFmb3VuZCkge1xuICAgIHNvcnRlZEFycmF5LnNwbGljZShpZHgsIDAsIGV2ZW50KTtcbiAgfVxuICByZXR1cm4gc29ydGVkQXJyYXk7XG59XG5mdW5jdGlvbiBpbnNlcnRFdmVudEludG9Bc2NlbmRpbmdMaXN0KHNvcnRlZEFycmF5LCBldmVudCkge1xuICBjb25zdCBbaWR4LCBmb3VuZF0gPSBiaW5hcnlTZWFyY2goc29ydGVkQXJyYXksIChiKSA9PiB7XG4gICAgaWYgKGV2ZW50LmlkID09PSBiLmlkKVxuICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKGV2ZW50LmNyZWF0ZWRfYXQgPT09IGIuY3JlYXRlZF9hdClcbiAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gZXZlbnQuY3JlYXRlZF9hdCAtIGIuY3JlYXRlZF9hdDtcbiAgfSk7XG4gIGlmICghZm91bmQpIHtcbiAgICBzb3J0ZWRBcnJheS5zcGxpY2UoaWR4LCAwLCBldmVudCk7XG4gIH1cbiAgcmV0dXJuIHNvcnRlZEFycmF5O1xufVxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGFyciwgY29tcGFyZSkge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChzdGFydCArIGVuZCkgLyAyKTtcbiAgICBjb25zdCBjbXAgPSBjb21wYXJlKGFyclttaWRdKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICByZXR1cm4gW21pZCwgdHJ1ZV07XG4gICAgfVxuICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICBlbmQgPSBtaWQgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IG1pZCArIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBbc3RhcnQsIGZhbHNlXTtcbn1cbnZhciBRdWV1ZU5vZGUgPSBjbGFzcyB7XG4gIHZhbHVlO1xuICBuZXh0ID0gbnVsbDtcbiAgcHJldiA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLnZhbHVlID0gbWVzc2FnZTtcbiAgfVxufTtcbnZhciBRdWV1ZSA9IGNsYXNzIHtcbiAgZmlyc3Q7XG4gIGxhc3Q7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZmlyc3QgPSBudWxsO1xuICAgIHRoaXMubGFzdCA9IG51bGw7XG4gIH1cbiAgZW5xdWV1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG5ld05vZGUgPSBuZXcgUXVldWVOb2RlKHZhbHVlKTtcbiAgICBpZiAoIXRoaXMubGFzdCkge1xuICAgICAgdGhpcy5maXJzdCA9IG5ld05vZGU7XG4gICAgICB0aGlzLmxhc3QgPSBuZXdOb2RlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sYXN0ID09PSB0aGlzLmZpcnN0KSB7XG4gICAgICB0aGlzLmxhc3QgPSBuZXdOb2RlO1xuICAgICAgdGhpcy5sYXN0LnByZXYgPSB0aGlzLmZpcnN0O1xuICAgICAgdGhpcy5maXJzdC5uZXh0ID0gbmV3Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Tm9kZS5wcmV2ID0gdGhpcy5sYXN0O1xuICAgICAgdGhpcy5sYXN0Lm5leHQgPSBuZXdOb2RlO1xuICAgICAgdGhpcy5sYXN0ID0gbmV3Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZGVxdWV1ZSgpIHtcbiAgICBpZiAoIXRoaXMuZmlyc3QpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAodGhpcy5maXJzdCA9PT0gdGhpcy5sYXN0KSB7XG4gICAgICBjb25zdCB0YXJnZXQyID0gdGhpcy5maXJzdDtcbiAgICAgIHRoaXMuZmlyc3QgPSBudWxsO1xuICAgICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgICAgIHJldHVybiB0YXJnZXQyLnZhbHVlO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmZpcnN0O1xuICAgIHRoaXMuZmlyc3QgPSB0YXJnZXQubmV4dDtcbiAgICByZXR1cm4gdGFyZ2V0LnZhbHVlO1xuICB9XG59O1xuXG4vLyBwdXJlLnRzXG52YXIgSlMgPSBjbGFzcyB7XG4gIGdlbmVyYXRlU2VjcmV0S2V5KCkge1xuICAgIHJldHVybiBzY2hub3JyLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgfVxuICBnZXRQdWJsaWNLZXkoc2VjcmV0S2V5KSB7XG4gICAgcmV0dXJuIGJ5dGVzVG9IZXgoc2Nobm9yci5nZXRQdWJsaWNLZXkoc2VjcmV0S2V5KSk7XG4gIH1cbiAgZmluYWxpemVFdmVudCh0LCBzZWNyZXRLZXkpIHtcbiAgICBjb25zdCBldmVudCA9IHQ7XG4gICAgZXZlbnQucHVia2V5ID0gYnl0ZXNUb0hleChzY2hub3JyLmdldFB1YmxpY0tleShzZWNyZXRLZXkpKTtcbiAgICBldmVudC5pZCA9IGdldEV2ZW50SGFzaChldmVudCk7XG4gICAgZXZlbnQuc2lnID0gYnl0ZXNUb0hleChzY2hub3JyLnNpZ24oZ2V0RXZlbnRIYXNoKGV2ZW50KSwgc2VjcmV0S2V5KSk7XG4gICAgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gdHJ1ZTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgdmVyaWZ5RXZlbnQoZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9PT0gXCJib29sZWFuXCIpXG4gICAgICByZXR1cm4gZXZlbnRbdmVyaWZpZWRTeW1ib2xdO1xuICAgIGNvbnN0IGhhc2ggPSBnZXRFdmVudEhhc2goZXZlbnQpO1xuICAgIGlmIChoYXNoICE9PSBldmVudC5pZCkge1xuICAgICAgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YWxpZCA9IHNjaG5vcnIudmVyaWZ5KGV2ZW50LnNpZywgaGFzaCwgZXZlbnQucHVia2V5KTtcbiAgICAgIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9IHZhbGlkO1xuICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gc2VyaWFsaXplRXZlbnQoZXZ0KSB7XG4gIGlmICghdmFsaWRhdGVFdmVudChldnQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IHNlcmlhbGl6ZSBldmVudCB3aXRoIHdyb25nIG9yIG1pc3NpbmcgcHJvcGVydGllc1wiKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFswLCBldnQucHVia2V5LCBldnQuY3JlYXRlZF9hdCwgZXZ0LmtpbmQsIGV2dC50YWdzLCBldnQuY29udGVudF0pO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRIYXNoKGV2ZW50KSB7XG4gIGxldCBldmVudEhhc2ggPSBzaGEyNTYodXRmOEVuY29kZXIuZW5jb2RlKHNlcmlhbGl6ZUV2ZW50KGV2ZW50KSkpO1xuICByZXR1cm4gYnl0ZXNUb0hleChldmVudEhhc2gpO1xufVxudmFyIGkgPSBuZXcgSlMoKTtcbnZhciBnZW5lcmF0ZVNlY3JldEtleSA9IGkuZ2VuZXJhdGVTZWNyZXRLZXk7XG52YXIgZ2V0UHVibGljS2V5ID0gaS5nZXRQdWJsaWNLZXk7XG52YXIgZmluYWxpemVFdmVudCA9IGkuZmluYWxpemVFdmVudDtcbnZhciB2ZXJpZnlFdmVudCA9IGkudmVyaWZ5RXZlbnQ7XG5cbi8vIGtpbmRzLnRzXG52YXIga2luZHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoa2luZHNfZXhwb3J0cywge1xuICBBcHBsaWNhdGlvbjogKCkgPT4gQXBwbGljYXRpb24sXG4gIEJhZGdlQXdhcmQ6ICgpID0+IEJhZGdlQXdhcmQsXG4gIEJhZGdlRGVmaW5pdGlvbjogKCkgPT4gQmFkZ2VEZWZpbml0aW9uLFxuICBCbG9ja2VkUmVsYXlzTGlzdDogKCkgPT4gQmxvY2tlZFJlbGF5c0xpc3QsXG4gIEJvb2ttYXJrTGlzdDogKCkgPT4gQm9va21hcmtMaXN0LFxuICBCb29rbWFya3NldHM6ICgpID0+IEJvb2ttYXJrc2V0cyxcbiAgQ2FsZW5kYXI6ICgpID0+IENhbGVuZGFyLFxuICBDYWxlbmRhckV2ZW50UlNWUDogKCkgPT4gQ2FsZW5kYXJFdmVudFJTVlAsXG4gIENoYW5uZWxDcmVhdGlvbjogKCkgPT4gQ2hhbm5lbENyZWF0aW9uLFxuICBDaGFubmVsSGlkZU1lc3NhZ2U6ICgpID0+IENoYW5uZWxIaWRlTWVzc2FnZSxcbiAgQ2hhbm5lbE1lc3NhZ2U6ICgpID0+IENoYW5uZWxNZXNzYWdlLFxuICBDaGFubmVsTWV0YWRhdGE6ICgpID0+IENoYW5uZWxNZXRhZGF0YSxcbiAgQ2hhbm5lbE11dGVVc2VyOiAoKSA9PiBDaGFubmVsTXV0ZVVzZXIsXG4gIENsYXNzaWZpZWRMaXN0aW5nOiAoKSA9PiBDbGFzc2lmaWVkTGlzdGluZyxcbiAgQ2xpZW50QXV0aDogKCkgPT4gQ2xpZW50QXV0aCxcbiAgQ29tbXVuaXRpZXNMaXN0OiAoKSA9PiBDb21tdW5pdGllc0xpc3QsXG4gIENvbW11bml0eURlZmluaXRpb246ICgpID0+IENvbW11bml0eURlZmluaXRpb24sXG4gIENvbW11bml0eVBvc3RBcHByb3ZhbDogKCkgPT4gQ29tbXVuaXR5UG9zdEFwcHJvdmFsLFxuICBDb250YWN0czogKCkgPT4gQ29udGFjdHMsXG4gIENyZWF0ZU9yVXBkYXRlUHJvZHVjdDogKCkgPT4gQ3JlYXRlT3JVcGRhdGVQcm9kdWN0LFxuICBDcmVhdGVPclVwZGF0ZVN0YWxsOiAoKSA9PiBDcmVhdGVPclVwZGF0ZVN0YWxsLFxuICBDdXJhdGlvbnNldHM6ICgpID0+IEN1cmF0aW9uc2V0cyxcbiAgRGF0ZTogKCkgPT4gRGF0ZTIsXG4gIERpcmVjdE1lc3NhZ2VSZWxheXNMaXN0OiAoKSA9PiBEaXJlY3RNZXNzYWdlUmVsYXlzTGlzdCxcbiAgRHJhZnRDbGFzc2lmaWVkTGlzdGluZzogKCkgPT4gRHJhZnRDbGFzc2lmaWVkTGlzdGluZyxcbiAgRHJhZnRMb25nOiAoKSA9PiBEcmFmdExvbmcsXG4gIEVtb2ppc2V0czogKCkgPT4gRW1vamlzZXRzLFxuICBFbmNyeXB0ZWREaXJlY3RNZXNzYWdlOiAoKSA9PiBFbmNyeXB0ZWREaXJlY3RNZXNzYWdlLFxuICBFdmVudERlbGV0aW9uOiAoKSA9PiBFdmVudERlbGV0aW9uLFxuICBGaWxlTWV0YWRhdGE6ICgpID0+IEZpbGVNZXRhZGF0YSxcbiAgRmlsZVNlcnZlclByZWZlcmVuY2U6ICgpID0+IEZpbGVTZXJ2ZXJQcmVmZXJlbmNlLFxuICBGb2xsb3dzZXRzOiAoKSA9PiBGb2xsb3dzZXRzLFxuICBHZW5lcmljUmVwb3N0OiAoKSA9PiBHZW5lcmljUmVwb3N0LFxuICBHZW5lcmljbGlzdHM6ICgpID0+IEdlbmVyaWNsaXN0cyxcbiAgR2lmdFdyYXA6ICgpID0+IEdpZnRXcmFwLFxuICBIVFRQQXV0aDogKCkgPT4gSFRUUEF1dGgsXG4gIEhhbmRsZXJpbmZvcm1hdGlvbjogKCkgPT4gSGFuZGxlcmluZm9ybWF0aW9uLFxuICBIYW5kbGVycmVjb21tZW5kYXRpb246ICgpID0+IEhhbmRsZXJyZWNvbW1lbmRhdGlvbixcbiAgSGlnaGxpZ2h0czogKCkgPT4gSGlnaGxpZ2h0cyxcbiAgSW50ZXJlc3RzTGlzdDogKCkgPT4gSW50ZXJlc3RzTGlzdCxcbiAgSW50ZXJlc3RzZXRzOiAoKSA9PiBJbnRlcmVzdHNldHMsXG4gIEpvYkZlZWRiYWNrOiAoKSA9PiBKb2JGZWVkYmFjayxcbiAgSm9iUmVxdWVzdDogKCkgPT4gSm9iUmVxdWVzdCxcbiAgSm9iUmVzdWx0OiAoKSA9PiBKb2JSZXN1bHQsXG4gIExhYmVsOiAoKSA9PiBMYWJlbCxcbiAgTGlnaHRuaW5nUHViUlBDOiAoKSA9PiBMaWdodG5pbmdQdWJSUEMsXG4gIExpdmVDaGF0TWVzc2FnZTogKCkgPT4gTGl2ZUNoYXRNZXNzYWdlLFxuICBMaXZlRXZlbnQ6ICgpID0+IExpdmVFdmVudCxcbiAgTG9uZ0Zvcm1BcnRpY2xlOiAoKSA9PiBMb25nRm9ybUFydGljbGUsXG4gIE1ldGFkYXRhOiAoKSA9PiBNZXRhZGF0YSxcbiAgTXV0ZWxpc3Q6ICgpID0+IE11dGVsaXN0LFxuICBOV0NXYWxsZXRJbmZvOiAoKSA9PiBOV0NXYWxsZXRJbmZvLFxuICBOV0NXYWxsZXRSZXF1ZXN0OiAoKSA9PiBOV0NXYWxsZXRSZXF1ZXN0LFxuICBOV0NXYWxsZXRSZXNwb25zZTogKCkgPT4gTldDV2FsbGV0UmVzcG9uc2UsXG4gIE5vc3RyQ29ubmVjdDogKCkgPT4gTm9zdHJDb25uZWN0LFxuICBPcGVuVGltZXN0YW1wczogKCkgPT4gT3BlblRpbWVzdGFtcHMsXG4gIFBpbmxpc3Q6ICgpID0+IFBpbmxpc3QsXG4gIFByaXZhdGVEaXJlY3RNZXNzYWdlOiAoKSA9PiBQcml2YXRlRGlyZWN0TWVzc2FnZSxcbiAgUHJvYmxlbVRyYWNrZXI6ICgpID0+IFByb2JsZW1UcmFja2VyLFxuICBQcm9maWxlQmFkZ2VzOiAoKSA9PiBQcm9maWxlQmFkZ2VzLFxuICBQdWJsaWNDaGF0c0xpc3Q6ICgpID0+IFB1YmxpY0NoYXRzTGlzdCxcbiAgUmVhY3Rpb246ICgpID0+IFJlYWN0aW9uLFxuICBSZWNvbW1lbmRSZWxheTogKCkgPT4gUmVjb21tZW5kUmVsYXksXG4gIFJlbGF5TGlzdDogKCkgPT4gUmVsYXlMaXN0LFxuICBSZWxheXNldHM6ICgpID0+IFJlbGF5c2V0cyxcbiAgUmVwb3J0OiAoKSA9PiBSZXBvcnQsXG4gIFJlcG9ydGluZzogKCkgPT4gUmVwb3J0aW5nLFxuICBSZXBvc3Q6ICgpID0+IFJlcG9zdCxcbiAgU2VhbDogKCkgPT4gU2VhbCxcbiAgU2VhcmNoUmVsYXlzTGlzdDogKCkgPT4gU2VhcmNoUmVsYXlzTGlzdCxcbiAgU2hvcnRUZXh0Tm90ZTogKCkgPT4gU2hvcnRUZXh0Tm90ZSxcbiAgVGltZTogKCkgPT4gVGltZSxcbiAgVXNlckVtb2ppTGlzdDogKCkgPT4gVXNlckVtb2ppTGlzdCxcbiAgVXNlclN0YXR1c2VzOiAoKSA9PiBVc2VyU3RhdHVzZXMsXG4gIFphcDogKCkgPT4gWmFwLFxuICBaYXBHb2FsOiAoKSA9PiBaYXBHb2FsLFxuICBaYXBSZXF1ZXN0OiAoKSA9PiBaYXBSZXF1ZXN0LFxuICBjbGFzc2lmeUtpbmQ6ICgpID0+IGNsYXNzaWZ5S2luZCxcbiAgaXNBZGRyZXNzYWJsZUtpbmQ6ICgpID0+IGlzQWRkcmVzc2FibGVLaW5kLFxuICBpc0VwaGVtZXJhbEtpbmQ6ICgpID0+IGlzRXBoZW1lcmFsS2luZCxcbiAgaXNLaW5kOiAoKSA9PiBpc0tpbmQsXG4gIGlzUGFyYW1ldGVyaXplZFJlcGxhY2VhYmxlS2luZDogKCkgPT4gaXNQYXJhbWV0ZXJpemVkUmVwbGFjZWFibGVLaW5kLFxuICBpc1JlZ3VsYXJLaW5kOiAoKSA9PiBpc1JlZ3VsYXJLaW5kLFxuICBpc1JlcGxhY2VhYmxlS2luZDogKCkgPT4gaXNSZXBsYWNlYWJsZUtpbmRcbn0pO1xuZnVuY3Rpb24gaXNSZWd1bGFyS2luZChraW5kKSB7XG4gIHJldHVybiAxZTMgPD0ga2luZCAmJiBraW5kIDwgMWU0IHx8IFsxLCAyLCA0LCA1LCA2LCA3LCA4LCAxNiwgNDAsIDQxLCA0MiwgNDMsIDQ0XS5pbmNsdWRlcyhraW5kKTtcbn1cbmZ1bmN0aW9uIGlzUmVwbGFjZWFibGVLaW5kKGtpbmQpIHtcbiAgcmV0dXJuIFswLCAzXS5pbmNsdWRlcyhraW5kKSB8fCAxZTQgPD0ga2luZCAmJiBraW5kIDwgMmU0O1xufVxuZnVuY3Rpb24gaXNFcGhlbWVyYWxLaW5kKGtpbmQpIHtcbiAgcmV0dXJuIDJlNCA8PSBraW5kICYmIGtpbmQgPCAzZTQ7XG59XG5mdW5jdGlvbiBpc0FkZHJlc3NhYmxlS2luZChraW5kKSB7XG4gIHJldHVybiAzZTQgPD0ga2luZCAmJiBraW5kIDwgNGU0O1xufVxudmFyIGlzUGFyYW1ldGVyaXplZFJlcGxhY2VhYmxlS2luZCA9IGlzQWRkcmVzc2FibGVLaW5kO1xuZnVuY3Rpb24gY2xhc3NpZnlLaW5kKGtpbmQpIHtcbiAgaWYgKGlzUmVndWxhcktpbmQoa2luZCkpXG4gICAgcmV0dXJuIFwicmVndWxhclwiO1xuICBpZiAoaXNSZXBsYWNlYWJsZUtpbmQoa2luZCkpXG4gICAgcmV0dXJuIFwicmVwbGFjZWFibGVcIjtcbiAgaWYgKGlzRXBoZW1lcmFsS2luZChraW5kKSlcbiAgICByZXR1cm4gXCJlcGhlbWVyYWxcIjtcbiAgaWYgKGlzQWRkcmVzc2FibGVLaW5kKGtpbmQpKVxuICAgIHJldHVybiBcInBhcmFtZXRlcml6ZWRcIjtcbiAgcmV0dXJuIFwidW5rbm93blwiO1xufVxuZnVuY3Rpb24gaXNLaW5kKGV2ZW50LCBraW5kKSB7XG4gIGNvbnN0IGtpbmRBc0FycmF5ID0ga2luZCBpbnN0YW5jZW9mIEFycmF5ID8ga2luZCA6IFtraW5kXTtcbiAgcmV0dXJuIHZhbGlkYXRlRXZlbnQoZXZlbnQpICYmIGtpbmRBc0FycmF5LmluY2x1ZGVzKGV2ZW50LmtpbmQpIHx8IGZhbHNlO1xufVxudmFyIE1ldGFkYXRhID0gMDtcbnZhciBTaG9ydFRleHROb3RlID0gMTtcbnZhciBSZWNvbW1lbmRSZWxheSA9IDI7XG52YXIgQ29udGFjdHMgPSAzO1xudmFyIEVuY3J5cHRlZERpcmVjdE1lc3NhZ2UgPSA0O1xudmFyIEV2ZW50RGVsZXRpb24gPSA1O1xudmFyIFJlcG9zdCA9IDY7XG52YXIgUmVhY3Rpb24gPSA3O1xudmFyIEJhZGdlQXdhcmQgPSA4O1xudmFyIFNlYWwgPSAxMztcbnZhciBQcml2YXRlRGlyZWN0TWVzc2FnZSA9IDE0O1xudmFyIEdlbmVyaWNSZXBvc3QgPSAxNjtcbnZhciBDaGFubmVsQ3JlYXRpb24gPSA0MDtcbnZhciBDaGFubmVsTWV0YWRhdGEgPSA0MTtcbnZhciBDaGFubmVsTWVzc2FnZSA9IDQyO1xudmFyIENoYW5uZWxIaWRlTWVzc2FnZSA9IDQzO1xudmFyIENoYW5uZWxNdXRlVXNlciA9IDQ0O1xudmFyIE9wZW5UaW1lc3RhbXBzID0gMTA0MDtcbnZhciBHaWZ0V3JhcCA9IDEwNTk7XG52YXIgRmlsZU1ldGFkYXRhID0gMTA2MztcbnZhciBMaXZlQ2hhdE1lc3NhZ2UgPSAxMzExO1xudmFyIFByb2JsZW1UcmFja2VyID0gMTk3MTtcbnZhciBSZXBvcnQgPSAxOTg0O1xudmFyIFJlcG9ydGluZyA9IDE5ODQ7XG52YXIgTGFiZWwgPSAxOTg1O1xudmFyIENvbW11bml0eVBvc3RBcHByb3ZhbCA9IDQ1NTA7XG52YXIgSm9iUmVxdWVzdCA9IDU5OTk7XG52YXIgSm9iUmVzdWx0ID0gNjk5OTtcbnZhciBKb2JGZWVkYmFjayA9IDdlMztcbnZhciBaYXBHb2FsID0gOTA0MTtcbnZhciBaYXBSZXF1ZXN0ID0gOTczNDtcbnZhciBaYXAgPSA5NzM1O1xudmFyIEhpZ2hsaWdodHMgPSA5ODAyO1xudmFyIE11dGVsaXN0ID0gMWU0O1xudmFyIFBpbmxpc3QgPSAxMDAwMTtcbnZhciBSZWxheUxpc3QgPSAxMDAwMjtcbnZhciBCb29rbWFya0xpc3QgPSAxMDAwMztcbnZhciBDb21tdW5pdGllc0xpc3QgPSAxMDAwNDtcbnZhciBQdWJsaWNDaGF0c0xpc3QgPSAxMDAwNTtcbnZhciBCbG9ja2VkUmVsYXlzTGlzdCA9IDEwMDA2O1xudmFyIFNlYXJjaFJlbGF5c0xpc3QgPSAxMDAwNztcbnZhciBJbnRlcmVzdHNMaXN0ID0gMTAwMTU7XG52YXIgVXNlckVtb2ppTGlzdCA9IDEwMDMwO1xudmFyIERpcmVjdE1lc3NhZ2VSZWxheXNMaXN0ID0gMTAwNTA7XG52YXIgRmlsZVNlcnZlclByZWZlcmVuY2UgPSAxMDA5NjtcbnZhciBOV0NXYWxsZXRJbmZvID0gMTMxOTQ7XG52YXIgTGlnaHRuaW5nUHViUlBDID0gMjFlMztcbnZhciBDbGllbnRBdXRoID0gMjIyNDI7XG52YXIgTldDV2FsbGV0UmVxdWVzdCA9IDIzMTk0O1xudmFyIE5XQ1dhbGxldFJlc3BvbnNlID0gMjMxOTU7XG52YXIgTm9zdHJDb25uZWN0ID0gMjQxMzM7XG52YXIgSFRUUEF1dGggPSAyNzIzNTtcbnZhciBGb2xsb3dzZXRzID0gM2U0O1xudmFyIEdlbmVyaWNsaXN0cyA9IDMwMDAxO1xudmFyIFJlbGF5c2V0cyA9IDMwMDAyO1xudmFyIEJvb2ttYXJrc2V0cyA9IDMwMDAzO1xudmFyIEN1cmF0aW9uc2V0cyA9IDMwMDA0O1xudmFyIFByb2ZpbGVCYWRnZXMgPSAzMDAwODtcbnZhciBCYWRnZURlZmluaXRpb24gPSAzMDAwOTtcbnZhciBJbnRlcmVzdHNldHMgPSAzMDAxNTtcbnZhciBDcmVhdGVPclVwZGF0ZVN0YWxsID0gMzAwMTc7XG52YXIgQ3JlYXRlT3JVcGRhdGVQcm9kdWN0ID0gMzAwMTg7XG52YXIgTG9uZ0Zvcm1BcnRpY2xlID0gMzAwMjM7XG52YXIgRHJhZnRMb25nID0gMzAwMjQ7XG52YXIgRW1vamlzZXRzID0gMzAwMzA7XG52YXIgQXBwbGljYXRpb24gPSAzMDA3ODtcbnZhciBMaXZlRXZlbnQgPSAzMDMxMTtcbnZhciBVc2VyU3RhdHVzZXMgPSAzMDMxNTtcbnZhciBDbGFzc2lmaWVkTGlzdGluZyA9IDMwNDAyO1xudmFyIERyYWZ0Q2xhc3NpZmllZExpc3RpbmcgPSAzMDQwMztcbnZhciBEYXRlMiA9IDMxOTIyO1xudmFyIFRpbWUgPSAzMTkyMztcbnZhciBDYWxlbmRhciA9IDMxOTI0O1xudmFyIENhbGVuZGFyRXZlbnRSU1ZQID0gMzE5MjU7XG52YXIgSGFuZGxlcnJlY29tbWVuZGF0aW9uID0gMzE5ODk7XG52YXIgSGFuZGxlcmluZm9ybWF0aW9uID0gMzE5OTA7XG52YXIgQ29tbXVuaXR5RGVmaW5pdGlvbiA9IDM0NTUwO1xuXG4vLyBmaWx0ZXIudHNcbmZ1bmN0aW9uIG1hdGNoRmlsdGVyKGZpbHRlciwgZXZlbnQpIHtcbiAgaWYgKGZpbHRlci5pZHMgJiYgZmlsdGVyLmlkcy5pbmRleE9mKGV2ZW50LmlkKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbHRlci5raW5kcyAmJiBmaWx0ZXIua2luZHMuaW5kZXhPZihldmVudC5raW5kKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbHRlci5hdXRob3JzICYmIGZpbHRlci5hdXRob3JzLmluZGV4T2YoZXZlbnQucHVia2V5KSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgZiBpbiBmaWx0ZXIpIHtcbiAgICBpZiAoZlswXSA9PT0gXCIjXCIpIHtcbiAgICAgIGxldCB0YWdOYW1lID0gZi5zbGljZSgxKTtcbiAgICAgIGxldCB2YWx1ZXMgPSBmaWx0ZXJbYCMke3RhZ05hbWV9YF07XG4gICAgICBpZiAodmFsdWVzICYmICFldmVudC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gZi5zbGljZSgxKSAmJiB2YWx1ZXMuaW5kZXhPZih2KSAhPT0gLTEpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChmaWx0ZXIuc2luY2UgJiYgZXZlbnQuY3JlYXRlZF9hdCA8IGZpbHRlci5zaW5jZSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChmaWx0ZXIudW50aWwgJiYgZXZlbnQuY3JlYXRlZF9hdCA+IGZpbHRlci51bnRpbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbWF0Y2hGaWx0ZXJzKGZpbHRlcnMsIGV2ZW50KSB7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBmaWx0ZXJzLmxlbmd0aDsgaTIrKykge1xuICAgIGlmIChtYXRjaEZpbHRlcihmaWx0ZXJzW2kyXSwgZXZlbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbWVyZ2VGaWx0ZXJzKC4uLmZpbHRlcnMpIHtcbiAgbGV0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgZmlsdGVycy5sZW5ndGg7IGkyKyspIHtcbiAgICBsZXQgZmlsdGVyID0gZmlsdGVyc1tpMl07XG4gICAgT2JqZWN0LmVudHJpZXMoZmlsdGVyKS5mb3JFYWNoKChbcHJvcGVydHksIHZhbHVlc10pID0+IHtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gXCJraW5kc1wiIHx8IHByb3BlcnR5ID09PSBcImlkc1wiIHx8IHByb3BlcnR5ID09PSBcImF1dGhvcnNcIiB8fCBwcm9wZXJ0eVswXSA9PT0gXCIjXCIpIHtcbiAgICAgICAgcmVzdWx0W3Byb3BlcnR5XSA9IHJlc3VsdFtwcm9wZXJ0eV0gfHwgW107XG4gICAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgdmFsdWVzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW3ZdO1xuICAgICAgICAgIGlmICghcmVzdWx0W3Byb3BlcnR5XS5pbmNsdWRlcyh2YWx1ZSkpXG4gICAgICAgICAgICByZXN1bHRbcHJvcGVydHldLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGZpbHRlci5saW1pdCAmJiAoIXJlc3VsdC5saW1pdCB8fCBmaWx0ZXIubGltaXQgPiByZXN1bHQubGltaXQpKVxuICAgICAgcmVzdWx0LmxpbWl0ID0gZmlsdGVyLmxpbWl0O1xuICAgIGlmIChmaWx0ZXIudW50aWwgJiYgKCFyZXN1bHQudW50aWwgfHwgZmlsdGVyLnVudGlsID4gcmVzdWx0LnVudGlsKSlcbiAgICAgIHJlc3VsdC51bnRpbCA9IGZpbHRlci51bnRpbDtcbiAgICBpZiAoZmlsdGVyLnNpbmNlICYmICghcmVzdWx0LnNpbmNlIHx8IGZpbHRlci5zaW5jZSA8IHJlc3VsdC5zaW5jZSkpXG4gICAgICByZXN1bHQuc2luY2UgPSBmaWx0ZXIuc2luY2U7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldEZpbHRlckxpbWl0KGZpbHRlcikge1xuICBpZiAoZmlsdGVyLmlkcyAmJiAhZmlsdGVyLmlkcy5sZW5ndGgpXG4gICAgcmV0dXJuIDA7XG4gIGlmIChmaWx0ZXIua2luZHMgJiYgIWZpbHRlci5raW5kcy5sZW5ndGgpXG4gICAgcmV0dXJuIDA7XG4gIGlmIChmaWx0ZXIuYXV0aG9ycyAmJiAhZmlsdGVyLmF1dGhvcnMubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmaWx0ZXIpKSB7XG4gICAgaWYgKGtleVswXSA9PT0gXCIjXCIgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgIXZhbHVlLmxlbmd0aClcbiAgICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihcbiAgICBNYXRoLm1heCgwLCBmaWx0ZXIubGltaXQgPz8gSW5maW5pdHkpLFxuICAgIGZpbHRlci5pZHM/Lmxlbmd0aCA/PyBJbmZpbml0eSxcbiAgICBmaWx0ZXIuYXV0aG9ycz8ubGVuZ3RoICYmIGZpbHRlci5raW5kcz8uZXZlcnkoKGtpbmQpID0+IGlzUmVwbGFjZWFibGVLaW5kKGtpbmQpKSA/IGZpbHRlci5hdXRob3JzLmxlbmd0aCAqIGZpbHRlci5raW5kcy5sZW5ndGggOiBJbmZpbml0eSxcbiAgICBmaWx0ZXIuYXV0aG9ycz8ubGVuZ3RoICYmIGZpbHRlci5raW5kcz8uZXZlcnkoKGtpbmQpID0+IGlzQWRkcmVzc2FibGVLaW5kKGtpbmQpKSAmJiBmaWx0ZXJbXCIjZFwiXT8ubGVuZ3RoID8gZmlsdGVyLmF1dGhvcnMubGVuZ3RoICogZmlsdGVyLmtpbmRzLmxlbmd0aCAqIGZpbHRlcltcIiNkXCJdLmxlbmd0aCA6IEluZmluaXR5XG4gICk7XG59XG5cbi8vIGZha2Vqc29uLnRzXG52YXIgZmFrZWpzb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZmFrZWpzb25fZXhwb3J0cywge1xuICBnZXRIZXg2NDogKCkgPT4gZ2V0SGV4NjQsXG4gIGdldEludDogKCkgPT4gZ2V0SW50LFxuICBnZXRTdWJzY3JpcHRpb25JZDogKCkgPT4gZ2V0U3Vic2NyaXB0aW9uSWQsXG4gIG1hdGNoRXZlbnRJZDogKCkgPT4gbWF0Y2hFdmVudElkLFxuICBtYXRjaEV2ZW50S2luZDogKCkgPT4gbWF0Y2hFdmVudEtpbmQsXG4gIG1hdGNoRXZlbnRQdWJrZXk6ICgpID0+IG1hdGNoRXZlbnRQdWJrZXlcbn0pO1xuZnVuY3Rpb24gZ2V0SGV4NjQoanNvbiwgZmllbGQpIHtcbiAgbGV0IGxlbiA9IGZpZWxkLmxlbmd0aCArIDM7XG4gIGxldCBpZHggPSBqc29uLmluZGV4T2YoYFwiJHtmaWVsZH1cIjpgKSArIGxlbjtcbiAgbGV0IHMgPSBqc29uLnNsaWNlKGlkeCkuaW5kZXhPZihgXCJgKSArIGlkeCArIDE7XG4gIHJldHVybiBqc29uLnNsaWNlKHMsIHMgKyA2NCk7XG59XG5mdW5jdGlvbiBnZXRJbnQoanNvbiwgZmllbGQpIHtcbiAgbGV0IGxlbiA9IGZpZWxkLmxlbmd0aDtcbiAgbGV0IGlkeCA9IGpzb24uaW5kZXhPZihgXCIke2ZpZWxkfVwiOmApICsgbGVuICsgMztcbiAgbGV0IHNsaWNlZCA9IGpzb24uc2xpY2UoaWR4KTtcbiAgbGV0IGVuZCA9IE1hdGgubWluKHNsaWNlZC5pbmRleE9mKFwiLFwiKSwgc2xpY2VkLmluZGV4T2YoXCJ9XCIpKTtcbiAgcmV0dXJuIHBhcnNlSW50KHNsaWNlZC5zbGljZSgwLCBlbmQpLCAxMCk7XG59XG5mdW5jdGlvbiBnZXRTdWJzY3JpcHRpb25JZChqc29uKSB7XG4gIGxldCBpZHggPSBqc29uLnNsaWNlKDAsIDIyKS5pbmRleE9mKGBcIkVWRU5UXCJgKTtcbiAgaWYgKGlkeCA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBwc3RhcnQgPSBqc29uLnNsaWNlKGlkeCArIDcgKyAxKS5pbmRleE9mKGBcImApO1xuICBpZiAocHN0YXJ0ID09PSAtMSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHN0YXJ0ID0gaWR4ICsgNyArIDEgKyBwc3RhcnQ7XG4gIGxldCBwZW5kID0ganNvbi5zbGljZShzdGFydCArIDEsIDgwKS5pbmRleE9mKGBcImApO1xuICBpZiAocGVuZCA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBlbmQgPSBzdGFydCArIDEgKyBwZW5kO1xuICByZXR1cm4ganNvbi5zbGljZShzdGFydCArIDEsIGVuZCk7XG59XG5mdW5jdGlvbiBtYXRjaEV2ZW50SWQoanNvbiwgaWQpIHtcbiAgcmV0dXJuIGlkID09PSBnZXRIZXg2NChqc29uLCBcImlkXCIpO1xufVxuZnVuY3Rpb24gbWF0Y2hFdmVudFB1YmtleShqc29uLCBwdWJrZXkpIHtcbiAgcmV0dXJuIHB1YmtleSA9PT0gZ2V0SGV4NjQoanNvbiwgXCJwdWJrZXlcIik7XG59XG5mdW5jdGlvbiBtYXRjaEV2ZW50S2luZChqc29uLCBraW5kKSB7XG4gIHJldHVybiBraW5kID09PSBnZXRJbnQoanNvbiwgXCJraW5kXCIpO1xufVxuXG4vLyBuaXA0Mi50c1xudmFyIG5pcDQyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDQyX2V4cG9ydHMsIHtcbiAgbWFrZUF1dGhFdmVudDogKCkgPT4gbWFrZUF1dGhFdmVudFxufSk7XG5mdW5jdGlvbiBtYWtlQXV0aEV2ZW50KHJlbGF5VVJMLCBjaGFsbGVuZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBDbGllbnRBdXRoLFxuICAgIGNyZWF0ZWRfYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyksXG4gICAgdGFnczogW1xuICAgICAgW1wicmVsYXlcIiwgcmVsYXlVUkxdLFxuICAgICAgW1wiY2hhbGxlbmdlXCIsIGNoYWxsZW5nZV1cbiAgICBdLFxuICAgIGNvbnRlbnQ6IFwiXCJcbiAgfTtcbn1cblxuLy8gaGVscGVycy50c1xuYXN5bmMgZnVuY3Rpb24geWllbGRUaHJlYWQoKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGNoID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNoLnBvcnQxLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH07XG4gICAgY2gucG9ydDEuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgY2gucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgY2gucG9ydDEuc3RhcnQoKTtcbiAgfSk7XG59XG52YXIgYWx3YXlzVHJ1ZSA9ICh0KSA9PiB7XG4gIHRbdmVyaWZpZWRTeW1ib2xdID0gdHJ1ZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBhYnN0cmFjdC1yZWxheS50c1xudmFyIEFic3RyYWN0UmVsYXkgPSBjbGFzcyB7XG4gIHVybDtcbiAgX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICBvbmNsb3NlID0gbnVsbDtcbiAgb25ub3RpY2UgPSAobXNnKSA9PiBjb25zb2xlLmRlYnVnKGBOT1RJQ0UgZnJvbSAke3RoaXMudXJsfTogJHttc2d9YCk7XG4gIF9vbmF1dGggPSBudWxsO1xuICBiYXNlRW9zZVRpbWVvdXQgPSA0NDAwO1xuICBjb25uZWN0aW9uVGltZW91dCA9IDQ0MDA7XG4gIHB1Ymxpc2hUaW1lb3V0ID0gNDQwMDtcbiAgb3BlblN1YnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25uZWN0aW9uVGltZW91dEhhbmRsZTtcbiAgY29ubmVjdGlvblByb21pc2U7XG4gIG9wZW5Db3VudFJlcXVlc3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgb3BlbkV2ZW50UHVibGlzaGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgd3M7XG4gIGluY29taW5nTWVzc2FnZVF1ZXVlID0gbmV3IFF1ZXVlKCk7XG4gIHF1ZXVlUnVubmluZyA9IGZhbHNlO1xuICBjaGFsbGVuZ2U7XG4gIGF1dGhQcm9taXNlO1xuICBzZXJpYWwgPSAwO1xuICB2ZXJpZnlFdmVudDtcbiAgX1dlYlNvY2tldDtcbiAgY29uc3RydWN0b3IodXJsLCBvcHRzKSB7XG4gICAgdGhpcy51cmwgPSBub3JtYWxpemVVUkwodXJsKTtcbiAgICB0aGlzLnZlcmlmeUV2ZW50ID0gb3B0cy52ZXJpZnlFdmVudDtcbiAgICB0aGlzLl9XZWJTb2NrZXQgPSBvcHRzLndlYnNvY2tldEltcGxlbWVudGF0aW9uIHx8IFdlYlNvY2tldDtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY29ubmVjdCh1cmwsIG9wdHMpIHtcbiAgICBjb25zdCByZWxheSA9IG5ldyBBYnN0cmFjdFJlbGF5KHVybCwgb3B0cyk7XG4gICAgYXdhaXQgcmVsYXkuY29ubmVjdCgpO1xuICAgIHJldHVybiByZWxheTtcbiAgfVxuICBjbG9zZUFsbFN1YnNjcmlwdGlvbnMocmVhc29uKSB7XG4gICAgZm9yIChsZXQgW18sIHN1Yl0gb2YgdGhpcy5vcGVuU3Vicykge1xuICAgICAgc3ViLmNsb3NlKHJlYXNvbik7XG4gICAgfVxuICAgIHRoaXMub3BlblN1YnMuY2xlYXIoKTtcbiAgICBmb3IgKGxldCBbXywgZXBdIG9mIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzKSB7XG4gICAgICBlcC5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgIH1cbiAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5jbGVhcigpO1xuICAgIGZvciAobGV0IFtfLCBjcl0gb2YgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cykge1xuICAgICAgY3IucmVqZWN0KG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICB9XG4gICAgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5jbGVhcigpO1xuICB9XG4gIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RlZDtcbiAgfVxuICBhc3luYyBjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25Qcm9taXNlKVxuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblByb21pc2U7XG4gICAgdGhpcy5jaGFsbGVuZ2UgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRoUHJvbWlzZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5jb25uZWN0aW9uVGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZWplY3QoXCJjb25uZWN0aW9uIHRpbWVkIG91dFwiKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5vbmNsb3NlPy4oKTtcbiAgICAgICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIHRpbWVkIG91dFwiKTtcbiAgICAgIH0sIHRoaXMuY29ubmVjdGlvblRpbWVvdXQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy53cyA9IG5ldyB0aGlzLl9XZWJTb2NrZXQodGhpcy51cmwpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLndzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvblRpbWVvdXRIYW5kbGUpO1xuICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy53cy5vbmVycm9yID0gKGV2KSA9PiB7XG4gICAgICAgIHJlamVjdChldi5tZXNzYWdlIHx8IFwid2Vic29ja2V0IGVycm9yXCIpO1xuICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgICB0aGlzLm9uY2xvc2U/LigpO1xuICAgICAgICAgIHRoaXMuY2xvc2VBbGxTdWJzY3JpcHRpb25zKFwicmVsYXkgY29ubmVjdGlvbiBlcnJvcmVkXCIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy53cy5vbmNsb3NlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgICB0aGlzLm9uY2xvc2U/LigpO1xuICAgICAgICAgIHRoaXMuY2xvc2VBbGxTdWJzY3JpcHRpb25zKFwicmVsYXkgY29ubmVjdGlvbiBjbG9zZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IHRoaXMuX29ubWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlO1xuICB9XG4gIGFzeW5jIHJ1blF1ZXVlKCkge1xuICAgIHRoaXMucXVldWVSdW5uaW5nID0gdHJ1ZTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGZhbHNlID09PSB0aGlzLmhhbmRsZU5leHQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGF3YWl0IHlpZWxkVGhyZWFkKCk7XG4gICAgfVxuICAgIHRoaXMucXVldWVSdW5uaW5nID0gZmFsc2U7XG4gIH1cbiAgaGFuZGxlTmV4dCgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5pbmNvbWluZ01lc3NhZ2VRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgaWYgKCFqc29uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHN1YmlkID0gZ2V0U3Vic2NyaXB0aW9uSWQoanNvbik7XG4gICAgaWYgKHN1YmlkKSB7XG4gICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KHN1YmlkKTtcbiAgICAgIGlmICghc28pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaWQgPSBnZXRIZXg2NChqc29uLCBcImlkXCIpO1xuICAgICAgY29uc3QgYWxyZWFkeUhhdmUgPSBzby5hbHJlYWR5SGF2ZUV2ZW50Py4oaWQpO1xuICAgICAgc28ucmVjZWl2ZWRFdmVudD8uKHRoaXMsIGlkKTtcbiAgICAgIGlmIChhbHJlYWR5SGF2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICBzd2l0Y2ggKGRhdGFbMF0pIHtcbiAgICAgICAgY2FzZSBcIkVWRU5UXCI6IHtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGRhdGFbMV0pO1xuICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZGF0YVsyXTtcbiAgICAgICAgICBpZiAodGhpcy52ZXJpZnlFdmVudChldmVudCkgJiYgbWF0Y2hGaWx0ZXJzKHNvLmZpbHRlcnMsIGV2ZW50KSkge1xuICAgICAgICAgICAgc28ub25ldmVudChldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiQ09VTlRcIjoge1xuICAgICAgICAgIGNvbnN0IGlkID0gZGF0YVsxXTtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YVsyXTtcbiAgICAgICAgICBjb25zdCBjciA9IHRoaXMub3BlbkNvdW50UmVxdWVzdHMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoY3IpIHtcbiAgICAgICAgICAgIGNyLnJlc29sdmUocGF5bG9hZC5jb3VudCk7XG4gICAgICAgICAgICB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiRU9TRVwiOiB7XG4gICAgICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChkYXRhWzFdKTtcbiAgICAgICAgICBpZiAoIXNvKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHNvLnJlY2VpdmVkRW9zZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiT0tcIjoge1xuICAgICAgICAgIGNvbnN0IGlkID0gZGF0YVsxXTtcbiAgICAgICAgICBjb25zdCBvayA9IGRhdGFbMl07XG4gICAgICAgICAgY29uc3QgcmVhc29uID0gZGF0YVszXTtcbiAgICAgICAgICBjb25zdCBlcCA9IHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmdldChpZCk7XG4gICAgICAgICAgaWYgKGVwKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZXAudGltZW91dCk7XG4gICAgICAgICAgICBpZiAob2spXG4gICAgICAgICAgICAgIGVwLnJlc29sdmUocmVhc29uKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgZXAucmVqZWN0KG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICAgICAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiQ0xPU0VEXCI6IHtcbiAgICAgICAgICBjb25zdCBpZCA9IGRhdGFbMV07XG4gICAgICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChpZCk7XG4gICAgICAgICAgaWYgKCFzbylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBzby5jbG9zZWQgPSB0cnVlO1xuICAgICAgICAgIHNvLmNsb3NlKGRhdGFbMl0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiTk9USUNFXCI6XG4gICAgICAgICAgdGhpcy5vbm5vdGljZShkYXRhWzFdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJBVVRIXCI6IHtcbiAgICAgICAgICB0aGlzLmNoYWxsZW5nZSA9IGRhdGFbMV07XG4gICAgICAgICAgdGhpcy5hdXRoUHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgICB0aGlzLl9vbmF1dGg/LihkYXRhWzFdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2VuZChtZXNzYWdlKSB7XG4gICAgaWYgKCF0aGlzLmNvbm5lY3Rpb25Qcm9taXNlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2VuZGluZyBvbiBjbG9zZWQgY29ubmVjdGlvblwiKTtcbiAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy53cz8uc2VuZChtZXNzYWdlKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBhdXRoKHNpZ25BdXRoRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuY2hhbGxlbmdlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgcGVyZm9ybSBhdXRoLCBubyBjaGFsbGVuZ2Ugd2FzIHJlY2VpdmVkXCIpO1xuICAgIGlmICh0aGlzLmF1dGhQcm9taXNlKVxuICAgICAgcmV0dXJuIHRoaXMuYXV0aFByb21pc2U7XG4gICAgY29uc3QgZXZ0ID0gYXdhaXQgc2lnbkF1dGhFdmVudChtYWtlQXV0aEV2ZW50KHRoaXMudXJsLCB0aGlzLmNoYWxsZW5nZSkpO1xuICAgIHRoaXMuYXV0aFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVwID0gdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZ2V0KGV2dC5pZCk7XG4gICAgICAgIGlmIChlcCkge1xuICAgICAgICAgIGVwLnJlamVjdChuZXcgRXJyb3IoXCJhdXRoIHRpbWVkIG91dFwiKSk7XG4gICAgICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZGVsZXRlKGV2dC5pZCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMucHVibGlzaFRpbWVvdXQpO1xuICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuc2V0KGV2dC5pZCwgeyByZXNvbHZlLCByZWplY3QsIHRpbWVvdXQgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kKCdbXCJBVVRIXCIsJyArIEpTT04uc3RyaW5naWZ5KGV2dCkgKyBcIl1cIik7XG4gICAgcmV0dXJuIHRoaXMuYXV0aFByb21pc2U7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChldmVudCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZXAgPSB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5nZXQoZXZlbnQuaWQpO1xuICAgICAgICBpZiAoZXApIHtcbiAgICAgICAgICBlcC5yZWplY3QobmV3IEVycm9yKFwicHVibGlzaCB0aW1lZCBvdXRcIikpO1xuICAgICAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmRlbGV0ZShldmVudC5pZCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMucHVibGlzaFRpbWVvdXQpO1xuICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuc2V0KGV2ZW50LmlkLCB7IHJlc29sdmUsIHJlamVjdCwgdGltZW91dCB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoJ1tcIkVWRU5UXCIsJyArIEpTT04uc3RyaW5naWZ5KGV2ZW50KSArIFwiXVwiKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGFzeW5jIGNvdW50KGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHRoaXMuc2VyaWFsKys7XG4gICAgY29uc3QgaWQgPSBwYXJhbXM/LmlkIHx8IFwiY291bnQ6XCIgKyB0aGlzLnNlcmlhbDtcbiAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLnNldChpZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kKCdbXCJDT1VOVFwiLFwiJyArIGlkICsgJ1wiLCcgKyBKU09OLnN0cmluZ2lmeShmaWx0ZXJzKS5zdWJzdHJpbmcoMSkpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgc3Vic2NyaWJlKGZpbHRlcnMsIHBhcmFtcykge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMucHJlcGFyZVN1YnNjcmlwdGlvbihmaWx0ZXJzLCBwYXJhbXMpO1xuICAgIHN1YnNjcmlwdGlvbi5maXJlKCk7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgfVxuICBwcmVwYXJlU3Vic2NyaXB0aW9uKGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHRoaXMuc2VyaWFsKys7XG4gICAgY29uc3QgaWQgPSBwYXJhbXMuaWQgfHwgKHBhcmFtcy5sYWJlbCA/IHBhcmFtcy5sYWJlbCArIFwiOlwiIDogXCJzdWI6XCIpICsgdGhpcy5zZXJpYWw7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbih0aGlzLCBpZCwgZmlsdGVycywgcGFyYW1zKTtcbiAgICB0aGlzLm9wZW5TdWJzLnNldChpZCwgc3Vic2NyaXB0aW9uKTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHRoaXMuY2xvc2VBbGxTdWJzY3JpcHRpb25zKFwicmVsYXkgY29ubmVjdGlvbiBjbG9zZWQgYnkgdXNcIik7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy53cz8uY2xvc2UoKTtcbiAgfVxuICBfb25tZXNzYWdlKGV2KSB7XG4gICAgdGhpcy5pbmNvbWluZ01lc3NhZ2VRdWV1ZS5lbnF1ZXVlKGV2LmRhdGEpO1xuICAgIGlmICghdGhpcy5xdWV1ZVJ1bm5pbmcpIHtcbiAgICAgIHRoaXMucnVuUXVldWUoKTtcbiAgICB9XG4gIH1cbn07XG52YXIgU3Vic2NyaXB0aW9uID0gY2xhc3Mge1xuICByZWxheTtcbiAgaWQ7XG4gIGNsb3NlZCA9IGZhbHNlO1xuICBlb3NlZCA9IGZhbHNlO1xuICBmaWx0ZXJzO1xuICBhbHJlYWR5SGF2ZUV2ZW50O1xuICByZWNlaXZlZEV2ZW50O1xuICBvbmV2ZW50O1xuICBvbmVvc2U7XG4gIG9uY2xvc2U7XG4gIGVvc2VUaW1lb3V0O1xuICBlb3NlVGltZW91dEhhbmRsZTtcbiAgY29uc3RydWN0b3IocmVsYXksIGlkLCBmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICB0aGlzLnJlbGF5ID0gcmVsYXk7XG4gICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5hbHJlYWR5SGF2ZUV2ZW50ID0gcGFyYW1zLmFscmVhZHlIYXZlRXZlbnQ7XG4gICAgdGhpcy5yZWNlaXZlZEV2ZW50ID0gcGFyYW1zLnJlY2VpdmVkRXZlbnQ7XG4gICAgdGhpcy5lb3NlVGltZW91dCA9IHBhcmFtcy5lb3NlVGltZW91dCB8fCByZWxheS5iYXNlRW9zZVRpbWVvdXQ7XG4gICAgdGhpcy5vbmVvc2UgPSBwYXJhbXMub25lb3NlO1xuICAgIHRoaXMub25jbG9zZSA9IHBhcmFtcy5vbmNsb3NlO1xuICAgIHRoaXMub25ldmVudCA9IHBhcmFtcy5vbmV2ZW50IHx8ICgoZXZlbnQpID0+IHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYG9uZXZlbnQoKSBjYWxsYmFjayBub3QgZGVmaW5lZCBmb3Igc3Vic2NyaXB0aW9uICcke3RoaXMuaWR9JyBpbiByZWxheSAke3RoaXMucmVsYXkudXJsfS4gZXZlbnQgcmVjZWl2ZWQ6YCxcbiAgICAgICAgZXZlbnRcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgZmlyZSgpIHtcbiAgICB0aGlzLnJlbGF5LnNlbmQoJ1tcIlJFUVwiLFwiJyArIHRoaXMuaWQgKyAnXCIsJyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZmlsdGVycykuc3Vic3RyaW5nKDEpKTtcbiAgICB0aGlzLmVvc2VUaW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCh0aGlzLnJlY2VpdmVkRW9zZS5iaW5kKHRoaXMpLCB0aGlzLmVvc2VUaW1lb3V0KTtcbiAgfVxuICByZWNlaXZlZEVvc2UoKSB7XG4gICAgaWYgKHRoaXMuZW9zZWQpXG4gICAgICByZXR1cm47XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZW9zZVRpbWVvdXRIYW5kbGUpO1xuICAgIHRoaXMuZW9zZWQgPSB0cnVlO1xuICAgIHRoaXMub25lb3NlPy4oKTtcbiAgfVxuICBjbG9zZShyZWFzb24gPSBcImNsb3NlZCBieSBjYWxsZXJcIikge1xuICAgIGlmICghdGhpcy5jbG9zZWQgJiYgdGhpcy5yZWxheS5jb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMucmVsYXkuc2VuZCgnW1wiQ0xPU0VcIiwnICsgSlNPTi5zdHJpbmdpZnkodGhpcy5pZCkgKyBcIl1cIik7XG4gICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMucmVsYXkub3BlblN1YnMuZGVsZXRlKHRoaXMuaWQpO1xuICAgIHRoaXMub25jbG9zZT8uKHJlYXNvbik7XG4gIH1cbn07XG5cbi8vIHJlbGF5LnRzXG52YXIgX1dlYlNvY2tldDtcbnRyeSB7XG4gIF9XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG59IGNhdGNoIHtcbn1cbnZhciBSZWxheSA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RSZWxheSB7XG4gIGNvbnN0cnVjdG9yKHVybCkge1xuICAgIHN1cGVyKHVybCwgeyB2ZXJpZnlFdmVudCwgd2Vic29ja2V0SW1wbGVtZW50YXRpb246IF9XZWJTb2NrZXQgfSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNvbm5lY3QodXJsKSB7XG4gICAgY29uc3QgcmVsYXkgPSBuZXcgUmVsYXkodXJsKTtcbiAgICBhd2FpdCByZWxheS5jb25uZWN0KCk7XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG59O1xuXG4vLyBhYnN0cmFjdC1wb29sLnRzXG52YXIgQWJzdHJhY3RTaW1wbGVQb29sID0gY2xhc3Mge1xuICByZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzZWVuT24gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB0cmFja1JlbGF5cyA9IGZhbHNlO1xuICB2ZXJpZnlFdmVudDtcbiAgdHJ1c3RlZFJlbGF5VVJMcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIF9XZWJTb2NrZXQ7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLnZlcmlmeUV2ZW50ID0gb3B0cy52ZXJpZnlFdmVudDtcbiAgICB0aGlzLl9XZWJTb2NrZXQgPSBvcHRzLndlYnNvY2tldEltcGxlbWVudGF0aW9uO1xuICB9XG4gIGFzeW5jIGVuc3VyZVJlbGF5KHVybCwgcGFyYW1zKSB7XG4gICAgdXJsID0gbm9ybWFsaXplVVJMKHVybCk7XG4gICAgbGV0IHJlbGF5ID0gdGhpcy5yZWxheXMuZ2V0KHVybCk7XG4gICAgaWYgKCFyZWxheSkge1xuICAgICAgcmVsYXkgPSBuZXcgQWJzdHJhY3RSZWxheSh1cmwsIHtcbiAgICAgICAgdmVyaWZ5RXZlbnQ6IHRoaXMudHJ1c3RlZFJlbGF5VVJMcy5oYXModXJsKSA/IGFsd2F5c1RydWUgOiB0aGlzLnZlcmlmeUV2ZW50LFxuICAgICAgICB3ZWJzb2NrZXRJbXBsZW1lbnRhdGlvbjogdGhpcy5fV2ViU29ja2V0XG4gICAgICB9KTtcbiAgICAgIGlmIChwYXJhbXM/LmNvbm5lY3Rpb25UaW1lb3V0KVxuICAgICAgICByZWxheS5jb25uZWN0aW9uVGltZW91dCA9IHBhcmFtcy5jb25uZWN0aW9uVGltZW91dDtcbiAgICAgIHRoaXMucmVsYXlzLnNldCh1cmwsIHJlbGF5KTtcbiAgICB9XG4gICAgYXdhaXQgcmVsYXkuY29ubmVjdCgpO1xuICAgIHJldHVybiByZWxheTtcbiAgfVxuICBjbG9zZShyZWxheXMpIHtcbiAgICByZWxheXMubWFwKG5vcm1hbGl6ZVVSTCkuZm9yRWFjaCgodXJsKSA9PiB7XG4gICAgICB0aGlzLnJlbGF5cy5nZXQodXJsKT8uY2xvc2UoKTtcbiAgICB9KTtcbiAgfVxuICBzdWJzY3JpYmUocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmliZU1hcChcbiAgICAgIHJlbGF5cy5tYXAoKHVybCkgPT4gKHsgdXJsLCBmaWx0ZXIgfSkpLFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgfVxuICBzdWJzY3JpYmVNYW55KHJlbGF5cywgZmlsdGVycywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlTWFwKFxuICAgICAgcmVsYXlzLmZsYXRNYXAoKHVybCkgPT4gZmlsdGVycy5tYXAoKGZpbHRlcikgPT4gKHsgdXJsLCBmaWx0ZXIgfSkpKSxcbiAgICAgIHBhcmFtc1xuICAgICk7XG4gIH1cbiAgc3Vic2NyaWJlTWFwKHJlcXVlc3RzLCBwYXJhbXMpIHtcbiAgICBpZiAodGhpcy50cmFja1JlbGF5cykge1xuICAgICAgcGFyYW1zLnJlY2VpdmVkRXZlbnQgPSAocmVsYXksIGlkKSA9PiB7XG4gICAgICAgIGxldCBzZXQgPSB0aGlzLnNlZW5Pbi5nZXQoaWQpO1xuICAgICAgICBpZiAoIXNldCkge1xuICAgICAgICAgIHNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgdGhpcy5zZWVuT24uc2V0KGlkLCBzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHNldC5hZGQocmVsYXkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgX2tub3duSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBzdWJzID0gW107XG4gICAgY29uc3QgZW9zZXNSZWNlaXZlZCA9IFtdO1xuICAgIGxldCBoYW5kbGVFb3NlID0gKGkyKSA9PiB7XG4gICAgICBpZiAoZW9zZXNSZWNlaXZlZFtpMl0pXG4gICAgICAgIHJldHVybjtcbiAgICAgIGVvc2VzUmVjZWl2ZWRbaTJdID0gdHJ1ZTtcbiAgICAgIGlmIChlb3Nlc1JlY2VpdmVkLmZpbHRlcigoYSkgPT4gYSkubGVuZ3RoID09PSByZXF1ZXN0cy5sZW5ndGgpIHtcbiAgICAgICAgcGFyYW1zLm9uZW9zZT8uKCk7XG4gICAgICAgIGhhbmRsZUVvc2UgPSAoKSA9PiB7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjbG9zZXNSZWNlaXZlZCA9IFtdO1xuICAgIGxldCBoYW5kbGVDbG9zZSA9IChpMiwgcmVhc29uKSA9PiB7XG4gICAgICBpZiAoY2xvc2VzUmVjZWl2ZWRbaTJdKVxuICAgICAgICByZXR1cm47XG4gICAgICBoYW5kbGVFb3NlKGkyKTtcbiAgICAgIGNsb3Nlc1JlY2VpdmVkW2kyXSA9IHJlYXNvbjtcbiAgICAgIGlmIChjbG9zZXNSZWNlaXZlZC5maWx0ZXIoKGEpID0+IGEpLmxlbmd0aCA9PT0gcmVxdWVzdHMubGVuZ3RoKSB7XG4gICAgICAgIHBhcmFtcy5vbmNsb3NlPy4oY2xvc2VzUmVjZWl2ZWQpO1xuICAgICAgICBoYW5kbGVDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxvY2FsQWxyZWFkeUhhdmVFdmVudEhhbmRsZXIgPSAoaWQpID0+IHtcbiAgICAgIGlmIChwYXJhbXMuYWxyZWFkeUhhdmVFdmVudD8uKGlkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhhdmUgPSBfa25vd25JZHMuaGFzKGlkKTtcbiAgICAgIF9rbm93bklkcy5hZGQoaWQpO1xuICAgICAgcmV0dXJuIGhhdmU7XG4gICAgfTtcbiAgICBjb25zdCBhbGxPcGVuZWQgPSBQcm9taXNlLmFsbChcbiAgICAgIHJlcXVlc3RzLm1hcChhc3luYyAoeyB1cmwsIGZpbHRlciB9LCBpMikgPT4ge1xuICAgICAgICB1cmwgPSBub3JtYWxpemVVUkwodXJsKTtcbiAgICAgICAgbGV0IHJlbGF5O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlbGF5ID0gYXdhaXQgdGhpcy5lbnN1cmVSZWxheSh1cmwsIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25UaW1lb3V0OiBwYXJhbXMubWF4V2FpdCA/IE1hdGgubWF4KHBhcmFtcy5tYXhXYWl0ICogMC44LCBwYXJhbXMubWF4V2FpdCAtIDFlMykgOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaGFuZGxlQ2xvc2UoaTIsIGVycj8ubWVzc2FnZSB8fCBTdHJpbmcoZXJyKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJzY3JpcHRpb24gPSByZWxheS5zdWJzY3JpYmUoW2ZpbHRlcl0sIHtcbiAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgb25lb3NlOiAoKSA9PiBoYW5kbGVFb3NlKGkyKSxcbiAgICAgICAgICBvbmNsb3NlOiAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVhc29uLnN0YXJ0c1dpdGgoXCJhdXRoLXJlcXVpcmVkOlwiKSAmJiBwYXJhbXMuZG9hdXRoKSB7XG4gICAgICAgICAgICAgIHJlbGF5LmF1dGgocGFyYW1zLmRvYXV0aCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVsYXkuc3Vic2NyaWJlKFtmaWx0ZXJdLCB7XG4gICAgICAgICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICAgICAgICBvbmVvc2U6ICgpID0+IGhhbmRsZUVvc2UoaTIpLFxuICAgICAgICAgICAgICAgICAgb25jbG9zZTogKHJlYXNvbjIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQ2xvc2UoaTIsIHJlYXNvbjIpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGFscmVhZHlIYXZlRXZlbnQ6IGxvY2FsQWxyZWFkeUhhdmVFdmVudEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICBlb3NlVGltZW91dDogcGFyYW1zLm1heFdhaXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZUNsb3NlKGkyLCBgYXV0aCB3YXMgcmVxdWlyZWQgYW5kIGF0dGVtcHRlZCwgYnV0IGZhaWxlZCB3aXRoOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoYW5kbGVDbG9zZShpMiwgcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGFscmVhZHlIYXZlRXZlbnQ6IGxvY2FsQWxyZWFkeUhhdmVFdmVudEhhbmRsZXIsXG4gICAgICAgICAgZW9zZVRpbWVvdXQ6IHBhcmFtcy5tYXhXYWl0XG4gICAgICAgIH0pO1xuICAgICAgICBzdWJzLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgIGF3YWl0IGFsbE9wZW5lZDtcbiAgICAgICAgc3Vicy5mb3JFYWNoKChzdWIpID0+IHtcbiAgICAgICAgICBzdWIuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBzdWJzY3JpYmVNYW55TWFwKHJlcXVlc3RzLCBwYXJhbXMpIHtcbiAgICBpZiAodGhpcy50cmFja1JlbGF5cykge1xuICAgICAgcGFyYW1zLnJlY2VpdmVkRXZlbnQgPSAocmVsYXksIGlkKSA9PiB7XG4gICAgICAgIGxldCBzZXQgPSB0aGlzLnNlZW5Pbi5nZXQoaWQpO1xuICAgICAgICBpZiAoIXNldCkge1xuICAgICAgICAgIHNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgdGhpcy5zZWVuT24uc2V0KGlkLCBzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHNldC5hZGQocmVsYXkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgX2tub3duSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBzdWJzID0gW107XG4gICAgY29uc3QgcmVsYXlzTGVuZ3RoID0gT2JqZWN0LmtleXMocmVxdWVzdHMpLmxlbmd0aDtcbiAgICBjb25zdCBlb3Nlc1JlY2VpdmVkID0gW107XG4gICAgbGV0IGhhbmRsZUVvc2UgPSAoaTIpID0+IHtcbiAgICAgIGlmIChlb3Nlc1JlY2VpdmVkW2kyXSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZW9zZXNSZWNlaXZlZFtpMl0gPSB0cnVlO1xuICAgICAgaWYgKGVvc2VzUmVjZWl2ZWQuZmlsdGVyKChhKSA9PiBhKS5sZW5ndGggPT09IHJlbGF5c0xlbmd0aCkge1xuICAgICAgICBwYXJhbXMub25lb3NlPy4oKTtcbiAgICAgICAgaGFuZGxlRW9zZSA9ICgpID0+IHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNsb3Nlc1JlY2VpdmVkID0gW107XG4gICAgbGV0IGhhbmRsZUNsb3NlID0gKGkyLCByZWFzb24pID0+IHtcbiAgICAgIGlmIChjbG9zZXNSZWNlaXZlZFtpMl0pXG4gICAgICAgIHJldHVybjtcbiAgICAgIGhhbmRsZUVvc2UoaTIpO1xuICAgICAgY2xvc2VzUmVjZWl2ZWRbaTJdID0gcmVhc29uO1xuICAgICAgaWYgKGNsb3Nlc1JlY2VpdmVkLmZpbHRlcigoYSkgPT4gYSkubGVuZ3RoID09PSByZWxheXNMZW5ndGgpIHtcbiAgICAgICAgcGFyYW1zLm9uY2xvc2U/LihjbG9zZXNSZWNlaXZlZCk7XG4gICAgICAgIGhhbmRsZUNsb3NlID0gKCkgPT4ge1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbG9jYWxBbHJlYWR5SGF2ZUV2ZW50SGFuZGxlciA9IChpZCkgPT4ge1xuICAgICAgaWYgKHBhcmFtcy5hbHJlYWR5SGF2ZUV2ZW50Py4oaWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaGF2ZSA9IF9rbm93bklkcy5oYXMoaWQpO1xuICAgICAgX2tub3duSWRzLmFkZChpZCk7XG4gICAgICByZXR1cm4gaGF2ZTtcbiAgICB9O1xuICAgIGNvbnN0IGFsbE9wZW5lZCA9IFByb21pc2UuYWxsKFxuICAgICAgT2JqZWN0LmVudHJpZXMocmVxdWVzdHMpLm1hcChhc3luYyAocmVxLCBpMiwgYXJyKSA9PiB7XG4gICAgICAgIGlmIChhcnIuaW5kZXhPZihyZXEpICE9PSBpMikge1xuICAgICAgICAgIGhhbmRsZUNsb3NlKGkyLCBcImR1cGxpY2F0ZSB1cmxcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBbdXJsLCBmaWx0ZXJzXSA9IHJlcTtcbiAgICAgICAgdXJsID0gbm9ybWFsaXplVVJMKHVybCk7XG4gICAgICAgIGxldCByZWxheTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZWxheSA9IGF3YWl0IHRoaXMuZW5zdXJlUmVsYXkodXJsLCB7XG4gICAgICAgICAgICBjb25uZWN0aW9uVGltZW91dDogcGFyYW1zLm1heFdhaXQgPyBNYXRoLm1heChwYXJhbXMubWF4V2FpdCAqIDAuOCwgcGFyYW1zLm1heFdhaXQgLSAxZTMpIDogdm9pZCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGhhbmRsZUNsb3NlKGkyLCBlcnI/Lm1lc3NhZ2UgfHwgU3RyaW5nKGVycikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3Vic2NyaXB0aW9uID0gcmVsYXkuc3Vic2NyaWJlKGZpbHRlcnMsIHtcbiAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgb25lb3NlOiAoKSA9PiBoYW5kbGVFb3NlKGkyKSxcbiAgICAgICAgICBvbmNsb3NlOiAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVhc29uLnN0YXJ0c1dpdGgoXCJhdXRoLXJlcXVpcmVkOlwiKSAmJiBwYXJhbXMuZG9hdXRoKSB7XG4gICAgICAgICAgICAgIHJlbGF5LmF1dGgocGFyYW1zLmRvYXV0aCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVsYXkuc3Vic2NyaWJlKGZpbHRlcnMsIHtcbiAgICAgICAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgICAgICAgIG9uZW9zZTogKCkgPT4gaGFuZGxlRW9zZShpMiksXG4gICAgICAgICAgICAgICAgICBvbmNsb3NlOiAocmVhc29uMikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVDbG9zZShpMiwgcmVhc29uMik7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgYWxyZWFkeUhhdmVFdmVudDogbG9jYWxBbHJlYWR5SGF2ZUV2ZW50SGFuZGxlcixcbiAgICAgICAgICAgICAgICAgIGVvc2VUaW1lb3V0OiBwYXJhbXMubWF4V2FpdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlQ2xvc2UoaTIsIGBhdXRoIHdhcyByZXF1aXJlZCBhbmQgYXR0ZW1wdGVkLCBidXQgZmFpbGVkIHdpdGg6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhhbmRsZUNsb3NlKGkyLCByZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYWxyZWFkeUhhdmVFdmVudDogbG9jYWxBbHJlYWR5SGF2ZUV2ZW50SGFuZGxlcixcbiAgICAgICAgICBlb3NlVGltZW91dDogcGFyYW1zLm1heFdhaXRcbiAgICAgICAgfSk7XG4gICAgICAgIHN1YnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgYXdhaXQgYWxsT3BlbmVkO1xuICAgICAgICBzdWJzLmZvckVhY2goKHN1YikgPT4ge1xuICAgICAgICAgIHN1Yi5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHN1YnNjcmliZUVvc2UocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcykge1xuICAgIGNvbnN0IHN1YmNsb3NlciA9IHRoaXMuc3Vic2NyaWJlKHJlbGF5cywgZmlsdGVyLCB7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBvbmVvc2UoKSB7XG4gICAgICAgIHN1YmNsb3Nlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdWJjbG9zZXI7XG4gIH1cbiAgc3Vic2NyaWJlTWFueUVvc2UocmVsYXlzLCBmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICBjb25zdCBzdWJjbG9zZXIgPSB0aGlzLnN1YnNjcmliZU1hbnkocmVsYXlzLCBmaWx0ZXJzLCB7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBvbmVvc2UoKSB7XG4gICAgICAgIHN1YmNsb3Nlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdWJjbG9zZXI7XG4gIH1cbiAgYXN5bmMgcXVlcnlTeW5jKHJlbGF5cywgZmlsdGVyLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgICAgdGhpcy5zdWJzY3JpYmVFb3NlKHJlbGF5cywgZmlsdGVyLCB7XG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgb25ldmVudChldmVudCkge1xuICAgICAgICAgIGV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25jbG9zZShfKSB7XG4gICAgICAgICAgcmVzb2x2ZShldmVudHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXQocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcykge1xuICAgIGZpbHRlci5saW1pdCA9IDE7XG4gICAgY29uc3QgZXZlbnRzID0gYXdhaXQgdGhpcy5xdWVyeVN5bmMocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcyk7XG4gICAgZXZlbnRzLnNvcnQoKGEsIGIpID0+IGIuY3JlYXRlZF9hdCAtIGEuY3JlYXRlZF9hdCk7XG4gICAgcmV0dXJuIGV2ZW50c1swXSB8fCBudWxsO1xuICB9XG4gIHB1Ymxpc2gocmVsYXlzLCBldmVudCkge1xuICAgIHJldHVybiByZWxheXMubWFwKG5vcm1hbGl6ZVVSTCkubWFwKGFzeW5jICh1cmwsIGkyLCBhcnIpID0+IHtcbiAgICAgIGlmIChhcnIuaW5kZXhPZih1cmwpICE9PSBpMikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJkdXBsaWNhdGUgdXJsXCIpO1xuICAgICAgfVxuICAgICAgbGV0IHIgPSBhd2FpdCB0aGlzLmVuc3VyZVJlbGF5KHVybCk7XG4gICAgICByZXR1cm4gci5wdWJsaXNoKGV2ZW50KS50aGVuKChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tSZWxheXMpIHtcbiAgICAgICAgICBsZXQgc2V0ID0gdGhpcy5zZWVuT24uZ2V0KGV2ZW50LmlkKTtcbiAgICAgICAgICBpZiAoIXNldCkge1xuICAgICAgICAgICAgc2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHRoaXMuc2Vlbk9uLnNldChldmVudC5pZCwgc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0LmFkZChyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVhc29uO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgbGlzdENvbm5lY3Rpb25TdGF0dXMoKSB7XG4gICAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnJlbGF5cy5mb3JFYWNoKChyZWxheSwgdXJsKSA9PiBtYXAuc2V0KHVybCwgcmVsYXkuY29ubmVjdGVkKSk7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVsYXlzLmZvckVhY2goKGNvbm4pID0+IGNvbm4uY2xvc2UoKSk7XG4gICAgdGhpcy5yZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG59O1xuXG4vLyBwb29sLnRzXG52YXIgX1dlYlNvY2tldDI7XG50cnkge1xuICBfV2ViU29ja2V0MiA9IFdlYlNvY2tldDtcbn0gY2F0Y2gge1xufVxudmFyIFNpbXBsZVBvb2wgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0U2ltcGxlUG9vbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHsgdmVyaWZ5RXZlbnQsIHdlYnNvY2tldEltcGxlbWVudGF0aW9uOiBfV2ViU29ja2V0MiB9KTtcbiAgfVxufTtcblxuLy8gbmlwMTkudHNcbnZhciBuaXAxOV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxOV9leHBvcnRzLCB7XG4gIEJFQ0gzMl9SRUdFWDogKCkgPT4gQkVDSDMyX1JFR0VYLFxuICBCZWNoMzJNYXhTaXplOiAoKSA9PiBCZWNoMzJNYXhTaXplLFxuICBOb3N0clR5cGVHdWFyZDogKCkgPT4gTm9zdHJUeXBlR3VhcmQsXG4gIGRlY29kZTogKCkgPT4gZGVjb2RlLFxuICBkZWNvZGVOb3N0clVSSTogKCkgPT4gZGVjb2RlTm9zdHJVUkksXG4gIGVuY29kZUJ5dGVzOiAoKSA9PiBlbmNvZGVCeXRlcyxcbiAgbmFkZHJFbmNvZGU6ICgpID0+IG5hZGRyRW5jb2RlLFxuICBuZXZlbnRFbmNvZGU6ICgpID0+IG5ldmVudEVuY29kZSxcbiAgbm90ZUVuY29kZTogKCkgPT4gbm90ZUVuY29kZSxcbiAgbnByb2ZpbGVFbmNvZGU6ICgpID0+IG5wcm9maWxlRW5jb2RlLFxuICBucHViRW5jb2RlOiAoKSA9PiBucHViRW5jb2RlLFxuICBuc2VjRW5jb2RlOiAoKSA9PiBuc2VjRW5jb2RlXG59KTtcbmltcG9ydCB7IGJ5dGVzVG9IZXggYXMgYnl0ZXNUb0hleDIsIGNvbmNhdEJ5dGVzLCBoZXhUb0J5dGVzIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IGJlY2gzMiB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIE5vc3RyVHlwZUd1YXJkID0ge1xuICBpc05Qcm9maWxlOiAodmFsdWUpID0+IC9ebnByb2ZpbGUxW2EtelxcZF0rJC8udGVzdCh2YWx1ZSB8fCBcIlwiKSxcbiAgaXNORXZlbnQ6ICh2YWx1ZSkgPT4gL15uZXZlbnQxW2EtelxcZF0rJC8udGVzdCh2YWx1ZSB8fCBcIlwiKSxcbiAgaXNOQWRkcjogKHZhbHVlKSA9PiAvXm5hZGRyMVthLXpcXGRdKyQvLnRlc3QodmFsdWUgfHwgXCJcIiksXG4gIGlzTlNlYzogKHZhbHVlKSA9PiAvXm5zZWMxW2EtelxcZF17NTh9JC8udGVzdCh2YWx1ZSB8fCBcIlwiKSxcbiAgaXNOUHViOiAodmFsdWUpID0+IC9ebnB1YjFbYS16XFxkXXs1OH0kLy50ZXN0KHZhbHVlIHx8IFwiXCIpLFxuICBpc05vdGU6ICh2YWx1ZSkgPT4gL15ub3RlMVthLXpcXGRdKyQvLnRlc3QodmFsdWUgfHwgXCJcIiksXG4gIGlzTmNyeXB0c2VjOiAodmFsdWUpID0+IC9ebmNyeXB0c2VjMVthLXpcXGRdKyQvLnRlc3QodmFsdWUgfHwgXCJcIilcbn07XG52YXIgQmVjaDMyTWF4U2l6ZSA9IDVlMztcbnZhciBCRUNIMzJfUkVHRVggPSAvW1xceDIxLVxceDdFXXsxLDgzfTFbMDIzNDU2Nzg5YWNkZWZnaGprbG1ucHFyc3R1dnd4eXpdezYsfS87XG5mdW5jdGlvbiBpbnRlZ2VyVG9VaW50OEFycmF5KG51bWJlcikge1xuICBjb25zdCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIHVpbnQ4QXJyYXlbMF0gPSBudW1iZXIgPj4gMjQgJiAyNTU7XG4gIHVpbnQ4QXJyYXlbMV0gPSBudW1iZXIgPj4gMTYgJiAyNTU7XG4gIHVpbnQ4QXJyYXlbMl0gPSBudW1iZXIgPj4gOCAmIDI1NTtcbiAgdWludDhBcnJheVszXSA9IG51bWJlciAmIDI1NTtcbiAgcmV0dXJuIHVpbnQ4QXJyYXk7XG59XG5mdW5jdGlvbiBkZWNvZGVOb3N0clVSSShuaXAxOWNvZGUpIHtcbiAgdHJ5IHtcbiAgICBpZiAobmlwMTljb2RlLnN0YXJ0c1dpdGgoXCJub3N0cjpcIikpXG4gICAgICBuaXAxOWNvZGUgPSBuaXAxOWNvZGUuc3Vic3RyaW5nKDYpO1xuICAgIHJldHVybiBkZWNvZGUobmlwMTljb2RlKTtcbiAgfSBjYXRjaCAoX2Vycikge1xuICAgIHJldHVybiB7IHR5cGU6IFwiaW52YWxpZFwiLCBkYXRhOiBudWxsIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGRlY29kZShuaXAxOSkge1xuICBsZXQgeyBwcmVmaXgsIHdvcmRzIH0gPSBiZWNoMzIuZGVjb2RlKG5pcDE5LCBCZWNoMzJNYXhTaXplKTtcbiAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheShiZWNoMzIuZnJvbVdvcmRzKHdvcmRzKSk7XG4gIHN3aXRjaCAocHJlZml4KSB7XG4gICAgY2FzZSBcIm5wcm9maWxlXCI6IHtcbiAgICAgIGxldCB0bHYgPSBwYXJzZVRMVihkYXRhKTtcbiAgICAgIGlmICghdGx2WzBdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5wcm9maWxlXCIpO1xuICAgICAgaWYgKHRsdlswXVswXS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMCBzaG91bGQgYmUgMzIgYnl0ZXNcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5wcm9maWxlXCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBwdWJrZXk6IGJ5dGVzVG9IZXgyKHRsdlswXVswXSksXG4gICAgICAgICAgcmVsYXlzOiB0bHZbMV0gPyB0bHZbMV0ubWFwKChkKSA9PiB1dGY4RGVjb2Rlci5kZWNvZGUoZCkpIDogW11cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIm5ldmVudFwiOiB7XG4gICAgICBsZXQgdGx2ID0gcGFyc2VUTFYoZGF0YSk7XG4gICAgICBpZiAoIXRsdlswXT8uWzBdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAwIGZvciBuZXZlbnRcIik7XG4gICAgICBpZiAodGx2WzBdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAwIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIGlmICh0bHZbMl0gJiYgdGx2WzJdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAyIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIGlmICh0bHZbM10gJiYgdGx2WzNdWzBdLmxlbmd0aCAhPT0gNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDMgc2hvdWxkIGJlIDQgYnl0ZXNcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5ldmVudFwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWQ6IGJ5dGVzVG9IZXgyKHRsdlswXVswXSksXG4gICAgICAgICAgcmVsYXlzOiB0bHZbMV0gPyB0bHZbMV0ubWFwKChkKSA9PiB1dGY4RGVjb2Rlci5kZWNvZGUoZCkpIDogW10sXG4gICAgICAgICAgYXV0aG9yOiB0bHZbMl0/LlswXSA/IGJ5dGVzVG9IZXgyKHRsdlsyXVswXSkgOiB2b2lkIDAsXG4gICAgICAgICAga2luZDogdGx2WzNdPy5bMF0gPyBwYXJzZUludChieXRlc1RvSGV4Mih0bHZbM11bMF0pLCAxNikgOiB2b2lkIDBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIm5hZGRyXCI6IHtcbiAgICAgIGxldCB0bHYgPSBwYXJzZVRMVihkYXRhKTtcbiAgICAgIGlmICghdGx2WzBdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5hZGRyXCIpO1xuICAgICAgaWYgKCF0bHZbMl0/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMiBmb3IgbmFkZHJcIik7XG4gICAgICBpZiAodGx2WzJdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAyIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIGlmICghdGx2WzNdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDMgZm9yIG5hZGRyXCIpO1xuICAgICAgaWYgKHRsdlszXVswXS5sZW5ndGggIT09IDQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAzIHNob3VsZCBiZSA0IGJ5dGVzXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJuYWRkclwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWRlbnRpZmllcjogdXRmOERlY29kZXIuZGVjb2RlKHRsdlswXVswXSksXG4gICAgICAgICAgcHVia2V5OiBieXRlc1RvSGV4Mih0bHZbMl1bMF0pLFxuICAgICAgICAgIGtpbmQ6IHBhcnNlSW50KGJ5dGVzVG9IZXgyKHRsdlszXVswXSksIDE2KSxcbiAgICAgICAgICByZWxheXM6IHRsdlsxXSA/IHRsdlsxXS5tYXAoKGQpID0+IHV0ZjhEZWNvZGVyLmRlY29kZShkKSkgOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibnNlY1wiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogcHJlZml4LCBkYXRhIH07XG4gICAgY2FzZSBcIm5wdWJcIjpcbiAgICBjYXNlIFwibm90ZVwiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogcHJlZml4LCBkYXRhOiBieXRlc1RvSGV4MihkYXRhKSB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gcHJlZml4ICR7cHJlZml4fWApO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVRMVihkYXRhKSB7XG4gIGxldCByZXN1bHQgPSB7fTtcbiAgbGV0IHJlc3QgPSBkYXRhO1xuICB3aGlsZSAocmVzdC5sZW5ndGggPiAwKSB7XG4gICAgbGV0IHQgPSByZXN0WzBdO1xuICAgIGxldCBsID0gcmVzdFsxXTtcbiAgICBsZXQgdiA9IHJlc3Quc2xpY2UoMiwgMiArIGwpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDIgKyBsKTtcbiAgICBpZiAodi5sZW5ndGggPCBsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3QgZW5vdWdoIGRhdGEgdG8gcmVhZCBvbiBUTFYgJHt0fWApO1xuICAgIHJlc3VsdFt0XSA9IHJlc3VsdFt0XSB8fCBbXTtcbiAgICByZXN1bHRbdF0ucHVzaCh2KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbnNlY0VuY29kZShrZXkpIHtcbiAgcmV0dXJuIGVuY29kZUJ5dGVzKFwibnNlY1wiLCBrZXkpO1xufVxuZnVuY3Rpb24gbnB1YkVuY29kZShoZXgpIHtcbiAgcmV0dXJuIGVuY29kZUJ5dGVzKFwibnB1YlwiLCBoZXhUb0J5dGVzKGhleCkpO1xufVxuZnVuY3Rpb24gbm90ZUVuY29kZShoZXgpIHtcbiAgcmV0dXJuIGVuY29kZUJ5dGVzKFwibm90ZVwiLCBoZXhUb0J5dGVzKGhleCkpO1xufVxuZnVuY3Rpb24gZW5jb2RlQmVjaDMyKHByZWZpeCwgZGF0YSkge1xuICBsZXQgd29yZHMgPSBiZWNoMzIudG9Xb3JkcyhkYXRhKTtcbiAgcmV0dXJuIGJlY2gzMi5lbmNvZGUocHJlZml4LCB3b3JkcywgQmVjaDMyTWF4U2l6ZSk7XG59XG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhwcmVmaXgsIGJ5dGVzKSB7XG4gIHJldHVybiBlbmNvZGVCZWNoMzIocHJlZml4LCBieXRlcyk7XG59XG5mdW5jdGlvbiBucHJvZmlsZUVuY29kZShwcm9maWxlKSB7XG4gIGxldCBkYXRhID0gZW5jb2RlVExWKHtcbiAgICAwOiBbaGV4VG9CeXRlcyhwcm9maWxlLnB1YmtleSldLFxuICAgIDE6IChwcm9maWxlLnJlbGF5cyB8fCBbXSkubWFwKCh1cmwpID0+IHV0ZjhFbmNvZGVyLmVuY29kZSh1cmwpKVxuICB9KTtcbiAgcmV0dXJuIGVuY29kZUJlY2gzMihcIm5wcm9maWxlXCIsIGRhdGEpO1xufVxuZnVuY3Rpb24gbmV2ZW50RW5jb2RlKGV2ZW50KSB7XG4gIGxldCBraW5kQXJyYXk7XG4gIGlmIChldmVudC5raW5kICE9PSB2b2lkIDApIHtcbiAgICBraW5kQXJyYXkgPSBpbnRlZ2VyVG9VaW50OEFycmF5KGV2ZW50LmtpbmQpO1xuICB9XG4gIGxldCBkYXRhID0gZW5jb2RlVExWKHtcbiAgICAwOiBbaGV4VG9CeXRlcyhldmVudC5pZCldLFxuICAgIDE6IChldmVudC5yZWxheXMgfHwgW10pLm1hcCgodXJsKSA9PiB1dGY4RW5jb2Rlci5lbmNvZGUodXJsKSksXG4gICAgMjogZXZlbnQuYXV0aG9yID8gW2hleFRvQnl0ZXMoZXZlbnQuYXV0aG9yKV0gOiBbXSxcbiAgICAzOiBraW5kQXJyYXkgPyBbbmV3IFVpbnQ4QXJyYXkoa2luZEFycmF5KV0gOiBbXVxuICB9KTtcbiAgcmV0dXJuIGVuY29kZUJlY2gzMihcIm5ldmVudFwiLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIG5hZGRyRW5jb2RlKGFkZHIpIHtcbiAgbGV0IGtpbmQgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gIG5ldyBEYXRhVmlldyhraW5kKS5zZXRVaW50MzIoMCwgYWRkci5raW5kLCBmYWxzZSk7XG4gIGxldCBkYXRhID0gZW5jb2RlVExWKHtcbiAgICAwOiBbdXRmOEVuY29kZXIuZW5jb2RlKGFkZHIuaWRlbnRpZmllcildLFxuICAgIDE6IChhZGRyLnJlbGF5cyB8fCBbXSkubWFwKCh1cmwpID0+IHV0ZjhFbmNvZGVyLmVuY29kZSh1cmwpKSxcbiAgICAyOiBbaGV4VG9CeXRlcyhhZGRyLnB1YmtleSldLFxuICAgIDM6IFtuZXcgVWludDhBcnJheShraW5kKV1cbiAgfSk7XG4gIHJldHVybiBlbmNvZGVCZWNoMzIoXCJuYWRkclwiLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVRMVih0bHYpIHtcbiAgbGV0IGVudHJpZXMgPSBbXTtcbiAgT2JqZWN0LmVudHJpZXModGx2KS5yZXZlcnNlKCkuZm9yRWFjaCgoW3QsIHZzXSkgPT4ge1xuICAgIHZzLmZvckVhY2goKHYpID0+IHtcbiAgICAgIGxldCBlbnRyeSA9IG5ldyBVaW50OEFycmF5KHYubGVuZ3RoICsgMik7XG4gICAgICBlbnRyeS5zZXQoW3BhcnNlSW50KHQpXSwgMCk7XG4gICAgICBlbnRyeS5zZXQoW3YubGVuZ3RoXSwgMSk7XG4gICAgICBlbnRyeS5zZXQodiwgMik7XG4gICAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGNvbmNhdEJ5dGVzKC4uLmVudHJpZXMpO1xufVxuXG4vLyByZWZlcmVuY2VzLnRzXG52YXIgbWVudGlvblJlZ2V4ID0gL1xcYm5vc3RyOigobm90ZXxucHVifG5hZGRyfG5ldmVudHxucHJvZmlsZSkxXFx3KylcXGJ8I1xcWyhcXGQrKVxcXS9nO1xuZnVuY3Rpb24gcGFyc2VSZWZlcmVuY2VzKGV2dCkge1xuICBsZXQgcmVmZXJlbmNlcyA9IFtdO1xuICBmb3IgKGxldCByZWYgb2YgZXZ0LmNvbnRlbnQubWF0Y2hBbGwobWVudGlvblJlZ2V4KSkge1xuICAgIGlmIChyZWZbMl0pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCB7IHR5cGUsIGRhdGEgfSA9IGRlY29kZShyZWZbMV0pO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwibnB1YlwiOiB7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIHByb2ZpbGU6IHsgcHVia2V5OiBkYXRhLCByZWxheXM6IFtdIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJucHJvZmlsZVwiOiB7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIHByb2ZpbGU6IGRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJub3RlXCI6IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgZXZlbnQ6IHsgaWQ6IGRhdGEsIHJlbGF5czogW10gfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm5ldmVudFwiOiB7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIGV2ZW50OiBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibmFkZHJcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBhZGRyZXNzOiBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWZbM10pIHtcbiAgICAgIGxldCBpZHggPSBwYXJzZUludChyZWZbM10sIDEwKTtcbiAgICAgIGxldCB0YWcgPSBldnQudGFnc1tpZHhdO1xuICAgICAgaWYgKCF0YWcpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgc3dpdGNoICh0YWdbMF0pIHtcbiAgICAgICAgY2FzZSBcInBcIjoge1xuICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICBwcm9maWxlOiB7IHB1YmtleTogdGFnWzFdLCByZWxheXM6IHRhZ1syXSA/IFt0YWdbMl1dIDogW10gfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJlXCI6IHtcbiAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgZXZlbnQ6IHsgaWQ6IHRhZ1sxXSwgcmVsYXlzOiB0YWdbMl0gPyBbdGFnWzJdXSA6IFtdIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYVwiOiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBba2luZCwgcHVia2V5LCBpZGVudGlmaWVyXSA9IHRhZ1sxXS5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIGFkZHJlc3M6IHtcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICAgICAgICBraW5kOiBwYXJzZUludChraW5kLCAxMCksXG4gICAgICAgICAgICAgICAgcmVsYXlzOiB0YWdbMl0gPyBbdGFnWzJdXSA6IFtdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVmZXJlbmNlcztcbn1cblxuLy8gbmlwMDQudHNcbnZhciBuaXAwNF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAwNF9leHBvcnRzLCB7XG4gIGRlY3J5cHQ6ICgpID0+IGRlY3J5cHQsXG4gIGVuY3J5cHQ6ICgpID0+IGVuY3J5cHRcbn0pO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4MywgcmFuZG9tQnl0ZXMgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XG5pbXBvcnQgeyBjYmMgfSBmcm9tIFwiQG5vYmxlL2NpcGhlcnMvYWVzXCI7XG5pbXBvcnQgeyBiYXNlNjQgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbmZ1bmN0aW9uIGVuY3J5cHQoc2VjcmV0S2V5LCBwdWJrZXksIHRleHQpIHtcbiAgY29uc3QgcHJpdmtleSA9IHNlY3JldEtleSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBieXRlc1RvSGV4MyhzZWNyZXRLZXkpIDogc2VjcmV0S2V5O1xuICBjb25zdCBrZXkgPSBzZWNwMjU2azEuZ2V0U2hhcmVkU2VjcmV0KHByaXZrZXksIFwiMDJcIiArIHB1YmtleSk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBnZXROb3JtYWxpemVkWChrZXkpO1xuICBsZXQgaXYgPSBVaW50OEFycmF5LmZyb20ocmFuZG9tQnl0ZXMoMTYpKTtcbiAgbGV0IHBsYWludGV4dCA9IHV0ZjhFbmNvZGVyLmVuY29kZSh0ZXh0KTtcbiAgbGV0IGNpcGhlcnRleHQgPSBjYmMobm9ybWFsaXplZEtleSwgaXYpLmVuY3J5cHQocGxhaW50ZXh0KTtcbiAgbGV0IGN0YjY0ID0gYmFzZTY0LmVuY29kZShuZXcgVWludDhBcnJheShjaXBoZXJ0ZXh0KSk7XG4gIGxldCBpdmI2NCA9IGJhc2U2NC5lbmNvZGUobmV3IFVpbnQ4QXJyYXkoaXYuYnVmZmVyKSk7XG4gIHJldHVybiBgJHtjdGI2NH0/aXY9JHtpdmI2NH1gO1xufVxuZnVuY3Rpb24gZGVjcnlwdChzZWNyZXRLZXksIHB1YmtleSwgZGF0YSkge1xuICBjb25zdCBwcml2a2V5ID0gc2VjcmV0S2V5IGluc3RhbmNlb2YgVWludDhBcnJheSA/IGJ5dGVzVG9IZXgzKHNlY3JldEtleSkgOiBzZWNyZXRLZXk7XG4gIGxldCBbY3RiNjQsIGl2YjY0XSA9IGRhdGEuc3BsaXQoXCI/aXY9XCIpO1xuICBsZXQga2V5ID0gc2VjcDI1NmsxLmdldFNoYXJlZFNlY3JldChwcml2a2V5LCBcIjAyXCIgKyBwdWJrZXkpO1xuICBsZXQgbm9ybWFsaXplZEtleSA9IGdldE5vcm1hbGl6ZWRYKGtleSk7XG4gIGxldCBpdiA9IGJhc2U2NC5kZWNvZGUoaXZiNjQpO1xuICBsZXQgY2lwaGVydGV4dCA9IGJhc2U2NC5kZWNvZGUoY3RiNjQpO1xuICBsZXQgcGxhaW50ZXh0ID0gY2JjKG5vcm1hbGl6ZWRLZXksIGl2KS5kZWNyeXB0KGNpcGhlcnRleHQpO1xuICByZXR1cm4gdXRmOERlY29kZXIuZGVjb2RlKHBsYWludGV4dCk7XG59XG5mdW5jdGlvbiBnZXROb3JtYWxpemVkWChrZXkpIHtcbiAgcmV0dXJuIGtleS5zbGljZSgxLCAzMyk7XG59XG5cbi8vIG5pcDA1LnRzXG52YXIgbmlwMDVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMDVfZXhwb3J0cywge1xuICBOSVAwNV9SRUdFWDogKCkgPT4gTklQMDVfUkVHRVgsXG4gIGlzTmlwMDU6ICgpID0+IGlzTmlwMDUsXG4gIGlzVmFsaWQ6ICgpID0+IGlzVmFsaWQsXG4gIHF1ZXJ5UHJvZmlsZTogKCkgPT4gcXVlcnlQcm9maWxlLFxuICBzZWFyY2hEb21haW46ICgpID0+IHNlYXJjaERvbWFpbixcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvblxufSk7XG52YXIgTklQMDVfUkVHRVggPSAvXig/OihbXFx3ListXSspQCk/KFtcXHdfLV0rKFxcLltcXHdfLV0rKSspJC87XG52YXIgaXNOaXAwNSA9ICh2YWx1ZSkgPT4gTklQMDVfUkVHRVgudGVzdCh2YWx1ZSB8fCBcIlwiKTtcbnZhciBfZmV0Y2g7XG50cnkge1xuICBfZmV0Y2ggPSBmZXRjaDtcbn0gY2F0Y2ggKF8pIHtcbiAgbnVsbDtcbn1cbmZ1bmN0aW9uIHVzZUZldGNoSW1wbGVtZW50YXRpb24oZmV0Y2hJbXBsZW1lbnRhdGlvbikge1xuICBfZmV0Y2ggPSBmZXRjaEltcGxlbWVudGF0aW9uO1xufVxuYXN5bmMgZnVuY3Rpb24gc2VhcmNoRG9tYWluKGRvbWFpbiwgcXVlcnkgPSBcIlwiKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vJHtkb21haW59Ly53ZWxsLWtub3duL25vc3RyLmpzb24/bmFtZT0ke3F1ZXJ5fWA7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgX2ZldGNoKHVybCwgeyByZWRpcmVjdDogXCJtYW51YWxcIiB9KTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIldyb25nIHJlc3BvbnNlIGNvZGVcIik7XG4gICAgfVxuICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiBqc29uLm5hbWVzO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBxdWVyeVByb2ZpbGUoZnVsbG5hbWUpIHtcbiAgY29uc3QgbWF0Y2ggPSBmdWxsbmFtZS5tYXRjaChOSVAwNV9SRUdFWCk7XG4gIGlmICghbWF0Y2gpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IFssIG5hbWUgPSBcIl9cIiwgZG9tYWluXSA9IG1hdGNoO1xuICB0cnkge1xuICAgIGNvbnN0IHVybCA9IGBodHRwczovLyR7ZG9tYWlufS8ud2VsbC1rbm93bi9ub3N0ci5qc29uP25hbWU9JHtuYW1lfWA7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgX2ZldGNoKHVybCwgeyByZWRpcmVjdDogXCJtYW51YWxcIiB9KTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIldyb25nIHJlc3BvbnNlIGNvZGVcIik7XG4gICAgfVxuICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IHB1YmtleSA9IGpzb24ubmFtZXNbbmFtZV07XG4gICAgcmV0dXJuIHB1YmtleSA/IHsgcHVia2V5LCByZWxheXM6IGpzb24ucmVsYXlzPy5bcHVia2V5XSB9IDogbnVsbDtcbiAgfSBjYXRjaCAoX2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaXNWYWxpZChwdWJrZXksIG5pcDA1KSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHF1ZXJ5UHJvZmlsZShuaXAwNSk7XG4gIHJldHVybiByZXMgPyByZXMucHVia2V5ID09PSBwdWJrZXkgOiBmYWxzZTtcbn1cblxuLy8gbmlwMTAudHNcbnZhciBuaXAxMF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxMF9leHBvcnRzLCB7XG4gIHBhcnNlOiAoKSA9PiBwYXJzZVxufSk7XG5mdW5jdGlvbiBwYXJzZShldmVudCkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgcmVwbHk6IHZvaWQgMCxcbiAgICByb290OiB2b2lkIDAsXG4gICAgbWVudGlvbnM6IFtdLFxuICAgIHByb2ZpbGVzOiBbXSxcbiAgICBxdW90ZXM6IFtdXG4gIH07XG4gIGxldCBtYXliZVBhcmVudDtcbiAgbGV0IG1heWJlUm9vdDtcbiAgZm9yIChsZXQgaTIgPSBldmVudC50YWdzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICBjb25zdCB0YWcgPSBldmVudC50YWdzW2kyXTtcbiAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiB0YWdbMV0pIHtcbiAgICAgIGNvbnN0IFtfLCBlVGFnRXZlbnRJZCwgZVRhZ1JlbGF5VXJsLCBlVGFnTWFya2VyLCBlVGFnQXV0aG9yXSA9IHRhZztcbiAgICAgIGNvbnN0IGV2ZW50UG9pbnRlciA9IHtcbiAgICAgICAgaWQ6IGVUYWdFdmVudElkLFxuICAgICAgICByZWxheXM6IGVUYWdSZWxheVVybCA/IFtlVGFnUmVsYXlVcmxdIDogW10sXG4gICAgICAgIGF1dGhvcjogZVRhZ0F1dGhvclxuICAgICAgfTtcbiAgICAgIGlmIChlVGFnTWFya2VyID09PSBcInJvb3RcIikge1xuICAgICAgICByZXN1bHQucm9vdCA9IGV2ZW50UG9pbnRlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZVRhZ01hcmtlciA9PT0gXCJyZXBseVwiKSB7XG4gICAgICAgIHJlc3VsdC5yZXBseSA9IGV2ZW50UG9pbnRlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZVRhZ01hcmtlciA9PT0gXCJtZW50aW9uXCIpIHtcbiAgICAgICAgcmVzdWx0Lm1lbnRpb25zLnB1c2goZXZlbnRQb2ludGVyKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIW1heWJlUGFyZW50KSB7XG4gICAgICAgIG1heWJlUGFyZW50ID0gZXZlbnRQb2ludGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF5YmVSb290ID0gZXZlbnRQb2ludGVyO1xuICAgICAgfVxuICAgICAgcmVzdWx0Lm1lbnRpb25zLnB1c2goZXZlbnRQb2ludGVyKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodGFnWzBdID09PSBcInFcIiAmJiB0YWdbMV0pIHtcbiAgICAgIGNvbnN0IFtfLCBlVGFnRXZlbnRJZCwgZVRhZ1JlbGF5VXJsXSA9IHRhZztcbiAgICAgIHJlc3VsdC5xdW90ZXMucHVzaCh7XG4gICAgICAgIGlkOiBlVGFnRXZlbnRJZCxcbiAgICAgICAgcmVsYXlzOiBlVGFnUmVsYXlVcmwgPyBbZVRhZ1JlbGF5VXJsXSA6IFtdXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRhZ1swXSA9PT0gXCJwXCIgJiYgdGFnWzFdKSB7XG4gICAgICByZXN1bHQucHJvZmlsZXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogdGFnWzFdLFxuICAgICAgICByZWxheXM6IHRhZ1syXSA/IFt0YWdbMl1dIDogW11cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG4gIGlmICghcmVzdWx0LnJvb3QpIHtcbiAgICByZXN1bHQucm9vdCA9IG1heWJlUm9vdCB8fCBtYXliZVBhcmVudCB8fCByZXN1bHQucmVwbHk7XG4gIH1cbiAgaWYgKCFyZXN1bHQucmVwbHkpIHtcbiAgICByZXN1bHQucmVwbHkgPSBtYXliZVBhcmVudCB8fCByZXN1bHQucm9vdDtcbiAgfVxuICA7XG4gIFtyZXN1bHQucmVwbHksIHJlc3VsdC5yb290XS5mb3JFYWNoKChyZWYpID0+IHtcbiAgICBpZiAoIXJlZilcbiAgICAgIHJldHVybjtcbiAgICBsZXQgaWR4ID0gcmVzdWx0Lm1lbnRpb25zLmluZGV4T2YocmVmKTtcbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgcmVzdWx0Lm1lbnRpb25zLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbiAgICBpZiAocmVmLmF1dGhvcikge1xuICAgICAgbGV0IGF1dGhvciA9IHJlc3VsdC5wcm9maWxlcy5maW5kKChwKSA9PiBwLnB1YmtleSA9PT0gcmVmLmF1dGhvcik7XG4gICAgICBpZiAoYXV0aG9yICYmIGF1dGhvci5yZWxheXMpIHtcbiAgICAgICAgaWYgKCFyZWYucmVsYXlzKSB7XG4gICAgICAgICAgcmVmLnJlbGF5cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGF1dGhvci5yZWxheXMuZm9yRWFjaCgodXJsKSA9PiB7XG4gICAgICAgICAgaWYgKHJlZi5yZWxheXM/LmluZGV4T2YodXJsKSA9PT0gLTEpXG4gICAgICAgICAgICByZWYucmVsYXlzLnB1c2godXJsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF1dGhvci5yZWxheXMgPSByZWYucmVsYXlzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJlc3VsdC5tZW50aW9ucy5mb3JFYWNoKChyZWYpID0+IHtcbiAgICBpZiAocmVmLmF1dGhvcikge1xuICAgICAgbGV0IGF1dGhvciA9IHJlc3VsdC5wcm9maWxlcy5maW5kKChwKSA9PiBwLnB1YmtleSA9PT0gcmVmLmF1dGhvcik7XG4gICAgICBpZiAoYXV0aG9yICYmIGF1dGhvci5yZWxheXMpIHtcbiAgICAgICAgaWYgKCFyZWYucmVsYXlzKSB7XG4gICAgICAgICAgcmVmLnJlbGF5cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGF1dGhvci5yZWxheXMuZm9yRWFjaCgodXJsKSA9PiB7XG4gICAgICAgICAgaWYgKHJlZi5yZWxheXMuaW5kZXhPZih1cmwpID09PSAtMSlcbiAgICAgICAgICAgIHJlZi5yZWxheXMucHVzaCh1cmwpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXV0aG9yLnJlbGF5cyA9IHJlZi5yZWxheXM7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gbmlwMTEudHNcbnZhciBuaXAxMV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxMV9leHBvcnRzLCB7XG4gIGZldGNoUmVsYXlJbmZvcm1hdGlvbjogKCkgPT4gZmV0Y2hSZWxheUluZm9ybWF0aW9uLFxuICB1c2VGZXRjaEltcGxlbWVudGF0aW9uOiAoKSA9PiB1c2VGZXRjaEltcGxlbWVudGF0aW9uMlxufSk7XG52YXIgX2ZldGNoMjtcbnRyeSB7XG4gIF9mZXRjaDIgPSBmZXRjaDtcbn0gY2F0Y2gge1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjIoZmV0Y2hJbXBsZW1lbnRhdGlvbikge1xuICBfZmV0Y2gyID0gZmV0Y2hJbXBsZW1lbnRhdGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoUmVsYXlJbmZvcm1hdGlvbih1cmwpIHtcbiAgcmV0dXJuIGF3YWl0IChhd2FpdCBmZXRjaCh1cmwucmVwbGFjZShcIndzOi8vXCIsIFwiaHR0cDovL1wiKS5yZXBsYWNlKFwid3NzOi8vXCIsIFwiaHR0cHM6Ly9cIiksIHtcbiAgICBoZWFkZXJzOiB7IEFjY2VwdDogXCJhcHBsaWNhdGlvbi9ub3N0citqc29uXCIgfVxuICB9KSkuanNvbigpO1xufVxuXG4vLyBuaXAxMy50c1xudmFyIG5pcDEzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDEzX2V4cG9ydHMsIHtcbiAgZmFzdEV2ZW50SGFzaDogKCkgPT4gZmFzdEV2ZW50SGFzaCxcbiAgZ2V0UG93OiAoKSA9PiBnZXRQb3csXG4gIG1pbmVQb3c6ICgpID0+IG1pbmVQb3dcbn0pO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4NCB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBzaGEyNTYgYXMgc2hhMjU2MiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiO1xuZnVuY3Rpb24gZ2V0UG93KGhleCkge1xuICBsZXQgY291bnQgPSAwO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgNjQ7IGkyICs9IDgpIHtcbiAgICBjb25zdCBuaWJibGUgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKGkyLCBpMiArIDgpLCAxNik7XG4gICAgaWYgKG5pYmJsZSA9PT0gMCkge1xuICAgICAgY291bnQgKz0gMzI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ICs9IE1hdGguY2x6MzIobmliYmxlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5mdW5jdGlvbiBtaW5lUG93KHVuc2lnbmVkLCBkaWZmaWN1bHR5KSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGNvbnN0IGV2ZW50ID0gdW5zaWduZWQ7XG4gIGNvbnN0IHRhZyA9IFtcIm5vbmNlXCIsIGNvdW50LnRvU3RyaW5nKCksIGRpZmZpY3VsdHkudG9TdHJpbmcoKV07XG4gIGV2ZW50LnRhZ3MucHVzaCh0YWcpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IG5vdzIgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMWUzKTtcbiAgICBpZiAobm93MiAhPT0gZXZlbnQuY3JlYXRlZF9hdCkge1xuICAgICAgY291bnQgPSAwO1xuICAgICAgZXZlbnQuY3JlYXRlZF9hdCA9IG5vdzI7XG4gICAgfVxuICAgIHRhZ1sxXSA9ICgrK2NvdW50KS50b1N0cmluZygpO1xuICAgIGV2ZW50LmlkID0gZmFzdEV2ZW50SGFzaChldmVudCk7XG4gICAgaWYgKGdldFBvdyhldmVudC5pZCkgPj0gZGlmZmljdWx0eSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBldmVudDtcbn1cbmZ1bmN0aW9uIGZhc3RFdmVudEhhc2goZXZ0KSB7XG4gIHJldHVybiBieXRlc1RvSGV4NChcbiAgICBzaGEyNTYyKHV0ZjhFbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeShbMCwgZXZ0LnB1YmtleSwgZXZ0LmNyZWF0ZWRfYXQsIGV2dC5raW5kLCBldnQudGFncywgZXZ0LmNvbnRlbnRdKSkpXG4gICk7XG59XG5cbi8vIG5pcDE3LnRzXG52YXIgbmlwMTdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMTdfZXhwb3J0cywge1xuICB1bndyYXBFdmVudDogKCkgPT4gdW53cmFwRXZlbnQyLFxuICB1bndyYXBNYW55RXZlbnRzOiAoKSA9PiB1bndyYXBNYW55RXZlbnRzMixcbiAgd3JhcEV2ZW50OiAoKSA9PiB3cmFwRXZlbnQyLFxuICB3cmFwTWFueUV2ZW50czogKCkgPT4gd3JhcE1hbnlFdmVudHMyXG59KTtcblxuLy8gbmlwNTkudHNcbnZhciBuaXA1OV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA1OV9leHBvcnRzLCB7XG4gIGNyZWF0ZVJ1bW9yOiAoKSA9PiBjcmVhdGVSdW1vcixcbiAgY3JlYXRlU2VhbDogKCkgPT4gY3JlYXRlU2VhbCxcbiAgY3JlYXRlV3JhcDogKCkgPT4gY3JlYXRlV3JhcCxcbiAgdW53cmFwRXZlbnQ6ICgpID0+IHVud3JhcEV2ZW50LFxuICB1bndyYXBNYW55RXZlbnRzOiAoKSA9PiB1bndyYXBNYW55RXZlbnRzLFxuICB3cmFwRXZlbnQ6ICgpID0+IHdyYXBFdmVudCxcbiAgd3JhcE1hbnlFdmVudHM6ICgpID0+IHdyYXBNYW55RXZlbnRzXG59KTtcblxuLy8gbmlwNDQudHNcbnZhciBuaXA0NF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA0NF9leHBvcnRzLCB7XG4gIGRlY3J5cHQ6ICgpID0+IGRlY3J5cHQyLFxuICBlbmNyeXB0OiAoKSA9PiBlbmNyeXB0MixcbiAgZ2V0Q29udmVyc2F0aW9uS2V5OiAoKSA9PiBnZXRDb252ZXJzYXRpb25LZXksXG4gIHYyOiAoKSA9PiB2MlxufSk7XG5pbXBvcnQgeyBjaGFjaGEyMCB9IGZyb20gXCJAbm9ibGUvY2lwaGVycy9jaGFjaGFcIjtcbmltcG9ydCB7IGVxdWFsQnl0ZXMgfSBmcm9tIFwiQG5vYmxlL2NpcGhlcnMvdXRpbHNcIjtcbmltcG9ydCB7IHNlY3AyNTZrMSBhcyBzZWNwMjU2azEyIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XG5pbXBvcnQgeyBleHRyYWN0IGFzIGhrZGZfZXh0cmFjdCwgZXhwYW5kIGFzIGhrZGZfZXhwYW5kIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvaGtkZlwiO1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL2htYWNcIjtcbmltcG9ydCB7IHNoYTI1NiBhcyBzaGEyNTYzIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5pbXBvcnQgeyBjb25jYXRCeXRlcyBhcyBjb25jYXRCeXRlczIsIHJhbmRvbUJ5dGVzIGFzIHJhbmRvbUJ5dGVzMiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBiYXNlNjQgYXMgYmFzZTY0MiB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIG1pblBsYWludGV4dFNpemUgPSAxO1xudmFyIG1heFBsYWludGV4dFNpemUgPSA2NTUzNTtcbmZ1bmN0aW9uIGdldENvbnZlcnNhdGlvbktleShwcml2a2V5QSwgcHVia2V5Qikge1xuICBjb25zdCBzaGFyZWRYID0gc2VjcDI1NmsxMi5nZXRTaGFyZWRTZWNyZXQocHJpdmtleUEsIFwiMDJcIiArIHB1YmtleUIpLnN1YmFycmF5KDEsIDMzKTtcbiAgcmV0dXJuIGhrZGZfZXh0cmFjdChzaGEyNTYzLCBzaGFyZWRYLCBcIm5pcDQ0LXYyXCIpO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZUtleXMoY29udmVyc2F0aW9uS2V5LCBub25jZSkge1xuICBjb25zdCBrZXlzID0gaGtkZl9leHBhbmQoc2hhMjU2MywgY29udmVyc2F0aW9uS2V5LCBub25jZSwgNzYpO1xuICByZXR1cm4ge1xuICAgIGNoYWNoYV9rZXk6IGtleXMuc3ViYXJyYXkoMCwgMzIpLFxuICAgIGNoYWNoYV9ub25jZToga2V5cy5zdWJhcnJheSgzMiwgNDQpLFxuICAgIGhtYWNfa2V5OiBrZXlzLnN1YmFycmF5KDQ0LCA3NilcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGNQYWRkZWRMZW4obGVuKSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobGVuKSB8fCBsZW4gPCAxKVxuICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJcIik7XG4gIGlmIChsZW4gPD0gMzIpXG4gICAgcmV0dXJuIDMyO1xuICBjb25zdCBuZXh0UG93ZXIgPSAxIDw8IE1hdGguZmxvb3IoTWF0aC5sb2cyKGxlbiAtIDEpKSArIDE7XG4gIGNvbnN0IGNodW5rID0gbmV4dFBvd2VyIDw9IDI1NiA/IDMyIDogbmV4dFBvd2VyIC8gODtcbiAgcmV0dXJuIGNodW5rICogKE1hdGguZmxvb3IoKGxlbiAtIDEpIC8gY2h1bmspICsgMSk7XG59XG5mdW5jdGlvbiB3cml0ZVUxNkJFKG51bSkge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkgfHwgbnVtIDwgbWluUGxhaW50ZXh0U2l6ZSB8fCBudW0gPiBtYXhQbGFpbnRleHRTaXplKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemU6IG11c3QgYmUgYmV0d2VlbiAxIGFuZCA2NTUzNSBieXRlc1wiKTtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMik7XG4gIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyKS5zZXRVaW50MTYoMCwgbnVtLCBmYWxzZSk7XG4gIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBwYWQocGxhaW50ZXh0KSB7XG4gIGNvbnN0IHVucGFkZGVkID0gdXRmOEVuY29kZXIuZW5jb2RlKHBsYWludGV4dCk7XG4gIGNvbnN0IHVucGFkZGVkTGVuID0gdW5wYWRkZWQubGVuZ3RoO1xuICBjb25zdCBwcmVmaXggPSB3cml0ZVUxNkJFKHVucGFkZGVkTGVuKTtcbiAgY29uc3Qgc3VmZml4ID0gbmV3IFVpbnQ4QXJyYXkoY2FsY1BhZGRlZExlbih1bnBhZGRlZExlbikgLSB1bnBhZGRlZExlbik7XG4gIHJldHVybiBjb25jYXRCeXRlczIocHJlZml4LCB1bnBhZGRlZCwgc3VmZml4KTtcbn1cbmZ1bmN0aW9uIHVucGFkKHBhZGRlZCkge1xuICBjb25zdCB1bnBhZGRlZExlbiA9IG5ldyBEYXRhVmlldyhwYWRkZWQuYnVmZmVyKS5nZXRVaW50MTYoMCk7XG4gIGNvbnN0IHVucGFkZGVkID0gcGFkZGVkLnN1YmFycmF5KDIsIDIgKyB1bnBhZGRlZExlbik7XG4gIGlmICh1bnBhZGRlZExlbiA8IG1pblBsYWludGV4dFNpemUgfHwgdW5wYWRkZWRMZW4gPiBtYXhQbGFpbnRleHRTaXplIHx8IHVucGFkZGVkLmxlbmd0aCAhPT0gdW5wYWRkZWRMZW4gfHwgcGFkZGVkLmxlbmd0aCAhPT0gMiArIGNhbGNQYWRkZWRMZW4odW5wYWRkZWRMZW4pKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGFkZGluZ1wiKTtcbiAgcmV0dXJuIHV0ZjhEZWNvZGVyLmRlY29kZSh1bnBhZGRlZCk7XG59XG5mdW5jdGlvbiBobWFjQWFkKGtleSwgbWVzc2FnZSwgYWFkKSB7XG4gIGlmIChhYWQubGVuZ3RoICE9PSAzMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBQUQgYXNzb2NpYXRlZCBkYXRhIG11c3QgYmUgMzIgYnl0ZXNcIik7XG4gIGNvbnN0IGNvbWJpbmVkID0gY29uY2F0Qnl0ZXMyKGFhZCwgbWVzc2FnZSk7XG4gIHJldHVybiBobWFjKHNoYTI1NjMsIGtleSwgY29tYmluZWQpO1xufVxuZnVuY3Rpb24gZGVjb2RlUGF5bG9hZChwYXlsb2FkKSB7XG4gIGlmICh0eXBlb2YgcGF5bG9hZCAhPT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXlsb2FkIG11c3QgYmUgYSB2YWxpZCBzdHJpbmdcIik7XG4gIGNvbnN0IHBsZW4gPSBwYXlsb2FkLmxlbmd0aDtcbiAgaWYgKHBsZW4gPCAxMzIgfHwgcGxlbiA+IDg3NDcyKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF5bG9hZCBsZW5ndGg6IFwiICsgcGxlbik7XG4gIGlmIChwYXlsb2FkWzBdID09PSBcIiNcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGVuY3J5cHRpb24gdmVyc2lvblwiKTtcbiAgbGV0IGRhdGE7XG4gIHRyeSB7XG4gICAgZGF0YSA9IGJhc2U2NDIuZGVjb2RlKHBheWxvYWQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmFzZTY0OiBcIiArIGVycm9yLm1lc3NhZ2UpO1xuICB9XG4gIGNvbnN0IGRsZW4gPSBkYXRhLmxlbmd0aDtcbiAgaWYgKGRsZW4gPCA5OSB8fCBkbGVuID4gNjU2MDMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhIGxlbmd0aDogXCIgKyBkbGVuKTtcbiAgY29uc3QgdmVycyA9IGRhdGFbMF07XG4gIGlmICh2ZXJzICE9PSAyKVxuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gZW5jcnlwdGlvbiB2ZXJzaW9uIFwiICsgdmVycyk7XG4gIHJldHVybiB7XG4gICAgbm9uY2U6IGRhdGEuc3ViYXJyYXkoMSwgMzMpLFxuICAgIGNpcGhlcnRleHQ6IGRhdGEuc3ViYXJyYXkoMzMsIC0zMiksXG4gICAgbWFjOiBkYXRhLnN1YmFycmF5KC0zMilcbiAgfTtcbn1cbmZ1bmN0aW9uIGVuY3J5cHQyKHBsYWludGV4dCwgY29udmVyc2F0aW9uS2V5LCBub25jZSA9IHJhbmRvbUJ5dGVzMigzMikpIHtcbiAgY29uc3QgeyBjaGFjaGFfa2V5LCBjaGFjaGFfbm9uY2UsIGhtYWNfa2V5IH0gPSBnZXRNZXNzYWdlS2V5cyhjb252ZXJzYXRpb25LZXksIG5vbmNlKTtcbiAgY29uc3QgcGFkZGVkID0gcGFkKHBsYWludGV4dCk7XG4gIGNvbnN0IGNpcGhlcnRleHQgPSBjaGFjaGEyMChjaGFjaGFfa2V5LCBjaGFjaGFfbm9uY2UsIHBhZGRlZCk7XG4gIGNvbnN0IG1hYyA9IGhtYWNBYWQoaG1hY19rZXksIGNpcGhlcnRleHQsIG5vbmNlKTtcbiAgcmV0dXJuIGJhc2U2NDIuZW5jb2RlKGNvbmNhdEJ5dGVzMihuZXcgVWludDhBcnJheShbMl0pLCBub25jZSwgY2lwaGVydGV4dCwgbWFjKSk7XG59XG5mdW5jdGlvbiBkZWNyeXB0MihwYXlsb2FkLCBjb252ZXJzYXRpb25LZXkpIHtcbiAgY29uc3QgeyBub25jZSwgY2lwaGVydGV4dCwgbWFjIH0gPSBkZWNvZGVQYXlsb2FkKHBheWxvYWQpO1xuICBjb25zdCB7IGNoYWNoYV9rZXksIGNoYWNoYV9ub25jZSwgaG1hY19rZXkgfSA9IGdldE1lc3NhZ2VLZXlzKGNvbnZlcnNhdGlvbktleSwgbm9uY2UpO1xuICBjb25zdCBjYWxjdWxhdGVkTWFjID0gaG1hY0FhZChobWFjX2tleSwgY2lwaGVydGV4dCwgbm9uY2UpO1xuICBpZiAoIWVxdWFsQnl0ZXMoY2FsY3VsYXRlZE1hYywgbWFjKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1BQ1wiKTtcbiAgY29uc3QgcGFkZGVkID0gY2hhY2hhMjAoY2hhY2hhX2tleSwgY2hhY2hhX25vbmNlLCBjaXBoZXJ0ZXh0KTtcbiAgcmV0dXJuIHVucGFkKHBhZGRlZCk7XG59XG52YXIgdjIgPSB7XG4gIHV0aWxzOiB7XG4gICAgZ2V0Q29udmVyc2F0aW9uS2V5LFxuICAgIGNhbGNQYWRkZWRMZW5cbiAgfSxcbiAgZW5jcnlwdDogZW5jcnlwdDIsXG4gIGRlY3J5cHQ6IGRlY3J5cHQyXG59O1xuXG4vLyBuaXA1OS50c1xudmFyIFRXT19EQVlTID0gMiAqIDI0ICogNjAgKiA2MDtcbnZhciBub3cgPSAoKSA9PiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxZTMpO1xudmFyIHJhbmRvbU5vdyA9ICgpID0+IE1hdGgucm91bmQobm93KCkgLSBNYXRoLnJhbmRvbSgpICogVFdPX0RBWVMpO1xudmFyIG5pcDQ0Q29udmVyc2F0aW9uS2V5ID0gKHByaXZhdGVLZXksIHB1YmxpY0tleSkgPT4gZ2V0Q29udmVyc2F0aW9uS2V5KHByaXZhdGVLZXksIHB1YmxpY0tleSk7XG52YXIgbmlwNDRFbmNyeXB0ID0gKGRhdGEsIHByaXZhdGVLZXksIHB1YmxpY0tleSkgPT4gZW5jcnlwdDIoSlNPTi5zdHJpbmdpZnkoZGF0YSksIG5pcDQ0Q29udmVyc2F0aW9uS2V5KHByaXZhdGVLZXksIHB1YmxpY0tleSkpO1xudmFyIG5pcDQ0RGVjcnlwdCA9IChkYXRhLCBwcml2YXRlS2V5KSA9PiBKU09OLnBhcnNlKGRlY3J5cHQyKGRhdGEuY29udGVudCwgbmlwNDRDb252ZXJzYXRpb25LZXkocHJpdmF0ZUtleSwgZGF0YS5wdWJrZXkpKSk7XG5mdW5jdGlvbiBjcmVhdGVSdW1vcihldmVudCwgcHJpdmF0ZUtleSkge1xuICBjb25zdCBydW1vciA9IHtcbiAgICBjcmVhdGVkX2F0OiBub3coKSxcbiAgICBjb250ZW50OiBcIlwiLFxuICAgIHRhZ3M6IFtdLFxuICAgIC4uLmV2ZW50LFxuICAgIHB1YmtleTogZ2V0UHVibGljS2V5KHByaXZhdGVLZXkpXG4gIH07XG4gIHJ1bW9yLmlkID0gZ2V0RXZlbnRIYXNoKHJ1bW9yKTtcbiAgcmV0dXJuIHJ1bW9yO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VhbChydW1vciwgcHJpdmF0ZUtleSwgcmVjaXBpZW50UHVibGljS2V5KSB7XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIGtpbmQ6IFNlYWwsXG4gICAgICBjb250ZW50OiBuaXA0NEVuY3J5cHQocnVtb3IsIHByaXZhdGVLZXksIHJlY2lwaWVudFB1YmxpY0tleSksXG4gICAgICBjcmVhdGVkX2F0OiByYW5kb21Ob3coKSxcbiAgICAgIHRhZ3M6IFtdXG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVXcmFwKHNlYWwsIHJlY2lwaWVudFB1YmxpY0tleSkge1xuICBjb25zdCByYW5kb21LZXkgPSBnZW5lcmF0ZVNlY3JldEtleSgpO1xuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBHaWZ0V3JhcCxcbiAgICAgIGNvbnRlbnQ6IG5pcDQ0RW5jcnlwdChzZWFsLCByYW5kb21LZXksIHJlY2lwaWVudFB1YmxpY0tleSksXG4gICAgICBjcmVhdGVkX2F0OiByYW5kb21Ob3coKSxcbiAgICAgIHRhZ3M6IFtbXCJwXCIsIHJlY2lwaWVudFB1YmxpY0tleV1dXG4gICAgfSxcbiAgICByYW5kb21LZXlcbiAgKTtcbn1cbmZ1bmN0aW9uIHdyYXBFdmVudChldmVudCwgc2VuZGVyUHJpdmF0ZUtleSwgcmVjaXBpZW50UHVibGljS2V5KSB7XG4gIGNvbnN0IHJ1bW9yID0gY3JlYXRlUnVtb3IoZXZlbnQsIHNlbmRlclByaXZhdGVLZXkpO1xuICBjb25zdCBzZWFsID0gY3JlYXRlU2VhbChydW1vciwgc2VuZGVyUHJpdmF0ZUtleSwgcmVjaXBpZW50UHVibGljS2V5KTtcbiAgcmV0dXJuIGNyZWF0ZVdyYXAoc2VhbCwgcmVjaXBpZW50UHVibGljS2V5KTtcbn1cbmZ1bmN0aW9uIHdyYXBNYW55RXZlbnRzKGV2ZW50LCBzZW5kZXJQcml2YXRlS2V5LCByZWNpcGllbnRzUHVibGljS2V5cykge1xuICBpZiAoIXJlY2lwaWVudHNQdWJsaWNLZXlzIHx8IHJlY2lwaWVudHNQdWJsaWNLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSByZWNpcGllbnQgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGNvbnN0IHNlbmRlclB1YmxpY0tleSA9IGdldFB1YmxpY0tleShzZW5kZXJQcml2YXRlS2V5KTtcbiAgY29uc3Qgd3JhcHBlZHMgPSBbd3JhcEV2ZW50KGV2ZW50LCBzZW5kZXJQcml2YXRlS2V5LCBzZW5kZXJQdWJsaWNLZXkpXTtcbiAgcmVjaXBpZW50c1B1YmxpY0tleXMuZm9yRWFjaCgocmVjaXBpZW50UHVibGljS2V5KSA9PiB7XG4gICAgd3JhcHBlZHMucHVzaCh3cmFwRXZlbnQoZXZlbnQsIHNlbmRlclByaXZhdGVLZXksIHJlY2lwaWVudFB1YmxpY0tleSkpO1xuICB9KTtcbiAgcmV0dXJuIHdyYXBwZWRzO1xufVxuZnVuY3Rpb24gdW53cmFwRXZlbnQod3JhcCwgcmVjaXBpZW50UHJpdmF0ZUtleSkge1xuICBjb25zdCB1bndyYXBwZWRTZWFsID0gbmlwNDREZWNyeXB0KHdyYXAsIHJlY2lwaWVudFByaXZhdGVLZXkpO1xuICByZXR1cm4gbmlwNDREZWNyeXB0KHVud3JhcHBlZFNlYWwsIHJlY2lwaWVudFByaXZhdGVLZXkpO1xufVxuZnVuY3Rpb24gdW53cmFwTWFueUV2ZW50cyh3cmFwcGVkRXZlbnRzLCByZWNpcGllbnRQcml2YXRlS2V5KSB7XG4gIGxldCB1bndyYXBwZWRFdmVudHMgPSBbXTtcbiAgd3JhcHBlZEV2ZW50cy5mb3JFYWNoKChlKSA9PiB7XG4gICAgdW53cmFwcGVkRXZlbnRzLnB1c2godW53cmFwRXZlbnQoZSwgcmVjaXBpZW50UHJpdmF0ZUtleSkpO1xuICB9KTtcbiAgdW53cmFwcGVkRXZlbnRzLnNvcnQoKGEsIGIpID0+IGEuY3JlYXRlZF9hdCAtIGIuY3JlYXRlZF9hdCk7XG4gIHJldHVybiB1bndyYXBwZWRFdmVudHM7XG59XG5cbi8vIG5pcDE3LnRzXG5mdW5jdGlvbiBjcmVhdGVFdmVudChyZWNpcGllbnRzLCBtZXNzYWdlLCBjb252ZXJzYXRpb25UaXRsZSwgcmVwbHlUbykge1xuICBjb25zdCBiYXNlRXZlbnQgPSB7XG4gICAgY3JlYXRlZF9hdDogTWF0aC5jZWlsKERhdGUubm93KCkgLyAxZTMpLFxuICAgIGtpbmQ6IFByaXZhdGVEaXJlY3RNZXNzYWdlLFxuICAgIHRhZ3M6IFtdLFxuICAgIGNvbnRlbnQ6IG1lc3NhZ2VcbiAgfTtcbiAgY29uc3QgcmVjaXBpZW50c0FycmF5ID0gQXJyYXkuaXNBcnJheShyZWNpcGllbnRzKSA/IHJlY2lwaWVudHMgOiBbcmVjaXBpZW50c107XG4gIHJlY2lwaWVudHNBcnJheS5mb3JFYWNoKCh7IHB1YmxpY0tleSwgcmVsYXlVcmwgfSkgPT4ge1xuICAgIGJhc2VFdmVudC50YWdzLnB1c2gocmVsYXlVcmwgPyBbXCJwXCIsIHB1YmxpY0tleSwgcmVsYXlVcmxdIDogW1wicFwiLCBwdWJsaWNLZXldKTtcbiAgfSk7XG4gIGlmIChyZXBseVRvKSB7XG4gICAgYmFzZUV2ZW50LnRhZ3MucHVzaChbXCJlXCIsIHJlcGx5VG8uZXZlbnRJZCwgcmVwbHlUby5yZWxheVVybCB8fCBcIlwiLCBcInJlcGx5XCJdKTtcbiAgfVxuICBpZiAoY29udmVyc2F0aW9uVGl0bGUpIHtcbiAgICBiYXNlRXZlbnQudGFncy5wdXNoKFtcInN1YmplY3RcIiwgY29udmVyc2F0aW9uVGl0bGVdKTtcbiAgfVxuICByZXR1cm4gYmFzZUV2ZW50O1xufVxuZnVuY3Rpb24gd3JhcEV2ZW50MihzZW5kZXJQcml2YXRlS2V5LCByZWNpcGllbnQsIG1lc3NhZ2UsIGNvbnZlcnNhdGlvblRpdGxlLCByZXBseVRvKSB7XG4gIGNvbnN0IGV2ZW50ID0gY3JlYXRlRXZlbnQocmVjaXBpZW50LCBtZXNzYWdlLCBjb252ZXJzYXRpb25UaXRsZSwgcmVwbHlUbyk7XG4gIHJldHVybiB3cmFwRXZlbnQoZXZlbnQsIHNlbmRlclByaXZhdGVLZXksIHJlY2lwaWVudC5wdWJsaWNLZXkpO1xufVxuZnVuY3Rpb24gd3JhcE1hbnlFdmVudHMyKHNlbmRlclByaXZhdGVLZXksIHJlY2lwaWVudHMsIG1lc3NhZ2UsIGNvbnZlcnNhdGlvblRpdGxlLCByZXBseVRvKSB7XG4gIGlmICghcmVjaXBpZW50cyB8fCByZWNpcGllbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSByZWNpcGllbnQgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGNvbnN0IHNlbmRlclB1YmxpY0tleSA9IGdldFB1YmxpY0tleShzZW5kZXJQcml2YXRlS2V5KTtcbiAgcmV0dXJuIFt7IHB1YmxpY0tleTogc2VuZGVyUHVibGljS2V5IH0sIC4uLnJlY2lwaWVudHNdLm1hcChcbiAgICAocmVjaXBpZW50KSA9PiB3cmFwRXZlbnQyKHNlbmRlclByaXZhdGVLZXksIHJlY2lwaWVudCwgbWVzc2FnZSwgY29udmVyc2F0aW9uVGl0bGUsIHJlcGx5VG8pXG4gICk7XG59XG52YXIgdW53cmFwRXZlbnQyID0gdW53cmFwRXZlbnQ7XG52YXIgdW53cmFwTWFueUV2ZW50czIgPSB1bndyYXBNYW55RXZlbnRzO1xuXG4vLyBuaXAxOC50c1xudmFyIG5pcDE4X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDE4X2V4cG9ydHMsIHtcbiAgZmluaXNoUmVwb3N0RXZlbnQ6ICgpID0+IGZpbmlzaFJlcG9zdEV2ZW50LFxuICBnZXRSZXBvc3RlZEV2ZW50OiAoKSA9PiBnZXRSZXBvc3RlZEV2ZW50LFxuICBnZXRSZXBvc3RlZEV2ZW50UG9pbnRlcjogKCkgPT4gZ2V0UmVwb3N0ZWRFdmVudFBvaW50ZXJcbn0pO1xuZnVuY3Rpb24gZmluaXNoUmVwb3N0RXZlbnQodCwgcmVwb3N0ZWQsIHJlbGF5VXJsLCBwcml2YXRlS2V5KSB7XG4gIGxldCBraW5kO1xuICBjb25zdCB0YWdzID0gWy4uLnQudGFncyA/PyBbXSwgW1wiZVwiLCByZXBvc3RlZC5pZCwgcmVsYXlVcmxdLCBbXCJwXCIsIHJlcG9zdGVkLnB1YmtleV1dO1xuICBpZiAocmVwb3N0ZWQua2luZCA9PT0gU2hvcnRUZXh0Tm90ZSkge1xuICAgIGtpbmQgPSBSZXBvc3Q7XG4gIH0gZWxzZSB7XG4gICAga2luZCA9IEdlbmVyaWNSZXBvc3Q7XG4gICAgdGFncy5wdXNoKFtcImtcIiwgU3RyaW5nKHJlcG9zdGVkLmtpbmQpXSk7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZCxcbiAgICAgIHRhZ3MsXG4gICAgICBjb250ZW50OiB0LmNvbnRlbnQgPT09IFwiXCIgfHwgcmVwb3N0ZWQudGFncz8uZmluZCgodGFnKSA9PiB0YWdbMF0gPT09IFwiLVwiKSA/IFwiXCIgOiBKU09OLnN0cmluZ2lmeShyZXBvc3RlZCksXG4gICAgICBjcmVhdGVkX2F0OiB0LmNyZWF0ZWRfYXRcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFJlcG9zdGVkRXZlbnRQb2ludGVyKGV2ZW50KSB7XG4gIGlmICghW1JlcG9zdCwgR2VuZXJpY1JlcG9zdF0uaW5jbHVkZXMoZXZlbnQua2luZCkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCBsYXN0RVRhZztcbiAgbGV0IGxhc3RQVGFnO1xuICBmb3IgKGxldCBpMiA9IGV2ZW50LnRhZ3MubGVuZ3RoIC0gMTsgaTIgPj0gMCAmJiAobGFzdEVUYWcgPT09IHZvaWQgMCB8fCBsYXN0UFRhZyA9PT0gdm9pZCAwKTsgaTItLSkge1xuICAgIGNvbnN0IHRhZyA9IGV2ZW50LnRhZ3NbaTJdO1xuICAgIGlmICh0YWcubGVuZ3RoID49IDIpIHtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwiZVwiICYmIGxhc3RFVGFnID09PSB2b2lkIDApIHtcbiAgICAgICAgbGFzdEVUYWcgPSB0YWc7XG4gICAgICB9IGVsc2UgaWYgKHRhZ1swXSA9PT0gXCJwXCIgJiYgbGFzdFBUYWcgPT09IHZvaWQgMCkge1xuICAgICAgICBsYXN0UFRhZyA9IHRhZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGxhc3RFVGFnID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgaWQ6IGxhc3RFVGFnWzFdLFxuICAgIHJlbGF5czogW2xhc3RFVGFnWzJdLCBsYXN0UFRhZz8uWzJdXS5maWx0ZXIoKHgpID0+IHR5cGVvZiB4ID09PSBcInN0cmluZ1wiKSxcbiAgICBhdXRob3I6IGxhc3RQVGFnPy5bMV1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJlcG9zdGVkRXZlbnQoZXZlbnQsIHsgc2tpcFZlcmlmaWNhdGlvbiB9ID0ge30pIHtcbiAgY29uc3QgcG9pbnRlciA9IGdldFJlcG9zdGVkRXZlbnRQb2ludGVyKGV2ZW50KTtcbiAgaWYgKHBvaW50ZXIgPT09IHZvaWQgMCB8fCBldmVudC5jb250ZW50ID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBsZXQgcmVwb3N0ZWRFdmVudDtcbiAgdHJ5IHtcbiAgICByZXBvc3RlZEV2ZW50ID0gSlNPTi5wYXJzZShldmVudC5jb250ZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChyZXBvc3RlZEV2ZW50LmlkICE9PSBwb2ludGVyLmlkKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAoIXNraXBWZXJpZmljYXRpb24gJiYgIXZlcmlmeUV2ZW50KHJlcG9zdGVkRXZlbnQpKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gcmVwb3N0ZWRFdmVudDtcbn1cblxuLy8gbmlwMjEudHNcbnZhciBuaXAyMV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAyMV9leHBvcnRzLCB7XG4gIE5PU1RSX1VSSV9SRUdFWDogKCkgPT4gTk9TVFJfVVJJX1JFR0VYLFxuICBwYXJzZTogKCkgPT4gcGFyc2UyLFxuICB0ZXN0OiAoKSA9PiB0ZXN0XG59KTtcbnZhciBOT1NUUl9VUklfUkVHRVggPSBuZXcgUmVnRXhwKGBub3N0cjooJHtCRUNIMzJfUkVHRVguc291cmNlfSlgKTtcbmZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBuZXcgUmVnRXhwKGBeJHtOT1NUUl9VUklfUkVHRVguc291cmNlfSRgKS50ZXN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlMih1cmkpIHtcbiAgY29uc3QgbWF0Y2ggPSB1cmkubWF0Y2gobmV3IFJlZ0V4cChgXiR7Tk9TVFJfVVJJX1JFR0VYLnNvdXJjZX0kYCkpO1xuICBpZiAoIW1hdGNoKVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBOb3N0ciBVUkk6ICR7dXJpfWApO1xuICByZXR1cm4ge1xuICAgIHVyaTogbWF0Y2hbMF0sXG4gICAgdmFsdWU6IG1hdGNoWzFdLFxuICAgIGRlY29kZWQ6IGRlY29kZShtYXRjaFsxXSlcbiAgfTtcbn1cblxuLy8gbmlwMjUudHNcbnZhciBuaXAyNV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAyNV9leHBvcnRzLCB7XG4gIGZpbmlzaFJlYWN0aW9uRXZlbnQ6ICgpID0+IGZpbmlzaFJlYWN0aW9uRXZlbnQsXG4gIGdldFJlYWN0ZWRFdmVudFBvaW50ZXI6ICgpID0+IGdldFJlYWN0ZWRFdmVudFBvaW50ZXJcbn0pO1xuZnVuY3Rpb24gZmluaXNoUmVhY3Rpb25FdmVudCh0LCByZWFjdGVkLCBwcml2YXRlS2V5KSB7XG4gIGNvbnN0IGluaGVyaXRlZFRhZ3MgPSByZWFjdGVkLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZy5sZW5ndGggPj0gMiAmJiAodGFnWzBdID09PSBcImVcIiB8fCB0YWdbMF0gPT09IFwicFwiKSk7XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIC4uLnQsXG4gICAgICBraW5kOiBSZWFjdGlvbixcbiAgICAgIHRhZ3M6IFsuLi50LnRhZ3MgPz8gW10sIC4uLmluaGVyaXRlZFRhZ3MsIFtcImVcIiwgcmVhY3RlZC5pZF0sIFtcInBcIiwgcmVhY3RlZC5wdWJrZXldXSxcbiAgICAgIGNvbnRlbnQ6IHQuY29udGVudCA/PyBcIitcIlxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufVxuZnVuY3Rpb24gZ2V0UmVhY3RlZEV2ZW50UG9pbnRlcihldmVudCkge1xuICBpZiAoZXZlbnQua2luZCAhPT0gUmVhY3Rpb24pIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCBsYXN0RVRhZztcbiAgbGV0IGxhc3RQVGFnO1xuICBmb3IgKGxldCBpMiA9IGV2ZW50LnRhZ3MubGVuZ3RoIC0gMTsgaTIgPj0gMCAmJiAobGFzdEVUYWcgPT09IHZvaWQgMCB8fCBsYXN0UFRhZyA9PT0gdm9pZCAwKTsgaTItLSkge1xuICAgIGNvbnN0IHRhZyA9IGV2ZW50LnRhZ3NbaTJdO1xuICAgIGlmICh0YWcubGVuZ3RoID49IDIpIHtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwiZVwiICYmIGxhc3RFVGFnID09PSB2b2lkIDApIHtcbiAgICAgICAgbGFzdEVUYWcgPSB0YWc7XG4gICAgICB9IGVsc2UgaWYgKHRhZ1swXSA9PT0gXCJwXCIgJiYgbGFzdFBUYWcgPT09IHZvaWQgMCkge1xuICAgICAgICBsYXN0UFRhZyA9IHRhZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGxhc3RFVGFnID09PSB2b2lkIDAgfHwgbGFzdFBUYWcgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpZDogbGFzdEVUYWdbMV0sXG4gICAgcmVsYXlzOiBbbGFzdEVUYWdbMl0sIGxhc3RQVGFnWzJdXS5maWx0ZXIoKHgpID0+IHggIT09IHZvaWQgMCksXG4gICAgYXV0aG9yOiBsYXN0UFRhZ1sxXVxuICB9O1xufVxuXG4vLyBuaXAyNy50c1xudmFyIG5pcDI3X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDI3X2V4cG9ydHMsIHtcbiAgcGFyc2U6ICgpID0+IHBhcnNlM1xufSk7XG52YXIgbm9DaGFyYWN0ZXIgPSAvXFxXL207XG52YXIgbm9VUkxDaGFyYWN0ZXIgPSAvXFxXIHxcXFckfCR8LHwgL207XG5mdW5jdGlvbiogcGFyc2UzKGNvbnRlbnQpIHtcbiAgY29uc3QgbWF4ID0gY29udGVudC5sZW5ndGg7XG4gIGxldCBwcmV2SW5kZXggPSAwO1xuICBsZXQgaW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBtYXgpIHtcbiAgICBsZXQgdSA9IGNvbnRlbnQuaW5kZXhPZihcIjpcIiwgaW5kZXgpO1xuICAgIGlmICh1ID09PSAtMSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChjb250ZW50LnN1YnN0cmluZyh1IC0gNSwgdSkgPT09IFwibm9zdHJcIikge1xuICAgICAgY29uc3QgbSA9IGNvbnRlbnQuc3Vic3RyaW5nKHUgKyA2MCkubWF0Y2gobm9DaGFyYWN0ZXIpO1xuICAgICAgY29uc3QgZW5kID0gbSA/IHUgKyA2MCArIG0uaW5kZXggOiBtYXg7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgcG9pbnRlcjtcbiAgICAgICAgbGV0IHsgZGF0YSwgdHlwZSB9ID0gZGVjb2RlKGNvbnRlbnQuc3Vic3RyaW5nKHUgKyAxLCBlbmQpKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm5wdWJcIjpcbiAgICAgICAgICAgIHBvaW50ZXIgPSB7IHB1YmtleTogZGF0YSB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm5zZWNcIjpcbiAgICAgICAgICBjYXNlIFwibm90ZVwiOlxuICAgICAgICAgICAgaW5kZXggPSBlbmQgKyAxO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHBvaW50ZXIgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2SW5kZXggIT09IHUgLSA1KSB7XG4gICAgICAgICAgeWllbGQgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY29udGVudC5zdWJzdHJpbmcocHJldkluZGV4LCB1IC0gNSkgfTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB7IHR5cGU6IFwicmVmZXJlbmNlXCIsIHBvaW50ZXIgfTtcbiAgICAgICAgaW5kZXggPSBlbmQ7XG4gICAgICAgIHByZXZJbmRleCA9IGluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgaW5kZXggPSB1ICsgMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb250ZW50LnN1YnN0cmluZyh1IC0gNSwgdSkgPT09IFwiaHR0cHNcIiB8fCBjb250ZW50LnN1YnN0cmluZyh1IC0gNCwgdSkgPT09IFwiaHR0cFwiKSB7XG4gICAgICBjb25zdCBtID0gY29udGVudC5zdWJzdHJpbmcodSArIDQpLm1hdGNoKG5vVVJMQ2hhcmFjdGVyKTtcbiAgICAgIGNvbnN0IGVuZCA9IG0gPyB1ICsgNCArIG0uaW5kZXggOiBtYXg7XG4gICAgICBjb25zdCBwcmVmaXhMZW4gPSBjb250ZW50W3UgLSAxXSA9PT0gXCJzXCIgPyA1IDogNDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCB1cmwgPSBuZXcgVVJMKGNvbnRlbnQuc3Vic3RyaW5nKHUgLSBwcmVmaXhMZW4sIGVuZCkpO1xuICAgICAgICBpZiAodXJsLmhvc3RuYW1lLmluZGV4T2YoXCIuXCIpID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdXJsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2SW5kZXggIT09IHUgLSBwcmVmaXhMZW4pIHtcbiAgICAgICAgICB5aWVsZCB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBjb250ZW50LnN1YnN0cmluZyhwcmV2SW5kZXgsIHUgLSBwcmVmaXhMZW4pIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybC5wYXRobmFtZS5lbmRzV2l0aChcIi5wbmdcIikgfHwgdXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLmpwZ1wiKSB8fCB1cmwucGF0aG5hbWUuZW5kc1dpdGgoXCIuanBlZ1wiKSB8fCB1cmwucGF0aG5hbWUuZW5kc1dpdGgoXCIuZ2lmXCIpIHx8IHVybC5wYXRobmFtZS5lbmRzV2l0aChcIi53ZWJwXCIpKSB7XG4gICAgICAgICAgeWllbGQgeyB0eXBlOiBcImltYWdlXCIsIHVybDogdXJsLnRvU3RyaW5nKCkgfTtcbiAgICAgICAgICBpbmRleCA9IGVuZDtcbiAgICAgICAgICBwcmV2SW5kZXggPSBpbmRleDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLm1wNFwiKSB8fCB1cmwucGF0aG5hbWUuZW5kc1dpdGgoXCIuYXZpXCIpIHx8IHVybC5wYXRobmFtZS5lbmRzV2l0aChcIi53ZWJtXCIpIHx8IHVybC5wYXRobmFtZS5lbmRzV2l0aChcIi5ta3ZcIikpIHtcbiAgICAgICAgICB5aWVsZCB7IHR5cGU6IFwidmlkZW9cIiwgdXJsOiB1cmwudG9TdHJpbmcoKSB9O1xuICAgICAgICAgIGluZGV4ID0gZW5kO1xuICAgICAgICAgIHByZXZJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmwucGF0aG5hbWUuZW5kc1dpdGgoXCIubXAzXCIpIHx8IHVybC5wYXRobmFtZS5lbmRzV2l0aChcIi5hYWNcIikgfHwgdXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLm9nZ1wiKSB8fCB1cmwucGF0aG5hbWUuZW5kc1dpdGgoXCIub3B1c1wiKSkge1xuICAgICAgICAgIHlpZWxkIHsgdHlwZTogXCJhdWRpb1wiLCB1cmw6IHVybC50b1N0cmluZygpIH07XG4gICAgICAgICAgaW5kZXggPSBlbmQ7XG4gICAgICAgICAgcHJldkluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgeyB0eXBlOiBcInVybFwiLCB1cmw6IHVybC50b1N0cmluZygpIH07XG4gICAgICAgIGluZGV4ID0gZW5kO1xuICAgICAgICBwcmV2SW5kZXggPSBpbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgIGluZGV4ID0gZW5kICsgMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb250ZW50LnN1YnN0cmluZyh1IC0gMywgdSkgPT09IFwid3NzXCIgfHwgY29udGVudC5zdWJzdHJpbmcodSAtIDIsIHUpID09PSBcIndzXCIpIHtcbiAgICAgIGNvbnN0IG0gPSBjb250ZW50LnN1YnN0cmluZyh1ICsgNCkubWF0Y2gobm9VUkxDaGFyYWN0ZXIpO1xuICAgICAgY29uc3QgZW5kID0gbSA/IHUgKyA0ICsgbS5pbmRleCA6IG1heDtcbiAgICAgIGNvbnN0IHByZWZpeExlbiA9IGNvbnRlbnRbdSAtIDFdID09PSBcInNcIiA/IDMgOiAyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHVybCA9IG5ldyBVUkwoY29udGVudC5zdWJzdHJpbmcodSAtIHByZWZpeExlbiwgZW5kKSk7XG4gICAgICAgIGlmICh1cmwuaG9zdG5hbWUuaW5kZXhPZihcIi5cIikgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB3cyB1cmxcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gdSAtIHByZWZpeExlbikge1xuICAgICAgICAgIHlpZWxkIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGNvbnRlbnQuc3Vic3RyaW5nKHByZXZJbmRleCwgdSAtIHByZWZpeExlbikgfTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB7IHR5cGU6IFwicmVsYXlcIiwgdXJsOiB1cmwudG9TdHJpbmcoKSB9O1xuICAgICAgICBpbmRleCA9IGVuZDtcbiAgICAgICAgcHJldkluZGV4ID0gaW5kZXg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICBpbmRleCA9IGVuZCArIDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCA9IHUgKyAxO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG4gIGlmIChwcmV2SW5kZXggIT09IG1heCkge1xuICAgIHlpZWxkIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGNvbnRlbnQuc3Vic3RyaW5nKHByZXZJbmRleCkgfTtcbiAgfVxufVxuXG4vLyBuaXAyOC50c1xudmFyIG5pcDI4X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDI4X2V4cG9ydHMsIHtcbiAgY2hhbm5lbENyZWF0ZUV2ZW50OiAoKSA9PiBjaGFubmVsQ3JlYXRlRXZlbnQsXG4gIGNoYW5uZWxIaWRlTWVzc2FnZUV2ZW50OiAoKSA9PiBjaGFubmVsSGlkZU1lc3NhZ2VFdmVudCxcbiAgY2hhbm5lbE1lc3NhZ2VFdmVudDogKCkgPT4gY2hhbm5lbE1lc3NhZ2VFdmVudCxcbiAgY2hhbm5lbE1ldGFkYXRhRXZlbnQ6ICgpID0+IGNoYW5uZWxNZXRhZGF0YUV2ZW50LFxuICBjaGFubmVsTXV0ZVVzZXJFdmVudDogKCkgPT4gY2hhbm5lbE11dGVVc2VyRXZlbnRcbn0pO1xudmFyIGNoYW5uZWxDcmVhdGVFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGxldCBjb250ZW50O1xuICBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0LmNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb250ZW50ID0gdC5jb250ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogQ2hhbm5lbENyZWF0aW9uLFxuICAgICAgdGFnczogWy4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxNZXRhZGF0YUV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsTWV0YWRhdGEsXG4gICAgICB0YWdzOiBbW1wiZVwiLCB0LmNoYW5uZWxfY3JlYXRlX2V2ZW50X2lkXSwgLi4udC50YWdzID8/IFtdXSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBjcmVhdGVkX2F0OiB0LmNyZWF0ZWRfYXRcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn07XG52YXIgY2hhbm5lbE1lc3NhZ2VFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGNvbnN0IHRhZ3MgPSBbW1wiZVwiLCB0LmNoYW5uZWxfY3JlYXRlX2V2ZW50X2lkLCB0LnJlbGF5X3VybCwgXCJyb290XCJdXTtcbiAgaWYgKHQucmVwbHlfdG9fY2hhbm5lbF9tZXNzYWdlX2V2ZW50X2lkKSB7XG4gICAgdGFncy5wdXNoKFtcImVcIiwgdC5yZXBseV90b19jaGFubmVsX21lc3NhZ2VfZXZlbnRfaWQsIHQucmVsYXlfdXJsLCBcInJlcGx5XCJdKTtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsTWVzc2FnZSxcbiAgICAgIHRhZ3M6IFsuLi50YWdzLCAuLi50LnRhZ3MgPz8gW11dLFxuICAgICAgY29udGVudDogdC5jb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxIaWRlTWVzc2FnZUV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsSGlkZU1lc3NhZ2UsXG4gICAgICB0YWdzOiBbW1wiZVwiLCB0LmNoYW5uZWxfbWVzc2FnZV9ldmVudF9pZF0sIC4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxNdXRlVXNlckV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsTXV0ZVVzZXIsXG4gICAgICB0YWdzOiBbW1wicFwiLCB0LnB1YmtleV90b19tdXRlXSwgLi4udC50YWdzID8/IFtdXSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBjcmVhdGVkX2F0OiB0LmNyZWF0ZWRfYXRcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn07XG5cbi8vIG5pcDMwLnRzXG52YXIgbmlwMzBfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMzBfZXhwb3J0cywge1xuICBFTU9KSV9TSE9SVENPREVfUkVHRVg6ICgpID0+IEVNT0pJX1NIT1JUQ09ERV9SRUdFWCxcbiAgbWF0Y2hBbGw6ICgpID0+IG1hdGNoQWxsLFxuICByZWdleDogKCkgPT4gcmVnZXgsXG4gIHJlcGxhY2VBbGw6ICgpID0+IHJlcGxhY2VBbGxcbn0pO1xudmFyIEVNT0pJX1NIT1JUQ09ERV9SRUdFWCA9IC86KFxcdyspOi87XG52YXIgcmVnZXggPSAoKSA9PiBuZXcgUmVnRXhwKGBcXFxcQiR7RU1PSklfU0hPUlRDT0RFX1JFR0VYLnNvdXJjZX1cXFxcQmAsIFwiZ1wiKTtcbmZ1bmN0aW9uKiBtYXRjaEFsbChjb250ZW50KSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBjb250ZW50Lm1hdGNoQWxsKHJlZ2V4KCkpO1xuICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgW3Nob3J0Y29kZSwgbmFtZV0gPSBtYXRjaDtcbiAgICAgIHlpZWxkIHtcbiAgICAgICAgc2hvcnRjb2RlLFxuICAgICAgICBuYW1lLFxuICAgICAgICBzdGFydDogbWF0Y2guaW5kZXgsXG4gICAgICAgIGVuZDogbWF0Y2guaW5kZXggKyBzaG9ydGNvZGUubGVuZ3RoXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZXBsYWNlQWxsKGNvbnRlbnQsIHJlcGxhY2VyKSB7XG4gIHJldHVybiBjb250ZW50LnJlcGxhY2VBbGwocmVnZXgoKSwgKHNob3J0Y29kZSwgbmFtZSkgPT4ge1xuICAgIHJldHVybiByZXBsYWNlcih7XG4gICAgICBzaG9ydGNvZGUsXG4gICAgICBuYW1lXG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyBuaXAzOS50c1xudmFyIG5pcDM5X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDM5X2V4cG9ydHMsIHtcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjMsXG4gIHZhbGlkYXRlR2l0aHViOiAoKSA9PiB2YWxpZGF0ZUdpdGh1YlxufSk7XG52YXIgX2ZldGNoMztcbnRyeSB7XG4gIF9mZXRjaDMgPSBmZXRjaDtcbn0gY2F0Y2gge1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjMoZmV0Y2hJbXBsZW1lbnRhdGlvbikge1xuICBfZmV0Y2gzID0gZmV0Y2hJbXBsZW1lbnRhdGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlR2l0aHViKHB1YmtleSwgdXNlcm5hbWUsIHByb29mKSB7XG4gIHRyeSB7XG4gICAgbGV0IHJlcyA9IGF3YWl0IChhd2FpdCBfZmV0Y2gzKGBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8ke3VzZXJuYW1lfS8ke3Byb29mfS9yYXdgKSkudGV4dCgpO1xuICAgIHJldHVybiByZXMgPT09IGBWZXJpZnlpbmcgdGhhdCBJIGNvbnRyb2wgdGhlIGZvbGxvd2luZyBOb3N0ciBwdWJsaWMga2V5OiAke3B1YmtleX1gO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIG5pcDQ3LnRzXG52YXIgbmlwNDdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNDdfZXhwb3J0cywge1xuICBtYWtlTndjUmVxdWVzdEV2ZW50OiAoKSA9PiBtYWtlTndjUmVxdWVzdEV2ZW50LFxuICBwYXJzZUNvbm5lY3Rpb25TdHJpbmc6ICgpID0+IHBhcnNlQ29ubmVjdGlvblN0cmluZ1xufSk7XG5mdW5jdGlvbiBwYXJzZUNvbm5lY3Rpb25TdHJpbmcoY29ubmVjdGlvblN0cmluZykge1xuICBjb25zdCB7IHBhdGhuYW1lLCBzZWFyY2hQYXJhbXMgfSA9IG5ldyBVUkwoY29ubmVjdGlvblN0cmluZyk7XG4gIGNvbnN0IHB1YmtleSA9IHBhdGhuYW1lO1xuICBjb25zdCByZWxheSA9IHNlYXJjaFBhcmFtcy5nZXQoXCJyZWxheVwiKTtcbiAgY29uc3Qgc2VjcmV0ID0gc2VhcmNoUGFyYW1zLmdldChcInNlY3JldFwiKTtcbiAgaWYgKCFwdWJrZXkgfHwgIXJlbGF5IHx8ICFzZWNyZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNvbm5lY3Rpb24gc3RyaW5nXCIpO1xuICB9XG4gIHJldHVybiB7IHB1YmtleSwgcmVsYXksIHNlY3JldCB9O1xufVxuYXN5bmMgZnVuY3Rpb24gbWFrZU53Y1JlcXVlc3RFdmVudChwdWJrZXksIHNlY3JldEtleSwgaW52b2ljZSkge1xuICBjb25zdCBjb250ZW50ID0ge1xuICAgIG1ldGhvZDogXCJwYXlfaW52b2ljZVwiLFxuICAgIHBhcmFtczoge1xuICAgICAgaW52b2ljZVxuICAgIH1cbiAgfTtcbiAgY29uc3QgZW5jcnlwdGVkQ29udGVudCA9IGF3YWl0IGVuY3J5cHQoc2VjcmV0S2V5LCBwdWJrZXksIEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpKTtcbiAgY29uc3QgZXZlbnRUZW1wbGF0ZSA9IHtcbiAgICBraW5kOiBOV0NXYWxsZXRSZXF1ZXN0LFxuICAgIGNyZWF0ZWRfYXQ6IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDFlMyksXG4gICAgY29udGVudDogZW5jcnlwdGVkQ29udGVudCxcbiAgICB0YWdzOiBbW1wicFwiLCBwdWJrZXldXVxuICB9O1xuICByZXR1cm4gZmluYWxpemVFdmVudChldmVudFRlbXBsYXRlLCBzZWNyZXRLZXkpO1xufVxuXG4vLyBuaXA1NC50c1xudmFyIG5pcDU0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDU0X2V4cG9ydHMsIHtcbiAgbm9ybWFsaXplSWRlbnRpZmllcjogKCkgPT4gbm9ybWFsaXplSWRlbnRpZmllclxufSk7XG5mdW5jdGlvbiBub3JtYWxpemVJZGVudGlmaWVyKG5hbWUpIHtcbiAgbmFtZSA9IG5hbWUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIG5hbWUgPSBuYW1lLm5vcm1hbGl6ZShcIk5GS0NcIik7XG4gIHJldHVybiBBcnJheS5mcm9tKG5hbWUpLm1hcCgoY2hhcikgPT4ge1xuICAgIGlmICgvXFxwe0xldHRlcn0vdS50ZXN0KGNoYXIpIHx8IC9cXHB7TnVtYmVyfS91LnRlc3QoY2hhcikpIHtcbiAgICAgIHJldHVybiBjaGFyO1xuICAgIH1cbiAgICByZXR1cm4gXCItXCI7XG4gIH0pLmpvaW4oXCJcIik7XG59XG5cbi8vIG5pcDU3LnRzXG52YXIgbmlwNTdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNTdfZXhwb3J0cywge1xuICBnZXRaYXBFbmRwb2ludDogKCkgPT4gZ2V0WmFwRW5kcG9pbnQsXG4gIG1ha2VaYXBSZWNlaXB0OiAoKSA9PiBtYWtlWmFwUmVjZWlwdCxcbiAgbWFrZVphcFJlcXVlc3Q6ICgpID0+IG1ha2VaYXBSZXF1ZXN0LFxuICB1c2VGZXRjaEltcGxlbWVudGF0aW9uOiAoKSA9PiB1c2VGZXRjaEltcGxlbWVudGF0aW9uNCxcbiAgdmFsaWRhdGVaYXBSZXF1ZXN0OiAoKSA9PiB2YWxpZGF0ZVphcFJlcXVlc3Rcbn0pO1xuaW1wb3J0IHsgYmVjaDMyIGFzIGJlY2gzMjIgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbnZhciBfZmV0Y2g0O1xudHJ5IHtcbiAgX2ZldGNoNCA9IGZldGNoO1xufSBjYXRjaCB7XG59XG5mdW5jdGlvbiB1c2VGZXRjaEltcGxlbWVudGF0aW9uNChmZXRjaEltcGxlbWVudGF0aW9uKSB7XG4gIF9mZXRjaDQgPSBmZXRjaEltcGxlbWVudGF0aW9uO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0WmFwRW5kcG9pbnQobWV0YWRhdGEpIHtcbiAgdHJ5IHtcbiAgICBsZXQgbG51cmwgPSBcIlwiO1xuICAgIGxldCB7IGx1ZDA2LCBsdWQxNiB9ID0gSlNPTi5wYXJzZShtZXRhZGF0YS5jb250ZW50KTtcbiAgICBpZiAobHVkMDYpIHtcbiAgICAgIGxldCB7IHdvcmRzIH0gPSBiZWNoMzIyLmRlY29kZShsdWQwNiwgMWUzKTtcbiAgICAgIGxldCBkYXRhID0gYmVjaDMyMi5mcm9tV29yZHMod29yZHMpO1xuICAgICAgbG51cmwgPSB1dGY4RGVjb2Rlci5kZWNvZGUoZGF0YSk7XG4gICAgfSBlbHNlIGlmIChsdWQxNikge1xuICAgICAgbGV0IFtuYW1lLCBkb21haW5dID0gbHVkMTYuc3BsaXQoXCJAXCIpO1xuICAgICAgbG51cmwgPSBuZXcgVVJMKGAvLndlbGwta25vd24vbG51cmxwLyR7bmFtZX1gLCBgaHR0cHM6Ly8ke2RvbWFpbn1gKS50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHJlcyA9IGF3YWl0IF9mZXRjaDQobG51cmwpO1xuICAgIGxldCBib2R5ID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBpZiAoYm9keS5hbGxvd3NOb3N0ciAmJiBib2R5Lm5vc3RyUHVia2V5KSB7XG4gICAgICByZXR1cm4gYm9keS5jYWxsYmFjaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWFrZVphcFJlcXVlc3Qoe1xuICBwcm9maWxlLFxuICBldmVudCxcbiAgYW1vdW50LFxuICByZWxheXMsXG4gIGNvbW1lbnQgPSBcIlwiXG59KSB7XG4gIGlmICghYW1vdW50KVxuICAgIHRocm93IG5ldyBFcnJvcihcImFtb3VudCBub3QgZ2l2ZW5cIik7XG4gIGlmICghcHJvZmlsZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9maWxlIG5vdCBnaXZlblwiKTtcbiAgbGV0IHpyID0ge1xuICAgIGtpbmQ6IDk3MzQsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMWUzKSxcbiAgICBjb250ZW50OiBjb21tZW50LFxuICAgIHRhZ3M6IFtcbiAgICAgIFtcInBcIiwgcHJvZmlsZV0sXG4gICAgICBbXCJhbW91bnRcIiwgYW1vdW50LnRvU3RyaW5nKCldLFxuICAgICAgW1wicmVsYXlzXCIsIC4uLnJlbGF5c11cbiAgICBdXG4gIH07XG4gIGlmIChldmVudCAmJiB0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICB6ci50YWdzLnB1c2goW1wiZVwiLCBldmVudF0pO1xuICB9XG4gIGlmIChldmVudCAmJiB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoaXNSZXBsYWNlYWJsZUtpbmQoZXZlbnQua2luZCkpIHtcbiAgICAgIGNvbnN0IGEgPSBbXCJhXCIsIGAke2V2ZW50LmtpbmR9OiR7ZXZlbnQucHVia2V5fTpgXTtcbiAgICAgIHpyLnRhZ3MucHVzaChhKTtcbiAgICB9IGVsc2UgaWYgKGlzQWRkcmVzc2FibGVLaW5kKGV2ZW50LmtpbmQpKSB7XG4gICAgICBsZXQgZCA9IGV2ZW50LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSBcImRcIiAmJiB2KTtcbiAgICAgIGlmICghZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZCB0YWcgbm90IGZvdW5kIG9yIGlzIGVtcHR5XCIpO1xuICAgICAgY29uc3QgYSA9IFtcImFcIiwgYCR7ZXZlbnQua2luZH06JHtldmVudC5wdWJrZXl9OiR7ZFsxXX1gXTtcbiAgICAgIHpyLnRhZ3MucHVzaChhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHpyO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVaYXBSZXF1ZXN0KHphcFJlcXVlc3RTdHJpbmcpIHtcbiAgbGV0IHphcFJlcXVlc3Q7XG4gIHRyeSB7XG4gICAgemFwUmVxdWVzdCA9IEpTT04ucGFyc2UoemFwUmVxdWVzdFN0cmluZyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBcIkludmFsaWQgemFwIHJlcXVlc3QgSlNPTi5cIjtcbiAgfVxuICBpZiAoIXZhbGlkYXRlRXZlbnQoemFwUmVxdWVzdCkpXG4gICAgcmV0dXJuIFwiWmFwIHJlcXVlc3QgaXMgbm90IGEgdmFsaWQgTm9zdHIgZXZlbnQuXCI7XG4gIGlmICghdmVyaWZ5RXZlbnQoemFwUmVxdWVzdCkpXG4gICAgcmV0dXJuIFwiSW52YWxpZCBzaWduYXR1cmUgb24gemFwIHJlcXVlc3QuXCI7XG4gIGxldCBwID0gemFwUmVxdWVzdC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gXCJwXCIgJiYgdik7XG4gIGlmICghcClcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBkb2Vzbid0IGhhdmUgYSAncCcgdGFnLlwiO1xuICBpZiAoIXBbMV0ubWF0Y2goL15bYS1mMC05XXs2NH0kLykpXG4gICAgcmV0dXJuIFwiWmFwIHJlcXVlc3QgJ3AnIHRhZyBpcyBub3QgdmFsaWQgaGV4LlwiO1xuICBsZXQgZSA9IHphcFJlcXVlc3QudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IFwiZVwiICYmIHYpO1xuICBpZiAoZSAmJiAhZVsxXS5tYXRjaCgvXlthLWYwLTldezY0fSQvKSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCAnZScgdGFnIGlzIG5vdCB2YWxpZCBoZXguXCI7XG4gIGxldCByZWxheXMgPSB6YXBSZXF1ZXN0LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSBcInJlbGF5c1wiICYmIHYpO1xuICBpZiAoIXJlbGF5cylcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBkb2Vzbid0IGhhdmUgYSAncmVsYXlzJyB0YWcuXCI7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWFrZVphcFJlY2VpcHQoe1xuICB6YXBSZXF1ZXN0LFxuICBwcmVpbWFnZSxcbiAgYm9sdDExLFxuICBwYWlkQXRcbn0pIHtcbiAgbGV0IHpyID0gSlNPTi5wYXJzZSh6YXBSZXF1ZXN0KTtcbiAgbGV0IHRhZ3NGcm9tWmFwUmVxdWVzdCA9IHpyLnRhZ3MuZmlsdGVyKChbdF0pID0+IHQgPT09IFwiZVwiIHx8IHQgPT09IFwicFwiIHx8IHQgPT09IFwiYVwiKTtcbiAgbGV0IHphcCA9IHtcbiAgICBraW5kOiA5NzM1LFxuICAgIGNyZWF0ZWRfYXQ6IE1hdGgucm91bmQocGFpZEF0LmdldFRpbWUoKSAvIDFlMyksXG4gICAgY29udGVudDogXCJcIixcbiAgICB0YWdzOiBbLi4udGFnc0Zyb21aYXBSZXF1ZXN0LCBbXCJQXCIsIHpyLnB1YmtleV0sIFtcImJvbHQxMVwiLCBib2x0MTFdLCBbXCJkZXNjcmlwdGlvblwiLCB6YXBSZXF1ZXN0XV1cbiAgfTtcbiAgaWYgKHByZWltYWdlKSB7XG4gICAgemFwLnRhZ3MucHVzaChbXCJwcmVpbWFnZVwiLCBwcmVpbWFnZV0pO1xuICB9XG4gIHJldHVybiB6YXA7XG59XG5cbi8vIG5pcDk4LnRzXG52YXIgbmlwOThfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwOThfZXhwb3J0cywge1xuICBnZXRUb2tlbjogKCkgPT4gZ2V0VG9rZW4sXG4gIGhhc2hQYXlsb2FkOiAoKSA9PiBoYXNoUGF5bG9hZCxcbiAgdW5wYWNrRXZlbnRGcm9tVG9rZW46ICgpID0+IHVucGFja0V2ZW50RnJvbVRva2VuLFxuICB2YWxpZGF0ZUV2ZW50OiAoKSA9PiB2YWxpZGF0ZUV2ZW50MixcbiAgdmFsaWRhdGVFdmVudEtpbmQ6ICgpID0+IHZhbGlkYXRlRXZlbnRLaW5kLFxuICB2YWxpZGF0ZUV2ZW50TWV0aG9kVGFnOiAoKSA9PiB2YWxpZGF0ZUV2ZW50TWV0aG9kVGFnLFxuICB2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZzogKCkgPT4gdmFsaWRhdGVFdmVudFBheWxvYWRUYWcsXG4gIHZhbGlkYXRlRXZlbnRUaW1lc3RhbXA6ICgpID0+IHZhbGlkYXRlRXZlbnRUaW1lc3RhbXAsXG4gIHZhbGlkYXRlRXZlbnRVcmxUYWc6ICgpID0+IHZhbGlkYXRlRXZlbnRVcmxUYWcsXG4gIHZhbGlkYXRlVG9rZW46ICgpID0+IHZhbGlkYXRlVG9rZW5cbn0pO1xuaW1wb3J0IHsgc2hhMjU2IGFzIHNoYTI1NjQgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIjtcbmltcG9ydCB7IGJ5dGVzVG9IZXggYXMgYnl0ZXNUb0hleDUgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuaW1wb3J0IHsgYmFzZTY0IGFzIGJhc2U2NDMgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbnZhciBfYXV0aG9yaXphdGlvblNjaGVtZSA9IFwiTm9zdHIgXCI7XG5hc3luYyBmdW5jdGlvbiBnZXRUb2tlbihsb2dpblVybCwgaHR0cE1ldGhvZCwgc2lnbiwgaW5jbHVkZUF1dGhvcml6YXRpb25TY2hlbWUgPSBmYWxzZSwgcGF5bG9hZCkge1xuICBjb25zdCBldmVudCA9IHtcbiAgICBraW5kOiBIVFRQQXV0aCxcbiAgICB0YWdzOiBbXG4gICAgICBbXCJ1XCIsIGxvZ2luVXJsXSxcbiAgICAgIFtcIm1ldGhvZFwiLCBodHRwTWV0aG9kXVxuICAgIF0sXG4gICAgY3JlYXRlZF9hdDogTWF0aC5yb3VuZChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDFlMyksXG4gICAgY29udGVudDogXCJcIlxuICB9O1xuICBpZiAocGF5bG9hZCkge1xuICAgIGV2ZW50LnRhZ3MucHVzaChbXCJwYXlsb2FkXCIsIGhhc2hQYXlsb2FkKHBheWxvYWQpXSk7XG4gIH1cbiAgY29uc3Qgc2lnbmVkRXZlbnQgPSBhd2FpdCBzaWduKGV2ZW50KTtcbiAgY29uc3QgYXV0aG9yaXphdGlvblNjaGVtZSA9IGluY2x1ZGVBdXRob3JpemF0aW9uU2NoZW1lID8gX2F1dGhvcml6YXRpb25TY2hlbWUgOiBcIlwiO1xuICByZXR1cm4gYXV0aG9yaXphdGlvblNjaGVtZSArIGJhc2U2NDMuZW5jb2RlKHV0ZjhFbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeShzaWduZWRFdmVudCkpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlVG9rZW4odG9rZW4sIHVybCwgbWV0aG9kKSB7XG4gIGNvbnN0IGV2ZW50ID0gYXdhaXQgdW5wYWNrRXZlbnRGcm9tVG9rZW4odG9rZW4pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgIHRocm93IGVycm9yO1xuICB9KTtcbiAgY29uc3QgdmFsaWQgPSBhd2FpdCB2YWxpZGF0ZUV2ZW50MihldmVudCwgdXJsLCBtZXRob2QpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgIHRocm93IGVycm9yO1xuICB9KTtcbiAgcmV0dXJuIHZhbGlkO1xufVxuYXN5bmMgZnVuY3Rpb24gdW5wYWNrRXZlbnRGcm9tVG9rZW4odG9rZW4pIHtcbiAgaWYgKCF0b2tlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdG9rZW5cIik7XG4gIH1cbiAgdG9rZW4gPSB0b2tlbi5yZXBsYWNlKF9hdXRob3JpemF0aW9uU2NoZW1lLCBcIlwiKTtcbiAgY29uc3QgZXZlbnRCNjQgPSB1dGY4RGVjb2Rlci5kZWNvZGUoYmFzZTY0My5kZWNvZGUodG9rZW4pKTtcbiAgaWYgKCFldmVudEI2NCB8fCBldmVudEI2NC5sZW5ndGggPT09IDAgfHwgIWV2ZW50QjY0LnN0YXJ0c1dpdGgoXCJ7XCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0b2tlblwiKTtcbiAgfVxuICBjb25zdCBldmVudCA9IEpTT04ucGFyc2UoZXZlbnRCNjQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUV2ZW50VGltZXN0YW1wKGV2ZW50KSB7XG4gIGlmICghZXZlbnQuY3JlYXRlZF9hdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gTWF0aC5yb3VuZChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDFlMykgLSBldmVudC5jcmVhdGVkX2F0IDwgNjA7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUV2ZW50S2luZChldmVudCkge1xuICByZXR1cm4gZXZlbnQua2luZCA9PT0gSFRUUEF1dGg7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUV2ZW50VXJsVGFnKGV2ZW50LCB1cmwpIHtcbiAgY29uc3QgdXJsVGFnID0gZXZlbnQudGFncy5maW5kKCh0KSA9PiB0WzBdID09PSBcInVcIik7XG4gIGlmICghdXJsVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB1cmxUYWcubGVuZ3RoID4gMCAmJiB1cmxUYWdbMV0gPT09IHVybDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRNZXRob2RUYWcoZXZlbnQsIG1ldGhvZCkge1xuICBjb25zdCBtZXRob2RUYWcgPSBldmVudC50YWdzLmZpbmQoKHQpID0+IHRbMF0gPT09IFwibWV0aG9kXCIpO1xuICBpZiAoIW1ldGhvZFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbWV0aG9kVGFnLmxlbmd0aCA+IDAgJiYgbWV0aG9kVGFnWzFdLnRvTG93ZXJDYXNlKCkgPT09IG1ldGhvZC50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gaGFzaFBheWxvYWQocGF5bG9hZCkge1xuICBjb25zdCBoYXNoID0gc2hhMjU2NCh1dGY4RW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpKTtcbiAgcmV0dXJuIGJ5dGVzVG9IZXg1KGhhc2gpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVFdmVudFBheWxvYWRUYWcoZXZlbnQsIHBheWxvYWQpIHtcbiAgY29uc3QgcGF5bG9hZFRhZyA9IGV2ZW50LnRhZ3MuZmluZCgodCkgPT4gdFswXSA9PT0gXCJwYXlsb2FkXCIpO1xuICBpZiAoIXBheWxvYWRUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcGF5bG9hZEhhc2ggPSBoYXNoUGF5bG9hZChwYXlsb2FkKTtcbiAgcmV0dXJuIHBheWxvYWRUYWcubGVuZ3RoID4gMCAmJiBwYXlsb2FkVGFnWzFdID09PSBwYXlsb2FkSGFzaDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlRXZlbnQyKGV2ZW50LCB1cmwsIG1ldGhvZCwgYm9keSkge1xuICBpZiAoIXZlcmlmeUV2ZW50KGV2ZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIHNpZ25hdHVyZSBpbnZhbGlkXCIpO1xuICB9XG4gIGlmICghdmFsaWRhdGVFdmVudEtpbmQoZXZlbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwga2luZCBpbnZhbGlkXCIpO1xuICB9XG4gIGlmICghdmFsaWRhdGVFdmVudFRpbWVzdGFtcChldmVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vc3RyIGV2ZW50LCBjcmVhdGVkX2F0IHRpbWVzdGFtcCBpbnZhbGlkXCIpO1xuICB9XG4gIGlmICghdmFsaWRhdGVFdmVudFVybFRhZyhldmVudCwgdXJsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIHVybCB0YWcgaW52YWxpZFwiKTtcbiAgfVxuICBpZiAoIXZhbGlkYXRlRXZlbnRNZXRob2RUYWcoZXZlbnQsIG1ldGhvZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vc3RyIGV2ZW50LCBtZXRob2QgdGFnIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKEJvb2xlYW4oYm9keSkgJiYgdHlwZW9mIGJvZHkgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMoYm9keSkubGVuZ3RoID4gMCkge1xuICAgIGlmICghdmFsaWRhdGVFdmVudFBheWxvYWRUYWcoZXZlbnQsIGJvZHkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vc3RyIGV2ZW50LCBwYXlsb2FkIHRhZyBkb2VzIG5vdCBtYXRjaCByZXF1ZXN0IGJvZHkgaGFzaFwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQge1xuICBSZWxheSxcbiAgU2ltcGxlUG9vbCxcbiAgZmluYWxpemVFdmVudCxcbiAgZmFrZWpzb25fZXhwb3J0cyBhcyBmaixcbiAgZ2VuZXJhdGVTZWNyZXRLZXksXG4gIGdldEV2ZW50SGFzaCxcbiAgZ2V0RmlsdGVyTGltaXQsXG4gIGdldFB1YmxpY0tleSxcbiAga2luZHNfZXhwb3J0cyBhcyBraW5kcyxcbiAgbWF0Y2hGaWx0ZXIsXG4gIG1hdGNoRmlsdGVycyxcbiAgbWVyZ2VGaWx0ZXJzLFxuICBuaXAwNF9leHBvcnRzIGFzIG5pcDA0LFxuICBuaXAwNV9leHBvcnRzIGFzIG5pcDA1LFxuICBuaXAxMF9leHBvcnRzIGFzIG5pcDEwLFxuICBuaXAxMV9leHBvcnRzIGFzIG5pcDExLFxuICBuaXAxM19leHBvcnRzIGFzIG5pcDEzLFxuICBuaXAxN19leHBvcnRzIGFzIG5pcDE3LFxuICBuaXAxOF9leHBvcnRzIGFzIG5pcDE4LFxuICBuaXAxOV9leHBvcnRzIGFzIG5pcDE5LFxuICBuaXAyMV9leHBvcnRzIGFzIG5pcDIxLFxuICBuaXAyNV9leHBvcnRzIGFzIG5pcDI1LFxuICBuaXAyN19leHBvcnRzIGFzIG5pcDI3LFxuICBuaXAyOF9leHBvcnRzIGFzIG5pcDI4LFxuICBuaXAzMF9leHBvcnRzIGFzIG5pcDMwLFxuICBuaXAzOV9leHBvcnRzIGFzIG5pcDM5LFxuICBuaXA0Ml9leHBvcnRzIGFzIG5pcDQyLFxuICBuaXA0NF9leHBvcnRzIGFzIG5pcDQ0LFxuICBuaXA0N19leHBvcnRzIGFzIG5pcDQ3LFxuICBuaXA1NF9leHBvcnRzIGFzIG5pcDU0LFxuICBuaXA1N19leHBvcnRzIGFzIG5pcDU3LFxuICBuaXA1OV9leHBvcnRzIGFzIG5pcDU5LFxuICBuaXA5OF9leHBvcnRzIGFzIG5pcDk4LFxuICBwYXJzZVJlZmVyZW5jZXMsXG4gIHNlcmlhbGl6ZUV2ZW50LFxuICBzb3J0RXZlbnRzLFxuICB1dGlsc19leHBvcnRzIGFzIHV0aWxzLFxuICB2YWxpZGF0ZUV2ZW50LFxuICB2ZXJpZmllZFN5bWJvbCxcbiAgdmVyaWZ5RXZlbnRcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQzBDO0FBQ3FCO0FBQ1A7QUFDeEQ7QUFDTztBQUNQO0FBQ0E7QUFDQSxnQ0FBZ0Msd0RBQUksWUFBWSxnRUFBVztBQUMzRCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLHFFQUFXLEdBQUcsK0JBQStCO0FBQzFFLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhYmxvZmVybmFuZGV6L3Rlc3QxMjMvVEVORVgtcGZrbWM5L21haW4vbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay1jYWNoZS1kZXhpZS9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG5pbXBvcnQgeyBjb25jYXRCeXRlcywgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IHdlaWVyc3RyYXNzIH0gZnJvbSAnLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyc7XG4vLyBjb25uZWN0cyBub2JsZS1jdXJ2ZXMgdG8gbm9ibGUtaGFzaGVzXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGFzaChoYXNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaCxcbiAgICAgICAgaG1hYzogKGtleSwgLi4ubXNncykgPT4gaG1hYyhoYXNoLCBrZXksIGNvbmNhdEJ5dGVzKC4uLm1zZ3MpKSxcbiAgICAgICAgcmFuZG9tQnl0ZXMsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDdXJ2ZShjdXJ2ZURlZiwgZGVmSGFzaCkge1xuICAgIGNvbnN0IGNyZWF0ZSA9IChoYXNoKSA9PiB3ZWllcnN0cmFzcyh7IC4uLmN1cnZlRGVmLCAuLi5nZXRIYXNoKGhhc2gpIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4uY3JlYXRlKGRlZkhhc2gpLCBjcmVhdGUgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hvcnR3X3V0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDc0Q7QUFDVjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCx5Q0FBeUM7QUFDekMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUCxJQUFJLDBEQUFhO0FBQ2pCLElBQUkseURBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVyxvREFBTztBQUNsQjtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFibG9mZXJuYW5kZXovdGVzdDEyMy9URU5FWC1wZmttYzkvbWFpbi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gQWJlbGlhbiBncm91cCB1dGlsaXRpZXNcbmltcG9ydCB7IHZhbGlkYXRlRmllbGQsIG5MZW5ndGggfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbi8vIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbi8vIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuLy8gQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4vLyAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbi8vIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3Jcbi8vIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbi8vIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuLy8gLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuLy8gLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbi8vIFRPRE86IFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy4gVGhpcyB3b3VsZCBhbGxvd1xuLy8gd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHdOQUYoYywgYml0cykge1xuICAgIGNvbnN0IGNvbnN0VGltZU5lZ2F0ZSA9IChjb25kaXRpb24sIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gKFcpID0+IHtcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IE1hdGguY2VpbChiaXRzIC8gVykgKyAxOyAvLyArMSwgYmVjYXVzZVxuICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplIH07XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25zdFRpbWVOZWdhdGUsXG4gICAgICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuKSB7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBkID0gZWxtO1xuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgICAgICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cbiAgICAgICAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxuICAgICAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcbiAgICAgICAgICogLSDwnZGKIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiAtIPCdkZsgaXMgdGhlIGJpdGxlbmd0aCBvZiB0aGUgY3VydmUgb3JkZXIuXG4gICAgICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHAgPSBlbG07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIC8vID0xLCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLmFkZChwKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcmV0dXJucyByZWFsIGFuZCBmYWtlIChmb3IgY29uc3QtdGltZSkgcG9pbnRzXG4gICAgICAgICAqL1xuICAgICAgICB3TkFGKFcsIHByZWNvbXB1dGVzLCBuKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYXliZSBjaGVjayB0aGF0IHNjYWxhciBpcyBsZXNzIHRoYW4gZ3JvdXAgb3JkZXI/IHdOQUYgYmVoYXZpb3VzIGlzIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIEJ1dCBuZWVkIHRvIGNhcmVmdWxseSByZW1vdmUgb3RoZXIgY2hlY2tzIGJlZm9yZSB3TkFGLiBPUkRFUiA9PSBiaXRzIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGYgPSBjLkJBU0U7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuICAgICAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IFcgYml0cy5cbiAgICAgICAgICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spO1xuICAgICAgICAgICAgICAgIC8vIFNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbiA+Pj0gc2hpZnRCeTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYml0cyBhcmUgYmlnZ2VyIHRoYW4gbWF4IHNpemUsIHdlJ2xsIHNwbGl0IHRob3NlLlxuICAgICAgICAgICAgICAgIC8vICsyMjQgPT4gMjU2IC0gMzJcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHdiaXRzIC09IG1heE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgbiArPSBfMW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGVhY2ggYWRkaXRpb24gaXMgbXVsdGlwbGllZCBieSAyICoqIFcsIGl0IGNhbm5vdCBjYW5jZWwgZWFjaCBvdGhlci4gSG93ZXZlcixcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBuZWdhdGUgbm93OiBpdCBpcyBwb3NzaWJsZSB0aGF0IG5lZ2F0ZWQgZWxlbWVudCBmcm9tIGxvdyB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBvYnZpb3VzIGhvdyB0aGlzIGNhbiBmYWlsLCBidXQgc3RpbGwgd29ydGggaW52ZXN0aWdhdGluZyBsYXRlci5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBvbnRvIFplcm8gcG9pbnQuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJhbmRvbSBwb2ludCBpbnNpZGUgY3VycmVudCB3aW5kb3cgdG8gZi5cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQxID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQxID0gd2luZG93ICUgMiAhPT0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMiA9IHdiaXRzIDwgMDtcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1vc3QgaW1wb3J0YW50IHBhcnQgZm9yIGNvbnN0LXRpbWUgZ2V0UHVibGljS2V5XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDEsIHByZWNvbXB1dGVzW29mZnNldDFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQyLCBwcmVjb21wdXRlc1tvZmZzZXQyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEpJVC1jb21waWxlciBzaG91bGQgbm90IGVsaW1pbmF0ZSBmIGhlcmUsIHNpbmNlIGl0IHdpbGwgbGF0ZXIgYmUgdXNlZCBpbiBub3JtYWxpemVaKClcbiAgICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlIHZhcmlhYmxlIGlzIHN0aWxsIHVudXNlZCwgdGhlcmUgYXJlIHNvbWUgY2hlY2tzIHdoaWNoIHdpbGxcbiAgICAgICAgICAgIC8vIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gY29tcGlsZXIgbmVlZHMgdG8gcHJvdmUgdGhleSB3b24ndCBoYXBwZW4sIHdoaWNoIGlzIGhhcmQuXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZXJlIGlzIGEgd2F5IHRvIEYgYmUgaW5maW5pdHktcG9pbnQgZXZlbiBpZiBwIGlzIG5vdCxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1ha2VzIGl0IGxlc3MgY29uc3QtdGltZTogYXJvdW5kIDEgYmlnaW50IG11bHRpcGx5LlxuICAgICAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkKFAsIHByZWNvbXB1dGVzTWFwLCBuLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFcgPSBQLl9XSU5ET1dfU0laRSB8fCAxO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHByZWNvbXB1dGVzTWFwLmdldChQKTtcbiAgICAgICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgICAgIGNvbXAgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coUCwgVyk7XG4gICAgICAgICAgICAgICAgaWYgKFcgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29tcHV0ZXNNYXAuc2V0KFAsIHRyYW5zZm9ybShjb21wKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRihXLCBjb21wLCBuKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcbiAgICB2YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array)\n        return dst;\n    if (typeof dst === 'string')\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(dst);\n    throw new Error('DST must be Uint8Array or string');\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1DO0FBQ29EO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPLFNBQVMsT0FBTztBQUN4RTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBVyxDQUFDLHNEQUFXO0FBQ3ZDLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBVztBQUNqQztBQUNBLDRDQUE0QztBQUM1QztBQUNBLGtCQUFrQixzREFBVztBQUM3QixhQUFhLHNEQUFXO0FBQ3hCLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0EsaUJBQWlCLHNEQUFXO0FBQzVCO0FBQ0EsZ0NBQWdDLHNEQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPLFNBQVMsc0RBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkVBQTZFO0FBQ2pHO0FBQ0E7QUFDTztBQUNQLElBQUkseURBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLG1DQUFtQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFHO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlEQUFpRDtBQUNqRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtDQUFrQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3Q0FBd0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhYmxvZmVybmFuZGV6L3Rlc3QxMjMvVEVORVgtcGZrbWM5L21haW4vbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay1jYWNoZS1kZXhpZS9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbW9kIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIHV0ZjhUb0J5dGVzLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVEU1QoZHN0KSB7XG4gICAgaWYgKGRzdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgaWYgKHR5cGVvZiBkc3QgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoZHN0KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RTVCBtdXN0IGJlIFVpbnQ4QXJyYXkgb3Igc3RyaW5nJyk7XG59XG4vLyBPY3RldCBTdHJlYW0gdG8gSW50ZWdlci4gXCJzcGVjXCIgaW1wbGVtZW50YXRpb24gb2Ygb3MyaXAgaXMgMi41eCBzbG93ZXIgdnMgYnl0ZXNUb051bWJlckJFLlxuY29uc3Qgb3MyaXAgPSBieXRlc1RvTnVtYmVyQkU7XG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxuZnVuY3Rpb24gaTJvc3AodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMSA8PCAoOCAqIGxlbmd0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgSTJPU1AgY2FsbDogdmFsdWU9JHt2YWx1ZX0gbGVuZ3RoPSR7bGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0pLmZpbGwoMCk7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHJlc1tpXSA9IHZhbHVlICYgMHhmZjtcbiAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzKTtcbn1cbmZ1bmN0aW9uIHN0cnhvcihhLCBiKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhW2ldIF4gYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIGlzQnl0ZXMoaXRlbSkge1xuICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG59XG5mdW5jdGlvbiBpc051bShpdGVtKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgZXhwZWN0ZWQnKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhIGNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbiBIIHRoYXQgb3V0cHV0cyBiIGJpdHNcbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjFcbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbkluQnl0ZXMsIEgpIHtcbiAgICBpc0J5dGVzKG1zZyk7XG4gICAgaXNCeXRlcyhEU1QpO1xuICAgIGlzTnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgRFNUID0gSChjb25jYXRCeXRlcyh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSwgRFNUKSk7XG4gICAgY29uc3QgeyBvdXRwdXRMZW46IGJfaW5fYnl0ZXMsIGJsb2NrTGVuOiByX2luX2J5dGVzIH0gPSBIO1xuICAgIGNvbnN0IGVsbCA9IE1hdGguY2VpbChsZW5JbkJ5dGVzIC8gYl9pbl9ieXRlcyk7XG4gICAgaWYgKGVsbCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHhtZCBsZW5ndGgnKTtcbiAgICBjb25zdCBEU1RfcHJpbWUgPSBjb25jYXRCeXRlcyhEU1QsIGkyb3NwKERTVC5sZW5ndGgsIDEpKTtcbiAgICBjb25zdCBaX3BhZCA9IGkyb3NwKDAsIHJfaW5fYnl0ZXMpO1xuICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpOyAvLyBsZW5faW5fYnl0ZXNfc3RyXG4gICAgY29uc3QgYiA9IG5ldyBBcnJheShlbGwpO1xuICAgIGNvbnN0IGJfMCA9IEgoY29uY2F0Qnl0ZXMoWl9wYWQsIG1zZywgbF9pX2Jfc3RyLCBpMm9zcCgwLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgYlswXSA9IEgoY29uY2F0Qnl0ZXMoYl8wLCBpMm9zcCgxLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZWxsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFtzdHJ4b3IoYl8wLCBiW2kgLSAxXSksIGkyb3NwKGkgKyAxLCAxKSwgRFNUX3ByaW1lXTtcbiAgICAgICAgYltpXSA9IEgoY29uY2F0Qnl0ZXMoLi4uYXJncykpO1xuICAgIH1cbiAgICBjb25zdCBwc2V1ZG9fcmFuZG9tX2J5dGVzID0gY29uY2F0Qnl0ZXMoLi4uYik7XG4gICAgcmV0dXJuIHBzZXVkb19yYW5kb21fYnl0ZXMuc2xpY2UoMCwgbGVuSW5CeXRlcyk7XG59XG4vLyBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYW4gZXh0ZW5kYWJsZS1vdXRwdXQgZnVuY3Rpb24gKFhPRikgSC5cbi8vIDEuIFRoZSBjb2xsaXNpb24gcmVzaXN0YW5jZSBvZiBIIE1VU1QgYmUgYXQgbGVhc3QgayBiaXRzLlxuLy8gMi4gSCBNVVNUIGJlIGFuIFhPRiB0aGF0IGhhcyBiZWVuIHByb3ZlZCBpbmRpZmZlcmVudGlhYmxlIGZyb21cbi8vICAgIGEgcmFuZG9tIG9yYWNsZSB1bmRlciBhIHJlYXNvbmFibGUgY3J5cHRvZ3JhcGhpYyBhc3N1bXB0aW9uLlxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMlxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuSW5CeXRlcywgaywgSCkge1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc0J5dGVzKERTVCk7XG4gICAgaXNOdW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIC8vIERTVCA9IEgoJ0gyQy1PVkVSU0laRS1EU1QtJyB8fCBhX3ZlcnlfbG9uZ19EU1QsIE1hdGguY2VpbCgobGVuSW5CeXRlcyAqIGspIC8gOCkpO1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgIGNvbnN0IGRrTGVuID0gTWF0aC5jZWlsKCgyICogaykgLyA4KTtcbiAgICAgICAgRFNUID0gSC5jcmVhdGUoeyBka0xlbiB9KS51cGRhdGUodXRmOFRvQnl0ZXMoJ0gyQy1PVkVSU0laRS1EU1QtJykpLnVwZGF0ZShEU1QpLmRpZ2VzdCgpO1xuICAgIH1cbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG9mOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcbiAgICByZXR1cm4gKEguY3JlYXRlKHsgZGtMZW46IGxlbkluQnl0ZXMgfSlcbiAgICAgICAgLnVwZGF0ZShtc2cpXG4gICAgICAgIC51cGRhdGUoaTJvc3AobGVuSW5CeXRlcywgMikpXG4gICAgICAgIC8vIDIuIERTVF9wcmltZSA9IERTVCB8fCBJMk9TUChsZW4oRFNUKSwgMSlcbiAgICAgICAgLnVwZGF0ZShEU1QpXG4gICAgICAgIC51cGRhdGUoaTJvc3AoRFNULmxlbmd0aCwgMSkpXG4gICAgICAgIC5kaWdlc3QoKSk7XG59XG4vKipcbiAqIEhhc2hlcyBhcmJpdHJhcnktbGVuZ3RoIGJ5dGUgc3RyaW5ncyB0byBhIGxpc3Qgb2Ygb25lIG9yIG1vcmUgZWxlbWVudHMgb2YgYSBmaW5pdGUgZmllbGQgRlxuICogaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjJcbiAqIEBwYXJhbSBtc2cgYSBieXRlIHN0cmluZyBjb250YWluaW5nIHRoZSBtZXNzYWdlIHRvIGhhc2hcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIEYgdG8gb3V0cHV0XG4gKiBAcGFyYW0gb3B0aW9ucyBge0RTVDogc3RyaW5nLCBwOiBiaWdpbnQsIG06IG51bWJlciwgazogbnVtYmVyLCBleHBhbmQ6ICd4bWQnIHwgJ3hvZicsIGhhc2g6IEh9YCwgc2VlIGFib3ZlXG4gKiBAcmV0dXJucyBbdV8wLCAuLi4sIHVfKGNvdW50IC0gMSldLCBhIGxpc3Qgb2YgZmllbGQgZWxlbWVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoX3RvX2ZpZWxkKG1zZywgY291bnQsIG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCB7XG4gICAgICAgIERTVDogJ3N0cmluZ09yVWludDhBcnJheScsXG4gICAgICAgIHA6ICdiaWdpbnQnLFxuICAgICAgICBtOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGs6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgcCwgaywgbSwgaGFzaCwgZXhwYW5kLCBEU1Q6IF9EU1QgfSA9IG9wdGlvbnM7XG4gICAgaXNCeXRlcyhtc2cpO1xuICAgIGlzTnVtKGNvdW50KTtcbiAgICBjb25zdCBEU1QgPSB2YWxpZGF0ZURTVChfRFNUKTtcbiAgICBjb25zdCBsb2cycCA9IHAudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IEwgPSBNYXRoLmNlaWwoKGxvZzJwICsgaykgLyA4KTsgLy8gc2VjdGlvbiA1LjEgb2YgaWV0ZiBkcmFmdCBsaW5rIGFib3ZlXG4gICAgY29uc3QgbGVuX2luX2J5dGVzID0gY291bnQgKiBtICogTDtcbiAgICBsZXQgcHJiOyAvLyBwc2V1ZG9fcmFuZG9tX2J5dGVzXG4gICAgaWYgKGV4cGFuZCA9PT0gJ3htZCcpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICd4b2YnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuX2luX2J5dGVzLCBrLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAnX2ludGVybmFsX3Bhc3MnKSB7XG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCB0ZXN0cyBvbmx5XG4gICAgICAgIHByYiA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgY29uc3QgZWxtX29mZnNldCA9IEwgKiAoaiArIGkgKiBtKTtcbiAgICAgICAgICAgIGNvbnN0IHR2ID0gcHJiLnN1YmFycmF5KGVsbV9vZmZzZXQsIGVsbV9vZmZzZXQgKyBMKTtcbiAgICAgICAgICAgIGVbal0gPSBtb2Qob3MyaXAodHYpLCBwKTtcbiAgICAgICAgfVxuICAgICAgICB1W2ldID0gZTtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNvZ2VueU1hcChmaWVsZCwgbWFwKSB7XG4gICAgLy8gTWFrZSBzYW1lIG9yZGVyIGFzIGluIHNwZWNcbiAgICBjb25zdCBDT0VGRiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gKHgsIHkpID0+IHtcbiAgICAgICAgY29uc3QgW3hOdW0sIHhEZW4sIHlOdW0sIHlEZW5dID0gQ09FRkYubWFwKCh2YWwpID0+IHZhbC5yZWR1Y2UoKGFjYywgaSkgPT4gZmllbGQuYWRkKGZpZWxkLm11bChhY2MsIHgpLCBpKSkpO1xuICAgICAgICB4ID0gZmllbGQuZGl2KHhOdW0sIHhEZW4pOyAvLyB4TnVtIC8geERlblxuICAgICAgICB5ID0gZmllbGQubXVsKHksIGZpZWxkLmRpdih5TnVtLCB5RGVuKSk7IC8vIHkgKiAoeU51bSAvIHlEZXYpXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludCwgbWFwVG9DdXJ2ZSwgZGVmKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBUb0N1cnZlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmUoKSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBoYXNoX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZiwgRFNUOiBkZWYuRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVsxXSkpO1xuICAgICAgICAgICAgY29uc3QgUCA9IHUwLmFkZCh1MSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGVuY29kZV90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAxLCB7IC4uLmRlZiwgRFNUOiBkZWYuZW5jb2RlRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtdG8tY3VydmUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p)  1    if a is a square (mod p)\n    // (a | p)  -1   if a is not a square (mod p)\n    // (a | p)  0    if a  0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P  3 (mod 4)\n    // n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P  9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ3VJO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxxRUFBcUUsUUFBUSxNQUFNLE9BQU87QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQTJDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLG1DQUFtQztBQUNuQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTyw0QkFBNEIsSUFBSTtBQUMzRSx1QkFBdUIsMERBQWUsUUFBUSwwREFBZTtBQUM3RDtBQUNBO0FBQ0Esa0JBQWtCLDBEQUFlLHNCQUFzQiwwREFBZTtBQUN0RTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFibG9mZXJuYW5kZXovdGVzdDEyMy9URU5FWC1wZmttYzkvbWFpbi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBVdGlsaXRpZXMgZm9yIG1vZHVsYXIgYXJpdGhtZXRpY3MgYW5kIGZpbml0ZSBmaWVsZHNcbmltcG9ydCB7IGJpdE1hc2ssIG51bWJlclRvQnl0ZXNCRSwgbnVtYmVyVG9CeXRlc0xFLCBieXRlc1RvTnVtYmVyQkUsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIHZhbGlkYXRlT2JqZWN0LCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF80biA9IEJpZ0ludCg0KSwgXzVuID0gQmlnSW50KDUpLCBfOG4gPSBCaWdJbnQoOCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF85biA9IEJpZ0ludCg5KSwgXzE2biA9IEJpZ0ludCgxNik7XG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcbmV4cG9ydCBmdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogQGV4YW1wbGVcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG4gKi9cbi8vIFRPRE86IHVzZSBmaWVsZCB2ZXJzaW9uICYmIHJlbW92ZVxuZXhwb3J0IGZ1bmN0aW9uIHBvdyhudW0sIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBpZiAobW9kdWxvIDw9IF8wbiB8fCBwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlci9tb2R1bG8gPiAwJyk7XG4gICAgaWYgKG1vZHVsbyA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gXzBuO1xuICAgIGxldCByZXMgPSBfMW47XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHJlcyA9IChyZXMgKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBudW0gPSAobnVtICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIERvZXMgeCBeICgyIF4gcG93ZXIpIG1vZCBwLiBwb3cyKDMwLCA0KSA9PSAzMCBeICgyIF4gNClcbmV4cG9ydCBmdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gSW52ZXJzZXMgbnVtYmVyIG92ZXIgbW9kdWxvXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuIHx8IG1vZHVsbyA8PSBfMG4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJzLCBnb3Qgbj0ke251bWJlcn0gbW9kPSR7bW9kdWxvfWApO1xuICAgIH1cbiAgICAvLyBFdWNsaWRlYW4gR0NEIGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vXG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG4vKipcbiAqIFRvbmVsbGktU2hhbmtzIHNxdWFyZSByb290IHNlYXJjaCBhbGdvcml0aG0uXG4gKiAxLiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTIpXG4gKiAyLiBTcXVhcmUgUm9vdHMgZnJvbSAxOyAyNCwgNTEsIDEwIHRvIERhbiBTaGFua3NcbiAqIFdpbGwgc3RhcnQgYW4gaW5maW5pdGUgbG9vcCBpZiBmaWVsZCBvcmRlciBQIGlzIG5vdCBwcmltZS5cbiAqIEBwYXJhbSBQIGZpZWxkIG9yZGVyXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHRha2VzIGZpZWxkIEZwIChjcmVhdGVkIGZyb20gUCkgYW5kIG51bWJlciBuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b25lbGxpU2hhbmtzKFApIHtcbiAgICAvLyBMZWdlbmRyZSBjb25zdGFudDogdXNlZCB0byBjYWxjdWxhdGUgTGVnZW5kcmUgc3ltYm9sIChhIHwgcCksXG4gICAgLy8gd2hpY2ggZGVub3RlcyB0aGUgdmFsdWUgb2YgYV4oKHAtMSkvMikgKG1vZCBwKS5cbiAgICAvLyAoYSB8IHApIOKJoSAxICAgIGlmIGEgaXMgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gICAgY29uc3QgbGVnZW5kcmVDID0gKFAgLSBfMW4pIC8gXzJuO1xuICAgIGxldCBRLCBTLCBaO1xuICAgIC8vIFN0ZXAgMTogQnkgZmFjdG9yaW5nIG91dCBwb3dlcnMgb2YgMiBmcm9tIHAgLSAxLFxuICAgIC8vIGZpbmQgcSBhbmQgcyBzdWNoIHRoYXQgcCAtIDEgPSBxKigyXnMpIHdpdGggcSBvZGRcbiAgICBmb3IgKFEgPSBQIC0gXzFuLCBTID0gMDsgUSAlIF8ybiA9PT0gXzBuOyBRIC89IF8ybiwgUysrKVxuICAgICAgICA7XG4gICAgLy8gU3RlcCAyOiBTZWxlY3QgYSBub24tc3F1YXJlIHogc3VjaCB0aGF0ICh6IHwgcCkg4omhIC0xIGFuZCBzZXQgYyDiiaEgenFcbiAgICBmb3IgKFogPSBfMm47IFogPCBQICYmIHBvdyhaLCBsZWdlbmRyZUMsIFApICE9PSBQIC0gXzFuOyBaKyspXG4gICAgICAgIDtcbiAgICAvLyBGYXN0LXBhdGhcbiAgICBpZiAoUyA9PT0gMSkge1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpRmFzdChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gU2xvdy1wYXRoXG4gICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpU2xvdyhGcCwgbikge1xuICAgICAgICAvLyBTdGVwIDA6IENoZWNrIHRoYXQgbiBpcyBpbmRlZWQgYSBzcXVhcmU6IChuIHwgcCkgc2hvdWxkIG5vdCBiZSDiiaEgLTFcbiAgICAgICAgaWYgKEZwLnBvdyhuLCBsZWdlbmRyZUMpID09PSBGcC5uZWcoRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgbGV0IHIgPSBTO1xuICAgICAgICAvLyBUT0RPOiB3aWxsIGZhaWwgYXQgRnAyL2V0Y1xuICAgICAgICBsZXQgZyA9IEZwLnBvdyhGcC5tdWwoRnAuT05FLCBaKSwgUSk7IC8vIHdpbGwgdXBkYXRlIGJvdGggeCBhbmQgYlxuICAgICAgICBsZXQgeCA9IEZwLnBvdyhuLCBRMWRpdjIpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgc3F1YXJlIHJvb3RcbiAgICAgICAgbGV0IGIgPSBGcC5wb3cobiwgUSk7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3JcbiAgICAgICAgd2hpbGUgKCFGcC5lcWwoYiwgRnAuT05FKSkge1xuICAgICAgICAgICAgaWYgKEZwLmVxbChiLCBGcC5aRVJPKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnAuWkVSTzsgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9uZWxsaSVFMiU4MCU5M1NoYW5rc19hbGdvcml0aG0gKDQuIElmIHQgPSAwLCByZXR1cm4gciA9IDApXG4gICAgICAgICAgICAvLyBGaW5kIG0gc3VjaCBiXigyXm0pPT0xXG4gICAgICAgICAgICBsZXQgbSA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCB0MiA9IEZwLnNxcihiKTsgbSA8IHI7IG0rKykge1xuICAgICAgICAgICAgICAgIGlmIChGcC5lcWwodDIsIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHQyID0gRnAuc3FyKHQyKTsgLy8gdDIgKj0gdDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEU6IHItbS0xIGNhbiBiZSBiaWdnZXIgdGhhbiAzMiwgbmVlZCB0byBjb252ZXJ0IHRvIGJpZ2ludCBiZWZvcmUgc2hpZnQsIG90aGVyd2lzZSB0aGVyZSB3aWxsIGJlIG92ZXJmbG93XG4gICAgICAgICAgICBjb25zdCBnZSA9IEZwLnBvdyhnLCBfMW4gPDwgQmlnSW50KHIgLSBtIC0gMSkpOyAvLyBnZSA9IDJeKHItbS0xKVxuICAgICAgICAgICAgZyA9IEZwLnNxcihnZSk7IC8vIGcgPSBnZSAqIGdlXG4gICAgICAgICAgICB4ID0gRnAubXVsKHgsIGdlKTsgLy8geCAqPSBnZVxuICAgICAgICAgICAgYiA9IEZwLm11bChiLCBnKTsgLy8gYiAqPSBnXG4gICAgICAgICAgICByID0gbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgLy8gTk9URTogZGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuICAgIC8vIEZvciBleGFtcGxlIHRoZXJlIGlzIEZwU3FydE9kZC9GcFNxcnRFdmVuIHRvIGNob2ljZSByb290IGJhc2VkIG9uIG9kZG5lc3MgKHVzZWQgZm9yIGhhc2gtdG8tY3VydmUpLlxuICAgIC8vIFAg4omhIDMgKG1vZCA0KVxuICAgIC8vIOKImm4gPSBuXigoUCsxKS80KVxuICAgIGlmIChQICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gTm90IGFsbCByb290cyBwb3NzaWJsZSFcbiAgICAgICAgLy8gY29uc3QgT1JERVIgPVxuICAgICAgICAvLyAgIDB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFibjtcbiAgICAgICAgLy8gY29uc3QgTlVNID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0M21vZDQoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIC8vIFRocm93IGlmIHJvb3QqKjIgIT0gblxuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQXRraW4gYWxnb3JpdGhtIGZvciBxIOKJoSA1IChtb2QgOCksIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMClcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKSB7XG4gICAgICAgIGNvbnN0IGMxID0gKFAgLSBfNW4pIC8gXzhuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xuICAgICAgICAgICAgY29uc3QgdiA9IEZwLnBvdyhuMiwgYzEpO1xuICAgICAgICAgICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gICAgICAgICAgICBjb25zdCBpID0gRnAubXVsKEZwLm11bChudiwgXzJuKSwgdik7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQIOKJoSA5IChtb2QgMTYpXG4gICAgaWYgKFAgJSBfMTZuID09PSBfOW4pIHtcbiAgICAgICAgLy8gTk9URTogdG9uZWxsaSBpcyB0b28gc2xvdyBmb3IgYmxzLUZwMiBjYWxjdWxhdGlvbnMgZXZlbiBvbiBzdGFydFxuICAgICAgICAvLyBNZWFucyB3ZSBjYW5ub3QgdXNlIHNxcnQgZm9yIGNvbnN0YW50cyBhdCBhbGwhXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGNvbnN0IGMxID0gRnAuc3FydChGcC5uZWdhdGUoRnAuT05FKSk7IC8vICAxLiBjMSA9IHNxcnQoLTEpIGluIEYsIGkuZS4sIChjMV4yKSA9PSAtMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMyID0gRnAuc3FydChjMSk7ICAgICAgICAgICAgICAgIC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMzID0gRnAuc3FydChGcC5uZWdhdGUoYzEpKTsgICAgIC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzQgPSAoUCArIF83bikgLyBfMTZuOyAgICAgICAgICAgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICAvLyBzcXJ0ID0gKHgpID0+IHtcbiAgICAgICAgLy8gICBsZXQgdHYxID0gRnAucG93KHgsIGM0KTsgICAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcbiAgICAgICAgLy8gICBsZXQgdHYyID0gRnAubXVsKGMxLCB0djEpOyAgICAgICAgICAgLy8gIDIuIHR2MiA9IGMxICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgdHYzID0gRnAubXVsKGMyLCB0djEpOyAgICAgICAgIC8vICAzLiB0djMgPSBjMiAqIHR2MVxuICAgICAgICAvLyAgIGxldCB0djQgPSBGcC5tdWwoYzMsIHR2MSk7ICAgICAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCBlMSA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMiA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYzKSwgeCk7IC8vICA2LiAgZTIgPSAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7IC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMyA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA5LiAgZTMgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICByZXR1cm4gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAgMTAuICB6ID0gQ01PVih0djEsIHR2MiwgZTMpICAjIFNlbGVjdCB0aGUgc3FydCBmcm9tIHR2MSBhbmQgdHYyXG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgLy8gT3RoZXIgY2FzZXM6IFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICAgIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xufVxuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bSwgbW9kdWxvKSA9PiAobW9kKG51bSwgbW9kdWxvKSAmIF8xbikgPT09IF8xbjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRklFTERfRklFTERTID0gW1xuICAgICdjcmVhdGUnLCAnaXNWYWxpZCcsICdpczAnLCAnbmVnJywgJ2ludicsICdzcXJ0JywgJ3NxcicsXG4gICAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcbl07XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICAgIE9SREVSOiAnYmlnaW50JyxcbiAgICAgICAgTUFTSzogJ2JpZ2ludCcsXG4gICAgICAgIEJZVEVTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIEJJVFM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KGZpZWxkLCBvcHRzKTtcbn1cbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG4vKipcbiAqIFNhbWUgYXMgYHBvd2AgYnV0IGZvciBGcDogbm9uLWNvbnN0YW50LXRpbWUuXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFBvdyhmLCBudW0sIHBvd2VyKSB7XG4gICAgLy8gU2hvdWxkIGhhdmUgc2FtZSBzcGVlZCBhcyBwb3cgZm9yIGJpZ2ludHNcbiAgICAvLyBUT0RPOiBiZW5jaG1hcmshXG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyID4gMCcpO1xuICAgIGlmIChwb3dlciA9PT0gXzBuKVxuICAgICAgICByZXR1cm4gZi5PTkU7XG4gICAgaWYgKHBvd2VyID09PSBfMW4pXG4gICAgICAgIHJldHVybiBudW07XG4gICAgbGV0IHAgPSBmLk9ORTtcbiAgICBsZXQgZCA9IG51bTtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcCA9IGYubXVsKHAsIGQpO1xuICAgICAgICBkID0gZi5zcXIoZCk7XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSBpbnZlcnQgYW4gYXJyYXkgb2YgRmllbGQgZWxlbWVudHMuXG4gKiBgaW52KDApYCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBoZXJlOiBtYWtlIHN1cmUgdG8gdGhyb3cgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcEludmVydEJhdGNoKGYsIG51bXMpIHtcbiAgICBjb25zdCB0bXAgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBmLk9ORSk7XG4gICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxuICAgIGNvbnN0IGludmVydGVkID0gZi5pbnYobGFzdE11bHRpcGxpZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHRtcDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcERpdihmLCBsaHMsIHJocykge1xuICAgIHJldHVybiBmLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gaW52ZXJ0KHJocywgZi5PUkRFUikgOiBmLmludihyaHMpKTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZXhwb3J0IGZ1bmN0aW9uIEZwSXNTcXVhcmUoZikge1xuICAgIGNvbnN0IGxlZ2VuZHJlQ29uc3QgPSAoZi5PUkRFUiAtIF8xbikgLyBfMm47IC8vIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIHJldHVybiAoeCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gZi5wb3coeCwgbGVnZW5kcmVDb25zdCk7XG4gICAgICAgIHJldHVybiBmLmVxbChwLCBmLlpFUk8pIHx8IGYuZXFsKHAsIGYuT05FKTtcbiAgICB9O1xufVxuLy8gQ1VSVkUubiBsZW5ndGhzXG5leHBvcnQgZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XG4gICAgLy8gQml0IHNpemUsIGJ5dGUgc2l6ZSBvZiBDVVJWRS5uXG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBmaW5pdGUgZmllbGQgb3ZlciBwcmltZS4gKipOb24tcHJpbWVzIGFyZSBub3Qgc3VwcG9ydGVkLioqXG4gKiBEbyBub3QgaW5pdCBpbiBsb29wOiBzbG93LiBWZXJ5IGZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBNYWpvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zOlxuICogKiBhKSBkZW5vcm1hbGl6ZWQgb3BlcmF0aW9ucyBsaWtlIG11bE4gaW5zdGVhZCBvZiBtdWxcbiAqICogYikgc2FtZSBvYmplY3Qgc2hhcGU6IG5ldmVyIGFkZCBvciByZW1vdmUga2V5c1xuICogKiBjKSBPYmplY3QuZnJlZXplXG4gKiBAcGFyYW0gT1JERVIgcHJpbWUgcG9zaXRpdmUgYmlnaW50XG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmOiBmYWxzZSkgaWYgZW5jb2RpbmcgLyBkZWNvZGluZyBzaG91bGQgYmUgaW4gbGl0dGxlLWVuZGlhblxuICogQHBhcmFtIHJlZGVmIG9wdGlvbmFsIGZhc3RlciByZWRlZmluaXRpb25zIG9mIHNxcnQgYW5kIG90aGVyIG1ldGhvZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZpZWxkKE9SREVSLCBiaXRMZW4sIGlzTEUgPSBmYWxzZSwgcmVkZWYgPSB7fSkge1xuICAgIGlmIChPUkRFUiA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgRmllbGQgT1JERVIgPiAwLCBnb3QgJHtPUkRFUn1gKTtcbiAgICBjb25zdCB7IG5CaXRMZW5ndGg6IEJJVFMsIG5CeXRlTGVuZ3RoOiBCWVRFUyB9ID0gbkxlbmd0aChPUkRFUiwgYml0TGVuKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkIGxlbmd0aHMgb3ZlciAyMDQ4IGJ5dGVzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgY29uc3Qgc3FydFAgPSBGcFNxcnQoT1JERVIpO1xuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiBiaXRNYXNrKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAke3R5cGVvZiBudW19YCk7XG4gICAgICAgICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICAgICAgICB9LFxuICAgICAgICBpczA6IChudW0pID0+IG51bSA9PT0gXzBuLFxuICAgICAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcbiAgICAgICAgbmVnOiAobnVtKSA9PiBtb2QoLW51bSwgT1JERVIpLFxuICAgICAgICBlcWw6IChsaHMsIHJocykgPT4gbGhzID09PSByaHMsXG4gICAgICAgIHNxcjogKG51bSkgPT4gbW9kKG51bSAqIG51bSwgT1JERVIpLFxuICAgICAgICBhZGQ6IChsaHMsIHJocykgPT4gbW9kKGxocyArIHJocywgT1JERVIpLFxuICAgICAgICBzdWI6IChsaHMsIHJocykgPT4gbW9kKGxocyAtIHJocywgT1JERVIpLFxuICAgICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0sIHBvd2VyKSxcbiAgICAgICAgZGl2OiAobGhzLCByaHMpID0+IG1vZChsaHMgKiBpbnZlcnQocmhzLCBPUkRFUiksIE9SREVSKSxcbiAgICAgICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXG4gICAgICAgIHNxck46IChudW0pID0+IG51bSAqIG51bSxcbiAgICAgICAgYWRkTjogKGxocywgcmhzKSA9PiBsaHMgKyByaHMsXG4gICAgICAgIHN1Yk46IChsaHMsIHJocykgPT4gbGhzIC0gcmhzLFxuICAgICAgICBtdWxOOiAobGhzLCByaHMpID0+IGxocyAqIHJocyxcbiAgICAgICAgaW52OiAobnVtKSA9PiBpbnZlcnQobnVtLCBPUkRFUiksXG4gICAgICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHwgKChuKSA9PiBzcXJ0UChmLCBuKSksXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFRPRE86IGRvIHdlIHJlYWxseSBuZWVkIGNvbnN0YW50IGNtb3Y/XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgY29uc3QtdGltZSBiaWdpbnRzIGFueXdheSwgc28gcHJvYmFibHkgd2lsbCBiZSBub3QgdmVyeSB1c2VmdWxcbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/IG51bWJlclRvQnl0ZXNMRShudW0sIEJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0sIEJZVEVTKSksXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBCWVRFUylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZwLmZyb21CeXRlczogZXhwZWN0ZWQgJHtCWVRFU30sIGdvdCAke2J5dGVzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHJldHVybiBpc0xFID8gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSA6IGJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRFdmVuKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogU2FtZSBhcyBtYXBLZXlUb0ZpZWxkLCBidXQgYWNjZXB0cyBsZXNzIGJ5dGVzICg0MCBpbnN0ZWFkIG9mIDQ4IGZvciAzMi1ieXRlIGZpZWxkKS5cbiAqIFdoaWNoIG1ha2VzIGl0IHNsaWdodGx5IG1vcmUgYmlhc2VkLCBsZXNzIHNlY3VyZS5cbiAqIEBkZXByZWNhdGVkIHVzZSBtYXBLZXlUb0ZpZWxkIGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hUb1ByaXZhdGVTY2FsYXIoaGFzaCwgZ3JvdXBPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgaGFzaCA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlSGFzaCcsIGhhc2gpO1xuICAgIGNvbnN0IGhhc2hMZW4gPSBoYXNoLmxlbmd0aDtcbiAgICBjb25zdCBtaW5MZW4gPSBuTGVuZ3RoKGdyb3VwT3JkZXIpLm5CeXRlTGVuZ3RoICsgODtcbiAgICBpZiAobWluTGVuIDwgMjQgfHwgaGFzaExlbiA8IG1pbkxlbiB8fCBoYXNoTGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBoYXNoVG9Qcml2YXRlU2NhbGFyOiBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7aGFzaExlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckxFKGhhc2gpIDogYnl0ZXNUb051bWJlckJFKGhhc2gpO1xuICAgIHJldHVybiBtb2QobnVtLCBncm91cE9yZGVyIC0gXzFuKSArIF8xbjtcbn1cbi8qKlxuICogUmV0dXJucyB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgY29uc3VtZWQgYnkgdGhlIGZpZWxkIGVsZW1lbnQuXG4gKiBGb3IgZXhhbXBsZSwgMzIgYnl0ZXMgZm9yIHVzdWFsIDI1Ni1iaXQgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgZmllbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGlmICh0eXBlb2YgZmllbGRPcmRlciAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnQnKTtcbiAgICBjb25zdCBiaXRMZW5ndGggPSBmaWVsZE9yZGVyLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGJpdExlbmd0aCAvIDgpO1xufVxuLyoqXG4gKiBSZXR1cm5zIG1pbmltYWwgYW1vdW50IG9mIGJ5dGVzIHRoYXQgY2FuIGJlIHNhZmVseSByZWR1Y2VkXG4gKiBieSBmaWVsZCBvcmRlci5cbiAqIFNob3VsZCBiZSAyXi0xMjggZm9yIDEyOC1iaXQgY3VydmUgc3VjaCBhcyBQMjU2LlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIHRhcmdldCBoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIHJldHVybiBsZW5ndGggKyBNYXRoLmNlaWwobGVuZ3RoIC8gMik7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIENhbiB0YWtlIChuICsgbi8yKSBvciBtb3JlIGJ5dGVzIG9mIHVuaWZvcm0gaW5wdXQgZS5nLiBmcm9tIENTUFJORyBvciBLREZcbiAqIGFuZCBjb252ZXJ0IHRoZW0gaW50byBwcml2YXRlIHNjYWxhciwgd2l0aCB0aGUgbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAqIE5lZWRzIGF0IGxlYXN0IDQ4IGJ5dGVzIG9mIGlucHV0IGZvciAzMi1ieXRlIHByaXZhdGUga2V5LlxuICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXG4gKiBGSVBTIDE4Ni01LCBBLjIgaHR0cHM6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9kZXRhaWwvZmlwcy8xODYvNS9maW5hbFxuICogUkZDIDkzODAsIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNVxuICogQHBhcmFtIGhhc2ggaGFzaCBvdXRwdXQgZnJvbSBTSEEzIG9yIGEgc2ltaWxhciBmdW5jdGlvblxuICogQHBhcmFtIGdyb3VwT3JkZXIgc2l6ZSBvZiBzdWJncm91cCAtIChlLmcuIHNlY3AyNTZrMS5DVVJWRS5uKVxuICogQHBhcmFtIGlzTEUgaW50ZXJwcmV0IGhhc2ggYnl0ZXMgYXMgTEUgbnVtXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwSGFzaFRvRmllbGQoa2V5LCBmaWVsZE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIGNvbnN0IGZpZWxkTGVuID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICBjb25zdCBtaW5MZW4gPSBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIC8vIE5vIHNtYWxsIG51bWJlcnM6IG5lZWQgdG8gdW5kZXJzdGFuZCBiaWFzIHN0b3J5LiBObyBodWdlIG51bWJlcnM6IGVhc2llciB0byBkZXRlY3QgSlMgdGltaW5ncy5cbiAgICBpZiAobGVuIDwgMTYgfHwgbGVuIDwgbWluTGVuIHx8IGxlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2xlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckJFKGtleSkgOiBieXRlc1RvTnVtYmVyTEUoa2V5KTtcbiAgICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4gICAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICAgIHJldHVybiBpc0xFID8gbnVtYmVyVG9CeXRlc0xFKHJlZHVjZWQsIGZpZWxkTGVuKSA6IG51bWJlclRvQnl0ZXNCRShyZWR1Y2VkLCBmaWVsZExlbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGFyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a) => a instanceof Uint8Array;\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length)\n        return false;\n    for (let i = 0; i < b1.length; i++)\n        if (b1[i] !== b2[i])\n            return false;\n    return true;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nconst bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || val instanceof Uint8Array,\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8saUNBQWlDLElBQUksWUFBWSxFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxXQUFXLGdCQUFnQixhQUFhLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw0REFBNEQsV0FBVztBQUN2RSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNPO0FBQ1A7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUNuRCw4REFBOEQ7QUFDckU7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUs7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCLEdBQUcsS0FBSyxHQUFHLFdBQVcsY0FBYyxLQUFLO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVyxXQUFXLFlBQVksSUFBSTtBQUNwRCxrQ0FBa0Msb0JBQW9CLElBQUksYUFBYSxHQUFHO0FBQzFFO0FBQ0Esa0NBQWtDLFVBQVUsSUFBSSxTQUFTO0FBQ3pELGtDQUFrQyxvQkFBb0IsSUFBSSxTQUFTO0FBQ25FLGtDQUFrQywyQkFBMkI7QUFDN0Qsa0NBQWtDLHdCQUF3QjtBQUMxRCIsInNvdXJjZXMiOlsiL1VzZXJzL3BhYmxvZmVybmFuZGV6L3Rlc3QxMjMvVEVORVgtcGZrbWM5L21haW4vbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay1jYWNoZS1kZXhpZS9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIDEwMCBsaW5lcyBvZiBjb2RlIGluIHRoZSBmaWxlIGFyZSBkdXBsaWNhdGVkIGZyb20gbm9ibGUtaGFzaGVzICh1dGlscykuXG4vLyBUaGlzIGlzIE9LOiBgYWJzdHJhY3RgIGRpcmVjdG9yeSBkb2VzIG5vdCB1c2Ugbm9ibGUtaGFzaGVzLlxuLy8gVXNlciBtYXkgb3B0LWluIGludG8gdXNpbmcgZGlmZmVyZW50IGhhc2hpbmcgbGlicmFyeS4gVGhpcyB3YXksIG5vYmxlLWhhc2hlc1xuLy8gd29uJ3QgYmUgaW5jbHVkZWQgaW50byB0aGVpciBidW5kbGUuXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvSGV4VW5wYWRkZWQobnVtKSB7XG4gICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQmlnIEVuZGlhblxuICAgIHJldHVybiBCaWdJbnQoaGV4ID09PSAnJyA/ICcwJyA6IGAweCR7aGV4fWApO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGxlbiA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGxlbiAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBsZW4pO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KGxlbiAqIDIsICcwJykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNMRShuLCBsZW4pIHtcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikucmV2ZXJzZSgpO1xufVxuLy8gVW5wYWRkZWQsIHJhcmVseSB1c2VkXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9WYXJCeXRlc0JFKG4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbn1cbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAncHJpdmF0ZSBrZXknXG4gKiBAcGFyYW0gaGV4IGhleCBzdHJpbmcgb3IgVWludDhBcnJheVxuICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIG9wdGlvbmFsLCB3aWxsIGNvbXBhcmUgdG8gcmVzdWx0IGFycmF5J3MgbGVuZ3RoXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlQnl0ZXModGl0bGUsIGhleCwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gaGV4VG9CeXRlcyhoZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgdmFsaWQgaGV4IHN0cmluZywgZ290IFwiJHtoZXh9XCIuIENhdXNlOiAke2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodThhKGhleCkpIHtcbiAgICAgICAgLy8gVWludDhBcnJheS5mcm9tKCkgaW5zdGVhZCBvZiBoYXNoLnNsaWNlKCkgYmVjYXVzZSBub2RlLmpzIEJ1ZmZlclxuICAgICAgICAvLyBpcyBpbnN0YW5jZSBvZiBVaW50OEFycmF5LCBhbmQgaXRzIHNsaWNlKCkgY3JlYXRlcyAqKm11dGFibGUqKiBjb3B5XG4gICAgICAgIHJlcyA9IFVpbnQ4QXJyYXkuZnJvbShoZXgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheWApO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSByZXMubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRMZW5ndGggPT09ICdudW1iZXInICYmIGxlbiAhPT0gZXhwZWN0ZWRMZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gZXhwZWN0ZWQgJHtleHBlY3RlZExlbmd0aH0gYnl0ZXMsIGdvdCAke2xlbn1gKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG5leHBvcnQgZnVuY3Rpb24gZXF1YWxCeXRlcyhiMSwgYjIpIHtcbiAgICAvLyBXZSBkb24ndCBjYXJlIGFib3V0IHRpbWluZyBhdHRhY2tzIGhlcmVcbiAgICBpZiAoYjEubGVuZ3RoICE9PSBiMi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIxLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYjFbaV0gIT09IGIyW2ldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vLyBCaXQgb3BlcmF0aW9uc1xuLyoqXG4gKiBDYWxjdWxhdGVzIGFtb3VudCBvZiBiaXRzIGluIGEgYmlnaW50LlxuICogU2FtZSBhcyBgbi50b1N0cmluZygyKS5sZW5ndGhgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRMZW4obikge1xuICAgIGxldCBsZW47XG4gICAgZm9yIChsZW4gPSAwOyBuID4gXzBuOyBuID4+PSBfMW4sIGxlbiArPSAxKVxuICAgICAgICA7XG4gICAgcmV0dXJuIGxlbjtcbn1cbi8qKlxuICogR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICogTk9URTogZmlyc3QgYml0IHBvc2l0aW9uIGlzIDAgKHNhbWUgYXMgYXJyYXlzKVxuICogU2FtZSBhcyBgISErQXJyYXkuZnJvbShuLnRvU3RyaW5nKDIpKS5yZXZlcnNlKClbcG9zXWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdEdldChuLCBwb3MpIHtcbiAgICByZXR1cm4gKG4gPj4gQmlnSW50KHBvcykpICYgXzFuO1xufVxuLyoqXG4gKiBTZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBiaXRTZXQgPSAobiwgcG9zLCB2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBuIHwgKCh2YWx1ZSA/IF8xbiA6IF8wbikgPDwgQmlnSW50KHBvcykpO1xufTtcbi8qKlxuICogQ2FsY3VsYXRlIG1hc2sgZm9yIE4gYml0cy4gTm90IHVzaW5nICoqIG9wZXJhdG9yIHdpdGggYmlnaW50cyBiZWNhdXNlIG9mIG9sZCBlbmdpbmVzLlxuICogU2FtZSBhcyBCaWdJbnQoYDBiJHtBcnJheShpKS5maWxsKCcxJykuam9pbignJyl9YClcbiAqL1xuZXhwb3J0IGNvbnN0IGJpdE1hc2sgPSAobikgPT4gKF8ybiA8PCBCaWdJbnQobiAtIDEpKSAtIF8xbjtcbi8vIERSQkdcbmNvbnN0IHU4biA9IChkYXRhKSA9PiBuZXcgVWludDhBcnJheShkYXRhKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG5jb25zdCB1OGZyID0gKGFycikgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSG1hY0RyYmcoaGFzaExlbiwgcUJ5dGVMZW4sIGhtYWNGbikge1xuICAgIGlmICh0eXBlb2YgaGFzaExlbiAhPT0gJ251bWJlcicgfHwgaGFzaExlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBxQnl0ZUxlbiAhPT0gJ251bWJlcicgfHwgcUJ5dGVMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3FCeXRlTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIGhtYWNGbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgLy8gU3RlcCBCLCBTdGVwIEM6IHNldCBoYXNoTGVuIHRvIDgqY2VpbChobGVuLzgpXG4gICAgbGV0IHYgPSB1OG4oaGFzaExlbik7IC8vIE1pbmltYWwgbm9uLWZ1bGwtc3BlYyBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICAgIGxldCBrID0gdThuKGhhc2hMZW4pOyAvLyBTdGVwcyBCIGFuZCBDIG9mIFJGQzY5NzkgMy4yOiBzZXQgaGFzaExlbiwgaW4gb3VyIGNhc2UgYWx3YXlzIHNhbWVcbiAgICBsZXQgaSA9IDA7IC8vIEl0ZXJhdGlvbnMgY291bnRlciwgd2lsbCB0aHJvdyB3aGVuIG92ZXIgMTAwMFxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICB2LmZpbGwoMSk7XG4gICAgICAgIGsuZmlsbCgwKTtcbiAgICAgICAgaSA9IDA7XG4gICAgfTtcbiAgICBjb25zdCBoID0gKC4uLmIpID0+IGhtYWNGbihrLCB2LCAuLi5iKTsgLy8gaG1hYyhrKSh2LCAuLi52YWx1ZXMpXG4gICAgY29uc3QgcmVzZWVkID0gKHNlZWQgPSB1OG4oKSkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgcmVzZWVkKCkgZnVuY3Rpb24uIFN0ZXBzIEQtR1xuICAgICAgICBrID0gaCh1OGZyKFsweDAwXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMCB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgayA9IGgodThmcihbMHgwMV0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDEgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgIH07XG4gICAgY29uc3QgZ2VuID0gKCkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgZ2VuZXJhdGUoKSBmdW5jdGlvblxuICAgICAgICBpZiAoaSsrID49IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RyYmc6IHRyaWVkIDEwMDAgdmFsdWVzJyk7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbiA8IHFCeXRlTGVuKSB7XG4gICAgICAgICAgICB2ID0gaCgpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB2LnNsaWNlKCk7XG4gICAgICAgICAgICBvdXQucHVzaChzbCk7XG4gICAgICAgICAgICBsZW4gKz0gdi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKC4uLm91dCk7XG4gICAgfTtcbiAgICBjb25zdCBnZW5VbnRpbCA9IChzZWVkLCBwcmVkKSA9PiB7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJlc2VlZChzZWVkKTsgLy8gU3RlcHMgRC1HXG4gICAgICAgIGxldCByZXMgPSB1bmRlZmluZWQ7IC8vIFN0ZXAgSDogZ3JpbmQgdW50aWwgayBpcyBpbiBbMS4ubi0xXVxuICAgICAgICB3aGlsZSAoIShyZXMgPSBwcmVkKGdlbigpKSkpXG4gICAgICAgICAgICByZXNlZWQoKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIHJldHVybiBnZW5VbnRpbDtcbn1cbi8vIFZhbGlkYXRpbmcgY3VydmVzIGFuZCBmaWVsZHNcbmNvbnN0IHZhbGlkYXRvckZucyA9IHtcbiAgICBiaWdpbnQ6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnLFxuICAgIGZ1bmN0aW9uOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuICAgIGJvb2xlYW46ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJyxcbiAgICBzdHJpbmc6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnLFxuICAgIHN0cmluZ09yVWludDhBcnJheTogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgVWludDhBcnJheSxcbiAgICBpc1NhZmVJbnRlZ2VyOiAodmFsKSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwpLFxuICAgIGFycmF5OiAodmFsKSA9PiBBcnJheS5pc0FycmF5KHZhbCksXG4gICAgZmllbGQ6ICh2YWwsIG9iamVjdCkgPT4gb2JqZWN0LkZwLmlzVmFsaWQodmFsKSxcbiAgICBoYXNoOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbC5vdXRwdXRMZW4pLFxufTtcbi8vIHR5cGUgUmVjb3JkPEsgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wsIFQ+ID0geyBbUCBpbiBLXTogVDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWUsIHR5cGUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tWYWwgPSB2YWxpZGF0b3JGbnNbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsaWRhdG9yIFwiJHt0eXBlfVwiLCBleHBlY3RlZCBmdW5jdGlvbmApO1xuICAgICAgICBjb25zdCB2YWwgPSBvYmplY3RbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghY2hlY2tWYWwodmFsLCBvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyYW0gJHtTdHJpbmcoZmllbGROYW1lKX09JHt2YWx9ICgke3R5cGVvZiB2YWx9KSwgZXhwZWN0ZWQgJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgZmFsc2UpO1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0VmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufVxuLy8gdmFsaWRhdGUgdHlwZSB0ZXN0c1xuLy8gY29uc3QgbzogeyBhOiBudW1iZXI7IGI6IG51bWJlcjsgYzogbnVtYmVyIH0gPSB7IGE6IDEsIGI6IDUsIGM6IDYgfTtcbi8vIGNvbnN0IHowID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnYmlnaW50JyB9KTsgLy8gT2shXG4vLyAvLyBTaG91bGQgZmFpbCB0eXBlLWNoZWNrXG4vLyBjb25zdCB6MSA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ3RtcCcgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejIgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MyA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgdGVzdDogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIGNvbnN0IHo0ID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y = x + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y = x + ax + b: Short weierstrass curve formula\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (key instanceof Uint8Array)\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y\n            const right = weierstrassEquation(x); // x + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z)  (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y = x + ax + b\n                let y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ29DO0FBQ0g7QUFDUTtBQUNRO0FBQ2pEO0FBQ0EsaUJBQWlCLHdEQUFhO0FBQzlCLElBQUkscURBQWlCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBLFFBQVEsd0NBQXdDLEVBQUUsc0NBQUU7QUFDN0M7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQ0FBMEM7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUIsSUFBSSxHQUFHLEVBQUUsRUFBRSxJQUFJLEdBQUcsRUFBRSxFQUFFO0FBQzNELEtBQUs7QUFDTDtBQUNB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QSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhYmxvZmVybmFuZGV6L3Rlc3QxMjMvVEVORVgtcGZrbWM5L21haW4vbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay1jYWNoZS1kZXhpZS9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFNob3J0IFdlaWVyc3RyYXNzIGN1cnZlLiBUaGUgZm9ybXVsYSBpczogecKyID0geMKzICsgYXggKyBiXG5pbXBvcnQgKiBhcyBtb2QgZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCAqIGFzIHV0IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgZW5zdXJlQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IHdOQUYsIHZhbGlkYXRlQmFzaWMgfSBmcm9tICcuL2N1cnZlLmpzJztcbmZ1bmN0aW9uIHZhbGlkYXRlUG9pbnRPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgYTogJ2ZpZWxkJyxcbiAgICAgICAgYjogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogJ2FycmF5JyxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6ICdib29sZWFuJyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiAnYm9vbGVhbicsXG4gICAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdG9CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xuICAgIGlmIChlbmRvKSB7XG4gICAgICAgIGlmICghRnAuZXFsKGEsIEZwLlpFUk8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuZG9tb3JwaGlzbSBjYW4gb25seSBiZSBkZWZpbmVkIGZvciBLb2JsaXR6IGN1cnZlcyB0aGF0IGhhdmUgYT0wJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRvICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGVuZG9tb3JwaGlzbSB3aXRoIGJldGE6IGJpZ2ludCBhbmQgc3BsaXRTY2FsYXI6IGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzIH0pO1xufVxuLy8gQVNOLjEgREVSIGVuY29kaW5nIHV0aWxpdGllc1xuY29uc3QgeyBieXRlc1RvTnVtYmVyQkU6IGIybiwgaGV4VG9CeXRlczogaDJiIH0gPSB1dDtcbmV4cG9ydCBjb25zdCBERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBjbGFzcyBERVJFcnIgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICAgICAgc3VwZXIobSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9wYXJzZUludChkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPT0gMHgwMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyIHRhZycpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhWzFdO1xuICAgICAgICBjb25zdCByZXMgPSBkYXRhLnN1YmFycmF5KDIsIGxlbiArIDIpO1xuICAgICAgICBpZiAoIWxlbiB8fCByZXMubGVuZ3RoICE9PSBsZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogd3JvbmcgbGVuZ3RoJyk7XG4gICAgICAgIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxuICAgICAgICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAgICAgICAvLyAtIGFkZCB6ZXJvIGJ5dGUgaWYgZXhpc3RzXG4gICAgICAgIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcbiAgICAgICAgaWYgKHJlc1swXSAmIDBiMTAwMDAwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogbmVnYXRpdmUnKTtcbiAgICAgICAgaWYgKHJlc1swXSA9PT0gMHgwMCAmJiAhKHJlc1sxXSAmIDBiMTAwMDAwMDApKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHVubmVjZXNzYXJ5IGxlYWRpbmcgemVybycpO1xuICAgICAgICByZXR1cm4geyBkOiBiMm4ocmVzKSwgbDogZGF0YS5zdWJhcnJheShsZW4gKyAyKSB9OyAvLyBkIGlzIGRhdGEsIGwgaXMgbGVmdFxuICAgIH0sXG4gICAgdG9TaWcoaGV4KSB7XG4gICAgICAgIC8vIHBhcnNlIERFUiBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBoZXggPT09ICdzdHJpbmcnID8gaDJiKGhleCkgOiBoZXg7XG4gICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndWk4YSBleHBlY3RlZCcpO1xuICAgICAgICBsZXQgbCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAobCA8IDIgfHwgZGF0YVswXSAhPSAweDMwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIHRhZycpO1xuICAgICAgICBpZiAoZGF0YVsxXSAhPT0gbCAtIDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmU6IGluY29ycmVjdCBsZW5ndGgnKTtcbiAgICAgICAgY29uc3QgeyBkOiByLCBsOiBzQnl0ZXMgfSA9IERFUi5fcGFyc2VJbnQoZGF0YS5zdWJhcnJheSgyKSk7XG4gICAgICAgIGNvbnN0IHsgZDogcywgbDogckJ5dGVzTGVmdCB9ID0gREVSLl9wYXJzZUludChzQnl0ZXMpO1xuICAgICAgICBpZiAockJ5dGVzTGVmdC5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICByZXR1cm4geyByLCBzIH07XG4gICAgfSxcbiAgICBoZXhGcm9tU2lnKHNpZykge1xuICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvIGlmIGZpcnN0IGJ5dGUgaGFzIG5lZ2F0aXZlIGJpdCBlbmFibGVkLiBNb3JlIGRldGFpbHMgaW4gJ19wYXJzZUludCdcbiAgICAgICAgY29uc3Qgc2xpY2UgPSAocykgPT4gKE51bWJlci5wYXJzZUludChzWzBdLCAxNikgJiAwYjEwMDAgPyAnMDAnICsgcyA6IHMpO1xuICAgICAgICBjb25zdCBoID0gKG51bSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcyA9IHNsaWNlKGgoc2lnLnMpKTtcbiAgICAgICAgY29uc3QgciA9IHNsaWNlKGgoc2lnLnIpKTtcbiAgICAgICAgY29uc3Qgc2hsID0gcy5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCByaGwgPSByLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHNsID0gaChzaGwpO1xuICAgICAgICBjb25zdCBybCA9IGgocmhsKTtcbiAgICAgICAgcmV0dXJuIGAzMCR7aChyaGwgKyBzaGwgKyA0KX0wMiR7cmx9JHtyfTAyJHtzbH0ke3N9YDtcbiAgICB9LFxufTtcbi8vIEJlIGZyaWVuZGx5IHRvIGJhZCBFQ01BU2NyaXB0IHBhcnNlcnMgYnkgbm90IHVzaW5nIGJpZ2ludCBsaXRlcmFsc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyksIF80biA9IEJpZ0ludCg0KTtcbmV4cG9ydCBmdW5jdGlvbiB3ZWllcnN0cmFzc1BvaW50cyhvcHRzKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZVBvaW50T3B0cyhvcHRzKTtcbiAgICBjb25zdCB7IEZwIH0gPSBDVVJWRTsgLy8gQWxsIGN1cnZlcyBoYXMgc2FtZSBmaWVsZCAvIGdyb3VwIGxlbmd0aCBhcyBmb3Igbm93LCBidXQgdGhleSBjYW4gZGlmZmVyXG4gICAgY29uc3QgdG9CeXRlcyA9IENVUlZFLnRvQnl0ZXMgfHxcbiAgICAgICAgKChfYywgcG9pbnQsIF9pc0NvbXByZXNzZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHV0LmNvbmNhdEJ5dGVzKFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCBGcC50b0J5dGVzKGEueCksIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGZyb21CeXRlcyA9IENVUlZFLmZyb21CeXRlcyB8fFxuICAgICAgICAoKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICAvLyBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyBpZiAoaGVhZCAhPT0gMHgwNCkgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG5vbi1jb21wcmVzc2VkIGVuY29kaW5nIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICB9KTtcbiAgICAvKipcbiAgICAgKiB5wrIgPSB4wrMgKyBheCArIGI6IFNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGZvcm11bGFcbiAgICAgKiBAcmV0dXJucyB5wrJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpIHtcbiAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XG4gICAgICAgIGNvbnN0IHgzID0gRnAubXVsKHgyLCB4KTsgLy8geDIgKiB4XG4gICAgICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgYSkpLCBiKTsgLy8geDMgKyBhICogeCArIGJcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgd2hldGhlciB0aGUgcGFzc2VkIGN1cnZlIHBhcmFtcyBhcmUgdmFsaWQuXG4gICAgLy8gV2UgY2hlY2sgaWYgY3VydmUgZXF1YXRpb24gd29ya3MgZm9yIGdlbmVyYXRvciBwb2ludC5cbiAgICAvLyBgYXNzZXJ0VmFsaWRpdHkoKWAgd29uJ3Qgd29yazogYGlzVG9yc2lvbkZyZWUoKWAgaXMgbm90IGF2YWlsYWJsZSBhdCB0aGlzIHBvaW50IGluIGJsczEyLTM4MS5cbiAgICAvLyBQcm9qZWN0aXZlUG9pbnQgY2xhc3MgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldC5cbiAgICBpZiAoIUZwLmVxbChGcC5zcXIoQ1VSVkUuR3kpLCB3ZWllcnN0cmFzc0VxdWF0aW9uKENVUlZFLkd4KSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGdlbmVyYXRvciBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgIC8vIFZhbGlkIGdyb3VwIGVsZW1lbnRzIHJlc2lkZSBpbiByYW5nZSAxLi5uLTFcbiAgICBmdW5jdGlvbiBpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbnVtID09PSAnYmlnaW50JyAmJiBfMG4gPCBudW0gJiYgbnVtIDwgQ1VSVkUubjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0R0UobnVtKSB7XG4gICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhbGlkIGJpZ2ludDogMCA8IGJpZ2ludCA8IGN1cnZlLm4nKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGVzIGlmIHByaXYga2V5IGlzIHZhbGlkIGFuZCBjb252ZXJ0cyBpdCB0byBiaWdpbnQuXG4gICAgLy8gU3VwcG9ydHMgb3B0aW9ucyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMgYW5kIHdyYXBQcml2YXRlS2V5LlxuICAgIGZ1bmN0aW9uIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIoa2V5KSB7XG4gICAgICAgIGNvbnN0IHsgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiBsZW5ndGhzLCBuQnl0ZUxlbmd0aCwgd3JhcFByaXZhdGVLZXksIG4gfSA9IENVUlZFO1xuICAgICAgICBpZiAobGVuZ3RocyAmJiB0eXBlb2Yga2V5ICE9PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgICAgICAgICAga2V5ID0gdXQuYnl0ZXNUb0hleChrZXkpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIGhleCBzdHJpbmcsIHBhZC4gRS5nLiBQNTIxIHdvdWxkIG5vcm0gMTMwLTEzMiBjaGFyIGhleCB0byAxMzItY2hhciBieXRlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXknKTtcbiAgICAgICAgICAgIGtleSA9IGtleS5wYWRTdGFydChuQnl0ZUxlbmd0aCAqIDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG51bSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiB1dC5ieXRlc1RvTnVtYmVyQkUoZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5LCBuQnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcml2YXRlIGtleSBtdXN0IGJlICR7bkJ5dGVMZW5ndGh9IGJ5dGVzLCBoZXggb3IgYmlnaW50LCBub3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwUHJpdmF0ZUtleSlcbiAgICAgICAgICAgIG51bSA9IG1vZC5tb2QobnVtLCBuKTsgLy8gZGlzYWJsZWQgYnkgZGVmYXVsdCwgZW5hYmxlZCBmb3IgQkxTXG4gICAgICAgIGFzc2VydEdFKG51bSk7IC8vIG51bSBpbiByYW5nZSBbMS4uTi0xXVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICBjb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGFzc2VydFByalBvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvamVjdGl2ZSBQb2ludCB3b3JrcyBpbiAzZCAvIHByb2plY3RpdmUgKGhvbW9nZW5lb3VzKSBjb29yZGluYXRlczogKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAqIERlZmF1bHQgUG9pbnQgd29ya3MgaW4gMmQgLyBhZmZpbmUgY29vcmRpbmF0ZXM6ICh4LCB5KVxuICAgICAqIFdlJ3JlIGRvaW5nIGNhbGN1bGF0aW9ucyBpbiBwcm9qZWN0aXZlLCBiZWNhdXNlIGl0cyBvcGVyYXRpb25zIGRvbid0IHJlcXVpcmUgY29zdGx5IGludmVyc2lvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHB4LCBweSwgcHopIHtcbiAgICAgICAgICAgIHRoaXMucHggPSBweDtcbiAgICAgICAgICAgIHRoaXMucHkgPSBweTtcbiAgICAgICAgICAgIHRoaXMucHogPSBwejtcbiAgICAgICAgICAgIGlmIChweCA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweSA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweiA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB6KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb2VzIG5vdCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgb24tY3VydmUuXG4gICAgICAgIC8vIFVzZSBmcm9tSGV4IGluc3RlYWQsIG9yIGNhbGwgYXNzZXJ0VmFsaWRpdHkoKSBsYXRlci5cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFwIHx8ICFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCBpczAgPSAoaSkgPT4gRnAuZXFsKGksIEZwLlpFUk8pO1xuICAgICAgICAgICAgLy8gZnJvbUFmZmluZSh4OjAsIHk6MCkgd291bGQgcHJvZHVjZSAoeDowLCB5OjAsIHo6MSksIGJ1dCB3ZSBuZWVkICh4OjAsIHk6MSwgejowKVxuICAgICAgICAgICAgaWYgKGlzMCh4KSAmJiBpczAoeSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIEZwLk9ORSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGEgYnVuY2ggb2YgUHJvamVjdGl2ZSBQb2ludHMgYnV0IGV4ZWN1dGVzIG9ubHkgb25lXG4gICAgICAgICAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gICAgICAgICAqIHNvIHRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgbWFzc2l2ZWx5LlxuICAgICAgICAgKiBPcHRpbWl6YXRpb246IGNvbnZlcnRzIGEgbGlzdCBvZiBwcm9qZWN0aXZlIHBvaW50cyB0byBhIGxpc3Qgb2YgaWRlbnRpY2FsIHBvaW50cyB3aXRoIFo9MS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChwb2ludHMubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgaGFzaCBzdHJpbmcgb3IgVWludDhBcnJheSB0byBQb2ludC5cbiAgICAgICAgICogQHBhcmFtIGhleCBzaG9ydC9sb25nIEVDRFNBIGhleFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShmcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3BvaW50SGV4JywgaGV4KSkpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBnZW5lcmF0b3IgcG9pbnQgYnkgcHJpdmF0ZUtleS5cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgcG9pbnQgb24gY3VydmUgaXMgdmFsaWQgaWYgaXQgY29uZm9ybXMgdG8gZXF1YXRpb24uXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkpIHtcbiAgICAgICAgICAgICAgICAvLyAoMCwgMSwgMCkgYWthIFpFUk8gaXMgaW52YWxpZCBpbiBtb3N0IGNvbnRleHRzLlxuICAgICAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIHdyb25nIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8gYW5kIGlzIGFsd2F5cyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIGlmIChDVVJWRS5hbGxvd0luZmluaXR5UG9pbnQgJiYgIUZwLmlzMCh0aGlzLnB5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHgsIHkgYXJlIHZhbGlkIGZpZWxkIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVG9yc2lvbkZyZWUoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRXZlblkoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGlmIChGcC5pc09kZClcbiAgICAgICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgdDMpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDAsIHQzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MiA9IEZwLmFkZCh0MiwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0MiwgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICB3TkFGKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgcG9pbnRQcmVjb21wdXRlcywgbiwgKGNvbXApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKGNvbXAubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKG4pIHtcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGFzc2VydEdFKG4pOyAvLyBXaWxsIHRocm93IG9uIDBcbiAgICAgICAgICAgIGlmIChuID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKCFlbmRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBuKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGVuZG9tb3JwaGlzbVxuICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICBsZXQgazFwID0gSTtcbiAgICAgICAgICAgIGxldCBrMnAgPSBJO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGlmIChrMiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBrMSA+Pj0gXzFuO1xuICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICBhc3NlcnRHRShzY2FsYXIpO1xuICAgICAgICAgICAgbGV0IG4gPSBzY2FsYXI7XG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMik7XG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGB6YCBmb3IgYm90aCBwb2ludHMsIGJ1dCByZXR1cm4gb25seSByZWFsIG9uZVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Lm5vcm1hbGl6ZVooW3BvaW50LCBmYWtlXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVmZmljaWVudGx5IGNhbGN1bGF0ZSBgYVAgKyBiUWAuIFVuc2FmZSwgY2FuIGV4cG9zZSBwcml2YXRlIGtleSwgaWYgdXNlZCBpbmNvcnJlY3RseS5cbiAgICAgICAgICogTm90IHVzaW5nIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiBwcmVjb21wdXRhdGlvbiB0YWJsZXMgYXJlIGZhc3Rlci5cbiAgICAgICAgICogVGhlIHRyaWNrIGNvdWxkIGJlIHVzZWZ1bCBpZiBib3RoIFAgYW5kIFEgYXJlIG5vdCBHIChub3QgaW4gb3VyIGNhc2UpLlxuICAgICAgICAgKiBAcmV0dXJucyBub24temVybyBhZmZpbmUgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBQb2ludC5CQVNFOyAvLyBObyBTdHJhdXNzLVNoYW1pciB0cmljazogd2UgaGF2ZSAxMCUgZmFzdGVyIEcgcHJlY29tcHV0ZXNcbiAgICAgICAgICAgIGNvbnN0IG11bCA9IChQLCBhIC8vIFNlbGVjdCBmYXN0ZXIgbXVsdGlwbHkoKSBtZXRob2RcbiAgICAgICAgICAgICkgPT4gKGEgPT09IF8wbiB8fCBhID09PSBfMW4gfHwgIVAuZXF1YWxzKEcpID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSkpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bS5pczAoKSA/IHVuZGVmaW5lZCA6IHN1bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgICAgICAvLyAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBpczAgPSB0aGlzLmlzMCgpO1xuICAgICAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgICAgICAvLyBhbGwgb3BlcmF0aW9ucywgc28gd2UgcmVwbGFjZSBpbnZaIHdpdGggYSByYW5kb20gbnVtYmVyLCAxLlxuICAgICAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICAgICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5ieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XG4gICAgY29uc3QgX2JpdHMgPSBDVVJWRS5uQml0TGVuZ3RoO1xuICAgIGNvbnN0IHduYWYgPSB3TkFGKFBvaW50LCBDVVJWRS5lbmRvID8gTWF0aC5jZWlsKF9iaXRzIC8gMikgOiBfYml0cyk7XG4gICAgLy8gVmFsaWRhdGUgaWYgZ2VuZXJhdG9yIHBvaW50IGlzIG9uIGN1cnZlXG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxuICAgICAgICBiaXRzMmludF9tb2ROOiAnZnVuY3Rpb24nLFxuICAgICAgICBsb3dTOiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBsb3dTOiB0cnVlLCAuLi5vcHRzIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzKGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSIH0gPSBDVVJWRTtcbiAgICBjb25zdCBjb21wcmVzc2VkTGVuID0gRnAuQllURVMgKyAxOyAvLyBlLmcuIDMzIGZvciAzMlxuICAgIGNvbnN0IHVuY29tcHJlc3NlZExlbiA9IDIgKiBGcC5CWVRFUyArIDE7IC8vIGUuZy4gNjUgZm9yIDMyXG4gICAgZnVuY3Rpb24gaXNWYWxpZEZpZWxkRWxlbWVudChudW0pIHtcbiAgICAgICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBGcC5PUkRFUjsgLy8gMCBpcyBiYW5uZWQgc2luY2UgaXQncyBub3QgaW52ZXJ0aWJsZSBGRVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5tb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZOKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5pbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogUG9pbnQsIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsIHdlaWVyc3RyYXNzRXF1YXRpb24sIGlzV2l0aGluQ3VydmVPcmRlciwgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcbiAgICAgICAgLi4uQ1VSVkUsXG4gICAgICAgIHRvQnl0ZXMoX2MsIHBvaW50LCBpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IHV0LmNvbmNhdEJ5dGVzO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHV0LmJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IEZwLnNxcnQoeTIpOyAvLyB5ID0gecKyIF4gKHArMSkvNFxuICAgICAgICAgICAgICAgIGNvbnN0IGlzWU9kZCA9ICh5ICYgXzFuKSA9PT0gXzFuO1xuICAgICAgICAgICAgICAgIC8vIEVDRFNBXG4gICAgICAgICAgICAgICAgY29uc3QgaXNIZWFkT2RkID0gKGhlYWQgJiAxKSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIZWFkT2RkICE9PSBpc1lPZGQpXG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5uZWcoeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuID09PSB1bmNvbXByZXNzZWRMZW4gJiYgaGVhZCA9PT0gMHgwNCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2ludCBvZiBsZW5ndGggJHtsZW59IHdhcyBpbnZhbGlkLiBFeHBlY3RlZCAke2NvbXByZXNzZWRMZW59IGNvbXByZXNzZWQgYnl0ZXMgb3IgJHt1bmNvbXByZXNzZWRMZW59IHVuY29tcHJlc3NlZCBieXRlc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IG51bVRvTkJ5dGVTdHIgPSAobnVtKSA9PiB1dC5ieXRlc1RvSGV4KHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKSk7XG4gICAgZnVuY3Rpb24gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKG51bWJlcikge1xuICAgICAgICBjb25zdCBIQUxGID0gQ1VSVkVfT1JERVIgPj4gXzFuO1xuICAgICAgICByZXR1cm4gbnVtYmVyID4gSEFMRjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUyhzKSB7XG4gICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykgPyBtb2ROKC1zKSA6IHM7XG4gICAgfVxuICAgIC8vIHNsaWNlIGJ5dGVzIG51bVxuICAgIGNvbnN0IHNsY051bSA9IChiLCBmcm9tLCB0bykgPT4gdXQuYnl0ZXNUb051bWJlckJFKGIuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICAvKipcbiAgICAgKiBFQ0RTQSBzaWduYXR1cmUgd2l0aCBpdHMgKHIsIHMpIHByb3BlcnRpZXMuIFN1cHBvcnRzIERFUiAmIGNvbXBhY3QgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuICAgIGNsYXNzIFNpZ25hdHVyZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHIsIHMsIHJlY292ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlcnkgPSByZWNvdmVyeTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWlyIChieXRlcyBvZiByLCBieXRlcyBvZiBzKVxuICAgICAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBsID0gQ1VSVkUubkJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBoZXggPSBlbnN1cmVCeXRlcygnY29tcGFjdFNpZ25hdHVyZScsIGhleCwgbCAqIDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoc2xjTnVtKGhleCwgMCwgbCksIHNsY051bShoZXgsIGwsIDIgKiBsKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSIGVuY29kZWQgRUNEU0Egc2lnbmF0dXJlXG4gICAgICAgIC8vIGh0dHBzOi8vYml0Y29pbi5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNTc2NDQvd2hhdC1hcmUtdGhlLXBhcnRzLW9mLWEtYml0Y29pbi10cmFuc2FjdGlvbi1pbnB1dC1zY3JpcHRcbiAgICAgICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IERFUi50b1NpZyhlbnN1cmVCeXRlcygnREVSJywgaGV4KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIC8vIGNhbiB1c2UgYXNzZXJ0R0UgaGVyZVxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5yKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3IgbXVzdCBiZSAwIDwgciA8IENVUlZFLm4nKTtcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzIG11c3QgYmUgMCA8IHMgPCBDVVJWRS5uJyk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkUmVjb3ZlcnlCaXQocmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMuciwgdGhpcy5zLCByZWNvdmVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5OiByZWMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgICAgICAgaWYgKHJlYyA9PSBudWxsIHx8ICFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xuICAgICAgICAgICAgaWYgKHJhZGogPj0gRnAuT1JERVIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChwcmVmaXggKyBudW1Ub05CeXRlU3RyKHJhZGopKTtcbiAgICAgICAgICAgIGNvbnN0IGlyID0gaW52TihyYWRqKTsgLy8gcl4tMVxuICAgICAgICAgICAgY29uc3QgdTEgPSBtb2ROKC1oICogaXIpOyAvLyAtaHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUyID0gbW9kTihzICogaXIpOyAvLyBzcl4tMVxuICAgICAgICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUiwgdTEsIHUyKTsgLy8gKHNyXi0xKVItKGhyXi0xKUcgPSAtKGhyXi0xKUcgKyAoc3JeLTEpXG4gICAgICAgICAgICBpZiAoIVEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2ludCBhdCBpbmZpbmlmeScpOyAvLyB1bnNhZmUgaXMgZmluZTogbm8gcHJpdiBkYXRhIGxlYWtlZFxuICAgICAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzaG91bGQgYmUgbG93LXMsIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5LlxuICAgICAgICBoYXNIaWdoUygpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVTKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBtb2ROKC10aGlzLnMpLCB0aGlzLnJlY292ZXJ5KSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSLWVuY29kZWRcbiAgICAgICAgdG9ERVJSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9ERVJIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gREVSLmhleEZyb21TaWcoeyByOiB0aGlzLnIsIHM6IHRoaXMucyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWRkZWQgYnl0ZXMgb2YgciwgdGhlbiBwYWRkZWQgYnl0ZXMgb2Ygc1xuICAgICAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9Db21wYWN0SGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1Ub05CeXRlU3RyKHRoaXMucikgKyBudW1Ub05CeXRlU3RyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2VzIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwcml2YXRlIGtleSBmcm9tIHJhbmRvbSBvZiBzaXplXG4gICAgICAgICAqIChncm91cExlbiArIGNlaWwoZ3JvdXBMZW4gLyAyKSkgd2l0aCBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gbW9kLmdldE1pbkhhc2hMZW5ndGgoQ1VSVkUubik7XG4gICAgICAgICAgICByZXR1cm4gbW9kLm1hcEhhc2hUb0ZpZWxkKENVUlZFLnJhbmRvbUJ5dGVzKGxlbmd0aCksIENVUlZFLm4pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBwcmVjb21wdXRlIHRhYmxlIGZvciBhbiBhcmJpdHJhcnkgRUMgcG9pbnQuIE1ha2VzIHBvaW50IFwiY2FjaGVkXCIuXG4gICAgICAgICAqIEFsbG93cyB0byBtYXNzaXZlbHkgc3BlZWQtdXAgYHBvaW50Lm11bHRpcGx5KHNjYWxhcilgLlxuICAgICAgICAgKiBAcmV0dXJucyBjYWNoZWQgcG9pbnRcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogY29uc3QgZmFzdCA9IHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoc29tZW9uZXNQdWJLZXkpKTtcbiAgICAgICAgICogZmFzdC5tdWx0aXBseShwcml2S2V5KTsgLy8gbXVjaCBmYXN0ZXIgRUNESCBub3dcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuICAgICAgICAgICAgcG9pbnQuX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSk7XG4gICAgICAgICAgICBwb2ludC5tdWx0aXBseShCaWdJbnQoMykpOyAvLyAzIGlzIGFyYml0cmFyeSwganVzdCBuZWVkIGFueSBudW1iZXIgaGVyZVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9LFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgcHVibGljIGtleSBmb3IgYSBwcml2YXRlIGtleS4gQ2hlY2tzIGZvciB2YWxpZGl0eSBvZiB0aGUgcHJpdmF0ZSBrZXkuXG4gICAgICogQHBhcmFtIHByaXZhdGVLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIFB1YmxpYyBrZXksIGZ1bGwgd2hlbiBpc0NvbXByZXNzZWQ9ZmFsc2U7IHNob3J0IHdoZW4gaXNDb21wcmVzc2VkPXRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWljayBhbmQgZGlydHkgY2hlY2sgZm9yIGl0ZW0gYmVpbmcgcHVibGljIGtleS4gRG9lcyBub3QgdmFsaWRhdGUgaGV4LCBvciBiZWluZyBvbi1jdXJ2ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb2JQdWIoaXRlbSkge1xuICAgICAgICBjb25zdCBhcnIgPSBpdGVtIGluc3RhbmNlb2YgVWludDhBcnJheTtcbiAgICAgICAgY29uc3Qgc3RyID0gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnO1xuICAgICAgICBjb25zdCBsZW4gPSAoYXJyIHx8IHN0cikgJiYgaXRlbS5sZW5ndGg7XG4gICAgICAgIGlmIChhcnIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuO1xuICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gMiAqIGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSAyICogdW5jb21wcmVzc2VkTGVuO1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRUNESCAoRWxsaXB0aWMgQ3VydmUgRGlmZmllIEhlbGxtYW4pLlxuICAgICAqIENvbXB1dGVzIHNoYXJlZCBwdWJsaWMga2V5IGZyb20gcHJpdmF0ZSBrZXkgYW5kIHB1YmxpYyBrZXkuXG4gICAgICogQ2hlY2tzOiAxKSBwcml2YXRlIGtleSB2YWxpZGl0eSAyKSBzaGFyZWQga2V5IGlzIG9uLWN1cnZlLlxuICAgICAqIERvZXMgTk9UIGhhc2ggdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUEgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gcHVibGljQiBkaWZmZXJlbnQgcHVibGljIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgc2hhcmVkIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdmF0ZUEsIHB1YmxpY0IsIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgaWYgKGlzUHJvYlB1Yihwcml2YXRlQSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZyBtdXN0IGJlIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIGlmICghaXNQcm9iUHViKHB1YmxpY0IpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmQgYXJnIG11c3QgYmUgcHVibGljIGtleScpO1xuICAgICAgICBjb25zdCBiID0gUG9pbnQuZnJvbUhleChwdWJsaWNCKTsgLy8gY2hlY2sgZm9yIGJlaW5nIG9uLWN1cnZlXG4gICAgICAgIHJldHVybiBiLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUEpKS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8vIFJGQzY5Nzk6IGVuc3VyZSBFQ0RTQSBtc2cgaXMgWCBieXRlcyBhbmQgPCBOLiBSRkMgc3VnZ2VzdHMgb3B0aW9uYWwgdHJ1bmNhdGluZyB2aWEgYml0czJvY3RldHMuXG4gICAgLy8gRklQUyAxODYtNCA0LjYgc3VnZ2VzdHMgdGhlIGxlZnRtb3N0IG1pbihuQml0TGVuLCBvdXRMZW4pIGJpdHMsIHdoaWNoIG1hdGNoZXMgYml0czJpbnQuXG4gICAgLy8gYml0czJpbnQgY2FuIHByb2R1Y2UgcmVzPk4sIHdlIGNhbiBkbyBtb2QocmVzLCBOKSBzaW5jZSB0aGUgYml0TGVuIGlzIHRoZSBzYW1lLlxuICAgIC8vIGludDJvY3RldHMgY2FuJ3QgYmUgdXNlZDsgcGFkcyBzbWFsbCBtc2dzIHdpdGggMDogdW5hY2NlcHRhdGJsZSBmb3IgdHJ1bmMgYXMgcGVyIFJGQyB2ZWN0b3JzXG4gICAgY29uc3QgYml0czJpbnQgPSBDVVJWRS5iaXRzMmludCB8fFxuICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIEZvciBjdXJ2ZXMgd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMDogYml0czJvY3RldHMoYml0czJvY3RldHMobSkpICE9PSBiaXRzMm9jdGV0cyhtKVxuICAgICAgICAgICAgLy8gZm9yIHNvbWUgY2FzZXMsIHNpbmNlIGJ5dGVzLmxlbmd0aCAqIDggaXMgbm90IGFjdHVhbCBiaXRMZW5ndGguXG4gICAgICAgICAgICBjb25zdCBudW0gPSB1dC5ieXRlc1RvTnVtYmVyQkUoYnl0ZXMpOyAvLyBjaGVjayBmb3IgPT0gdTggZG9uZSBoZXJlXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGJ5dGVzLmxlbmd0aCAqIDggLSBDVVJWRS5uQml0TGVuZ3RoOyAvLyB0cnVuY2F0ZSB0byBuQml0TGVuZ3RoIGxlZnRtb3N0IGJpdHNcbiAgICAgICAgICAgIHJldHVybiBkZWx0YSA+IDAgPyBudW0gPj4gQmlnSW50KGRlbHRhKSA6IG51bTtcbiAgICAgICAgfTtcbiAgICBjb25zdCBiaXRzMmludF9tb2ROID0gQ1VSVkUuYml0czJpbnRfbW9kTiB8fFxuICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2ROKGJpdHMyaW50KGJ5dGVzKSk7IC8vIGNhbid0IHVzZSBieXRlc1RvTnVtYmVyQkUgaGVyZVxuICAgICAgICB9O1xuICAgIC8vIE5PVEU6IHBhZHMgb3V0cHV0IHdpdGggemVybyBhcyBwZXIgc3BlY1xuICAgIGNvbnN0IE9SREVSX01BU0sgPSB1dC5iaXRNYXNrKENVUlZFLm5CaXRMZW5ndGgpO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRvIGJ5dGVzLiBDaGVja3MgaWYgbnVtIGluIGBbMC4uT1JERVJfTUFTSy0xXWAgZS5nLjogYFswLi4yXjI1Ni0xXWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50Mm9jdGV0cyhudW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaWdpbnQgZXhwZWN0ZWQnKTtcbiAgICAgICAgaWYgKCEoXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUl9NQVNLKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmlnaW50IGV4cGVjdGVkIDwgMl4ke0NVUlZFLm5CaXRMZW5ndGh9YCk7XG4gICAgICAgIC8vIHdvcmtzIHdpdGggb3JkZXIsIGNhbiBoYXZlIGRpZmZlcmVudCBzaXplIHRoYW4gbnVtVG9GaWVsZCFcbiAgICAgICAgcmV0dXJuIHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMlxuICAgIC8vIENyZWF0ZXMgUkZDNjk3OSBzZWVkOyBjb252ZXJ0cyBtc2cvcHJpdktleSB0byBudW1iZXJzLlxuICAgIC8vIFVzZWQgb25seSBpbiBzaWduLCBub3QgaW4gdmVyaWZ5LlxuICAgIC8vIE5PVEU6IHdlIGNhbm5vdCBhc3N1bWUgaGVyZSB0aGF0IG1zZ0hhc2ggaGFzIHNhbWUgYW1vdW50IG9mIGJ5dGVzIGFzIGN1cnZlIG9yZGVyLCB0aGlzIHdpbGwgYmUgd3JvbmcgYXQgbGVhc3QgZm9yIFA1MjEuXG4gICAgLy8gQWxzbyBpdCBjYW4gYmUgYmlnZ2VyIGZvciBQMjI0ICsgU0hBMjU2XG4gICAgZnVuY3Rpb24gcHJlcFNpZyhtc2dIYXNoLCBwcml2YXRlS2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgaWYgKFsncmVjb3ZlcmVkJywgJ2Nhbm9uaWNhbCddLnNvbWUoKGspID0+IGsgaW4gb3B0cykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24oKSBsZWdhY3kgb3B0aW9ucyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIGNvbnN0IHsgaGFzaCwgcmFuZG9tQnl0ZXMgfSA9IENVUlZFO1xuICAgICAgICBsZXQgeyBsb3dTLCBwcmVoYXNoLCBleHRyYUVudHJvcHk6IGVudCB9ID0gb3B0czsgLy8gZ2VuZXJhdGVzIGxvdy1zIHNpZ3MgYnkgZGVmYXVsdFxuICAgICAgICBpZiAobG93UyA9PSBudWxsKVxuICAgICAgICAgICAgbG93UyA9IHRydWU7IC8vIFJGQzY5NzkgMy4yOiB3ZSBza2lwIHN0ZXAgQSwgYmVjYXVzZSB3ZSBhbHJlYWR5IHByb3ZpZGUgaGFzaFxuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ3ByZWhhc2hlZCBtc2dIYXNoJywgaGFzaChtc2dIYXNoKSk7XG4gICAgICAgIC8vIFdlIGNhbid0IGxhdGVyIGNhbGwgYml0czJvY3RldHMsIHNpbmNlIG5lc3RlZCBiaXRzMmludCBpcyBicm9rZW4gZm9yIGN1cnZlc1xuICAgICAgICAvLyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwLiBCZWNhdXNlIG9mIHRoYXQsIHdlIHVud3JhcCBpdCBoZXJlIGFzIGludDJvY3RldHMgY2FsbC5cbiAgICAgICAgLy8gY29uc3QgYml0czJvY3RldHMgPSAoYml0cykgPT4gaW50Mm9jdGV0cyhiaXRzMmludF9tb2ROKGJpdHMpKVxuICAgICAgICBjb25zdCBoMWludCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IGQgPSBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpOyAvLyB2YWxpZGF0ZSBwcml2YXRlIGtleSwgY29udmVydCB0byBiaWdpbnRcbiAgICAgICAgY29uc3Qgc2VlZEFyZ3MgPSBbaW50Mm9jdGV0cyhkKSwgaW50Mm9jdGV0cyhoMWludCldO1xuICAgICAgICAvLyBleHRyYUVudHJvcHkuIFJGQzY5NzkgMy42OiBhZGRpdGlvbmFsIGsnIChvcHRpb25hbCkuXG4gICAgICAgIGlmIChlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMoRnAuQllURVMpIDogZW50OyAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgICAgICAgc2VlZEFyZ3MucHVzaChlbnN1cmVCeXRlcygnZXh0cmFFbnRyb3B5JywgZSkpOyAvLyBjaGVjayBmb3IgYmVpbmcgYnl0ZXNcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVkID0gdXQuY29uY2F0Qnl0ZXMoLi4uc2VlZEFyZ3MpOyAvLyBTdGVwIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAgICAgY29uc3QgbSA9IGgxaW50OyAvLyBOT1RFOiBubyBuZWVkIHRvIGNhbGwgYml0czJpbnQgc2Vjb25kIHRpbWUgaGVyZSwgaXQgaXMgaW5zaWRlIHRydW5jYXRlSGFzaCFcbiAgICAgICAgLy8gQ29udmVydHMgc2lnbmF0dXJlIHBhcmFtcyBpbnRvIHBvaW50IHcgci9zLCBjaGVja3MgcmVzdWx0IGZvciB2YWxpZGl0eS5cbiAgICAgICAgZnVuY3Rpb24gazJzaWcoa0J5dGVzKSB7XG4gICAgICAgICAgICAvLyBSRkMgNjk3OSBTZWN0aW9uIDMuMiwgc3RlcCAzOiBrID0gYml0czJpbnQoVClcbiAgICAgICAgICAgIGNvbnN0IGsgPSBiaXRzMmludChrQnl0ZXMpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihrKSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEltcG9ydGFudDogYWxsIG1vZCgpIGNhbGxzIGhlcmUgbXVzdCBiZSBkb25lIG92ZXIgTlxuICAgICAgICAgICAgY29uc3QgaWsgPSBpbnZOKGspOyAvLyBrXi0xIG1vZCBuXG4gICAgICAgICAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKS50b0FmZmluZSgpOyAvLyBxID0gR2tcbiAgICAgICAgICAgIGNvbnN0IHIgPSBtb2ROKHEueCk7IC8vIHIgPSBxLnggbW9kIG5cbiAgICAgICAgICAgIGlmIChyID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gQ2FuIHVzZSBzY2FsYXIgYmxpbmRpbmcgYl4tMShibSArIGJkcikgd2hlcmUgYiDiiIggWzEsceKIkjFdIGFjY29yZGluZyB0b1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzczMzcvNjUwOS4gV2UndmUgZGVjaWRlZCBhZ2FpbnN0IGl0OlxuICAgICAgICAgICAgLy8gYSkgZGVwZW5kZW5jeSBvbiBDU1BSTkcgYikgMTUlIHNsb3dkb3duIGMpIGRvZXNuJ3QgcmVhbGx5IGhlbHAgc2luY2UgYmlnaW50cyBhcmUgbm90IENUXG4gICAgICAgICAgICBjb25zdCBzID0gbW9kTihpayAqIG1vZE4obSArIHIgKiBkKSk7IC8vIE5vdCB1c2luZyBibGluZGluZyBoZXJlXG4gICAgICAgICAgICBpZiAocyA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCByZWNvdmVyeSA9IChxLnggPT09IHIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTsgLy8gcmVjb3ZlcnkgYml0ICgyIG9yIDMsIHdoZW4gcS54ID4gbilcbiAgICAgICAgICAgIGxldCBub3JtUyA9IHM7XG4gICAgICAgICAgICBpZiAobG93UyAmJiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykpIHtcbiAgICAgICAgICAgICAgICBub3JtUyA9IG5vcm1hbGl6ZVMocyk7IC8vIGlmIGxvd1Mgd2FzIHBhc3NlZCwgZW5zdXJlIHMgaXMgYWx3YXlzXG4gICAgICAgICAgICAgICAgcmVjb3ZlcnkgXj0gMTsgLy8gLy8gaW4gdGhlIGJvdHRvbSBoYWxmIG9mIE5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSk7IC8vIHVzZSBub3JtUywgbm90IHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZWVkLCBrMnNpZyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0U2lnT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICBjb25zdCBkZWZhdWx0VmVyT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICAvKipcbiAgICAgKiBTaWducyBtZXNzYWdlIGhhc2ggd2l0aCBhIHByaXZhdGUga2V5LlxuICAgICAqIGBgYFxuICAgICAqIHNpZ24obSwgZCwgaykgd2hlcmVcbiAgICAgKiAgICh4LCB5KSA9IEcgw5cga1xuICAgICAqICAgciA9IHggbW9kIG5cbiAgICAgKiAgIHMgPSAobSArIGRyKS9rIG1vZCBuXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIG1zZ0hhc2ggTk9UIG1lc3NhZ2UuIG1zZyBuZWVkcyB0byBiZSBoYXNoZWQgdG8gYG1zZ0hhc2hgLCBvciB1c2UgYHByZWhhc2hgLlxuICAgICAqIEBwYXJhbSBwcml2S2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIG9wdHMgbG93UyBmb3Igbm9uLW1hbGxlYWJsZSBzaWdzLiBleHRyYUVudHJvcHkgZm9yIG1peGluZyByYW5kb21uZXNzIGludG8gay4gcHJlaGFzaCB3aWxsIGhhc2ggZmlyc3QgYXJnLlxuICAgICAqIEByZXR1cm5zIHNpZ25hdHVyZSB3aXRoIHJlY292ZXJ5IHBhcmFtXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgY29uc3QgeyBzZWVkLCBrMnNpZyB9ID0gcHJlcFNpZyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzKTsgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMi5cbiAgICAgICAgY29uc3QgQyA9IENVUlZFO1xuICAgICAgICBjb25zdCBkcmJnID0gdXQuY3JlYXRlSG1hY0RyYmcoQy5oYXNoLm91dHB1dExlbiwgQy5uQnl0ZUxlbmd0aCwgQy5obWFjKTtcbiAgICAgICAgcmV0dXJuIGRyYmcoc2VlZCwgazJzaWcpOyAvLyBTdGVwcyBCLCBDLCBELCBFLCBGLCBHXG4gICAgfVxuICAgIC8vIEVuYWJsZSBwcmVjb21wdXRlcy4gU2xvd3MgZG93biBmaXJzdCBwdWJsaWNLZXkgY29tcHV0YXRpb24gYnkgMjBtcy5cbiAgICBQb2ludC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuICAgIC8vIHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LkJBU0UpXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBzaWduYXR1cmUgYWdhaW5zdCBtZXNzYWdlIGhhc2ggYW5kIHB1YmxpYyBrZXkuXG4gICAgICogUmVqZWN0cyBsb3dTIHNpZ25hdHVyZXMgYnkgZGVmYXVsdDogdG8gb3ZlcnJpZGUsXG4gICAgICogc3BlY2lmeSBvcHRpb24gYHtsb3dTOiBmYWxzZX1gLiBJbXBsZW1lbnRzIHNlY3Rpb24gNC4xLjQgZnJvbSBodHRwczovL3d3dy5zZWNnLm9yZy9zZWMxLXYyLnBkZjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZlcmlmeShyLCBzLCBoLCBQKSB3aGVyZVxuICAgICAqICAgVTEgPSBoc14tMSBtb2QgblxuICAgICAqICAgVTIgPSByc14tMSBtb2QgblxuICAgICAqICAgUiA9IFUx4ouFRyAtIFUy4ouFUFxuICAgICAqICAgbW9kKFIueCwgbikgPT0gclxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YmxpY0tleSwgb3B0cyA9IGRlZmF1bHRWZXJPcHRzKSB7XG4gICAgICAgIGNvbnN0IHNnID0gc2lnbmF0dXJlO1xuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgcHVibGljS2V5ID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSk7XG4gICAgICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnN0cmljdCB3YXMgcmVuYW1lZCB0byBsb3dTJyk7XG4gICAgICAgIGNvbnN0IHsgbG93UywgcHJlaGFzaCB9ID0gb3B0cztcbiAgICAgICAgbGV0IF9zaWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBQO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgc2cgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgLy8gU2lnbmF0dXJlIGNhbiBiZSByZXByZXNlbnRlZCBpbiAyIHdheXM6IGNvbXBhY3QgKDIqbkJ5dGVMZW5ndGgpICYgREVSICh2YXJpYWJsZS1sZW5ndGgpLlxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIERFUiBjYW4gYWxzbyBiZSAyKm5CeXRlTGVuZ3RoIGJ5dGVzLCB3ZSBjaGVjayBmb3IgaXQgZmlyc3QuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tREVSKHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGRlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGRlckVycm9yIGluc3RhbmNlb2YgREVSLkVycikpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkZXJFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tQ29tcGFjdChzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNnID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc2cuciA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIHNnLnMgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBzZztcbiAgICAgICAgICAgICAgICBfc2lnID0gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUEFSU0UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFAgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSA9PT0gJ1BBUlNFJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNpZ25hdHVyZSBtdXN0IGJlIFNpZ25hdHVyZSBpbnN0YW5jZSwgVWludDhBcnJheSBvciBoZXggc3RyaW5nYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd1MgJiYgX3NpZy5oYXNIaWdoUygpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBDVVJWRS5oYXNoKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IF9zaWc7XG4gICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgIGNvbnN0IGlzID0gaW52TihzKTsgLy8gc14tMVxuICAgICAgICBjb25zdCB1MSA9IG1vZE4oaCAqIGlzKTsgLy8gdTEgPSBoc14tMSBtb2QgblxuICAgICAgICBjb25zdCB1MiA9IG1vZE4ociAqIGlzKTsgLy8gdTIgPSByc14tMSBtb2QgblxuICAgICAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCB1MSwgdTIpPy50b0FmZmluZSgpOyAvLyBSID0gdTHii4VHICsgdTLii4VQXG4gICAgICAgIGlmICghUilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgdiA9IG1vZE4oUi54KTtcbiAgICAgICAgcmV0dXJuIHYgPT09IHI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIGdldFNoYXJlZFNlY3JldCxcbiAgICAgICAgc2lnbixcbiAgICAgICAgdmVyaWZ5LFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBTaWduYXR1cmUsXG4gICAgICAgIHV0aWxzLFxuICAgIH07XG59XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBTaGFsbHVlIGFuZCB2YW4gZGUgV29lc3Rpam5lIG1ldGhvZCBmb3IgYW55IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogVE9ETzogY2hlY2sgaWYgdGhlcmUgaXMgYSB3YXkgdG8gbWVyZ2UgdGhpcyB3aXRoIHV2UmF0aW8gaW4gRWR3YXJkczsgbW92ZSB0byBtb2R1bGFyLlxuICogYiA9IFRydWUgYW5kIHkgPSBzcXJ0KHUgLyB2KSBpZiAodSAvIHYpIGlzIHNxdWFyZSBpbiBGLCBhbmRcbiAqIGIgPSBGYWxzZSBhbmQgeSA9IHNxcnQoWiAqICh1IC8gdikpIG90aGVyd2lzZS5cbiAqIEBwYXJhbSBGcFxuICogQHBhcmFtIFpcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBTV1VGcFNxcnRSYXRpbyhGcCwgWikge1xuICAgIC8vIEdlbmVyaWMgaW1wbGVtZW50YXRpb25cbiAgICBjb25zdCBxID0gRnAuT1JERVI7XG4gICAgbGV0IGwgPSBfMG47XG4gICAgZm9yIChsZXQgbyA9IHEgLSBfMW47IG8gJSBfMm4gPT09IF8wbjsgbyAvPSBfMm4pXG4gICAgICAgIGwgKz0gXzFuO1xuICAgIGNvbnN0IGMxID0gbDsgLy8gMS4gYzEsIHRoZSBsYXJnZXN0IGludGVnZXIgc3VjaCB0aGF0IDJeYzEgZGl2aWRlcyBxIC0gMS5cbiAgICAvLyBXZSBuZWVkIDJuICoqIGMxIGFuZCAybiAqKiAoYzEtMSkuIFdlIGNhbid0IHVzZSAqKjsgYnV0IHdlIGNhbiB1c2UgPDwuXG4gICAgLy8gMm4gKiogYzEgPT0gMm4gPDwgKGMxLTEpXG4gICAgY29uc3QgXzJuX3Bvd19jMV8xID0gXzJuIDw8IChjMSAtIF8xbiAtIF8xbik7XG4gICAgY29uc3QgXzJuX3Bvd19jMSA9IF8ybl9wb3dfYzFfMSAqIF8ybjtcbiAgICBjb25zdCBjMiA9IChxIC0gXzFuKSAvIF8ybl9wb3dfYzE7IC8vIDIuIGMyID0gKHEgLSAxKSAvICgyXmMxKSAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjMyA9IChjMiAtIF8xbikgLyBfMm47IC8vIDMuIGMzID0gKGMyIC0gMSkgLyAyICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjNCA9IF8ybl9wb3dfYzEgLSBfMW47IC8vIDQuIGM0ID0gMl5jMSAtIDEgICAgICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjNSA9IF8ybl9wb3dfYzFfMTsgLy8gNS4gYzUgPSAyXihjMSAtIDEpICAgICAgICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjNiA9IEZwLnBvdyhaLCBjMik7IC8vIDYuIGM2ID0gWl5jMlxuICAgIGNvbnN0IGM3ID0gRnAucG93KFosIChjMiArIF8xbikgLyBfMm4pOyAvLyA3LiBjNyA9IFpeKChjMiArIDEpIC8gMilcbiAgICBsZXQgc3FydFJhdGlvID0gKHUsIHYpID0+IHtcbiAgICAgICAgbGV0IHR2MSA9IGM2OyAvLyAxLiB0djEgPSBjNlxuICAgICAgICBsZXQgdHYyID0gRnAucG93KHYsIGM0KTsgLy8gMi4gdHYyID0gdl5jNFxuICAgICAgICBsZXQgdHYzID0gRnAuc3FyKHR2Mik7IC8vIDMuIHR2MyA9IHR2Ml4yXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIHYpOyAvLyA0LiB0djMgPSB0djMgKiB2XG4gICAgICAgIGxldCB0djUgPSBGcC5tdWwodSwgdHYzKTsgLy8gNS4gdHY1ID0gdSAqIHR2M1xuICAgICAgICB0djUgPSBGcC5wb3codHY1LCBjMyk7IC8vIDYuIHR2NSA9IHR2NV5jM1xuICAgICAgICB0djUgPSBGcC5tdWwodHY1LCB0djIpOyAvLyA3LiB0djUgPSB0djUgKiB0djJcbiAgICAgICAgdHYyID0gRnAubXVsKHR2NSwgdik7IC8vIDguIHR2MiA9IHR2NSAqIHZcbiAgICAgICAgdHYzID0gRnAubXVsKHR2NSwgdSk7IC8vIDkuIHR2MyA9IHR2NSAqIHVcbiAgICAgICAgbGV0IHR2NCA9IEZwLm11bCh0djMsIHR2Mik7IC8vIDEwLiB0djQgPSB0djMgKiB0djJcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NCwgYzUpOyAvLyAxMS4gdHY1ID0gdHY0XmM1XG4gICAgICAgIGxldCBpc1FSID0gRnAuZXFsKHR2NSwgRnAuT05FKTsgLy8gMTIuIGlzUVIgPSB0djUgPT0gMVxuICAgICAgICB0djIgPSBGcC5tdWwodHYzLCBjNyk7IC8vIDEzLiB0djIgPSB0djMgKiBjN1xuICAgICAgICB0djUgPSBGcC5tdWwodHY0LCB0djEpOyAvLyAxNC4gdHY1ID0gdHY0ICogdHYxXG4gICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGlzUVIpOyAvLyAxNS4gdHYzID0gQ01PVih0djIsIHR2MywgaXNRUilcbiAgICAgICAgdHY0ID0gRnAuY21vdih0djUsIHR2NCwgaXNRUik7IC8vIDE2LiB0djQgPSBDTU9WKHR2NSwgdHY0LCBpc1FSKVxuICAgICAgICAvLyAxNy4gZm9yIGkgaW4gKGMxLCBjMSAtIDEsIC4uLiwgMik6XG4gICAgICAgIGZvciAobGV0IGkgPSBjMTsgaSA+IF8xbjsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgdHY1ID0gaSAtIF8ybjsgLy8gMTguICAgIHR2NSA9IGkgLSAyXG4gICAgICAgICAgICB0djUgPSBfMm4gPDwgKHR2NSAtIF8xbik7IC8vIDE5LiAgICB0djUgPSAyXnR2NVxuICAgICAgICAgICAgbGV0IHR2djUgPSBGcC5wb3codHY0LCB0djUpOyAvLyAyMC4gICAgdHY1ID0gdHY0XnR2NVxuICAgICAgICAgICAgY29uc3QgZTEgPSBGcC5lcWwodHZ2NSwgRnAuT05FKTsgLy8gMjEuICAgIGUxID0gdHY1ID09IDFcbiAgICAgICAgICAgIHR2MiA9IEZwLm11bCh0djMsIHR2MSk7IC8vIDIyLiAgICB0djIgPSB0djMgKiB0djFcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2MSk7IC8vIDIzLiAgICB0djEgPSB0djEgKiB0djFcbiAgICAgICAgICAgIHR2djUgPSBGcC5tdWwodHY0LCB0djEpOyAvLyAyNC4gICAgdHY1ID0gdHY0ICogdHYxXG4gICAgICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBlMSk7IC8vIDI1LiAgICB0djMgPSBDTU9WKHR2MiwgdHYzLCBlMSlcbiAgICAgICAgICAgIHR2NCA9IEZwLmNtb3YodHZ2NSwgdHY0LCBlMSk7IC8vIDI2LiAgICB0djQgPSBDTU9WKHR2NSwgdHY0LCBlMSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogdHYzIH07XG4gICAgfTtcbiAgICBpZiAoRnAuT1JERVIgJSBfNG4gPT09IF8zbikge1xuICAgICAgICAvLyBzcXJ0X3JhdGlvXzNtb2Q0KHUsIHYpXG4gICAgICAgIGNvbnN0IGMxID0gKEZwLk9SREVSIC0gXzNuKSAvIF80bjsgLy8gMS4gYzEgPSAocSAtIDMpIC8gNCAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgY29uc3QgYzIgPSBGcC5zcXJ0KEZwLm5lZyhaKSk7IC8vIDIuIGMyID0gc3FydCgtWilcbiAgICAgICAgc3FydFJhdGlvID0gKHUsIHYpID0+IHtcbiAgICAgICAgICAgIGxldCB0djEgPSBGcC5zcXIodik7IC8vIDEuIHR2MSA9IHZeMlxuICAgICAgICAgICAgY29uc3QgdHYyID0gRnAubXVsKHUsIHYpOyAvLyAyLiB0djIgPSB1ICogdlxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYyKTsgLy8gMy4gdHYxID0gdHYxICogdHYyXG4gICAgICAgICAgICBsZXQgeTEgPSBGcC5wb3codHYxLCBjMSk7IC8vIDQuIHkxID0gdHYxXmMxXG4gICAgICAgICAgICB5MSA9IEZwLm11bCh5MSwgdHYyKTsgLy8gNS4geTEgPSB5MSAqIHR2MlxuICAgICAgICAgICAgY29uc3QgeTIgPSBGcC5tdWwoeTEsIGMyKTsgLy8gNi4geTIgPSB5MSAqIGMyXG4gICAgICAgICAgICBjb25zdCB0djMgPSBGcC5tdWwoRnAuc3FyKHkxKSwgdik7IC8vIDcuIHR2MyA9IHkxXjI7IDguIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgICAgIGNvbnN0IGlzUVIgPSBGcC5lcWwodHYzLCB1KTsgLy8gOS4gaXNRUiA9IHR2MyA9PSB1XG4gICAgICAgICAgICBsZXQgeSA9IEZwLmNtb3YoeTIsIHkxLCBpc1FSKTsgLy8gMTAuIHkgPSBDTU9WKHkyLCB5MSwgaXNRUilcbiAgICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB5IH07IC8vIDExLiByZXR1cm4gKGlzUVIsIHkpIGlzUVIgPyB5IDogeSpjMlxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBObyBjdXJ2ZXMgdXNlcyB0aGF0XG4gICAgLy8gaWYgKEZwLk9SREVSICUgXzhuID09PSBfNW4pIC8vIHNxcnRfcmF0aW9fNW1vZDhcbiAgICByZXR1cm4gc3FydFJhdGlvO1xufVxuLyoqXG4gKiBTaW1wbGlmaWVkIFNoYWxsdWUtdmFuIGRlIFdvZXN0aWpuZS1VbGFzIE1ldGhvZFxuICogaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi02LjYuMlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcCwgb3B0cykge1xuICAgIG1vZC52YWxpZGF0ZUZpZWxkKEZwKTtcbiAgICBpZiAoIUZwLmlzVmFsaWQob3B0cy5BKSB8fCAhRnAuaXNWYWxpZChvcHRzLkIpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuWikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZVNpbXBsZVNXVTogaW52YWxpZCBvcHRzJyk7XG4gICAgY29uc3Qgc3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW8oRnAsIG9wdHMuWik7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcC5pc09kZCBpcyBub3QgaW1wbGVtZW50ZWQhJyk7XG4gICAgLy8gSW5wdXQ6IHUsIGFuIGVsZW1lbnQgb2YgRi5cbiAgICAvLyBPdXRwdXQ6ICh4LCB5KSwgYSBwb2ludCBvbiBFLlxuICAgIHJldHVybiAodSkgPT4ge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IHR2MSwgdHYyLCB0djMsIHR2NCwgdHY1LCB0djYsIHgsIHk7XG4gICAgICAgIHR2MSA9IEZwLnNxcih1KTsgLy8gMS4gIHR2MSA9IHVeMlxuICAgICAgICB0djEgPSBGcC5tdWwodHYxLCBvcHRzLlopOyAvLyAyLiAgdHYxID0gWiAqIHR2MVxuICAgICAgICB0djIgPSBGcC5zcXIodHYxKTsgLy8gMy4gIHR2MiA9IHR2MV4yXG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2MSk7IC8vIDQuICB0djIgPSB0djIgKyB0djFcbiAgICAgICAgdHYzID0gRnAuYWRkKHR2MiwgRnAuT05FKTsgLy8gNS4gIHR2MyA9IHR2MiArIDFcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgb3B0cy5CKTsgLy8gNi4gIHR2MyA9IEIgKiB0djNcbiAgICAgICAgdHY0ID0gRnAuY21vdihvcHRzLlosIEZwLm5lZyh0djIpLCAhRnAuZXFsKHR2MiwgRnAuWkVSTykpOyAvLyA3LiAgdHY0ID0gQ01PVihaLCAtdHYyLCB0djIgIT0gMClcbiAgICAgICAgdHY0ID0gRnAubXVsKHR2NCwgb3B0cy5BKTsgLy8gOC4gIHR2NCA9IEEgKiB0djRcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2Myk7IC8vIDkuICB0djIgPSB0djNeMlxuICAgICAgICB0djYgPSBGcC5zcXIodHY0KTsgLy8gMTAuIHR2NiA9IHR2NF4yXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQSk7IC8vIDExLiB0djUgPSBBICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDEyLiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gMTMuIHR2MiA9IHR2MiAqIHR2M1xuICAgICAgICB0djYgPSBGcC5tdWwodHY2LCB0djQpOyAvLyAxNC4gdHY2ID0gdHY2ICogdHY0XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQik7IC8vIDE1LiB0djUgPSBCICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDE2LiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgeCA9IEZwLm11bCh0djEsIHR2Myk7IC8vIDE3LiAgIHggPSB0djEgKiB0djNcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZSB9ID0gc3FydFJhdGlvKHR2MiwgdHY2KTsgLy8gMTguIChpc19neDFfc3F1YXJlLCB5MSkgPSBzcXJ0X3JhdGlvKHR2MiwgdHY2KVxuICAgICAgICB5ID0gRnAubXVsKHR2MSwgdSk7IC8vIDE5LiAgIHkgPSB0djEgKiB1ICAtPiBaICogdV4zICogeTFcbiAgICAgICAgeSA9IEZwLm11bCh5LCB2YWx1ZSk7IC8vIDIwLiAgIHkgPSB5ICogeTFcbiAgICAgICAgeCA9IEZwLmNtb3YoeCwgdHYzLCBpc1ZhbGlkKTsgLy8gMjEuICAgeCA9IENNT1YoeCwgdHYzLCBpc19neDFfc3F1YXJlKVxuICAgICAgICB5ID0gRnAuY21vdih5LCB2YWx1ZSwgaXNWYWxpZCk7IC8vIDIyLiAgIHkgPSBDTU9WKHksIHkxLCBpc19neDFfc3F1YXJlKVxuICAgICAgICBjb25zdCBlMSA9IEZwLmlzT2RkKHUpID09PSBGcC5pc09kZCh5KTsgLy8gMjMuICBlMSA9IHNnbjAodSkgPT0gc2duMCh5KVxuICAgICAgICB5ID0gRnAuY21vdihGcC5uZWcoeSksIHksIGUxKTsgLy8gMjQuICAgeSA9IENNT1YoLXksIHksIGUxKVxuICAgICAgICB4ID0gRnAuZGl2KHgsIHR2NCk7IC8vIDI1LiAgIHggPSB4IC8gdHY0XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2VpZXJzdHJhc3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x  p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('signature', signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!fe(r))\n            return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n        bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n        taggedHash,\n        mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vc2VjcDI1NmsxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDOEM7QUFDSTtBQUNPO0FBQ087QUFDaUM7QUFDMUI7QUFDdEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyxnQkFBZ0IsMERBQUk7QUFDcEIsZ0JBQWdCLDBEQUFJO0FBQ3BCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixrQkFBa0IsMERBQUk7QUFDdEIsa0JBQWtCLDBEQUFJO0FBQ3RCLGtCQUFrQiwwREFBSTtBQUN0QixnQkFBZ0IsMERBQUk7QUFDcEIsZ0JBQWdCLDBEQUFJO0FBQ3BCLGlCQUFpQiwwREFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkRBQUsscUNBQXFDLGVBQWU7QUFDN0Qsa0JBQWtCLDZEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBLHFCQUFxQix5REFBRztBQUN4QixxQkFBcUIseURBQUc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQyxFQUFFLHdEQUFNO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNERBQU07QUFDM0IsZUFBZSwrREFBVztBQUMxQjtBQUNBO0FBQ0EsV0FBVyw0REFBTSxDQUFDLCtEQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtRUFBZTtBQUN2QyxvQkFBb0IseURBQUc7QUFDdkIsb0JBQW9CLHlEQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esd0NBQXdDO0FBQ3hDLHdCQUF3QjtBQUN4QjtBQUNBLHNCQUFzQjtBQUN0QixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdFQUFXO0FBQy9ELGNBQWMsK0RBQVc7QUFDekIsWUFBWSx1QkFBdUIsbUNBQW1DO0FBQ3RFLGNBQWMsK0RBQVcsMEJBQTBCO0FBQ25ELDJCQUEyQixtRUFBZSxpQ0FBaUM7QUFDM0Usd0RBQXdEO0FBQ3hELG9CQUFvQixtRUFBZSxTQUFTO0FBQzVDO0FBQ0EsbURBQW1EO0FBQ25ELFlBQVksdUJBQXVCLDJCQUEyQjtBQUM5RCxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBVztBQUMzQixjQUFjLCtEQUFXO0FBQ3pCLGdCQUFnQiwrREFBVztBQUMzQjtBQUNBLHlCQUF5QixtRUFBZSxRQUFRLHdCQUF3QjtBQUN4RSxrQkFBa0IsbUVBQWUsdUJBQXVCLDJCQUEyQjtBQUNuRjtBQUNBO0FBQ0Esa0JBQWtCLG1FQUFlLHdCQUF3Qiw0QkFBNEI7QUFDckY7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCwyQ0FBMkM7QUFDM0M7QUFDQSwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBLFdBQVc7QUFDWCxLQUFLO0FBQ0wsQ0FBQztBQUNELHNDQUFzQyxzRUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2RUFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyx3RUFBWTtBQUMvQyxZQUFZLE9BQU87QUFDbkI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3REFBTTtBQUNoQixDQUFDO0FBQ007QUFDQTtBQUNQIiwic291cmNlcyI6WyIvVXNlcnMvcGFibG9mZXJuYW5kZXovdGVzdDEyMy9URU5FWC1wZmttYzkvbWFpbi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vc2VjcDI1NmsxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyBGaWVsZCwgbW9kLCBwb3cyIH0gZnJvbSAnLi9hYnN0cmFjdC9tb2R1bGFyLmpzJztcbmltcG9ydCB7IG1hcFRvQ3VydmVTaW1wbGVTV1UgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbmltcG9ydCB7IGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBudW1iZXJUb0J5dGVzQkUgfSBmcm9tICcuL2Fic3RyYWN0L3V0aWxzLmpzJztcbmltcG9ydCB7IGNyZWF0ZUhhc2hlciwgaXNvZ2VueU1hcCB9IGZyb20gJy4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDdXJ2ZSB9IGZyb20gJy4vX3Nob3J0d191dGlscy5qcyc7XG5jb25zdCBzZWNwMjU2azFQID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnKTtcbmNvbnN0IHNlY3AyNTZrMU4gPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScpO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgZGl2TmVhcmVzdCA9IChhLCBiKSA9PiAoYSArIGIgLyBfMm4pIC8gYjtcbi8qKlxuICog4oiabiA9IG5eKChwKzEpLzQpIGZvciBmaWVsZHMgcCA9IDMgbW9kIDQuIFdlIHVud3JhcCB0aGUgbG9vcCBhbmQgbXVsdGlwbHkgYml0LWJ5LWJpdC5cbiAqIChQKzFuLzRuKS50b1N0cmluZygyKSB3b3VsZCBwcm9kdWNlIGJpdHMgWzIyM3ggMSwgMCwgMjJ4IDEsIDR4IDAsIDExLCAwMF1cbiAqL1xuZnVuY3Rpb24gc3FydE1vZCh5KSB7XG4gICAgY29uc3QgUCA9IHNlY3AyNTZrMVA7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzNuID0gQmlnSW50KDMpLCBfNm4gPSBCaWdJbnQoNiksIF8xMW4gPSBCaWdJbnQoMTEpLCBfMjJuID0gQmlnSW50KDIyKTtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfMjNuID0gQmlnSW50KDIzKSwgXzQ0biA9IEJpZ0ludCg0NCksIF84OG4gPSBCaWdJbnQoODgpO1xuICAgIGNvbnN0IGIyID0gKHkgKiB5ICogeSkgJSBQOyAvLyB4XjMsIDExXG4gICAgY29uc3QgYjMgPSAoYjIgKiBiMiAqIHkpICUgUDsgLy8geF43XG4gICAgY29uc3QgYjYgPSAocG93MihiMywgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjkgPSAocG93MihiNiwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjExID0gKHBvdzIoYjksIF8ybiwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IGIyMiA9IChwb3cyKGIxMSwgXzExbiwgUCkgKiBiMTEpICUgUDtcbiAgICBjb25zdCBiNDQgPSAocG93MihiMjIsIF8yMm4sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgYjg4ID0gKHBvdzIoYjQ0LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIxNzYgPSAocG93MihiODgsIF84OG4sIFApICogYjg4KSAlIFA7XG4gICAgY29uc3QgYjIyMCA9IChwb3cyKGIxNzYsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjIyMyA9IChwb3cyKGIyMjAsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IHQxID0gKHBvdzIoYjIyMywgXzIzbiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCB0MiA9IChwb3cyKHQxLCBfNm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCByb290ID0gcG93Mih0MiwgXzJuLCBQKTtcbiAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG5jb25zdCBGcCA9IEZpZWxkKHNlY3AyNTZrMVAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IHNxcnQ6IHNxcnRNb2QgfSk7XG5leHBvcnQgY29uc3Qgc2VjcDI1NmsxID0gY3JlYXRlQ3VydmUoe1xuICAgIGE6IEJpZ0ludCgwKSxcbiAgICBiOiBCaWdJbnQoNyksXG4gICAgRnAsXG4gICAgbjogc2VjcDI1NmsxTixcbiAgICAvLyBCYXNlIHBvaW50ICh4LCB5KSBha2EgZ2VuZXJhdG9yIHBvaW50XG4gICAgR3g6IEJpZ0ludCgnNTUwNjYyNjMwMjIyNzczNDM2Njk1Nzg3MTg4OTUxNjg1MzQzMjYyNTA2MDM0NTM3Nzc1OTQxNzU1MDAxODczNjAzODkxMTY3MjkyNDAnKSxcbiAgICBHeTogQmlnSW50KCczMjY3MDUxMDAyMDc1ODgxNjk3ODA4MzA4NTEzMDUwNzA0MzE4NDQ3MTI3MzM4MDY1OTI0MzI3NTkzODkwNDMzNTc1NzMzNzQ4MjQyNCcpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBsb3dTOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIHNlY3AyNTZrMSBiZWxvbmdzIHRvIEtvYmxpdHogY3VydmVzOiBpdCBoYXMgZWZmaWNpZW50bHkgY29tcHV0YWJsZSBlbmRvbW9ycGhpc20uXG4gICAgICogRW5kb21vcnBoaXNtIHVzZXMgMnggbGVzcyBSQU0sIHNwZWVkcyB1cCBwcmVjb21wdXRhdGlvbiBieSAyeCBhbmQgRUNESCAvIGtleSByZWNvdmVyeSBieSAyMCUuXG4gICAgICogRm9yIHByZWNvbXB1dGVkIHdOQUYgaXQgdHJhZGVzIG9mZiAxLzIgaW5pdCB0aW1lICYgMS8zIHJhbSBmb3IgMjAlIHBlcmYgaGl0LlxuICAgICAqIEV4cGxhbmF0aW9uOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsbWlsbHIvZWI2NzA4MDY3OTNlODRkZjYyOGE3YzQzNGE4NzMwNjZcbiAgICAgKi9cbiAgICBlbmRvOiB7XG4gICAgICAgIGJldGE6IEJpZ0ludCgnMHg3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyksXG4gICAgICAgIHNwbGl0U2NhbGFyOiAoaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbiA9IHNlY3AyNTZrMU47XG4gICAgICAgICAgICBjb25zdCBhMSA9IEJpZ0ludCgnMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScpO1xuICAgICAgICAgICAgY29uc3QgYjEgPSAtXzFuICogQmlnSW50KCcweGU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJyk7XG4gICAgICAgICAgICBjb25zdCBhMiA9IEJpZ0ludCgnMHgxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDgnKTtcbiAgICAgICAgICAgIGNvbnN0IGIyID0gYTE7XG4gICAgICAgICAgICBjb25zdCBQT1dfMl8xMjggPSBCaWdJbnQoJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7IC8vICgybioqMTI4bikudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICBjb25zdCBjMSA9IGRpdk5lYXJlc3QoYjIgKiBrLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gZGl2TmVhcmVzdCgtYjEgKiBrLCBuKTtcbiAgICAgICAgICAgIGxldCBrMSA9IG1vZChrIC0gYzEgKiBhMSAtIGMyICogYTIsIG4pO1xuICAgICAgICAgICAgbGV0IGsyID0gbW9kKC1jMSAqIGIxIC0gYzIgKiBiMiwgbik7XG4gICAgICAgICAgICBjb25zdCBrMW5lZyA9IGsxID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgY29uc3QgazJuZWcgPSBrMiA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMSA9IG4gLSBrMTtcbiAgICAgICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgICAgICBrMiA9IG4gLSBrMjtcbiAgICAgICAgICAgIGlmIChrMSA+IFBPV18yXzEyOCB8fCBrMiA+IFBPV18yXzEyOCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXRTY2FsYXI6IEVuZG9tb3JwaGlzbSBmYWlsZWQsIGs9JyArIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgazFuZWcsIGsxLCBrMm5lZywgazIgfTtcbiAgICAgICAgfSxcbiAgICB9LFxufSwgc2hhMjU2KTtcbi8vIFNjaG5vcnIgc2lnbmF0dXJlcyBhcmUgc3VwZXJpb3IgdG8gRUNEU0EgZnJvbSBhYm92ZS4gQmVsb3cgaXMgU2Nobm9yci1zcGVjaWZpYyBCSVAwMzQwIGNvZGUuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQwLm1lZGlhd2lraVxuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgZmUgPSAoeCkgPT4gdHlwZW9mIHggPT09ICdiaWdpbnQnICYmIF8wbiA8IHggJiYgeCA8IHNlY3AyNTZrMVA7XG5jb25zdCBnZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxTjtcbi8qKiBBbiBvYmplY3QgbWFwcGluZyB0YWdzIHRvIHRoZWlyIHRhZ2dlZCBoYXNoIHByZWZpeCBvZiBbU0hBMjU2KHRhZykgfCBTSEEyNTYodGFnKV0gKi9cbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5mdW5jdGlvbiB0YWdnZWRIYXNoKHRhZywgLi4ubWVzc2FnZXMpIHtcbiAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YWdIID0gc2hhMjU2KFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgdGFnUCA9IGNvbmNhdEJ5dGVzKHRhZ0gsIHRhZ0gpO1xuICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICB9XG4gICAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuLy8gRUNEU0EgY29tcGFjdCBwb2ludHMgYXJlIDMzLWJ5dGUuIFNjaG5vcnIgaXMgMzI6IHdlIHN0cmlwIGZpcnN0IGJ5dGUgMHgwMiBvciAweDAzXG5jb25zdCBwb2ludFRvQnl0ZXMgPSAocG9pbnQpID0+IHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG5jb25zdCBudW1UbzMyYiA9IChuKSA9PiBudW1iZXJUb0J5dGVzQkUobiwgMzIpO1xuY29uc3QgbW9kUCA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxUCk7XG5jb25zdCBtb2ROID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFOKTtcbmNvbnN0IFBvaW50ID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludDtcbmNvbnN0IEdtdWxBZGQgPSAoUSwgYSwgYikgPT4gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKTtcbi8vIENhbGN1bGF0ZSBwb2ludCwgc2NhbGFyIGFuZCBieXRlc1xuZnVuY3Rpb24gc2Nobm9yckdldEV4dFB1YktleShwcml2KSB7XG4gICAgbGV0IGRfID0gc2VjcDI1NmsxLnV0aWxzLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdik7IC8vIHNhbWUgbWV0aG9kIGV4ZWN1dGVkIGluIGZyb21Qcml2YXRlS2V5XG4gICAgbGV0IHAgPSBQb2ludC5mcm9tUHJpdmF0ZUtleShkXyk7IC8vIFAgPSBkJ+KLhUc7IDAgPCBkJyA8IG4gY2hlY2sgaXMgZG9uZSBpbnNpZGVcbiAgICBjb25zdCBzY2FsYXIgPSBwLmhhc0V2ZW5ZKCkgPyBkXyA6IG1vZE4oLWRfKTtcbiAgICByZXR1cm4geyBzY2FsYXI6IHNjYWxhciwgYnl0ZXM6IHBvaW50VG9CeXRlcyhwKSB9O1xufVxuLyoqXG4gKiBsaWZ0X3ggZnJvbSBCSVAzNDAuIENvbnZlcnQgMzItYnl0ZSB4IGNvb3JkaW5hdGUgdG8gZWxsaXB0aWMgY3VydmUgcG9pbnQuXG4gKiBAcmV0dXJucyB2YWxpZCBwb2ludCBjaGVja2VkIGZvciBiZWluZyBvbi1jdXJ2ZVxuICovXG5mdW5jdGlvbiBsaWZ0X3goeCkge1xuICAgIGlmICghZmUoeCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHg6IG5lZWQgMCA8IHggPCBwJyk7IC8vIEZhaWwgaWYgeCDiiaUgcC5cbiAgICBjb25zdCB4eCA9IG1vZFAoeCAqIHgpO1xuICAgIGNvbnN0IGMgPSBtb2RQKHh4ICogeCArIEJpZ0ludCg3KSk7IC8vIExldCBjID0geMKzICsgNyBtb2QgcC5cbiAgICBsZXQgeSA9IHNxcnRNb2QoYyk7IC8vIExldCB5ID0gY14ocCsxKS80IG1vZCBwLlxuICAgIGlmICh5ICUgXzJuICE9PSBfMG4pXG4gICAgICAgIHkgPSBtb2RQKC15KTsgLy8gUmV0dXJuIHRoZSB1bmlxdWUgcG9pbnQgUCBzdWNoIHRoYXQgeChQKSA9IHggYW5kXG4gICAgY29uc3QgcCA9IG5ldyBQb2ludCh4LCB5LCBfMW4pOyAvLyB5KFApID0geSBpZiB5IG1vZCAyID0gMCBvciB5KFApID0gcC15IG90aGVyd2lzZS5cbiAgICBwLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIENyZWF0ZSB0YWdnZWQgaGFzaCwgY29udmVydCBpdCB0byBiaWdpbnQsIHJlZHVjZSBtb2R1bG8tbi5cbiAqL1xuZnVuY3Rpb24gY2hhbGxlbmdlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbW9kTihieXRlc1RvTnVtYmVyQkUodGFnZ2VkSGFzaCgnQklQMDM0MC9jaGFsbGVuZ2UnLCAuLi5hcmdzKSkpO1xufVxuLyoqXG4gKiBTY2hub3JyIHB1YmxpYyBrZXkgaXMganVzdCBgeGAgY29vcmRpbmF0ZSBvZiBQb2ludCBhcyBwZXIgQklQMzQwLlxuICovXG5mdW5jdGlvbiBzY2hub3JyR2V0UHVibGljS2V5KHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KS5ieXRlczsgLy8gZCc9aW50KHNrKS4gRmFpbCBpZiBkJz0wIG9yIGQn4omlbi4gUmV0IGJ5dGVzKGQn4ouFRylcbn1cbi8qKlxuICogQ3JlYXRlcyBTY2hub3JyIHNpZ25hdHVyZSBhcyBwZXIgQklQMzQwLiBWZXJpZmllcyBpdHNlbGYgYmVmb3JlIHJldHVybmluZyBhbnl0aGluZy5cbiAqIGF1eFJhbmQgaXMgb3B0aW9uYWwgYW5kIGlzIG5vdCB0aGUgc29sZSBzb3VyY2Ugb2YgayBnZW5lcmF0aW9uOiBiYWQgQ1NQUk5HIHdvbid0IGJlIGRhbmdlcm91cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgYXV4UmFuZCA9IHJhbmRvbUJ5dGVzKDMyKSkge1xuICAgIGNvbnN0IG0gPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgIGNvbnN0IHsgYnl0ZXM6IHB4LCBzY2FsYXI6IGQgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSk7IC8vIGNoZWNrcyBmb3IgaXNXaXRoaW5DdXJ2ZU9yZGVyXG4gICAgY29uc3QgYSA9IGVuc3VyZUJ5dGVzKCdhdXhSYW5kJywgYXV4UmFuZCwgMzIpOyAvLyBBdXhpbGlhcnkgcmFuZG9tIGRhdGEgYTogYSAzMi1ieXRlIGFycmF5XG4gICAgY29uc3QgdCA9IG51bVRvMzJiKGQgXiBieXRlc1RvTnVtYmVyQkUodGFnZ2VkSGFzaCgnQklQMDM0MC9hdXgnLCBhKSkpOyAvLyBMZXQgdCBiZSB0aGUgYnl0ZS13aXNlIHhvciBvZiBieXRlcyhkKSBhbmQgaGFzaC9hdXgoYSlcbiAgICBjb25zdCByYW5kID0gdGFnZ2VkSGFzaCgnQklQMDM0MC9ub25jZScsIHQsIHB4LCBtKTsgLy8gTGV0IHJhbmQgPSBoYXNoL25vbmNlKHQgfHwgYnl0ZXMoUCkgfHwgbSlcbiAgICBjb25zdCBrXyA9IG1vZE4oYnl0ZXNUb051bWJlckJFKHJhbmQpKTsgLy8gTGV0IGsnID0gaW50KHJhbmQpIG1vZCBuXG4gICAgaWYgKGtfID09PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbiBmYWlsZWQ6IGsgaXMgemVybycpOyAvLyBGYWlsIGlmIGsnID0gMC5cbiAgICBjb25zdCB7IGJ5dGVzOiByeCwgc2NhbGFyOiBrIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KGtfKTsgLy8gTGV0IFIgPSBrJ+KLhUcuXG4gICAgY29uc3QgZSA9IGNoYWxsZW5nZShyeCwgcHgsIG0pOyAvLyBMZXQgZSA9IGludChoYXNoL2NoYWxsZW5nZShieXRlcyhSKSB8fCBieXRlcyhQKSB8fCBtKSkgbW9kIG4uXG4gICAgY29uc3Qgc2lnID0gbmV3IFVpbnQ4QXJyYXkoNjQpOyAvLyBMZXQgc2lnID0gYnl0ZXMoUikgfHwgYnl0ZXMoKGsgKyBlZCkgbW9kIG4pLlxuICAgIHNpZy5zZXQocngsIDApO1xuICAgIHNpZy5zZXQobnVtVG8zMmIobW9kTihrICsgZSAqIGQpKSwgMzIpO1xuICAgIC8vIElmIFZlcmlmeShieXRlcyhQKSwgbSwgc2lnKSAoc2VlIGJlbG93KSByZXR1cm5zIGZhaWx1cmUsIGFib3J0XG4gICAgaWYgKCFzY2hub3JyVmVyaWZ5KHNpZywgbSwgcHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ246IEludmFsaWQgc2lnbmF0dXJlIHByb2R1Y2VkJyk7XG4gICAgcmV0dXJuIHNpZztcbn1cbi8qKlxuICogVmVyaWZpZXMgU2Nobm9yciBzaWduYXR1cmUuXG4gKiBXaWxsIHN3YWxsb3cgZXJyb3JzICYgcmV0dXJuIGZhbHNlIGV4Y2VwdCBmb3IgaW5pdGlhbCB0eXBlIHZhbGlkYXRpb24gb2YgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgY29uc3Qgc2lnID0gZW5zdXJlQnl0ZXMoJ3NpZ25hdHVyZScsIHNpZ25hdHVyZSwgNjQpO1xuICAgIGNvbnN0IG0gPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgIGNvbnN0IHB1YiA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXksIDMyKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBQID0gbGlmdF94KGJ5dGVzVG9OdW1iZXJCRShwdWIpKTsgLy8gUCA9IGxpZnRfeChpbnQocGspKTsgZmFpbCBpZiB0aGF0IGZhaWxzXG4gICAgICAgIGNvbnN0IHIgPSBieXRlc1RvTnVtYmVyQkUoc2lnLnN1YmFycmF5KDAsIDMyKSk7IC8vIExldCByID0gaW50KHNpZ1swOjMyXSk7IGZhaWwgaWYgciDiiaUgcC5cbiAgICAgICAgaWYgKCFmZShyKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgcyA9IGJ5dGVzVG9OdW1iZXJCRShzaWcuc3ViYXJyYXkoMzIsIDY0KSk7IC8vIExldCBzID0gaW50KHNpZ1szMjo2NF0pOyBmYWlsIGlmIHMg4omlIG4uXG4gICAgICAgIGlmICghZ2UocykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UobnVtVG8zMmIociksIHBvaW50VG9CeXRlcyhQKSwgbSk7IC8vIGludChjaGFsbGVuZ2UoYnl0ZXMocil8fGJ5dGVzKFApfHxtKSklblxuICAgICAgICBjb25zdCBSID0gR211bEFkZChQLCBzLCBtb2ROKC1lKSk7IC8vIFIgPSBz4ouFRyAtIGXii4VQXG4gICAgICAgIGlmICghUiB8fCAhUi5oYXNFdmVuWSgpIHx8IFIudG9BZmZpbmUoKS54ICE9PSByKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyAtZVAgPT0gKG4tZSlQXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBGYWlsIGlmIGlzX2luZmluaXRlKFIpIC8gbm90IGhhc19ldmVuX3koUikgLyB4KFIpIOKJoCByLlxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBzY2hub3JyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoe1xuICAgIGdldFB1YmxpY0tleTogc2Nobm9yckdldFB1YmxpY0tleSxcbiAgICBzaWduOiBzY2hub3JyU2lnbixcbiAgICB2ZXJpZnk6IHNjaG5vcnJWZXJpZnksXG4gICAgdXRpbHM6IHtcbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogc2VjcDI1NmsxLnV0aWxzLnJhbmRvbVByaXZhdGVLZXksXG4gICAgICAgIGxpZnRfeCxcbiAgICAgICAgcG9pbnRUb0J5dGVzLFxuICAgICAgICBudW1iZXJUb0J5dGVzQkUsXG4gICAgICAgIGJ5dGVzVG9OdW1iZXJCRSxcbiAgICAgICAgdGFnZ2VkSGFzaCxcbiAgICAgICAgbW9kLFxuICAgIH0sXG59KSkoKTtcbmNvbnN0IGlzb01hcCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaXNvZ2VueU1hcChGcCwgW1xuICAgIC8vIHhOdW1cbiAgICBbXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4YzcnLFxuICAgICAgICAnMHg3ZDNkNGM4MGJjMzIxZDViOWYzMTVjZWE3ZmQ0NGM1ZDU5NWQyZmMwYmY2M2I5MmRmZmYxMDQ0ZjE3YzY1ODEnLFxuICAgICAgICAnMHg1MzRjMzI4ZDIzZjIzNGU2ZTJhNDEzZGVjYTI1Y2FlY2U0NTA2MTQ0MDM3YzQwMzE0ZWNiZDBiNTNkOWRkMjYyJyxcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYTg4YycsXG4gICAgXSxcbiAgICAvLyB4RGVuXG4gICAgW1xuICAgICAgICAnMHhkMzU3NzExOTNkOTQ5MThhOWNhMzRjY2JiN2I2NDBkZDg2Y2Q0MDk1NDJmODQ4N2Q5ZmU2Yjc0NTc4MWViNDliJyxcbiAgICAgICAgJzB4ZWRhZGM2ZjY0MzgzZGMxZGY3YzRiMmQ1MWI1NDIyNTQwNmQzNmI2NDFmNWU0MWJiYzUyYTU2NjEyYThjNmQxNCcsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuICAgIC8vIHlOdW1cbiAgICBbXG4gICAgICAgICcweDRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiOGUzOGUyM2MnLFxuICAgICAgICAnMHhjNzVlMGMzMmQ1Y2I3YzBmYTlkMGE1NGIxMmEwYTZkNTY0N2FiMDQ2ZDY4NmRhNmZkZmZjOTBmYzIwMWQ3MWEzJyxcbiAgICAgICAgJzB4MjlhNjE5NDY5MWY5MWE3MzcxNTIwOWVmNjUxMmU1NzY3MjI4MzBhMjAxYmUyMDE4YTc2NWU4NWE5ZWNlZTkzMScsXG4gICAgICAgICcweDJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmMzhlMzhkODQnLFxuICAgIF0sXG4gICAgLy8geURlblxuICAgIFtcbiAgICAgICAgJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZjkzYicsXG4gICAgICAgICcweDdhMDY1MzRiYjhiZGI0OWZkNWU5ZTY2MzI3MjJjMjk4OTQ2N2MxYmZjOGU4ZDk3OGRmYjQyNWQyNjg1YzI1NzMnLFxuICAgICAgICAnMHg2NDg0YWE3MTY1NDVjYTJjZjNhNzBjM2ZhOGZlMzM3ZTBhM2QyMTE2MmYwZDYyOTlhN2JmODE5MmJmZDJhNzZmJyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG5dLm1hcCgoaSkgPT4gaS5tYXAoKGopID0+IEJpZ0ludChqKSkpKSkoKTtcbmNvbnN0IG1hcFNXVSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcCwge1xuICAgIEE6IEJpZ0ludCgnMHgzZjg3MzFhYmRkNjYxYWRjYTA4YTU1NThmMGY1ZDI3MmU5NTNkMzYzY2I2ZjBlNWQ0MDU0NDdjMDFhNDQ0NTMzJyksXG4gICAgQjogQmlnSW50KCcxNzcxJyksXG4gICAgWjogRnAuY3JlYXRlKEJpZ0ludCgnLTExJykpLFxufSkpKCk7XG5jb25zdCBodGYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gbWFwU1dVKEZwLmNyZWF0ZShzY2FsYXJzWzBdKSk7XG4gICAgcmV0dXJuIGlzb01hcCh4LCB5KTtcbn0sIHtcbiAgICBEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9ST18nLFxuICAgIGVuY29kZURTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX05VXycsXG4gICAgcDogRnAuT1JERVIsXG4gICAgbTogMSxcbiAgICBrOiAxMjgsXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICBoYXNoOiBzaGEyNTYsXG59KSkoKTtcbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmhhc2hUb0N1cnZlKSgpO1xuZXhwb3J0IGNvbnN0IGVuY29kZVRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5lbmNvZGVUb0N1cnZlKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxrQkFBa0IsU0FBUztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNxRDtBQUNyRCxpQkFBaUI7QUFDakIsaUVBQWUsTUFBTSxFQUFDO0FBQ3RCIiwic291cmNlcyI6WyIvVXNlcnMvcGFibG9mZXJuYW5kZXovdGVzdDEyMy9URU5FWC1wZmttYzkvbWFpbi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmZ1bmN0aW9uIGhhc2goaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydCB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThDO0FBQ1M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1CQUFtQiwyQ0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFVO0FBQzlCO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsZ0JBQWdCLHlCQUF5QjtBQUN6QyxlQUFlLGtEQUFPO0FBQ3RCO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFEQUFVO0FBQzNDLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQyxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFibG9mZXJuYW5kZXovdGVzdDEyMy9URU5FWC1wZmttYzkvbWFpbi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhpc3RzLCBvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgY3JlYXRlVmlldywgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5leHBvcnQgY2xhc3MgU0hBMiBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3NoYTIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!******************************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \******************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === 'object' && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNrQztBQUMzQixlQUFlLDJNQUFFLFdBQVcsMk1BQUUsaUJBQWlCLDBOQUFpQixHQUFHLGtEQUFZO0FBQ3RGIiwic291cmNlcyI6WyIvVXNlcnMvcGFibG9mZXJuYW5kZXovdGVzdDEyMy9URU5FWC1wZmttYzkvbWFpbi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIFNlZSB1dGlscy50cyBmb3IgZGV0YWlscy5cbi8vIFRoZSBmaWxlIHdpbGwgdGhyb3cgb24gbm9kZS5qcyAxNCBhbmQgZWFybGllci5cbi8vIEB0cy1pZ25vcmVcbmltcG9ydCAqIGFzIG5jIGZyb20gJ25vZGU6Y3J5cHRvJztcbmV4cG9ydCBjb25zdCBjcnlwdG8gPSBuYyAmJiB0eXBlb2YgbmMgPT09ICdvYmplY3QnICYmICd3ZWJjcnlwdG8nIGluIG5jID8gbmMud2ViY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvTm9kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdHO0FBQ3JEO0FBQzNDO0FBQ08sbUJBQW1CLDJDQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBVTtBQUNsQixvQkFBb0Isa0RBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQVk7QUFDcEIsUUFBUSxpREFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxnQkFBZ0IseURBQXlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhYmxvZmVybmFuZGV6L3Rlc3QxMjMvVEVORVgtcGZrbWM5L21haW4vbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay1jYWNoZS1kZXhpZS9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzaCBhcyBhc3NlcnRIYXNoLCBieXRlcyBhcyBhc3NlcnRCeXRlcywgZXhpc3RzIGFzIGFzc2VydEV4aXN0cyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBITUFDIChSRkMgMjEwNClcbmV4cG9ydCBjbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFzc2VydEhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgICAgICBhc3NlcnRCeXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0M7QUFDaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBDQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDLHdCQUF3QixRQUFRO0FBQ2hDLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQ7QUFDQSwyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQiwwREFBZTtBQUM5QywrQkFBK0IsMERBQWU7QUFDckQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYWJsb2Zlcm5hbmRlei90ZXN0MTIzL1RFTkVYLXBma21jOS9tYWluL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGstY2FjaGUtZGV4aWUvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHsgcm90ciwgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBTSEEyLTI1NiBuZWVkIHRvIHRyeSAyXjEyOCBoYXNoZXMgdG8gZXhlY3V0ZSBiaXJ0aGRheSBhdHRhY2suXG4vLyBCVEMgbmV0d29yayBpcyBkb2luZyAyXjY3IGhhc2hlcy9zZWMgYXMgcGVyIGVhcmx5IDIwMjMuXG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgSVYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBJVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IElWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBJVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IElWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBJVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5BID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkMgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkYgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyNTYoKSk7XG5leHBvcnQgY29uc3Qgc2hhMjI0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMjU2LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhDO0FBQzlDO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDVDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxRQUFRLHdEQUFNLFdBQVcsd0RBQU07QUFDL0IsZUFBZSx3REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhYmxvZmVybmFuZGV6L3Rlc3QxMjMvVEVORVgtcGZrbWM5L21haW4vbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay1jYWNoZS1kZXhpZS9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuZXhwb3J0IGNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBpZiAoIXU4YShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBVaW50OEFycmF5LCBnb3QgJHt0eXBlb2YgZGF0YX1gKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmxlbmd0aCwgMCkpO1xuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gICAgYXJyYXlzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaWYgKCF1OGEoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByO1xufVxuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmV4cG9ydCBjbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmNvbnN0IHRvU3RyID0ge30udG9TdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiB0b1N0ci5jYWxsKG9wdHMpICE9PSAnW29iamVjdCBPYmplY3RdJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ087QUFDUDtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxrQkFBa0IsU0FBUztBQUM1RjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxNQUFNLEVBQUM7QUFDdEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYWJsb2Zlcm5hbmRlei90ZXN0MTIzL1RFTkVYLXBma21jOS9tYWluL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGstY2FjaGUtZGV4aWUvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke2J9YCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc2goaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuY29uc3QgYXNzZXJ0ID0ge1xuICAgIG51bWJlcixcbiAgICBib29sLFxuICAgIGJ5dGVzLFxuICAgIGhhc2gsXG4gICAgZXhpc3RzLFxuICAgIG91dHB1dCxcbn07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(this.buffer);\n    }\n    update(data) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtDO0FBQ3FCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBO0FBQ0EsUUFBUSx5REFBYTtBQUNyQixnQkFBZ0IseUJBQXlCO0FBQ3pDLGVBQWUsa0RBQU87QUFDdEI7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQVU7QUFDM0MsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQWE7QUFDckIsUUFBUSx5REFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxREFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFxRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhYmxvZmVybmFuZGV6L3Rlc3QxMjMvVEVORVgtcGZrbWM5L21haW4vbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay1jYWNoZS1kZXhpZS9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19zaGEyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIGNyZWF0ZVZpZXcsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBCYXNlIFNIQTIgY2xhc3MgKFJGQyA2MjM0KVxuZXhwb3J0IGNsYXNzIFNIQTIgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgYXNzZXJ0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYXNzZXJ0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgYXNzZXJ0Lm91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gY3JlYXRlVmlldyhvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaGEyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === 'object' && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNrQztBQUMzQixlQUFlLDJNQUFFLFdBQVcsMk1BQUUsaUJBQWlCLDBOQUFpQixHQUFHLGtEQUFZO0FBQ3RGIiwic291cmNlcyI6WyIvVXNlcnMvcGFibG9mZXJuYW5kZXovdGVzdDEyMy9URU5FWC1wZmttYzkvbWFpbi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIFNlZSB1dGlscy50cyBmb3IgZGV0YWlscy5cbi8vIFRoZSBmaWxlIHdpbGwgdGhyb3cgb24gbm9kZS5qcyAxNCBhbmQgZWFybGllci5cbi8vIEB0cy1pZ25vcmVcbmltcG9ydCAqIGFzIG5jIGZyb20gJ25vZGU6Y3J5cHRvJztcbmV4cG9ydCBjb25zdCBjcnlwdG8gPSBuYyAmJiB0eXBlb2YgbmMgPT09ICdvYmplY3QnICYmICd3ZWJjcnlwdG8nIGluIG5jID8gbmMud2ViY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvTm9kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   expand: () => (/* binding */ expand),\n/* harmony export */   extract: () => (/* binding */ extract),\n/* harmony export */   hkdf: () => (/* binding */ hkdf)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hmac.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js\");\n\n\n\n// HKDF (RFC 5869)\n// https://soatok.blog/2021/11/17/understanding-hkdf/\n/**\n * HKDF-Extract(IKM, salt) -> PRK\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash\n * @param ikm\n * @param salt\n * @returns\n */\nfunction extract(hash, ikm, salt) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n    // NOTE: some libraries treat zero-length array as 'not provided';\n    // we don't, since we have undefined as 'not provided'\n    // https://github.com/RustCrypto/KDFs/issues/15\n    if (salt === undefined)\n        salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros\n    return (0,_hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac)(hash, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(salt), (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(ikm));\n}\n// HKDF-Expand(PRK, info, L) -> OKM\nconst HKDF_COUNTER = new Uint8Array([0]);\nconst EMPTY_BUFFER = new Uint8Array();\n/**\n * HKDF-expand from the spec.\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in octets\n */\nfunction expand(hash, prk, info, length = 32) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(length);\n    if (length > 255 * hash.outputLen)\n        throw new Error('Length should be <= 255*HashLen');\n    const blocks = Math.ceil(length / hash.outputLen);\n    if (info === undefined)\n        info = EMPTY_BUFFER;\n    // first L(ength) octets of T\n    const okm = new Uint8Array(blocks * hash.outputLen);\n    // Re-use HMAC instance between blocks\n    const HMAC = _hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac.create(hash, prk);\n    const HMACTmp = HMAC._cloneInto();\n    const T = new Uint8Array(HMAC.outputLen);\n    for (let counter = 0; counter < blocks; counter++) {\n        HKDF_COUNTER[0] = counter + 1;\n        // T(0) = empty string (zero length)\n        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n            .update(info)\n            .update(HKDF_COUNTER)\n            .digestInto(T);\n        okm.set(T, hash.outputLen * counter);\n        HMAC._cloneInto(HMACTmp);\n    }\n    HMAC.destroy();\n    HMACTmp.destroy();\n    T.fill(0);\n    HKDF_COUNTER.fill(0);\n    return okm.slice(0, length);\n}\n/**\n * HKDF (RFC 5869): extract + expand in one step.\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information\n * @param length - length of output keying material in octets\n */\nconst hkdf = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);\n//# sourceMappingURL=hkdf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaGtkZi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBa0M7QUFDRztBQUNKO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLHVEQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsV0FBVyw4Q0FBSSxPQUFPLGtEQUFPLFFBQVEsa0RBQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksdURBQVc7QUFDZixJQUFJLHlEQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMENBQUk7QUFDckI7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiL1VzZXJzL3BhYmxvZmVybmFuZGV6L3Rlc3QxMjMvVEVORVgtcGZrbWM5L21haW4vbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay1jYWNoZS1kZXhpZS9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2hrZGYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gJy4vaG1hYy5qcyc7XG4vLyBIS0RGIChSRkMgNTg2OSlcbi8vIGh0dHBzOi8vc29hdG9rLmJsb2cvMjAyMS8xMS8xNy91bmRlcnN0YW5kaW5nLWhrZGYvXG4vKipcbiAqIEhLREYtRXh0cmFjdChJS00sIHNhbHQpIC0+IFBSS1xuICogQXJndW1lbnRzIHBvc2l0aW9uIGRpZmZlcnMgZnJvbSBzcGVjIChJS00gaXMgZmlyc3Qgb25lLCBzaW5jZSBpdCBpcyBub3Qgb3B0aW9uYWwpXG4gKiBAcGFyYW0gaGFzaFxuICogQHBhcmFtIGlrbVxuICogQHBhcmFtIHNhbHRcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0KGhhc2gsIGlrbSwgc2FsdCkge1xuICAgIGFzc2VydC5oYXNoKGhhc2gpO1xuICAgIC8vIE5PVEU6IHNvbWUgbGlicmFyaWVzIHRyZWF0IHplcm8tbGVuZ3RoIGFycmF5IGFzICdub3QgcHJvdmlkZWQnO1xuICAgIC8vIHdlIGRvbid0LCBzaW5jZSB3ZSBoYXZlIHVuZGVmaW5lZCBhcyAnbm90IHByb3ZpZGVkJ1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9SdXN0Q3J5cHRvL0tERnMvaXNzdWVzLzE1XG4gICAgaWYgKHNhbHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgc2FsdCA9IG5ldyBVaW50OEFycmF5KGhhc2gub3V0cHV0TGVuKTsgLy8gaWYgbm90IHByb3ZpZGVkLCBpdCBpcyBzZXQgdG8gYSBzdHJpbmcgb2YgSGFzaExlbiB6ZXJvc1xuICAgIHJldHVybiBobWFjKGhhc2gsIHRvQnl0ZXMoc2FsdCksIHRvQnl0ZXMoaWttKSk7XG59XG4vLyBIS0RGLUV4cGFuZChQUkssIGluZm8sIEwpIC0+IE9LTVxuY29uc3QgSEtERl9DT1VOVEVSID0gbmV3IFVpbnQ4QXJyYXkoWzBdKTtcbmNvbnN0IEVNUFRZX0JVRkZFUiA9IG5ldyBVaW50OEFycmF5KCk7XG4vKipcbiAqIEhLREYtZXhwYW5kIGZyb20gdGhlIHNwZWMuXG4gKiBAcGFyYW0gcHJrIC0gYSBwc2V1ZG9yYW5kb20ga2V5IG9mIGF0IGxlYXN0IEhhc2hMZW4gb2N0ZXRzICh1c3VhbGx5LCB0aGUgb3V0cHV0IGZyb20gdGhlIGV4dHJhY3Qgc3RlcClcbiAqIEBwYXJhbSBpbmZvIC0gb3B0aW9uYWwgY29udGV4dCBhbmQgYXBwbGljYXRpb24gc3BlY2lmaWMgaW5mb3JtYXRpb24gKGNhbiBiZSBhIHplcm8tbGVuZ3RoIHN0cmluZylcbiAqIEBwYXJhbSBsZW5ndGggLSBsZW5ndGggb2Ygb3V0cHV0IGtleWluZyBtYXRlcmlhbCBpbiBvY3RldHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZChoYXNoLCBwcmssIGluZm8sIGxlbmd0aCA9IDMyKSB7XG4gICAgYXNzZXJ0Lmhhc2goaGFzaCk7XG4gICAgYXNzZXJ0Lm51bWJlcihsZW5ndGgpO1xuICAgIGlmIChsZW5ndGggPiAyNTUgKiBoYXNoLm91dHB1dExlbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZW5ndGggc2hvdWxkIGJlIDw9IDI1NSpIYXNoTGVuJyk7XG4gICAgY29uc3QgYmxvY2tzID0gTWF0aC5jZWlsKGxlbmd0aCAvIGhhc2gub3V0cHV0TGVuKTtcbiAgICBpZiAoaW5mbyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBpbmZvID0gRU1QVFlfQlVGRkVSO1xuICAgIC8vIGZpcnN0IEwoZW5ndGgpIG9jdGV0cyBvZiBUXG4gICAgY29uc3Qgb2ttID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tzICogaGFzaC5vdXRwdXRMZW4pO1xuICAgIC8vIFJlLXVzZSBITUFDIGluc3RhbmNlIGJldHdlZW4gYmxvY2tzXG4gICAgY29uc3QgSE1BQyA9IGhtYWMuY3JlYXRlKGhhc2gsIHByayk7XG4gICAgY29uc3QgSE1BQ1RtcCA9IEhNQUMuX2Nsb25lSW50bygpO1xuICAgIGNvbnN0IFQgPSBuZXcgVWludDhBcnJheShITUFDLm91dHB1dExlbik7XG4gICAgZm9yIChsZXQgY291bnRlciA9IDA7IGNvdW50ZXIgPCBibG9ja3M7IGNvdW50ZXIrKykge1xuICAgICAgICBIS0RGX0NPVU5URVJbMF0gPSBjb3VudGVyICsgMTtcbiAgICAgICAgLy8gVCgwKSA9IGVtcHR5IHN0cmluZyAoemVybyBsZW5ndGgpXG4gICAgICAgIC8vIFQoTikgPSBITUFDLUhhc2goUFJLLCBUKE4tMSkgfCBpbmZvIHwgTilcbiAgICAgICAgSE1BQ1RtcC51cGRhdGUoY291bnRlciA9PT0gMCA/IEVNUFRZX0JVRkZFUiA6IFQpXG4gICAgICAgICAgICAudXBkYXRlKGluZm8pXG4gICAgICAgICAgICAudXBkYXRlKEhLREZfQ09VTlRFUilcbiAgICAgICAgICAgIC5kaWdlc3RJbnRvKFQpO1xuICAgICAgICBva20uc2V0KFQsIGhhc2gub3V0cHV0TGVuICogY291bnRlcik7XG4gICAgICAgIEhNQUMuX2Nsb25lSW50byhITUFDVG1wKTtcbiAgICB9XG4gICAgSE1BQy5kZXN0cm95KCk7XG4gICAgSE1BQ1RtcC5kZXN0cm95KCk7XG4gICAgVC5maWxsKDApO1xuICAgIEhLREZfQ09VTlRFUi5maWxsKDApO1xuICAgIHJldHVybiBva20uc2xpY2UoMCwgbGVuZ3RoKTtcbn1cbi8qKlxuICogSEtERiAoUkZDIDU4NjkpOiBleHRyYWN0ICsgZXhwYW5kIGluIG9uZSBzdGVwLlxuICogQHBhcmFtIGhhc2ggLSBoYXNoIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCAoZS5nLiBzaGEyNTYpXG4gKiBAcGFyYW0gaWttIC0gaW5wdXQga2V5aW5nIG1hdGVyaWFsLCB0aGUgaW5pdGlhbCBrZXlcbiAqIEBwYXJhbSBzYWx0IC0gb3B0aW9uYWwgc2FsdCB2YWx1ZSAoYSBub24tc2VjcmV0IHJhbmRvbSB2YWx1ZSlcbiAqIEBwYXJhbSBpbmZvIC0gb3B0aW9uYWwgY29udGV4dCBhbmQgYXBwbGljYXRpb24gc3BlY2lmaWMgaW5mb3JtYXRpb25cbiAqIEBwYXJhbSBsZW5ndGggLSBsZW5ndGggb2Ygb3V0cHV0IGtleWluZyBtYXRlcmlhbCBpbiBvY3RldHNcbiAqL1xuZXhwb3J0IGNvbnN0IGhrZGYgPSAoaGFzaCwgaWttLCBzYWx0LCBpbmZvLCBsZW5ndGgpID0+IGV4cGFuZChoYXNoLCBleHRyYWN0KGhhc2gsIGlrbSwgc2FsdCksIGluZm8sIGxlbmd0aCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oa2RmLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ1M7QUFDM0M7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFXO0FBQ25CLG9CQUFvQixrREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBYTtBQUNyQixRQUFRLHdEQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcGFibG9mZXJuYW5kZXovdGVzdDEyMy9URU5FWC1wZmttYzkvbWFpbi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBITUFDIChSRkMgMjEwNClcbmV4cG9ydCBjbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFzc2VydC5oYXNoKGhhc2gpO1xuICAgICAgICBjb25zdCBrZXkgPSB0b0J5dGVzKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIHBhZC5maWxsKDApO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgIGFzc2VydC5leGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBhc3NlcnQuYnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0M7QUFDaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUMsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsd0JBQXdCLFFBQVE7QUFDaEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRDtBQUNBLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZUFBZSwwREFBZTtBQUM5QixlQUFlLDBEQUFlO0FBQ3JDIiwic291cmNlcyI6WyIvVXNlcnMvcGFibG9mZXJuYW5kZXovdGVzdDEyMy9URU5FWC1wZmttYzkvbWFpbi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNIQTIgfSBmcm9tICcuL19zaGEyLmpzJztcbmltcG9ydCB7IHJvdHIsIHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5jb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgSVYgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IElWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBJVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IElWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBJVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IElWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gcm90cihXMTUsIDcpIF4gcm90cihXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSByb3RyKEUsIDYpIF4gcm90cihFLCAxMSkgXiByb3RyKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSByb3RyKEEsIDIpIF4gcm90cihBLCAxMykgXiByb3RyKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn1cbi8vIENvbnN0YW50cyBmcm9tIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGZcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyNTYoKSk7XG5leHBvcnQgY29uc3Qgc2hhMjI0ID0gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhDO0FBQzlDO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSx3REFBTSxXQUFXLHdEQUFNO0FBQy9CLGVBQWUsd0RBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYWJsb2Zlcm5hbmRlei90ZXN0MTIzL1RFTkVYLXBma21jOS9tYWluL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGstY2FjaGUtZGV4aWUvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQsIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBjb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnQgY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG4vLyBiaWctZW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGhhc2hlczpcbi8vIGVhcmx5LXRocm93IGFuIGVycm9yIGJlY2F1c2Ugd2UgZG9uJ3Qgc3VwcG9ydCBCRSB5ZXQuXG5leHBvcnQgY29uc3QgaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG5pZiAoIWlzTEUpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG5jb25zdCBoZXhlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAodiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBpZiAoIXU4YShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBVaW50OEFycmF5LCBnb3QgJHt0eXBlb2YgZGF0YX1gKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmxlbmd0aCwgMCkpO1xuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gICAgYXJyYXlzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaWYgKCF1OGEoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByO1xufVxuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmV4cG9ydCBjbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbi8vIENoZWNrIGlmIG9iamVjdCBkb2Vucyd0IGhhdmUgY3VzdG9tIGNvbnN0cnVjdG9yIChsaWtlIFVpbnQ4QXJyYXkvQXJyYXkpXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKG9iaikgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JyB8fCAhaXNQbGFpbk9iamVjdChvcHRzKSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbi8qKlxuICogU2VjdXJlIFBSTkcuIFVzZXMgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLCB3aGljaCBkZWZlcnMgdG8gT1MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction chain(...args) {\n    const wrap = (a, b) => (c) => a(b(c));\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\nfunction convertRadix(data, from, to) {\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            digits[i] = Math.floor(digitBase / to);\n            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!digits[i])\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = (from, to) => from + (to - gcd(from, to));\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0;\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1;\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nconst utils = { alphabet, chain, checksum, radix, radix2, join, padding };\nconst base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nconst base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nconst base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nconst base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nconst base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nconst base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nconst base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nconst base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nconst base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nconst base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        prefix = prefix.toLowerCase();\n        return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nconst bech32 = genBech32('bech32');\nconst bech32m = genBech32('bech32m');\nconst utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nconst hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString;\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsR0FBRyxhQUFhLGdCQUFnQjtBQUNyRztBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxPQUFPO0FBQ2xGO0FBQ0E7QUFDQSx3REFBd0QsT0FBTyxjQUFjLFNBQVM7QUFDdEY7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsRUFBRTtBQUN2RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxFQUFFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQ0FBbUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsS0FBSztBQUN6RDtBQUNBLGtEQUFrRCxHQUFHO0FBQ3JEO0FBQ0E7QUFDQTtBQUNB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QixnQkFBZ0I7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdFQUFnRSxVQUFVLGNBQWMsU0FBUztBQUNqRztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsK0JBQStCO0FBQzFGO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPIiwic291cmNlcyI6WyIvVXNlcnMvcGFibG9mZXJuYW5kZXovdGVzdDEyMy9URU5FWC1wZmttYzkvbWFpbi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWNhY2hlLWRleGllL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgc2N1cmUtYmFzZSAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke259YCk7XG59XG5mdW5jdGlvbiBjaGFpbiguLi5hcmdzKSB7XG4gICAgY29uc3Qgd3JhcCA9IChhLCBiKSA9PiAoYykgPT4gYShiKGMpKTtcbiAgICBjb25zdCBlbmNvZGUgPSBBcnJheS5mcm9tKGFyZ3MpXG4gICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgLnJlZHVjZSgoYWNjLCBpKSA9PiAoYWNjID8gd3JhcChhY2MsIGkuZW5jb2RlKSA6IGkuZW5jb2RlKSwgdW5kZWZpbmVkKTtcbiAgICBjb25zdCBkZWNvZGUgPSBhcmdzLnJlZHVjZSgoYWNjLCBpKSA9PiAoYWNjID8gd3JhcChhY2MsIGkuZGVjb2RlKSA6IGkuZGVjb2RlKSwgdW5kZWZpbmVkKTtcbiAgICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSB9O1xufVxuZnVuY3Rpb24gYWxwaGFiZXQoYWxwaGFiZXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgbnVtYmVycycpO1xuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnROdW1iZXIoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0gYWxwaGFiZXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpZ2l0IGluZGV4IG91dHNpZGUgYWxwaGFiZXQ6ICR7aX0gKGFscGhhYmV0OiAke2FscGhhYmV0Lmxlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFscGhhYmV0W2ldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5tYXAoKGxldHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGV0dGVyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhbHBoYWJldC5kZWNvZGU6IG5vdCBzdHJpbmcgZWxlbWVudD0ke2xldHRlcn1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGFscGhhYmV0LmluZGV4T2YobGV0dGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbGV0dGVyOiBcIiR7bGV0dGVyfVwiLiBBbGxvd2VkOiAke2FscGhhYmV0fWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBqb2luKHNlcGFyYXRvciA9ICcnKSB7XG4gICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4gc2VwYXJhdG9yIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChmcm9tKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZnJvbSkgfHwgKGZyb20ubGVuZ3RoICYmIHR5cGVvZiBmcm9tWzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBmcm9tKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgam9pbi5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgcmV0dXJuIGZyb20uam9pbihzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6ICh0bykgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0byAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gdG8uc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFkZGluZyhiaXRzLCBjaHIgPSAnPScpIHtcbiAgICBhc3NlcnROdW1iZXIoYml0cyk7XG4gICAgaWYgKHR5cGVvZiBjaHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcgY2hyIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpIHx8IChkYXRhLmxlbmd0aCAmJiB0eXBlb2YgZGF0YVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZGF0YSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHdoaWxlICgoZGF0YS5sZW5ndGggKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGNocik7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBpbnB1dClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZGVjb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGVuZCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIHNob3VsZCBoYXZlIHdob2xlIG51bWJlciBvZiBieXRlcycpO1xuICAgICAgICAgICAgZm9yICg7IGVuZCA+IDAgJiYgaW5wdXRbZW5kIC0gMV0gPT09IGNocjsgZW5kLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoISgoKGVuZCAtIDEpICogYml0cykgJSA4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBoYXMgdG9vIG11Y2ggcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKDAsIGVuZCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZShmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9ybWFsaXplIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiB7IGVuY29kZTogKGZyb20pID0+IGZyb20sIGRlY29kZTogKHRvKSA9PiBmbih0bykgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeChkYXRhLCBmcm9tLCB0bykge1xuICAgIGlmIChmcm9tIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIGZyb209JHtmcm9tfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAodG8gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgdG89JHt0b30sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogZGF0YSBzaG91bGQgYmUgYXJyYXknKTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgY29uc3QgZGlnaXRzID0gQXJyYXkuZnJvbShkYXRhKTtcbiAgICBkaWdpdHMuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICBhc3NlcnROdW1iZXIoZCk7XG4gICAgICAgIGlmIChkIDwgMCB8fCBkID49IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7ZH1gKTtcbiAgICB9KTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgY2FycnkgPSAwO1xuICAgICAgICBsZXQgZG9uZSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBkaWdpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gZGlnaXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgZGlnaXRCYXNlID0gZnJvbSAqIGNhcnJ5ICsgZGlnaXQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpZ2l0QmFzZSkgfHxcbiAgICAgICAgICAgICAgICAoZnJvbSAqIGNhcnJ5KSAvIGZyb20gIT09IGNhcnJ5IHx8XG4gICAgICAgICAgICAgICAgZGlnaXRCYXNlIC0gZGlnaXQgIT09IGZyb20gKiBjYXJyeSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FycnkgPSBkaWdpdEJhc2UgJSB0bztcbiAgICAgICAgICAgIGRpZ2l0c1tpXSA9IE1hdGguZmxvb3IoZGlnaXRCYXNlIC8gdG8pO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaWdpdHNbaV0pIHx8IGRpZ2l0c1tpXSAqIHRvICsgY2FycnkgIT09IGRpZ2l0QmFzZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFkaWdpdHNbaV0pXG4gICAgICAgICAgICAgICAgcG9zID0gaTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goY2FycnkpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMSAmJiBkYXRhW2ldID09PSAwOyBpKyspXG4gICAgICAgIHJlcy5wdXNoKDApO1xuICAgIHJldHVybiByZXMucmV2ZXJzZSgpO1xufVxuY29uc3QgZ2NkID0gKGEsIGIpID0+ICghYiA/IGEgOiBnY2QoYiwgYSAlIGIpKTtcbmNvbnN0IHJhZGl4MmNhcnJ5ID0gKGZyb20sIHRvKSA9PiBmcm9tICsgKHRvIC0gZ2NkKGZyb20sIHRvKSk7XG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgyKGRhdGEsIGZyb20sIHRvLCBwYWRkaW5nKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDI6IGRhdGEgc2hvdWxkIGJlIGFycmF5Jyk7XG4gICAgaWYgKGZyb20gPD0gMCB8fCBmcm9tID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgZnJvbT0ke2Zyb219YCk7XG4gICAgaWYgKHRvIDw9IDAgfHwgdG8gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyB0bz0ke3RvfWApO1xuICAgIGlmIChyYWRpeDJjYXJyeShmcm9tLCB0bykgPiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IGZyb209JHtmcm9tfSB0bz0ke3RvfSBjYXJyeUJpdHM9JHtyYWRpeDJjYXJyeShmcm9tLCB0byl9YCk7XG4gICAgfVxuICAgIGxldCBjYXJyeSA9IDA7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgY29uc3QgbWFzayA9IDIgKiogdG8gLSAxO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbiBvZiBkYXRhKSB7XG4gICAgICAgIGFzc2VydE51bWJlcihuKTtcbiAgICAgICAgaWYgKG4gPj0gMiAqKiBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBpbnZhbGlkIGRhdGEgd29yZD0ke259IGZyb209JHtmcm9tfWApO1xuICAgICAgICBjYXJyeSA9IChjYXJyeSA8PCBmcm9tKSB8IG47XG4gICAgICAgIGlmIChwb3MgKyBmcm9tID4gMzIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IHBvcz0ke3Bvc30gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIHBvcyArPSBmcm9tO1xuICAgICAgICBmb3IgKDsgcG9zID49IHRvOyBwb3MgLT0gdG8pXG4gICAgICAgICAgICByZXMucHVzaCgoKGNhcnJ5ID4+IChwb3MgLSB0bykpICYgbWFzaykgPj4+IDApO1xuICAgICAgICBjYXJyeSAmPSAyICoqIHBvcyAtIDE7XG4gICAgfVxuICAgIGNhcnJ5ID0gKGNhcnJ5IDw8ICh0byAtIHBvcykpICYgbWFzaztcbiAgICBpZiAoIXBhZGRpbmcgJiYgcG9zID49IGZyb20pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhjZXNzIHBhZGRpbmcnKTtcbiAgICBpZiAoIXBhZGRpbmcgJiYgY2FycnkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9uLXplcm8gcGFkZGluZzogJHtjYXJyeX1gKTtcbiAgICBpZiAocGFkZGluZyAmJiBwb3MgPiAwKVxuICAgICAgICByZXMucHVzaChjYXJyeSA+Pj4gMCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHJhZGl4KG51bSkge1xuICAgIGFzc2VydE51bWJlcihudW0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXguZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFJhZGl4KEFycmF5LmZyb20oYnl0ZXMpLCAyICoqIDgsIG51bSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXguZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeChkaWdpdHMsIG51bSwgMiAqKiA4KSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJhZGl4MihiaXRzLCByZXZQYWRkaW5nID0gZmFsc2UpIHtcbiAgICBhc3NlcnROdW1iZXIoYml0cyk7XG4gICAgaWYgKGJpdHMgPD0gMCB8fCBiaXRzID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBiaXRzIHNob3VsZCBiZSBpbiAoMC4uMzJdJyk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KDgsIGJpdHMpID4gMzIgfHwgcmFkaXgyY2FycnkoYml0cywgOCkgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFJhZGl4MihBcnJheS5mcm9tKGJ5dGVzKSwgOCwgYml0cywgIXJldlBhZGRpbmcpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4MihkaWdpdHMsIGJpdHMsIDgsIHJldlBhZGRpbmcpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdW5zYWZlV3JhcHBlcihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zYWZlV3JhcHBlciBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrc3VtKGxlbiwgZm4pIHtcbiAgICBhc3NlcnROdW1iZXIobGVuKTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5lbmNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bSA9IGZuKGRhdGEpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIGxlbik7XG4gICAgICAgICAgICByZXMuc2V0KGRhdGEpO1xuICAgICAgICAgICAgcmVzLnNldChjaGVja3N1bSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmRlY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhLnNsaWNlKDAsIC1sZW4pO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hlY2tzdW0gPSBmbihwYXlsb2FkKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2hlY2tzdW0gPSBkYXRhLnNsaWNlKC1sZW4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hlY2tzdW1baV0gIT09IG9sZENoZWNrc3VtW2ldKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0nKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgY29uc3QgdXRpbHMgPSB7IGFscGhhYmV0LCBjaGFpbiwgY2hlY2tzdW0sIHJhZGl4LCByYWRpeDIsIGpvaW4sIHBhZGRpbmcgfTtcbmV4cG9ydCBjb25zdCBiYXNlMTYgPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGJyksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzIgPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyaGV4ID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnKSwgcGFkZGluZyg1KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmNyb2NrZm9yZCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSEpLTU5QUVJTVFZXWFlaJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9PL2csICcwJykucmVwbGFjZSgvW0lMXS9nLCAnMScpKSk7XG5leHBvcnQgY29uc3QgYmFzZTY0ID0gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycpLCBwYWRkaW5nKDYpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTY0dXJsID0gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLCBwYWRkaW5nKDYpLCBqb2luKCcnKSk7XG5jb25zdCBnZW5CYXNlNTggPSAoYWJjKSA9PiBjaGFpbihyYWRpeCg1OCksIGFscGhhYmV0KGFiYyksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlNTggPSBnZW5CYXNlNTgoJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonKTtcbmV4cG9ydCBjb25zdCBiYXNlNThmbGlja3IgPSBnZW5CYXNlNTgoJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonKTtcbmV4cG9ydCBjb25zdCBiYXNlNTh4cnAgPSBnZW5CYXNlNTgoJ3Jwc2huYWYzOXdCVURORUdISktMTTRQUVJTVDdWV1hZWjJiY2RlQ2c2NWprbThvRnFpMXR1dkF4eXonKTtcbmNvbnN0IFhNUl9CTE9DS19MRU4gPSBbMCwgMiwgMywgNSwgNiwgNywgOSwgMTAsIDExXTtcbmV4cG9ydCBjb25zdCBiYXNlNTh4bXIgPSB7XG4gICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gZGF0YS5zdWJhcnJheShpLCBpICsgOCk7XG4gICAgICAgICAgICByZXMgKz0gYmFzZTU4LmVuY29kZShibG9jaykucGFkU3RhcnQoWE1SX0JMT0NLX0xFTltibG9jay5sZW5ndGhdLCAnMScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBkZWNvZGUoc3RyKSB7XG4gICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDExKSB7XG4gICAgICAgICAgICBjb25zdCBzbGljZSA9IHN0ci5zbGljZShpLCBpICsgMTEpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tMZW4gPSBYTVJfQkxPQ0tfTEVOLmluZGV4T2Yoc2xpY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gYmFzZTU4LmRlY29kZShzbGljZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tbal0gIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFzZTU4eG1yOiB3cm9uZyBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KEFycmF5LmZyb20oYmxvY2suc2xpY2UoYmxvY2subGVuZ3RoIC0gYmxvY2tMZW4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShyZXMpO1xuICAgIH0sXG59O1xuZXhwb3J0IGNvbnN0IGJhc2U1OGNoZWNrID0gKHNoYTI1NikgPT4gY2hhaW4oY2hlY2tzdW0oNCwgKGRhdGEpID0+IHNoYTI1NihzaGEyNTYoZGF0YSkpKSwgYmFzZTU4KTtcbmNvbnN0IEJFQ0hfQUxQSEFCRVQgPSBjaGFpbihhbHBoYWJldCgncXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2wnKSwgam9pbignJykpO1xuY29uc3QgUE9MWU1PRF9HRU5FUkFUT1JTID0gWzB4M2I2YTU3YjIsIDB4MjY1MDhlNmQsIDB4MWVhMTE5ZmEsIDB4M2Q0MjMzZGQsIDB4MmExNDYyYjNdO1xuZnVuY3Rpb24gYmVjaDMyUG9seW1vZChwcmUpIHtcbiAgICBjb25zdCBiID0gcHJlID4+IDI1O1xuICAgIGxldCBjaGsgPSAocHJlICYgMHgxZmZmZmZmKSA8PCA1O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUE9MWU1PRF9HRU5FUkFUT1JTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgoKGIgPj4gaSkgJiAxKSA9PT0gMSlcbiAgICAgICAgICAgIGNoayBePSBQT0xZTU9EX0dFTkVSQVRPUlNbaV07XG4gICAgfVxuICAgIHJldHVybiBjaGs7XG59XG5mdW5jdGlvbiBiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgZW5jb2RpbmdDb25zdCA9IDEpIHtcbiAgICBjb25zdCBsZW4gPSBwcmVmaXgubGVuZ3RoO1xuICAgIGxldCBjaGsgPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHByZWZpeC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDMzIHx8IGMgPiAxMjYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHJlZml4ICgke3ByZWZpeH0pYCk7XG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChjID4+IDUpO1xuICAgIH1cbiAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKHByZWZpeC5jaGFyQ29kZUF0KGkpICYgMHgxZik7XG4gICAgZm9yIChsZXQgdiBvZiB3b3JkcylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gdjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGNoayBePSBlbmNvZGluZ0NvbnN0O1xuICAgIHJldHVybiBCRUNIX0FMUEhBQkVULmVuY29kZShjb252ZXJ0UmFkaXgyKFtjaGsgJSAyICoqIDMwXSwgMzAsIDUsIGZhbHNlKSk7XG59XG5mdW5jdGlvbiBnZW5CZWNoMzIoZW5jb2RpbmcpIHtcbiAgICBjb25zdCBFTkNPRElOR19DT05TVCA9IGVuY29kaW5nID09PSAnYmVjaDMyJyA/IDEgOiAweDJiYzgzMGEzO1xuICAgIGNvbnN0IF93b3JkcyA9IHJhZGl4Mig1KTtcbiAgICBjb25zdCBmcm9tV29yZHMgPSBfd29yZHMuZGVjb2RlO1xuICAgIGNvbnN0IHRvV29yZHMgPSBfd29yZHMuZW5jb2RlO1xuICAgIGNvbnN0IGZyb21Xb3Jkc1Vuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZnJvbVdvcmRzKTtcbiAgICBmdW5jdGlvbiBlbmNvZGUocHJlZml4LCB3b3JkcywgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHByZWZpeCAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgcHJlZml4IHNob3VsZCBiZSBzdHJpbmcsIG5vdCAke3R5cGVvZiBwcmVmaXh9YCk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh3b3JkcykgfHwgKHdvcmRzLmxlbmd0aCAmJiB0eXBlb2Ygd29yZHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmVuY29kZSB3b3JkcyBzaG91bGQgYmUgYXJyYXkgb2YgbnVtYmVycywgbm90ICR7dHlwZW9mIHdvcmRzfWApO1xuICAgICAgICBjb25zdCBhY3R1YWxMZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgNyArIHdvcmRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxpbWl0ICE9PSBmYWxzZSAmJiBhY3R1YWxMZW5ndGggPiBsaW1pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYExlbmd0aCAke2FjdHVhbExlbmd0aH0gZXhjZWVkcyBsaW1pdCAke2xpbWl0fWApO1xuICAgICAgICBwcmVmaXggPSBwcmVmaXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0xJHtCRUNIX0FMUEhBQkVULmVuY29kZSh3b3Jkcyl9JHtiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpfWA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZShzdHIsIGxpbWl0ID0gOTApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBzdHJpbmcsIG5vdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoIDwgOCB8fCAobGltaXQgIT09IGZhbHNlICYmIHN0ci5sZW5ndGggPiBsaW1pdCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBXcm9uZyBzdHJpbmcgbGVuZ3RoOiAke3N0ci5sZW5ndGh9ICgke3N0cn0pLiBFeHBlY3RlZCAoOC4uJHtsaW1pdH0pYCk7XG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHN0ciAhPT0gbG93ZXJlZCAmJiBzdHIgIT09IHN0ci50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJpbmcgbXVzdCBiZSBsb3dlcmNhc2Ugb3IgdXBwZXJjYXNlYCk7XG4gICAgICAgIHN0ciA9IGxvd2VyZWQ7XG4gICAgICAgIGNvbnN0IHNlcEluZGV4ID0gc3RyLmxhc3RJbmRleE9mKCcxJyk7XG4gICAgICAgIGlmIChzZXBJbmRleCA9PT0gMCB8fCBzZXBJbmRleCA9PT0gLTEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExldHRlciBcIjFcIiBtdXN0IGJlIHByZXNlbnQgYmV0d2VlbiBwcmVmaXggYW5kIGRhdGEgb25seWApO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBzdHIuc2xpY2UoMCwgc2VwSW5kZXgpO1xuICAgICAgICBjb25zdCBfd29yZHMgPSBzdHIuc2xpY2Uoc2VwSW5kZXggKyAxKTtcbiAgICAgICAgaWYgKF93b3Jkcy5sZW5ndGggPCA2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgYmUgYXQgbGVhc3QgNiBjaGFyYWN0ZXJzIGxvbmcnKTtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBCRUNIX0FMUEhBQkVULmRlY29kZShfd29yZHMpLnNsaWNlKDAsIC02KTtcbiAgICAgICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKTtcbiAgICAgICAgaWYgKCFfd29yZHMuZW5kc1dpdGgoc3VtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGVja3N1bSBpbiAke3N0cn06IGV4cGVjdGVkIFwiJHtzdW19XCJgKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWNvZGVVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGRlY29kZSk7XG4gICAgZnVuY3Rpb24gZGVjb2RlVG9CeXRlcyhzdHIpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHdvcmRzIH0gPSBkZWNvZGUoc3RyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMsIGJ5dGVzOiBmcm9tV29yZHMod29yZHMpIH07XG4gICAgfVxuICAgIHJldHVybiB7IGVuY29kZSwgZGVjb2RlLCBkZWNvZGVUb0J5dGVzLCBkZWNvZGVVbnNhZmUsIGZyb21Xb3JkcywgZnJvbVdvcmRzVW5zYWZlLCB0b1dvcmRzIH07XG59XG5leHBvcnQgY29uc3QgYmVjaDMyID0gZ2VuQmVjaDMyKCdiZWNoMzInKTtcbmV4cG9ydCBjb25zdCBiZWNoMzJtID0gZ2VuQmVjaDMyKCdiZWNoMzJtJyk7XG5leHBvcnQgY29uc3QgdXRmOCA9IHtcbiAgICBlbmNvZGU6IChkYXRhKSA9PiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSksXG4gICAgZGVjb2RlOiAoc3RyKSA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSxcbn07XG5leHBvcnQgY29uc3QgaGV4ID0gY2hhaW4ocmFkaXgyKDQpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OWFiY2RlZicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzICE9PSAnc3RyaW5nJyB8fCBzLmxlbmd0aCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGhleC5kZWNvZGU6IGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN9IHdpdGggbGVuZ3RoICR7cy5sZW5ndGh9YCk7XG4gICAgcmV0dXJuIHMudG9Mb3dlckNhc2UoKTtcbn0pKTtcbmNvbnN0IENPREVSUyA9IHtcbiAgICB1dGY4LCBoZXgsIGJhc2UxNiwgYmFzZTMyLCBiYXNlNjQsIGJhc2U2NHVybCwgYmFzZTU4LCBiYXNlNTh4bXJcbn07XG5jb25zdCBjb2RlclR5cGVFcnJvciA9IGBJbnZhbGlkIGVuY29kaW5nIHR5cGUuIEF2YWlsYWJsZSB0eXBlczogJHtPYmplY3Qua2V5cyhDT0RFUlMpLmpvaW4oJywgJyl9YDtcbmV4cG9ydCBjb25zdCBieXRlc1RvU3RyaW5nID0gKHR5cGUsIGJ5dGVzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyB8fCAhQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAoIShieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1RvU3RyaW5nKCkgZXhwZWN0cyBVaW50OEFycmF5Jyk7XG4gICAgcmV0dXJuIENPREVSU1t0eXBlXS5lbmNvZGUoYnl0ZXMpO1xufTtcbmV4cG9ydCBjb25zdCBzdHIgPSBieXRlc1RvU3RyaW5nO1xuZXhwb3J0IGNvbnN0IHN0cmluZ1RvQnl0ZXMgPSAodHlwZSwgc3RyKSA9PiB7XG4gICAgaWYgKCFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5nVG9CeXRlcygpIGV4cGVjdHMgc3RyaW5nJyk7XG4gICAgcmV0dXJuIENPREVSU1t0eXBlXS5kZWNvZGUoc3RyKTtcbn07XG5leHBvcnQgY29uc3QgYnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-cache-dexie/node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-hooks/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-hooks/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BECH32_REGEX: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.BECH32_REGEX),\n/* harmony export */   EMPTY_MUTE_CRITERIA: () => (/* binding */ EMPTY_MUTE_CRITERIA),\n/* harmony export */   NDKAppHandlerEvent: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKAppHandlerEvent),\n/* harmony export */   NDKAppSettings: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKAppSettings),\n/* harmony export */   NDKArticle: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKArticle),\n/* harmony export */   NDKCashuMintList: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKCashuMintList),\n/* harmony export */   NDKCashuToken: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKCashuToken),\n/* harmony export */   NDKCashuWalletTx: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKCashuWalletTx),\n/* harmony export */   NDKClassified: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKClassified),\n/* harmony export */   NDKDVMJobFeedback: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKDVMJobFeedback),\n/* harmony export */   NDKDVMJobResult: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKDVMJobResult),\n/* harmony export */   NDKDVMRequest: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKDVMRequest),\n/* harmony export */   NDKDraft: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKDraft),\n/* harmony export */   NDKDvmJobFeedbackStatus: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKDvmJobFeedbackStatus),\n/* harmony export */   NDKEvent: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKEvent),\n/* harmony export */   NDKHighlight: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKHighlight),\n/* harmony export */   NDKImage: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKImage),\n/* harmony export */   NDKKind: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKKind),\n/* harmony export */   NDKList: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKList),\n/* harmony export */   NDKListKinds: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKListKinds),\n/* harmony export */   NDKNip07Signer: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKNip07Signer),\n/* harmony export */   NDKNip46Backend: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKNip46Backend),\n/* harmony export */   NDKNip46Signer: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKNip46Signer),\n/* harmony export */   NDKNostrRpc: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKNostrRpc),\n/* harmony export */   NDKNutzap: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKNutzap),\n/* harmony export */   NDKPool: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKPool),\n/* harmony export */   NDKPrivateKeySigner: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKPrivateKeySigner),\n/* harmony export */   NDKPublishError: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKPublishError),\n/* harmony export */   NDKRelay: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKRelay),\n/* harmony export */   NDKRelayAuthPolicies: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKRelayAuthPolicies),\n/* harmony export */   NDKRelayList: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKRelayList),\n/* harmony export */   NDKRelaySet: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKRelaySet),\n/* harmony export */   NDKRelayStatus: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKRelayStatus),\n/* harmony export */   NDKRepost: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKRepost),\n/* harmony export */   NDKSessionLocalStorage: () => (/* binding */ NDKSessionLocalStorage),\n/* harmony export */   NDKSimpleGroup: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKSimpleGroup),\n/* harmony export */   NDKSimpleGroupMemberList: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKSimpleGroupMemberList),\n/* harmony export */   NDKSimpleGroupMetadata: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKSimpleGroupMetadata),\n/* harmony export */   NDKStory: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKStory),\n/* harmony export */   NDKStorySticker: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKStorySticker),\n/* harmony export */   NDKStoryStickerType: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKStoryStickerType),\n/* harmony export */   NDKSubscription: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKSubscription),\n/* harmony export */   NDKSubscriptionCacheUsage: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKSubscriptionCacheUsage),\n/* harmony export */   NDKSubscriptionReceipt: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKSubscriptionReceipt),\n/* harmony export */   NDKSubscriptionStart: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKSubscriptionStart),\n/* harmony export */   NDKSubscriptionTier: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKSubscriptionTier),\n/* harmony export */   NDKTranscriptionDVM: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKTranscriptionDVM),\n/* harmony export */   NDKUser: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKUser),\n/* harmony export */   NDKVideo: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKVideo),\n/* harmony export */   NDKWiki: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKWiki),\n/* harmony export */   NDKWikiMergeRequest: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKWikiMergeRequest),\n/* harmony export */   NDKZapper: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKZapper),\n/* harmony export */   NIP33_A_REGEX: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NIP33_A_REGEX),\n/* harmony export */   NdkNutzapStatus: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NdkNutzapStatus),\n/* harmony export */   addOrUpdateStoredSession: () => (/* binding */ addOrUpdateStoredSession),\n/* harmony export */   calculateRelaySetFromEvent: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.calculateRelaySetFromEvent),\n/* harmony export */   calculateTermDurationInSeconds: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.calculateTermDurationInSeconds),\n/* harmony export */   cashuPubkeyToNostrPubkey: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.cashuPubkeyToNostrPubkey),\n/* harmony export */   clearActivePubkey: () => (/* binding */ clearActivePubkey),\n/* harmony export */   compareFilter: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.compareFilter),\n/* harmony export */   createSubscribeStore: () => (/* binding */ createSubscribeStore),\n/* harmony export */   \"default\": () => (/* binding */ index_default),\n/* harmony export */   defaultOpts: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.defaultOpts),\n/* harmony export */   deserialize: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.deserialize),\n/* harmony export */   dvmSchedule: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.dvmSchedule),\n/* harmony export */   eventHasETagMarkers: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.eventHasETagMarkers),\n/* harmony export */   eventIsPartOfThread: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.eventIsPartOfThread),\n/* harmony export */   eventIsReply: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.eventIsReply),\n/* harmony export */   eventReplies: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.eventReplies),\n/* harmony export */   eventThreadIds: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.eventThreadIds),\n/* harmony export */   eventThreads: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.eventThreads),\n/* harmony export */   eventsBySameAuthor: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.eventsBySameAuthor),\n/* harmony export */   filterAndRelaySetFromBech32: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.filterAndRelaySetFromBech32),\n/* harmony export */   filterFingerprint: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.filterFingerprint),\n/* harmony export */   filterForEventsTaggingId: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.filterForEventsTaggingId),\n/* harmony export */   filterFromId: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.filterFromId),\n/* harmony export */   generateContentTags: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.generateContentTags),\n/* harmony export */   generateHashtags: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.generateHashtags),\n/* harmony export */   generateSubId: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.generateSubId),\n/* harmony export */   generateZapRequest: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.generateZapRequest),\n/* harmony export */   getActivePubkey: () => (/* binding */ getActivePubkey),\n/* harmony export */   getEventReplyId: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.getEventReplyId),\n/* harmony export */   getNip57ZapSpecFromLud: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.getNip57ZapSpecFromLud),\n/* harmony export */   getRelayListForUser: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.getRelayListForUser),\n/* harmony export */   getRelayListForUsers: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.getRelayListForUsers),\n/* harmony export */   getReplyTag: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.getReplyTag),\n/* harmony export */   getRootEventId: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.getRootEventId),\n/* harmony export */   getRootTag: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.getRootTag),\n/* harmony export */   giftUnwrap: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.giftUnwrap),\n/* harmony export */   giftWrap: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.giftWrap),\n/* harmony export */   imetaTagToTag: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.imetaTagToTag),\n/* harmony export */   isEventOriginalPost: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.isEventOriginalPost),\n/* harmony export */   isNip33AValue: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.isNip33AValue),\n/* harmony export */   loadSessionsFromStorage: () => (/* binding */ loadSessionsFromStorage),\n/* harmony export */   mapImetaTag: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.mapImetaTag),\n/* harmony export */   matchFilter: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.matchFilter),\n/* harmony export */   mergeFilters: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.mergeFilters),\n/* harmony export */   mergeTags: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.mergeTags),\n/* harmony export */   ndkSignerFromPayload: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.ndkSignerFromPayload),\n/* harmony export */   newAmount: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.newAmount),\n/* harmony export */   normalize: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.normalize),\n/* harmony export */   normalizeRelayUrl: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.normalizeRelayUrl),\n/* harmony export */   normalizeUrl: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.normalizeUrl),\n/* harmony export */   parseTagToSubscriptionAmount: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.parseTagToSubscriptionAmount),\n/* harmony export */   pinEvent: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.pinEvent),\n/* harmony export */   possibleIntervalFrequencies: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.possibleIntervalFrequencies),\n/* harmony export */   profileFromEvent: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.profileFromEvent),\n/* harmony export */   proofP2pk: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.proofP2pk),\n/* harmony export */   proofP2pkNostr: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.proofP2pkNostr),\n/* harmony export */   proofsTotalBalance: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.proofsTotalBalance),\n/* harmony export */   queryFullyFilled: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.queryFullyFilled),\n/* harmony export */   relayListFromKind3: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.relayListFromKind3),\n/* harmony export */   relaysFromBech32: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.relaysFromBech32),\n/* harmony export */   removeStoredSession: () => (/* binding */ removeStoredSession),\n/* harmony export */   saveSessionsToStorage: () => (/* binding */ saveSessionsToStorage),\n/* harmony export */   serialize: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.serialize),\n/* harmony export */   serializeProfile: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.serializeProfile),\n/* harmony export */   signerRegistry: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.signerRegistry),\n/* harmony export */   storeActivePubkey: () => (/* binding */ storeActivePubkey),\n/* harmony export */   strToDimension: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.strToDimension),\n/* harmony export */   strToPosition: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.strToPosition),\n/* harmony export */   tryNormalizeRelayUrl: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.tryNormalizeRelayUrl),\n/* harmony export */   uniqueTag: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.uniqueTag),\n/* harmony export */   useActiveMuteCriteria: () => (/* binding */ useActiveMuteCriteria),\n/* harmony export */   useAvailableSessions: () => (/* binding */ useAvailableSessions),\n/* harmony export */   useCurrentUserProfile: () => (/* binding */ useCurrentUserProfile),\n/* harmony export */   useEvent: () => (/* binding */ useEvent),\n/* harmony export */   useFollows: () => (/* binding */ useFollows),\n/* harmony export */   useIsItemMuted: () => (/* binding */ useIsItemMuted),\n/* harmony export */   useMuteCriteria: () => (/* binding */ useMuteCriteria),\n/* harmony export */   useMuteFilter: () => (/* binding */ useMuteFilter),\n/* harmony export */   useMuteItem: () => (/* binding */ useMuteItem),\n/* harmony export */   useNDK: () => (/* binding */ useNDK),\n/* harmony export */   useNDKCurrentPubkey: () => (/* binding */ useNDKCurrentPubkey),\n/* harmony export */   useNDKCurrentUser: () => (/* binding */ useNDKCurrentUser),\n/* harmony export */   useNDKInit: () => (/* binding */ useNDKInit),\n/* harmony export */   useNDKNutzapMonitor: () => (/* binding */ useNDKNutzapMonitor),\n/* harmony export */   useNDKSessionEvent: () => (/* binding */ useNDKSessionEvent),\n/* harmony export */   useNDKSessionLogin: () => (/* binding */ useNDKSessionLogin),\n/* harmony export */   useNDKSessionLogout: () => (/* binding */ useNDKSessionLogout),\n/* harmony export */   useNDKSessionMonitor: () => (/* binding */ useNDKSessionMonitor),\n/* harmony export */   useNDKSessionSessions: () => (/* binding */ useNDKSessionSessions),\n/* harmony export */   useNDKSessionSigners: () => (/* binding */ useNDKSessionSigners),\n/* harmony export */   useNDKSessionStart: () => (/* binding */ useNDKSessionStart),\n/* harmony export */   useNDKSessionStop: () => (/* binding */ useNDKSessionStop),\n/* harmony export */   useNDKSessionSwitch: () => (/* binding */ useNDKSessionSwitch),\n/* harmony export */   useNDKStore: () => (/* binding */ useNDKStore),\n/* harmony export */   useNDKUnpublishedEvents: () => (/* binding */ useNDKUnpublishedEvents),\n/* harmony export */   useNDKWallet: () => (/* binding */ useNDKWallet),\n/* harmony export */   useObserver: () => (/* binding */ useObserver),\n/* harmony export */   useProfile: () => (/* binding */ useProfile),\n/* harmony export */   useProfileValue: () => (/* binding */ useProfileValue),\n/* harmony export */   usePublishMuteList: () => (/* binding */ usePublishMuteList),\n/* harmony export */   useSetProfile: () => (/* binding */ useSetProfile),\n/* harmony export */   useSubscribe: () => (/* binding */ useSubscribe),\n/* harmony export */   useUnmuteItem: () => (/* binding */ useUnmuteItem),\n/* harmony export */   useUserProfilesStore: () => (/* binding */ useUserProfilesStore),\n/* harmony export */   wrapEvent: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.wrapEvent),\n/* harmony export */   zapInvoiceFromEvent: () => (/* reexport safe */ _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.zapInvoiceFromEvent)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(ssr)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var zustand_middleware_immer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zustand/middleware/immer */ \"(ssr)/./node_modules/zustand/esm/middleware/immer.mjs\");\n/* harmony import */ var _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @nostr-dev-kit/ndk */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-hooks/node_modules/@nostr-dev-kit/ndk/dist/index.mjs\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/./node_modules/zustand/esm/react/shallow.mjs\");\n/* harmony import */ var zustand_vanilla__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand/vanilla */ \"(ssr)/./node_modules/zustand/esm/vanilla.mjs\");\n/* harmony import */ var _nostr_dev_kit_ndk_wallet__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @nostr-dev-kit/ndk-wallet */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-wallet/dist/index.js\");\n// src/session/hooks/index.ts\n\n\n// src/ndk/hooks/index.ts\n\n\n// src/profiles/store/index.ts\n\n\n// src/utils/time.ts\nvar inSeconds = (ms) => ms / 1e3;\n\n// src/profiles/store/fetch-profile.ts\nvar fetchProfileImplementation = (set, get, pubkey, opts) => {\n  const force = opts?.refresh;\n  const { ndk, profiles } = get();\n  if (!ndk) {\n    console.error(\"NDK instance is not initialized. Did you use useNDKInit at the beginning of your app?\");\n    return;\n  }\n  if (!pubkey) return;\n  const currentProfile = profiles.get(pubkey);\n  if (currentProfile && !force) return;\n  const user = ndk.getUser({ pubkey });\n  user.fetchProfile(opts?.subOpts).then((profile) => {\n    set((state) => {\n      const profiles2 = new Map(state.profiles);\n      if (profile) profiles2.set(pubkey, profile);\n      const lastFetchedAt = new Map(state.lastFetchedAt);\n      lastFetchedAt.set(pubkey, inSeconds(Date.now()));\n      return { profiles: profiles2, lastFetchedAt };\n    });\n  }).catch((err) => {\n    set((state) => {\n      const lastFetchedAt = new Map(state.lastFetchedAt);\n      lastFetchedAt.set(pubkey, inSeconds(Date.now()));\n      return { lastFetchedAt };\n    });\n  });\n};\n\n// src/profiles/store/initialize.ts\nfunction initializeProfilesStore(set, ndk) {\n  const cacheAdapter = ndk.cacheAdapter;\n  if (cacheAdapter?.getAllProfilesSync) {\n    const keys = cacheAdapter.getAllProfilesSync();\n    const profiles = /* @__PURE__ */ new Map();\n    const lastFetchedAt = /* @__PURE__ */ new Map();\n    for (const [key, profile] of keys) {\n      profiles.set(key, profile);\n      lastFetchedAt.set(key, profile.cachedAt ?? 0);\n    }\n    set({ profiles, lastFetchedAt, ndk });\n  } else {\n    set({ ndk });\n  }\n}\n\n// src/profiles/store/set-profile.ts\nvar setProfileImplementation = (set, pubkey, profile, cachedAt) => {\n  set((state) => {\n    const newProfiles = new Map(state.profiles);\n    newProfiles.set(pubkey, profile);\n    const newLastFetchedAt = new Map(state.lastFetchedAt);\n    newLastFetchedAt.set(pubkey, cachedAt ?? inSeconds(Date.now()));\n    return { profiles: newProfiles, lastFetchedAt: newLastFetchedAt };\n  });\n};\n\n// src/profiles/store/index.ts\nvar useUserProfilesStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)((set, get) => ({\n  profiles: /* @__PURE__ */ new Map(),\n  lastFetchedAt: /* @__PURE__ */ new Map(),\n  ndk: void 0,\n  /** @internal */\n  initialize: (ndk) => initializeProfilesStore(set, ndk),\n  setProfile: (pubkey, profile, cachedAt) => setProfileImplementation(set, pubkey, profile, cachedAt),\n  fetchProfile: (pubkey, opts) => fetchProfileImplementation(set, get, pubkey, opts)\n}));\n\n// src/session/store/index.ts\n\n\n\n\n// src/session/store/add-session.ts\n\n\n// src/ndk/store/index.ts\n\nvar useNDKStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)((set) => {\n  return {\n    ndk: null,\n    // currentUser removed\n    setNDK: (ndk) => {\n      set({ ndk });\n    },\n    setSigner: (signer) => {\n      set((state) => {\n        if (state.ndk) {\n          state.ndk.signer = signer;\n        }\n        return { ndk: state.ndk };\n      });\n    }\n  };\n});\n\n// src/mutes/store/index.ts\n\n\n\n\n// src/mutes/store/init.ts\nvar initMutes = (set, get, pubkey) => {\n  set((state) => {\n    if (!state.mutes.has(pubkey)) {\n      state.mutes.set(pubkey, {\n        pubkeys: /* @__PURE__ */ new Set(),\n        hashtags: /* @__PURE__ */ new Set(),\n        words: /* @__PURE__ */ new Set(),\n        eventIds: /* @__PURE__ */ new Set()\n      });\n    }\n  });\n};\n\n// src/mutes/store/load.ts\nvar loadMuteList = (set, get, pubkey, event) => {\n  set((state) => {\n    if (!state.mutes.has(pubkey)) {\n      initMutes(set, get, pubkey);\n    }\n    const userMutes = state.mutes.get(pubkey);\n    if (!userMutes) return;\n    const newMutedPubkeys = /* @__PURE__ */ new Set();\n    const newMutedEvents = /* @__PURE__ */ new Set();\n    const newMutedHashtags = /* @__PURE__ */ new Set();\n    const newMutedWords = /* @__PURE__ */ new Set();\n    for (const tag of event.tags) {\n      if (tag[0] === \"p\") newMutedPubkeys.add(tag[1]);\n      else if (tag[0] === \"e\") newMutedEvents.add(tag[1]);\n      else if (tag[0] === \"t\") newMutedHashtags.add(tag[1]);\n      else if (tag[0] === \"word\") newMutedWords.add(tag[1]);\n    }\n    userMutes.pubkeys = newMutedPubkeys;\n    userMutes.eventIds = newMutedEvents;\n    userMutes.hashtags = newMutedHashtags;\n    userMutes.words = newMutedWords;\n    userMutes.muteListEvent = event;\n  });\n};\n\n// src/mutes/utils/compute-mute-criteria.ts\nfunction computeMuteCriteria(userMutes, extraMutes) {\n  return {\n    pubkeys: /* @__PURE__ */ new Set([\n      ...userMutes?.pubkeys ?? [],\n      ...extraMutes.pubkeys ?? []\n    ]),\n    eventIds: /* @__PURE__ */ new Set([\n      ...userMutes?.eventIds ?? [],\n      ...extraMutes.eventIds ?? []\n    ]),\n    hashtags: /* @__PURE__ */ new Set([\n      ...userMutes?.hashtags ?? [],\n      ...extraMutes.hashtags ?? []\n    ]),\n    words: /* @__PURE__ */ new Set([\n      ...userMutes?.words ?? [],\n      ...extraMutes.words ?? []\n    ])\n  };\n}\n\n// src/mutes/store/mute-item.ts\nvar muteItem = (set, get, pubkey, item, type, options) => {\n  set((state) => {\n    if (!state.mutes.has(pubkey)) {\n      initMutes(set, get, pubkey);\n    }\n    const userMutes = state.mutes.get(pubkey);\n    if (!userMutes) return;\n    switch (type) {\n      case \"pubkey\":\n        userMutes.pubkeys.add(item);\n        break;\n      case \"event\":\n        userMutes.eventIds.add(item);\n        break;\n      case \"hashtag\":\n        userMutes.hashtags.add(item);\n        break;\n      case \"word\":\n        userMutes.words.add(item);\n        break;\n    }\n    if (state.activePubkey === pubkey) {\n      state.muteCriteria = computeMuteCriteria(userMutes, state.extraMutes);\n    }\n  });\n  if (options?.publish !== false) {\n    get().publishMuteList(pubkey);\n  }\n};\n\n// src/mutes/store/unmute-item.ts\nvar unmuteItem = (set, get, pubkey, item, type, options) => {\n  set((state) => {\n    const userMutes = state.mutes.get(pubkey);\n    if (!userMutes) return;\n    switch (type) {\n      case \"pubkey\":\n        userMutes.pubkeys.delete(item);\n        break;\n      case \"event\":\n        userMutes.eventIds.delete(item);\n        break;\n      case \"hashtag\":\n        userMutes.hashtags.delete(item);\n        break;\n      case \"word\":\n        userMutes.words.delete(item);\n        break;\n    }\n    if (state.activePubkey === pubkey) {\n      state.muteCriteria = computeMuteCriteria(userMutes, state.extraMutes);\n    }\n  });\n  if (options?.publish !== false) {\n    get().publishMuteList(pubkey);\n  }\n};\n\n// src/mutes/store/set-active-pubkey.ts\nfunction setActivePubkey(set, pubkey) {\n  set((state) => {\n    state.activePubkey = pubkey;\n    const userMutes = pubkey ? state.mutes.get(pubkey) : void 0;\n    state.muteCriteria = computeMuteCriteria(userMutes, state.extraMutes);\n  });\n}\n\n// src/mutes/store/publish.ts\nvar publishMuteList = async (get, pubkey) => {\n  const userMutes = get().mutes.get(pubkey);\n  if (!userMutes) return void 0;\n  const ndk = useNDKSessions.getState().ndk;\n  if (!ndk) return void 0;\n  const event = new ndk.NDKEvent(ndk);\n  event.kind = 1e4;\n  event.content = \"\";\n  for (const mutedPubkey of userMutes.pubkeys) {\n    event.tags.push([\"p\", mutedPubkey]);\n  }\n  for (const mutedEventId of userMutes.eventIds) {\n    event.tags.push([\"e\", mutedEventId]);\n  }\n  for (const mutedHashtag of userMutes.hashtags) {\n    event.tags.push([\"t\", mutedHashtag]);\n  }\n  for (const mutedWord of userMutes.words) {\n    event.tags.push([\"word\", mutedWord]);\n  }\n  try {\n    await event.sign();\n    await event.publish();\n    get().loadMuteList(pubkey, event);\n    return event;\n  } catch (error) {\n    console.error(\"Failed to publish mute list:\", error);\n    return void 0;\n  }\n};\n\n// src/mutes/utils/identify-mute-item.ts\n\nfunction identifyMuteItem(item) {\n  let itemType;\n  let value;\n  if (item instanceof _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKEvent) {\n    itemType = \"event\";\n    value = item.id;\n  } else if (item instanceof _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKUser) {\n    itemType = \"pubkey\";\n    value = item.pubkey;\n  } else if (typeof item === \"string\") {\n    if (item.startsWith(\"#\") && item.length > 1) {\n      itemType = \"hashtag\";\n      value = item.substring(1);\n    } else {\n      itemType = \"word\";\n      value = item;\n    }\n  } else {\n    console.warn(\"identifyMuteItem: Invalid item type provided.\", item);\n    return void 0;\n  }\n  return { type: itemType, value };\n}\n\n// src/mutes/store/add-extra-mute-items.ts\nvar addExtraMuteItems = (set, get, items) => {\n  set((state) => {\n    for (const item of items) {\n      const identified = identifyMuteItem(item);\n      if (!identified) continue;\n      const { type, value } = identified;\n      switch (type) {\n        case \"pubkey\":\n          state.extraMutes.pubkeys.add(value);\n          break;\n        case \"event\":\n          state.extraMutes.eventIds.add(value);\n          break;\n        case \"hashtag\":\n          state.extraMutes.hashtags.add(value.toLowerCase());\n          break;\n        case \"word\":\n          state.extraMutes.words.add(value.toLowerCase());\n          break;\n      }\n    }\n    const userMutes = state.activePubkey ? state.mutes.get(state.activePubkey) : void 0;\n    state.muteCriteria = computeMuteCriteria(userMutes, state.extraMutes);\n  });\n};\n\n// src/mutes/store/index.ts\n(0,immer__WEBPACK_IMPORTED_MODULE_3__.enableMapSet)();\nvar mutesStateCreator = (set, get) => ({\n  mutes: /* @__PURE__ */ new Map(),\n  extraMutes: {\n    pubkeys: /* @__PURE__ */ new Set(),\n    hashtags: /* @__PURE__ */ new Set(),\n    words: /* @__PURE__ */ new Set(),\n    eventIds: /* @__PURE__ */ new Set()\n  },\n  activePubkey: null,\n  muteCriteria: {\n    pubkeys: /* @__PURE__ */ new Set(),\n    eventIds: /* @__PURE__ */ new Set(),\n    hashtags: /* @__PURE__ */ new Set(),\n    words: /* @__PURE__ */ new Set()\n  },\n  initMutes: (pubkey) => initMutes(set, get, pubkey),\n  loadMuteList: (pubkey, event) => loadMuteList(set, get, pubkey, event),\n  muteItem: (pubkey, item, type, options) => muteItem(set, get, pubkey, item, type, options),\n  unmuteItem: (pubkey, item, type, options) => unmuteItem(set, get, pubkey, item, type, options),\n  setActivePubkey: (pubkey) => setActivePubkey(set, pubkey),\n  addExtraMuteItems: (items) => addExtraMuteItems(set, get, items),\n  publishMuteList: (pubkey) => publishMuteList(get, pubkey)\n});\nvar useNDKMutes = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)((0,zustand_middleware_immer__WEBPACK_IMPORTED_MODULE_4__.immer)(mutesStateCreator));\n\n// src/session/store/add-session.ts\nvar createDefaultSession = (pubkey) => ({\n  pubkey,\n  events: /* @__PURE__ */ new Map(),\n  lastActive: Date.now() / 1e3\n});\nvar addSession = async (set, get, userOrSigner, setActive = true) => {\n  let user;\n  let signer = void 0;\n  let userPubkey;\n  if (userOrSigner instanceof _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKUser) {\n    user = userOrSigner;\n    userPubkey = user.pubkey;\n  } else {\n    signer = userOrSigner;\n    try {\n      user = await signer.user();\n      userPubkey = user.pubkey;\n      set((draft) => {\n        draft.signers.set(userPubkey, signer);\n      });\n    } catch (error) {\n      console.error(\"Failed to get user from signer:\", error);\n      throw new Error(\"Could not retrieve user from the provided signer.\");\n    }\n  }\n  set((draft) => {\n    let session = draft.sessions.get(userPubkey);\n    if (!session) {\n      session = createDefaultSession(userPubkey);\n      draft.sessions.set(userPubkey, session);\n    } else {\n      session.lastActive = Date.now() / 1e3;\n      console.debug(`Session already exists for ${userPubkey}, updating lastActive.`);\n    }\n    if (setActive) {\n      draft.activePubkey = userPubkey;\n      useNDKStore.getState().setSigner(signer);\n    }\n  });\n  useNDKMutes.getState().initMutes(userPubkey);\n  if (setActive) {\n    useNDKMutes.getState().setActivePubkey(userPubkey);\n  }\n  return userPubkey;\n};\n\n// src/session/store/init.ts\nvar init = (set, ndk) => {\n  set((draft) => {\n    draft.ndk = ndk;\n  });\n};\n\n// src/session/store/remove-session.ts\nvar removeSession = (set, get, pubkey) => {\n  const state = get();\n  const sessionToRemove = state.sessions.get(pubkey);\n  const signerToRemove = state.signers.get(pubkey);\n  if (!sessionToRemove) {\n    console.warn(`No session found to remove for pubkey: ${pubkey}`);\n    return;\n  }\n  if (sessionToRemove.subscription) {\n    console.debug(`Stopping subscription for removed session ${pubkey}`);\n    try {\n      sessionToRemove.subscription.stop();\n    } catch (error) {\n      console.error(`Error stopping subscription for removed session ${pubkey}:`, error);\n    }\n  }\n  const wasActive = state.activePubkey === pubkey;\n  set((draft) => {\n    draft.sessions.delete(pubkey);\n    draft.signers.delete(pubkey);\n    if (wasActive) {\n      let nextActivePubkey = null;\n      let latestLastActive = 0;\n      for (const [key, session] of draft.sessions.entries()) {\n        if (session.lastActive > latestLastActive) {\n          latestLastActive = session.lastActive;\n          nextActivePubkey = key;\n        }\n      }\n      draft.activePubkey = nextActivePubkey;\n      const nextActiveSigner = nextActivePubkey ? draft.signers.get(nextActivePubkey) : void 0;\n      const ndk = draft.ndk;\n      if (ndk) {\n        ndk.signer = nextActiveSigner;\n      }\n    }\n  });\n};\n\n// src/session/store/start-session.ts\n\nfunction handleProfileEvent(event, sessionDraft) {\n  const profile = (0,_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.profileFromEvent)(event);\n  if (profile) {\n    profile.created_at = event.created_at;\n    sessionDraft.profile = profile;\n  }\n}\nfunction handleContactsEvent(event, sessionDraft) {\n  const followSet = new Set(event.tags.filter((t) => t[0] === \"p\").map((t) => t[1]));\n  sessionDraft.followSet = followSet;\n}\nfunction handleOtherEvent(event, sessionDraft, opts) {\n  const existingEvent = sessionDraft.events.get(event.kind);\n  if (!existingEvent || event.created_at > existingEvent.created_at) {\n    sessionDraft.events.set(event.kind, event);\n  }\n  const klassWrapper = opts?.events?.get(event.kind);\n  if (klassWrapper) {\n    const wrappedEvent = klassWrapper.from(event);\n    if (wrappedEvent) sessionDraft.events.set(event.kind, wrappedEvent);\n  }\n}\nfunction handleKindFollowEvent(event, sessionDraft, followed = true, last_updated_at = event.created_at) {\n  const kindFollowSet = sessionDraft.kindFollowSet ?? /* @__PURE__ */ new Map();\n  const kinds = event.getMatchingTags(\"k\").map((t) => Number(t[1]));\n  const followedPubkeys = event.getMatchingTags(\"p\").map((t) => t[1]);\n  for (const kind of kinds) {\n    for (const pubkey of followedPubkeys) {\n      const kindFollows = kindFollowSet.get(kind) || /* @__PURE__ */ new Map();\n      const followedInfo = { followed, last_updated_at };\n      const existingFollowedInfo = kindFollows.get(pubkey);\n      if (!existingFollowedInfo || existingFollowedInfo.last_updated_at < event.created_at) {\n        kindFollows.set(pubkey, followedInfo);\n      }\n      kindFollowSet.set(kind, kindFollows);\n    }\n  }\n  sessionDraft.kindFollowSet = kindFollowSet;\n}\nfunction handkeEventDeletion(event, sessionDraft) {\n  const kindFollowSet = sessionDraft.kindFollowSet;\n  if (!kindFollowSet) return;\n  for (const eTag of event.getMatchingTags(\"e\")) {\n    if (!eTag[1]) continue;\n    if (!event.ndk) continue;\n    const followEventDeleted = event.ndk.fetchEventSync(eTag[1]);\n    if (!followEventDeleted?.[0]) continue;\n    handleKindFollowEvent(followEventDeleted[0], sessionDraft, false, event.created_at);\n  }\n}\nfunction processEvent(event, sessionDraft, opts) {\n  const knownEventForKind = sessionDraft.events?.get(event.kind);\n  if (!(!knownEventForKind || knownEventForKind.created_at < event.created_at) && event.isReplaceable()) {\n    console.log(\"We already have an event of kind \" + event.kind + \" that is newer\", {\n      knownEvent: knownEventForKind.created_at,\n      incomingEvent: event.created_at\n    });\n    return;\n  }\n  try {\n    switch (event.kind) {\n      case _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKKind.Metadata:\n        handleProfileEvent(event, sessionDraft);\n        break;\n      case _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKKind.Contacts:\n        handleContactsEvent(event, sessionDraft);\n        break;\n      case _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKKind.MuteList:\n        useNDKMutes.getState().loadMuteList(sessionDraft.pubkey, event);\n        break;\n      case 967:\n        handleKindFollowEvent(event, sessionDraft);\n        break;\n      case _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKKind.EventDeletion:\n        handkeEventDeletion(event, sessionDraft);\n        break;\n      default:\n        handleOtherEvent(event, sessionDraft, opts);\n    }\n    sessionDraft.events.set(event.kind, event);\n  } catch (error) {\n    console.error(`Error processing event kind ${event.kind} for ${sessionDraft.pubkey}:`, error, event);\n  }\n}\nfunction buildSessionFilter(pubkey, opts) {\n  const mainKindsToFetch = /* @__PURE__ */ new Set();\n  if (opts.profile !== false) mainKindsToFetch.add(_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKKind.Metadata);\n  if (opts.follows !== false) mainKindsToFetch.add(_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKKind.Contacts);\n  mainKindsToFetch.add(_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKKind.MuteList);\n  for (const kind of opts.events?.keys() || []) {\n    mainKindsToFetch.add(kind);\n  }\n  const filter = [{ kinds: Array.from(mainKindsToFetch), authors: [pubkey] }];\n  if (Array.isArray(opts.follows)) {\n    filter.push({ kinds: [967], \"#k\": opts.follows.map((k) => k.toString()), authors: [pubkey] });\n  }\n  return filter;\n}\nvar startSession = (set, get, pubkey, opts) => {\n  console.log(\"calling startSession\", pubkey);\n  const ndk = get().ndk;\n  if (!ndk) {\n    console.error(\"NDK instance not initialized in session store. Cannot start session.\");\n    return;\n  }\n  const existingSession = get().sessions.get(pubkey);\n  if (!existingSession) {\n    return;\n  }\n  if (existingSession.subscription) {\n    existingSession.subscription.stop();\n    set((draft) => {\n      const session = draft.sessions.get(pubkey);\n      if (session) {\n        session.subscription = void 0;\n      }\n    });\n  }\n  const filters = buildSessionFilter(pubkey, opts);\n  if (filters.length === 0) {\n    console.warn(`No filters generated for session start options for pubkey ${pubkey}. No subscription created.`);\n    return;\n  }\n  const onEvent = (event, relay) => {\n    console.log(\"handle session event\", event.pubkey.slice(0, 6), event.kind, relay?.url);\n    set((draft) => {\n      const session = draft.sessions.get(pubkey);\n      if (!session) return;\n      processEvent(event, session, opts);\n    });\n  };\n  const onEvents = (events) => {\n    set((draft) => {\n      const session = draft.sessions.get(pubkey);\n      if (!session) return;\n      for (const event of events) {\n        processEvent(event, session, opts);\n      }\n      console.debug(`Processed ${events.length} cached events for ${pubkey}`);\n    });\n  };\n  const sub = ndk.subscribe(filters, { closeOnEose: false, addSinceFromCache: true }, { onEvent, onEvents });\n  set((draft) => {\n    const session = draft.sessions.get(pubkey);\n    if (session) {\n      session.subscription = sub;\n    }\n  });\n};\n\n// src/session/store/stop-session.ts\nvar stopSession = (set, get, pubkey) => {\n  const session = get().sessions.get(pubkey);\n  if (session?.subscription) {\n    console.debug(`Stopping session subscription for ${pubkey}`);\n    try {\n      session.subscription.stop();\n    } catch (error) {\n      console.error(`Error stopping subscription for ${pubkey}:`, error);\n    }\n    set((draft) => {\n      const draftSession = draft.sessions.get(pubkey);\n      if (draftSession) {\n        draftSession.subscription = void 0;\n      }\n    });\n  } else {\n    console.debug(`No active subscription found for session ${pubkey} to stop.`);\n  }\n};\n\n// src/session/store/switch-to-user.ts\nvar switchToUser = (set, get, pubkey) => {\n  const signers = get().signers;\n  const ndk = get().ndk;\n  if (!ndk) {\n    console.error(\"Cannot switch user: NDK instance not initialized in session store.\");\n    return;\n  }\n  let signer = void 0;\n  if (pubkey !== null) {\n    const session = get().sessions.get(pubkey);\n    if (!session) {\n      console.error(`Cannot switch to user ${pubkey}: Session does not exist.`);\n      return;\n    }\n    signer = signers.get(pubkey);\n  }\n  useNDKStore.getState().setSigner(signer);\n  set((draft) => {\n    draft.activePubkey = pubkey;\n    if (pubkey) {\n      const draftSession = draft.sessions.get(pubkey);\n      if (draftSession) {\n        draftSession.lastActive = Date.now() / 1e3;\n      }\n    }\n  });\n  const muteStore = useNDKMutes.getState();\n  muteStore.setActivePubkey(pubkey);\n  if (pubkey) {\n    muteStore.initMutes(pubkey);\n  }\n};\n\n// src/session/store/update-session.ts\nvar updateSession = (set, get, pubkey, data) => {\n  set((draft) => {\n    const session = draft.sessions.get(pubkey);\n    if (!session) {\n      console.warn(`Attempted to update non-existent session: ${pubkey}`);\n      return;\n    }\n    Object.assign(session, data);\n    session.lastActive = Date.now();\n  });\n};\n\n// src/session/store/index.ts\n(0,immer__WEBPACK_IMPORTED_MODULE_3__.enableMapSet)();\nvar sessionStateCreator = (set, get) => ({\n  ndk: void 0,\n  // Add NDK instance holder\n  sessions: /* @__PURE__ */ new Map(),\n  signers: /* @__PURE__ */ new Map(),\n  // Keep signers map for addSession logic\n  activePubkey: null,\n  // Initialization\n  init: (ndkInstance) => init(set, ndkInstance),\n  /**\n   * Adds the session. This is how we login a user.\n   * @param userOrSigner\n   * @param setActive - If true, sets the session as active.\n   * @returns\n   */\n  addSession: async (userOrSigner, setActive) => {\n    const pubkey = await addSession(set, get, userOrSigner, setActive);\n    if (pubkey && setActive) get().switchToUser(pubkey);\n    return pubkey;\n  },\n  startSession: (pubkey, opts) => startSession(set, get, pubkey, opts),\n  stopSession: (pubkey) => stopSession(set, get, pubkey),\n  switchToUser: (pubkey) => switchToUser(set, get, pubkey),\n  removeSession: (pubkey) => removeSession(set, get, pubkey),\n  // Internal update function\n  updateSession: (pubkey, data) => updateSession(set, get, pubkey, data)\n});\nvar useNDKSessions = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)((0,zustand_middleware_immer__WEBPACK_IMPORTED_MODULE_4__.immer)(sessionStateCreator));\n\n// src/ndk/hooks/index.ts\nvar useNDK = () => {\n  const ndk = useNDKStore((state) => state.ndk);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({ ndk }), [ndk]);\n};\nvar useNDKCurrentPubkey = () => useNDKSessions((state) => state.activePubkey);\nvar useNDKCurrentUser = () => {\n  const ndk = useNDKStore((state) => state.ndk);\n  const activePubkey = useNDKCurrentPubkey();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (ndk && activePubkey) {\n      return ndk.getUser({ pubkey: activePubkey });\n    }\n    return null;\n  }, [ndk, activePubkey]);\n};\nfunction useNDKUnpublishedEvents() {\n  const { ndk } = useNDK();\n  const [unpublishedEvents, setUnpublishedEvents] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n  const updateStateFromCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {\n    if (!ndk?.cacheAdapter?.getUnpublishedEvents) return;\n    const entries = await ndk.cacheAdapter.getUnpublishedEvents();\n    const previousEntries = new Set(state.current?.map((e) => e.event.id));\n    const newEntries = [];\n    let changed = entries.length !== state.current?.length;\n    if (!changed) {\n      const currentIds = new Set(state.current.map((e) => e.event.id));\n      for (const entry of entries) {\n        if (!currentIds.has(entry.event.id)) {\n          changed = true;\n          break;\n        }\n      }\n    }\n    if (changed) {\n      const freshEntries = entries.map((entry) => ({ ...entry }));\n      state.current = freshEntries;\n      setUnpublishedEvents(freshEntries);\n      for (const entry of freshEntries) {\n        entry.event.on(\"published\", () => {\n          state.current = state.current?.filter((e) => e.event.id !== entry.event.id);\n          setUnpublishedEvents(state.current);\n        });\n      }\n    }\n  }, [ndk]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!ndk?.cacheAdapter?.getUnpublishedEvents) return;\n    updateStateFromCache();\n    const handlePublishFailed = (_event, _error, _relays) => {\n      updateStateFromCache();\n    };\n    ndk?.on(\"event:publish-failed\", handlePublishFailed);\n    return () => {\n      ndk?.off(\"event:publish-failed\", handlePublishFailed);\n    };\n  }, [ndk, updateStateFromCache]);\n  return unpublishedEvents;\n}\nfunction useNDKInit() {\n  const setNDK = useNDKStore((state) => state.setNDK);\n  const initializeProfilesStore2 = useUserProfilesStore((state) => state.initialize);\n  const initializeSessionStore = useNDKSessions((state) => state.init);\n  const initializeNDK = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (ndkInstance) => {\n      if (!ndkInstance) {\n        console.error(\"useNDKInit: Attempted to initialize with a null NDK instance.\");\n        return;\n      }\n      setNDK(ndkInstance);\n      initializeProfilesStore2(ndkInstance);\n      initializeSessionStore(ndkInstance);\n    },\n    [setNDK, initializeProfilesStore2, initializeSessionStore]\n  );\n  return initializeNDK;\n}\n\n// src/profiles/hooks/index.ts\n\n\n\nfunction useProfile(pubkey, forceRefresh) {\n  return useProfileValue(pubkey, { refresh: forceRefresh });\n}\nfunction useProfileValue(pubkey, opts) {\n  const fetchProfile = useUserProfilesStore((state) => state.fetchProfile);\n  const profileSelector = (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_5__.useShallow)((state) => pubkey ? state.profiles.get(pubkey) : void 0);\n  const profile = useUserProfilesStore(profileSelector);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (pubkey) {\n      fetchProfile(pubkey, opts);\n    }\n  }, [pubkey, fetchProfile, opts]);\n  return profile;\n}\nfunction useSetProfile() {\n  const setProfile = useUserProfilesStore((state) => state.setProfile);\n  const { ndk } = useNDK();\n  const update = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (newProfile) => {\n      if (!ndk) return null;\n      const event = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKEvent(ndk);\n      event.kind = _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKKind.Metadata;\n      event.content = (0,_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.serializeProfile)(newProfile);\n      await event.sign();\n      event.publish();\n      setProfile(event.pubkey, newProfile);\n    },\n    [ndk]\n  );\n  return update;\n}\n\n// src/session/hooks/index.ts\nvar EMPTY_SET = /* @__PURE__ */ new Set();\nvar EMPTY_KIND_MAP = /* @__PURE__ */ new Map();\nvar useNDKSessionLogin = () => {\n  const addSession2 = useNDKSessions.getState().addSession;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (userOrSigner, setActive) => addSession2(userOrSigner, setActive),\n    [addSession2]\n  );\n};\nvar useNDKSessionLogout = () => {\n  const currentPubkey = useNDKCurrentPubkey();\n  const removeSession2 = useNDKSessions.getState().removeSession;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (pubkey) => {\n      const _pubkey = pubkey ?? currentPubkey;\n      if (!_pubkey) {\n        console.error(\"No pubkey provided for logout\");\n        return;\n      }\n      removeSession2(_pubkey);\n    },\n    [removeSession2, currentPubkey]\n  );\n};\nvar useNDKSessionSwitch = () => {\n  const switchToUser2 = useNDKSessions.getState().switchToUser;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((pubkey) => switchToUser2(pubkey), [switchToUser2]);\n};\nvar useFollows = () => {\n  const follows = useNDKSessions(\n    (s) => s.activePubkey ? s.sessions.get(s.activePubkey)?.followSet ?? EMPTY_SET : EMPTY_SET\n  );\n  const followKinds = useNDKSessions(\n    (s) => s.activePubkey ? s.sessions.get(s.activePubkey)?.kindFollowSet ?? EMPTY_KIND_MAP : EMPTY_KIND_MAP\n  );\n  const followSet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const set = new Set(follows);\n    for (const kinds of followKinds.values()) {\n      for (const [pubkey, { followed }] of kinds.entries()) {\n        if (followed) {\n          set.add(pubkey);\n        } else {\n          set.delete(pubkey);\n        }\n      }\n    }\n    return set;\n  }, [follows, followKinds]);\n  return followSet;\n};\nfunction useNDKSessionEvent(kind, options = {}) {\n  const { ndk } = useNDK();\n  const { create: create6 } = options;\n  const activePubkey = useNDKSessions((s) => s.activePubkey);\n  const activeSessionEvents = useNDKSessions(\n    (s) => s.activePubkey ? s.sessions.get(s.activePubkey)?.events : void 0\n  );\n  const event = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!activeSessionEvents || !activePubkey) return void 0;\n    const existingEvent = activeSessionEvents.get(kind);\n    if (existingEvent) return existingEvent;\n    if (create6 && ndk) {\n      try {\n        const newInstance = new create6(ndk);\n        newInstance.pubkey = activePubkey;\n        return newInstance;\n      } catch (error) {\n        console.error(`Failed to create instance for kind ${kind} using provided class:`, error);\n        return void 0;\n      }\n    }\n    return void 0;\n  }, [activeSessionEvents, kind, ndk, activePubkey]);\n  return event;\n}\nvar useCurrentUserProfile = () => {\n  const activePubkey = useNDKSessions((state) => state.activePubkey);\n  const profile = useProfileValue(activePubkey ?? void 0);\n  return profile;\n};\n\n// src/session/hooks/signers.ts\nvar useNDKSessionSigners = () => useNDKSessions((s) => s.signers);\n\n// src/session/hooks/sessions.ts\nvar useNDKSessionSessions = () => useNDKSessions((s) => s.sessions);\n\n// src/session/hooks/control.ts\nvar useNDKSessionStart = () => useNDKSessions((s) => s.startSession);\nvar useNDKSessionStop = () => useNDKSessions((s) => s.stopSession);\n\n// src/session/hooks/use-ndk-session-monitor.ts\n\n\n\n// src/session/storage/index.ts\nvar SESSIONS_STORE_KEY = \"ndk-saved-sessions\";\nvar ACTIVE_PUBKEY_STORE_KEY = \"ndk-active-pubkey\";\nvar NDKSessionLocalStorage = class {\n  /**\n   * Get an item from localStorage.\n   * @param key The key to retrieve.\n   * @returns The stored value or null if not found.\n   */\n  getItem(key) {\n    if (typeof localStorage === \"undefined\") {\n      console.warn(\"localStorage is not available in this environment\");\n      return null;\n    }\n    return localStorage.getItem(key);\n  }\n  /**\n   * Set an item in localStorage.\n   * @param key The key to store.\n   * @param value The value to store.\n   */\n  setItem(key, value) {\n    if (typeof localStorage === \"undefined\") {\n      console.warn(\"localStorage is not available in this environment\");\n      return;\n    }\n    localStorage.setItem(key, value);\n  }\n  /**\n   * Delete an item from localStorage.\n   * @param key The key to delete.\n   */\n  deleteItem(key) {\n    if (typeof localStorage === \"undefined\") {\n      console.warn(\"localStorage is not available in this environment\");\n      return;\n    }\n    localStorage.removeItem(key);\n  }\n};\nfunction loadSessionsFromStorage(storage) {\n  try {\n    const sessionsJson = storage.getItem(SESSIONS_STORE_KEY);\n    if (!sessionsJson) return [];\n    const sessions = JSON.parse(sessionsJson);\n    return sessions;\n  } catch (error) {\n    console.error(\"[NDK] Error loading sessions from storage:\", error);\n    return [];\n  }\n}\nfunction saveSessionsToStorage(storage, sessions) {\n  try {\n    storage.setItem(SESSIONS_STORE_KEY, JSON.stringify(sessions));\n  } catch (error) {\n    console.error(\"[NDK] Error saving sessions to storage:\", error);\n  }\n}\nasync function addOrUpdateStoredSession(storage, pubkey, signerPayload) {\n  try {\n    const sessions = loadSessionsFromStorage(storage);\n    const existingIndex = sessions.findIndex((s) => s.pubkey === pubkey);\n    if (existingIndex !== -1) {\n      if (signerPayload !== void 0) {\n        sessions[existingIndex].signerPayload = signerPayload;\n      }\n    } else {\n      sessions.push({\n        pubkey,\n        signerPayload\n        // Will be undefined for read-only sessions initially\n      });\n    }\n    saveSessionsToStorage(storage, sessions);\n  } catch (error) {\n    console.error(\"[NDK] Error adding/updating stored session:\", error);\n  }\n}\nasync function removeStoredSession(storage, pubkey) {\n  try {\n    const sessions = loadSessionsFromStorage(storage);\n    const updatedSessions = sessions.filter((s) => s.pubkey !== pubkey);\n    saveSessionsToStorage(storage, updatedSessions);\n  } catch (error) {\n    console.error(\"[NDK] Error removing session from storage:\", error);\n  }\n}\nfunction getActivePubkey(storage) {\n  try {\n    const activePubkey = storage.getItem(ACTIVE_PUBKEY_STORE_KEY);\n    return activePubkey || void 0;\n  } catch (error) {\n    console.error(\"[NDK] Error getting active pubkey from storage:\", error);\n    return void 0;\n  }\n}\nfunction storeActivePubkey(storage, pubkey) {\n  try {\n    storage.setItem(ACTIVE_PUBKEY_STORE_KEY, pubkey);\n  } catch (error) {\n    console.error(\"[NDK] Error setting active pubkey in storage:\", error);\n  }\n}\nasync function clearActivePubkey(storage) {\n  try {\n    storage.deleteItem(ACTIVE_PUBKEY_STORE_KEY);\n  } catch (error) {\n    console.error(\"[NDK] Error clearing active pubkey from storage:\", error);\n  }\n}\n\n// src/session/hooks/use-ndk-session-monitor.ts\nfunction useNDKSessionMonitor(sessionStorage, opts) {\n  const { ndk } = useNDK();\n  const isInitialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const storedKeys = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(/* @__PURE__ */ new Map());\n  const storedActivePubkey = sessionStorage && getActivePubkey(sessionStorage);\n  const addSession2 = useNDKSessionLogin();\n  const currentUser = useNDKCurrentUser();\n  const signers = useNDKSessionSigners();\n  const sessions = useNDKSessionSessions();\n  const startSession2 = useNDKSessionStart();\n  const stopSession2 = useNDKSessionStop();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!ndk || isInitialized.current || !sessionStorage) return;\n    async function initializeFromStorage() {\n      if (!ndk || !sessionStorage) return;\n      try {\n        const storedSessions = loadSessionsFromStorage(sessionStorage);\n        if (storedSessions.length === 0) {\n          return;\n        }\n        for (const storedSession of storedSessions) {\n          const { pubkey, signerPayload } = storedSession;\n          try {\n            const user = ndk.getUser({ pubkey });\n            let signer = void 0;\n            if (signerPayload) {\n              signer = await (0,_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.ndkSignerFromPayload)(signerPayload, ndk);\n              if (!signer) {\n                console.warn(\n                  `[NDK] Failed to deserialize signer for ${pubkey}, session will be read-only.`\n                );\n              } else {\n                storedKeys.current.set(pubkey, true);\n              }\n            } else {\n              storedKeys.current.set(pubkey, false);\n            }\n            await addSession2(signer ? signer : user, pubkey === storedActivePubkey);\n          } catch (error) {\n            console.error(\n              `[NDK] Failed to process stored session for pubkey ${storedSession.pubkey}:`,\n              error\n            );\n          }\n        }\n      } catch (error) {\n        console.error(\"[NDK] Error initializing sessions from storage:\", error);\n      }\n    }\n    initializeFromStorage().finally(() => {\n      if (storedActivePubkey) {\n        startSession2(storedActivePubkey, opts || {});\n      }\n      isInitialized.current = true;\n    });\n  }, [ndk, sessionStorage]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!ndk || !isInitialized.current || !sessionStorage) return;\n    async function persistSessions() {\n      if (!ndk || !sessionStorage) return;\n      for (const [pubkey, signer] of signers) {\n        if (storedKeys.current.get(pubkey)) continue;\n        const payload = signer.toPayload();\n        if (payload) {\n          await addOrUpdateStoredSession(sessionStorage, pubkey, payload);\n          storedKeys.current.set(pubkey, true);\n        }\n      }\n      for (const pubkey of sessions.keys()) {\n        if (storedKeys.current.has(pubkey)) continue;\n        await addOrUpdateStoredSession(sessionStorage, pubkey);\n        storedKeys.current.set(pubkey, true);\n      }\n    }\n    persistSessions();\n  }, [sessions, signers, ndk, sessionStorage]);\n  const currentActivePubkey = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(currentUser?.pubkey);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    console.log(\"Current user pubkey:\", currentUser?.pubkey);\n    if (!ndk || !isInitialized.current || !sessionStorage) return;\n    if (currentUser?.pubkey === currentActivePubkey.current) {\n      console.log(\"No change in active pubkey, skipping update.\");\n      return;\n    }\n    async function updateActivePubkey() {\n      if (!ndk || !sessionStorage) return;\n      if (currentUser?.pubkey) {\n        try {\n          if (currentActivePubkey.current !== currentUser.pubkey) {\n            if (currentActivePubkey.current) {\n              await stopSession2(currentActivePubkey.current);\n            }\n            currentActivePubkey.current = currentUser.pubkey;\n          }\n          console.log(\"Storing active pubkey:\", currentUser.pubkey);\n          storeActivePubkey(sessionStorage, currentUser.pubkey);\n          console.log(\"Starting session for active pubkey:\", currentUser.pubkey);\n          await startSession2(currentUser.pubkey, opts || {});\n        } catch (error) {\n          console.error(`Failed to start session for active pubkey ${currentUser?.pubkey}:`, error);\n        }\n      } else {\n        await clearActivePubkey(sessionStorage);\n      }\n    }\n    updateActivePubkey();\n  }, [currentUser?.pubkey, ndk, sessionStorage]);\n  const prevSessionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(/* @__PURE__ */ new Map());\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!sessionStorage) return;\n    const currentSessions = sessions;\n    const prevSessions = prevSessionsRef.current;\n    prevSessions.forEach((_, pubkey) => {\n      if (!currentSessions.has(pubkey)) {\n        console.log(`Session ${pubkey} detected as removed, updating storage.`);\n        removeStoredSession(sessionStorage, pubkey);\n      }\n    });\n    prevSessionsRef.current = new Map(currentSessions);\n  }, [sessions, sessionStorage]);\n  return null;\n}\n\n// src/mutes/hooks/use-is-item-muted.ts\n\n\n\n// src/mutes/hooks/use-mute-criteria.ts\n\n\n// src/mutes/hooks/use-mute-filter.ts\n\n\n// src/utils/mute.ts\nvar isMuted = (event, criteria) => {\n  if (!criteria) return false;\n  const { pubkeys, eventIds, hashtags, words } = criteria;\n  if (pubkeys.has(event.pubkey)) return true;\n  if (eventIds.has(event.id)) return true;\n  if (eventIds.size > 0 || hashtags.size > 0) {\n    for (const tag of event.tags) {\n      if (tag[0] === \"e\" && eventIds.has(tag[1])) return true;\n      if (tag[0] === \"t\" && hashtags.has(tag[1])) return true;\n    }\n  }\n  if (words && words.size > 0 && event.content) {\n    const wordsInContent = event.content.split(/\\s+/).map((word) => word.toLowerCase());\n    for (const word of wordsInContent) {\n      if (words.has(word)) return true;\n    }\n  }\n  return false;\n};\n\n// src/mutes/hooks/use-mute-filter.ts\nvar EMPTY_MUTE_CRITERIA = {\n  pubkeys: /* @__PURE__ */ new Set(),\n  eventIds: /* @__PURE__ */ new Set(),\n  hashtags: /* @__PURE__ */ new Set(),\n  words: /* @__PURE__ */ new Set()\n};\nfunction useMuteFilter() {\n  const muteCriteria = useActiveMuteCriteria();\n  console.log(\"useMuteFilter\", muteCriteria);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (event) => {\n      return isMuted(event, muteCriteria);\n    },\n    [muteCriteria]\n  );\n}\n\n// src/mutes/hooks/use-mute-criteria.ts\nfunction useActiveMuteCriteria() {\n  return useNDKMutes((s) => s.muteCriteria);\n}\nfunction useMuteCriteria(pubkey) {\n  const mutesForPubkey = useNDKMutes((s) => pubkey ? s.mutes.get(pubkey) : EMPTY_MUTE_CRITERIA);\n  const extraMutes = useNDKMutes((s) => s.extraMutes);\n  const [criteria, setCriteria] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(EMPTY_MUTE_CRITERIA);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const combinedMutes = {\n      eventIds: /* @__PURE__ */ new Set([...mutesForPubkey?.eventIds || [], ...extraMutes?.eventIds || []]),\n      hashtags: /* @__PURE__ */ new Set([...mutesForPubkey?.hashtags || [], ...extraMutes?.hashtags || []]),\n      words: /* @__PURE__ */ new Set([...mutesForPubkey?.words || [], ...extraMutes?.words || []]),\n      pubkeys: /* @__PURE__ */ new Set([...mutesForPubkey?.pubkeys || [], ...extraMutes?.pubkeys || []])\n    };\n    setCriteria(combinedMutes);\n  }, [\n    mutesForPubkey?.eventIds,\n    mutesForPubkey?.hashtags,\n    mutesForPubkey?.words,\n    mutesForPubkey?.pubkeys,\n    extraMutes?.eventIds,\n    extraMutes?.hashtags,\n    extraMutes?.words,\n    extraMutes?.pubkeys\n  ]);\n  return criteria;\n}\n\n// src/mutes/hooks/use-is-item-muted.ts\nfunction useIsItemMuted(item) {\n  const muteCriteria = useActiveMuteCriteria();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    let itemType;\n    let value;\n    if (item instanceof _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKEvent) {\n      itemType = \"event\";\n      value = item.id;\n    } else if (item instanceof _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKUser) {\n      itemType = \"pubkey\";\n      value = item.pubkey;\n    } else if (typeof item === \"string\") {\n      if (item.startsWith(\"#\") && item.length > 1) {\n        itemType = \"hashtag\";\n        value = item.substring(1);\n      } else {\n        itemType = \"word\";\n        value = item;\n      }\n    } else {\n      return false;\n    }\n    switch (itemType) {\n      case \"event\":\n        return muteCriteria.eventIds.has(value);\n      case \"pubkey\":\n        return muteCriteria.pubkeys.has(value);\n      case \"hashtag\":\n        return muteCriteria.hashtags.has(value);\n      case \"word\":\n        return muteCriteria.words.has(value);\n      default:\n        return false;\n    }\n  }, [muteCriteria, item]);\n}\n\n// src/mutes/hooks/use-mute-item.ts\n\nfunction useMuteItem(options) {\n  const currentPubkey = useNDKCurrentPubkey();\n  const muteItem2 = useNDKMutes((s) => s.muteItem);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (item) => {\n      if (!currentPubkey) {\n        console.warn(\"useMuteItem: No active user found. Cannot mute item.\");\n        return;\n      }\n      const identified = identifyMuteItem(item);\n      if (!identified) return;\n      const { type, value } = identified;\n      muteItem2(currentPubkey, value, type, options);\n    },\n    [currentPubkey, muteItem2, options]\n  );\n}\n\n// src/mutes/hooks/use-publish-mute-list.ts\n\nfunction usePublishMuteList() {\n  const currentPubkey = useNDKCurrentPubkey();\n  const publishMuteList2 = useNDKMutes((s) => s.publishMuteList);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {\n    if (!currentPubkey) {\n      console.warn(\"usePublishMuteList: No active user found. Cannot publish mute list.\");\n      return void 0;\n    }\n    return publishMuteList2(currentPubkey);\n  }, [currentPubkey, publishMuteList2]);\n}\n\n// src/mutes/hooks/use-unmute-item.ts\n\n\nfunction useUnmuteItem(options) {\n  const currentPubkey = useNDKCurrentPubkey();\n  const unmuteItem2 = useNDKMutes((s) => s.unmuteItem);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (item) => {\n      if (!currentPubkey) {\n        console.warn(\"useUnmuteItem: No active user found. Cannot unmute item.\");\n        return;\n      }\n      let itemType;\n      let value;\n      if (item instanceof _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKEvent) {\n        itemType = \"event\";\n        value = item.id;\n      } else if (item instanceof _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKUser) {\n        itemType = \"pubkey\";\n        value = item.pubkey;\n      } else if (typeof item === \"string\") {\n        if (item.startsWith(\"#\") && item.length > 1) {\n          itemType = \"hashtag\";\n          value = item.substring(1);\n        } else {\n          itemType = \"word\";\n          value = item;\n        }\n      } else {\n        console.warn(\"useUnmuteItem: Invalid item type provided.\", item);\n        return;\n      }\n      unmuteItem2(currentPubkey, value, itemType, options);\n    },\n    [currentPubkey, unmuteItem2, options]\n  );\n}\n\n// src/observer/hooks/index.ts\n\n\nfunction useObserver(filters, opts = {}, dependencies = []) {\n  const { ndk } = useNDK();\n  const sub = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const [events, setEvents] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const buffer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n  const bufferTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const addedEventIds = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(/* @__PURE__ */ new Set());\n  console.log(\"useObserver\");\n  const muteFilter = useMuteFilter();\n  dependencies.push(!!filters);\n  const stopFilters = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (sub.current) sub.current.stop();\n    sub.current = null;\n    buffer.current = [];\n    if (bufferTimeout.current) {\n      clearTimeout(bufferTimeout.current);\n      bufferTimeout.current = null;\n    }\n    addedEventIds.current.clear();\n    setEvents([]);\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!ndk || !filters) return;\n    let isValid = true;\n    if (sub.current) stopFilters();\n    const processEvent2 = (event) => {\n      if (!isValid) return;\n      if (!opts.includeMuted && muteFilter(event)) return;\n      const tagId = event.tagId();\n      if (addedEventIds.current.has(tagId)) return;\n      addedEventIds.current.add(tagId);\n      buffer.current.push(event);\n      if (!bufferTimeout.current) {\n        bufferTimeout.current = setTimeout(() => {\n          setEvents((prev) => [...prev, ...buffer.current]);\n          buffer.current = [];\n          bufferTimeout.current = null;\n        }, 50);\n      }\n    };\n    sub.current = ndk.subscribe(\n      filters,\n      {\n        closeOnEose: true,\n        cacheUsage: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKSubscriptionCacheUsage.ONLY_CACHE,\n        groupable: false,\n        wrap: true,\n        ...opts\n      },\n      {\n        onEvent: (event) => {\n          if (!isValid) return;\n          processEvent2(event);\n        },\n        onEvents: (events2) => {\n          const filtered = !opts.includeMuted ? events2.filter((e) => !muteFilter(e)) : events2;\n          setEvents(filtered);\n        }\n      }\n    );\n    if (buffer.current.length > 0) {\n      if (bufferTimeout.current) {\n        clearTimeout(bufferTimeout.current);\n        bufferTimeout.current = null;\n      }\n      buffer.current = [];\n    }\n    return () => {\n      isValid = false;\n      stopFilters();\n    };\n  }, [ndk, ...dependencies]);\n  return events;\n}\n\n// src/subscribe/hooks/subscribe.ts\n\n\n\n// src/subscribe/store/index.ts\n\nvar createSubscribeStore = (bufferMs = 30) => {\n  const store = (0,zustand_vanilla__WEBPACK_IMPORTED_MODULE_6__.createStore)((set, get) => {\n    const buffer = /* @__PURE__ */ new Map();\n    let timeout = null;\n    const flushBuffer = () => {\n      const state = get();\n      const newEventMap = new Map(state.eventMap);\n      let hasChanges = false;\n      for (const [id, event] of buffer.entries()) {\n        const existingEvent = newEventMap.get(id);\n        if (!existingEvent || existingEvent.created_at !== void 0 && event.created_at !== void 0 && event.created_at > existingEvent.created_at) {\n          newEventMap.set(id, event);\n          hasChanges = true;\n        }\n      }\n      buffer.clear();\n      if (hasChanges) {\n        const newEvents = Array.from(newEventMap.values());\n        set({ eventMap: newEventMap, events: newEvents });\n      }\n      timeout = null;\n    };\n    return {\n      events: [],\n      eventMap: /* @__PURE__ */ new Map(),\n      eose: false,\n      subscriptionRef: void 0,\n      addEvent: (event) => {\n        const id = event.tagId();\n        if (bufferMs !== false) {\n          const existingInBuffer = buffer.get(id);\n          const existingInStore = get().eventMap.get(id);\n          if (existingInBuffer && existingInBuffer.created_at !== void 0 && event.created_at !== void 0 && existingInBuffer.created_at >= event.created_at) {\n            return;\n          }\n          if (existingInStore && existingInStore.created_at !== void 0 && event.created_at !== void 0 && existingInStore.created_at >= event.created_at) {\n            return;\n          }\n          buffer.set(id, event);\n          if (!timeout) {\n            timeout = setTimeout(flushBuffer, bufferMs);\n          }\n        } else {\n          const state = get();\n          const newEventMap = new Map(state.eventMap);\n          const existingEvent = newEventMap.get(id);\n          if (existingEvent && existingEvent.created_at !== void 0 && event.created_at !== void 0 && existingEvent.created_at >= event.created_at) {\n            return;\n          }\n          newEventMap.set(id, event);\n          const newEvents = Array.from(newEventMap.values());\n          set({ eventMap: newEventMap, events: newEvents });\n        }\n      },\n      addEvents: (events) => {\n        if (!events || events.length === 0) return;\n        if (bufferMs !== false) {\n          let needsFlush = false;\n          for (const event of events) {\n            if (!event) continue;\n            const id = event.tagId();\n            const existingInBuffer = buffer.get(id);\n            const existingInStore = get().eventMap.get(id);\n            if (existingInBuffer && existingInBuffer.created_at !== void 0 && event.created_at !== void 0 && existingInBuffer.created_at >= event.created_at) {\n              continue;\n            }\n            if (existingInStore && existingInStore.created_at !== void 0 && event.created_at !== void 0 && existingInStore.created_at >= event.created_at) {\n              continue;\n            }\n            buffer.set(id, event);\n            needsFlush = true;\n          }\n          if (needsFlush && !timeout) {\n            timeout = setTimeout(flushBuffer, bufferMs);\n          }\n        } else {\n          const state = get();\n          const newEventMap = new Map(state.eventMap);\n          let hasUpdates = false;\n          for (const event of events) {\n            if (!event) continue;\n            const id = event.tagId();\n            const existingEvent = newEventMap.get(id);\n            if (existingEvent && existingEvent.created_at !== void 0 && event.created_at !== void 0 && existingEvent.created_at >= event.created_at) {\n              continue;\n            }\n            newEventMap.set(id, event);\n            hasUpdates = true;\n          }\n          if (hasUpdates) {\n            const newEvents = Array.from(newEventMap.values());\n            set({ eventMap: newEventMap, events: newEvents });\n          }\n        }\n      },\n      removeEventId: (id) => {\n        const state = get();\n        const newEventMap = new Map(state.eventMap);\n        newEventMap.delete(id);\n        const newEvents = Array.from(newEventMap.values());\n        set({ eventMap: newEventMap, events: newEvents });\n      },\n      filterMutedEvents: (muteFilter) => {\n        const state = get();\n        const currentEventMap = state.eventMap;\n        const newEventMap = /* @__PURE__ */ new Map();\n        for (const [id, event] of currentEventMap.entries()) {\n          if (!muteFilter(event)) {\n            newEventMap.set(id, event);\n          }\n        }\n        const newEvents = Array.from(newEventMap.values());\n        set({ eventMap: newEventMap, events: newEvents });\n      },\n      setEose: () => {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n          flushBuffer();\n        }\n        set({ eose: true });\n        if (bufferMs !== false) {\n          bufferMs = 16;\n        }\n      },\n      reset: () => {\n        buffer.clear();\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        set({\n          events: [],\n          eventMap: /* @__PURE__ */ new Map(),\n          eose: false,\n          subscriptionRef: void 0\n        });\n      }\n    };\n  });\n  return store;\n};\n\n// src/subscribe/hooks/subscribe.ts\nfunction useSubscribe(filters, opts = {}, dependencies = []) {\n  const { ndk } = useNDK();\n  const muteFilter = useMuteFilter();\n  const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  if (!storeRef.current) {\n    storeRef.current = createSubscribeStore(opts.bufferMs);\n  }\n  const store = storeRef.current;\n  const subRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!ndk || !filters) return;\n    if (subRef.current) {\n      subRef.current.stop();\n      subRef.current = null;\n    }\n    const setupSubscription = () => {\n      const currentFilters = filters;\n      const handleEvent = (event) => {\n        if (!opts.includeDeleted && event.hasTag(\"deleted\")) {\n          return;\n        }\n        if (!opts.includeMuted && muteFilter(event)) {\n          return;\n        }\n        event.once(\"deleted\", () => {\n          const state2 = store.getState();\n          state2.removeEventId(event.tagId());\n        });\n        const state = store.getState();\n        state.addEvent(event);\n      };\n      const handleCachedEvents = (events2) => {\n        if (events2 && events2.length > 0) {\n          const validEvents = events2.filter((e) => {\n            if (!opts.includeDeleted && e.hasTag(\"deleted\")) return false;\n            if (!opts.includeMuted && muteFilter(e)) return false;\n            return true;\n          });\n          if (validEvents.length > 0) {\n            const state = store.getState();\n            state.addEvents(validEvents);\n            for (const evt of validEvents) {\n              evt.once(\"deleted\", () => {\n                const state2 = store.getState();\n                state2.removeEventId(evt.tagId());\n              });\n            }\n          }\n        }\n      };\n      const handleEose = () => {\n        const state = store.getState();\n        state.setEose();\n      };\n      const sub = ndk.subscribe(currentFilters, opts, {\n        onEvent: handleEvent,\n        onEvents: handleCachedEvents,\n        onEose: handleEose\n      });\n      subRef.current = sub;\n    };\n    setupSubscription();\n    return () => {\n      if (subRef.current) {\n        subRef.current.stop();\n        subRef.current = null;\n      }\n    };\n  }, [ndk, muteFilter, !!filters, ...dependencies]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!opts.includeMuted) {\n      const state = store.getState();\n      state.filterMutedEvents(muteFilter);\n    }\n  }, [muteFilter, store, opts.includeMuted]);\n  const events = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.useStore)(store, (s) => s.events);\n  const eose = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.useStore)(store, (s) => s.eose);\n  return { events, eose };\n}\n\n// src/subscribe/hooks/event.ts\n\nfunction useEvent(idOrFilter, opts = {}, dependencies = []) {\n  const [event, setEvent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n  const { ndk } = useNDK();\n  dependencies.push(!!idOrFilter);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    async function fetchEvent() {\n      if (!ndk || !idOrFilter) return;\n      const events = await ndk.fetchEvent(idOrFilter, opts);\n      setEvent(events);\n    }\n    fetchEvent();\n  }, dependencies);\n  return event;\n}\n\n// src/session/hooks/use-available-sessions.ts\n\nvar useAvailableSessions = () => {\n  const sessions = useNDKSessions((state) => state.sessions);\n  const availablePubkeys = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => Array.from(sessions.keys()),\n    // Get keys from sessions map\n    [sessions]\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({ availablePubkeys }), [availablePubkeys]);\n};\n\n// src/wallet/hooks/index.ts\n\n\n\n\nvar useInternalWalletStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)((set) => ({\n  activeWallet: null,\n  balance: null,\n  setActiveWallet: (wallet) => set({ activeWallet: wallet }),\n  setBalance: (balance) => set({ balance })\n}));\nvar useNDKWallet = () => {\n  const { ndk } = useNDK();\n  const activeWallet = useInternalWalletStore((s) => s.activeWallet);\n  const storeSetActiveWallet = useInternalWalletStore((s) => s.setActiveWallet);\n  const balance = useInternalWalletStore((s) => s.balance);\n  const setBalance = useInternalWalletStore((s) => s.setBalance);\n  const setActiveWallet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (wallet) => {\n      if (!ndk) return;\n      let debounceTimer;\n      storeSetActiveWallet(wallet);\n      ndk.wallet = wallet ?? void 0;\n      const updateBalance = () => {\n        if (debounceTimer) clearTimeout(debounceTimer);\n        debounceTimer = setTimeout(() => {\n          const balanceObj = wallet?.balance;\n          const amount = balanceObj?.amount ?? null;\n          setBalance(amount);\n        }, 50);\n      };\n      if (wallet) {\n        wallet.on(\"ready\", updateBalance);\n        wallet.on(\"balance_updated\", updateBalance);\n        wallet.updateBalance?.();\n      } else {\n        setBalance(null);\n      }\n    },\n    [ndk, storeSetActiveWallet, setBalance]\n  );\n  return { activeWallet, setActiveWallet, balance, setBalance };\n};\nvar useInternalNutzapMonitorStore = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)((set) => ({\n  nutzapMonitor: null,\n  setNutzapMonitor: (monitor) => set({ nutzapMonitor: monitor })\n}));\nvar useNDKNutzapMonitor = (mintList, start = false) => {\n  const { ndk } = useNDK();\n  const currentUser = useNDKCurrentUser();\n  const { activeWallet } = useNDKWallet();\n  const nutzapMonitor = useInternalNutzapMonitorStore((s) => s.nutzapMonitor);\n  const setNutzapMonitor = useInternalNutzapMonitorStore((s) => s.setNutzapMonitor);\n  const [monitorStarted, setMonitorStarted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const monitorStore = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (ndk?.cacheAdapter?.getAllNutzapStates && ndk?.cacheAdapter?.setNutzapState) {\n      const boundGetAll = ndk.cacheAdapter.getAllNutzapStates.bind(ndk.cacheAdapter);\n      const boundSetState = ndk.cacheAdapter.setNutzapState.bind(ndk.cacheAdapter);\n      return {\n        getAllNutzaps: boundGetAll,\n        setNutzapState: boundSetState\n      };\n    }\n    return void 0;\n  }, [ndk?.cacheAdapter]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!ndk || !currentUser?.pubkey || !activeWallet) {\n      if (nutzapMonitor) {\n        console.log(\"Stopping NDKNutzapMonitor due to missing dependencies\");\n        nutzapMonitor.stop();\n        setNutzapMonitor(null);\n        setMonitorStarted(false);\n      }\n      return;\n    }\n    if (!nutzapMonitor && start) {\n      console.log(\"Initializing NDKNutzapMonitor\");\n      const monitor = new _nostr_dev_kit_ndk_wallet__WEBPACK_IMPORTED_MODULE_7__.NDKNutzapMonitor(ndk, currentUser, {\n        mintList,\n        store: monitorStore\n      });\n      monitor.wallet = activeWallet;\n      setNutzapMonitor(monitor);\n    } else if (nutzapMonitor) {\n      if (nutzapMonitor.wallet?.walletId !== activeWallet.walletId) {\n        console.log(\"Updating wallet in NDKNutzapMonitor\");\n        nutzapMonitor.wallet = activeWallet;\n      }\n      if (nutzapMonitor.mintList !== mintList) {\n        console.log(\"Updating mintList in NDKNutzapMonitor\");\n        nutzapMonitor.mintList = mintList;\n      }\n    }\n  }, [ndk, currentUser, activeWallet, mintList, monitorStore, nutzapMonitor, setNutzapMonitor, start]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (start && nutzapMonitor && !monitorStarted) {\n      console.log(\"Starting NDKNutzapMonitor\");\n      nutzapMonitor.start({\n        filter: { limit: 100 },\n        opts: { skipVerification: true }\n      }).then(() => {\n        setMonitorStarted(true);\n        console.log(\"NDKNutzapMonitor started successfully\");\n      }).catch((err) => {\n        console.error(\"Failed to start NDKNutzapMonitor\", err);\n      });\n    } else if (!start && nutzapMonitor && monitorStarted) {\n      console.log(\"Stopping NDKNutzapMonitor\");\n      nutzapMonitor.stop();\n      setMonitorStarted(false);\n    }\n    return () => {\n      if (nutzapMonitor && monitorStarted) {\n        console.log(\"Stopping NDKNutzapMonitor on cleanup\");\n        nutzapMonitor.stop();\n        setMonitorStarted(false);\n      }\n    };\n  }, [start, nutzapMonitor, monitorStarted]);\n  return { nutzapMonitor };\n};\n\n// src/index.ts\n\n\nvar index_default = _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWhvb2tzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN5RTs7QUFFekU7QUFDMEU7O0FBRTFFO0FBQ2lDOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDLElBQUk7QUFDSixVQUFVLEtBQUs7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDs7QUFFQTtBQUNBLDJCQUEyQiwrQ0FBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDc0Q7QUFDVjtBQUNlOztBQUUzRDtBQUN5RDs7QUFFekQ7QUFDNEM7QUFDNUMsa0JBQWtCLCtDQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNxQztBQUNPO0FBQ0s7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUN1RDtBQUN2RDtBQUNBO0FBQ0E7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O0FBK0NyQiIsInNvdXJjZXMiOlsiL1VzZXJzL3BhYmxvZmVybmFuZGV6L3Rlc3QxMjMvVEVORVgtcGZrbWM5L21haW4vbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay1ob29rcy9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9zZXNzaW9uL2hvb2tzL2luZGV4LnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazMsIHVzZU1lbW8gYXMgdXNlTWVtbzIgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL25kay9ob29rcy9pbmRleC50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvcHJvZmlsZXMvc3RvcmUvaW5kZXgudHNcbmltcG9ydCB7IGNyZWF0ZSB9IGZyb20gXCJ6dXN0YW5kXCI7XG5cbi8vIHNyYy91dGlscy90aW1lLnRzXG52YXIgaW5TZWNvbmRzID0gKG1zKSA9PiBtcyAvIDFlMztcblxuLy8gc3JjL3Byb2ZpbGVzL3N0b3JlL2ZldGNoLXByb2ZpbGUudHNcbnZhciBmZXRjaFByb2ZpbGVJbXBsZW1lbnRhdGlvbiA9IChzZXQsIGdldCwgcHVia2V5LCBvcHRzKSA9PiB7XG4gIGNvbnN0IGZvcmNlID0gb3B0cz8ucmVmcmVzaDtcbiAgY29uc3QgeyBuZGssIHByb2ZpbGVzIH0gPSBnZXQoKTtcbiAgaWYgKCFuZGspIHtcbiAgICBjb25zb2xlLmVycm9yKFwiTkRLIGluc3RhbmNlIGlzIG5vdCBpbml0aWFsaXplZC4gRGlkIHlvdSB1c2UgdXNlTkRLSW5pdCBhdCB0aGUgYmVnaW5uaW5nIG9mIHlvdXIgYXBwP1wiKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFwdWJrZXkpIHJldHVybjtcbiAgY29uc3QgY3VycmVudFByb2ZpbGUgPSBwcm9maWxlcy5nZXQocHVia2V5KTtcbiAgaWYgKGN1cnJlbnRQcm9maWxlICYmICFmb3JjZSkgcmV0dXJuO1xuICBjb25zdCB1c2VyID0gbmRrLmdldFVzZXIoeyBwdWJrZXkgfSk7XG4gIHVzZXIuZmV0Y2hQcm9maWxlKG9wdHM/LnN1Yk9wdHMpLnRoZW4oKHByb2ZpbGUpID0+IHtcbiAgICBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBwcm9maWxlczIgPSBuZXcgTWFwKHN0YXRlLnByb2ZpbGVzKTtcbiAgICAgIGlmIChwcm9maWxlKSBwcm9maWxlczIuc2V0KHB1YmtleSwgcHJvZmlsZSk7XG4gICAgICBjb25zdCBsYXN0RmV0Y2hlZEF0ID0gbmV3IE1hcChzdGF0ZS5sYXN0RmV0Y2hlZEF0KTtcbiAgICAgIGxhc3RGZXRjaGVkQXQuc2V0KHB1YmtleSwgaW5TZWNvbmRzKERhdGUubm93KCkpKTtcbiAgICAgIHJldHVybiB7IHByb2ZpbGVzOiBwcm9maWxlczIsIGxhc3RGZXRjaGVkQXQgfTtcbiAgICB9KTtcbiAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGxhc3RGZXRjaGVkQXQgPSBuZXcgTWFwKHN0YXRlLmxhc3RGZXRjaGVkQXQpO1xuICAgICAgbGFzdEZldGNoZWRBdC5zZXQocHVia2V5LCBpblNlY29uZHMoRGF0ZS5ub3coKSkpO1xuICAgICAgcmV0dXJuIHsgbGFzdEZldGNoZWRBdCB9O1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8vIHNyYy9wcm9maWxlcy9zdG9yZS9pbml0aWFsaXplLnRzXG5mdW5jdGlvbiBpbml0aWFsaXplUHJvZmlsZXNTdG9yZShzZXQsIG5kaykge1xuICBjb25zdCBjYWNoZUFkYXB0ZXIgPSBuZGsuY2FjaGVBZGFwdGVyO1xuICBpZiAoY2FjaGVBZGFwdGVyPy5nZXRBbGxQcm9maWxlc1N5bmMpIHtcbiAgICBjb25zdCBrZXlzID0gY2FjaGVBZGFwdGVyLmdldEFsbFByb2ZpbGVzU3luYygpO1xuICAgIGNvbnN0IHByb2ZpbGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBsYXN0RmV0Y2hlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHByb2ZpbGVdIG9mIGtleXMpIHtcbiAgICAgIHByb2ZpbGVzLnNldChrZXksIHByb2ZpbGUpO1xuICAgICAgbGFzdEZldGNoZWRBdC5zZXQoa2V5LCBwcm9maWxlLmNhY2hlZEF0ID8/IDApO1xuICAgIH1cbiAgICBzZXQoeyBwcm9maWxlcywgbGFzdEZldGNoZWRBdCwgbmRrIH0pO1xuICB9IGVsc2Uge1xuICAgIHNldCh7IG5kayB9KTtcbiAgfVxufVxuXG4vLyBzcmMvcHJvZmlsZXMvc3RvcmUvc2V0LXByb2ZpbGUudHNcbnZhciBzZXRQcm9maWxlSW1wbGVtZW50YXRpb24gPSAoc2V0LCBwdWJrZXksIHByb2ZpbGUsIGNhY2hlZEF0KSA9PiB7XG4gIHNldCgoc3RhdGUpID0+IHtcbiAgICBjb25zdCBuZXdQcm9maWxlcyA9IG5ldyBNYXAoc3RhdGUucHJvZmlsZXMpO1xuICAgIG5ld1Byb2ZpbGVzLnNldChwdWJrZXksIHByb2ZpbGUpO1xuICAgIGNvbnN0IG5ld0xhc3RGZXRjaGVkQXQgPSBuZXcgTWFwKHN0YXRlLmxhc3RGZXRjaGVkQXQpO1xuICAgIG5ld0xhc3RGZXRjaGVkQXQuc2V0KHB1YmtleSwgY2FjaGVkQXQgPz8gaW5TZWNvbmRzKERhdGUubm93KCkpKTtcbiAgICByZXR1cm4geyBwcm9maWxlczogbmV3UHJvZmlsZXMsIGxhc3RGZXRjaGVkQXQ6IG5ld0xhc3RGZXRjaGVkQXQgfTtcbiAgfSk7XG59O1xuXG4vLyBzcmMvcHJvZmlsZXMvc3RvcmUvaW5kZXgudHNcbnZhciB1c2VVc2VyUHJvZmlsZXNTdG9yZSA9IGNyZWF0ZSgoc2V0LCBnZXQpID0+ICh7XG4gIHByb2ZpbGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICBsYXN0RmV0Y2hlZEF0OiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICBuZGs6IHZvaWQgMCxcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBpbml0aWFsaXplOiAobmRrKSA9PiBpbml0aWFsaXplUHJvZmlsZXNTdG9yZShzZXQsIG5kayksXG4gIHNldFByb2ZpbGU6IChwdWJrZXksIHByb2ZpbGUsIGNhY2hlZEF0KSA9PiBzZXRQcm9maWxlSW1wbGVtZW50YXRpb24oc2V0LCBwdWJrZXksIHByb2ZpbGUsIGNhY2hlZEF0KSxcbiAgZmV0Y2hQcm9maWxlOiAocHVia2V5LCBvcHRzKSA9PiBmZXRjaFByb2ZpbGVJbXBsZW1lbnRhdGlvbihzZXQsIGdldCwgcHVia2V5LCBvcHRzKVxufSkpO1xuXG4vLyBzcmMvc2Vzc2lvbi9zdG9yZS9pbmRleC50c1xuaW1wb3J0IHsgZW5hYmxlTWFwU2V0IGFzIGVuYWJsZU1hcFNldDIgfSBmcm9tIFwiaW1tZXJcIjtcbmltcG9ydCB7IGNyZWF0ZSBhcyBjcmVhdGU0IH0gZnJvbSBcInp1c3RhbmRcIjtcbmltcG9ydCB7IGltbWVyIGFzIGltbWVyMiB9IGZyb20gXCJ6dXN0YW5kL21pZGRsZXdhcmUvaW1tZXJcIjtcblxuLy8gc3JjL3Nlc3Npb24vc3RvcmUvYWRkLXNlc3Npb24udHNcbmltcG9ydCB7IE5ES1VzZXIgYXMgTkRLVXNlcjIgfSBmcm9tIFwiQG5vc3RyLWRldi1raXQvbmRrXCI7XG5cbi8vIHNyYy9uZGsvc3RvcmUvaW5kZXgudHNcbmltcG9ydCB7IGNyZWF0ZSBhcyBjcmVhdGUyIH0gZnJvbSBcInp1c3RhbmRcIjtcbnZhciB1c2VOREtTdG9yZSA9IGNyZWF0ZTIoKHNldCkgPT4ge1xuICByZXR1cm4ge1xuICAgIG5kazogbnVsbCxcbiAgICAvLyBjdXJyZW50VXNlciByZW1vdmVkXG4gICAgc2V0TkRLOiAobmRrKSA9PiB7XG4gICAgICBzZXQoeyBuZGsgfSk7XG4gICAgfSxcbiAgICBzZXRTaWduZXI6IChzaWduZXIpID0+IHtcbiAgICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgaWYgKHN0YXRlLm5kaykge1xuICAgICAgICAgIHN0YXRlLm5kay5zaWduZXIgPSBzaWduZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbmRrOiBzdGF0ZS5uZGsgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0pO1xuXG4vLyBzcmMvbXV0ZXMvc3RvcmUvaW5kZXgudHNcbmltcG9ydCB7IGVuYWJsZU1hcFNldCB9IGZyb20gXCJpbW1lclwiO1xuaW1wb3J0IHsgY3JlYXRlIGFzIGNyZWF0ZTMgfSBmcm9tIFwienVzdGFuZFwiO1xuaW1wb3J0IHsgaW1tZXIgfSBmcm9tIFwienVzdGFuZC9taWRkbGV3YXJlL2ltbWVyXCI7XG5cbi8vIHNyYy9tdXRlcy9zdG9yZS9pbml0LnRzXG52YXIgaW5pdE11dGVzID0gKHNldCwgZ2V0LCBwdWJrZXkpID0+IHtcbiAgc2V0KChzdGF0ZSkgPT4ge1xuICAgIGlmICghc3RhdGUubXV0ZXMuaGFzKHB1YmtleSkpIHtcbiAgICAgIHN0YXRlLm11dGVzLnNldChwdWJrZXksIHtcbiAgICAgICAgcHVia2V5czogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgICAgaGFzaHRhZ3M6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICAgIHdvcmRzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgICBldmVudElkczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIHNyYy9tdXRlcy9zdG9yZS9sb2FkLnRzXG52YXIgbG9hZE11dGVMaXN0ID0gKHNldCwgZ2V0LCBwdWJrZXksIGV2ZW50KSA9PiB7XG4gIHNldCgoc3RhdGUpID0+IHtcbiAgICBpZiAoIXN0YXRlLm11dGVzLmhhcyhwdWJrZXkpKSB7XG4gICAgICBpbml0TXV0ZXMoc2V0LCBnZXQsIHB1YmtleSk7XG4gICAgfVxuICAgIGNvbnN0IHVzZXJNdXRlcyA9IHN0YXRlLm11dGVzLmdldChwdWJrZXkpO1xuICAgIGlmICghdXNlck11dGVzKSByZXR1cm47XG4gICAgY29uc3QgbmV3TXV0ZWRQdWJrZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBuZXdNdXRlZEV2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgbmV3TXV0ZWRIYXNodGFncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgbmV3TXV0ZWRXb3JkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgZXZlbnQudGFncykge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJwXCIpIG5ld011dGVkUHVia2V5cy5hZGQodGFnWzFdKTtcbiAgICAgIGVsc2UgaWYgKHRhZ1swXSA9PT0gXCJlXCIpIG5ld011dGVkRXZlbnRzLmFkZCh0YWdbMV0pO1xuICAgICAgZWxzZSBpZiAodGFnWzBdID09PSBcInRcIikgbmV3TXV0ZWRIYXNodGFncy5hZGQodGFnWzFdKTtcbiAgICAgIGVsc2UgaWYgKHRhZ1swXSA9PT0gXCJ3b3JkXCIpIG5ld011dGVkV29yZHMuYWRkKHRhZ1sxXSk7XG4gICAgfVxuICAgIHVzZXJNdXRlcy5wdWJrZXlzID0gbmV3TXV0ZWRQdWJrZXlzO1xuICAgIHVzZXJNdXRlcy5ldmVudElkcyA9IG5ld011dGVkRXZlbnRzO1xuICAgIHVzZXJNdXRlcy5oYXNodGFncyA9IG5ld011dGVkSGFzaHRhZ3M7XG4gICAgdXNlck11dGVzLndvcmRzID0gbmV3TXV0ZWRXb3JkcztcbiAgICB1c2VyTXV0ZXMubXV0ZUxpc3RFdmVudCA9IGV2ZW50O1xuICB9KTtcbn07XG5cbi8vIHNyYy9tdXRlcy91dGlscy9jb21wdXRlLW11dGUtY3JpdGVyaWEudHNcbmZ1bmN0aW9uIGNvbXB1dGVNdXRlQ3JpdGVyaWEodXNlck11dGVzLCBleHRyYU11dGVzKSB7XG4gIHJldHVybiB7XG4gICAgcHVia2V5czogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAgICAgLi4udXNlck11dGVzPy5wdWJrZXlzID8/IFtdLFxuICAgICAgLi4uZXh0cmFNdXRlcy5wdWJrZXlzID8/IFtdXG4gICAgXSksXG4gICAgZXZlbnRJZHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgICAgIC4uLnVzZXJNdXRlcz8uZXZlbnRJZHMgPz8gW10sXG4gICAgICAuLi5leHRyYU11dGVzLmV2ZW50SWRzID8/IFtdXG4gICAgXSksXG4gICAgaGFzaHRhZ3M6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgICAgIC4uLnVzZXJNdXRlcz8uaGFzaHRhZ3MgPz8gW10sXG4gICAgICAuLi5leHRyYU11dGVzLmhhc2h0YWdzID8/IFtdXG4gICAgXSksXG4gICAgd29yZHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgICAgIC4uLnVzZXJNdXRlcz8ud29yZHMgPz8gW10sXG4gICAgICAuLi5leHRyYU11dGVzLndvcmRzID8/IFtdXG4gICAgXSlcbiAgfTtcbn1cblxuLy8gc3JjL211dGVzL3N0b3JlL211dGUtaXRlbS50c1xudmFyIG11dGVJdGVtID0gKHNldCwgZ2V0LCBwdWJrZXksIGl0ZW0sIHR5cGUsIG9wdGlvbnMpID0+IHtcbiAgc2V0KChzdGF0ZSkgPT4ge1xuICAgIGlmICghc3RhdGUubXV0ZXMuaGFzKHB1YmtleSkpIHtcbiAgICAgIGluaXRNdXRlcyhzZXQsIGdldCwgcHVia2V5KTtcbiAgICB9XG4gICAgY29uc3QgdXNlck11dGVzID0gc3RhdGUubXV0ZXMuZ2V0KHB1YmtleSk7XG4gICAgaWYgKCF1c2VyTXV0ZXMpIHJldHVybjtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJwdWJrZXlcIjpcbiAgICAgICAgdXNlck11dGVzLnB1YmtleXMuYWRkKGl0ZW0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICB1c2VyTXV0ZXMuZXZlbnRJZHMuYWRkKGl0ZW0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJoYXNodGFnXCI6XG4gICAgICAgIHVzZXJNdXRlcy5oYXNodGFncy5hZGQoaXRlbSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIndvcmRcIjpcbiAgICAgICAgdXNlck11dGVzLndvcmRzLmFkZChpdGVtKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5hY3RpdmVQdWJrZXkgPT09IHB1YmtleSkge1xuICAgICAgc3RhdGUubXV0ZUNyaXRlcmlhID0gY29tcHV0ZU11dGVDcml0ZXJpYSh1c2VyTXV0ZXMsIHN0YXRlLmV4dHJhTXV0ZXMpO1xuICAgIH1cbiAgfSk7XG4gIGlmIChvcHRpb25zPy5wdWJsaXNoICE9PSBmYWxzZSkge1xuICAgIGdldCgpLnB1Ymxpc2hNdXRlTGlzdChwdWJrZXkpO1xuICB9XG59O1xuXG4vLyBzcmMvbXV0ZXMvc3RvcmUvdW5tdXRlLWl0ZW0udHNcbnZhciB1bm11dGVJdGVtID0gKHNldCwgZ2V0LCBwdWJrZXksIGl0ZW0sIHR5cGUsIG9wdGlvbnMpID0+IHtcbiAgc2V0KChzdGF0ZSkgPT4ge1xuICAgIGNvbnN0IHVzZXJNdXRlcyA9IHN0YXRlLm11dGVzLmdldChwdWJrZXkpO1xuICAgIGlmICghdXNlck11dGVzKSByZXR1cm47XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwicHVia2V5XCI6XG4gICAgICAgIHVzZXJNdXRlcy5wdWJrZXlzLmRlbGV0ZShpdGVtKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgdXNlck11dGVzLmV2ZW50SWRzLmRlbGV0ZShpdGVtKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaGFzaHRhZ1wiOlxuICAgICAgICB1c2VyTXV0ZXMuaGFzaHRhZ3MuZGVsZXRlKGl0ZW0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ3b3JkXCI6XG4gICAgICAgIHVzZXJNdXRlcy53b3Jkcy5kZWxldGUoaXRlbSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuYWN0aXZlUHVia2V5ID09PSBwdWJrZXkpIHtcbiAgICAgIHN0YXRlLm11dGVDcml0ZXJpYSA9IGNvbXB1dGVNdXRlQ3JpdGVyaWEodXNlck11dGVzLCBzdGF0ZS5leHRyYU11dGVzKTtcbiAgICB9XG4gIH0pO1xuICBpZiAob3B0aW9ucz8ucHVibGlzaCAhPT0gZmFsc2UpIHtcbiAgICBnZXQoKS5wdWJsaXNoTXV0ZUxpc3QocHVia2V5KTtcbiAgfVxufTtcblxuLy8gc3JjL211dGVzL3N0b3JlL3NldC1hY3RpdmUtcHVia2V5LnRzXG5mdW5jdGlvbiBzZXRBY3RpdmVQdWJrZXkoc2V0LCBwdWJrZXkpIHtcbiAgc2V0KChzdGF0ZSkgPT4ge1xuICAgIHN0YXRlLmFjdGl2ZVB1YmtleSA9IHB1YmtleTtcbiAgICBjb25zdCB1c2VyTXV0ZXMgPSBwdWJrZXkgPyBzdGF0ZS5tdXRlcy5nZXQocHVia2V5KSA6IHZvaWQgMDtcbiAgICBzdGF0ZS5tdXRlQ3JpdGVyaWEgPSBjb21wdXRlTXV0ZUNyaXRlcmlhKHVzZXJNdXRlcywgc3RhdGUuZXh0cmFNdXRlcyk7XG4gIH0pO1xufVxuXG4vLyBzcmMvbXV0ZXMvc3RvcmUvcHVibGlzaC50c1xudmFyIHB1Ymxpc2hNdXRlTGlzdCA9IGFzeW5jIChnZXQsIHB1YmtleSkgPT4ge1xuICBjb25zdCB1c2VyTXV0ZXMgPSBnZXQoKS5tdXRlcy5nZXQocHVia2V5KTtcbiAgaWYgKCF1c2VyTXV0ZXMpIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IG5kayA9IHVzZU5ES1Nlc3Npb25zLmdldFN0YXRlKCkubmRrO1xuICBpZiAoIW5kaykgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgZXZlbnQgPSBuZXcgbmRrLk5ES0V2ZW50KG5kayk7XG4gIGV2ZW50LmtpbmQgPSAxZTQ7XG4gIGV2ZW50LmNvbnRlbnQgPSBcIlwiO1xuICBmb3IgKGNvbnN0IG11dGVkUHVia2V5IG9mIHVzZXJNdXRlcy5wdWJrZXlzKSB7XG4gICAgZXZlbnQudGFncy5wdXNoKFtcInBcIiwgbXV0ZWRQdWJrZXldKTtcbiAgfVxuICBmb3IgKGNvbnN0IG11dGVkRXZlbnRJZCBvZiB1c2VyTXV0ZXMuZXZlbnRJZHMpIHtcbiAgICBldmVudC50YWdzLnB1c2goW1wiZVwiLCBtdXRlZEV2ZW50SWRdKTtcbiAgfVxuICBmb3IgKGNvbnN0IG11dGVkSGFzaHRhZyBvZiB1c2VyTXV0ZXMuaGFzaHRhZ3MpIHtcbiAgICBldmVudC50YWdzLnB1c2goW1widFwiLCBtdXRlZEhhc2h0YWddKTtcbiAgfVxuICBmb3IgKGNvbnN0IG11dGVkV29yZCBvZiB1c2VyTXV0ZXMud29yZHMpIHtcbiAgICBldmVudC50YWdzLnB1c2goW1wid29yZFwiLCBtdXRlZFdvcmRdKTtcbiAgfVxuICB0cnkge1xuICAgIGF3YWl0IGV2ZW50LnNpZ24oKTtcbiAgICBhd2FpdCBldmVudC5wdWJsaXNoKCk7XG4gICAgZ2V0KCkubG9hZE11dGVMaXN0KHB1YmtleSwgZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHB1Ymxpc2ggbXV0ZSBsaXN0OlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcblxuLy8gc3JjL211dGVzL3V0aWxzL2lkZW50aWZ5LW11dGUtaXRlbS50c1xuaW1wb3J0IHsgTkRLRXZlbnQsIE5ES1VzZXIgfSBmcm9tIFwiQG5vc3RyLWRldi1raXQvbmRrXCI7XG5mdW5jdGlvbiBpZGVudGlmeU11dGVJdGVtKGl0ZW0pIHtcbiAgbGV0IGl0ZW1UeXBlO1xuICBsZXQgdmFsdWU7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICBpdGVtVHlwZSA9IFwiZXZlbnRcIjtcbiAgICB2YWx1ZSA9IGl0ZW0uaWQ7XG4gIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES1VzZXIpIHtcbiAgICBpdGVtVHlwZSA9IFwicHVia2V5XCI7XG4gICAgdmFsdWUgPSBpdGVtLnB1YmtleTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChpdGVtLnN0YXJ0c1dpdGgoXCIjXCIpICYmIGl0ZW0ubGVuZ3RoID4gMSkge1xuICAgICAgaXRlbVR5cGUgPSBcImhhc2h0YWdcIjtcbiAgICAgIHZhbHVlID0gaXRlbS5zdWJzdHJpbmcoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW1UeXBlID0gXCJ3b3JkXCI7XG4gICAgICB2YWx1ZSA9IGl0ZW07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybihcImlkZW50aWZ5TXV0ZUl0ZW06IEludmFsaWQgaXRlbSB0eXBlIHByb3ZpZGVkLlwiLCBpdGVtKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB7IHR5cGU6IGl0ZW1UeXBlLCB2YWx1ZSB9O1xufVxuXG4vLyBzcmMvbXV0ZXMvc3RvcmUvYWRkLWV4dHJhLW11dGUtaXRlbXMudHNcbnZhciBhZGRFeHRyYU11dGVJdGVtcyA9IChzZXQsIGdldCwgaXRlbXMpID0+IHtcbiAgc2V0KChzdGF0ZSkgPT4ge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgY29uc3QgaWRlbnRpZmllZCA9IGlkZW50aWZ5TXV0ZUl0ZW0oaXRlbSk7XG4gICAgICBpZiAoIWlkZW50aWZpZWQpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gaWRlbnRpZmllZDtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwicHVia2V5XCI6XG4gICAgICAgICAgc3RhdGUuZXh0cmFNdXRlcy5wdWJrZXlzLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgIHN0YXRlLmV4dHJhTXV0ZXMuZXZlbnRJZHMuYWRkKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImhhc2h0YWdcIjpcbiAgICAgICAgICBzdGF0ZS5leHRyYU11dGVzLmhhc2h0YWdzLmFkZCh2YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIndvcmRcIjpcbiAgICAgICAgICBzdGF0ZS5leHRyYU11dGVzLndvcmRzLmFkZCh2YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXNlck11dGVzID0gc3RhdGUuYWN0aXZlUHVia2V5ID8gc3RhdGUubXV0ZXMuZ2V0KHN0YXRlLmFjdGl2ZVB1YmtleSkgOiB2b2lkIDA7XG4gICAgc3RhdGUubXV0ZUNyaXRlcmlhID0gY29tcHV0ZU11dGVDcml0ZXJpYSh1c2VyTXV0ZXMsIHN0YXRlLmV4dHJhTXV0ZXMpO1xuICB9KTtcbn07XG5cbi8vIHNyYy9tdXRlcy9zdG9yZS9pbmRleC50c1xuZW5hYmxlTWFwU2V0KCk7XG52YXIgbXV0ZXNTdGF0ZUNyZWF0b3IgPSAoc2V0LCBnZXQpID0+ICh7XG4gIG11dGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICBleHRyYU11dGVzOiB7XG4gICAgcHVia2V5czogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICBoYXNodGFnczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICB3b3JkczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICBldmVudElkczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICB9LFxuICBhY3RpdmVQdWJrZXk6IG51bGwsXG4gIG11dGVDcml0ZXJpYToge1xuICAgIHB1YmtleXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgZXZlbnRJZHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgaGFzaHRhZ3M6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgd29yZHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgfSxcbiAgaW5pdE11dGVzOiAocHVia2V5KSA9PiBpbml0TXV0ZXMoc2V0LCBnZXQsIHB1YmtleSksXG4gIGxvYWRNdXRlTGlzdDogKHB1YmtleSwgZXZlbnQpID0+IGxvYWRNdXRlTGlzdChzZXQsIGdldCwgcHVia2V5LCBldmVudCksXG4gIG11dGVJdGVtOiAocHVia2V5LCBpdGVtLCB0eXBlLCBvcHRpb25zKSA9PiBtdXRlSXRlbShzZXQsIGdldCwgcHVia2V5LCBpdGVtLCB0eXBlLCBvcHRpb25zKSxcbiAgdW5tdXRlSXRlbTogKHB1YmtleSwgaXRlbSwgdHlwZSwgb3B0aW9ucykgPT4gdW5tdXRlSXRlbShzZXQsIGdldCwgcHVia2V5LCBpdGVtLCB0eXBlLCBvcHRpb25zKSxcbiAgc2V0QWN0aXZlUHVia2V5OiAocHVia2V5KSA9PiBzZXRBY3RpdmVQdWJrZXkoc2V0LCBwdWJrZXkpLFxuICBhZGRFeHRyYU11dGVJdGVtczogKGl0ZW1zKSA9PiBhZGRFeHRyYU11dGVJdGVtcyhzZXQsIGdldCwgaXRlbXMpLFxuICBwdWJsaXNoTXV0ZUxpc3Q6IChwdWJrZXkpID0+IHB1Ymxpc2hNdXRlTGlzdChnZXQsIHB1YmtleSlcbn0pO1xudmFyIHVzZU5ES011dGVzID0gY3JlYXRlMyhpbW1lcihtdXRlc1N0YXRlQ3JlYXRvcikpO1xuXG4vLyBzcmMvc2Vzc2lvbi9zdG9yZS9hZGQtc2Vzc2lvbi50c1xudmFyIGNyZWF0ZURlZmF1bHRTZXNzaW9uID0gKHB1YmtleSkgPT4gKHtcbiAgcHVia2V5LFxuICBldmVudHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gIGxhc3RBY3RpdmU6IERhdGUubm93KCkgLyAxZTNcbn0pO1xudmFyIGFkZFNlc3Npb24gPSBhc3luYyAoc2V0LCBnZXQsIHVzZXJPclNpZ25lciwgc2V0QWN0aXZlID0gdHJ1ZSkgPT4ge1xuICBsZXQgdXNlcjtcbiAgbGV0IHNpZ25lciA9IHZvaWQgMDtcbiAgbGV0IHVzZXJQdWJrZXk7XG4gIGlmICh1c2VyT3JTaWduZXIgaW5zdGFuY2VvZiBOREtVc2VyMikge1xuICAgIHVzZXIgPSB1c2VyT3JTaWduZXI7XG4gICAgdXNlclB1YmtleSA9IHVzZXIucHVia2V5O1xuICB9IGVsc2Uge1xuICAgIHNpZ25lciA9IHVzZXJPclNpZ25lcjtcbiAgICB0cnkge1xuICAgICAgdXNlciA9IGF3YWl0IHNpZ25lci51c2VyKCk7XG4gICAgICB1c2VyUHVia2V5ID0gdXNlci5wdWJrZXk7XG4gICAgICBzZXQoKGRyYWZ0KSA9PiB7XG4gICAgICAgIGRyYWZ0LnNpZ25lcnMuc2V0KHVzZXJQdWJrZXksIHNpZ25lcik7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBnZXQgdXNlciBmcm9tIHNpZ25lcjpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJldHJpZXZlIHVzZXIgZnJvbSB0aGUgcHJvdmlkZWQgc2lnbmVyLlwiKTtcbiAgICB9XG4gIH1cbiAgc2V0KChkcmFmdCkgPT4ge1xuICAgIGxldCBzZXNzaW9uID0gZHJhZnQuc2Vzc2lvbnMuZ2V0KHVzZXJQdWJrZXkpO1xuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgc2Vzc2lvbiA9IGNyZWF0ZURlZmF1bHRTZXNzaW9uKHVzZXJQdWJrZXkpO1xuICAgICAgZHJhZnQuc2Vzc2lvbnMuc2V0KHVzZXJQdWJrZXksIHNlc3Npb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXNzaW9uLmxhc3RBY3RpdmUgPSBEYXRlLm5vdygpIC8gMWUzO1xuICAgICAgY29uc29sZS5kZWJ1ZyhgU2Vzc2lvbiBhbHJlYWR5IGV4aXN0cyBmb3IgJHt1c2VyUHVia2V5fSwgdXBkYXRpbmcgbGFzdEFjdGl2ZS5gKTtcbiAgICB9XG4gICAgaWYgKHNldEFjdGl2ZSkge1xuICAgICAgZHJhZnQuYWN0aXZlUHVia2V5ID0gdXNlclB1YmtleTtcbiAgICAgIHVzZU5ES1N0b3JlLmdldFN0YXRlKCkuc2V0U2lnbmVyKHNpZ25lcik7XG4gICAgfVxuICB9KTtcbiAgdXNlTkRLTXV0ZXMuZ2V0U3RhdGUoKS5pbml0TXV0ZXModXNlclB1YmtleSk7XG4gIGlmIChzZXRBY3RpdmUpIHtcbiAgICB1c2VOREtNdXRlcy5nZXRTdGF0ZSgpLnNldEFjdGl2ZVB1YmtleSh1c2VyUHVia2V5KTtcbiAgfVxuICByZXR1cm4gdXNlclB1YmtleTtcbn07XG5cbi8vIHNyYy9zZXNzaW9uL3N0b3JlL2luaXQudHNcbnZhciBpbml0ID0gKHNldCwgbmRrKSA9PiB7XG4gIHNldCgoZHJhZnQpID0+IHtcbiAgICBkcmFmdC5uZGsgPSBuZGs7XG4gIH0pO1xufTtcblxuLy8gc3JjL3Nlc3Npb24vc3RvcmUvcmVtb3ZlLXNlc3Npb24udHNcbnZhciByZW1vdmVTZXNzaW9uID0gKHNldCwgZ2V0LCBwdWJrZXkpID0+IHtcbiAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgY29uc3Qgc2Vzc2lvblRvUmVtb3ZlID0gc3RhdGUuc2Vzc2lvbnMuZ2V0KHB1YmtleSk7XG4gIGNvbnN0IHNpZ25lclRvUmVtb3ZlID0gc3RhdGUuc2lnbmVycy5nZXQocHVia2V5KTtcbiAgaWYgKCFzZXNzaW9uVG9SZW1vdmUpIHtcbiAgICBjb25zb2xlLndhcm4oYE5vIHNlc3Npb24gZm91bmQgdG8gcmVtb3ZlIGZvciBwdWJrZXk6ICR7cHVia2V5fWApO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2Vzc2lvblRvUmVtb3ZlLnN1YnNjcmlwdGlvbikge1xuICAgIGNvbnNvbGUuZGVidWcoYFN0b3BwaW5nIHN1YnNjcmlwdGlvbiBmb3IgcmVtb3ZlZCBzZXNzaW9uICR7cHVia2V5fWApO1xuICAgIHRyeSB7XG4gICAgICBzZXNzaW9uVG9SZW1vdmUuc3Vic2NyaXB0aW9uLnN0b3AoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igc3RvcHBpbmcgc3Vic2NyaXB0aW9uIGZvciByZW1vdmVkIHNlc3Npb24gJHtwdWJrZXl9OmAsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgd2FzQWN0aXZlID0gc3RhdGUuYWN0aXZlUHVia2V5ID09PSBwdWJrZXk7XG4gIHNldCgoZHJhZnQpID0+IHtcbiAgICBkcmFmdC5zZXNzaW9ucy5kZWxldGUocHVia2V5KTtcbiAgICBkcmFmdC5zaWduZXJzLmRlbGV0ZShwdWJrZXkpO1xuICAgIGlmICh3YXNBY3RpdmUpIHtcbiAgICAgIGxldCBuZXh0QWN0aXZlUHVia2V5ID0gbnVsbDtcbiAgICAgIGxldCBsYXRlc3RMYXN0QWN0aXZlID0gMDtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgc2Vzc2lvbl0gb2YgZHJhZnQuc2Vzc2lvbnMuZW50cmllcygpKSB7XG4gICAgICAgIGlmIChzZXNzaW9uLmxhc3RBY3RpdmUgPiBsYXRlc3RMYXN0QWN0aXZlKSB7XG4gICAgICAgICAgbGF0ZXN0TGFzdEFjdGl2ZSA9IHNlc3Npb24ubGFzdEFjdGl2ZTtcbiAgICAgICAgICBuZXh0QWN0aXZlUHVia2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkcmFmdC5hY3RpdmVQdWJrZXkgPSBuZXh0QWN0aXZlUHVia2V5O1xuICAgICAgY29uc3QgbmV4dEFjdGl2ZVNpZ25lciA9IG5leHRBY3RpdmVQdWJrZXkgPyBkcmFmdC5zaWduZXJzLmdldChuZXh0QWN0aXZlUHVia2V5KSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IG5kayA9IGRyYWZ0Lm5kaztcbiAgICAgIGlmIChuZGspIHtcbiAgICAgICAgbmRrLnNpZ25lciA9IG5leHRBY3RpdmVTaWduZXI7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIHNyYy9zZXNzaW9uL3N0b3JlL3N0YXJ0LXNlc3Npb24udHNcbmltcG9ydCB7IE5ES0tpbmQsIHByb2ZpbGVGcm9tRXZlbnQgfSBmcm9tIFwiQG5vc3RyLWRldi1raXQvbmRrXCI7XG5mdW5jdGlvbiBoYW5kbGVQcm9maWxlRXZlbnQoZXZlbnQsIHNlc3Npb25EcmFmdCkge1xuICBjb25zdCBwcm9maWxlID0gcHJvZmlsZUZyb21FdmVudChldmVudCk7XG4gIGlmIChwcm9maWxlKSB7XG4gICAgcHJvZmlsZS5jcmVhdGVkX2F0ID0gZXZlbnQuY3JlYXRlZF9hdDtcbiAgICBzZXNzaW9uRHJhZnQucHJvZmlsZSA9IHByb2ZpbGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUNvbnRhY3RzRXZlbnQoZXZlbnQsIHNlc3Npb25EcmFmdCkge1xuICBjb25zdCBmb2xsb3dTZXQgPSBuZXcgU2V0KGV2ZW50LnRhZ3MuZmlsdGVyKCh0KSA9PiB0WzBdID09PSBcInBcIikubWFwKCh0KSA9PiB0WzFdKSk7XG4gIHNlc3Npb25EcmFmdC5mb2xsb3dTZXQgPSBmb2xsb3dTZXQ7XG59XG5mdW5jdGlvbiBoYW5kbGVPdGhlckV2ZW50KGV2ZW50LCBzZXNzaW9uRHJhZnQsIG9wdHMpIHtcbiAgY29uc3QgZXhpc3RpbmdFdmVudCA9IHNlc3Npb25EcmFmdC5ldmVudHMuZ2V0KGV2ZW50LmtpbmQpO1xuICBpZiAoIWV4aXN0aW5nRXZlbnQgfHwgZXZlbnQuY3JlYXRlZF9hdCA+IGV4aXN0aW5nRXZlbnQuY3JlYXRlZF9hdCkge1xuICAgIHNlc3Npb25EcmFmdC5ldmVudHMuc2V0KGV2ZW50LmtpbmQsIGV2ZW50KTtcbiAgfVxuICBjb25zdCBrbGFzc1dyYXBwZXIgPSBvcHRzPy5ldmVudHM/LmdldChldmVudC5raW5kKTtcbiAgaWYgKGtsYXNzV3JhcHBlcikge1xuICAgIGNvbnN0IHdyYXBwZWRFdmVudCA9IGtsYXNzV3JhcHBlci5mcm9tKGV2ZW50KTtcbiAgICBpZiAod3JhcHBlZEV2ZW50KSBzZXNzaW9uRHJhZnQuZXZlbnRzLnNldChldmVudC5raW5kLCB3cmFwcGVkRXZlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVLaW5kRm9sbG93RXZlbnQoZXZlbnQsIHNlc3Npb25EcmFmdCwgZm9sbG93ZWQgPSB0cnVlLCBsYXN0X3VwZGF0ZWRfYXQgPSBldmVudC5jcmVhdGVkX2F0KSB7XG4gIGNvbnN0IGtpbmRGb2xsb3dTZXQgPSBzZXNzaW9uRHJhZnQua2luZEZvbGxvd1NldCA/PyAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBraW5kcyA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImtcIikubWFwKCh0KSA9PiBOdW1iZXIodFsxXSkpO1xuICBjb25zdCBmb2xsb3dlZFB1YmtleXMgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpLm1hcCgodCkgPT4gdFsxXSk7XG4gIGZvciAoY29uc3Qga2luZCBvZiBraW5kcykge1xuICAgIGZvciAoY29uc3QgcHVia2V5IG9mIGZvbGxvd2VkUHVia2V5cykge1xuICAgICAgY29uc3Qga2luZEZvbGxvd3MgPSBraW5kRm9sbG93U2V0LmdldChraW5kKSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgZm9sbG93ZWRJbmZvID0geyBmb2xsb3dlZCwgbGFzdF91cGRhdGVkX2F0IH07XG4gICAgICBjb25zdCBleGlzdGluZ0ZvbGxvd2VkSW5mbyA9IGtpbmRGb2xsb3dzLmdldChwdWJrZXkpO1xuICAgICAgaWYgKCFleGlzdGluZ0ZvbGxvd2VkSW5mbyB8fCBleGlzdGluZ0ZvbGxvd2VkSW5mby5sYXN0X3VwZGF0ZWRfYXQgPCBldmVudC5jcmVhdGVkX2F0KSB7XG4gICAgICAgIGtpbmRGb2xsb3dzLnNldChwdWJrZXksIGZvbGxvd2VkSW5mbyk7XG4gICAgICB9XG4gICAgICBraW5kRm9sbG93U2V0LnNldChraW5kLCBraW5kRm9sbG93cyk7XG4gICAgfVxuICB9XG4gIHNlc3Npb25EcmFmdC5raW5kRm9sbG93U2V0ID0ga2luZEZvbGxvd1NldDtcbn1cbmZ1bmN0aW9uIGhhbmRrZUV2ZW50RGVsZXRpb24oZXZlbnQsIHNlc3Npb25EcmFmdCkge1xuICBjb25zdCBraW5kRm9sbG93U2V0ID0gc2Vzc2lvbkRyYWZ0LmtpbmRGb2xsb3dTZXQ7XG4gIGlmICgha2luZEZvbGxvd1NldCkgcmV0dXJuO1xuICBmb3IgKGNvbnN0IGVUYWcgb2YgZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKSkge1xuICAgIGlmICghZVRhZ1sxXSkgY29udGludWU7XG4gICAgaWYgKCFldmVudC5uZGspIGNvbnRpbnVlO1xuICAgIGNvbnN0IGZvbGxvd0V2ZW50RGVsZXRlZCA9IGV2ZW50Lm5kay5mZXRjaEV2ZW50U3luYyhlVGFnWzFdKTtcbiAgICBpZiAoIWZvbGxvd0V2ZW50RGVsZXRlZD8uWzBdKSBjb250aW51ZTtcbiAgICBoYW5kbGVLaW5kRm9sbG93RXZlbnQoZm9sbG93RXZlbnREZWxldGVkWzBdLCBzZXNzaW9uRHJhZnQsIGZhbHNlLCBldmVudC5jcmVhdGVkX2F0KTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc0V2ZW50KGV2ZW50LCBzZXNzaW9uRHJhZnQsIG9wdHMpIHtcbiAgY29uc3Qga25vd25FdmVudEZvcktpbmQgPSBzZXNzaW9uRHJhZnQuZXZlbnRzPy5nZXQoZXZlbnQua2luZCk7XG4gIGlmICghKCFrbm93bkV2ZW50Rm9yS2luZCB8fCBrbm93bkV2ZW50Rm9yS2luZC5jcmVhdGVkX2F0IDwgZXZlbnQuY3JlYXRlZF9hdCkgJiYgZXZlbnQuaXNSZXBsYWNlYWJsZSgpKSB7XG4gICAgY29uc29sZS5sb2coXCJXZSBhbHJlYWR5IGhhdmUgYW4gZXZlbnQgb2Yga2luZCBcIiArIGV2ZW50LmtpbmQgKyBcIiB0aGF0IGlzIG5ld2VyXCIsIHtcbiAgICAgIGtub3duRXZlbnQ6IGtub3duRXZlbnRGb3JLaW5kLmNyZWF0ZWRfYXQsXG4gICAgICBpbmNvbWluZ0V2ZW50OiBldmVudC5jcmVhdGVkX2F0XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRyeSB7XG4gICAgc3dpdGNoIChldmVudC5raW5kKSB7XG4gICAgICBjYXNlIE5ES0tpbmQuTWV0YWRhdGE6XG4gICAgICAgIGhhbmRsZVByb2ZpbGVFdmVudChldmVudCwgc2Vzc2lvbkRyYWZ0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE5ES0tpbmQuQ29udGFjdHM6XG4gICAgICAgIGhhbmRsZUNvbnRhY3RzRXZlbnQoZXZlbnQsIHNlc3Npb25EcmFmdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBOREtLaW5kLk11dGVMaXN0OlxuICAgICAgICB1c2VOREtNdXRlcy5nZXRTdGF0ZSgpLmxvYWRNdXRlTGlzdChzZXNzaW9uRHJhZnQucHVia2V5LCBldmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5Njc6XG4gICAgICAgIGhhbmRsZUtpbmRGb2xsb3dFdmVudChldmVudCwgc2Vzc2lvbkRyYWZ0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE5ES0tpbmQuRXZlbnREZWxldGlvbjpcbiAgICAgICAgaGFuZGtlRXZlbnREZWxldGlvbihldmVudCwgc2Vzc2lvbkRyYWZ0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBoYW5kbGVPdGhlckV2ZW50KGV2ZW50LCBzZXNzaW9uRHJhZnQsIG9wdHMpO1xuICAgIH1cbiAgICBzZXNzaW9uRHJhZnQuZXZlbnRzLnNldChldmVudC5raW5kLCBldmVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBldmVudCBraW5kICR7ZXZlbnQua2luZH0gZm9yICR7c2Vzc2lvbkRyYWZ0LnB1YmtleX06YCwgZXJyb3IsIGV2ZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gYnVpbGRTZXNzaW9uRmlsdGVyKHB1YmtleSwgb3B0cykge1xuICBjb25zdCBtYWluS2luZHNUb0ZldGNoID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgaWYgKG9wdHMucHJvZmlsZSAhPT0gZmFsc2UpIG1haW5LaW5kc1RvRmV0Y2guYWRkKE5ES0tpbmQuTWV0YWRhdGEpO1xuICBpZiAob3B0cy5mb2xsb3dzICE9PSBmYWxzZSkgbWFpbktpbmRzVG9GZXRjaC5hZGQoTkRLS2luZC5Db250YWN0cyk7XG4gIG1haW5LaW5kc1RvRmV0Y2guYWRkKE5ES0tpbmQuTXV0ZUxpc3QpO1xuICBmb3IgKGNvbnN0IGtpbmQgb2Ygb3B0cy5ldmVudHM/LmtleXMoKSB8fCBbXSkge1xuICAgIG1haW5LaW5kc1RvRmV0Y2guYWRkKGtpbmQpO1xuICB9XG4gIGNvbnN0IGZpbHRlciA9IFt7IGtpbmRzOiBBcnJheS5mcm9tKG1haW5LaW5kc1RvRmV0Y2gpLCBhdXRob3JzOiBbcHVia2V5XSB9XTtcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5mb2xsb3dzKSkge1xuICAgIGZpbHRlci5wdXNoKHsga2luZHM6IFs5NjddLCBcIiNrXCI6IG9wdHMuZm9sbG93cy5tYXAoKGspID0+IGsudG9TdHJpbmcoKSksIGF1dGhvcnM6IFtwdWJrZXldIH0pO1xuICB9XG4gIHJldHVybiBmaWx0ZXI7XG59XG52YXIgc3RhcnRTZXNzaW9uID0gKHNldCwgZ2V0LCBwdWJrZXksIG9wdHMpID0+IHtcbiAgY29uc29sZS5sb2coXCJjYWxsaW5nIHN0YXJ0U2Vzc2lvblwiLCBwdWJrZXkpO1xuICBjb25zdCBuZGsgPSBnZXQoKS5uZGs7XG4gIGlmICghbmRrKSB7XG4gICAgY29uc29sZS5lcnJvcihcIk5ESyBpbnN0YW5jZSBub3QgaW5pdGlhbGl6ZWQgaW4gc2Vzc2lvbiBzdG9yZS4gQ2Fubm90IHN0YXJ0IHNlc3Npb24uXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBleGlzdGluZ1Nlc3Npb24gPSBnZXQoKS5zZXNzaW9ucy5nZXQocHVia2V5KTtcbiAgaWYgKCFleGlzdGluZ1Nlc3Npb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGV4aXN0aW5nU2Vzc2lvbi5zdWJzY3JpcHRpb24pIHtcbiAgICBleGlzdGluZ1Nlc3Npb24uc3Vic2NyaXB0aW9uLnN0b3AoKTtcbiAgICBzZXQoKGRyYWZ0KSA9PiB7XG4gICAgICBjb25zdCBzZXNzaW9uID0gZHJhZnQuc2Vzc2lvbnMuZ2V0KHB1YmtleSk7XG4gICAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICBzZXNzaW9uLnN1YnNjcmlwdGlvbiA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb25zdCBmaWx0ZXJzID0gYnVpbGRTZXNzaW9uRmlsdGVyKHB1YmtleSwgb3B0cyk7XG4gIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGUud2FybihgTm8gZmlsdGVycyBnZW5lcmF0ZWQgZm9yIHNlc3Npb24gc3RhcnQgb3B0aW9ucyBmb3IgcHVia2V5ICR7cHVia2V5fS4gTm8gc3Vic2NyaXB0aW9uIGNyZWF0ZWQuYCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9uRXZlbnQgPSAoZXZlbnQsIHJlbGF5KSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJoYW5kbGUgc2Vzc2lvbiBldmVudFwiLCBldmVudC5wdWJrZXkuc2xpY2UoMCwgNiksIGV2ZW50LmtpbmQsIHJlbGF5Py51cmwpO1xuICAgIHNldCgoZHJhZnQpID0+IHtcbiAgICAgIGNvbnN0IHNlc3Npb24gPSBkcmFmdC5zZXNzaW9ucy5nZXQocHVia2V5KTtcbiAgICAgIGlmICghc2Vzc2lvbikgcmV0dXJuO1xuICAgICAgcHJvY2Vzc0V2ZW50KGV2ZW50LCBzZXNzaW9uLCBvcHRzKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3Qgb25FdmVudHMgPSAoZXZlbnRzKSA9PiB7XG4gICAgc2V0KChkcmFmdCkgPT4ge1xuICAgICAgY29uc3Qgc2Vzc2lvbiA9IGRyYWZ0LnNlc3Npb25zLmdldChwdWJrZXkpO1xuICAgICAgaWYgKCFzZXNzaW9uKSByZXR1cm47XG4gICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICBwcm9jZXNzRXZlbnQoZXZlbnQsIHNlc3Npb24sIG9wdHMpO1xuICAgICAgfVxuICAgICAgY29uc29sZS5kZWJ1ZyhgUHJvY2Vzc2VkICR7ZXZlbnRzLmxlbmd0aH0gY2FjaGVkIGV2ZW50cyBmb3IgJHtwdWJrZXl9YCk7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHN1YiA9IG5kay5zdWJzY3JpYmUoZmlsdGVycywgeyBjbG9zZU9uRW9zZTogZmFsc2UsIGFkZFNpbmNlRnJvbUNhY2hlOiB0cnVlIH0sIHsgb25FdmVudCwgb25FdmVudHMgfSk7XG4gIHNldCgoZHJhZnQpID0+IHtcbiAgICBjb25zdCBzZXNzaW9uID0gZHJhZnQuc2Vzc2lvbnMuZ2V0KHB1YmtleSk7XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHNlc3Npb24uc3Vic2NyaXB0aW9uID0gc3ViO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBzcmMvc2Vzc2lvbi9zdG9yZS9zdG9wLXNlc3Npb24udHNcbnZhciBzdG9wU2Vzc2lvbiA9IChzZXQsIGdldCwgcHVia2V5KSA9PiB7XG4gIGNvbnN0IHNlc3Npb24gPSBnZXQoKS5zZXNzaW9ucy5nZXQocHVia2V5KTtcbiAgaWYgKHNlc3Npb24/LnN1YnNjcmlwdGlvbikge1xuICAgIGNvbnNvbGUuZGVidWcoYFN0b3BwaW5nIHNlc3Npb24gc3Vic2NyaXB0aW9uIGZvciAke3B1YmtleX1gKTtcbiAgICB0cnkge1xuICAgICAgc2Vzc2lvbi5zdWJzY3JpcHRpb24uc3RvcCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzdG9wcGluZyBzdWJzY3JpcHRpb24gZm9yICR7cHVia2V5fTpgLCBlcnJvcik7XG4gICAgfVxuICAgIHNldCgoZHJhZnQpID0+IHtcbiAgICAgIGNvbnN0IGRyYWZ0U2Vzc2lvbiA9IGRyYWZ0LnNlc3Npb25zLmdldChwdWJrZXkpO1xuICAgICAgaWYgKGRyYWZ0U2Vzc2lvbikge1xuICAgICAgICBkcmFmdFNlc3Npb24uc3Vic2NyaXB0aW9uID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZGVidWcoYE5vIGFjdGl2ZSBzdWJzY3JpcHRpb24gZm91bmQgZm9yIHNlc3Npb24gJHtwdWJrZXl9IHRvIHN0b3AuYCk7XG4gIH1cbn07XG5cbi8vIHNyYy9zZXNzaW9uL3N0b3JlL3N3aXRjaC10by11c2VyLnRzXG52YXIgc3dpdGNoVG9Vc2VyID0gKHNldCwgZ2V0LCBwdWJrZXkpID0+IHtcbiAgY29uc3Qgc2lnbmVycyA9IGdldCgpLnNpZ25lcnM7XG4gIGNvbnN0IG5kayA9IGdldCgpLm5kaztcbiAgaWYgKCFuZGspIHtcbiAgICBjb25zb2xlLmVycm9yKFwiQ2Fubm90IHN3aXRjaCB1c2VyOiBOREsgaW5zdGFuY2Ugbm90IGluaXRpYWxpemVkIGluIHNlc3Npb24gc3RvcmUuXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc2lnbmVyID0gdm9pZCAwO1xuICBpZiAocHVia2V5ICE9PSBudWxsKSB7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IGdldCgpLnNlc3Npb25zLmdldChwdWJrZXkpO1xuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgY29uc29sZS5lcnJvcihgQ2Fubm90IHN3aXRjaCB0byB1c2VyICR7cHVia2V5fTogU2Vzc2lvbiBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2lnbmVyID0gc2lnbmVycy5nZXQocHVia2V5KTtcbiAgfVxuICB1c2VOREtTdG9yZS5nZXRTdGF0ZSgpLnNldFNpZ25lcihzaWduZXIpO1xuICBzZXQoKGRyYWZ0KSA9PiB7XG4gICAgZHJhZnQuYWN0aXZlUHVia2V5ID0gcHVia2V5O1xuICAgIGlmIChwdWJrZXkpIHtcbiAgICAgIGNvbnN0IGRyYWZ0U2Vzc2lvbiA9IGRyYWZ0LnNlc3Npb25zLmdldChwdWJrZXkpO1xuICAgICAgaWYgKGRyYWZ0U2Vzc2lvbikge1xuICAgICAgICBkcmFmdFNlc3Npb24ubGFzdEFjdGl2ZSA9IERhdGUubm93KCkgLyAxZTM7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgY29uc3QgbXV0ZVN0b3JlID0gdXNlTkRLTXV0ZXMuZ2V0U3RhdGUoKTtcbiAgbXV0ZVN0b3JlLnNldEFjdGl2ZVB1YmtleShwdWJrZXkpO1xuICBpZiAocHVia2V5KSB7XG4gICAgbXV0ZVN0b3JlLmluaXRNdXRlcyhwdWJrZXkpO1xuICB9XG59O1xuXG4vLyBzcmMvc2Vzc2lvbi9zdG9yZS91cGRhdGUtc2Vzc2lvbi50c1xudmFyIHVwZGF0ZVNlc3Npb24gPSAoc2V0LCBnZXQsIHB1YmtleSwgZGF0YSkgPT4ge1xuICBzZXQoKGRyYWZ0KSA9PiB7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IGRyYWZ0LnNlc3Npb25zLmdldChwdWJrZXkpO1xuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgY29uc29sZS53YXJuKGBBdHRlbXB0ZWQgdG8gdXBkYXRlIG5vbi1leGlzdGVudCBzZXNzaW9uOiAke3B1YmtleX1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihzZXNzaW9uLCBkYXRhKTtcbiAgICBzZXNzaW9uLmxhc3RBY3RpdmUgPSBEYXRlLm5vdygpO1xuICB9KTtcbn07XG5cbi8vIHNyYy9zZXNzaW9uL3N0b3JlL2luZGV4LnRzXG5lbmFibGVNYXBTZXQyKCk7XG52YXIgc2Vzc2lvblN0YXRlQ3JlYXRvciA9IChzZXQsIGdldCkgPT4gKHtcbiAgbmRrOiB2b2lkIDAsXG4gIC8vIEFkZCBOREsgaW5zdGFuY2UgaG9sZGVyXG4gIHNlc3Npb25zOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICBzaWduZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAvLyBLZWVwIHNpZ25lcnMgbWFwIGZvciBhZGRTZXNzaW9uIGxvZ2ljXG4gIGFjdGl2ZVB1YmtleTogbnVsbCxcbiAgLy8gSW5pdGlhbGl6YXRpb25cbiAgaW5pdDogKG5ka0luc3RhbmNlKSA9PiBpbml0KHNldCwgbmRrSW5zdGFuY2UpLFxuICAvKipcbiAgICogQWRkcyB0aGUgc2Vzc2lvbi4gVGhpcyBpcyBob3cgd2UgbG9naW4gYSB1c2VyLlxuICAgKiBAcGFyYW0gdXNlck9yU2lnbmVyXG4gICAqIEBwYXJhbSBzZXRBY3RpdmUgLSBJZiB0cnVlLCBzZXRzIHRoZSBzZXNzaW9uIGFzIGFjdGl2ZS5cbiAgICogQHJldHVybnNcbiAgICovXG4gIGFkZFNlc3Npb246IGFzeW5jICh1c2VyT3JTaWduZXIsIHNldEFjdGl2ZSkgPT4ge1xuICAgIGNvbnN0IHB1YmtleSA9IGF3YWl0IGFkZFNlc3Npb24oc2V0LCBnZXQsIHVzZXJPclNpZ25lciwgc2V0QWN0aXZlKTtcbiAgICBpZiAocHVia2V5ICYmIHNldEFjdGl2ZSkgZ2V0KCkuc3dpdGNoVG9Vc2VyKHB1YmtleSk7XG4gICAgcmV0dXJuIHB1YmtleTtcbiAgfSxcbiAgc3RhcnRTZXNzaW9uOiAocHVia2V5LCBvcHRzKSA9PiBzdGFydFNlc3Npb24oc2V0LCBnZXQsIHB1YmtleSwgb3B0cyksXG4gIHN0b3BTZXNzaW9uOiAocHVia2V5KSA9PiBzdG9wU2Vzc2lvbihzZXQsIGdldCwgcHVia2V5KSxcbiAgc3dpdGNoVG9Vc2VyOiAocHVia2V5KSA9PiBzd2l0Y2hUb1VzZXIoc2V0LCBnZXQsIHB1YmtleSksXG4gIHJlbW92ZVNlc3Npb246IChwdWJrZXkpID0+IHJlbW92ZVNlc3Npb24oc2V0LCBnZXQsIHB1YmtleSksXG4gIC8vIEludGVybmFsIHVwZGF0ZSBmdW5jdGlvblxuICB1cGRhdGVTZXNzaW9uOiAocHVia2V5LCBkYXRhKSA9PiB1cGRhdGVTZXNzaW9uKHNldCwgZ2V0LCBwdWJrZXksIGRhdGEpXG59KTtcbnZhciB1c2VOREtTZXNzaW9ucyA9IGNyZWF0ZTQoaW1tZXIyKHNlc3Npb25TdGF0ZUNyZWF0b3IpKTtcblxuLy8gc3JjL25kay9ob29rcy9pbmRleC50c1xudmFyIHVzZU5ESyA9ICgpID0+IHtcbiAgY29uc3QgbmRrID0gdXNlTkRLU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5uZGspO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiAoeyBuZGsgfSksIFtuZGtdKTtcbn07XG52YXIgdXNlTkRLQ3VycmVudFB1YmtleSA9ICgpID0+IHVzZU5ES1Nlc3Npb25zKChzdGF0ZSkgPT4gc3RhdGUuYWN0aXZlUHVia2V5KTtcbnZhciB1c2VOREtDdXJyZW50VXNlciA9ICgpID0+IHtcbiAgY29uc3QgbmRrID0gdXNlTkRLU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5uZGspO1xuICBjb25zdCBhY3RpdmVQdWJrZXkgPSB1c2VOREtDdXJyZW50UHVia2V5KCk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAobmRrICYmIGFjdGl2ZVB1YmtleSkge1xuICAgICAgcmV0dXJuIG5kay5nZXRVc2VyKHsgcHVia2V5OiBhY3RpdmVQdWJrZXkgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LCBbbmRrLCBhY3RpdmVQdWJrZXldKTtcbn07XG5mdW5jdGlvbiB1c2VOREtVbnB1Ymxpc2hlZEV2ZW50cygpIHtcbiAgY29uc3QgeyBuZGsgfSA9IHVzZU5ESygpO1xuICBjb25zdCBbdW5wdWJsaXNoZWRFdmVudHMsIHNldFVucHVibGlzaGVkRXZlbnRzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3Qgc3RhdGUgPSB1c2VSZWYoW10pO1xuICBjb25zdCB1cGRhdGVTdGF0ZUZyb21DYWNoZSA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBpZiAoIW5kaz8uY2FjaGVBZGFwdGVyPy5nZXRVbnB1Ymxpc2hlZEV2ZW50cykgcmV0dXJuO1xuICAgIGNvbnN0IGVudHJpZXMgPSBhd2FpdCBuZGsuY2FjaGVBZGFwdGVyLmdldFVucHVibGlzaGVkRXZlbnRzKCk7XG4gICAgY29uc3QgcHJldmlvdXNFbnRyaWVzID0gbmV3IFNldChzdGF0ZS5jdXJyZW50Py5tYXAoKGUpID0+IGUuZXZlbnQuaWQpKTtcbiAgICBjb25zdCBuZXdFbnRyaWVzID0gW107XG4gICAgbGV0IGNoYW5nZWQgPSBlbnRyaWVzLmxlbmd0aCAhPT0gc3RhdGUuY3VycmVudD8ubGVuZ3RoO1xuICAgIGlmICghY2hhbmdlZCkge1xuICAgICAgY29uc3QgY3VycmVudElkcyA9IG5ldyBTZXQoc3RhdGUuY3VycmVudC5tYXAoKGUpID0+IGUuZXZlbnQuaWQpKTtcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBpZiAoIWN1cnJlbnRJZHMuaGFzKGVudHJ5LmV2ZW50LmlkKSkge1xuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICBjb25zdCBmcmVzaEVudHJpZXMgPSBlbnRyaWVzLm1hcCgoZW50cnkpID0+ICh7IC4uLmVudHJ5IH0pKTtcbiAgICAgIHN0YXRlLmN1cnJlbnQgPSBmcmVzaEVudHJpZXM7XG4gICAgICBzZXRVbnB1Ymxpc2hlZEV2ZW50cyhmcmVzaEVudHJpZXMpO1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBmcmVzaEVudHJpZXMpIHtcbiAgICAgICAgZW50cnkuZXZlbnQub24oXCJwdWJsaXNoZWRcIiwgKCkgPT4ge1xuICAgICAgICAgIHN0YXRlLmN1cnJlbnQgPSBzdGF0ZS5jdXJyZW50Py5maWx0ZXIoKGUpID0+IGUuZXZlbnQuaWQgIT09IGVudHJ5LmV2ZW50LmlkKTtcbiAgICAgICAgICBzZXRVbnB1Ymxpc2hlZEV2ZW50cyhzdGF0ZS5jdXJyZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbbmRrXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFuZGs/LmNhY2hlQWRhcHRlcj8uZ2V0VW5wdWJsaXNoZWRFdmVudHMpIHJldHVybjtcbiAgICB1cGRhdGVTdGF0ZUZyb21DYWNoZSgpO1xuICAgIGNvbnN0IGhhbmRsZVB1Ymxpc2hGYWlsZWQgPSAoX2V2ZW50LCBfZXJyb3IsIF9yZWxheXMpID0+IHtcbiAgICAgIHVwZGF0ZVN0YXRlRnJvbUNhY2hlKCk7XG4gICAgfTtcbiAgICBuZGs/Lm9uKFwiZXZlbnQ6cHVibGlzaC1mYWlsZWRcIiwgaGFuZGxlUHVibGlzaEZhaWxlZCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG5kaz8ub2ZmKFwiZXZlbnQ6cHVibGlzaC1mYWlsZWRcIiwgaGFuZGxlUHVibGlzaEZhaWxlZCk7XG4gICAgfTtcbiAgfSwgW25kaywgdXBkYXRlU3RhdGVGcm9tQ2FjaGVdKTtcbiAgcmV0dXJuIHVucHVibGlzaGVkRXZlbnRzO1xufVxuZnVuY3Rpb24gdXNlTkRLSW5pdCgpIHtcbiAgY29uc3Qgc2V0TkRLID0gdXNlTkRLU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5zZXROREspO1xuICBjb25zdCBpbml0aWFsaXplUHJvZmlsZXNTdG9yZTIgPSB1c2VVc2VyUHJvZmlsZXNTdG9yZSgoc3RhdGUpID0+IHN0YXRlLmluaXRpYWxpemUpO1xuICBjb25zdCBpbml0aWFsaXplU2Vzc2lvblN0b3JlID0gdXNlTkRLU2Vzc2lvbnMoKHN0YXRlKSA9PiBzdGF0ZS5pbml0KTtcbiAgY29uc3QgaW5pdGlhbGl6ZU5ESyA9IHVzZUNhbGxiYWNrKFxuICAgIChuZGtJbnN0YW5jZSkgPT4ge1xuICAgICAgaWYgKCFuZGtJbnN0YW5jZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwidXNlTkRLSW5pdDogQXR0ZW1wdGVkIHRvIGluaXRpYWxpemUgd2l0aCBhIG51bGwgTkRLIGluc3RhbmNlLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0TkRLKG5ka0luc3RhbmNlKTtcbiAgICAgIGluaXRpYWxpemVQcm9maWxlc1N0b3JlMihuZGtJbnN0YW5jZSk7XG4gICAgICBpbml0aWFsaXplU2Vzc2lvblN0b3JlKG5ka0luc3RhbmNlKTtcbiAgICB9LFxuICAgIFtzZXROREssIGluaXRpYWxpemVQcm9maWxlc1N0b3JlMiwgaW5pdGlhbGl6ZVNlc3Npb25TdG9yZV1cbiAgKTtcbiAgcmV0dXJuIGluaXRpYWxpemVOREs7XG59XG5cbi8vIHNyYy9wcm9maWxlcy9ob29rcy9pbmRleC50c1xuaW1wb3J0IHtcbiAgTkRLRXZlbnQgYXMgTkRLRXZlbnQyLFxuICBOREtLaW5kIGFzIE5ES0tpbmQyLFxuICBzZXJpYWxpemVQcm9maWxlXG59IGZyb20gXCJAbm9zdHItZGV2LWtpdC9uZGtcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMiwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVNoYWxsb3cgfSBmcm9tIFwienVzdGFuZC9zaGFsbG93XCI7XG5mdW5jdGlvbiB1c2VQcm9maWxlKHB1YmtleSwgZm9yY2VSZWZyZXNoKSB7XG4gIHJldHVybiB1c2VQcm9maWxlVmFsdWUocHVia2V5LCB7IHJlZnJlc2g6IGZvcmNlUmVmcmVzaCB9KTtcbn1cbmZ1bmN0aW9uIHVzZVByb2ZpbGVWYWx1ZShwdWJrZXksIG9wdHMpIHtcbiAgY29uc3QgZmV0Y2hQcm9maWxlID0gdXNlVXNlclByb2ZpbGVzU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5mZXRjaFByb2ZpbGUpO1xuICBjb25zdCBwcm9maWxlU2VsZWN0b3IgPSB1c2VTaGFsbG93KChzdGF0ZSkgPT4gcHVia2V5ID8gc3RhdGUucHJvZmlsZXMuZ2V0KHB1YmtleSkgOiB2b2lkIDApO1xuICBjb25zdCBwcm9maWxlID0gdXNlVXNlclByb2ZpbGVzU3RvcmUocHJvZmlsZVNlbGVjdG9yKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgaWYgKHB1YmtleSkge1xuICAgICAgZmV0Y2hQcm9maWxlKHB1YmtleSwgb3B0cyk7XG4gICAgfVxuICB9LCBbcHVia2V5LCBmZXRjaFByb2ZpbGUsIG9wdHNdKTtcbiAgcmV0dXJuIHByb2ZpbGU7XG59XG5mdW5jdGlvbiB1c2VTZXRQcm9maWxlKCkge1xuICBjb25zdCBzZXRQcm9maWxlID0gdXNlVXNlclByb2ZpbGVzU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5zZXRQcm9maWxlKTtcbiAgY29uc3QgeyBuZGsgfSA9IHVzZU5ESygpO1xuICBjb25zdCB1cGRhdGUgPSB1c2VDYWxsYmFjazIoXG4gICAgYXN5bmMgKG5ld1Byb2ZpbGUpID0+IHtcbiAgICAgIGlmICghbmRrKSByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50MihuZGspO1xuICAgICAgZXZlbnQua2luZCA9IE5ES0tpbmQyLk1ldGFkYXRhO1xuICAgICAgZXZlbnQuY29udGVudCA9IHNlcmlhbGl6ZVByb2ZpbGUobmV3UHJvZmlsZSk7XG4gICAgICBhd2FpdCBldmVudC5zaWduKCk7XG4gICAgICBldmVudC5wdWJsaXNoKCk7XG4gICAgICBzZXRQcm9maWxlKGV2ZW50LnB1YmtleSwgbmV3UHJvZmlsZSk7XG4gICAgfSxcbiAgICBbbmRrXVxuICApO1xuICByZXR1cm4gdXBkYXRlO1xufVxuXG4vLyBzcmMvc2Vzc2lvbi9ob29rcy9pbmRleC50c1xudmFyIEVNUFRZX1NFVCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG52YXIgRU1QVFlfS0lORF9NQVAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xudmFyIHVzZU5ES1Nlc3Npb25Mb2dpbiA9ICgpID0+IHtcbiAgY29uc3QgYWRkU2Vzc2lvbjIgPSB1c2VOREtTZXNzaW9ucy5nZXRTdGF0ZSgpLmFkZFNlc3Npb247XG4gIHJldHVybiB1c2VDYWxsYmFjazMoXG4gICAgKHVzZXJPclNpZ25lciwgc2V0QWN0aXZlKSA9PiBhZGRTZXNzaW9uMih1c2VyT3JTaWduZXIsIHNldEFjdGl2ZSksXG4gICAgW2FkZFNlc3Npb24yXVxuICApO1xufTtcbnZhciB1c2VOREtTZXNzaW9uTG9nb3V0ID0gKCkgPT4ge1xuICBjb25zdCBjdXJyZW50UHVia2V5ID0gdXNlTkRLQ3VycmVudFB1YmtleSgpO1xuICBjb25zdCByZW1vdmVTZXNzaW9uMiA9IHVzZU5ES1Nlc3Npb25zLmdldFN0YXRlKCkucmVtb3ZlU2Vzc2lvbjtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAocHVia2V5KSA9PiB7XG4gICAgICBjb25zdCBfcHVia2V5ID0gcHVia2V5ID8/IGN1cnJlbnRQdWJrZXk7XG4gICAgICBpZiAoIV9wdWJrZXkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIHB1YmtleSBwcm92aWRlZCBmb3IgbG9nb3V0XCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZW1vdmVTZXNzaW9uMihfcHVia2V5KTtcbiAgICB9LFxuICAgIFtyZW1vdmVTZXNzaW9uMiwgY3VycmVudFB1YmtleV1cbiAgKTtcbn07XG52YXIgdXNlTkRLU2Vzc2lvblN3aXRjaCA9ICgpID0+IHtcbiAgY29uc3Qgc3dpdGNoVG9Vc2VyMiA9IHVzZU5ES1Nlc3Npb25zLmdldFN0YXRlKCkuc3dpdGNoVG9Vc2VyO1xuICByZXR1cm4gdXNlQ2FsbGJhY2szKChwdWJrZXkpID0+IHN3aXRjaFRvVXNlcjIocHVia2V5KSwgW3N3aXRjaFRvVXNlcjJdKTtcbn07XG52YXIgdXNlRm9sbG93cyA9ICgpID0+IHtcbiAgY29uc3QgZm9sbG93cyA9IHVzZU5ES1Nlc3Npb25zKFxuICAgIChzKSA9PiBzLmFjdGl2ZVB1YmtleSA/IHMuc2Vzc2lvbnMuZ2V0KHMuYWN0aXZlUHVia2V5KT8uZm9sbG93U2V0ID8/IEVNUFRZX1NFVCA6IEVNUFRZX1NFVFxuICApO1xuICBjb25zdCBmb2xsb3dLaW5kcyA9IHVzZU5ES1Nlc3Npb25zKFxuICAgIChzKSA9PiBzLmFjdGl2ZVB1YmtleSA/IHMuc2Vzc2lvbnMuZ2V0KHMuYWN0aXZlUHVia2V5KT8ua2luZEZvbGxvd1NldCA/PyBFTVBUWV9LSU5EX01BUCA6IEVNUFRZX0tJTkRfTUFQXG4gICk7XG4gIGNvbnN0IGZvbGxvd1NldCA9IHVzZU1lbW8yKCgpID0+IHtcbiAgICBjb25zdCBzZXQgPSBuZXcgU2V0KGZvbGxvd3MpO1xuICAgIGZvciAoY29uc3Qga2luZHMgb2YgZm9sbG93S2luZHMudmFsdWVzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgW3B1YmtleSwgeyBmb2xsb3dlZCB9XSBvZiBraW5kcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKGZvbGxvd2VkKSB7XG4gICAgICAgICAgc2V0LmFkZChwdWJrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldC5kZWxldGUocHVia2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2V0O1xuICB9LCBbZm9sbG93cywgZm9sbG93S2luZHNdKTtcbiAgcmV0dXJuIGZvbGxvd1NldDtcbn07XG5mdW5jdGlvbiB1c2VOREtTZXNzaW9uRXZlbnQoa2luZCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgbmRrIH0gPSB1c2VOREsoKTtcbiAgY29uc3QgeyBjcmVhdGU6IGNyZWF0ZTYgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGFjdGl2ZVB1YmtleSA9IHVzZU5ES1Nlc3Npb25zKChzKSA9PiBzLmFjdGl2ZVB1YmtleSk7XG4gIGNvbnN0IGFjdGl2ZVNlc3Npb25FdmVudHMgPSB1c2VOREtTZXNzaW9ucyhcbiAgICAocykgPT4gcy5hY3RpdmVQdWJrZXkgPyBzLnNlc3Npb25zLmdldChzLmFjdGl2ZVB1YmtleSk/LmV2ZW50cyA6IHZvaWQgMFxuICApO1xuICBjb25zdCBldmVudCA9IHVzZU1lbW8yKCgpID0+IHtcbiAgICBpZiAoIWFjdGl2ZVNlc3Npb25FdmVudHMgfHwgIWFjdGl2ZVB1YmtleSkgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCBleGlzdGluZ0V2ZW50ID0gYWN0aXZlU2Vzc2lvbkV2ZW50cy5nZXQoa2luZCk7XG4gICAgaWYgKGV4aXN0aW5nRXZlbnQpIHJldHVybiBleGlzdGluZ0V2ZW50O1xuICAgIGlmIChjcmVhdGU2ICYmIG5kaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbmV3SW5zdGFuY2UgPSBuZXcgY3JlYXRlNihuZGspO1xuICAgICAgICBuZXdJbnN0YW5jZS5wdWJrZXkgPSBhY3RpdmVQdWJrZXk7XG4gICAgICAgIHJldHVybiBuZXdJbnN0YW5jZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgaW5zdGFuY2UgZm9yIGtpbmQgJHtraW5kfSB1c2luZyBwcm92aWRlZCBjbGFzczpgLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH0sIFthY3RpdmVTZXNzaW9uRXZlbnRzLCBraW5kLCBuZGssIGFjdGl2ZVB1YmtleV0pO1xuICByZXR1cm4gZXZlbnQ7XG59XG52YXIgdXNlQ3VycmVudFVzZXJQcm9maWxlID0gKCkgPT4ge1xuICBjb25zdCBhY3RpdmVQdWJrZXkgPSB1c2VOREtTZXNzaW9ucygoc3RhdGUpID0+IHN0YXRlLmFjdGl2ZVB1YmtleSk7XG4gIGNvbnN0IHByb2ZpbGUgPSB1c2VQcm9maWxlVmFsdWUoYWN0aXZlUHVia2V5ID8/IHZvaWQgMCk7XG4gIHJldHVybiBwcm9maWxlO1xufTtcblxuLy8gc3JjL3Nlc3Npb24vaG9va3Mvc2lnbmVycy50c1xudmFyIHVzZU5ES1Nlc3Npb25TaWduZXJzID0gKCkgPT4gdXNlTkRLU2Vzc2lvbnMoKHMpID0+IHMuc2lnbmVycyk7XG5cbi8vIHNyYy9zZXNzaW9uL2hvb2tzL3Nlc3Npb25zLnRzXG52YXIgdXNlTkRLU2Vzc2lvblNlc3Npb25zID0gKCkgPT4gdXNlTkRLU2Vzc2lvbnMoKHMpID0+IHMuc2Vzc2lvbnMpO1xuXG4vLyBzcmMvc2Vzc2lvbi9ob29rcy9jb250cm9sLnRzXG52YXIgdXNlTkRLU2Vzc2lvblN0YXJ0ID0gKCkgPT4gdXNlTkRLU2Vzc2lvbnMoKHMpID0+IHMuc3RhcnRTZXNzaW9uKTtcbnZhciB1c2VOREtTZXNzaW9uU3RvcCA9ICgpID0+IHVzZU5ES1Nlc3Npb25zKChzKSA9PiBzLnN0b3BTZXNzaW9uKTtcblxuLy8gc3JjL3Nlc3Npb24vaG9va3MvdXNlLW5kay1zZXNzaW9uLW1vbml0b3IudHNcbmltcG9ydCB7IG5ka1NpZ25lckZyb21QYXlsb2FkIH0gZnJvbSBcIkBub3N0ci1kZXYta2l0L25ka1wiO1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDMsIHVzZVJlZiBhcyB1c2VSZWYyIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9zZXNzaW9uL3N0b3JhZ2UvaW5kZXgudHNcbnZhciBTRVNTSU9OU19TVE9SRV9LRVkgPSBcIm5kay1zYXZlZC1zZXNzaW9uc1wiO1xudmFyIEFDVElWRV9QVUJLRVlfU1RPUkVfS0VZID0gXCJuZGstYWN0aXZlLXB1YmtleVwiO1xudmFyIE5ES1Nlc3Npb25Mb2NhbFN0b3JhZ2UgPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBHZXQgYW4gaXRlbSBmcm9tIGxvY2FsU3RvcmFnZS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHJldHJpZXZlLlxuICAgKiBAcmV0dXJucyBUaGUgc3RvcmVkIHZhbHVlIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgKi9cbiAgZ2V0SXRlbShrZXkpIHtcbiAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY29uc29sZS53YXJuKFwibG9jYWxTdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudFwiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgfVxuICAvKipcbiAgICogU2V0IGFuIGl0ZW0gaW4gbG9jYWxTdG9yYWdlLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gc3RvcmUuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc3RvcmUuXG4gICAqL1xuICBzZXRJdGVtKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY29uc29sZS53YXJuKFwibG9jYWxTdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhbiBpdGVtIGZyb20gbG9jYWxTdG9yYWdlLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gZGVsZXRlLlxuICAgKi9cbiAgZGVsZXRlSXRlbShrZXkpIHtcbiAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY29uc29sZS53YXJuKFwibG9jYWxTdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGxvYWRTZXNzaW9uc0Zyb21TdG9yYWdlKHN0b3JhZ2UpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZXNzaW9uc0pzb24gPSBzdG9yYWdlLmdldEl0ZW0oU0VTU0lPTlNfU1RPUkVfS0VZKTtcbiAgICBpZiAoIXNlc3Npb25zSnNvbikgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHNlc3Npb25zID0gSlNPTi5wYXJzZShzZXNzaW9uc0pzb24pO1xuICAgIHJldHVybiBzZXNzaW9ucztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW05ES10gRXJyb3IgbG9hZGluZyBzZXNzaW9ucyBmcm9tIHN0b3JhZ2U6XCIsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cbmZ1bmN0aW9uIHNhdmVTZXNzaW9uc1RvU3RvcmFnZShzdG9yYWdlLCBzZXNzaW9ucykge1xuICB0cnkge1xuICAgIHN0b3JhZ2Uuc2V0SXRlbShTRVNTSU9OU19TVE9SRV9LRVksIEpTT04uc3RyaW5naWZ5KHNlc3Npb25zKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltOREtdIEVycm9yIHNhdmluZyBzZXNzaW9ucyB0byBzdG9yYWdlOlwiLCBlcnJvcik7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGFkZE9yVXBkYXRlU3RvcmVkU2Vzc2lvbihzdG9yYWdlLCBwdWJrZXksIHNpZ25lclBheWxvYWQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZXNzaW9ucyA9IGxvYWRTZXNzaW9uc0Zyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBzZXNzaW9ucy5maW5kSW5kZXgoKHMpID0+IHMucHVia2V5ID09PSBwdWJrZXkpO1xuICAgIGlmIChleGlzdGluZ0luZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKHNpZ25lclBheWxvYWQgIT09IHZvaWQgMCkge1xuICAgICAgICBzZXNzaW9uc1tleGlzdGluZ0luZGV4XS5zaWduZXJQYXlsb2FkID0gc2lnbmVyUGF5bG9hZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2Vzc2lvbnMucHVzaCh7XG4gICAgICAgIHB1YmtleSxcbiAgICAgICAgc2lnbmVyUGF5bG9hZFxuICAgICAgICAvLyBXaWxsIGJlIHVuZGVmaW5lZCBmb3IgcmVhZC1vbmx5IHNlc3Npb25zIGluaXRpYWxseVxuICAgICAgfSk7XG4gICAgfVxuICAgIHNhdmVTZXNzaW9uc1RvU3RvcmFnZShzdG9yYWdlLCBzZXNzaW9ucyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltOREtdIEVycm9yIGFkZGluZy91cGRhdGluZyBzdG9yZWQgc2Vzc2lvbjpcIiwgZXJyb3IpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZW1vdmVTdG9yZWRTZXNzaW9uKHN0b3JhZ2UsIHB1YmtleSkge1xuICB0cnkge1xuICAgIGNvbnN0IHNlc3Npb25zID0gbG9hZFNlc3Npb25zRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgY29uc3QgdXBkYXRlZFNlc3Npb25zID0gc2Vzc2lvbnMuZmlsdGVyKChzKSA9PiBzLnB1YmtleSAhPT0gcHVia2V5KTtcbiAgICBzYXZlU2Vzc2lvbnNUb1N0b3JhZ2Uoc3RvcmFnZSwgdXBkYXRlZFNlc3Npb25zKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW05ES10gRXJyb3IgcmVtb3Zpbmcgc2Vzc2lvbiBmcm9tIHN0b3JhZ2U6XCIsIGVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0QWN0aXZlUHVia2V5KHN0b3JhZ2UpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBhY3RpdmVQdWJrZXkgPSBzdG9yYWdlLmdldEl0ZW0oQUNUSVZFX1BVQktFWV9TVE9SRV9LRVkpO1xuICAgIHJldHVybiBhY3RpdmVQdWJrZXkgfHwgdm9pZCAwO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbTkRLXSBFcnJvciBnZXR0aW5nIGFjdGl2ZSBwdWJrZXkgZnJvbSBzdG9yYWdlOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gc3RvcmVBY3RpdmVQdWJrZXkoc3RvcmFnZSwgcHVia2V5KSB7XG4gIHRyeSB7XG4gICAgc3RvcmFnZS5zZXRJdGVtKEFDVElWRV9QVUJLRVlfU1RPUkVfS0VZLCBwdWJrZXkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbTkRLXSBFcnJvciBzZXR0aW5nIGFjdGl2ZSBwdWJrZXkgaW4gc3RvcmFnZTpcIiwgZXJyb3IpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBjbGVhckFjdGl2ZVB1YmtleShzdG9yYWdlKSB7XG4gIHRyeSB7XG4gICAgc3RvcmFnZS5kZWxldGVJdGVtKEFDVElWRV9QVUJLRVlfU1RPUkVfS0VZKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW05ES10gRXJyb3IgY2xlYXJpbmcgYWN0aXZlIHB1YmtleSBmcm9tIHN0b3JhZ2U6XCIsIGVycm9yKTtcbiAgfVxufVxuXG4vLyBzcmMvc2Vzc2lvbi9ob29rcy91c2UtbmRrLXNlc3Npb24tbW9uaXRvci50c1xuZnVuY3Rpb24gdXNlTkRLU2Vzc2lvbk1vbml0b3Ioc2Vzc2lvblN0b3JhZ2UsIG9wdHMpIHtcbiAgY29uc3QgeyBuZGsgfSA9IHVzZU5ESygpO1xuICBjb25zdCBpc0luaXRpYWxpemVkID0gdXNlUmVmMihmYWxzZSk7XG4gIGNvbnN0IHN0b3JlZEtleXMgPSB1c2VSZWYyKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICBjb25zdCBzdG9yZWRBY3RpdmVQdWJrZXkgPSBzZXNzaW9uU3RvcmFnZSAmJiBnZXRBY3RpdmVQdWJrZXkoc2Vzc2lvblN0b3JhZ2UpO1xuICBjb25zdCBhZGRTZXNzaW9uMiA9IHVzZU5ES1Nlc3Npb25Mb2dpbigpO1xuICBjb25zdCBjdXJyZW50VXNlciA9IHVzZU5ES0N1cnJlbnRVc2VyKCk7XG4gIGNvbnN0IHNpZ25lcnMgPSB1c2VOREtTZXNzaW9uU2lnbmVycygpO1xuICBjb25zdCBzZXNzaW9ucyA9IHVzZU5ES1Nlc3Npb25TZXNzaW9ucygpO1xuICBjb25zdCBzdGFydFNlc3Npb24yID0gdXNlTkRLU2Vzc2lvblN0YXJ0KCk7XG4gIGNvbnN0IHN0b3BTZXNzaW9uMiA9IHVzZU5ES1Nlc3Npb25TdG9wKCk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGlmICghbmRrIHx8IGlzSW5pdGlhbGl6ZWQuY3VycmVudCB8fCAhc2Vzc2lvblN0b3JhZ2UpIHJldHVybjtcbiAgICBhc3luYyBmdW5jdGlvbiBpbml0aWFsaXplRnJvbVN0b3JhZ2UoKSB7XG4gICAgICBpZiAoIW5kayB8fCAhc2Vzc2lvblN0b3JhZ2UpIHJldHVybjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0b3JlZFNlc3Npb25zID0gbG9hZFNlc3Npb25zRnJvbVN0b3JhZ2Uoc2Vzc2lvblN0b3JhZ2UpO1xuICAgICAgICBpZiAoc3RvcmVkU2Vzc2lvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgc3RvcmVkU2Vzc2lvbiBvZiBzdG9yZWRTZXNzaW9ucykge1xuICAgICAgICAgIGNvbnN0IHsgcHVia2V5LCBzaWduZXJQYXlsb2FkIH0gPSBzdG9yZWRTZXNzaW9uO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gbmRrLmdldFVzZXIoeyBwdWJrZXkgfSk7XG4gICAgICAgICAgICBsZXQgc2lnbmVyID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHNpZ25lclBheWxvYWQpIHtcbiAgICAgICAgICAgICAgc2lnbmVyID0gYXdhaXQgbmRrU2lnbmVyRnJvbVBheWxvYWQoc2lnbmVyUGF5bG9hZCwgbmRrKTtcbiAgICAgICAgICAgICAgaWYgKCFzaWduZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICBgW05ES10gRmFpbGVkIHRvIGRlc2VyaWFsaXplIHNpZ25lciBmb3IgJHtwdWJrZXl9LCBzZXNzaW9uIHdpbGwgYmUgcmVhZC1vbmx5LmBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0b3JlZEtleXMuY3VycmVudC5zZXQocHVia2V5LCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RvcmVkS2V5cy5jdXJyZW50LnNldChwdWJrZXksIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGFkZFNlc3Npb24yKHNpZ25lciA/IHNpZ25lciA6IHVzZXIsIHB1YmtleSA9PT0gc3RvcmVkQWN0aXZlUHVia2V5KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgYFtOREtdIEZhaWxlZCB0byBwcm9jZXNzIHN0b3JlZCBzZXNzaW9uIGZvciBwdWJrZXkgJHtzdG9yZWRTZXNzaW9uLnB1YmtleX06YCxcbiAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiW05ES10gRXJyb3IgaW5pdGlhbGl6aW5nIHNlc3Npb25zIGZyb20gc3RvcmFnZTpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbml0aWFsaXplRnJvbVN0b3JhZ2UoKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIGlmIChzdG9yZWRBY3RpdmVQdWJrZXkpIHtcbiAgICAgICAgc3RhcnRTZXNzaW9uMihzdG9yZWRBY3RpdmVQdWJrZXksIG9wdHMgfHwge30pO1xuICAgICAgfVxuICAgICAgaXNJbml0aWFsaXplZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9KTtcbiAgfSwgW25kaywgc2Vzc2lvblN0b3JhZ2VdKTtcbiAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgaWYgKCFuZGsgfHwgIWlzSW5pdGlhbGl6ZWQuY3VycmVudCB8fCAhc2Vzc2lvblN0b3JhZ2UpIHJldHVybjtcbiAgICBhc3luYyBmdW5jdGlvbiBwZXJzaXN0U2Vzc2lvbnMoKSB7XG4gICAgICBpZiAoIW5kayB8fCAhc2Vzc2lvblN0b3JhZ2UpIHJldHVybjtcbiAgICAgIGZvciAoY29uc3QgW3B1YmtleSwgc2lnbmVyXSBvZiBzaWduZXJzKSB7XG4gICAgICAgIGlmIChzdG9yZWRLZXlzLmN1cnJlbnQuZ2V0KHB1YmtleSkpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gc2lnbmVyLnRvUGF5bG9hZCgpO1xuICAgICAgICBpZiAocGF5bG9hZCkge1xuICAgICAgICAgIGF3YWl0IGFkZE9yVXBkYXRlU3RvcmVkU2Vzc2lvbihzZXNzaW9uU3RvcmFnZSwgcHVia2V5LCBwYXlsb2FkKTtcbiAgICAgICAgICBzdG9yZWRLZXlzLmN1cnJlbnQuc2V0KHB1YmtleSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgcHVia2V5IG9mIHNlc3Npb25zLmtleXMoKSkge1xuICAgICAgICBpZiAoc3RvcmVkS2V5cy5jdXJyZW50LmhhcyhwdWJrZXkpKSBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgYWRkT3JVcGRhdGVTdG9yZWRTZXNzaW9uKHNlc3Npb25TdG9yYWdlLCBwdWJrZXkpO1xuICAgICAgICBzdG9yZWRLZXlzLmN1cnJlbnQuc2V0KHB1YmtleSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHBlcnNpc3RTZXNzaW9ucygpO1xuICB9LCBbc2Vzc2lvbnMsIHNpZ25lcnMsIG5kaywgc2Vzc2lvblN0b3JhZ2VdKTtcbiAgY29uc3QgY3VycmVudEFjdGl2ZVB1YmtleSA9IHVzZVJlZjIoY3VycmVudFVzZXI/LnB1YmtleSk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiQ3VycmVudCB1c2VyIHB1YmtleTpcIiwgY3VycmVudFVzZXI/LnB1YmtleSk7XG4gICAgaWYgKCFuZGsgfHwgIWlzSW5pdGlhbGl6ZWQuY3VycmVudCB8fCAhc2Vzc2lvblN0b3JhZ2UpIHJldHVybjtcbiAgICBpZiAoY3VycmVudFVzZXI/LnB1YmtleSA9PT0gY3VycmVudEFjdGl2ZVB1YmtleS5jdXJyZW50KSB7XG4gICAgICBjb25zb2xlLmxvZyhcIk5vIGNoYW5nZSBpbiBhY3RpdmUgcHVia2V5LCBza2lwcGluZyB1cGRhdGUuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiB1cGRhdGVBY3RpdmVQdWJrZXkoKSB7XG4gICAgICBpZiAoIW5kayB8fCAhc2Vzc2lvblN0b3JhZ2UpIHJldHVybjtcbiAgICAgIGlmIChjdXJyZW50VXNlcj8ucHVia2V5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRBY3RpdmVQdWJrZXkuY3VycmVudCAhPT0gY3VycmVudFVzZXIucHVia2V5KSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEFjdGl2ZVB1YmtleS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgIGF3YWl0IHN0b3BTZXNzaW9uMihjdXJyZW50QWN0aXZlUHVia2V5LmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEFjdGl2ZVB1YmtleS5jdXJyZW50ID0gY3VycmVudFVzZXIucHVia2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlN0b3JpbmcgYWN0aXZlIHB1YmtleTpcIiwgY3VycmVudFVzZXIucHVia2V5KTtcbiAgICAgICAgICBzdG9yZUFjdGl2ZVB1YmtleShzZXNzaW9uU3RvcmFnZSwgY3VycmVudFVzZXIucHVia2V5KTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlN0YXJ0aW5nIHNlc3Npb24gZm9yIGFjdGl2ZSBwdWJrZXk6XCIsIGN1cnJlbnRVc2VyLnB1YmtleSk7XG4gICAgICAgICAgYXdhaXQgc3RhcnRTZXNzaW9uMihjdXJyZW50VXNlci5wdWJrZXksIG9wdHMgfHwge30pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBzdGFydCBzZXNzaW9uIGZvciBhY3RpdmUgcHVia2V5ICR7Y3VycmVudFVzZXI/LnB1YmtleX06YCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCBjbGVhckFjdGl2ZVB1YmtleShzZXNzaW9uU3RvcmFnZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUFjdGl2ZVB1YmtleSgpO1xuICB9LCBbY3VycmVudFVzZXI/LnB1YmtleSwgbmRrLCBzZXNzaW9uU3RvcmFnZV0pO1xuICBjb25zdCBwcmV2U2Vzc2lvbnNSZWYgPSB1c2VSZWYyKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICBpZiAoIXNlc3Npb25TdG9yYWdlKSByZXR1cm47XG4gICAgY29uc3QgY3VycmVudFNlc3Npb25zID0gc2Vzc2lvbnM7XG4gICAgY29uc3QgcHJldlNlc3Npb25zID0gcHJldlNlc3Npb25zUmVmLmN1cnJlbnQ7XG4gICAgcHJldlNlc3Npb25zLmZvckVhY2goKF8sIHB1YmtleSkgPT4ge1xuICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbnMuaGFzKHB1YmtleSkpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFNlc3Npb24gJHtwdWJrZXl9IGRldGVjdGVkIGFzIHJlbW92ZWQsIHVwZGF0aW5nIHN0b3JhZ2UuYCk7XG4gICAgICAgIHJlbW92ZVN0b3JlZFNlc3Npb24oc2Vzc2lvblN0b3JhZ2UsIHB1YmtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHJldlNlc3Npb25zUmVmLmN1cnJlbnQgPSBuZXcgTWFwKGN1cnJlbnRTZXNzaW9ucyk7XG4gIH0sIFtzZXNzaW9ucywgc2Vzc2lvblN0b3JhZ2VdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIHNyYy9tdXRlcy9ob29rcy91c2UtaXMtaXRlbS1tdXRlZC50c1xuaW1wb3J0IHsgdXNlTWVtbyBhcyB1c2VNZW1vNCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgTkRLRXZlbnQgYXMgTkRLRXZlbnQzLCBOREtVc2VyIGFzIE5ES1VzZXIzIH0gZnJvbSBcIkBub3N0ci1kZXYta2l0L25ka1wiO1xuXG4vLyBzcmMvbXV0ZXMvaG9va3MvdXNlLW11dGUtY3JpdGVyaWEudHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q0LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL211dGVzL2hvb2tzL3VzZS1tdXRlLWZpbHRlci50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s0IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy91dGlscy9tdXRlLnRzXG52YXIgaXNNdXRlZCA9IChldmVudCwgY3JpdGVyaWEpID0+IHtcbiAgaWYgKCFjcml0ZXJpYSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCB7IHB1YmtleXMsIGV2ZW50SWRzLCBoYXNodGFncywgd29yZHMgfSA9IGNyaXRlcmlhO1xuICBpZiAocHVia2V5cy5oYXMoZXZlbnQucHVia2V5KSkgcmV0dXJuIHRydWU7XG4gIGlmIChldmVudElkcy5oYXMoZXZlbnQuaWQpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGV2ZW50SWRzLnNpemUgPiAwIHx8IGhhc2h0YWdzLnNpemUgPiAwKSB7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgZXZlbnQudGFncykge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgJiYgZXZlbnRJZHMuaGFzKHRhZ1sxXSkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJ0XCIgJiYgaGFzaHRhZ3MuaGFzKHRhZ1sxXSkpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAod29yZHMgJiYgd29yZHMuc2l6ZSA+IDAgJiYgZXZlbnQuY29udGVudCkge1xuICAgIGNvbnN0IHdvcmRzSW5Db250ZW50ID0gZXZlbnQuY29udGVudC5zcGxpdCgvXFxzKy8pLm1hcCgod29yZCkgPT4gd29yZC50b0xvd2VyQ2FzZSgpKTtcbiAgICBmb3IgKGNvbnN0IHdvcmQgb2Ygd29yZHNJbkNvbnRlbnQpIHtcbiAgICAgIGlmICh3b3Jkcy5oYXMod29yZCkpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBzcmMvbXV0ZXMvaG9va3MvdXNlLW11dGUtZmlsdGVyLnRzXG52YXIgRU1QVFlfTVVURV9DUklURVJJQSA9IHtcbiAgcHVia2V5czogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgZXZlbnRJZHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gIGhhc2h0YWdzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICB3b3JkczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxufTtcbmZ1bmN0aW9uIHVzZU11dGVGaWx0ZXIoKSB7XG4gIGNvbnN0IG11dGVDcml0ZXJpYSA9IHVzZUFjdGl2ZU11dGVDcml0ZXJpYSgpO1xuICBjb25zb2xlLmxvZyhcInVzZU11dGVGaWx0ZXJcIiwgbXV0ZUNyaXRlcmlhKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrNChcbiAgICAoZXZlbnQpID0+IHtcbiAgICAgIHJldHVybiBpc011dGVkKGV2ZW50LCBtdXRlQ3JpdGVyaWEpO1xuICAgIH0sXG4gICAgW211dGVDcml0ZXJpYV1cbiAgKTtcbn1cblxuLy8gc3JjL211dGVzL2hvb2tzL3VzZS1tdXRlLWNyaXRlcmlhLnRzXG5mdW5jdGlvbiB1c2VBY3RpdmVNdXRlQ3JpdGVyaWEoKSB7XG4gIHJldHVybiB1c2VOREtNdXRlcygocykgPT4gcy5tdXRlQ3JpdGVyaWEpO1xufVxuZnVuY3Rpb24gdXNlTXV0ZUNyaXRlcmlhKHB1YmtleSkge1xuICBjb25zdCBtdXRlc0ZvclB1YmtleSA9IHVzZU5ES011dGVzKChzKSA9PiBwdWJrZXkgPyBzLm11dGVzLmdldChwdWJrZXkpIDogRU1QVFlfTVVURV9DUklURVJJQSk7XG4gIGNvbnN0IGV4dHJhTXV0ZXMgPSB1c2VOREtNdXRlcygocykgPT4gcy5leHRyYU11dGVzKTtcbiAgY29uc3QgW2NyaXRlcmlhLCBzZXRDcml0ZXJpYV0gPSB1c2VTdGF0ZTIoRU1QVFlfTVVURV9DUklURVJJQSk7XG4gIHVzZUVmZmVjdDQoKCkgPT4ge1xuICAgIGNvbnN0IGNvbWJpbmVkTXV0ZXMgPSB7XG4gICAgICBldmVudElkczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLm11dGVzRm9yUHVia2V5Py5ldmVudElkcyB8fCBbXSwgLi4uZXh0cmFNdXRlcz8uZXZlbnRJZHMgfHwgW11dKSxcbiAgICAgIGhhc2h0YWdzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4ubXV0ZXNGb3JQdWJrZXk/Lmhhc2h0YWdzIHx8IFtdLCAuLi5leHRyYU11dGVzPy5oYXNodGFncyB8fCBbXV0pLFxuICAgICAgd29yZHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi5tdXRlc0ZvclB1YmtleT8ud29yZHMgfHwgW10sIC4uLmV4dHJhTXV0ZXM/LndvcmRzIHx8IFtdXSksXG4gICAgICBwdWJrZXlzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4ubXV0ZXNGb3JQdWJrZXk/LnB1YmtleXMgfHwgW10sIC4uLmV4dHJhTXV0ZXM/LnB1YmtleXMgfHwgW11dKVxuICAgIH07XG4gICAgc2V0Q3JpdGVyaWEoY29tYmluZWRNdXRlcyk7XG4gIH0sIFtcbiAgICBtdXRlc0ZvclB1YmtleT8uZXZlbnRJZHMsXG4gICAgbXV0ZXNGb3JQdWJrZXk/Lmhhc2h0YWdzLFxuICAgIG11dGVzRm9yUHVia2V5Py53b3JkcyxcbiAgICBtdXRlc0ZvclB1YmtleT8ucHVia2V5cyxcbiAgICBleHRyYU11dGVzPy5ldmVudElkcyxcbiAgICBleHRyYU11dGVzPy5oYXNodGFncyxcbiAgICBleHRyYU11dGVzPy53b3JkcyxcbiAgICBleHRyYU11dGVzPy5wdWJrZXlzXG4gIF0pO1xuICByZXR1cm4gY3JpdGVyaWE7XG59XG5cbi8vIHNyYy9tdXRlcy9ob29rcy91c2UtaXMtaXRlbS1tdXRlZC50c1xuZnVuY3Rpb24gdXNlSXNJdGVtTXV0ZWQoaXRlbSkge1xuICBjb25zdCBtdXRlQ3JpdGVyaWEgPSB1c2VBY3RpdmVNdXRlQ3JpdGVyaWEoKTtcbiAgcmV0dXJuIHVzZU1lbW80KCgpID0+IHtcbiAgICBsZXQgaXRlbVR5cGU7XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTkRLRXZlbnQzKSB7XG4gICAgICBpdGVtVHlwZSA9IFwiZXZlbnRcIjtcbiAgICAgIHZhbHVlID0gaXRlbS5pZDtcbiAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtVc2VyMykge1xuICAgICAgaXRlbVR5cGUgPSBcInB1YmtleVwiO1xuICAgICAgdmFsdWUgPSBpdGVtLnB1YmtleTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoaXRlbS5zdGFydHNXaXRoKFwiI1wiKSAmJiBpdGVtLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaXRlbVR5cGUgPSBcImhhc2h0YWdcIjtcbiAgICAgICAgdmFsdWUgPSBpdGVtLnN1YnN0cmluZygxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1UeXBlID0gXCJ3b3JkXCI7XG4gICAgICAgIHZhbHVlID0gaXRlbTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzd2l0Y2ggKGl0ZW1UeXBlKSB7XG4gICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgcmV0dXJuIG11dGVDcml0ZXJpYS5ldmVudElkcy5oYXModmFsdWUpO1xuICAgICAgY2FzZSBcInB1YmtleVwiOlxuICAgICAgICByZXR1cm4gbXV0ZUNyaXRlcmlhLnB1YmtleXMuaGFzKHZhbHVlKTtcbiAgICAgIGNhc2UgXCJoYXNodGFnXCI6XG4gICAgICAgIHJldHVybiBtdXRlQ3JpdGVyaWEuaGFzaHRhZ3MuaGFzKHZhbHVlKTtcbiAgICAgIGNhc2UgXCJ3b3JkXCI6XG4gICAgICAgIHJldHVybiBtdXRlQ3JpdGVyaWEud29yZHMuaGFzKHZhbHVlKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIFttdXRlQ3JpdGVyaWEsIGl0ZW1dKTtcbn1cblxuLy8gc3JjL211dGVzL2hvb2tzL3VzZS1tdXRlLWl0ZW0udHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrNSB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlTXV0ZUl0ZW0ob3B0aW9ucykge1xuICBjb25zdCBjdXJyZW50UHVia2V5ID0gdXNlTkRLQ3VycmVudFB1YmtleSgpO1xuICBjb25zdCBtdXRlSXRlbTIgPSB1c2VOREtNdXRlcygocykgPT4gcy5tdXRlSXRlbSk7XG4gIHJldHVybiB1c2VDYWxsYmFjazUoXG4gICAgKGl0ZW0pID0+IHtcbiAgICAgIGlmICghY3VycmVudFB1YmtleSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJ1c2VNdXRlSXRlbTogTm8gYWN0aXZlIHVzZXIgZm91bmQuIENhbm5vdCBtdXRlIGl0ZW0uXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpZGVudGlmaWVkID0gaWRlbnRpZnlNdXRlSXRlbShpdGVtKTtcbiAgICAgIGlmICghaWRlbnRpZmllZCkgcmV0dXJuO1xuICAgICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gaWRlbnRpZmllZDtcbiAgICAgIG11dGVJdGVtMihjdXJyZW50UHVia2V5LCB2YWx1ZSwgdHlwZSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBbY3VycmVudFB1YmtleSwgbXV0ZUl0ZW0yLCBvcHRpb25zXVxuICApO1xufVxuXG4vLyBzcmMvbXV0ZXMvaG9va3MvdXNlLXB1Ymxpc2gtbXV0ZS1saXN0LnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazYgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZVB1Ymxpc2hNdXRlTGlzdCgpIHtcbiAgY29uc3QgY3VycmVudFB1YmtleSA9IHVzZU5ES0N1cnJlbnRQdWJrZXkoKTtcbiAgY29uc3QgcHVibGlzaE11dGVMaXN0MiA9IHVzZU5ES011dGVzKChzKSA9PiBzLnB1Ymxpc2hNdXRlTGlzdCk7XG4gIHJldHVybiB1c2VDYWxsYmFjazYoYXN5bmMgKCkgPT4ge1xuICAgIGlmICghY3VycmVudFB1YmtleSkge1xuICAgICAgY29uc29sZS53YXJuKFwidXNlUHVibGlzaE11dGVMaXN0OiBObyBhY3RpdmUgdXNlciBmb3VuZC4gQ2Fubm90IHB1Ymxpc2ggbXV0ZSBsaXN0LlwiKTtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBwdWJsaXNoTXV0ZUxpc3QyKGN1cnJlbnRQdWJrZXkpO1xuICB9LCBbY3VycmVudFB1YmtleSwgcHVibGlzaE11dGVMaXN0Ml0pO1xufVxuXG4vLyBzcmMvbXV0ZXMvaG9va3MvdXNlLXVubXV0ZS1pdGVtLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazcgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IE5ES0V2ZW50IGFzIE5ES0V2ZW50NCwgTkRLVXNlciBhcyBOREtVc2VyNCB9IGZyb20gXCJAbm9zdHItZGV2LWtpdC9uZGtcIjtcbmZ1bmN0aW9uIHVzZVVubXV0ZUl0ZW0ob3B0aW9ucykge1xuICBjb25zdCBjdXJyZW50UHVia2V5ID0gdXNlTkRLQ3VycmVudFB1YmtleSgpO1xuICBjb25zdCB1bm11dGVJdGVtMiA9IHVzZU5ES011dGVzKChzKSA9PiBzLnVubXV0ZUl0ZW0pO1xuICByZXR1cm4gdXNlQ2FsbGJhY2s3KFxuICAgIChpdGVtKSA9PiB7XG4gICAgICBpZiAoIWN1cnJlbnRQdWJrZXkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwidXNlVW5tdXRlSXRlbTogTm8gYWN0aXZlIHVzZXIgZm91bmQuIENhbm5vdCB1bm11dGUgaXRlbS5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBpdGVtVHlwZTtcbiAgICAgIGxldCB2YWx1ZTtcbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTkRLRXZlbnQ0KSB7XG4gICAgICAgIGl0ZW1UeXBlID0gXCJldmVudFwiO1xuICAgICAgICB2YWx1ZSA9IGl0ZW0uaWQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtVc2VyNCkge1xuICAgICAgICBpdGVtVHlwZSA9IFwicHVia2V5XCI7XG4gICAgICAgIHZhbHVlID0gaXRlbS5wdWJrZXk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChpdGVtLnN0YXJ0c1dpdGgoXCIjXCIpICYmIGl0ZW0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGl0ZW1UeXBlID0gXCJoYXNodGFnXCI7XG4gICAgICAgICAgdmFsdWUgPSBpdGVtLnN1YnN0cmluZygxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtVHlwZSA9IFwid29yZFwiO1xuICAgICAgICAgIHZhbHVlID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwidXNlVW5tdXRlSXRlbTogSW52YWxpZCBpdGVtIHR5cGUgcHJvdmlkZWQuXCIsIGl0ZW0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1bm11dGVJdGVtMihjdXJyZW50UHVia2V5LCB2YWx1ZSwgaXRlbVR5cGUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgW2N1cnJlbnRQdWJrZXksIHVubXV0ZUl0ZW0yLCBvcHRpb25zXVxuICApO1xufVxuXG4vLyBzcmMvb2JzZXJ2ZXIvaG9va3MvaW5kZXgudHNcbmltcG9ydCB7XG4gIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2Vcbn0gZnJvbSBcIkBub3N0ci1kZXYta2l0L25ka1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s4LCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NSwgdXNlUmVmIGFzIHVzZVJlZjMsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMyB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlT2JzZXJ2ZXIoZmlsdGVycywgb3B0cyA9IHt9LCBkZXBlbmRlbmNpZXMgPSBbXSkge1xuICBjb25zdCB7IG5kayB9ID0gdXNlTkRLKCk7XG4gIGNvbnN0IHN1YiA9IHVzZVJlZjMobnVsbCk7XG4gIGNvbnN0IFtldmVudHMsIHNldEV2ZW50c10gPSB1c2VTdGF0ZTMoW10pO1xuICBjb25zdCBidWZmZXIgPSB1c2VSZWYzKFtdKTtcbiAgY29uc3QgYnVmZmVyVGltZW91dCA9IHVzZVJlZjMobnVsbCk7XG4gIGNvbnN0IGFkZGVkRXZlbnRJZHMgPSB1c2VSZWYzKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICBjb25zb2xlLmxvZyhcInVzZU9ic2VydmVyXCIpO1xuICBjb25zdCBtdXRlRmlsdGVyID0gdXNlTXV0ZUZpbHRlcigpO1xuICBkZXBlbmRlbmNpZXMucHVzaCghIWZpbHRlcnMpO1xuICBjb25zdCBzdG9wRmlsdGVycyA9IHVzZUNhbGxiYWNrOCgoKSA9PiB7XG4gICAgaWYgKHN1Yi5jdXJyZW50KSBzdWIuY3VycmVudC5zdG9wKCk7XG4gICAgc3ViLmN1cnJlbnQgPSBudWxsO1xuICAgIGJ1ZmZlci5jdXJyZW50ID0gW107XG4gICAgaWYgKGJ1ZmZlclRpbWVvdXQuY3VycmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGJ1ZmZlclRpbWVvdXQuY3VycmVudCk7XG4gICAgICBidWZmZXJUaW1lb3V0LmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBhZGRlZEV2ZW50SWRzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICBzZXRFdmVudHMoW10pO1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdDUoKCkgPT4ge1xuICAgIGlmICghbmRrIHx8ICFmaWx0ZXJzKSByZXR1cm47XG4gICAgbGV0IGlzVmFsaWQgPSB0cnVlO1xuICAgIGlmIChzdWIuY3VycmVudCkgc3RvcEZpbHRlcnMoKTtcbiAgICBjb25zdCBwcm9jZXNzRXZlbnQyID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoIWlzVmFsaWQpIHJldHVybjtcbiAgICAgIGlmICghb3B0cy5pbmNsdWRlTXV0ZWQgJiYgbXV0ZUZpbHRlcihldmVudCkpIHJldHVybjtcbiAgICAgIGNvbnN0IHRhZ0lkID0gZXZlbnQudGFnSWQoKTtcbiAgICAgIGlmIChhZGRlZEV2ZW50SWRzLmN1cnJlbnQuaGFzKHRhZ0lkKSkgcmV0dXJuO1xuICAgICAgYWRkZWRFdmVudElkcy5jdXJyZW50LmFkZCh0YWdJZCk7XG4gICAgICBidWZmZXIuY3VycmVudC5wdXNoKGV2ZW50KTtcbiAgICAgIGlmICghYnVmZmVyVGltZW91dC5jdXJyZW50KSB7XG4gICAgICAgIGJ1ZmZlclRpbWVvdXQuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHNldEV2ZW50cygocHJldikgPT4gWy4uLnByZXYsIC4uLmJ1ZmZlci5jdXJyZW50XSk7XG4gICAgICAgICAgYnVmZmVyLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgICBidWZmZXJUaW1lb3V0LmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9LCA1MCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBzdWIuY3VycmVudCA9IG5kay5zdWJzY3JpYmUoXG4gICAgICBmaWx0ZXJzLFxuICAgICAge1xuICAgICAgICBjbG9zZU9uRW9zZTogdHJ1ZSxcbiAgICAgICAgY2FjaGVVc2FnZTogTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZS5PTkxZX0NBQ0hFLFxuICAgICAgICBncm91cGFibGU6IGZhbHNlLFxuICAgICAgICB3cmFwOiB0cnVlLFxuICAgICAgICAuLi5vcHRzXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBvbkV2ZW50OiAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoIWlzVmFsaWQpIHJldHVybjtcbiAgICAgICAgICBwcm9jZXNzRXZlbnQyKGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FdmVudHM6IChldmVudHMyKSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWQgPSAhb3B0cy5pbmNsdWRlTXV0ZWQgPyBldmVudHMyLmZpbHRlcigoZSkgPT4gIW11dGVGaWx0ZXIoZSkpIDogZXZlbnRzMjtcbiAgICAgICAgICBzZXRFdmVudHMoZmlsdGVyZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAoYnVmZmVyLmN1cnJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGJ1ZmZlclRpbWVvdXQuY3VycmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoYnVmZmVyVGltZW91dC5jdXJyZW50KTtcbiAgICAgICAgYnVmZmVyVGltZW91dC5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGJ1ZmZlci5jdXJyZW50ID0gW107XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICBzdG9wRmlsdGVycygpO1xuICAgIH07XG4gIH0sIFtuZGssIC4uLmRlcGVuZGVuY2llc10pO1xuICByZXR1cm4gZXZlbnRzO1xufVxuXG4vLyBzcmMvc3Vic2NyaWJlL2hvb2tzL3N1YnNjcmliZS50c1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDYsIHVzZVJlZiBhcyB1c2VSZWY0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gXCJ6dXN0YW5kXCI7XG5cbi8vIHNyYy9zdWJzY3JpYmUvc3RvcmUvaW5kZXgudHNcbmltcG9ydCB7IGNyZWF0ZVN0b3JlIH0gZnJvbSBcInp1c3RhbmQvdmFuaWxsYVwiO1xudmFyIGNyZWF0ZVN1YnNjcmliZVN0b3JlID0gKGJ1ZmZlck1zID0gMzApID0+IHtcbiAgY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZSgoc2V0LCBnZXQpID0+IHtcbiAgICBjb25zdCBidWZmZXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCB0aW1lb3V0ID0gbnVsbDtcbiAgICBjb25zdCBmbHVzaEJ1ZmZlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICBjb25zdCBuZXdFdmVudE1hcCA9IG5ldyBNYXAoc3RhdGUuZXZlbnRNYXApO1xuICAgICAgbGV0IGhhc0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgW2lkLCBldmVudF0gb2YgYnVmZmVyLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBleGlzdGluZ0V2ZW50ID0gbmV3RXZlbnRNYXAuZ2V0KGlkKTtcbiAgICAgICAgaWYgKCFleGlzdGluZ0V2ZW50IHx8IGV4aXN0aW5nRXZlbnQuY3JlYXRlZF9hdCAhPT0gdm9pZCAwICYmIGV2ZW50LmNyZWF0ZWRfYXQgIT09IHZvaWQgMCAmJiBldmVudC5jcmVhdGVkX2F0ID4gZXhpc3RpbmdFdmVudC5jcmVhdGVkX2F0KSB7XG4gICAgICAgICAgbmV3RXZlbnRNYXAuc2V0KGlkLCBldmVudCk7XG4gICAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJ1ZmZlci5jbGVhcigpO1xuICAgICAgaWYgKGhhc0NoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgbmV3RXZlbnRzID0gQXJyYXkuZnJvbShuZXdFdmVudE1hcC52YWx1ZXMoKSk7XG4gICAgICAgIHNldCh7IGV2ZW50TWFwOiBuZXdFdmVudE1hcCwgZXZlbnRzOiBuZXdFdmVudHMgfSk7XG4gICAgICB9XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBldmVudHM6IFtdLFxuICAgICAgZXZlbnRNYXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBlb3NlOiBmYWxzZSxcbiAgICAgIHN1YnNjcmlwdGlvblJlZjogdm9pZCAwLFxuICAgICAgYWRkRXZlbnQ6IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IGV2ZW50LnRhZ0lkKCk7XG4gICAgICAgIGlmIChidWZmZXJNcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBjb25zdCBleGlzdGluZ0luQnVmZmVyID0gYnVmZmVyLmdldChpZCk7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdJblN0b3JlID0gZ2V0KCkuZXZlbnRNYXAuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoZXhpc3RpbmdJbkJ1ZmZlciAmJiBleGlzdGluZ0luQnVmZmVyLmNyZWF0ZWRfYXQgIT09IHZvaWQgMCAmJiBldmVudC5jcmVhdGVkX2F0ICE9PSB2b2lkIDAgJiYgZXhpc3RpbmdJbkJ1ZmZlci5jcmVhdGVkX2F0ID49IGV2ZW50LmNyZWF0ZWRfYXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4aXN0aW5nSW5TdG9yZSAmJiBleGlzdGluZ0luU3RvcmUuY3JlYXRlZF9hdCAhPT0gdm9pZCAwICYmIGV2ZW50LmNyZWF0ZWRfYXQgIT09IHZvaWQgMCAmJiBleGlzdGluZ0luU3RvcmUuY3JlYXRlZF9hdCA+PSBldmVudC5jcmVhdGVkX2F0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZmZlci5zZXQoaWQsIGV2ZW50KTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZsdXNoQnVmZmVyLCBidWZmZXJNcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgICAgY29uc3QgbmV3RXZlbnRNYXAgPSBuZXcgTWFwKHN0YXRlLmV2ZW50TWFwKTtcbiAgICAgICAgICBjb25zdCBleGlzdGluZ0V2ZW50ID0gbmV3RXZlbnRNYXAuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoZXhpc3RpbmdFdmVudCAmJiBleGlzdGluZ0V2ZW50LmNyZWF0ZWRfYXQgIT09IHZvaWQgMCAmJiBldmVudC5jcmVhdGVkX2F0ICE9PSB2b2lkIDAgJiYgZXhpc3RpbmdFdmVudC5jcmVhdGVkX2F0ID49IGV2ZW50LmNyZWF0ZWRfYXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV3RXZlbnRNYXAuc2V0KGlkLCBldmVudCk7XG4gICAgICAgICAgY29uc3QgbmV3RXZlbnRzID0gQXJyYXkuZnJvbShuZXdFdmVudE1hcC52YWx1ZXMoKSk7XG4gICAgICAgICAgc2V0KHsgZXZlbnRNYXA6IG5ld0V2ZW50TWFwLCBldmVudHM6IG5ld0V2ZW50cyB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFkZEV2ZW50czogKGV2ZW50cykgPT4ge1xuICAgICAgICBpZiAoIWV2ZW50cyB8fCBldmVudHMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIGlmIChidWZmZXJNcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBsZXQgbmVlZHNGbHVzaCA9IGZhbHNlO1xuICAgICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50KSBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZXZlbnQudGFnSWQoKTtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSW5CdWZmZXIgPSBidWZmZXIuZ2V0KGlkKTtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSW5TdG9yZSA9IGdldCgpLmV2ZW50TWFwLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdJbkJ1ZmZlciAmJiBleGlzdGluZ0luQnVmZmVyLmNyZWF0ZWRfYXQgIT09IHZvaWQgMCAmJiBldmVudC5jcmVhdGVkX2F0ICE9PSB2b2lkIDAgJiYgZXhpc3RpbmdJbkJ1ZmZlci5jcmVhdGVkX2F0ID49IGV2ZW50LmNyZWF0ZWRfYXQpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdJblN0b3JlICYmIGV4aXN0aW5nSW5TdG9yZS5jcmVhdGVkX2F0ICE9PSB2b2lkIDAgJiYgZXZlbnQuY3JlYXRlZF9hdCAhPT0gdm9pZCAwICYmIGV4aXN0aW5nSW5TdG9yZS5jcmVhdGVkX2F0ID49IGV2ZW50LmNyZWF0ZWRfYXQpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGlkLCBldmVudCk7XG4gICAgICAgICAgICBuZWVkc0ZsdXNoID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5lZWRzRmx1c2ggJiYgIXRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZsdXNoQnVmZmVyLCBidWZmZXJNcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgICAgY29uc3QgbmV3RXZlbnRNYXAgPSBuZXcgTWFwKHN0YXRlLmV2ZW50TWFwKTtcbiAgICAgICAgICBsZXQgaGFzVXBkYXRlcyA9IGZhbHNlO1xuICAgICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50KSBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZXZlbnQudGFnSWQoKTtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRXZlbnQgPSBuZXdFdmVudE1hcC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRXZlbnQgJiYgZXhpc3RpbmdFdmVudC5jcmVhdGVkX2F0ICE9PSB2b2lkIDAgJiYgZXZlbnQuY3JlYXRlZF9hdCAhPT0gdm9pZCAwICYmIGV4aXN0aW5nRXZlbnQuY3JlYXRlZF9hdCA+PSBldmVudC5jcmVhdGVkX2F0KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3RXZlbnRNYXAuc2V0KGlkLCBldmVudCk7XG4gICAgICAgICAgICBoYXNVcGRhdGVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhc1VwZGF0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0V2ZW50cyA9IEFycmF5LmZyb20obmV3RXZlbnRNYXAudmFsdWVzKCkpO1xuICAgICAgICAgICAgc2V0KHsgZXZlbnRNYXA6IG5ld0V2ZW50TWFwLCBldmVudHM6IG5ld0V2ZW50cyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW1vdmVFdmVudElkOiAoaWQpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICAgICAgY29uc3QgbmV3RXZlbnRNYXAgPSBuZXcgTWFwKHN0YXRlLmV2ZW50TWFwKTtcbiAgICAgICAgbmV3RXZlbnRNYXAuZGVsZXRlKGlkKTtcbiAgICAgICAgY29uc3QgbmV3RXZlbnRzID0gQXJyYXkuZnJvbShuZXdFdmVudE1hcC52YWx1ZXMoKSk7XG4gICAgICAgIHNldCh7IGV2ZW50TWFwOiBuZXdFdmVudE1hcCwgZXZlbnRzOiBuZXdFdmVudHMgfSk7XG4gICAgICB9LFxuICAgICAgZmlsdGVyTXV0ZWRFdmVudHM6IChtdXRlRmlsdGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRFdmVudE1hcCA9IHN0YXRlLmV2ZW50TWFwO1xuICAgICAgICBjb25zdCBuZXdFdmVudE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2lkLCBldmVudF0gb2YgY3VycmVudEV2ZW50TWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgIGlmICghbXV0ZUZpbHRlcihldmVudCkpIHtcbiAgICAgICAgICAgIG5ld0V2ZW50TWFwLnNldChpZCwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdFdmVudHMgPSBBcnJheS5mcm9tKG5ld0V2ZW50TWFwLnZhbHVlcygpKTtcbiAgICAgICAgc2V0KHsgZXZlbnRNYXA6IG5ld0V2ZW50TWFwLCBldmVudHM6IG5ld0V2ZW50cyB9KTtcbiAgICAgIH0sXG4gICAgICBzZXRFb3NlOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIGZsdXNoQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KHsgZW9zZTogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKGJ1ZmZlck1zICE9PSBmYWxzZSkge1xuICAgICAgICAgIGJ1ZmZlck1zID0gMTY7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICBidWZmZXIuY2xlYXIoKTtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KHtcbiAgICAgICAgICBldmVudHM6IFtdLFxuICAgICAgICAgIGV2ZW50TWFwOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgICAgIGVvc2U6IGZhbHNlLFxuICAgICAgICAgIHN1YnNjcmlwdGlvblJlZjogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gc3RvcmU7XG59O1xuXG4vLyBzcmMvc3Vic2NyaWJlL2hvb2tzL3N1YnNjcmliZS50c1xuZnVuY3Rpb24gdXNlU3Vic2NyaWJlKGZpbHRlcnMsIG9wdHMgPSB7fSwgZGVwZW5kZW5jaWVzID0gW10pIHtcbiAgY29uc3QgeyBuZGsgfSA9IHVzZU5ESygpO1xuICBjb25zdCBtdXRlRmlsdGVyID0gdXNlTXV0ZUZpbHRlcigpO1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVJlZjQobnVsbCk7XG4gIGlmICghc3RvcmVSZWYuY3VycmVudCkge1xuICAgIHN0b3JlUmVmLmN1cnJlbnQgPSBjcmVhdGVTdWJzY3JpYmVTdG9yZShvcHRzLmJ1ZmZlck1zKTtcbiAgfVxuICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gIGNvbnN0IHN1YlJlZiA9IHVzZVJlZjQobnVsbCk7XG4gIHVzZUVmZmVjdDYoKCkgPT4ge1xuICAgIGlmICghbmRrIHx8ICFmaWx0ZXJzKSByZXR1cm47XG4gICAgaWYgKHN1YlJlZi5jdXJyZW50KSB7XG4gICAgICBzdWJSZWYuY3VycmVudC5zdG9wKCk7XG4gICAgICBzdWJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNldHVwU3Vic2NyaXB0aW9uID0gKCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudEZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgICAgY29uc3QgaGFuZGxlRXZlbnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCFvcHRzLmluY2x1ZGVEZWxldGVkICYmIGV2ZW50Lmhhc1RhZyhcImRlbGV0ZWRcIikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRzLmluY2x1ZGVNdXRlZCAmJiBtdXRlRmlsdGVyKGV2ZW50KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5vbmNlKFwiZGVsZXRlZFwiLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUyID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBzdGF0ZTIucmVtb3ZlRXZlbnRJZChldmVudC50YWdJZCgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgc3RhdGUuYWRkRXZlbnQoZXZlbnQpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGhhbmRsZUNhY2hlZEV2ZW50cyA9IChldmVudHMyKSA9PiB7XG4gICAgICAgIGlmIChldmVudHMyICYmIGV2ZW50czIubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHZhbGlkRXZlbnRzID0gZXZlbnRzMi5maWx0ZXIoKGUpID0+IHtcbiAgICAgICAgICAgIGlmICghb3B0cy5pbmNsdWRlRGVsZXRlZCAmJiBlLmhhc1RhZyhcImRlbGV0ZWRcIikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghb3B0cy5pbmNsdWRlTXV0ZWQgJiYgbXV0ZUZpbHRlcihlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHZhbGlkRXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHN0YXRlLmFkZEV2ZW50cyh2YWxpZEV2ZW50cyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV2dCBvZiB2YWxpZEV2ZW50cykge1xuICAgICAgICAgICAgICBldnQub25jZShcImRlbGV0ZWRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlMiA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgc3RhdGUyLnJlbW92ZUV2ZW50SWQoZXZ0LnRhZ0lkKCkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBoYW5kbGVFb3NlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIHN0YXRlLnNldEVvc2UoKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzdWIgPSBuZGsuc3Vic2NyaWJlKGN1cnJlbnRGaWx0ZXJzLCBvcHRzLCB7XG4gICAgICAgIG9uRXZlbnQ6IGhhbmRsZUV2ZW50LFxuICAgICAgICBvbkV2ZW50czogaGFuZGxlQ2FjaGVkRXZlbnRzLFxuICAgICAgICBvbkVvc2U6IGhhbmRsZUVvc2VcbiAgICAgIH0pO1xuICAgICAgc3ViUmVmLmN1cnJlbnQgPSBzdWI7XG4gICAgfTtcbiAgICBzZXR1cFN1YnNjcmlwdGlvbigpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoc3ViUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgc3ViUmVmLmN1cnJlbnQuc3RvcCgpO1xuICAgICAgICBzdWJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW25kaywgbXV0ZUZpbHRlciwgISFmaWx0ZXJzLCAuLi5kZXBlbmRlbmNpZXNdKTtcbiAgdXNlRWZmZWN0NigoKSA9PiB7XG4gICAgaWYgKCFvcHRzLmluY2x1ZGVNdXRlZCkge1xuICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgc3RhdGUuZmlsdGVyTXV0ZWRFdmVudHMobXV0ZUZpbHRlcik7XG4gICAgfVxuICB9LCBbbXV0ZUZpbHRlciwgc3RvcmUsIG9wdHMuaW5jbHVkZU11dGVkXSk7XG4gIGNvbnN0IGV2ZW50cyA9IHVzZVN0b3JlKHN0b3JlLCAocykgPT4gcy5ldmVudHMpO1xuICBjb25zdCBlb3NlID0gdXNlU3RvcmUoc3RvcmUsIChzKSA9PiBzLmVvc2UpO1xuICByZXR1cm4geyBldmVudHMsIGVvc2UgfTtcbn1cblxuLy8gc3JjL3N1YnNjcmliZS9ob29rcy9ldmVudC50c1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDcsIHVzZVN0YXRlIGFzIHVzZVN0YXRlNCB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlRXZlbnQoaWRPckZpbHRlciwgb3B0cyA9IHt9LCBkZXBlbmRlbmNpZXMgPSBbXSkge1xuICBjb25zdCBbZXZlbnQsIHNldEV2ZW50XSA9IHVzZVN0YXRlNCgpO1xuICBjb25zdCB7IG5kayB9ID0gdXNlTkRLKCk7XG4gIGRlcGVuZGVuY2llcy5wdXNoKCEhaWRPckZpbHRlcik7XG4gIHVzZUVmZmVjdDcoKCkgPT4ge1xuICAgIGFzeW5jIGZ1bmN0aW9uIGZldGNoRXZlbnQoKSB7XG4gICAgICBpZiAoIW5kayB8fCAhaWRPckZpbHRlcikgcmV0dXJuO1xuICAgICAgY29uc3QgZXZlbnRzID0gYXdhaXQgbmRrLmZldGNoRXZlbnQoaWRPckZpbHRlciwgb3B0cyk7XG4gICAgICBzZXRFdmVudChldmVudHMpO1xuICAgIH1cbiAgICBmZXRjaEV2ZW50KCk7XG4gIH0sIGRlcGVuZGVuY2llcyk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLy8gc3JjL3Nlc3Npb24vaG9va3MvdXNlLWF2YWlsYWJsZS1zZXNzaW9ucy50c1xuaW1wb3J0IHsgdXNlTWVtbyBhcyB1c2VNZW1vNSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZUF2YWlsYWJsZVNlc3Npb25zID0gKCkgPT4ge1xuICBjb25zdCBzZXNzaW9ucyA9IHVzZU5ES1Nlc3Npb25zKChzdGF0ZSkgPT4gc3RhdGUuc2Vzc2lvbnMpO1xuICBjb25zdCBhdmFpbGFibGVQdWJrZXlzID0gdXNlTWVtbzUoXG4gICAgKCkgPT4gQXJyYXkuZnJvbShzZXNzaW9ucy5rZXlzKCkpLFxuICAgIC8vIEdldCBrZXlzIGZyb20gc2Vzc2lvbnMgbWFwXG4gICAgW3Nlc3Npb25zXVxuICApO1xuICByZXR1cm4gdXNlTWVtbzUoKCkgPT4gKHsgYXZhaWxhYmxlUHVia2V5cyB9KSwgW2F2YWlsYWJsZVB1YmtleXNdKTtcbn07XG5cbi8vIHNyYy93YWxsZXQvaG9va3MvaW5kZXgudHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrOSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY3JlYXRlIGFzIGNyZWF0ZTUgfSBmcm9tIFwienVzdGFuZFwiO1xuaW1wb3J0IHsgTkRLTnV0emFwTW9uaXRvciB9IGZyb20gXCJAbm9zdHItZGV2LWtpdC9uZGstd2FsbGV0XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0OCwgdXNlTWVtbyBhcyB1c2VNZW1vNiwgdXNlU3RhdGUgYXMgdXNlU3RhdGU1IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlSW50ZXJuYWxXYWxsZXRTdG9yZSA9IGNyZWF0ZTUoKHNldCkgPT4gKHtcbiAgYWN0aXZlV2FsbGV0OiBudWxsLFxuICBiYWxhbmNlOiBudWxsLFxuICBzZXRBY3RpdmVXYWxsZXQ6ICh3YWxsZXQpID0+IHNldCh7IGFjdGl2ZVdhbGxldDogd2FsbGV0IH0pLFxuICBzZXRCYWxhbmNlOiAoYmFsYW5jZSkgPT4gc2V0KHsgYmFsYW5jZSB9KVxufSkpO1xudmFyIHVzZU5ES1dhbGxldCA9ICgpID0+IHtcbiAgY29uc3QgeyBuZGsgfSA9IHVzZU5ESygpO1xuICBjb25zdCBhY3RpdmVXYWxsZXQgPSB1c2VJbnRlcm5hbFdhbGxldFN0b3JlKChzKSA9PiBzLmFjdGl2ZVdhbGxldCk7XG4gIGNvbnN0IHN0b3JlU2V0QWN0aXZlV2FsbGV0ID0gdXNlSW50ZXJuYWxXYWxsZXRTdG9yZSgocykgPT4gcy5zZXRBY3RpdmVXYWxsZXQpO1xuICBjb25zdCBiYWxhbmNlID0gdXNlSW50ZXJuYWxXYWxsZXRTdG9yZSgocykgPT4gcy5iYWxhbmNlKTtcbiAgY29uc3Qgc2V0QmFsYW5jZSA9IHVzZUludGVybmFsV2FsbGV0U3RvcmUoKHMpID0+IHMuc2V0QmFsYW5jZSk7XG4gIGNvbnN0IHNldEFjdGl2ZVdhbGxldCA9IHVzZUNhbGxiYWNrOShcbiAgICAod2FsbGV0KSA9PiB7XG4gICAgICBpZiAoIW5kaykgcmV0dXJuO1xuICAgICAgbGV0IGRlYm91bmNlVGltZXI7XG4gICAgICBzdG9yZVNldEFjdGl2ZVdhbGxldCh3YWxsZXQpO1xuICAgICAgbmRrLndhbGxldCA9IHdhbGxldCA/PyB2b2lkIDA7XG4gICAgICBjb25zdCB1cGRhdGVCYWxhbmNlID0gKCkgPT4ge1xuICAgICAgICBpZiAoZGVib3VuY2VUaW1lcikgY2xlYXJUaW1lb3V0KGRlYm91bmNlVGltZXIpO1xuICAgICAgICBkZWJvdW5jZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgYmFsYW5jZU9iaiA9IHdhbGxldD8uYmFsYW5jZTtcbiAgICAgICAgICBjb25zdCBhbW91bnQgPSBiYWxhbmNlT2JqPy5hbW91bnQgPz8gbnVsbDtcbiAgICAgICAgICBzZXRCYWxhbmNlKGFtb3VudCk7XG4gICAgICAgIH0sIDUwKTtcbiAgICAgIH07XG4gICAgICBpZiAod2FsbGV0KSB7XG4gICAgICAgIHdhbGxldC5vbihcInJlYWR5XCIsIHVwZGF0ZUJhbGFuY2UpO1xuICAgICAgICB3YWxsZXQub24oXCJiYWxhbmNlX3VwZGF0ZWRcIiwgdXBkYXRlQmFsYW5jZSk7XG4gICAgICAgIHdhbGxldC51cGRhdGVCYWxhbmNlPy4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJhbGFuY2UobnVsbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbbmRrLCBzdG9yZVNldEFjdGl2ZVdhbGxldCwgc2V0QmFsYW5jZV1cbiAgKTtcbiAgcmV0dXJuIHsgYWN0aXZlV2FsbGV0LCBzZXRBY3RpdmVXYWxsZXQsIGJhbGFuY2UsIHNldEJhbGFuY2UgfTtcbn07XG52YXIgdXNlSW50ZXJuYWxOdXR6YXBNb25pdG9yU3RvcmUgPSBjcmVhdGU1KChzZXQpID0+ICh7XG4gIG51dHphcE1vbml0b3I6IG51bGwsXG4gIHNldE51dHphcE1vbml0b3I6IChtb25pdG9yKSA9PiBzZXQoeyBudXR6YXBNb25pdG9yOiBtb25pdG9yIH0pXG59KSk7XG52YXIgdXNlTkRLTnV0emFwTW9uaXRvciA9IChtaW50TGlzdCwgc3RhcnQgPSBmYWxzZSkgPT4ge1xuICBjb25zdCB7IG5kayB9ID0gdXNlTkRLKCk7XG4gIGNvbnN0IGN1cnJlbnRVc2VyID0gdXNlTkRLQ3VycmVudFVzZXIoKTtcbiAgY29uc3QgeyBhY3RpdmVXYWxsZXQgfSA9IHVzZU5ES1dhbGxldCgpO1xuICBjb25zdCBudXR6YXBNb25pdG9yID0gdXNlSW50ZXJuYWxOdXR6YXBNb25pdG9yU3RvcmUoKHMpID0+IHMubnV0emFwTW9uaXRvcik7XG4gIGNvbnN0IHNldE51dHphcE1vbml0b3IgPSB1c2VJbnRlcm5hbE51dHphcE1vbml0b3JTdG9yZSgocykgPT4gcy5zZXROdXR6YXBNb25pdG9yKTtcbiAgY29uc3QgW21vbml0b3JTdGFydGVkLCBzZXRNb25pdG9yU3RhcnRlZF0gPSB1c2VTdGF0ZTUoZmFsc2UpO1xuICBjb25zdCBtb25pdG9yU3RvcmUgPSB1c2VNZW1vNigoKSA9PiB7XG4gICAgaWYgKG5kaz8uY2FjaGVBZGFwdGVyPy5nZXRBbGxOdXR6YXBTdGF0ZXMgJiYgbmRrPy5jYWNoZUFkYXB0ZXI/LnNldE51dHphcFN0YXRlKSB7XG4gICAgICBjb25zdCBib3VuZEdldEFsbCA9IG5kay5jYWNoZUFkYXB0ZXIuZ2V0QWxsTnV0emFwU3RhdGVzLmJpbmQobmRrLmNhY2hlQWRhcHRlcik7XG4gICAgICBjb25zdCBib3VuZFNldFN0YXRlID0gbmRrLmNhY2hlQWRhcHRlci5zZXROdXR6YXBTdGF0ZS5iaW5kKG5kay5jYWNoZUFkYXB0ZXIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0QWxsTnV0emFwczogYm91bmRHZXRBbGwsXG4gICAgICAgIHNldE51dHphcFN0YXRlOiBib3VuZFNldFN0YXRlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9LCBbbmRrPy5jYWNoZUFkYXB0ZXJdKTtcbiAgdXNlRWZmZWN0OCgoKSA9PiB7XG4gICAgaWYgKCFuZGsgfHwgIWN1cnJlbnRVc2VyPy5wdWJrZXkgfHwgIWFjdGl2ZVdhbGxldCkge1xuICAgICAgaWYgKG51dHphcE1vbml0b3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJTdG9wcGluZyBOREtOdXR6YXBNb25pdG9yIGR1ZSB0byBtaXNzaW5nIGRlcGVuZGVuY2llc1wiKTtcbiAgICAgICAgbnV0emFwTW9uaXRvci5zdG9wKCk7XG4gICAgICAgIHNldE51dHphcE1vbml0b3IobnVsbCk7XG4gICAgICAgIHNldE1vbml0b3JTdGFydGVkKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFudXR6YXBNb25pdG9yICYmIHN0YXJ0KSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkluaXRpYWxpemluZyBOREtOdXR6YXBNb25pdG9yXCIpO1xuICAgICAgY29uc3QgbW9uaXRvciA9IG5ldyBOREtOdXR6YXBNb25pdG9yKG5kaywgY3VycmVudFVzZXIsIHtcbiAgICAgICAgbWludExpc3QsXG4gICAgICAgIHN0b3JlOiBtb25pdG9yU3RvcmVcbiAgICAgIH0pO1xuICAgICAgbW9uaXRvci53YWxsZXQgPSBhY3RpdmVXYWxsZXQ7XG4gICAgICBzZXROdXR6YXBNb25pdG9yKG1vbml0b3IpO1xuICAgIH0gZWxzZSBpZiAobnV0emFwTW9uaXRvcikge1xuICAgICAgaWYgKG51dHphcE1vbml0b3Iud2FsbGV0Py53YWxsZXRJZCAhPT0gYWN0aXZlV2FsbGV0LndhbGxldElkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVXBkYXRpbmcgd2FsbGV0IGluIE5ES051dHphcE1vbml0b3JcIik7XG4gICAgICAgIG51dHphcE1vbml0b3Iud2FsbGV0ID0gYWN0aXZlV2FsbGV0O1xuICAgICAgfVxuICAgICAgaWYgKG51dHphcE1vbml0b3IubWludExpc3QgIT09IG1pbnRMaXN0KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVXBkYXRpbmcgbWludExpc3QgaW4gTkRLTnV0emFwTW9uaXRvclwiKTtcbiAgICAgICAgbnV0emFwTW9uaXRvci5taW50TGlzdCA9IG1pbnRMaXN0O1xuICAgICAgfVxuICAgIH1cbiAgfSwgW25kaywgY3VycmVudFVzZXIsIGFjdGl2ZVdhbGxldCwgbWludExpc3QsIG1vbml0b3JTdG9yZSwgbnV0emFwTW9uaXRvciwgc2V0TnV0emFwTW9uaXRvciwgc3RhcnRdKTtcbiAgdXNlRWZmZWN0OCgoKSA9PiB7XG4gICAgaWYgKHN0YXJ0ICYmIG51dHphcE1vbml0b3IgJiYgIW1vbml0b3JTdGFydGVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlN0YXJ0aW5nIE5ES051dHphcE1vbml0b3JcIik7XG4gICAgICBudXR6YXBNb25pdG9yLnN0YXJ0KHtcbiAgICAgICAgZmlsdGVyOiB7IGxpbWl0OiAxMDAgfSxcbiAgICAgICAgb3B0czogeyBza2lwVmVyaWZpY2F0aW9uOiB0cnVlIH1cbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICBzZXRNb25pdG9yU3RhcnRlZCh0cnVlKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJOREtOdXR6YXBNb25pdG9yIHN0YXJ0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHN0YXJ0IE5ES051dHphcE1vbml0b3JcIiwgZXJyKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIXN0YXJ0ICYmIG51dHphcE1vbml0b3IgJiYgbW9uaXRvclN0YXJ0ZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiU3RvcHBpbmcgTkRLTnV0emFwTW9uaXRvclwiKTtcbiAgICAgIG51dHphcE1vbml0b3Iuc3RvcCgpO1xuICAgICAgc2V0TW9uaXRvclN0YXJ0ZWQoZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKG51dHphcE1vbml0b3IgJiYgbW9uaXRvclN0YXJ0ZWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJTdG9wcGluZyBOREtOdXR6YXBNb25pdG9yIG9uIGNsZWFudXBcIik7XG4gICAgICAgIG51dHphcE1vbml0b3Iuc3RvcCgpO1xuICAgICAgICBzZXRNb25pdG9yU3RhcnRlZChmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3N0YXJ0LCBudXR6YXBNb25pdG9yLCBtb25pdG9yU3RhcnRlZF0pO1xuICByZXR1cm4geyBudXR6YXBNb25pdG9yIH07XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJAbm9zdHItZGV2LWtpdC9uZGtcIjtcbmltcG9ydCBOREsgZnJvbSBcIkBub3N0ci1kZXYta2l0L25ka1wiO1xudmFyIGluZGV4X2RlZmF1bHQgPSBOREs7XG5leHBvcnQge1xuICBFTVBUWV9NVVRFX0NSSVRFUklBLFxuICBOREtTZXNzaW9uTG9jYWxTdG9yYWdlLFxuICBhZGRPclVwZGF0ZVN0b3JlZFNlc3Npb24sXG4gIGNsZWFyQWN0aXZlUHVia2V5LFxuICBjcmVhdGVTdWJzY3JpYmVTdG9yZSxcbiAgaW5kZXhfZGVmYXVsdCBhcyBkZWZhdWx0LFxuICBnZXRBY3RpdmVQdWJrZXksXG4gIGxvYWRTZXNzaW9uc0Zyb21TdG9yYWdlLFxuICByZW1vdmVTdG9yZWRTZXNzaW9uLFxuICBzYXZlU2Vzc2lvbnNUb1N0b3JhZ2UsXG4gIHN0b3JlQWN0aXZlUHVia2V5LFxuICB1c2VBY3RpdmVNdXRlQ3JpdGVyaWEsXG4gIHVzZUF2YWlsYWJsZVNlc3Npb25zLFxuICB1c2VDdXJyZW50VXNlclByb2ZpbGUsXG4gIHVzZUV2ZW50LFxuICB1c2VGb2xsb3dzLFxuICB1c2VJc0l0ZW1NdXRlZCxcbiAgdXNlTXV0ZUNyaXRlcmlhLFxuICB1c2VNdXRlRmlsdGVyLFxuICB1c2VNdXRlSXRlbSxcbiAgdXNlTkRLLFxuICB1c2VOREtDdXJyZW50UHVia2V5LFxuICB1c2VOREtDdXJyZW50VXNlcixcbiAgdXNlTkRLSW5pdCxcbiAgdXNlTkRLTnV0emFwTW9uaXRvcixcbiAgdXNlTkRLU2Vzc2lvbkV2ZW50LFxuICB1c2VOREtTZXNzaW9uTG9naW4sXG4gIHVzZU5ES1Nlc3Npb25Mb2dvdXQsXG4gIHVzZU5ES1Nlc3Npb25Nb25pdG9yLFxuICB1c2VOREtTZXNzaW9uU2Vzc2lvbnMsXG4gIHVzZU5ES1Nlc3Npb25TaWduZXJzLFxuICB1c2VOREtTZXNzaW9uU3RhcnQsXG4gIHVzZU5ES1Nlc3Npb25TdG9wLFxuICB1c2VOREtTZXNzaW9uU3dpdGNoLFxuICB1c2VOREtTdG9yZSxcbiAgdXNlTkRLVW5wdWJsaXNoZWRFdmVudHMsXG4gIHVzZU5ES1dhbGxldCxcbiAgdXNlT2JzZXJ2ZXIsXG4gIHVzZVByb2ZpbGUsXG4gIHVzZVByb2ZpbGVWYWx1ZSxcbiAgdXNlUHVibGlzaE11dGVMaXN0LFxuICB1c2VTZXRQcm9maWxlLFxuICB1c2VTdWJzY3JpYmUsXG4gIHVzZVVubXV0ZUl0ZW0sXG4gIHVzZVVzZXJQcm9maWxlc1N0b3JlXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-hooks/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-hooks/node_modules/@nostr-dev-kit/ndk/dist/index.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-hooks/node_modules/@nostr-dev-kit/ndk/dist/index.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BECH32_REGEX: () => (/* binding */ BECH32_REGEX),\n/* harmony export */   NDKAppHandlerEvent: () => (/* binding */ NDKAppHandlerEvent),\n/* harmony export */   NDKAppSettings: () => (/* binding */ NDKAppSettings),\n/* harmony export */   NDKArticle: () => (/* binding */ NDKArticle),\n/* harmony export */   NDKCashuMintList: () => (/* binding */ NDKCashuMintList),\n/* harmony export */   NDKCashuToken: () => (/* binding */ NDKCashuToken),\n/* harmony export */   NDKCashuWalletTx: () => (/* binding */ NDKCashuWalletTx),\n/* harmony export */   NDKClassified: () => (/* binding */ NDKClassified),\n/* harmony export */   NDKDVMJobFeedback: () => (/* binding */ NDKDVMJobFeedback),\n/* harmony export */   NDKDVMJobResult: () => (/* binding */ NDKDVMJobResult),\n/* harmony export */   NDKDVMRequest: () => (/* binding */ NDKDVMRequest),\n/* harmony export */   NDKDraft: () => (/* binding */ NDKDraft),\n/* harmony export */   NDKDvmJobFeedbackStatus: () => (/* binding */ NDKDvmJobFeedbackStatus),\n/* harmony export */   NDKEvent: () => (/* binding */ NDKEvent),\n/* harmony export */   NDKHighlight: () => (/* binding */ NDKHighlight),\n/* harmony export */   NDKImage: () => (/* binding */ NDKImage),\n/* harmony export */   NDKKind: () => (/* binding */ NDKKind),\n/* harmony export */   NDKList: () => (/* binding */ NDKList),\n/* harmony export */   NDKListKinds: () => (/* binding */ NDKListKinds),\n/* harmony export */   NDKNip07Signer: () => (/* binding */ NDKNip07Signer),\n/* harmony export */   NDKNip46Backend: () => (/* binding */ NDKNip46Backend),\n/* harmony export */   NDKNip46Signer: () => (/* binding */ NDKNip46Signer),\n/* harmony export */   NDKNostrRpc: () => (/* binding */ NDKNostrRpc),\n/* harmony export */   NDKNutzap: () => (/* binding */ NDKNutzap),\n/* harmony export */   NDKPool: () => (/* binding */ NDKPool),\n/* harmony export */   NDKPrivateKeySigner: () => (/* binding */ NDKPrivateKeySigner),\n/* harmony export */   NDKPublishError: () => (/* binding */ NDKPublishError),\n/* harmony export */   NDKRelay: () => (/* binding */ NDKRelay),\n/* harmony export */   NDKRelayAuthPolicies: () => (/* binding */ NDKRelayAuthPolicies),\n/* harmony export */   NDKRelayList: () => (/* binding */ NDKRelayList),\n/* harmony export */   NDKRelaySet: () => (/* binding */ NDKRelaySet),\n/* harmony export */   NDKRelayStatus: () => (/* binding */ NDKRelayStatus),\n/* harmony export */   NDKRepost: () => (/* binding */ NDKRepost),\n/* harmony export */   NDKSimpleGroup: () => (/* binding */ NDKSimpleGroup),\n/* harmony export */   NDKSimpleGroupMemberList: () => (/* binding */ NDKSimpleGroupMemberList),\n/* harmony export */   NDKSimpleGroupMetadata: () => (/* binding */ NDKSimpleGroupMetadata),\n/* harmony export */   NDKStory: () => (/* binding */ NDKStory),\n/* harmony export */   NDKStorySticker: () => (/* binding */ NDKStorySticker),\n/* harmony export */   NDKStoryStickerType: () => (/* binding */ NDKStoryStickerType),\n/* harmony export */   NDKSubscription: () => (/* binding */ NDKSubscription),\n/* harmony export */   NDKSubscriptionCacheUsage: () => (/* binding */ NDKSubscriptionCacheUsage),\n/* harmony export */   NDKSubscriptionReceipt: () => (/* binding */ NDKSubscriptionReceipt),\n/* harmony export */   NDKSubscriptionStart: () => (/* binding */ NDKSubscriptionStart),\n/* harmony export */   NDKSubscriptionTier: () => (/* binding */ NDKSubscriptionTier),\n/* harmony export */   NDKTranscriptionDVM: () => (/* binding */ NDKTranscriptionDVM),\n/* harmony export */   NDKUser: () => (/* binding */ NDKUser),\n/* harmony export */   NDKVideo: () => (/* binding */ NDKVideo),\n/* harmony export */   NDKWiki: () => (/* binding */ NDKWiki),\n/* harmony export */   NDKWikiMergeRequest: () => (/* binding */ NDKWikiMergeRequest),\n/* harmony export */   NDKZapper: () => (/* binding */ NDKZapper),\n/* harmony export */   NIP33_A_REGEX: () => (/* binding */ NIP33_A_REGEX),\n/* harmony export */   NdkNutzapStatus: () => (/* binding */ NdkNutzapStatus),\n/* harmony export */   calculateRelaySetFromEvent: () => (/* binding */ calculateRelaySetFromEvent),\n/* harmony export */   calculateTermDurationInSeconds: () => (/* binding */ calculateTermDurationInSeconds),\n/* harmony export */   cashuPubkeyToNostrPubkey: () => (/* binding */ cashuPubkeyToNostrPubkey),\n/* harmony export */   compareFilter: () => (/* binding */ compareFilter),\n/* harmony export */   \"default\": () => (/* binding */ NDK),\n/* harmony export */   defaultOpts: () => (/* binding */ defaultOpts),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   dvmSchedule: () => (/* binding */ dvmSchedule),\n/* harmony export */   eventHasETagMarkers: () => (/* binding */ eventHasETagMarkers),\n/* harmony export */   eventIsPartOfThread: () => (/* binding */ eventIsPartOfThread),\n/* harmony export */   eventIsReply: () => (/* binding */ eventIsReply),\n/* harmony export */   eventReplies: () => (/* binding */ eventReplies),\n/* harmony export */   eventThreadIds: () => (/* binding */ eventThreadIds),\n/* harmony export */   eventThreads: () => (/* binding */ eventThreads),\n/* harmony export */   eventsBySameAuthor: () => (/* binding */ eventsBySameAuthor),\n/* harmony export */   filterAndRelaySetFromBech32: () => (/* binding */ filterAndRelaySetFromBech32),\n/* harmony export */   filterFingerprint: () => (/* binding */ filterFingerprint),\n/* harmony export */   filterForEventsTaggingId: () => (/* binding */ filterForEventsTaggingId),\n/* harmony export */   filterFromId: () => (/* binding */ filterFromId),\n/* harmony export */   generateContentTags: () => (/* binding */ generateContentTags),\n/* harmony export */   generateHashtags: () => (/* binding */ generateHashtags),\n/* harmony export */   generateSubId: () => (/* binding */ generateSubId),\n/* harmony export */   generateZapRequest: () => (/* binding */ generateZapRequest),\n/* harmony export */   getEventReplyId: () => (/* binding */ getEventReplyId),\n/* harmony export */   getNip57ZapSpecFromLud: () => (/* binding */ getNip57ZapSpecFromLud),\n/* harmony export */   getRelayListForUser: () => (/* binding */ getRelayListForUser),\n/* harmony export */   getRelayListForUsers: () => (/* binding */ getRelayListForUsers),\n/* harmony export */   getReplyTag: () => (/* binding */ getReplyTag),\n/* harmony export */   getRootEventId: () => (/* binding */ getRootEventId),\n/* harmony export */   getRootTag: () => (/* binding */ getRootTag),\n/* harmony export */   giftUnwrap: () => (/* binding */ giftUnwrap),\n/* harmony export */   giftWrap: () => (/* binding */ giftWrap),\n/* harmony export */   imetaTagToTag: () => (/* binding */ imetaTagToTag),\n/* harmony export */   isEventOriginalPost: () => (/* binding */ isEventOriginalPost),\n/* harmony export */   isNip33AValue: () => (/* binding */ isNip33AValue),\n/* harmony export */   mapImetaTag: () => (/* binding */ mapImetaTag),\n/* harmony export */   matchFilter: () => (/* binding */ matchFilter),\n/* harmony export */   mergeFilters: () => (/* binding */ mergeFilters),\n/* harmony export */   mergeTags: () => (/* binding */ mergeTags),\n/* harmony export */   ndkSignerFromPayload: () => (/* binding */ ndkSignerFromPayload),\n/* harmony export */   newAmount: () => (/* binding */ newAmount),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   normalizeRelayUrl: () => (/* binding */ normalizeRelayUrl),\n/* harmony export */   normalizeUrl: () => (/* binding */ normalizeUrl),\n/* harmony export */   parseTagToSubscriptionAmount: () => (/* binding */ parseTagToSubscriptionAmount),\n/* harmony export */   pinEvent: () => (/* binding */ pinEvent),\n/* harmony export */   possibleIntervalFrequencies: () => (/* binding */ possibleIntervalFrequencies),\n/* harmony export */   profileFromEvent: () => (/* binding */ profileFromEvent),\n/* harmony export */   proofP2pk: () => (/* binding */ proofP2pk),\n/* harmony export */   proofP2pkNostr: () => (/* binding */ proofP2pkNostr),\n/* harmony export */   proofsTotalBalance: () => (/* binding */ proofsTotalBalance),\n/* harmony export */   queryFullyFilled: () => (/* binding */ queryFullyFilled),\n/* harmony export */   relayListFromKind3: () => (/* binding */ relayListFromKind3),\n/* harmony export */   relaysFromBech32: () => (/* binding */ relaysFromBech32),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializeProfile: () => (/* binding */ serializeProfile),\n/* harmony export */   signerRegistry: () => (/* binding */ signerRegistry),\n/* harmony export */   strToDimension: () => (/* binding */ strToDimension),\n/* harmony export */   strToPosition: () => (/* binding */ strToPosition),\n/* harmony export */   tryNormalizeRelayUrl: () => (/* binding */ tryNormalizeRelayUrl),\n/* harmony export */   uniqueTag: () => (/* binding */ uniqueTag),\n/* harmony export */   wrapEvent: () => (/* binding */ wrapEvent),\n/* harmony export */   zapInvoiceFromEvent: () => (/* binding */ zapInvoiceFromEvent)\n/* harmony export */ });\n/* harmony import */ var tseep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tseep */ \"(ssr)/./node_modules/tseep/lib/index.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nostr-tools */ \"(ssr)/./node_modules/.pnpm/nostr-tools@2.14.2_typescript@5.8.3/node_modules/nostr-tools/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! typescript-lru-cache */ \"(ssr)/./node_modules/typescript-lru-cache/dist/index.js\");\n/* harmony import */ var light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! light-bolt11-decoder */ \"(ssr)/./node_modules/light-bolt11-decoder/bolt11.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n// src/types.ts\nvar NdkNutzapStatus = /* @__PURE__ */ ((NdkNutzapStatus2) => {\n  NdkNutzapStatus2[\"INITIAL\"] = \"initial\";\n  NdkNutzapStatus2[\"PROCESSING\"] = \"processing\";\n  NdkNutzapStatus2[\"REDEEMED\"] = \"redeemed\";\n  NdkNutzapStatus2[\"SPENT\"] = \"spent\";\n  NdkNutzapStatus2[\"MISSING_PRIVKEY\"] = \"missing_privkey\";\n  NdkNutzapStatus2[\"TEMPORARY_ERROR\"] = \"temporary_error\";\n  NdkNutzapStatus2[\"PERMANENT_ERROR\"] = \"permanent_error\";\n  NdkNutzapStatus2[\"INVALID_NUTZAP\"] = \"invalid_nutzap\";\n  return NdkNutzapStatus2;\n})(NdkNutzapStatus || {});\n\n// src/events/kinds/index.ts\nvar NDKKind = /* @__PURE__ */ ((NDKKind2) => {\n  NDKKind2[NDKKind2[\"Metadata\"] = 0] = \"Metadata\";\n  NDKKind2[NDKKind2[\"Text\"] = 1] = \"Text\";\n  NDKKind2[NDKKind2[\"RecommendRelay\"] = 2] = \"RecommendRelay\";\n  NDKKind2[NDKKind2[\"Contacts\"] = 3] = \"Contacts\";\n  NDKKind2[NDKKind2[\"EncryptedDirectMessage\"] = 4] = \"EncryptedDirectMessage\";\n  NDKKind2[NDKKind2[\"EventDeletion\"] = 5] = \"EventDeletion\";\n  NDKKind2[NDKKind2[\"Repost\"] = 6] = \"Repost\";\n  NDKKind2[NDKKind2[\"Reaction\"] = 7] = \"Reaction\";\n  NDKKind2[NDKKind2[\"BadgeAward\"] = 8] = \"BadgeAward\";\n  NDKKind2[NDKKind2[\"GroupChat\"] = 9] = \"GroupChat\";\n  NDKKind2[NDKKind2[\"GroupNote\"] = 11] = \"GroupNote\";\n  NDKKind2[NDKKind2[\"GroupReply\"] = 12] = \"GroupReply\";\n  NDKKind2[NDKKind2[\"GiftWrapSeal\"] = 13] = \"GiftWrapSeal\";\n  NDKKind2[NDKKind2[\"PrivateDirectMessage\"] = 14] = \"PrivateDirectMessage\";\n  NDKKind2[NDKKind2[\"Image\"] = 20] = \"Image\";\n  NDKKind2[NDKKind2[\"Video\"] = 21] = \"Video\";\n  NDKKind2[NDKKind2[\"ShortVideo\"] = 22] = \"ShortVideo\";\n  NDKKind2[NDKKind2[\"Story\"] = 23] = \"Story\";\n  NDKKind2[NDKKind2[\"Vanish\"] = 62] = \"Vanish\";\n  NDKKind2[NDKKind2[\"CashuWalletBackup\"] = 375] = \"CashuWalletBackup\";\n  NDKKind2[NDKKind2[\"GiftWrap\"] = 1059] = \"GiftWrap\";\n  NDKKind2[NDKKind2[\"GenericRepost\"] = 16] = \"GenericRepost\";\n  NDKKind2[NDKKind2[\"ChannelCreation\"] = 40] = \"ChannelCreation\";\n  NDKKind2[NDKKind2[\"ChannelMetadata\"] = 41] = \"ChannelMetadata\";\n  NDKKind2[NDKKind2[\"ChannelMessage\"] = 42] = \"ChannelMessage\";\n  NDKKind2[NDKKind2[\"ChannelHideMessage\"] = 43] = \"ChannelHideMessage\";\n  NDKKind2[NDKKind2[\"ChannelMuteUser\"] = 44] = \"ChannelMuteUser\";\n  NDKKind2[NDKKind2[\"WikiMergeRequest\"] = 818] = \"WikiMergeRequest\";\n  NDKKind2[NDKKind2[\"GenericReply\"] = 1111] = \"GenericReply\";\n  NDKKind2[NDKKind2[\"Media\"] = 1063] = \"Media\";\n  NDKKind2[NDKKind2[\"Report\"] = 1984] = \"Report\";\n  NDKKind2[NDKKind2[\"Label\"] = 1985] = \"Label\";\n  NDKKind2[NDKKind2[\"DVMReqTextExtraction\"] = 5e3] = \"DVMReqTextExtraction\";\n  NDKKind2[NDKKind2[\"DVMReqTextSummarization\"] = 5001] = \"DVMReqTextSummarization\";\n  NDKKind2[NDKKind2[\"DVMReqTextTranslation\"] = 5002] = \"DVMReqTextTranslation\";\n  NDKKind2[NDKKind2[\"DVMReqTextGeneration\"] = 5050] = \"DVMReqTextGeneration\";\n  NDKKind2[NDKKind2[\"DVMReqImageGeneration\"] = 5100] = \"DVMReqImageGeneration\";\n  NDKKind2[NDKKind2[\"DVMReqTextToSpeech\"] = 5250] = \"DVMReqTextToSpeech\";\n  NDKKind2[NDKKind2[\"DVMReqDiscoveryNostrContent\"] = 5300] = \"DVMReqDiscoveryNostrContent\";\n  NDKKind2[NDKKind2[\"DVMReqDiscoveryNostrPeople\"] = 5301] = \"DVMReqDiscoveryNostrPeople\";\n  NDKKind2[NDKKind2[\"DVMReqTimestamping\"] = 5900] = \"DVMReqTimestamping\";\n  NDKKind2[NDKKind2[\"DVMEventSchedule\"] = 5905] = \"DVMEventSchedule\";\n  NDKKind2[NDKKind2[\"DVMJobFeedback\"] = 7e3] = \"DVMJobFeedback\";\n  NDKKind2[NDKKind2[\"Subscribe\"] = 7001] = \"Subscribe\";\n  NDKKind2[NDKKind2[\"Unsubscribe\"] = 7002] = \"Unsubscribe\";\n  NDKKind2[NDKKind2[\"SubscriptionReceipt\"] = 7003] = \"SubscriptionReceipt\";\n  NDKKind2[NDKKind2[\"CashuReserve\"] = 7373] = \"CashuReserve\";\n  NDKKind2[NDKKind2[\"CashuQuote\"] = 7374] = \"CashuQuote\";\n  NDKKind2[NDKKind2[\"CashuToken\"] = 7375] = \"CashuToken\";\n  NDKKind2[NDKKind2[\"CashuWalletTx\"] = 7376] = \"CashuWalletTx\";\n  NDKKind2[NDKKind2[\"GroupAdminAddUser\"] = 9e3] = \"GroupAdminAddUser\";\n  NDKKind2[NDKKind2[\"GroupAdminRemoveUser\"] = 9001] = \"GroupAdminRemoveUser\";\n  NDKKind2[NDKKind2[\"GroupAdminEditMetadata\"] = 9002] = \"GroupAdminEditMetadata\";\n  NDKKind2[NDKKind2[\"GroupAdminEditStatus\"] = 9006] = \"GroupAdminEditStatus\";\n  NDKKind2[NDKKind2[\"GroupAdminCreateGroup\"] = 9007] = \"GroupAdminCreateGroup\";\n  NDKKind2[NDKKind2[\"GroupAdminRequestJoin\"] = 9021] = \"GroupAdminRequestJoin\";\n  NDKKind2[NDKKind2[\"MuteList\"] = 1e4] = \"MuteList\";\n  NDKKind2[NDKKind2[\"PinList\"] = 10001] = \"PinList\";\n  NDKKind2[NDKKind2[\"RelayList\"] = 10002] = \"RelayList\";\n  NDKKind2[NDKKind2[\"BookmarkList\"] = 10003] = \"BookmarkList\";\n  NDKKind2[NDKKind2[\"CommunityList\"] = 10004] = \"CommunityList\";\n  NDKKind2[NDKKind2[\"PublicChatList\"] = 10005] = \"PublicChatList\";\n  NDKKind2[NDKKind2[\"BlockRelayList\"] = 10006] = \"BlockRelayList\";\n  NDKKind2[NDKKind2[\"SearchRelayList\"] = 10007] = \"SearchRelayList\";\n  NDKKind2[NDKKind2[\"SimpleGroupList\"] = 10009] = \"SimpleGroupList\";\n  NDKKind2[NDKKind2[\"InterestList\"] = 10015] = \"InterestList\";\n  NDKKind2[NDKKind2[\"CashuMintList\"] = 10019] = \"CashuMintList\";\n  NDKKind2[NDKKind2[\"EmojiList\"] = 10030] = \"EmojiList\";\n  NDKKind2[NDKKind2[\"DirectMessageReceiveRelayList\"] = 10050] = \"DirectMessageReceiveRelayList\";\n  NDKKind2[NDKKind2[\"BlossomList\"] = 10063] = \"BlossomList\";\n  NDKKind2[NDKKind2[\"NostrWaletConnectInfo\"] = 13194] = \"NostrWaletConnectInfo\";\n  NDKKind2[NDKKind2[\"TierList\"] = 17e3] = \"TierList\";\n  NDKKind2[NDKKind2[\"CashuWallet\"] = 17375] = \"CashuWallet\";\n  NDKKind2[NDKKind2[\"FollowSet\"] = 3e4] = \"FollowSet\";\n  NDKKind2[NDKKind2[\"CategorizedPeopleList\"] = 3e4 /* FollowSet */] = \"CategorizedPeopleList\";\n  NDKKind2[NDKKind2[\"CategorizedBookmarkList\"] = 30001] = \"CategorizedBookmarkList\";\n  NDKKind2[NDKKind2[\"RelaySet\"] = 30002] = \"RelaySet\";\n  NDKKind2[NDKKind2[\"CategorizedRelayList\"] = 30002 /* RelaySet */] = \"CategorizedRelayList\";\n  NDKKind2[NDKKind2[\"BookmarkSet\"] = 30003] = \"BookmarkSet\";\n  NDKKind2[NDKKind2[\"CurationSet\"] = 30004] = \"CurationSet\";\n  NDKKind2[NDKKind2[\"ArticleCurationSet\"] = 30004] = \"ArticleCurationSet\";\n  NDKKind2[NDKKind2[\"VideoCurationSet\"] = 30005] = \"VideoCurationSet\";\n  NDKKind2[NDKKind2[\"ImageCurationSet\"] = 30006] = \"ImageCurationSet\";\n  NDKKind2[NDKKind2[\"InterestSet\"] = 30015] = \"InterestSet\";\n  NDKKind2[NDKKind2[\"InterestsList\"] = 30015 /* InterestSet */] = \"InterestsList\";\n  NDKKind2[NDKKind2[\"EmojiSet\"] = 30030] = \"EmojiSet\";\n  NDKKind2[NDKKind2[\"ModularArticle\"] = 30040] = \"ModularArticle\";\n  NDKKind2[NDKKind2[\"ModularArticleItem\"] = 30041] = \"ModularArticleItem\";\n  NDKKind2[NDKKind2[\"Wiki\"] = 30818] = \"Wiki\";\n  NDKKind2[NDKKind2[\"Draft\"] = 31234] = \"Draft\";\n  NDKKind2[NDKKind2[\"SubscriptionTier\"] = 37001] = \"SubscriptionTier\";\n  NDKKind2[NDKKind2[\"EcashMintRecommendation\"] = 38e3] = \"EcashMintRecommendation\";\n  NDKKind2[NDKKind2[\"HighlightSet\"] = 39802] = \"HighlightSet\";\n  NDKKind2[NDKKind2[\"CategorizedHighlightList\"] = 39802 /* HighlightSet */] = \"CategorizedHighlightList\";\n  NDKKind2[NDKKind2[\"Nutzap\"] = 9321] = \"Nutzap\";\n  NDKKind2[NDKKind2[\"ZapRequest\"] = 9734] = \"ZapRequest\";\n  NDKKind2[NDKKind2[\"Zap\"] = 9735] = \"Zap\";\n  NDKKind2[NDKKind2[\"Highlight\"] = 9802] = \"Highlight\";\n  NDKKind2[NDKKind2[\"ClientAuth\"] = 22242] = \"ClientAuth\";\n  NDKKind2[NDKKind2[\"NostrWalletConnectReq\"] = 23194] = \"NostrWalletConnectReq\";\n  NDKKind2[NDKKind2[\"NostrWalletConnectRes\"] = 23195] = \"NostrWalletConnectRes\";\n  NDKKind2[NDKKind2[\"NostrConnect\"] = 24133] = \"NostrConnect\";\n  NDKKind2[NDKKind2[\"BlossomUpload\"] = 24242] = \"BlossomUpload\";\n  NDKKind2[NDKKind2[\"HttpAuth\"] = 27235] = \"HttpAuth\";\n  NDKKind2[NDKKind2[\"ProfileBadge\"] = 30008] = \"ProfileBadge\";\n  NDKKind2[NDKKind2[\"BadgeDefinition\"] = 30009] = \"BadgeDefinition\";\n  NDKKind2[NDKKind2[\"MarketStall\"] = 30017] = \"MarketStall\";\n  NDKKind2[NDKKind2[\"MarketProduct\"] = 30018] = \"MarketProduct\";\n  NDKKind2[NDKKind2[\"Article\"] = 30023] = \"Article\";\n  NDKKind2[NDKKind2[\"AppSpecificData\"] = 30078] = \"AppSpecificData\";\n  NDKKind2[NDKKind2[\"Classified\"] = 30402] = \"Classified\";\n  NDKKind2[NDKKind2[\"HorizontalVideo\"] = 34235] = \"HorizontalVideo\";\n  NDKKind2[NDKKind2[\"VerticalVideo\"] = 34236] = \"VerticalVideo\";\n  NDKKind2[NDKKind2[\"LegacyCashuWallet\"] = 37375] = \"LegacyCashuWallet\";\n  NDKKind2[NDKKind2[\"GroupMetadata\"] = 39e3] = \"GroupMetadata\";\n  NDKKind2[NDKKind2[\"GroupAdmins\"] = 39001] = \"GroupAdmins\";\n  NDKKind2[NDKKind2[\"GroupMembers\"] = 39002] = \"GroupMembers\";\n  NDKKind2[NDKKind2[\"AppRecommendation\"] = 31989] = \"AppRecommendation\";\n  NDKKind2[NDKKind2[\"AppHandler\"] = 31990] = \"AppHandler\";\n  return NDKKind2;\n})(NDKKind || {});\nvar NDKListKinds = [\n  1e4 /* MuteList */,\n  10001 /* PinList */,\n  10002 /* RelayList */,\n  10003 /* BookmarkList */,\n  10004 /* CommunityList */,\n  10005 /* PublicChatList */,\n  10006 /* BlockRelayList */,\n  10007 /* SearchRelayList */,\n  10015 /* InterestList */,\n  10030 /* EmojiList */,\n  10050 /* DirectMessageReceiveRelayList */,\n  3e4 /* FollowSet */,\n  30003 /* BookmarkSet */,\n  30001 /* CategorizedBookmarkList */,\n  // Backwards compatibility\n  30002 /* RelaySet */,\n  30004 /* ArticleCurationSet */,\n  30005 /* VideoCurationSet */,\n  30015 /* InterestSet */,\n  30030 /* EmojiSet */,\n  39802 /* HighlightSet */\n];\n\n// src/events/index.ts\n\n\n// src/relay/sets/calculate.ts\n\n\n// src/outbox/write.ts\nfunction getRelaysForSync(ndk, author, type = \"write\") {\n  if (!ndk.outboxTracker) return void 0;\n  const item = ndk.outboxTracker.data.get(author);\n  if (!item) return void 0;\n  if (type === \"write\") {\n    return item.writeRelays;\n  }\n  return item.readRelays;\n}\nasync function getWriteRelaysFor(ndk, author, type = \"write\") {\n  if (!ndk.outboxTracker) return void 0;\n  if (!ndk.outboxTracker.data.has(author)) {\n    await ndk.outboxTracker.trackUsers([author]);\n  }\n  return getRelaysForSync(ndk, author, type);\n}\n\n// src/outbox/relay-ranking.ts\nfunction getTopRelaysForAuthors(ndk, authors) {\n  const relaysWithCount = /* @__PURE__ */ new Map();\n  authors.forEach((author) => {\n    const writeRelays = getRelaysForSync(ndk, author);\n    if (writeRelays) {\n      writeRelays.forEach((relay) => {\n        const count = relaysWithCount.get(relay) || 0;\n        relaysWithCount.set(relay, count + 1);\n      });\n    }\n  });\n  const sortedRelays = Array.from(relaysWithCount.entries()).sort((a, b) => b[1] - a[1]);\n  return sortedRelays.map((entry) => entry[0]);\n}\n\n// src/outbox/index.ts\nfunction getAllRelaysForAllPubkeys(ndk, pubkeys, type = \"read\") {\n  const pubkeysToRelays = /* @__PURE__ */ new Map();\n  const authorsMissingRelays = /* @__PURE__ */ new Set();\n  pubkeys.forEach((pubkey) => {\n    const relays = getRelaysForSync(ndk, pubkey, type);\n    if (relays && relays.size > 0) {\n      relays.forEach((relay) => {\n        const pubkeysInRelay = pubkeysToRelays.get(relay) || /* @__PURE__ */ new Set();\n        pubkeysInRelay.add(pubkey);\n      });\n      pubkeysToRelays.set(pubkey, relays);\n    } else {\n      authorsMissingRelays.add(pubkey);\n    }\n  });\n  return { pubkeysToRelays, authorsMissingRelays };\n}\nfunction chooseRelayCombinationForPubkeys(ndk, pubkeys, type, { count, preferredRelays } = {}) {\n  count ??= 2;\n  preferredRelays ??= /* @__PURE__ */ new Set();\n  const pool = ndk.pool;\n  const connectedRelays = pool.connectedRelays();\n  connectedRelays.forEach((relay) => {\n    preferredRelays?.add(relay.url);\n  });\n  const relayToAuthorsMap = /* @__PURE__ */ new Map();\n  const { pubkeysToRelays, authorsMissingRelays } = getAllRelaysForAllPubkeys(ndk, pubkeys, type);\n  const sortedRelays = getTopRelaysForAuthors(ndk, pubkeys);\n  const addAuthorToRelay = (author, relay) => {\n    const authorsInRelay = relayToAuthorsMap.get(relay) || [];\n    authorsInRelay.push(author);\n    relayToAuthorsMap.set(relay, authorsInRelay);\n  };\n  for (const [author, authorRelays] of pubkeysToRelays.entries()) {\n    let missingRelayCount = count;\n    for (const relay of connectedRelays) {\n      if (authorRelays.has(relay.url)) {\n        addAuthorToRelay(author, relay.url);\n        missingRelayCount--;\n      }\n    }\n    for (const authorRelay of authorRelays) {\n      if (relayToAuthorsMap.has(authorRelay)) {\n        addAuthorToRelay(author, authorRelay);\n        missingRelayCount--;\n      }\n    }\n    if (missingRelayCount <= 0) continue;\n    for (const relay of sortedRelays) {\n      if (missingRelayCount <= 0) break;\n      if (authorRelays.has(relay)) {\n        addAuthorToRelay(author, relay);\n        missingRelayCount--;\n      }\n    }\n  }\n  for (const author of authorsMissingRelays) {\n    pool.permanentAndConnectedRelays().forEach((relay) => {\n      const authorsInRelay = relayToAuthorsMap.get(relay.url) || [];\n      authorsInRelay.push(author);\n      relayToAuthorsMap.set(relay.url, authorsInRelay);\n    });\n  }\n  return relayToAuthorsMap;\n}\n\n// src/outbox/read/with-authors.ts\nfunction getRelaysForFilterWithAuthors(ndk, authors, relayGoalPerAuthor = 2) {\n  return chooseRelayCombinationForPubkeys(ndk, authors, \"write\", { count: relayGoalPerAuthor });\n}\n\n// src/utils/normalize-url.ts\nfunction tryNormalizeRelayUrl(url) {\n  try {\n    return normalizeRelayUrl(url);\n  } catch {\n    return void 0;\n  }\n}\nfunction normalizeRelayUrl(url) {\n  let r = normalizeUrl(url, {\n    stripAuthentication: false,\n    stripWWW: false,\n    stripHash: true\n  });\n  if (!r.endsWith(\"/\")) {\n    r += \"/\";\n  }\n  return r;\n}\nfunction normalize(urls) {\n  const normalized = /* @__PURE__ */ new Set();\n  for (const url of urls) {\n    try {\n      normalized.add(normalizeRelayUrl(url));\n    } catch {\n    }\n  }\n  return Array.from(normalized);\n}\nvar DATA_URL_DEFAULT_MIME_TYPE = \"text/plain\";\nvar DATA_URL_DEFAULT_CHARSET = \"us-ascii\";\nvar testParameter = (name, filters) => filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);\nvar supportedProtocols = /* @__PURE__ */ new Set([\"https:\", \"http:\", \"file:\"]);\nvar hasCustomProtocol = (urlString) => {\n  try {\n    const { protocol } = new URL(urlString);\n    return protocol.endsWith(\":\") && !protocol.includes(\".\") && !supportedProtocols.has(protocol);\n  } catch {\n    return false;\n  }\n};\nvar normalizeDataURL = (urlString, { stripHash }) => {\n  const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);\n  if (!match) {\n    throw new Error(`Invalid URL: ${urlString}`);\n  }\n  const type = match.groups?.type ?? \"\";\n  const data = match.groups?.data ?? \"\";\n  let hash = match.groups?.hash ?? \"\";\n  const mediaType = type.split(\";\");\n  hash = stripHash ? \"\" : hash;\n  let isBase64 = false;\n  if (mediaType[mediaType.length - 1] === \"base64\") {\n    mediaType.pop();\n    isBase64 = true;\n  }\n  const mimeType = mediaType.shift()?.toLowerCase() ?? \"\";\n  const attributes = mediaType.map((attribute) => {\n    let [key, value = \"\"] = attribute.split(\"=\").map((string) => string.trim());\n    if (key === \"charset\") {\n      value = value.toLowerCase();\n      if (value === DATA_URL_DEFAULT_CHARSET) {\n        return \"\";\n      }\n    }\n    return `${key}${value ? `=${value}` : \"\"}`;\n  }).filter(Boolean);\n  const normalizedMediaType = [...attributes];\n  if (isBase64) {\n    normalizedMediaType.push(\"base64\");\n  }\n  if (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {\n    normalizedMediaType.unshift(mimeType);\n  }\n  return `data:${normalizedMediaType.join(\";\")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : \"\"}`;\n};\nfunction normalizeUrl(urlString, options = {}) {\n  options = {\n    defaultProtocol: \"http\",\n    normalizeProtocol: true,\n    forceHttp: false,\n    forceHttps: false,\n    stripAuthentication: true,\n    stripHash: false,\n    stripTextFragment: true,\n    stripWWW: true,\n    removeQueryParameters: [/^utm_\\w+/i],\n    removeTrailingSlash: true,\n    removeSingleSlash: true,\n    removeDirectoryIndex: false,\n    removeExplicitPort: false,\n    sortQueryParameters: true,\n    ...options\n  };\n  if (typeof options.defaultProtocol === \"string\" && !options.defaultProtocol.endsWith(\":\")) {\n    options.defaultProtocol = `${options.defaultProtocol}:`;\n  }\n  urlString = urlString.trim();\n  if (/^data:/i.test(urlString)) {\n    return normalizeDataURL(urlString, options);\n  }\n  if (hasCustomProtocol(urlString)) {\n    return urlString;\n  }\n  const hasRelativeProtocol = urlString.startsWith(\"//\");\n  const isRelativeUrl = !hasRelativeProtocol && /^\\.*\\//.test(urlString);\n  if (!isRelativeUrl) {\n    urlString = urlString.replace(/^(?!(?:\\w+:)?\\/\\/)|^\\/\\//, options.defaultProtocol);\n  }\n  const urlObject = new URL(urlString);\n  urlObject.hostname = urlObject.hostname.toLowerCase();\n  if (options.forceHttp && options.forceHttps) {\n    throw new Error(\"The `forceHttp` and `forceHttps` options cannot be used together\");\n  }\n  if (options.forceHttp && urlObject.protocol === \"https:\") {\n    urlObject.protocol = \"http:\";\n  }\n  if (options.forceHttps && urlObject.protocol === \"http:\") {\n    urlObject.protocol = \"https:\";\n  }\n  if (options.stripAuthentication) {\n    urlObject.username = \"\";\n    urlObject.password = \"\";\n  }\n  if (options.stripHash) {\n    urlObject.hash = \"\";\n  } else if (options.stripTextFragment) {\n    urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, \"\");\n  }\n  if (urlObject.pathname) {\n    const protocolRegex = /\\b[a-z][a-z\\d+\\-.]{1,50}:\\/\\//g;\n    let lastIndex = 0;\n    let result = \"\";\n    for (; ; ) {\n      const match = protocolRegex.exec(urlObject.pathname);\n      if (!match) {\n        break;\n      }\n      const protocol = match[0];\n      const protocolAtIndex = match.index;\n      const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);\n      result += intermediate.replace(/\\/{2,}/g, \"/\");\n      result += protocol;\n      lastIndex = protocolAtIndex + protocol.length;\n    }\n    const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);\n    result += remnant.replace(/\\/{2,}/g, \"/\");\n    urlObject.pathname = result;\n  }\n  if (urlObject.pathname) {\n    try {\n      urlObject.pathname = decodeURI(urlObject.pathname);\n    } catch {\n    }\n  }\n  if (options.removeDirectoryIndex === true) {\n    options.removeDirectoryIndex = [/^index\\.[a-z]+$/];\n  }\n  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {\n    let pathComponents = urlObject.pathname.split(\"/\");\n    const lastComponent = pathComponents[pathComponents.length - 1];\n    if (testParameter(lastComponent, options.removeDirectoryIndex)) {\n      pathComponents = pathComponents.slice(0, -1);\n      urlObject.pathname = `${pathComponents.slice(1).join(\"/\")}/`;\n    }\n  }\n  if (urlObject.hostname) {\n    urlObject.hostname = urlObject.hostname.replace(/\\.$/, \"\");\n    if (options.stripWWW && /^www\\.(?!www\\.)[a-z\\-\\d]{1,63}\\.[a-z.\\-\\d]{2,63}$/.test(urlObject.hostname)) {\n      urlObject.hostname = urlObject.hostname.replace(/^www\\./, \"\");\n    }\n  }\n  if (Array.isArray(options.removeQueryParameters)) {\n    for (const key of [...urlObject.searchParams.keys()]) {\n      if (testParameter(key, options.removeQueryParameters)) {\n        urlObject.searchParams.delete(key);\n      }\n    }\n  }\n  if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {\n    urlObject.search = \"\";\n  }\n  if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {\n    for (const key of [...urlObject.searchParams.keys()]) {\n      if (!testParameter(key, options.keepQueryParameters)) {\n        urlObject.searchParams.delete(key);\n      }\n    }\n  }\n  if (options.sortQueryParameters) {\n    urlObject.searchParams.sort();\n    try {\n      urlObject.search = decodeURIComponent(urlObject.search);\n    } catch {\n    }\n  }\n  if (options.removeTrailingSlash) {\n    urlObject.pathname = urlObject.pathname.replace(/\\/$/, \"\");\n  }\n  if (options.removeExplicitPort && urlObject.port) {\n    urlObject.port = \"\";\n  }\n  const oldUrlString = urlString;\n  urlString = urlObject.toString();\n  if (!options.removeSingleSlash && urlObject.pathname === \"/\" && !oldUrlString.endsWith(\"/\") && urlObject.hash === \"\") {\n    urlString = urlString.replace(/\\/$/, \"\");\n  }\n  if ((options.removeTrailingSlash || urlObject.pathname === \"/\") && urlObject.hash === \"\" && options.removeSingleSlash) {\n    urlString = urlString.replace(/\\/$/, \"\");\n  }\n  if (hasRelativeProtocol && !options.normalizeProtocol) {\n    urlString = urlString.replace(/^http:\\/\\//, \"//\");\n  }\n  if (options.stripProtocol) {\n    urlString = urlString.replace(/^(?:https?:)?\\/\\//, \"\");\n  }\n  return urlString;\n}\n\n// src/relay/index.ts\n\n\n\n// src/relay/connectivity.ts\nvar MAX_RECONNECT_ATTEMPTS = 5;\nvar FLAPPING_THRESHOLD_MS = 1e3;\nvar NDKRelayConnectivity = class {\n  ndkRelay;\n  ws;\n  _status;\n  timeoutMs;\n  connectedAt;\n  _connectionStats = {\n    attempts: 0,\n    success: 0,\n    durations: []\n  };\n  debug;\n  netDebug;\n  connectTimeout;\n  reconnectTimeout;\n  ndk;\n  openSubs = /* @__PURE__ */ new Map();\n  openCountRequests = /* @__PURE__ */ new Map();\n  openEventPublishes = /* @__PURE__ */ new Map();\n  serial = 0;\n  baseEoseTimeout = 4400;\n  constructor(ndkRelay, ndk) {\n    this.ndkRelay = ndkRelay;\n    this._status = 1 /* DISCONNECTED */;\n    const rand = Math.floor(Math.random() * 1e3);\n    this.debug = this.ndkRelay.debug.extend(`connectivity${rand}`);\n    this.ndk = ndk;\n  }\n  /**\n   * Connects to the NDK relay and handles the connection lifecycle.\n   *\n   * This method attempts to establish a WebSocket connection to the NDK relay specified in the `ndkRelay` object.\n   * If the connection is successful, it updates the connection statistics, sets the connection status to `CONNECTED`,\n   * and emits `connect` and `ready` events on the `ndkRelay` object.\n   *\n   * If the connection attempt fails, it handles the error by either initiating a reconnection attempt or emitting a\n   * `delayed-connect` event on the `ndkRelay` object, depending on the `reconnect` parameter.\n   *\n   * @param timeoutMs - The timeout in milliseconds for the connection attempt. If not provided, the default timeout from the `ndkRelay` object is used.\n   * @param reconnect - Indicates whether a reconnection should be attempted if the connection fails. Defaults to `true`.\n   * @returns A Promise that resolves when the connection is established, or rejects if the connection fails.\n   */\n  async connect(timeoutMs, reconnect = true) {\n    if (this._status !== 2 /* RECONNECTING */ && this._status !== 1 /* DISCONNECTED */ || this.reconnectTimeout) {\n      this.debug(\n        \"Relay requested to be connected but was in state %s or it had a reconnect timeout\",\n        this._status\n      );\n      return;\n    }\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = void 0;\n    }\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = void 0;\n    }\n    timeoutMs ??= this.timeoutMs;\n    if (!this.timeoutMs && timeoutMs) this.timeoutMs = timeoutMs;\n    if (this.timeoutMs) this.connectTimeout = setTimeout(() => this.onConnectionError(reconnect), this.timeoutMs);\n    try {\n      this.updateConnectionStats.attempt();\n      if (this._status === 1 /* DISCONNECTED */) this._status = 4 /* CONNECTING */;\n      else this._status = 2 /* RECONNECTING */;\n      this.ws = new WebSocket(this.ndkRelay.url);\n      this.ws.onopen = this.onConnect.bind(this);\n      this.ws.onclose = this.onDisconnect.bind(this);\n      this.ws.onmessage = this.onMessage.bind(this);\n      this.ws.onerror = this.onError.bind(this);\n    } catch (e) {\n      this.debug(`Failed to connect to ${this.ndkRelay.url}`, e);\n      this._status = 1 /* DISCONNECTED */;\n      if (reconnect) this.handleReconnection();\n      else this.ndkRelay.emit(\"delayed-connect\", 2 * 24 * 60 * 60 * 1e3);\n      throw e;\n    }\n  }\n  /**\n   * Disconnects the WebSocket connection to the NDK relay.\n   * This method sets the connection status to `NDKRelayStatus.DISCONNECTING`,\n   * attempts to close the WebSocket connection, and sets the status to\n   * `NDKRelayStatus.DISCONNECTED` if the disconnect operation fails.\n   */\n  disconnect() {\n    this._status = 0 /* DISCONNECTING */;\n    try {\n      this.ws?.close();\n    } catch (e) {\n      this.debug(\"Failed to disconnect\", e);\n      this._status = 1 /* DISCONNECTED */;\n    }\n  }\n  /**\n   * Handles the error that occurred when attempting to connect to the NDK relay.\n   * If `reconnect` is `true`, this method will initiate a reconnection attempt.\n   * Otherwise, it will emit a `delayed-connect` event on the `ndkRelay` object,\n   * indicating that a reconnection should be attempted after a delay.\n   *\n   * @param reconnect - Indicates whether a reconnection should be attempted.\n   */\n  onConnectionError(reconnect) {\n    this.debug(`Error connecting to ${this.ndkRelay.url}`, this.timeoutMs);\n    if (reconnect && !this.reconnectTimeout) {\n      this.handleReconnection();\n    }\n  }\n  /**\n   * Handles the connection event when the WebSocket connection is established.\n   * This method is called when the WebSocket connection is successfully opened.\n   * It clears any existing connection and reconnection timeouts, updates the connection statistics,\n   * sets the connection status to `CONNECTED`, and emits `connect` and `ready` events on the `ndkRelay` object.\n   */\n  onConnect() {\n    this.netDebug?.(\"connected\", this.ndkRelay);\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = void 0;\n    }\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = void 0;\n    }\n    this.updateConnectionStats.connected();\n    this._status = 5 /* CONNECTED */;\n    this.ndkRelay.emit(\"connect\");\n    this.ndkRelay.emit(\"ready\");\n  }\n  /**\n   * Handles the disconnection event when the WebSocket connection is closed.\n   * This method is called when the WebSocket connection is successfully closed.\n   * It updates the connection statistics, sets the connection status to `DISCONNECTED`,\n   * initiates a reconnection attempt if we didn't disconnect ourselves,\n   * and emits a `disconnect` event on the `ndkRelay` object.\n   */\n  onDisconnect() {\n    this.netDebug?.(\"disconnected\", this.ndkRelay);\n    this.updateConnectionStats.disconnected();\n    if (this._status === 5 /* CONNECTED */) {\n      this.handleReconnection();\n    }\n    this._status = 1 /* DISCONNECTED */;\n    this.ndkRelay.emit(\"disconnect\");\n  }\n  /**\n   * Handles incoming messages from the NDK relay WebSocket connection.\n   * This method is called whenever a message is received from the relay.\n   * It parses the message data and dispatches the appropriate handling logic based on the message type.\n   *\n   * @param event - The MessageEvent containing the received message data.\n   */\n  onMessage(event) {\n    this.netDebug?.(event.data, this.ndkRelay, \"recv\");\n    try {\n      const data = JSON.parse(event.data);\n      const [cmd, id, ..._rest] = data;\n      switch (cmd) {\n        case \"EVENT\": {\n          const so = this.openSubs.get(id);\n          const event2 = data[2];\n          if (!so) {\n            this.debug(`Received event for unknown subscription ${id}`);\n            return;\n          }\n          so.onevent(event2);\n          return;\n        }\n        case \"COUNT\": {\n          const payload = data[2];\n          const cr = this.openCountRequests.get(id);\n          if (cr) {\n            cr.resolve(payload.count);\n            this.openCountRequests.delete(id);\n          }\n          return;\n        }\n        case \"EOSE\": {\n          const so = this.openSubs.get(id);\n          if (!so) return;\n          so.oneose(id);\n          return;\n        }\n        case \"OK\": {\n          const ok = data[2];\n          const reason = data[3];\n          const ep = this.openEventPublishes.get(id);\n          const firstEp = ep?.pop();\n          if (!ep || !firstEp) {\n            this.debug(\"Received OK for unknown event publish\", id);\n            return;\n          }\n          if (ok) firstEp.resolve(reason);\n          else firstEp.reject(new Error(reason));\n          if (ep.length === 0) {\n            this.openEventPublishes.delete(id);\n          } else {\n            this.openEventPublishes.set(id, ep);\n          }\n          return;\n        }\n        case \"CLOSED\": {\n          const so = this.openSubs.get(id);\n          if (!so) return;\n          so.onclosed(data[2]);\n          return;\n        }\n        case \"NOTICE\":\n          this.onNotice(data[1]);\n          return;\n        case \"AUTH\": {\n          this.onAuthRequested(data[1]);\n          return;\n        }\n      }\n    } catch (error) {\n      this.debug(`Error parsing message from ${this.ndkRelay.url}: ${error.message}`, error?.stack);\n      return;\n    }\n  }\n  /**\n   * Handles an authentication request from the NDK relay.\n   *\n   * If an authentication policy is configured, it will be used to authenticate the connection.\n   * Otherwise, the `auth` event will be emitted to allow the application to handle the authentication.\n   *\n   * @param challenge - The authentication challenge provided by the NDK relay.\n   */\n  async onAuthRequested(challenge) {\n    const authPolicy = this.ndkRelay.authPolicy ?? this.ndk?.relayAuthDefaultPolicy;\n    this.debug(\"Relay requested authentication\", {\n      havePolicy: !!authPolicy\n    });\n    if (this._status === 7 /* AUTHENTICATING */) {\n      this.debug(\"Already authenticating, ignoring\");\n      return;\n    }\n    this._status = 6 /* AUTH_REQUESTED */;\n    if (authPolicy) {\n      if (this._status >= 5 /* CONNECTED */) {\n        this._status = 7 /* AUTHENTICATING */;\n        let res;\n        try {\n          res = await authPolicy(this.ndkRelay, challenge);\n        } catch (e) {\n          this.debug(\"Authentication policy threw an error\", e);\n          res = false;\n        }\n        this.debug(\"Authentication policy returned\", !!res);\n        if (res instanceof NDKEvent || res === true) {\n          if (res instanceof NDKEvent) {\n            await this.auth(res);\n          }\n          const authenticate = async () => {\n            if (this._status >= 5 /* CONNECTED */ && this._status < 8 /* AUTHENTICATED */) {\n              const event = new NDKEvent(this.ndk);\n              event.kind = 22242 /* ClientAuth */;\n              event.tags = [\n                [\"relay\", this.ndkRelay.url],\n                [\"challenge\", challenge]\n              ];\n              await event.sign();\n              this.auth(event).then(() => {\n                this._status = 8 /* AUTHENTICATED */;\n                this.ndkRelay.emit(\"authed\");\n                this.debug(\"Authentication successful\");\n              }).catch((e) => {\n                this._status = 6 /* AUTH_REQUESTED */;\n                this.ndkRelay.emit(\"auth:failed\", e);\n                this.debug(\"Authentication failed\", e);\n              });\n            } else {\n              this.debug(\"Authentication failed, it changed status, status is %d\", this._status);\n            }\n          };\n          if (res === true) {\n            if (!this.ndk?.signer) {\n              this.debug(\"No signer available for authentication localhost\");\n              this.ndk?.once(\"signer:ready\", authenticate);\n            } else {\n              authenticate().catch((e) => {\n                console.error(\"Error authenticating\", e);\n              });\n            }\n          }\n          this._status = 5 /* CONNECTED */;\n          this.ndkRelay.emit(\"authed\");\n        }\n      }\n    } else {\n      this.ndkRelay.emit(\"auth\", challenge);\n    }\n  }\n  /**\n   * Handles errors that occur on the WebSocket connection to the relay.\n   * @param error - The error or event that occurred.\n   */\n  onError(error) {\n    this.debug(`WebSocket error on ${this.ndkRelay.url}:`, error);\n  }\n  /**\n   * Gets the current status of the NDK relay connection.\n   * @returns {NDKRelayStatus} The current status of the NDK relay connection.\n   */\n  get status() {\n    return this._status;\n  }\n  /**\n   * Checks if the NDK relay connection is currently available.\n   * @returns {boolean} `true` if the relay connection is in the `CONNECTED` status, `false` otherwise.\n   */\n  isAvailable() {\n    return this._status === 5 /* CONNECTED */;\n  }\n  /**\n   * Checks if the NDK relay connection is flapping, which means the connection is rapidly\n   * disconnecting and reconnecting. This is determined by analyzing the durations of the\n   * last three connection attempts. If the standard deviation of the durations is less\n   * than 1000 milliseconds, the connection is considered to be flapping.\n   *\n   * @returns {boolean} `true` if the connection is flapping, `false` otherwise.\n   */\n  isFlapping() {\n    const durations = this._connectionStats.durations;\n    if (durations.length % 3 !== 0) return false;\n    const sum = durations.reduce((a, b) => a + b, 0);\n    const avg = sum / durations.length;\n    const variance = durations.map((x) => (x - avg) ** 2).reduce((a, b) => a + b, 0) / durations.length;\n    const stdDev = Math.sqrt(variance);\n    const isFlapping = stdDev < FLAPPING_THRESHOLD_MS;\n    return isFlapping;\n  }\n  /**\n   * Handles a notice received from the NDK relay.\n   * If the notice indicates the relay is complaining (e.g. \"too many\" or \"maximum\"),\n   * the method disconnects from the relay and attempts to reconnect after a 2-second delay.\n   * A debug message is logged with the relay URL and the notice text.\n   * The \"notice\" event is emitted on the ndkRelay instance with the notice text.\n   *\n   * @param notice - The notice text received from the NDK relay.\n   */\n  async onNotice(notice) {\n    this.ndkRelay.emit(\"notice\", notice);\n  }\n  /**\n   * Attempts to reconnect to the NDK relay after a connection is lost.\n   * This function is called recursively to handle multiple reconnection attempts.\n   * It checks if the relay is flapping and emits a \"flapping\" event if so.\n   * It then calculates a delay before the next reconnection attempt based on the number of previous attempts.\n   * The function sets a timeout to execute the next reconnection attempt after the calculated delay.\n   * If the maximum number of reconnection attempts is reached, a debug message is logged.\n   *\n   * @param attempt - The current attempt number (default is 0).\n   */\n  handleReconnection(attempt = 0) {\n    if (this.reconnectTimeout) return;\n    if (this.isFlapping()) {\n      this.ndkRelay.emit(\"flapping\", this._connectionStats);\n      this._status = 3 /* FLAPPING */;\n      return;\n    }\n    const reconnectDelay = this.connectedAt ? Math.max(0, 6e4 - (Date.now() - this.connectedAt)) : 5e3 * (this._connectionStats.attempts + 1);\n    this.reconnectTimeout = setTimeout(() => {\n      this.reconnectTimeout = void 0;\n      this._status = 2 /* RECONNECTING */;\n      this.connect().catch((_err) => {\n        if (attempt < MAX_RECONNECT_ATTEMPTS) {\n          setTimeout(\n            () => {\n              this.handleReconnection(attempt + 1);\n            },\n            1e3 * (attempt + 1) ^ 4\n          );\n        } else {\n          this.debug(\"Reconnect failed\");\n        }\n      });\n    }, reconnectDelay);\n    this.ndkRelay.emit(\"delayed-connect\", reconnectDelay);\n    this.debug(\"Reconnecting in\", reconnectDelay);\n    this._connectionStats.nextReconnectAt = Date.now() + reconnectDelay;\n  }\n  /**\n   * Sends a message to the NDK relay if the connection is in the CONNECTED state and the WebSocket is open.\n   * If the connection is not in the CONNECTED state or the WebSocket is not open, logs a debug message and throws an error.\n   *\n   * @param message - The message to send to the NDK relay.\n   * @throws {Error} If attempting to send on a closed relay connection.\n   */\n  async send(message) {\n    if (this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN) {\n      this.ws?.send(message);\n      this.netDebug?.(message, this.ndkRelay, \"send\");\n    } else {\n      this.debug(`Not connected to ${this.ndkRelay.url} (%d), not sending message ${message}`, this._status);\n    }\n  }\n  /**\n   * Authenticates the NDK event by sending it to the NDK relay and returning a promise that resolves with the result.\n   *\n   * @param event - The NDK event to authenticate.\n   * @returns A promise that resolves with the authentication result.\n   */\n  async auth(event) {\n    const ret = new Promise((resolve, reject) => {\n      const val = this.openEventPublishes.get(event.id) ?? [];\n      val.push({ resolve, reject });\n      this.openEventPublishes.set(event.id, val);\n    });\n    this.send(`[\"AUTH\",${JSON.stringify(event.rawEvent())}]`);\n    return ret;\n  }\n  /**\n   * Publishes an NDK event to the relay and returns a promise that resolves with the result.\n   *\n   * @param event - The NDK event to publish.\n   * @returns A promise that resolves with the result of the event publication.\n   * @throws {Error} If attempting to publish on a closed relay connection.\n   */\n  async publish(event) {\n    const ret = new Promise((resolve, reject) => {\n      const val = this.openEventPublishes.get(event.id) ?? [];\n      if (val.length > 0) {\n        console.warn(`Duplicate event publishing detected, you are publishing event ${event.id} twice`);\n      }\n      val.push({ resolve, reject });\n      this.openEventPublishes.set(event.id, val);\n    });\n    this.send(`[\"EVENT\",${JSON.stringify(event)}]`);\n    return ret;\n  }\n  /**\n   * Counts the number of events that match the provided filters.\n   *\n   * @param filters - The filters to apply to the count request.\n   * @param params - An optional object containing a custom id for the count request.\n   * @returns A promise that resolves with the number of matching events.\n   * @throws {Error} If attempting to send the count request on a closed relay connection.\n   */\n  async count(filters, params) {\n    this.serial++;\n    const id = params?.id || `count:${this.serial}`;\n    const ret = new Promise((resolve, reject) => {\n      this.openCountRequests.set(id, { resolve, reject });\n    });\n    this.send(`[\"COUNT\",\"${id}\",${JSON.stringify(filters).substring(1)}`);\n    return ret;\n  }\n  close(subId, reason) {\n    this.send(`[\"CLOSE\",\"${subId}\"]`);\n    const sub = this.openSubs.get(subId);\n    this.openSubs.delete(subId);\n    if (sub) sub.onclose(reason);\n  }\n  /**\n   * Subscribes to the NDK relay with the provided filters and parameters.\n   *\n   * @param filters - The filters to apply to the subscription.\n   * @param params - The subscription parameters, including an optional custom id.\n   * @returns A new NDKRelaySubscription instance.\n   */\n  req(relaySub) {\n    `${this.send(`[\"REQ\",\"${relaySub.subId}\",${JSON.stringify(relaySub.executeFilters).substring(1)}`)}]`;\n    this.openSubs.set(relaySub.subId, relaySub);\n  }\n  /**\n   * Utility functions to update the connection stats.\n   */\n  updateConnectionStats = {\n    connected: () => {\n      this._connectionStats.success++;\n      this._connectionStats.connectedAt = Date.now();\n    },\n    disconnected: () => {\n      if (this._connectionStats.connectedAt) {\n        this._connectionStats.durations.push(Date.now() - this._connectionStats.connectedAt);\n        if (this._connectionStats.durations.length > 100) {\n          this._connectionStats.durations.shift();\n        }\n      }\n      this._connectionStats.connectedAt = void 0;\n    },\n    attempt: () => {\n      this._connectionStats.attempts++;\n      this._connectionStats.connectedAt = Date.now();\n    }\n  };\n  /** Returns the connection stats. */\n  get connectionStats() {\n    return this._connectionStats;\n  }\n  /** Returns the relay URL */\n  get url() {\n    return this.ndkRelay.url;\n  }\n  get connected() {\n    return this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN;\n  }\n};\n\n// src/relay/publisher.ts\nvar NDKRelayPublisher = class {\n  ndkRelay;\n  debug;\n  constructor(ndkRelay) {\n    this.ndkRelay = ndkRelay;\n    this.debug = ndkRelay.debug.extend(\"publisher\");\n  }\n  /**\n   * Published an event to the relay; if the relay is not connected, it will\n   * wait for the relay to connect before publishing the event.\n   *\n   * If the relay does not connect within the timeout, the publish operation\n   * will fail.\n   * @param event  The event to publish\n   * @param timeoutMs  The timeout for the publish operation in milliseconds\n   * @returns A promise that resolves when the event has been published or rejects if the operation times out\n   */\n  async publish(event, timeoutMs = 2500) {\n    let timeout;\n    const publishConnected = () => {\n      return new Promise((resolve, reject) => {\n        try {\n          this.publishEvent(event).then((_result) => {\n            this.ndkRelay.emit(\"published\", event);\n            event.emit(\"relay:published\", this.ndkRelay);\n            resolve(true);\n          }).catch(reject);\n        } catch (err) {\n          reject(err);\n        }\n      });\n    };\n    const timeoutPromise = new Promise((_, reject) => {\n      timeout = setTimeout(() => {\n        timeout = void 0;\n        reject(new Error(`Timeout: ${timeoutMs}ms`));\n      }, timeoutMs);\n    });\n    const onConnectHandler = () => {\n      publishConnected().then((result) => connectResolve(result)).catch((err) => connectReject(err));\n    };\n    let connectResolve;\n    let connectReject;\n    const onError = (err) => {\n      this.ndkRelay.debug(\"Publish failed\", err, event.id);\n      this.ndkRelay.emit(\"publish:failed\", event, err);\n      event.emit(\"relay:publish:failed\", this.ndkRelay, err);\n      throw err;\n    };\n    const onFinally = () => {\n      if (timeout) clearTimeout(timeout);\n      this.ndkRelay.removeListener(\"connect\", onConnectHandler);\n    };\n    if (this.ndkRelay.status >= 5 /* CONNECTED */) {\n      return Promise.race([publishConnected(), timeoutPromise]).catch(onError).finally(onFinally);\n    }\n    if (this.ndkRelay.status <= 1 /* DISCONNECTED */) {\n      console.warn(\"Relay is disconnected, trying to connect to publish an event\", this.ndkRelay.url);\n      this.ndkRelay.connect();\n    } else {\n      console.warn(\"Relay not connected, waiting for connection to publish an event\", this.ndkRelay.url);\n    }\n    return Promise.race([\n      new Promise((resolve, reject) => {\n        connectResolve = resolve;\n        connectReject = reject;\n        this.ndkRelay.once(\"connect\", onConnectHandler);\n      }),\n      timeoutPromise\n    ]).catch(onError).finally(onFinally);\n  }\n  async publishEvent(event) {\n    return this.ndkRelay.connectivity.publish(event.rawEvent());\n  }\n};\n\n// src/subscription/grouping.ts\nfunction filterFingerprint(filters, closeOnEose) {\n  const elements = [];\n  for (const filter of filters) {\n    const keys = Object.entries(filter || {}).map(([key, values]) => {\n      if ([\"since\", \"until\"].includes(key)) {\n        return `${key}:${values}`;\n      }\n      return key;\n    }).sort().join(\"-\");\n    elements.push(keys);\n  }\n  let id = closeOnEose ? \"+\" : \"\";\n  id += elements.join(\"|\");\n  return id;\n}\nfunction mergeFilters(filters) {\n  const result = [];\n  const lastResult = {};\n  filters.filter((f) => !!f.limit).forEach((filterWithLimit) => result.push(filterWithLimit));\n  filters = filters.filter((f) => !f.limit);\n  if (filters.length === 0) return result;\n  filters.forEach((filter) => {\n    Object.entries(filter).forEach(([key, value]) => {\n      if (Array.isArray(value)) {\n        if (lastResult[key] === void 0) {\n          lastResult[key] = [...value];\n        } else {\n          lastResult[key] = Array.from(/* @__PURE__ */ new Set([...lastResult[key], ...value]));\n        }\n      } else {\n        lastResult[key] = value;\n      }\n    });\n  });\n  return [...result, lastResult];\n}\n\n// src/relay/subscription.ts\nvar NDKRelaySubscription = class {\n  fingerprint;\n  items = /* @__PURE__ */ new Map();\n  topSubManager;\n  debug;\n  /**\n   * Tracks the status of this REQ.\n   */\n  status = 0 /* INITIAL */;\n  onClose;\n  relay;\n  /**\n   * Whether this subscription has reached EOSE.\n   */\n  eosed = false;\n  /**\n   * Timeout at which this subscription will\n   * start executing.\n   */\n  executionTimer;\n  /**\n   * Track the time at which this subscription will fire.\n   */\n  fireTime;\n  /**\n   * The delay type that the current fireTime was calculated with.\n   */\n  delayType;\n  /**\n   * The filters that have been executed.\n   */\n  executeFilters;\n  id = Math.random().toString(36).substring(7);\n  /**\n   *\n   * @param fingerprint The fingerprint of this subscription.\n   */\n  constructor(relay, fingerprint, topSubManager) {\n    this.relay = relay;\n    this.topSubManager = topSubManager;\n    this.debug = relay.debug.extend(`sub[${this.id}]`);\n    this.fingerprint = fingerprint || Math.random().toString(36).substring(7);\n  }\n  _subId;\n  get subId() {\n    if (this._subId) return this._subId;\n    this._subId = this.fingerprint.slice(0, 15);\n    return this._subId;\n  }\n  subIdParts = /* @__PURE__ */ new Set();\n  addSubIdPart(part) {\n    this.subIdParts.add(part);\n  }\n  addItem(subscription, filters) {\n    this.debug(\"Adding item\", {\n      filters,\n      internalId: subscription.internalId,\n      status: this.status,\n      fingerprint: this.fingerprint,\n      id: this.subId,\n      items: this.items,\n      itemsSize: this.items.size\n    });\n    if (this.items.has(subscription.internalId)) return;\n    subscription.on(\"close\", this.removeItem.bind(this, subscription));\n    this.items.set(subscription.internalId, { subscription, filters });\n    if (this.status !== 3 /* RUNNING */) {\n      if (subscription.subId && (!this._subId || this._subId.length < 48)) {\n        if (this.status === 0 /* INITIAL */ || this.status === 1 /* PENDING */) {\n          this.addSubIdPart(subscription.subId);\n        }\n      }\n    }\n    switch (this.status) {\n      case 0 /* INITIAL */:\n        this.evaluateExecutionPlan(subscription);\n        break;\n      case 3 /* RUNNING */:\n        break;\n      case 1 /* PENDING */:\n        this.evaluateExecutionPlan(subscription);\n        break;\n      case 4 /* CLOSED */:\n        this.debug(\"Subscription is closed, cannot add new items %o (%o)\", subscription, filters);\n        throw new Error(\"Cannot add new items to a closed subscription\");\n    }\n  }\n  /**\n   * A subscription has been closed, remove it from the list of items.\n   * @param subscription\n   */\n  removeItem(subscription) {\n    this.items.delete(subscription.internalId);\n    if (this.items.size === 0) {\n      if (!this.eosed) return;\n      this.close();\n      this.cleanup();\n    }\n  }\n  close() {\n    if (this.status === 4 /* CLOSED */) return;\n    const prevStatus = this.status;\n    this.status = 4 /* CLOSED */;\n    if (prevStatus === 3 /* RUNNING */) {\n      try {\n        this.relay.close(this.subId);\n      } catch (e) {\n        this.debug(\"Error closing subscription\", e, this);\n      }\n    } else {\n      this.debug(\"Subscription wanted to close but it wasn't running, this is probably ok\", {\n        subId: this.subId,\n        prevStatus,\n        sub: this\n      });\n    }\n    this.cleanup();\n  }\n  cleanup() {\n    if (this.executionTimer) clearTimeout(this.executionTimer);\n    this.relay.off(\"ready\", this.executeOnRelayReady);\n    this.relay.off(\"authed\", this.reExecuteAfterAuth);\n    if (this.onClose) this.onClose(this);\n  }\n  evaluateExecutionPlan(subscription) {\n    if (!subscription.isGroupable()) {\n      this.status = 1 /* PENDING */;\n      this.execute();\n      return;\n    }\n    if (subscription.filters.find((filter) => !!filter.limit)) {\n      this.executeFilters = this.compileFilters();\n      if (this.executeFilters.length >= 10) {\n        this.status = 1 /* PENDING */;\n        this.execute();\n        return;\n      }\n    }\n    const delay = subscription.groupableDelay;\n    const delayType = subscription.groupableDelayType;\n    if (!delay) throw new Error(\"Cannot group a subscription without a delay\");\n    if (this.status === 0 /* INITIAL */) {\n      this.schedule(delay, delayType);\n    } else {\n      const existingDelayType = this.delayType;\n      const timeUntilFire = this.fireTime - Date.now();\n      if (existingDelayType === \"at-least\" && delayType === \"at-least\") {\n        if (timeUntilFire < delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-least\" && delayType === \"at-most\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-most\" && delayType === \"at-most\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-most\" && delayType === \"at-least\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else {\n        throw new Error(`Unknown delay type combination ${existingDelayType} ${delayType}`);\n      }\n    }\n  }\n  schedule(delay, delayType) {\n    this.status = 1 /* PENDING */;\n    const currentTime = Date.now();\n    this.fireTime = currentTime + delay;\n    this.delayType = delayType;\n    const timer = setTimeout(this.execute.bind(this), delay);\n    if (delayType === \"at-least\") {\n      this.executionTimer = timer;\n    }\n  }\n  executeOnRelayReady = () => {\n    if (this.status !== 2 /* WAITING */) return;\n    if (this.items.size === 0) {\n      this.debug(\"No items to execute; this relay was probably too slow to respond and the caller gave up\", {\n        status: this.status,\n        fingerprint: this.fingerprint,\n        items: this.items,\n        itemsSize: this.items.size,\n        id: this.id,\n        subId: this.subId\n      });\n      this.cleanup();\n      return;\n    }\n    this.debug(\"Executing on relay ready\", {\n      status: this.status,\n      fingerprint: this.fingerprint,\n      items: this.items,\n      itemsSize: this.items.size\n    });\n    this.status = 1 /* PENDING */;\n    this.execute();\n  };\n  finalizeSubId() {\n    if (this.subIdParts.size > 0) {\n      this._subId = Array.from(this.subIdParts).join(\"-\");\n    } else {\n      this._subId = this.fingerprint.slice(0, 15);\n    }\n    this._subId += `-${Math.random().toString(36).substring(2, 7)}`;\n  }\n  // we do it this way so that we can remove the listener\n  reExecuteAfterAuth = (() => {\n    const oldSubId = this.subId;\n    this.debug(\"Re-executing after auth\", this.items.size);\n    if (this.eosed) {\n      this.relay.close(this.subId);\n    } else {\n      this.debug(\"We are abandoning an opened subscription, once it EOSE's, the handler will close it\", {\n        oldSubId\n      });\n    }\n    this._subId = void 0;\n    this.status = 1 /* PENDING */;\n    this.execute();\n    this.debug(\"Re-executed after auth %s \\u{1F449} %s\", oldSubId, this.subId);\n  }).bind(this);\n  execute() {\n    if (this.status !== 1 /* PENDING */) {\n      return;\n    }\n    if (!this.relay.connected) {\n      this.status = 2 /* WAITING */;\n      this.debug(\"Waiting for relay to be ready\", {\n        status: this.status,\n        id: this.subId,\n        fingerprint: this.fingerprint,\n        items: this.items,\n        itemsSize: this.items.size\n      });\n      this.relay.once(\"ready\", this.executeOnRelayReady);\n      return;\n    }\n    if (this.relay.status < 8 /* AUTHENTICATED */) {\n      this.relay.once(\"authed\", this.reExecuteAfterAuth);\n    }\n    this.status = 3 /* RUNNING */;\n    this.finalizeSubId();\n    this.executeFilters = this.compileFilters();\n    this.relay.req(this);\n  }\n  onstart() {\n  }\n  onevent(event) {\n    this.topSubManager.dispatchEvent(event, this.relay);\n  }\n  oneose(subId) {\n    this.eosed = true;\n    if (subId !== this.subId) {\n      this.debug(\"Received EOSE for an abandoned subscription\", subId, this.subId);\n      this.relay.close(subId);\n      return;\n    }\n    if (this.items.size === 0) {\n      this.close();\n    }\n    for (const { subscription } of this.items.values()) {\n      subscription.eoseReceived(this.relay);\n      if (subscription.closeOnEose) {\n        this.debug(\"Removing item because of EOSE\", {\n          filters: subscription.filters,\n          internalId: subscription.internalId,\n          status: this.status,\n          fingerprint: this.fingerprint,\n          items: this.items,\n          itemsSize: this.items.size\n        });\n        this.removeItem(subscription);\n      }\n    }\n  }\n  onclose(_reason) {\n    this.status = 4 /* CLOSED */;\n  }\n  onclosed(reason) {\n    if (!reason) return;\n    for (const { subscription } of this.items.values()) {\n      subscription.closedReceived(this.relay, reason);\n    }\n  }\n  /**\n   * Grabs the filters from all the subscriptions\n   * and merges them into a single filter.\n   */\n  compileFilters() {\n    const mergedFilters = [];\n    const filters = Array.from(this.items.values()).map((item) => item.filters);\n    if (!filters[0]) {\n      this.debug(\"\\u{1F440} No filters to merge\", this.items);\n      console.error(\"BUG: No filters to merge!\", this.items);\n      return [];\n    }\n    const filterCount = filters[0].length;\n    for (let i = 0; i < filterCount; i++) {\n      const allFiltersAtIndex = filters.map((filter) => filter[i]);\n      mergedFilters.push(...mergeFilters(allFiltersAtIndex));\n    }\n    return mergedFilters;\n  }\n};\n\n// src/relay/sub-manager.ts\nvar NDKRelaySubscriptionManager = class {\n  relay;\n  subscriptions;\n  generalSubManager;\n  /**\n   * @param relay - The relay instance.\n   * @param generalSubManager - The subscription manager instance.\n   */\n  constructor(relay, generalSubManager) {\n    this.relay = relay;\n    this.subscriptions = /* @__PURE__ */ new Map();\n    this.generalSubManager = generalSubManager;\n  }\n  /**\n   * Adds a subscription to the manager.\n   */\n  addSubscription(sub, filters) {\n    let relaySub;\n    if (!sub.isGroupable()) {\n      relaySub = this.createSubscription(sub, filters);\n    } else {\n      const filterFp = filterFingerprint(filters, sub.closeOnEose);\n      if (filterFp) {\n        const existingSubs = this.subscriptions.get(filterFp);\n        relaySub = (existingSubs || []).find((sub2) => sub2.status < 3 /* RUNNING */);\n      }\n      relaySub ??= this.createSubscription(sub, filters, filterFp);\n    }\n    relaySub.addItem(sub, filters);\n  }\n  createSubscription(_sub, _filters, fingerprint) {\n    const relaySub = new NDKRelaySubscription(this.relay, fingerprint || null, this.generalSubManager);\n    relaySub.onClose = this.onRelaySubscriptionClose.bind(this);\n    const currentVal = this.subscriptions.get(relaySub.fingerprint) ?? [];\n    this.subscriptions.set(relaySub.fingerprint, [...currentVal, relaySub]);\n    return relaySub;\n  }\n  onRelaySubscriptionClose(sub) {\n    let currentVal = this.subscriptions.get(sub.fingerprint) ?? [];\n    if (!currentVal) {\n      console.warn(\"Unexpectedly did not find a subscription with fingerprint\", sub.fingerprint);\n    } else if (currentVal.length === 1) {\n      this.subscriptions.delete(sub.fingerprint);\n    } else {\n      currentVal = currentVal.filter((s) => s.id !== sub.id);\n      this.subscriptions.set(sub.fingerprint, currentVal);\n    }\n  }\n};\n\n// src/relay/index.ts\nvar NDKRelayStatus = /* @__PURE__ */ ((NDKRelayStatus2) => {\n  NDKRelayStatus2[NDKRelayStatus2[\"DISCONNECTING\"] = 0] = \"DISCONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"DISCONNECTED\"] = 1] = \"DISCONNECTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"FLAPPING\"] = 3] = \"FLAPPING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"CONNECTING\"] = 4] = \"CONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"CONNECTED\"] = 5] = \"CONNECTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTH_REQUESTED\"] = 6] = \"AUTH_REQUESTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTHENTICATING\"] = 7] = \"AUTHENTICATING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTHENTICATED\"] = 8] = \"AUTHENTICATED\";\n  return NDKRelayStatus2;\n})(NDKRelayStatus || {});\nvar NDKRelay = class _NDKRelay extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  url;\n  scores;\n  connectivity;\n  subs;\n  publisher;\n  authPolicy;\n  /**\n   * The lowest validation ratio this relay can reach.\n   */\n  lowestValidationRatio;\n  /**\n   * Current validation ratio this relay is targeting.\n   */\n  targetValidationRatio;\n  validationRatioFn;\n  /**\n   * This tracks events that have been seen by this relay\n   * with a valid signature.\n   */\n  validatedEventCount = 0;\n  /**\n   * This tracks events that have been seen by this relay\n   * but have not been validated.\n   */\n  nonValidatedEventCount = 0;\n  /**\n   * Whether this relay is trusted.\n   *\n   * Trusted relay's events do not get their signature verified.\n   */\n  trusted = false;\n  complaining = false;\n  debug;\n  static defaultValidationRatioUpdateFn = (relay, validatedCount, _nonValidatedCount) => {\n    if (relay.lowestValidationRatio === void 0 || relay.targetValidationRatio === void 0) return 1;\n    let newRatio = relay.validationRatio;\n    if (relay.validationRatio > relay.targetValidationRatio) {\n      const factor = validatedCount / 100;\n      newRatio = Math.max(relay.lowestValidationRatio, relay.validationRatio - factor);\n    }\n    if (newRatio < relay.validationRatio) {\n      return newRatio;\n    }\n    return relay.validationRatio;\n  };\n  constructor(url, authPolicy, ndk) {\n    super();\n    this.url = normalizeRelayUrl(url);\n    this.scores = /* @__PURE__ */ new Map();\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_1__(`ndk:relay:${url}`);\n    this.connectivity = new NDKRelayConnectivity(this, ndk);\n    this.connectivity.netDebug = ndk?.netDebug;\n    this.req = this.connectivity.req.bind(this.connectivity);\n    this.close = this.connectivity.close.bind(this.connectivity);\n    this.subs = new NDKRelaySubscriptionManager(this, ndk.subManager);\n    this.publisher = new NDKRelayPublisher(this);\n    this.authPolicy = authPolicy;\n    this.targetValidationRatio = ndk?.initialValidationRatio;\n    this.lowestValidationRatio = ndk?.lowestValidationRatio;\n    this.validationRatioFn = (ndk?.validationRatioFn ?? _NDKRelay.defaultValidationRatioUpdateFn).bind(this);\n    this.updateValidationRatio();\n    if (!ndk) {\n      console.trace(\"relay created without ndk\");\n    }\n  }\n  updateValidationRatio() {\n    setTimeout(() => {\n      this.updateValidationRatio();\n    }, 3e4);\n  }\n  get status() {\n    return this.connectivity.status;\n  }\n  get connectionStats() {\n    return this.connectivity.connectionStats;\n  }\n  /**\n   * Connects to the relay.\n   */\n  async connect(timeoutMs, reconnect = true) {\n    return this.connectivity.connect(timeoutMs, reconnect);\n  }\n  /**\n   * Disconnects from the relay.\n   */\n  disconnect() {\n    if (this.status === 1 /* DISCONNECTED */) {\n      return;\n    }\n    this.connectivity.disconnect();\n  }\n  /**\n   * Queues or executes the subscription of a specific set of filters\n   * within this relay.\n   *\n   * @param subscription NDKSubscription this filters belong to.\n   * @param filters Filters to execute\n   */\n  subscribe(subscription, filters) {\n    this.subs.addSubscription(subscription, filters);\n  }\n  /**\n   * Publishes an event to the relay with an optional timeout.\n   *\n   * If the relay is not connected, the event will be published when the relay connects,\n   * unless the timeout is reached before the relay connects.\n   *\n   * @param event The event to publish\n   * @param timeoutMs The timeout for the publish operation in milliseconds\n   * @returns A promise that resolves when the event has been published or rejects if the operation times out\n   */\n  async publish(event, timeoutMs = 2500) {\n    return this.publisher.publish(event, timeoutMs);\n  }\n  referenceTags() {\n    return [[\"r\", this.url]];\n  }\n  addValidatedEvent() {\n    this.validatedEventCount++;\n  }\n  addNonValidatedEvent() {\n    this.nonValidatedEventCount++;\n  }\n  /**\n   * The current validation ratio this relay has achieved.\n   */\n  get validationRatio() {\n    if (this.nonValidatedEventCount === 0) {\n      return 1;\n    }\n    return this.validatedEventCount / (this.validatedEventCount + this.nonValidatedEventCount);\n  }\n  shouldValidateEvent() {\n    if (this.trusted) {\n      return false;\n    }\n    if (this.targetValidationRatio === void 0) {\n      return true;\n    }\n    return this.validationRatio < this.targetValidationRatio;\n  }\n  get connected() {\n    return this.connectivity.connected;\n  }\n  req;\n  close;\n};\n\n// src/relay/sets/index.ts\nvar NDKPublishError = class extends Error {\n  errors;\n  publishedToRelays;\n  /**\n   * Intended relay set where the publishing was intended to happen.\n   */\n  intendedRelaySet;\n  constructor(message, errors, publishedToRelays, intendedRelaySet) {\n    super(message);\n    this.errors = errors;\n    this.publishedToRelays = publishedToRelays;\n    this.intendedRelaySet = intendedRelaySet;\n  }\n  get relayErrors() {\n    const errors = [];\n    for (const [relay, err] of this.errors) {\n      errors.push(`${relay.url}: ${err}`);\n    }\n    return errors.join(\"\\n\");\n  }\n};\nvar NDKRelaySet = class _NDKRelaySet {\n  relays;\n  debug;\n  ndk;\n  pool;\n  constructor(relays, ndk, pool) {\n    this.relays = relays;\n    this.ndk = ndk;\n    this.pool = pool ?? ndk.pool;\n    this.debug = ndk.debug.extend(\"relayset\");\n  }\n  /**\n   * Adds a relay to this set.\n   */\n  addRelay(relay) {\n    this.relays.add(relay);\n  }\n  get relayUrls() {\n    return Array.from(this.relays).map((r) => r.url);\n  }\n  /**\n   * Creates a relay set from a list of relay URLs.\n   *\n   * If no connection to the relay is found in the pool it will temporarily\n   * connect to it.\n   *\n   * @param relayUrls - list of relay URLs to include in this set\n   * @param ndk\n   * @param connect - whether to connect to the relay immediately if it was already in the pool but not connected\n   * @returns NDKRelaySet\n   */\n  static fromRelayUrls(relayUrls, ndk, connect = true, pool) {\n    pool = pool ?? ndk.pool;\n    if (!pool) throw new Error(\"No pool provided\");\n    const relays = /* @__PURE__ */ new Set();\n    for (const url of relayUrls) {\n      const relay = pool.relays.get(normalizeRelayUrl(url));\n      if (relay) {\n        if (relay.status < 5 /* CONNECTED */ && connect) {\n          relay.connect();\n        }\n        relays.add(relay);\n      } else {\n        const temporaryRelay = new NDKRelay(normalizeRelayUrl(url), ndk?.relayAuthDefaultPolicy, ndk);\n        pool.useTemporaryRelay(temporaryRelay, void 0, `requested from fromRelayUrls ${relayUrls}`);\n        relays.add(temporaryRelay);\n      }\n    }\n    return new _NDKRelaySet(new Set(relays), ndk, pool);\n  }\n  /**\n   * Publish an event to all relays in this relay set.\n   *\n   * This method implements a robust mechanism for publishing events to multiple relays with\n   * built-in handling for race conditions, timeouts, and partial failures. The implementation\n   * uses a dual-tracking mechanism to ensure accurate reporting of which relays successfully\n   * received an event.\n   *\n   * Key aspects of this implementation:\n   *\n   * 1. DUAL-TRACKING MECHANISM:\n   *    - Promise-based tracking: Records successes/failures from the promises returned by relay.publish()\n   *    - Event-based tracking: Listens for 'relay:published' events that indicate successful publishing\n   *    This approach ensures we don't miss successful publishes even if there are subsequent errors in\n   *    the promise chain.\n   *\n   * 2. RACE CONDITION HANDLING:\n   *    - If a relay emits a success event but later fails in the promise chain, we still count it as a success\n   *    - If a relay times out after successfully publishing, we still count it as a success\n   *    - All relay operations happen in parallel, with proper tracking regardless of completion order\n   *\n   * 3. TIMEOUT MANAGEMENT:\n   *    - Individual timeouts for each relay operation\n   *    - Proper cleanup of timeouts to prevent memory leaks\n   *    - Clear timeout error reporting\n   *\n   * 4. ERROR HANDLING:\n   *    - Detailed tracking of specific errors for each failed relay\n   *    - Special handling for ephemeral events (which don't expect acknowledgement)\n   *    - RequiredRelayCount parameter to control the minimum success threshold\n   *\n   * @param event Event to publish\n   * @param timeoutMs Timeout in milliseconds for each relay publish operation\n   * @param requiredRelayCount The minimum number of relays we expect the event to be published to\n   * @returns A set of relays the event was published to\n   * @throws {NDKPublishError} If the event could not be published to at least `requiredRelayCount` relays\n   * @example\n   * ```typescript\n   * const relaySet = new NDKRelaySet(new Set([relay1, relay2]), ndk);\n   * const publishedToRelays = await relaySet.publish(event);\n   * // publishedToRelays can contain relay1, relay2, both, or none\n   * // depending on which relays the event was successfully published to\n   * if (publishedToRelays.size > 0) {\n   *   console.log(\"Event published to at least one relay\");\n   * }\n   * ```\n   */\n  async publish(event, timeoutMs, requiredRelayCount = 1) {\n    const publishedToRelays = /* @__PURE__ */ new Set();\n    const errors = /* @__PURE__ */ new Map();\n    const isEphemeral2 = event.isEphemeral();\n    event.publishStatus = \"pending\";\n    const relayPublishedHandler = (relay) => {\n      publishedToRelays.add(relay);\n    };\n    event.on(\"relay:published\", relayPublishedHandler);\n    try {\n      const promises = Array.from(this.relays).map((relay) => {\n        return new Promise((resolve) => {\n          const timeoutId = timeoutMs ? setTimeout(() => {\n            if (!publishedToRelays.has(relay)) {\n              errors.set(relay, new Error(`Publish timeout after ${timeoutMs}ms`));\n              resolve(false);\n            }\n          }, timeoutMs) : null;\n          relay.publish(event, timeoutMs).then((success) => {\n            if (timeoutId) clearTimeout(timeoutId);\n            if (success) {\n              publishedToRelays.add(relay);\n              resolve(true);\n            } else {\n              resolve(false);\n            }\n          }).catch((err) => {\n            if (timeoutId) clearTimeout(timeoutId);\n            if (!isEphemeral2) {\n              errors.set(relay, err);\n            }\n            resolve(false);\n          });\n        });\n      });\n      await Promise.all(promises);\n      if (publishedToRelays.size < requiredRelayCount) {\n        if (!isEphemeral2) {\n          const error = new NDKPublishError(\n            \"Not enough relays received the event\",\n            errors,\n            publishedToRelays,\n            this\n          );\n          event.publishStatus = \"error\";\n          event.publishError = error;\n          this.ndk?.emit(\"event:publish-failed\", event, error, this.relayUrls);\n          throw error;\n        }\n      } else {\n        event.publishStatus = \"success\";\n        event.emit(\"published\", { relaySet: this, publishedToRelays });\n      }\n      return publishedToRelays;\n    } finally {\n      event.off(\"relay:published\", relayPublishedHandler);\n    }\n  }\n  get size() {\n    return this.relays.size;\n  }\n};\n\n// src/relay/sets/calculate.ts\nvar d = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:outbox:calculate\");\nasync function calculateRelaySetFromEvent(ndk, event) {\n  const relays = /* @__PURE__ */ new Set();\n  const authorWriteRelays = await getWriteRelaysFor(ndk, event.pubkey);\n  if (authorWriteRelays) {\n    authorWriteRelays.forEach((relayUrl) => {\n      const relay = ndk.pool?.getRelay(relayUrl);\n      if (relay) relays.add(relay);\n    });\n  }\n  let relayHints = event.tags.filter((tag) => [\"a\", \"e\"].includes(tag[0])).map((tag) => tag[2]).filter((url) => url?.startsWith(\"wss://\")).filter((url) => {\n    try {\n      new URL(url);\n      return true;\n    } catch {\n      return false;\n    }\n  }).map((url) => normalizeRelayUrl(url));\n  relayHints = Array.from(new Set(relayHints)).slice(0, 5);\n  relayHints.forEach((relayUrl) => {\n    const relay = ndk.pool?.getRelay(relayUrl, true, true);\n    if (relay) {\n      d(\"Adding relay hint %s\", relayUrl);\n      relays.add(relay);\n    }\n  });\n  const pTags = event.getMatchingTags(\"p\").map((tag) => tag[1]);\n  if (pTags.length < 5) {\n    const pTaggedRelays = Array.from(\n      chooseRelayCombinationForPubkeys(ndk, pTags, \"read\", {\n        preferredRelays: new Set(authorWriteRelays)\n      }).keys()\n    );\n    pTaggedRelays.forEach((relayUrl) => {\n      const relay = ndk.pool?.getRelay(relayUrl, false, true);\n      if (relay) {\n        d(\"Adding p-tagged relay %s\", relayUrl);\n        relays.add(relay);\n      }\n    });\n  } else {\n    d(\"Too many p-tags to consider %d\", pTags.length);\n  }\n  ndk.pool?.permanentAndConnectedRelays().forEach((relay) => relays.add(relay));\n  return new NDKRelaySet(relays, ndk);\n}\nfunction calculateRelaySetsFromFilter(ndk, filters, pool) {\n  const result = /* @__PURE__ */ new Map();\n  const authors = /* @__PURE__ */ new Set();\n  filters.forEach((filter) => {\n    if (filter.authors) {\n      filter.authors.forEach((author) => authors.add(author));\n    }\n  });\n  if (authors.size > 0) {\n    const authorToRelaysMap = getRelaysForFilterWithAuthors(ndk, Array.from(authors));\n    for (const relayUrl of authorToRelaysMap.keys()) {\n      result.set(relayUrl, []);\n    }\n    for (const filter of filters) {\n      if (filter.authors) {\n        for (const [relayUrl, authors2] of authorToRelaysMap.entries()) {\n          const authorFilterAndRelayPubkeyIntersection = filter.authors.filter(\n            (author) => authors2.includes(author)\n          );\n          result.set(relayUrl, [\n            ...result.get(relayUrl),\n            {\n              ...filter,\n              // Overwrite authors sent to this relay with the authors that were\n              // present in the filter and are also present in the relay\n              authors: authorFilterAndRelayPubkeyIntersection\n            }\n          ]);\n        }\n      } else {\n        for (const relayUrl of authorToRelaysMap.keys()) {\n          result.set(relayUrl, [...result.get(relayUrl), filter]);\n        }\n      }\n    }\n  } else {\n    if (ndk.explicitRelayUrls) {\n      ndk.explicitRelayUrls.forEach((relayUrl) => {\n        result.set(relayUrl, filters);\n      });\n    }\n  }\n  if (result.size === 0) {\n    pool.permanentAndConnectedRelays().slice(0, 5).forEach((relay) => {\n      result.set(relay.url, filters);\n    });\n  }\n  return result;\n}\nfunction calculateRelaySetsFromFilters(ndk, filters, pool) {\n  const a = calculateRelaySetsFromFilter(ndk, filters, pool);\n  return a;\n}\n\n// src/events/content-tagger.ts\n\nfunction mergeTags(tags1, tags2) {\n  const tagMap = /* @__PURE__ */ new Map();\n  const generateKey = (tag) => tag.join(\",\");\n  const isContained = (smaller, larger) => {\n    return smaller.every((value, index) => value === larger[index]);\n  };\n  const processTag = (tag) => {\n    for (const [key, existingTag] of tagMap) {\n      if (isContained(existingTag, tag) || isContained(tag, existingTag)) {\n        if (tag.length >= existingTag.length) {\n          tagMap.set(key, tag);\n        }\n        return;\n      }\n    }\n    tagMap.set(generateKey(tag), tag);\n  };\n  tags1.concat(tags2).forEach(processTag);\n  return Array.from(tagMap.values());\n}\nfunction uniqueTag(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  const sameLength = aLength === bLength;\n  if (sameLength) {\n    if (a.every((v, i) => v === b[i])) {\n      return [a];\n    }\n    return [a, b];\n  }\n  if (aLength > bLength && a.every((v, i) => v === b[i])) {\n    return [a];\n  }\n  if (bLength > aLength && b.every((v, i) => v === a[i])) {\n    return [b];\n  }\n  return [a, b];\n}\nvar hashtagRegex = /(?<=\\s|^)(#[^\\s!@#$%^&*()=+./,[{\\]};:'\"?><]+)/g;\nfunction generateHashtags(content) {\n  const hashtags = content.match(hashtagRegex);\n  const tagIds = /* @__PURE__ */ new Set();\n  const tag = /* @__PURE__ */ new Set();\n  if (hashtags) {\n    for (const hashtag of hashtags) {\n      if (tagIds.has(hashtag.slice(1))) continue;\n      tag.add(hashtag.slice(1));\n      tagIds.add(hashtag.slice(1));\n    }\n  }\n  return Array.from(tag);\n}\nasync function generateContentTags(content, tags = []) {\n  const tagRegex = /(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g;\n  const promises = [];\n  const addTagIfNew = (t) => {\n    if (!tags.find((t2) => [\"q\", t[0]].includes(t2[0]) && t2[1] === t[1])) {\n      tags.push(t);\n    }\n  };\n  content = content.replace(tagRegex, (tag) => {\n    try {\n      const entity = tag.split(/(@|nostr:)/)[2];\n      const { type, data } = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(entity);\n      let t;\n      switch (type) {\n        case \"npub\":\n          t = [\"p\", data];\n          break;\n        case \"nprofile\":\n          t = [\"p\", data.pubkey];\n          break;\n        case \"note\":\n          promises.push(\n            new Promise(async (resolve) => {\n              addTagIfNew([\"q\", data, await maybeGetEventRelayUrl(entity)]);\n              resolve();\n            })\n          );\n          break;\n        case \"nevent\":\n          promises.push(\n            new Promise(async (resolve) => {\n              const { id, author } = data;\n              let { relays } = data;\n              if (!relays || relays.length === 0) {\n                relays = [await maybeGetEventRelayUrl(entity)];\n              }\n              addTagIfNew([\"q\", id, relays[0]]);\n              if (author) addTagIfNew([\"p\", author]);\n              resolve();\n            })\n          );\n          break;\n        case \"naddr\":\n          promises.push(\n            new Promise(async (resolve) => {\n              const id = [data.kind, data.pubkey, data.identifier].join(\":\");\n              let relays = data.relays ?? [];\n              if (relays.length === 0) {\n                relays = [await maybeGetEventRelayUrl(entity)];\n              }\n              addTagIfNew([\"q\", id, relays[0]]);\n              addTagIfNew([\"p\", data.pubkey]);\n              resolve();\n            })\n          );\n          break;\n        default:\n          return tag;\n      }\n      if (t) addTagIfNew(t);\n      return `nostr:${entity}`;\n    } catch (_error) {\n      return tag;\n    }\n  });\n  await Promise.all(promises);\n  const newTags = generateHashtags(content).map((hashtag) => [\"t\", hashtag]);\n  tags = mergeTags(tags, newTags);\n  return { content, tags };\n}\nasync function maybeGetEventRelayUrl(_nip19Id) {\n  return \"\";\n}\n\n// src/events/encryption.ts\nasync function encrypt(recipient, signer, scheme = \"nip44\") {\n  let encrypted;\n  if (!this.ndk) throw new Error(\"No NDK instance found!\");\n  let currentSigner = signer;\n  if (!currentSigner) {\n    this.ndk.assertSigner();\n    currentSigner = this.ndk.signer;\n  }\n  if (!currentSigner) throw new Error(\"no NDK signer\");\n  const currentRecipient = recipient || (() => {\n    const pTags = this.getMatchingTags(\"p\");\n    if (pTags.length !== 1) {\n      throw new Error(\"No recipient could be determined and no explicit recipient was provided\");\n    }\n    return this.ndk.getUser({ pubkey: pTags[0][1] });\n  })();\n  if (scheme === \"nip44\" && await isEncryptionEnabled(currentSigner, \"nip44\")) {\n    encrypted = await currentSigner.encrypt(currentRecipient, this.content, \"nip44\");\n  }\n  if ((!encrypted || scheme === \"nip04\") && await isEncryptionEnabled(currentSigner, \"nip04\")) {\n    encrypted = await currentSigner.encrypt(currentRecipient, this.content, \"nip04\");\n  }\n  if (!encrypted) throw new Error(\"Failed to encrypt event.\");\n  this.content = encrypted;\n}\nasync function decrypt(sender, signer, scheme) {\n  if (this.ndk?.cacheAdapter?.getDecryptedEvent) {\n    let cachedEvent = null;\n    if (typeof this.ndk.cacheAdapter.getDecryptedEvent === \"function\") {\n      cachedEvent = this.ndk.cacheAdapter.getDecryptedEvent(this.id);\n    }\n    if (cachedEvent) {\n      this.content = cachedEvent.content;\n      return;\n    }\n  }\n  let decrypted;\n  if (!this.ndk) throw new Error(\"No NDK instance found!\");\n  let currentSigner = signer;\n  if (!currentSigner) {\n    this.ndk.assertSigner();\n    currentSigner = this.ndk.signer;\n  }\n  if (!currentSigner) throw new Error(\"no NDK signer\");\n  const currentSender = sender || this.author;\n  if (!currentSender) throw new Error(\"No sender provided and no author available\");\n  const currentScheme = scheme || (this.content.match(/\\\\?iv=/) ? \"nip04\" : \"nip44\");\n  if ((currentScheme === \"nip04\" || this.kind === 4) && await isEncryptionEnabled(currentSigner, \"nip04\") && this.content.search(\"\\\\?iv=\")) {\n    decrypted = await currentSigner.decrypt(currentSender, this.content, \"nip04\");\n  }\n  if (!decrypted && currentScheme === \"nip44\" && await isEncryptionEnabled(currentSigner, \"nip44\")) {\n    decrypted = await currentSigner.decrypt(currentSender, this.content, \"nip44\");\n  }\n  if (!decrypted) throw new Error(\"Failed to decrypt event.\");\n  this.content = decrypted;\n  if (this.ndk?.cacheAdapter?.addDecryptedEvent) {\n    this.ndk.cacheAdapter.addDecryptedEvent(this);\n  }\n}\nasync function isEncryptionEnabled(signer, scheme) {\n  if (!signer.encryptionEnabled) return false;\n  if (!scheme) return true;\n  return Boolean(await signer.encryptionEnabled(scheme));\n}\n\n// src/thread/index.ts\nfunction eventsBySameAuthor(op, events) {\n  const eventsByAuthor = /* @__PURE__ */ new Map();\n  eventsByAuthor.set(op.id, op);\n  events.forEach((event) => {\n    if (event.pubkey === op.pubkey) {\n      eventsByAuthor.set(event.id, event);\n    }\n  });\n  return eventsByAuthor;\n}\nvar hasMarkers = (event, tagType) => {\n  return event.getMatchingTags(tagType).some((tag) => tag[3] && tag[3] !== \"\");\n};\nfunction eventIsReply(op, event, threadIds = /* @__PURE__ */ new Set(), tagType) {\n  tagType ??= op.tagType();\n  const tags = event.getMatchingTags(tagType);\n  threadIds.add(op.tagId());\n  if (threadIds.has(event.tagId())) return false;\n  const heedExplicitReplyMarker = () => {\n    let eventIsTagged = false;\n    for (const tag of tags) {\n      if (tag[3] === \"reply\") return threadIds.has(tag[1]);\n      const markerIsEmpty = tag[3] === \"\" || tag[3] === void 0;\n      const markerIsRoot = tag[3] === \"root\";\n      if (tag[1] === op.tagId() && (markerIsEmpty || markerIsRoot)) {\n        eventIsTagged = markerIsRoot ? \"root\" : true;\n      }\n    }\n    if (!eventIsTagged) return false;\n    if (eventIsTagged === \"root\") return true;\n  };\n  const explicitReplyMarker = heedExplicitReplyMarker();\n  if (explicitReplyMarker !== void 0) return explicitReplyMarker;\n  if (hasMarkers(event, tagType)) return false;\n  const expectedTags = op.getMatchingTags(\"e\").map((tag) => tag[1]);\n  expectedTags.push(op.id);\n  return event.getMatchingTags(\"e\").every((tag) => expectedTags.includes(tag[1]));\n}\nfunction eventThreads(op, events) {\n  const eventsByAuthor = eventsBySameAuthor(op, events);\n  const threadEvents = events.filter((event) => eventIsPartOfThread(op, event, eventsByAuthor));\n  return threadEvents.sort((a, b) => a.created_at - b.created_at);\n}\nfunction getEventReplyId(event) {\n  const replyTag = getReplyTag(event);\n  if (replyTag) return replyTag[1];\n  const rootTag = getRootTag(event);\n  if (rootTag) return rootTag[1];\n}\nfunction isEventOriginalPost(event) {\n  return getEventReplyId(event) === void 0;\n}\nfunction eventThreadIds(op, events) {\n  const threadIds = /* @__PURE__ */ new Map();\n  const threadEvents = eventThreads(op, events);\n  threadEvents.forEach((event) => threadIds.set(event.id, event));\n  return threadIds;\n}\nfunction eventReplies(op, events, threadEventIds) {\n  threadEventIds ??= new Set(eventThreadIds(op, events).keys());\n  return events.filter((event) => eventIsReply(op, event, threadEventIds));\n}\nfunction eventIsPartOfThread(op, event, eventsByAuthor) {\n  if (op.pubkey !== event.pubkey) return false;\n  const taggedEventIds = event.getMatchingTags(\"e\").map((tag) => tag[1]);\n  const allTaggedEventsAreByOriginalAuthor = taggedEventIds.every((id) => eventsByAuthor.has(id));\n  return allTaggedEventsAreByOriginalAuthor;\n}\nfunction eventHasETagMarkers(event) {\n  for (const tag of event.tags) {\n    if (tag[0] === \"e\" && (tag[3] ?? \"\").length > 0) return true;\n  }\n  return false;\n}\nfunction getRootEventId(event, searchTag) {\n  searchTag ??= event.tagType();\n  const rootEventTag = getRootTag(event, searchTag);\n  if (rootEventTag) return rootEventTag[1];\n  const replyTag = getReplyTag(event, searchTag);\n  return replyTag?.[1];\n}\nfunction getRootTag(event, searchTag) {\n  searchTag ??= event.tagType();\n  const rootEventTag = event.tags.find(isTagRootTag);\n  if (!rootEventTag) {\n    if (eventHasETagMarkers(event)) return;\n    const matchingTags = event.getMatchingTags(searchTag);\n    if (matchingTags.length < 3) return matchingTags[0];\n  }\n  return rootEventTag;\n}\nvar nip22RootTags = /* @__PURE__ */ new Set([\"A\", \"E\", \"I\"]);\nvar nip22ReplyTags = /* @__PURE__ */ new Set([\"a\", \"e\", \"i\"]);\nfunction getReplyTag(event, searchTag) {\n  if (event.kind === 1111 /* GenericReply */) {\n    let replyTag2;\n    for (const tag of event.tags) {\n      if (nip22RootTags.has(tag[0])) replyTag2 = tag;\n      else if (nip22ReplyTags.has(tag[0])) {\n        replyTag2 = tag;\n        break;\n      }\n    }\n    return replyTag2;\n  }\n  searchTag ??= event.tagType();\n  let hasMarkers2 = false;\n  let replyTag;\n  for (const tag of event.tags) {\n    if (tag[0] !== searchTag) continue;\n    if ((tag[3] ?? \"\").length > 0) hasMarkers2 = true;\n    if (hasMarkers2 && tag[3] === \"reply\") return tag;\n    if (hasMarkers2 && tag[3] === \"root\") replyTag = tag;\n    if (!hasMarkers2) replyTag = tag;\n  }\n  return replyTag;\n}\nfunction isTagRootTag(tag) {\n  return tag[0] === \"E\" || tag[3] === \"root\";\n}\n\n// src/events/fetch-tagged-event.ts\nasync function fetchTaggedEvent(tag, marker) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const t = this.getMatchingTags(tag, marker);\n  if (t.length === 0) return void 0;\n  const [_, id, hint] = t[0];\n  let relay = hint !== \"\" ? this.ndk.pool.getRelay(hint) : void 0;\n  const event = await this.ndk.fetchEvent(id, {}, relay);\n  return event;\n}\nasync function fetchRootEvent(subOpts) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const rootTag = getRootTag(this);\n  if (!rootTag) return void 0;\n  return this.ndk.fetchEventFromTag(rootTag, this, subOpts);\n}\nasync function fetchReplyEvent(subOpts) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const replyTag = getReplyTag(this);\n  if (!replyTag) return void 0;\n  return this.ndk.fetchEventFromTag(replyTag, this, subOpts);\n}\n\n// src/events/kind.ts\nfunction isReplaceable() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return [0, 3].includes(this.kind) || this.kind >= 1e4 && this.kind < 2e4 || this.kind >= 3e4 && this.kind < 4e4;\n}\nfunction isEphemeral() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return this.kind >= 2e4 && this.kind < 3e4;\n}\nfunction isParamReplaceable() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return this.kind >= 3e4 && this.kind < 4e4;\n}\n\n// src/events/nip19.ts\n\nvar DEFAULT_RELAY_COUNT = 2;\nfunction encode(maxRelayCount = DEFAULT_RELAY_COUNT) {\n  let relays = [];\n  if (this.onRelays.length > 0) {\n    relays = this.onRelays.map((relay) => relay.url);\n  } else if (this.relay) {\n    relays = [this.relay.url];\n  }\n  if (relays.length > maxRelayCount) {\n    relays = relays.slice(0, maxRelayCount);\n  }\n  if (this.isParamReplaceable()) {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.naddrEncode({\n      kind: this.kind,\n      pubkey: this.pubkey,\n      identifier: this.replaceableDTag(),\n      relays\n    });\n  }\n  if (relays.length > 0) {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.neventEncode({\n      id: this.tagId(),\n      relays,\n      author: this.pubkey\n    });\n  }\n  return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.noteEncode(this.tagId());\n}\n\n// src/events/repost.ts\nasync function repost(publish = true, signer) {\n  if (!signer && publish) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    signer = this.ndk.signer;\n  }\n  const e = new NDKEvent(this.ndk, {\n    kind: getKind(this)\n  });\n  if (!this.isProtected) e.content = JSON.stringify(this.rawEvent());\n  e.tag(this);\n  if (this.kind !== 1 /* Text */) {\n    e.tags.push([\"k\", `${this.kind}`]);\n  }\n  if (signer) await e.sign(signer);\n  if (publish) await e.publish();\n  return e;\n}\nfunction getKind(event) {\n  if (event.kind === 1) {\n    return 6 /* Repost */;\n  }\n  return 16 /* GenericRepost */;\n}\n\n// src/events/serializer.ts\nfunction serialize(includeSig = false, includeId = false) {\n  const payload = [0, this.pubkey, this.created_at, this.kind, this.tags, this.content];\n  if (includeSig) payload.push(this.sig);\n  if (includeId) payload.push(this.id);\n  return JSON.stringify(payload);\n}\nfunction deserialize(serializedEvent) {\n  const eventArray = JSON.parse(serializedEvent);\n  const ret = {\n    pubkey: eventArray[1],\n    created_at: eventArray[2],\n    kind: eventArray[3],\n    tags: eventArray[4],\n    content: eventArray[5]\n  };\n  if (eventArray.length >= 7) {\n    const first = eventArray[6];\n    const second = eventArray[7];\n    if (first && first.length === 128) {\n      ret.sig = first;\n      if (second && second.length === 64) {\n        ret.id = second;\n      }\n    } else if (first && first.length === 64) {\n      ret.id = first;\n      if (second && second.length === 128) {\n        ret.sig = second;\n      }\n    }\n  }\n  return ret;\n}\n\n// src/events/validation.ts\n\n\n\n\n\n// src/events/signature.ts\nvar worker;\nvar processingQueue = {};\nfunction signatureVerificationInit(w) {\n  worker = w;\n  worker.onmessage = (msg) => {\n    const [eventId, result] = msg.data;\n    const record = processingQueue[eventId];\n    if (!record) {\n      console.error(\"No record found for event\", eventId);\n      return;\n    }\n    delete processingQueue[eventId];\n    for (const resolve of record.resolves) {\n      resolve(result);\n    }\n  };\n}\nasync function verifySignatureAsync(event, _persist) {\n  const promise = new Promise((resolve) => {\n    const serialized = event.serialize();\n    let enqueue = false;\n    if (!processingQueue[event.id]) {\n      processingQueue[event.id] = { event, resolves: [] };\n      enqueue = true;\n    }\n    processingQueue[event.id].resolves.push(resolve);\n    if (!enqueue) return;\n    worker?.postMessage({\n      serialized,\n      id: event.id,\n      sig: event.sig,\n      pubkey: event.pubkey\n    });\n  });\n  return promise;\n}\n\n// src/events/validation.ts\nvar PUBKEY_REGEX = /^[a-f0-9]{64}$/;\nfunction validate() {\n  if (typeof this.kind !== \"number\") return false;\n  if (typeof this.content !== \"string\") return false;\n  if (typeof this.created_at !== \"number\") return false;\n  if (typeof this.pubkey !== \"string\") return false;\n  if (!this.pubkey.match(PUBKEY_REGEX)) return false;\n  if (!Array.isArray(this.tags)) return false;\n  for (let i = 0; i < this.tags.length; i++) {\n    const tag = this.tags[i];\n    if (!Array.isArray(tag)) return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\") return false;\n    }\n  }\n  return true;\n}\nvar verifiedSignatures = new typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({\n  maxSize: 1e3,\n  entryExpirationTimeInMS: 6e4\n});\nfunction verifySignature(persist) {\n  if (typeof this.signatureVerified === \"boolean\") return this.signatureVerified;\n  const prevVerification = verifiedSignatures.get(this.id);\n  if (prevVerification !== null) {\n    this.signatureVerified = !!prevVerification;\n    return this.signatureVerified;\n  }\n  try {\n    if (this.ndk?.asyncSigVerification) {\n      verifySignatureAsync(this, persist).then((result) => {\n        if (persist) {\n          this.signatureVerified = result;\n          if (result) verifiedSignatures.set(this.id, this.sig);\n        }\n        if (!result) {\n          this.ndk?.emit(\"event:invalid-sig\", this);\n          verifiedSignatures.set(this.id, false);\n        }\n      });\n    } else {\n      const hash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(new TextEncoder().encode(this.serialize()));\n      const res = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__.schnorr.verify(this.sig, hash, this.pubkey);\n      if (res) verifiedSignatures.set(this.id, this.sig);\n      else verifiedSignatures.set(this.id, false);\n      this.signatureVerified = res;\n      return res;\n    }\n  } catch (_err) {\n    this.signatureVerified = false;\n    return false;\n  }\n}\nfunction getEventHash() {\n  return getEventHashFromSerializedEvent(this.serialize());\n}\nfunction getEventHashFromSerializedEvent(serializedEvent) {\n  const eventHash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(new TextEncoder().encode(serializedEvent));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(eventHash);\n}\n\n// src/events/index.ts\nvar skipClientTagOnKinds = /* @__PURE__ */ new Set([\n  0 /* Metadata */,\n  4 /* EncryptedDirectMessage */,\n  1059 /* GiftWrap */,\n  13 /* GiftWrapSeal */,\n  3 /* Contacts */,\n  9734 /* ZapRequest */,\n  5 /* EventDeletion */\n]);\nvar NDKEvent = class _NDKEvent extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  created_at;\n  content = \"\";\n  tags = [];\n  kind;\n  id = \"\";\n  sig;\n  pubkey = \"\";\n  signatureVerified;\n  _author = void 0;\n  /**\n   * The relay that this event was first received from.\n   */\n  relay;\n  /**\n   * The relays that this event was received from and/or successfully published to.\n   */\n  get onRelays() {\n    let res = [];\n    if (!this.ndk) {\n      if (this.relay) res.push(this.relay);\n    } else {\n      res = this.ndk.subManager.seenEvents.get(this.id) || [];\n    }\n    return res;\n  }\n  /**\n   * The status of the publish operation.\n   */\n  publishStatus = \"success\";\n  publishError;\n  constructor(ndk, event) {\n    super();\n    this.ndk = ndk;\n    this.created_at = event?.created_at;\n    this.content = event?.content || \"\";\n    this.tags = event?.tags || [];\n    this.id = event?.id || \"\";\n    this.sig = event?.sig;\n    this.pubkey = event?.pubkey || \"\";\n    this.kind = event?.kind;\n    if (event instanceof _NDKEvent) {\n      if (this.relay) {\n        this.relay = event.relay;\n        this.ndk?.subManager.seenEvent(event.id, this.relay);\n      }\n      this.publishStatus = event.publishStatus;\n      this.publishError = event.publishError;\n    }\n  }\n  /**\n   * Deserialize an NDKEvent from a serialized payload.\n   * @param ndk\n   * @param event\n   * @returns\n   */\n  static deserialize(ndk, event) {\n    return new _NDKEvent(ndk, deserialize(event));\n  }\n  /**\n   * Returns the event as is.\n   */\n  rawEvent() {\n    return {\n      created_at: this.created_at,\n      content: this.content,\n      tags: this.tags,\n      kind: this.kind,\n      pubkey: this.pubkey,\n      id: this.id,\n      sig: this.sig\n    };\n  }\n  set author(user) {\n    this.pubkey = user.pubkey;\n    this._author = user;\n    this._author.ndk ??= this.ndk;\n  }\n  /**\n   * Returns an NDKUser for the author of the event.\n   */\n  get author() {\n    if (this._author) return this._author;\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const user = this.ndk.getUser({ pubkey: this.pubkey });\n    this._author = user;\n    return user;\n  }\n  /**\n   * NIP-73 tagging of external entities\n   * @param entity to be tagged\n   * @param type of the entity\n   * @param markerUrl to be used as the marker URL\n   *\n   * @example\n   * ```typescript\n   * event.tagExternal(\"https://example.com/article/123#nostr\", \"url\");\n   * event.tags => [[\"i\", \"https://example.com/123\"], [\"k\", \"https://example.com\"]]\n   * ```\n   *\n   * @example tag a podcast:item:guid\n   * ```typescript\n   * event.tagExternal(\"e32b4890-b9ea-4aef-a0bf-54b787833dc5\", \"podcast:item:guid\");\n   * event.tags => [[\"i\", \"podcast:item:guid:e32b4890-b9ea-4aef-a0bf-54b787833dc5\"], [\"k\", \"podcast:item:guid\"]]\n   * ```\n   *\n   * @see https://github.com/nostr-protocol/nips/blob/master/73.md\n   */\n  tagExternal(entity, type, markerUrl) {\n    const iTag = [\"i\"];\n    const kTag = [\"k\"];\n    switch (type) {\n      case \"url\": {\n        const url = new URL(entity);\n        url.hash = \"\";\n        iTag.push(url.toString());\n        kTag.push(`${url.protocol}//${url.host}`);\n        break;\n      }\n      case \"hashtag\":\n        iTag.push(`#${entity.toLowerCase()}`);\n        kTag.push(\"#\");\n        break;\n      case \"geohash\":\n        iTag.push(`geo:${entity.toLowerCase()}`);\n        kTag.push(\"geo\");\n        break;\n      case \"isbn\":\n        iTag.push(`isbn:${entity.replace(/-/g, \"\")}`);\n        kTag.push(\"isbn\");\n        break;\n      case \"podcast:guid\":\n        iTag.push(`podcast:guid:${entity}`);\n        kTag.push(\"podcast:guid\");\n        break;\n      case \"podcast:item:guid\":\n        iTag.push(`podcast:item:guid:${entity}`);\n        kTag.push(\"podcast:item:guid\");\n        break;\n      case \"podcast:publisher:guid\":\n        iTag.push(`podcast:publisher:guid:${entity}`);\n        kTag.push(\"podcast:publisher:guid\");\n        break;\n      case \"isan\":\n        iTag.push(`isan:${entity.split(\"-\").slice(0, 4).join(\"-\")}`);\n        kTag.push(\"isan\");\n        break;\n      case \"doi\":\n        iTag.push(`doi:${entity.toLowerCase()}`);\n        kTag.push(\"doi\");\n        break;\n      default:\n        throw new Error(`Unsupported NIP-73 entity type: ${type}`);\n    }\n    if (markerUrl) {\n      iTag.push(markerUrl);\n    }\n    this.tags.push(iTag);\n    this.tags.push(kTag);\n  }\n  /**\n   * Tag a user with an optional marker.\n   * @param target What is to be tagged. Can be an NDKUser, NDKEvent, or an NDKTag.\n   * @param marker The marker to use in the tag.\n   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event.\n   * @param forceTag Force a specific tag to be used instead of the default \"e\" or \"a\" tag.\n   * @example\n   * ```typescript\n   * reply.tag(opEvent, \"reply\");\n   * // reply.tags => [[\"e\", <id>, <relay>, \"reply\"]]\n   * ```\n   */\n  tag(target, marker, skipAuthorTag, forceTag) {\n    let tags = [];\n    const isNDKUser = target.fetchProfile !== void 0;\n    if (isNDKUser) {\n      forceTag ??= \"p\";\n      const tag = [forceTag, target.pubkey];\n      if (marker) tag.push(...[\"\", marker]);\n      tags.push(tag);\n    } else if (target instanceof _NDKEvent) {\n      const event = target;\n      skipAuthorTag ??= event?.pubkey === this.pubkey;\n      tags = event.referenceTags(marker, skipAuthorTag, forceTag);\n      for (const pTag of event.getMatchingTags(\"p\")) {\n        if (pTag[1] === this.pubkey) continue;\n        if (this.tags.find((t) => t[0] === \"p\" && t[1] === pTag[1])) continue;\n        this.tags.push([\"p\", pTag[1]]);\n      }\n    } else if (Array.isArray(target)) {\n      tags = [target];\n    } else {\n      throw new Error(\"Invalid argument\", target);\n    }\n    this.tags = mergeTags(this.tags, tags);\n  }\n  /**\n   * Return a NostrEvent object, trying to fill in missing fields\n   * when possible, adding tags when necessary.\n   * @param pubkey {string} The pubkey of the user who the event belongs to.\n   * @returns {Promise<NostrEvent>} A promise that resolves to a NostrEvent.\n   */\n  async toNostrEvent(pubkey) {\n    if (!pubkey && this.pubkey === \"\") {\n      const user = await this.ndk?.signer?.user();\n      this.pubkey = user?.pubkey || \"\";\n    }\n    if (!this.created_at) {\n      this.created_at = Math.floor(Date.now() / 1e3);\n    }\n    const { content, tags } = await this.generateTags();\n    this.content = content || \"\";\n    this.tags = tags;\n    try {\n      this.id = this.getEventHash();\n    } catch (_e) {\n    }\n    return this.rawEvent();\n  }\n  serialize = serialize.bind(this);\n  getEventHash = getEventHash.bind(this);\n  validate = validate.bind(this);\n  verifySignature = verifySignature.bind(this);\n  /**\n   * Is this event replaceable (whether parameterized or not)?\n   *\n   * This will return true for kind 0, 3, 10k-20k and 30k-40k\n   */\n  isReplaceable = isReplaceable.bind(this);\n  isEphemeral = isEphemeral.bind(this);\n  isDvm = () => this.kind && this.kind >= 5e3 && this.kind <= 7e3;\n  /**\n   * Is this event parameterized replaceable?\n   *\n   * This will return true for kind 30k-40k\n   */\n  isParamReplaceable = isParamReplaceable.bind(this);\n  /**\n   * Encodes a bech32 id.\n   *\n   * @param relays {string[]} The relays to encode in the id\n   * @returns {string} - Encoded naddr, note or nevent.\n   */\n  encode = encode.bind(this);\n  encrypt = encrypt.bind(this);\n  decrypt = decrypt.bind(this);\n  /**\n   * Get all tags with the given name\n   * @param tagName {string} The name of the tag to search for\n   * @returns {NDKTag[]} An array of the matching tags\n   */\n  getMatchingTags(tagName, marker) {\n    const t = this.tags.filter((tag) => tag[0] === tagName);\n    if (marker === void 0) return t;\n    return t.filter((tag) => tag[3] === marker);\n  }\n  /**\n   * Check if the event has a tag with the given name\n   * @param tagName\n   * @param marker\n   * @returns\n   */\n  hasTag(tagName, marker) {\n    return this.tags.some((tag) => tag[0] === tagName && (!marker || tag[3] === marker));\n  }\n  /**\n   * Get the first tag with the given name\n   * @param tagName Tag name to search for\n   * @returns The value of the first tag with the given name, or undefined if no such tag exists\n   */\n  tagValue(tagName, marker) {\n    const tags = this.getMatchingTags(tagName, marker);\n    if (tags.length === 0) return void 0;\n    return tags[0][1];\n  }\n  /**\n   * Gets the NIP-31 \"alt\" tag of the event.\n   */\n  get alt() {\n    return this.tagValue(\"alt\");\n  }\n  /**\n   * Sets the NIP-31 \"alt\" tag of the event. Use this to set an alt tag so\n   * clients that don't handle a particular event kind can display something\n   * useful for users.\n   */\n  set alt(alt) {\n    this.removeTag(\"alt\");\n    if (alt) this.tags.push([\"alt\", alt]);\n  }\n  /**\n   * Gets the NIP-33 \"d\" tag of the event.\n   */\n  get dTag() {\n    return this.tagValue(\"d\");\n  }\n  /**\n   * Sets the NIP-33 \"d\" tag of the event.\n   */\n  set dTag(value) {\n    this.removeTag(\"d\");\n    if (value) this.tags.push([\"d\", value]);\n  }\n  /**\n   * Remove all tags with the given name (e.g. \"d\", \"a\", \"p\")\n   * @param tagName Tag name(s) to search for and remove\n   * @param marker Optional marker to check for too\n   *\n   * @example\n   * Remove a tags with a \"defer\" marker\n   * ```typescript\n   * event.tags = [\n   *   [\"a\", \"....\", \"defer\"],\n   *   [\"a\", \"....\", \"no-defer\"],\n   * ]\n   *\n   * event.removeTag(\"a\", \"defer\");\n   *\n   * // event.tags => [[\"a\", \"....\", \"no-defer\"]]\n   *\n   * @returns {void}\n   */\n  removeTag(tagName, marker) {\n    const tagNames = Array.isArray(tagName) ? tagName : [tagName];\n    this.tags = this.tags.filter((tag) => {\n      const include = tagNames.includes(tag[0]);\n      const hasMarker = marker ? tag[3] === marker : true;\n      return !(include && hasMarker);\n    });\n  }\n  /**\n   * Replace a tag with a new value. If not found, it will be added.\n   * @param tag The tag to replace.\n   * @param value The new value for the tag.\n   */\n  replaceTag(tag) {\n    this.removeTag(tag[0]);\n    this.tags.push(tag);\n  }\n  /**\n   * Sign the event if a signer is present.\n   *\n   * It will generate tags.\n   * Repleacable events will have their created_at field set to the current time.\n   * @param signer {NDKSigner} The NDKSigner to use to sign the event\n   * @returns {Promise<string>} A Promise that resolves to the signature of the signed event.\n   */\n  async sign(signer) {\n    if (!signer) {\n      this.ndk?.assertSigner();\n      signer = this.ndk?.signer;\n    } else {\n      this.author = await signer.user();\n    }\n    const nostrEvent = await this.toNostrEvent();\n    this.sig = await signer.sign(nostrEvent);\n    return this.sig;\n  }\n  /**\n   *\n   * @param relaySet\n   * @param timeoutMs\n   * @param requiredRelayCount\n   * @returns\n   */\n  async publishReplaceable(relaySet, timeoutMs, requiredRelayCount) {\n    this.id = \"\";\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.sig = \"\";\n    return this.publish(relaySet, timeoutMs, requiredRelayCount);\n  }\n  /**\n   * Attempt to sign and then publish an NDKEvent to a given relaySet.\n   * If no relaySet is provided, the relaySet will be calculated by NDK.\n   * @param relaySet {NDKRelaySet} The relaySet to publish the even to.\n   * @param timeoutM {number} The timeout for the publish operation in milliseconds.\n   * @param requiredRelayCount The number of relays that must receive the event for the publish to be considered successful.\n   * @returns A promise that resolves to the relays the event was published to.\n   */\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    if (!this.sig) await this.sign();\n    if (!this.ndk) throw new Error(\"NDKEvent must be associated with an NDK instance to publish\");\n    if (!relaySet || relaySet.size === 0) {\n      relaySet = this.ndk.devWriteRelaySet || await calculateRelaySetFromEvent(this.ndk, this);\n    }\n    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {\n      const eTags = this.getMatchingTags(\"e\").map((tag) => tag[1]);\n      this.ndk.cacheAdapter.deleteEventIds(eTags);\n    }\n    const rawEvent = this.rawEvent();\n    if (this.ndk.cacheAdapter?.addUnpublishedEvent && shouldTrackUnpublishedEvent(this)) {\n      try {\n        this.ndk.cacheAdapter.addUnpublishedEvent(this, relaySet.relayUrls);\n      } catch (e) {\n        console.error(\"Error adding unpublished event to cache\", e);\n      }\n    }\n    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {\n      this.ndk.cacheAdapter.deleteEventIds(this.getMatchingTags(\"e\").map((tag) => tag[1]));\n    }\n    this.ndk.subManager.dispatchEvent(rawEvent, void 0, true);\n    const relays = await relaySet.publish(this, timeoutMs, requiredRelayCount);\n    relays.forEach((relay) => this.ndk?.subManager.seenEvent(this.id, relay));\n    return relays;\n  }\n  /**\n   * Generates tags for users, notes, and other events tagged in content.\n   * Will also generate random \"d\" tag for parameterized replaceable events where needed.\n   * @returns {ContentTag} The tags and content of the event.\n   */\n  async generateTags() {\n    let tags = [];\n    const g = await generateContentTags(this.content, this.tags);\n    const content = g.content;\n    tags = g.tags;\n    if (this.kind && this.isParamReplaceable()) {\n      const dTag = this.getMatchingTags(\"d\")[0];\n      if (!dTag) {\n        const title = this.tagValue(\"title\");\n        const randLength = title ? 6 : 16;\n        let str = [...Array(randLength)].map(() => Math.random().toString(36)[2]).join(\"\");\n        if (title && title.length > 0) {\n          str = `${title.replace(/[^a-z0-9]+/gi, \"-\").replace(/^-|-$/g, \"\")}-${str}`;\n        }\n        tags.push([\"d\", str]);\n      }\n    }\n    if (this.shouldAddClientTag) {\n      const clientTag = [\"client\", this.ndk?.clientName ?? \"\"];\n      if (this.ndk?.clientNip89) clientTag.push(this.ndk?.clientNip89);\n      tags.push(clientTag);\n    } else if (this.shouldStripClientTag) {\n      tags = tags.filter((tag) => tag[0] !== \"client\");\n    }\n    return { content: content || \"\", tags };\n  }\n  get shouldAddClientTag() {\n    if (!this.ndk?.clientName && !this.ndk?.clientNip89) return false;\n    if (skipClientTagOnKinds.has(this.kind)) return false;\n    if (this.isEphemeral()) return false;\n    if (this.isReplaceable() && !this.isParamReplaceable()) return false;\n    if (this.isDvm()) return false;\n    if (this.hasTag(\"client\")) return false;\n    return true;\n  }\n  get shouldStripClientTag() {\n    return skipClientTagOnKinds.has(this.kind);\n  }\n  muted() {\n    const authorMutedEntry = this.ndk?.mutedIds.get(this.pubkey);\n    if (authorMutedEntry && authorMutedEntry === \"p\") return \"author\";\n    const eventTagReference = this.tagReference();\n    const eventMutedEntry = this.ndk?.mutedIds.get(eventTagReference[1]);\n    if (eventMutedEntry && eventMutedEntry === eventTagReference[0]) return \"event\";\n    return null;\n  }\n  /**\n   * Returns the \"d\" tag of a parameterized replaceable event or throws an error if the event isn't\n   * a parameterized replaceable event.\n   * @returns {string} the \"d\" tag of the event.\n   *\n   * @deprecated Use `dTag` instead.\n   */\n  replaceableDTag() {\n    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {\n      const dTag = this.getMatchingTags(\"d\")[0];\n      const dTagId = dTag ? dTag[1] : \"\";\n      return dTagId;\n    }\n    throw new Error(\"Event is not a parameterized replaceable event\");\n  }\n  /**\n   * Provides a deduplication key for the event.\n   *\n   * For kinds 0, 3, 10k-20k this will be the event <kind>:<pubkey>\n   * For kinds 30k-40k this will be the event <kind>:<pubkey>:<d-tag>\n   * For all other kinds this will be the event id\n   */\n  deduplicationKey() {\n    if (this.kind === 0 || this.kind === 3 || this.kind && this.kind >= 1e4 && this.kind < 2e4) {\n      return `${this.kind}:${this.pubkey}`;\n    }\n    return this.tagId();\n  }\n  /**\n   * Returns the id of the event or, if it's a parameterized event, the generated id of the event using \"d\" tag, pubkey, and kind.\n   * @returns {string} The id\n   */\n  tagId() {\n    if (this.isParamReplaceable()) {\n      return this.tagAddress();\n    }\n    return this.id;\n  }\n  /**\n   * Returns a stable reference value for a replaceable event.\n   *\n   * Param replaceable events are returned in the expected format of `<kind>:<pubkey>:<d-tag>`.\n   * Kind-replaceable events are returned in the format of `<kind>:<pubkey>:`.\n   *\n   * @returns {string} A stable reference value for replaceable events\n   */\n  tagAddress() {\n    if (this.isParamReplaceable()) {\n      const dTagId = this.dTag ?? \"\";\n      return `${this.kind}:${this.pubkey}:${dTagId}`;\n    }\n    if (this.isReplaceable()) {\n      return `${this.kind}:${this.pubkey}:`;\n    }\n    throw new Error(\"Event is not a replaceable event\");\n  }\n  /**\n   * Determines the type of tag that can be used to reference this event from another event.\n   * @returns {string} The tag type\n   * @example\n   * event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   * event.tagType(); // \"a\"\n   */\n  tagType() {\n    return this.isParamReplaceable() ? \"a\" : \"e\";\n  }\n  /**\n   * Get the tag that can be used to reference this event from another event.\n   *\n   * Consider using referenceTags() instead (unless you have a good reason to use this)\n   *\n   * @example\n   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *     event.tagReference(); // [\"a\", \"30000:pubkey:d-code\"]\n   *\n   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *     event.tagReference(); // [\"e\", \"eventid\"]\n   * @returns {NDKTag} The NDKTag object referencing this event\n   */\n  tagReference(marker) {\n    let tag;\n    if (this.isParamReplaceable()) {\n      tag = [\"a\", this.tagAddress()];\n    } else {\n      tag = [\"e\", this.tagId()];\n    }\n    if (this.relay) {\n      tag.push(this.relay.url);\n    } else {\n      tag.push(\"\");\n    }\n    tag.push(marker ?? \"\");\n    if (!this.isParamReplaceable()) {\n      tag.push(this.pubkey);\n    }\n    return tag;\n  }\n  /**\n   * Get the tags that can be used to reference this event from another event\n   * @param marker The marker to use in the tag\n   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event\n   * @param forceTag Force a specific tag to be used instead of the default \"e\" or \"a\" tag\n   * @example\n   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *     event.referenceTags(); // [[\"a\", \"30000:pubkey:d-code\"], [\"e\", \"parent-id\"]]\n   *\n   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *     event.referenceTags(); // [[\"e\", \"parent-id\"]]\n   * @returns {NDKTag} The NDKTag object referencing this event\n   */\n  referenceTags(marker, skipAuthorTag, forceTag) {\n    let tags = [];\n    if (this.isParamReplaceable()) {\n      tags = [\n        [forceTag ?? \"a\", this.tagAddress()],\n        [forceTag ?? \"e\", this.id]\n      ];\n    } else {\n      tags = [[forceTag ?? \"e\", this.id]];\n    }\n    tags = tags.map((tag) => {\n      if (tag[0] === \"e\" || marker) {\n        tag.push(this.relay?.url ?? \"\");\n      } else if (this.relay?.url) {\n        tag.push(this.relay?.url);\n      }\n      return tag;\n    });\n    tags.forEach((tag) => {\n      if (tag[0] === \"e\") {\n        tag.push(marker ?? \"\");\n        tag.push(this.pubkey);\n      } else if (marker) {\n        tag.push(marker);\n      }\n    });\n    tags = [...tags, ...this.getMatchingTags(\"h\")];\n    if (!skipAuthorTag) tags.push(...this.author.referenceTags());\n    return tags;\n  }\n  /**\n   * Provides the filter that will return matching events for this event.\n   *\n   * @example\n   *    event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *    event.filter(); // { \"#a\": [\"30000:pubkey:d-code\"] }\n   * @example\n   *    event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *    event.filter(); // { \"#e\": [\"eventid\"] }\n   *\n   * @returns The filter that will return matching events for this event\n   */\n  filter() {\n    if (this.isParamReplaceable()) {\n      return { \"#a\": [this.tagId()] };\n    }\n    return { \"#e\": [this.tagId()] };\n  }\n  nip22Filter() {\n    if (this.isParamReplaceable()) {\n      return { \"#A\": [this.tagId()] };\n    }\n    return { \"#E\": [this.tagId()] };\n  }\n  /**\n   * Generates a deletion event of the current event\n   *\n   * @param reason The reason for the deletion\n   * @param publish Whether to publish the deletion event automatically\n   * @returns The deletion event\n   */\n  async delete(reason, publish = true) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const e = new _NDKEvent(this.ndk, {\n      kind: 5 /* EventDeletion */,\n      content: reason || \"\"\n    });\n    e.tag(this, void 0, true);\n    e.tags.push([\"k\", this.kind?.toString()]);\n    if (publish) {\n      this.emit(\"deleted\");\n      await e.publish();\n    }\n    return e;\n  }\n  /**\n   * Establishes whether this is a NIP-70-protectede event.\n   * @@satisfies NIP-70\n   */\n  set isProtected(val) {\n    this.removeTag(\"-\");\n    if (val) this.tags.push([\"-\"]);\n  }\n  /**\n   * Whether this is a NIP-70-protected event.\n   * @@satisfies NIP-70\n   */\n  get isProtected() {\n    return this.hasTag(\"-\");\n  }\n  /**\n   * Fetch an event tagged with the given tag following relay hints if provided.\n   * @param tag The tag to search for\n   * @param marker The marker to use in the tag (e.g. \"root\")\n   * @returns The fetched event or null if no event was found, undefined if no matching tag was found in the event\n   * * @example\n   * const replyEvent = await ndk.fetchEvent(\"nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd\")\n   * const originalEvent = await replyEvent.fetchTaggedEvent(\"e\", \"reply\");\n   * console.log(replyEvent.encode() + \" is a reply to event \" + originalEvent?.encode());\n   */\n  fetchTaggedEvent = fetchTaggedEvent.bind(this);\n  /**\n   * Fetch the root event of the current event.\n   * @returns The fetched root event or null if no event was found\n   * @example\n   * const replyEvent = await ndk.fetchEvent(\"nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd\")\n   * const rootEvent = await replyEvent.fetchRootEvent();\n   * console.log(replyEvent.encode() + \" is a reply in the thread \" + rootEvent?.encode());\n   */\n  fetchRootEvent = fetchRootEvent.bind(this);\n  /**\n   * Fetch the event the current event is replying to.\n   * @returns The fetched reply event or null if no event was found\n   */\n  fetchReplyEvent = fetchReplyEvent.bind(this);\n  /**\n   * NIP-18 reposting event.\n   *\n   * @param publish Whether to publish the reposted event automatically @default true\n   * @param signer The signer to use for signing the reposted event\n   * @returns The reposted event\n   *\n   * @function\n   */\n  repost = repost.bind(this);\n  /**\n   * React to an existing event\n   *\n   * @param content The content of the reaction\n   */\n  async react(content, publish = true) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const e = new _NDKEvent(this.ndk, {\n      kind: 7 /* Reaction */,\n      content\n    });\n    e.tag(this);\n    if (publish) await e.publish();\n    return e;\n  }\n  /**\n   * Checks whether the event is valid per underlying NIPs.\n   *\n   * This method is meant to be overridden by subclasses that implement specific NIPs\n   * to allow the enforcement of NIP-specific validation rules.\n   *\n   * Otherwise, it will only check for basic event properties.\n   *\n   */\n  get isValid() {\n    return this.validate();\n  }\n  get inspect() {\n    return JSON.stringify(this.rawEvent(), null, 4);\n  }\n  /**\n   * Dump the event to console for debugging purposes.\n   * Prints a JSON stringified version of rawEvent() with indentation\n   * and also lists all relay URLs for onRelays.\n   */\n  dump() {\n    console.debug(JSON.stringify(this.rawEvent(), null, 4));\n    console.debug(\"Event on relays:\", this.onRelays.map((relay) => relay.url).join(\", \"));\n  }\n  /**\n   * Creates a reply event for the current event.\n   *\n   * This function will use NIP-22 when appropriate (i.e. replies to non-kind:1 events).\n   * This function does not have side-effects; it will just return an event with the appropriate tags\n   * to generate the reply event; the caller is responsible for publishing the event.\n   */\n  reply() {\n    const reply = new _NDKEvent(this.ndk);\n    if (this.kind === 1) {\n      reply.kind = 1;\n      const opHasETag = this.hasTag(\"e\");\n      if (opHasETag) {\n        reply.tags = [\n          ...reply.tags,\n          ...this.getMatchingTags(\"e\"),\n          ...this.getMatchingTags(\"p\"),\n          ...this.getMatchingTags(\"a\"),\n          ...this.referenceTags(\"reply\")\n        ];\n      } else {\n        reply.tag(this, \"root\");\n      }\n    } else {\n      reply.kind = 1111 /* GenericReply */;\n      const carryOverTags = [\"A\", \"E\", \"I\", \"P\"];\n      const rootTags = this.tags.filter((tag) => carryOverTags.includes(tag[0]));\n      if (rootTags.length > 0) {\n        const rootKind = this.tagValue(\"K\");\n        reply.tags.push(...rootTags);\n        if (rootKind) reply.tags.push([\"K\", rootKind]);\n        const [type, id, _, ...extra] = this.tagReference();\n        const tag = [type, id, ...extra];\n        reply.tags.push(tag);\n      } else {\n        const [type, id, _, relayHint] = this.tagReference();\n        const tag = [type, id, relayHint ?? \"\"];\n        if (type === \"e\") tag.push(this.pubkey);\n        reply.tags.push(tag);\n        const uppercaseTag = [...tag];\n        uppercaseTag[0] = uppercaseTag[0].toUpperCase();\n        reply.tags.push(uppercaseTag);\n        reply.tags.push([\"K\", this.kind?.toString()]);\n        reply.tags.push([\"P\", this.pubkey]);\n      }\n      reply.tags.push([\"k\", this.kind?.toString()]);\n      reply.tags.push(...this.getMatchingTags(\"p\"));\n      reply.tags.push([\"p\", this.pubkey]);\n    }\n    return reply;\n  }\n};\nvar untrackedUnpublishedEvents = /* @__PURE__ */ new Set([\n  24133 /* NostrConnect */,\n  13194 /* NostrWaletConnectInfo */,\n  23194 /* NostrWalletConnectReq */,\n  23195 /* NostrWalletConnectRes */\n]);\nfunction shouldTrackUnpublishedEvent(event) {\n  return !untrackedUnpublishedEvents.has(event.kind);\n}\n\n// src/relay/pool/index.ts\n\nvar NDKPool = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  // TODO: This should probably be an LRU cache\n  _relays = /* @__PURE__ */ new Map();\n  status = \"idle\";\n  autoConnectRelays = /* @__PURE__ */ new Set();\n  poolBlacklistRelayUrls = /* @__PURE__ */ new Set();\n  debug;\n  temporaryRelayTimers = /* @__PURE__ */ new Map();\n  flappingRelays = /* @__PURE__ */ new Set();\n  // A map to store timeouts for each flapping relay.\n  backoffTimes = /* @__PURE__ */ new Map();\n  ndk;\n  get blacklistRelayUrls() {\n    const val = new Set(this.ndk.blacklistRelayUrls);\n    this.poolBlacklistRelayUrls.forEach((url) => val.add(url));\n    return val;\n  }\n  /**\n   * @param relayUrls - The URLs of the relays to connect to.\n   * @param blacklistedRelayUrls - URLs to blacklist for this pool IN ADDITION to those blacklisted at the ndk-level\n   * @param ndk - The NDK instance.\n   * @param opts - Options for the pool.\n   */\n  constructor(relayUrls, blacklistedRelayUrls, ndk, {\n    debug: debug8,\n    name\n  } = {}) {\n    super();\n    this.debug = debug8 ?? ndk.debug.extend(\"pool\");\n    if (name) this._name = name;\n    this.ndk = ndk;\n    this.relayUrls = relayUrls;\n    this.poolBlacklistRelayUrls = new Set(blacklistedRelayUrls);\n    this.ndk.pools.push(this);\n  }\n  get relays() {\n    return this._relays;\n  }\n  set relayUrls(urls) {\n    this._relays.clear();\n    for (const relayUrl of urls) {\n      const relay = new NDKRelay(relayUrl, void 0, this.ndk);\n      relay.connectivity.netDebug = this.ndk.netDebug;\n      this.addRelay(relay);\n    }\n  }\n  _name = \"unnamed\";\n  get name() {\n    return this._name;\n  }\n  set name(name) {\n    this._name = name;\n    this.debug = this.debug.extend(name);\n  }\n  /**\n   * Adds a relay to the pool, and sets a timer to remove it if it is not used within the specified time.\n   * @param relay - The relay to add to the pool.\n   * @param removeIfUnusedAfter - The time in milliseconds to wait before removing the relay from the pool after it is no longer used.\n   */\n  useTemporaryRelay(relay, removeIfUnusedAfter = 3e4, filters) {\n    const relayAlreadyInPool = this.relays.has(relay.url);\n    if (!relayAlreadyInPool) {\n      this.addRelay(relay);\n      this.debug(\"Adding temporary relay %s for filters %o\", relay.url, filters);\n    }\n    const existingTimer = this.temporaryRelayTimers.get(relay.url);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n    }\n    if (!relayAlreadyInPool || existingTimer) {\n      const timer = setTimeout(() => {\n        if (this.ndk.explicitRelayUrls?.includes(relay.url)) return;\n        this.removeRelay(relay.url);\n      }, removeIfUnusedAfter);\n      this.temporaryRelayTimers.set(relay.url, timer);\n    }\n  }\n  /**\n   * Adds a relay to the pool.\n   *\n   * @param relay - The relay to add to the pool.\n   * @param connect - Whether or not to connect to the relay.\n   */\n  addRelay(relay, connect = true) {\n    const isAlreadyInPool = this.relays.has(relay.url);\n    const isBlacklisted = this.blacklistRelayUrls?.has(relay.url);\n    const isCustomRelayUrl = relay.url.includes(\"/npub1\");\n    let reconnect = true;\n    const relayUrl = relay.url;\n    if (isAlreadyInPool) return;\n    if (isBlacklisted) {\n      this.debug(`Refusing to add relay ${relayUrl}: blacklisted`);\n      return;\n    }\n    if (isCustomRelayUrl) {\n      this.debug(`Refusing to add relay ${relayUrl}: is a filter relay`);\n      return;\n    }\n    if (this.ndk.cacheAdapter?.getRelayStatus) {\n      const info = this.ndk.cacheAdapter.getRelayStatus(relayUrl);\n      if (info?.dontConnectBefore) {\n        if (info.dontConnectBefore > Date.now()) {\n          const delay = info.dontConnectBefore - Date.now();\n          this.debug(`Refusing to add relay ${relayUrl}: delayed connect for ${delay}ms`);\n          setTimeout(() => {\n            this.addRelay(relay, connect);\n          }, delay);\n          return;\n        }\n        reconnect = false;\n      }\n    }\n    const noticeHandler = (notice) => this.emit(\"notice\", relay, notice);\n    const connectHandler = () => this.handleRelayConnect(relayUrl);\n    const readyHandler = () => this.handleRelayReady(relay);\n    const disconnectHandler = () => this.emit(\"relay:disconnect\", relay);\n    const flappingHandler = () => this.handleFlapping(relay);\n    const authHandler = (challenge) => this.emit(\"relay:auth\", relay, challenge);\n    const authedHandler = () => this.emit(\"relay:authed\", relay);\n    relay.off(\"notice\", noticeHandler);\n    relay.off(\"connect\", connectHandler);\n    relay.off(\"ready\", readyHandler);\n    relay.off(\"disconnect\", disconnectHandler);\n    relay.off(\"flapping\", flappingHandler);\n    relay.off(\"auth\", authHandler);\n    relay.off(\"authed\", authedHandler);\n    relay.on(\"notice\", noticeHandler);\n    relay.on(\"connect\", connectHandler);\n    relay.on(\"ready\", readyHandler);\n    relay.on(\"disconnect\", disconnectHandler);\n    relay.on(\"flapping\", flappingHandler);\n    relay.on(\"auth\", authHandler);\n    relay.on(\"authed\", authedHandler);\n    relay.on(\"delayed-connect\", (delay) => {\n      if (this.ndk.cacheAdapter?.updateRelayStatus) {\n        this.ndk.cacheAdapter.updateRelayStatus(relay.url, {\n          dontConnectBefore: Date.now() + delay\n        });\n      }\n    });\n    this._relays.set(relayUrl, relay);\n    if (connect) this.autoConnectRelays.add(relayUrl);\n    if (connect && this.status === \"active\") {\n      this.emit(\"relay:connecting\", relay);\n      relay.connect(void 0, reconnect).catch((e) => {\n        this.debug(`Failed to connect to relay ${relayUrl}`, e);\n      });\n    }\n  }\n  /**\n   * Removes a relay from the pool.\n   * @param relayUrl - The URL of the relay to remove.\n   * @returns {boolean} True if the relay was removed, false if it was not found.\n   */\n  removeRelay(relayUrl) {\n    const relay = this.relays.get(relayUrl);\n    if (relay) {\n      relay.disconnect();\n      this.relays.delete(relayUrl);\n      this.autoConnectRelays.delete(relayUrl);\n      this.emit(\"relay:disconnect\", relay);\n      return true;\n    }\n    const existingTimer = this.temporaryRelayTimers.get(relayUrl);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n      this.temporaryRelayTimers.delete(relayUrl);\n    }\n    return false;\n  }\n  /**\n   * Checks whether a relay is already connected in the pool.\n   */\n  isRelayConnected(url) {\n    const normalizedUrl = normalizeRelayUrl(url);\n    const relay = this.relays.get(normalizedUrl);\n    if (!relay) return false;\n    return relay.status === 5 /* CONNECTED */;\n  }\n  /**\n   * Fetches a relay from the pool, or creates a new one if it does not exist.\n   *\n   * New relays will be attempted to be connected.\n   */\n  getRelay(url, connect = true, temporary = false, filters) {\n    let relay = this.relays.get(normalizeRelayUrl(url));\n    if (!relay) {\n      relay = new NDKRelay(url, void 0, this.ndk);\n      relay.connectivity.netDebug = this.ndk.netDebug;\n      if (temporary) {\n        this.useTemporaryRelay(relay, 3e4, filters);\n      } else {\n        this.addRelay(relay, connect);\n      }\n    }\n    return relay;\n  }\n  handleRelayConnect(relayUrl) {\n    const relay = this.relays.get(relayUrl);\n    if (!relay) {\n      console.error(\"NDK BUG: relay not found in pool\", { relayUrl });\n      return;\n    }\n    this.emit(\"relay:connect\", relay);\n    if (this.stats().connected === this.relays.size) {\n      this.emit(\"connect\");\n    }\n  }\n  handleRelayReady(relay) {\n    this.emit(\"relay:ready\", relay);\n  }\n  /**\n   * Attempts to establish a connection to each relay in the pool.\n   *\n   * @async\n   * @param {number} [timeoutMs] - Optional timeout in milliseconds for each connection attempt.\n   * @returns {Promise<void>} A promise that resolves when all connection attempts have completed.\n   * @throws {Error} If any of the connection attempts result in an error or timeout.\n   */\n  async connect(timeoutMs) {\n    const promises = [];\n    this.status = \"active\";\n    this.debug(`Connecting to ${this.relays.size} relays${timeoutMs ? `, timeout ${timeoutMs}...` : \"\"}`);\n    const relaysToConnect = new Set(this.autoConnectRelays.keys());\n    for (const relayUrl of relaysToConnect) {\n      const relay = this.relays.get(relayUrl);\n      if (!relay) {\n        continue;\n      }\n      const connectPromise = new Promise((resolve, reject) => {\n        this.emit(\"relay:connecting\", relay);\n        return relay.connect(timeoutMs).then(resolve).catch(reject);\n      });\n      if (timeoutMs) {\n        const timeoutPromise = new Promise((_, reject) => {\n          setTimeout(() => reject(`Timed out after ${timeoutMs}ms`), timeoutMs);\n        });\n        promises.push(\n          Promise.race([connectPromise, timeoutPromise]).catch((e) => {\n            this.debug(`Failed to connect to relay ${relay.url}: ${e ?? \"No reason specified\"}`);\n          })\n        );\n      } else {\n        promises.push(connectPromise);\n      }\n    }\n    const maybeEmitConnect = () => {\n      const allConnected = this.stats().connected === this.relays.size;\n      const someConnected = this.stats().connected > 0;\n      if (!allConnected && someConnected) {\n        this.emit(\"connect\");\n      }\n    };\n    if (timeoutMs) setTimeout(maybeEmitConnect, timeoutMs);\n    await Promise.all(promises);\n    maybeEmitConnect();\n  }\n  checkOnFlappingRelays() {\n    const flappingRelaysCount = this.flappingRelays.size;\n    const totalRelays = this.relays.size;\n    if (flappingRelaysCount / totalRelays >= 0.8) {\n      for (const relayUrl of this.flappingRelays) {\n        this.backoffTimes.set(relayUrl, 0);\n      }\n    }\n  }\n  handleFlapping(relay) {\n    this.debug(`Relay ${relay.url} is flapping`);\n    let currentBackoff = this.backoffTimes.get(relay.url) || 5e3;\n    currentBackoff = currentBackoff * 2;\n    this.backoffTimes.set(relay.url, currentBackoff);\n    this.debug(`Backoff time for ${relay.url} is ${currentBackoff}ms`);\n    setTimeout(() => {\n      this.debug(`Attempting to reconnect to ${relay.url}`);\n      this.emit(\"relay:connecting\", relay);\n      relay.connect();\n      this.checkOnFlappingRelays();\n    }, currentBackoff);\n    relay.disconnect();\n    this.emit(\"flapping\", relay);\n  }\n  size() {\n    return this.relays.size;\n  }\n  /**\n   * Returns the status of each relay in the pool.\n   * @returns {NDKPoolStats} An object containing the number of relays in each status.\n   */\n  stats() {\n    const stats = {\n      total: 0,\n      connected: 0,\n      disconnected: 0,\n      connecting: 0\n    };\n    for (const relay of this.relays.values()) {\n      stats.total++;\n      if (relay.status === 5 /* CONNECTED */) {\n        stats.connected++;\n      } else if (relay.status === 1 /* DISCONNECTED */) {\n        stats.disconnected++;\n      } else if (relay.status === 4 /* CONNECTING */) {\n        stats.connecting++;\n      }\n    }\n    return stats;\n  }\n  connectedRelays() {\n    return Array.from(this.relays.values()).filter((relay) => relay.status >= 5 /* CONNECTED */);\n  }\n  permanentAndConnectedRelays() {\n    return Array.from(this.relays.values()).filter(\n      (relay) => relay.status >= 5 /* CONNECTED */ && !this.temporaryRelayTimers.has(relay.url)\n    );\n  }\n  /**\n   * Get a list of all relay urls in the pool.\n   */\n  urls() {\n    return Array.from(this.relays.keys());\n  }\n};\n\n// src/user/index.ts\n\n\n// src/events/kinds/nutzap/mint-list.ts\nvar NDKCashuMintList = class _NDKCashuMintList extends NDKEvent {\n  static kind = 10019 /* CashuMintList */;\n  static kinds = [10019 /* CashuMintList */];\n  _p2pk;\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 10019 /* CashuMintList */;\n  }\n  static from(event) {\n    return new _NDKCashuMintList(event.ndk, event);\n  }\n  set relays(urls) {\n    this.tags = this.tags.filter((t) => t[0] !== \"relay\");\n    for (const url of urls) {\n      this.tags.push([\"relay\", url]);\n    }\n  }\n  get relays() {\n    const r = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"relay\") {\n        r.push(tag[1]);\n      }\n    }\n    return r;\n  }\n  set mints(urls) {\n    this.tags = this.tags.filter((t) => t[0] !== \"mint\");\n    for (const url of urls) {\n      this.tags.push([\"mint\", url]);\n    }\n  }\n  get mints() {\n    const r = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"mint\") {\n        r.push(tag[1]);\n      }\n    }\n    return Array.from(new Set(r));\n  }\n  get p2pk() {\n    if (this._p2pk) {\n      return this._p2pk;\n    }\n    this._p2pk = this.tagValue(\"pubkey\") ?? this.pubkey;\n    return this._p2pk;\n  }\n  set p2pk(pubkey) {\n    this._p2pk = pubkey;\n    this.removeTag(\"pubkey\");\n    if (pubkey) {\n      this.tags.push([\"pubkey\", pubkey]);\n    }\n  }\n  get relaySet() {\n    return NDKRelaySet.fromRelayUrls(this.relays, this.ndk);\n  }\n};\n\n// src/subscription/index.ts\n\n\n// src/events/kinds/article.ts\nvar NDKArticle = class _NDKArticle extends NDKEvent {\n  static kind = 30023 /* Article */;\n  static kinds = [30023 /* Article */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30023 /* Article */;\n  }\n  /**\n   * Creates a NDKArticle from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKArticle from.\n   * @returns NDKArticle\n   */\n  static from(event) {\n    return new _NDKArticle(event.ndk, event);\n  }\n  /**\n   * Getter for the article title.\n   *\n   * @returns {string | undefined} - The article title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the article title.\n   *\n   * @param {string | undefined} title - The title to set for the article.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the article image.\n   *\n   * @returns {string | undefined} - The article image if available, otherwise undefined.\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Setter for the article image.\n   *\n   * @param {string | undefined} image - The image to set for the article.\n   */\n  set image(image) {\n    this.removeTag(\"image\");\n    if (image) this.tags.push([\"image\", image]);\n  }\n  get summary() {\n    return this.tagValue(\"summary\");\n  }\n  set summary(summary) {\n    this.removeTag(\"summary\");\n    if (summary) this.tags.push([\"summary\", summary]);\n  }\n  /**\n   * Getter for the article's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      let val = Number.parseInt(tag);\n      if (val > 1e12) {\n        val = Math.floor(val / 1e3);\n      }\n      return val;\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the article's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the article's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Generates content tags for the article.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n  /**\n   * Getter for the article's URL.\n   *\n   * @returns {string | undefined} - The article's URL if available, otherwise undefined.\n   */\n  get url() {\n    return this.tagValue(\"url\");\n  }\n  /**\n   * Setter for the article's URL.\n   *\n   * @param {string | undefined} url - The URL to set for the article.\n   */\n  set url(url) {\n    if (url) {\n      this.tags.push([\"url\", url]);\n    } else {\n      this.removeTag(\"url\");\n    }\n  }\n};\n\n// src/events/kinds/cashu/token.ts\nfunction proofsTotalBalance(proofs) {\n  return proofs.reduce((acc, proof) => {\n    if (proof.amount < 0) {\n      throw new Error(\"proof amount is negative\");\n    }\n    return acc + proof.amount;\n  }, 0);\n}\nvar NDKCashuToken = class _NDKCashuToken extends NDKEvent {\n  _proofs = [];\n  _mint;\n  static kind = 7375 /* CashuToken */;\n  static kinds = [7375 /* CashuToken */];\n  /**\n   * Tokens that this token superseeds\n   */\n  _deletes = [];\n  original;\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7375 /* CashuToken */;\n  }\n  static async from(event) {\n    const token = new _NDKCashuToken(event.ndk, event);\n    token.original = event;\n    try {\n      await token.decrypt();\n    } catch {\n      token.content = token.original.content;\n    }\n    try {\n      const content = JSON.parse(token.content);\n      token.proofs = content.proofs;\n      token.mint = content.mint ?? token.tagValue(\"mint\");\n      token.deletedTokens = content.del ?? [];\n      if (!Array.isArray(token.proofs)) return;\n    } catch (_e) {\n      return;\n    }\n    return token;\n  }\n  get proofs() {\n    return this._proofs;\n  }\n  set proofs(proofs) {\n    const cs = /* @__PURE__ */ new Set();\n    this._proofs = proofs.filter((proof) => {\n      if (cs.has(proof.C)) {\n        console.warn(\"Passed in proofs had duplicates, ignoring\", proof.C);\n        return false;\n      }\n      if (proof.amount < 0) {\n        console.warn(\"Invalid proof with negative amount\", proof);\n        return false;\n      }\n      cs.add(proof.C);\n      return true;\n    }).map(this.cleanProof);\n  }\n  /**\n   * Returns a minimal proof object with only essential properties\n   */\n  cleanProof(proof) {\n    return {\n      id: proof.id,\n      amount: proof.amount,\n      C: proof.C,\n      secret: proof.secret\n    };\n  }\n  async toNostrEvent(pubkey) {\n    if (!this.ndk) throw new Error(\"no ndk\");\n    if (!this.ndk.signer) throw new Error(\"no signer\");\n    const payload = {\n      proofs: this.proofs.map(this.cleanProof),\n      mint: this.mint,\n      del: this.deletedTokens ?? []\n    };\n    this.content = JSON.stringify(payload);\n    const user = await this.ndk.signer.user();\n    await this.encrypt(user, void 0, \"nip44\");\n    return super.toNostrEvent(pubkey);\n  }\n  set mint(mint) {\n    this._mint = mint;\n  }\n  get mint() {\n    return this._mint;\n  }\n  /**\n   * Tokens that were deleted by the creation of this token.\n   */\n  get deletedTokens() {\n    return this._deletes;\n  }\n  /**\n   * Marks tokens that were deleted by the creation of this token.\n   */\n  set deletedTokens(tokenIds) {\n    this._deletes = tokenIds;\n  }\n  get amount() {\n    return proofsTotalBalance(this.proofs);\n  }\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    if (this.original) {\n      return this.original.publish(relaySet, timeoutMs, requiredRelayCount);\n    }\n    return super.publish(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/events/kinds/highlight.ts\n\nvar NDKHighlight = class _NDKHighlight extends NDKEvent {\n  _article;\n  static kind = 9802 /* Highlight */;\n  static kinds = [9802 /* Highlight */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 9802 /* Highlight */;\n  }\n  static from(event) {\n    return new _NDKHighlight(event.ndk, event);\n  }\n  get url() {\n    return this.tagValue(\"r\");\n  }\n  /**\n   * Context tag.\n   */\n  set context(context) {\n    if (context === void 0) {\n      this.tags = this.tags.filter(([tag, _value]) => tag !== \"context\");\n    } else {\n      this.tags = this.tags.filter(([tag, _value]) => tag !== \"context\");\n      this.tags.push([\"context\", context]);\n    }\n  }\n  get context() {\n    return this.tags.find(([tag, _value]) => tag === \"context\")?.[1] ?? void 0;\n  }\n  /**\n   * Will return the article URL or NDKEvent if they have already been\n   * set (it won't attempt to load remote events)\n   */\n  get article() {\n    return this._article;\n  }\n  /**\n   * Article the highlight is coming from.\n   *\n   * @param article Article URL or NDKEvent.\n   */\n  set article(article) {\n    this._article = article;\n    if (typeof article === \"string\") {\n      this.tags.push([\"r\", article]);\n    } else {\n      this.tag(article);\n    }\n  }\n  getArticleTag() {\n    return this.getMatchingTags(\"a\")[0] || this.getMatchingTags(\"e\")[0] || this.getMatchingTags(\"r\")[0];\n  }\n  async getArticle() {\n    if (this._article !== void 0) return this._article;\n    let taggedBech32;\n    const articleTag = this.getArticleTag();\n    if (!articleTag) return void 0;\n    switch (articleTag[0]) {\n      case \"a\": {\n        const [kind, pubkey, identifier] = articleTag[1].split(\":\");\n        taggedBech32 = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.naddrEncode({\n          kind: Number.parseInt(kind),\n          pubkey,\n          identifier\n        });\n        break;\n      }\n      case \"e\":\n        taggedBech32 = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.noteEncode(articleTag[1]);\n        break;\n      case \"r\":\n        this._article = articleTag[1];\n        break;\n    }\n    if (taggedBech32) {\n      let a = await this.ndk?.fetchEvent(taggedBech32);\n      if (a) {\n        if (a.kind === 30023 /* Article */) {\n          a = NDKArticle.from(a);\n        }\n        this._article = a;\n      }\n    }\n    return this._article;\n  }\n};\n\n// src/utils/imeta.ts\nfunction mapImetaTag(tag) {\n  const data = {};\n  if (tag.length === 2) {\n    const parts = tag[1].split(\" \");\n    for (let i = 0; i < parts.length; i += 2) {\n      const key = parts[i];\n      const value = parts[i + 1];\n      if (key === \"fallback\") {\n        if (!data.fallback) data.fallback = [];\n        data.fallback.push(value);\n      } else {\n        data[key] = value;\n      }\n    }\n    return data;\n  }\n  const tags = tag.slice(1);\n  for (const val of tags) {\n    const parts = val.split(\" \");\n    const key = parts[0];\n    const value = parts.slice(1).join(\" \");\n    if (key === \"fallback\") {\n      if (!data.fallback) data.fallback = [];\n      data.fallback.push(value);\n    } else {\n      data[key] = value;\n    }\n  }\n  return data;\n}\nfunction imetaTagToTag(imeta) {\n  const tag = [\"imeta\"];\n  for (const [key, value] of Object.entries(imeta)) {\n    if (Array.isArray(value)) {\n      for (const v of value) {\n        tag.push(`${key} ${v}`);\n      }\n    } else if (value) {\n      tag.push(`${key} ${value}`);\n    }\n  }\n  return tag;\n}\n\n// src/events/kinds/image.ts\nvar NDKImage = class _NDKImage extends NDKEvent {\n  static kind = 20 /* Image */;\n  static kinds = [20 /* Image */];\n  _imetas;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 20 /* Image */;\n  }\n  /**\n   * Creates a NDKImage from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKImage from.\n   * @returns NDKImage\n   */\n  static from(event) {\n    return new _NDKImage(event.ndk, event.rawEvent());\n  }\n  get isValid() {\n    return this.imetas.length > 0;\n  }\n  get imetas() {\n    if (this._imetas) return this._imetas;\n    this._imetas = this.tags.filter((tag) => tag[0] === \"imeta\").map(mapImetaTag).filter((imeta) => !!imeta.url);\n    return this._imetas;\n  }\n  set imetas(tags) {\n    this._imetas = tags;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"imeta\");\n    this.tags.push(...tags.map(imetaTagToTag));\n  }\n};\n\n// src/events/kinds/lists/index.ts\nvar NDKList = class _NDKList extends NDKEvent {\n  _encryptedTags;\n  static kinds = [\n    10063 /* BlossomList */,\n    30001 /* CategorizedBookmarkList */,\n    10004 /* CommunityList */,\n    10050 /* DirectMessageReceiveRelayList */,\n    10030 /* EmojiList */,\n    10015 /* InterestList */,\n    10001 /* PinList */,\n    10002 /* RelayList */,\n    10007 /* SearchRelayList */,\n    10006 /* BlockRelayList */,\n    10003 /* BookmarkList */\n  ];\n  /**\n   * Stores the number of bytes the content was before decryption\n   * to expire the cache when the content changes.\n   */\n  encryptedTagsLength;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30001 /* CategorizedBookmarkList */;\n  }\n  /**\n   * Wrap a NDKEvent into a NDKList\n   */\n  static from(ndkEvent) {\n    return new _NDKList(ndkEvent.ndk, ndkEvent);\n  }\n  /**\n   * Returns the title of the list. Falls back on fetching the name tag value.\n   */\n  get title() {\n    const titleTag = this.tagValue(\"title\") || this.tagValue(\"name\");\n    if (titleTag) return titleTag;\n    if (this.kind === 3 /* Contacts */) {\n      return \"Contacts\";\n    }\n    if (this.kind === 1e4 /* MuteList */) {\n      return \"Mute\";\n    }\n    if (this.kind === 10001 /* PinList */) {\n      return \"Pinned Notes\";\n    }\n    if (this.kind === 10002 /* RelayList */) {\n      return \"Relay Metadata\";\n    }\n    if (this.kind === 10003 /* BookmarkList */) {\n      return \"Bookmarks\";\n    }\n    if (this.kind === 10004 /* CommunityList */) {\n      return \"Communities\";\n    }\n    if (this.kind === 10005 /* PublicChatList */) {\n      return \"Public Chats\";\n    }\n    if (this.kind === 10006 /* BlockRelayList */) {\n      return \"Blocked Relays\";\n    }\n    if (this.kind === 10007 /* SearchRelayList */) {\n      return \"Search Relays\";\n    }\n    if (this.kind === 10050 /* DirectMessageReceiveRelayList */) {\n      return \"Direct Message Receive Relays\";\n    }\n    if (this.kind === 10015 /* InterestList */) {\n      return \"Interests\";\n    }\n    if (this.kind === 10030 /* EmojiList */) {\n      return \"Emojis\";\n    }\n    return this.tagValue(\"d\");\n  }\n  /**\n   * Sets the title of the list.\n   */\n  set title(title) {\n    this.removeTag([\"title\", \"name\"]);\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Returns the name of the list.\n   * @deprecated Please use \"title\" instead.\n   */\n  get name() {\n    return this.title;\n  }\n  /**\n   * Sets the name of the list.\n   * @deprecated Please use \"title\" instead. This method will use the `title` tag instead.\n   */\n  set name(name) {\n    this.title = name;\n  }\n  /**\n   * Returns the description of the list.\n   */\n  get description() {\n    return this.tagValue(\"description\");\n  }\n  /**\n   * Sets the description of the list.\n   */\n  set description(name) {\n    this.removeTag(\"description\");\n    if (name) this.tags.push([\"description\", name]);\n  }\n  /**\n   * Returns the image of the list.\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Sets the image of the list.\n   */\n  set image(name) {\n    this.removeTag(\"image\");\n    if (name) this.tags.push([\"image\", name]);\n  }\n  isEncryptedTagsCacheValid() {\n    return !!(this._encryptedTags && this.encryptedTagsLength === this.content.length);\n  }\n  /**\n   * Returns the decrypted content of the list.\n   */\n  async encryptedTags(useCache = true) {\n    if (useCache && this.isEncryptedTagsCacheValid()) return this._encryptedTags;\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    const user = await this.ndk.signer.user();\n    try {\n      if (this.content.length > 0) {\n        try {\n          const decryptedContent = await this.ndk.signer.decrypt(user, this.content);\n          const a = JSON.parse(decryptedContent);\n          if (a?.[0]) {\n            this.encryptedTagsLength = this.content.length;\n            return this._encryptedTags = a;\n          }\n          this.encryptedTagsLength = this.content.length;\n          return this._encryptedTags = [];\n        } catch (_e) {\n        }\n      }\n    } catch (_e) {\n    }\n    return [];\n  }\n  /**\n   * This method can be overriden to validate that a tag is valid for this list.\n   *\n   * (i.e. the NDKPersonList can validate that items are NDKUser instances)\n   */\n  validateTag(_tagValue) {\n    return true;\n  }\n  getItems(type) {\n    return this.tags.filter((tag) => tag[0] === type);\n  }\n  /**\n   * Returns the unecrypted items in this list.\n   */\n  get items() {\n    return this.tags.filter((t) => {\n      return ![\n        \"d\",\n        \"L\",\n        \"l\",\n        \"title\",\n        \"name\",\n        \"description\",\n        \"published_at\",\n        \"summary\",\n        \"image\",\n        \"thumb\",\n        \"alt\",\n        \"expiration\",\n        \"subject\",\n        \"client\"\n      ].includes(t[0]);\n    });\n  }\n  /**\n   * Adds a new item to the list.\n   * @param relay Relay to add\n   * @param mark Optional mark to add to the item\n   * @param encrypted Whether to encrypt the item\n   * @param position Where to add the item in the list (top or bottom)\n   */\n  async addItem(item, mark = void 0, encrypted = false, position = \"bottom\") {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    let tags;\n    if (item instanceof NDKEvent) {\n      tags = [item.tagReference(mark)];\n    } else if (item instanceof NDKUser) {\n      tags = item.referenceTags();\n    } else if (item instanceof NDKRelay) {\n      tags = item.referenceTags();\n    } else if (Array.isArray(item)) {\n      tags = [item];\n    } else {\n      throw new Error(\"Invalid object type\");\n    }\n    if (mark) tags[0].push(mark);\n    if (encrypted) {\n      const user = await this.ndk.signer.user();\n      const currentList = await this.encryptedTags();\n      if (position === \"top\") currentList.unshift(...tags);\n      else currentList.push(...tags);\n      this._encryptedTags = currentList;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(currentList);\n      await this.encrypt(user);\n    } else {\n      if (position === \"top\") this.tags.unshift(...tags);\n      else this.tags.push(...tags);\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n  }\n  /**\n   * Removes an item from the list from both the encrypted and unencrypted lists.\n   * @param value value of item to remove from the list\n   * @param publish whether to publish the change\n   * @returns\n   */\n  async removeItemByValue(value, publish = true) {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    const index = this.tags.findIndex((tag) => tag[1] === value);\n    if (index >= 0) {\n      this.tags.splice(index, 1);\n    }\n    const user = await this.ndk.signer.user();\n    const encryptedTags = await this.encryptedTags();\n    const encryptedIndex = encryptedTags.findIndex((tag) => tag[1] === value);\n    if (encryptedIndex >= 0) {\n      encryptedTags.splice(encryptedIndex, 1);\n      this._encryptedTags = encryptedTags;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(encryptedTags);\n      await this.encrypt(user);\n    }\n    if (publish) {\n      return this.publishReplaceable();\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n  }\n  /**\n   * Removes an item from the list.\n   *\n   * @param index The index of the item to remove.\n   * @param encrypted Whether to remove from the encrypted list or not.\n   */\n  async removeItem(index, encrypted) {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    if (encrypted) {\n      const user = await this.ndk.signer.user();\n      const currentList = await this.encryptedTags();\n      currentList.splice(index, 1);\n      this._encryptedTags = currentList;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(currentList);\n      await this.encrypt(user);\n    } else {\n      this.tags.splice(index, 1);\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n    return this;\n  }\n  has(item) {\n    return this.items.some((tag) => tag[1] === item);\n  }\n  /**\n   * Creates a filter that will result in fetching\n   * the items of this list\n   * @example\n   * const list = new NDKList(...);\n   * const filters = list.filterForItems();\n   * const events = await ndk.fetchEvents(filters);\n   */\n  filterForItems() {\n    const ids = /* @__PURE__ */ new Set();\n    const nip33Queries = /* @__PURE__ */ new Map();\n    const filters = [];\n    for (const tag of this.items) {\n      if (tag[0] === \"e\" && tag[1]) {\n        ids.add(tag[1]);\n      } else if (tag[0] === \"a\" && tag[1]) {\n        const [kind, pubkey, dTag] = tag[1].split(\":\");\n        if (!kind || !pubkey) continue;\n        const key = `${kind}:${pubkey}`;\n        const item = nip33Queries.get(key) || [];\n        item.push(dTag || \"\");\n        nip33Queries.set(key, item);\n      }\n    }\n    if (ids.size > 0) {\n      filters.push({ ids: Array.from(ids) });\n    }\n    if (nip33Queries.size > 0) {\n      for (const [key, values] of nip33Queries.entries()) {\n        const [kind, pubkey] = key.split(\":\");\n        filters.push({\n          kinds: [Number.parseInt(kind)],\n          authors: [pubkey],\n          \"#d\": values\n        });\n      }\n    }\n    return filters;\n  }\n};\nvar lists_default = NDKList;\n\n// src/events/kinds/nutzap/index.ts\n\nvar NDKNutzap = class _NDKNutzap extends NDKEvent {\n  debug;\n  _proofs = [];\n  static kind = 9321 /* Nutzap */;\n  static kinds = [_NDKNutzap.kind];\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 9321 /* Nutzap */;\n    this.debug = ndk?.debug.extend(\"nutzap\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:nutzap\");\n    if (!this.alt) this.alt = \"This is a nutzap\";\n    try {\n      const proofTags = this.getMatchingTags(\"proof\");\n      if (proofTags.length) {\n        this._proofs = proofTags.map((tag) => JSON.parse(tag[1]));\n      } else {\n        this._proofs = JSON.parse(this.content);\n      }\n    } catch {\n      return;\n    }\n  }\n  static from(event) {\n    const e = new _NDKNutzap(event.ndk, event);\n    if (!e._proofs || !e._proofs.length) return;\n    return e;\n  }\n  set comment(comment) {\n    this.content = comment ?? \"\";\n  }\n  get comment() {\n    const c = this.tagValue(\"comment\");\n    if (c) return c;\n    return this.content;\n  }\n  set proofs(proofs) {\n    this._proofs = proofs;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"proof\");\n    for (const proof of proofs) {\n      this.tags.push([\"proof\", JSON.stringify(proof)]);\n    }\n  }\n  get proofs() {\n    return this._proofs;\n  }\n  get rawP2pk() {\n    const firstProof = this.proofs[0];\n    try {\n      const secret = JSON.parse(firstProof.secret);\n      let payload;\n      if (typeof secret === \"string\") {\n        payload = JSON.parse(secret);\n        this.debug(\"stringified payload\", firstProof.secret);\n      } else if (typeof secret === \"object\") {\n        payload = secret;\n      }\n      if (Array.isArray(payload) && payload[0] === \"P2PK\" && payload.length > 1 && typeof payload[1] === \"object\" && payload[1] !== null) {\n        return payload[1].data;\n      }\n      if (typeof payload === \"object\" && payload !== null && typeof payload[1]?.data === \"string\") {\n        return payload[1].data;\n      }\n    } catch (e) {\n      this.debug(\"error parsing p2pk pubkey\", e, this.proofs[0]);\n    }\n    return void 0;\n  }\n  /**\n   * Gets the p2pk pubkey that is embedded in the first proof.\n   *\n   * Note that this returns a nostr pubkey, not a cashu pubkey (no \"02\" prefix)\n   */\n  get p2pk() {\n    const rawP2pk = this.rawP2pk;\n    if (!rawP2pk) return;\n    return rawP2pk.startsWith(\"02\") ? rawP2pk.slice(2) : rawP2pk;\n  }\n  /**\n   * Get the mint where this nutzap proofs exist\n   */\n  get mint() {\n    return this.tagValue(\"u\");\n  }\n  set mint(value) {\n    this.replaceTag([\"u\", value]);\n  }\n  get unit() {\n    let _unit = this.tagValue(\"unit\") ?? \"sat\";\n    if (_unit?.startsWith(\"msat\")) _unit = \"sat\";\n    return _unit;\n  }\n  set unit(value) {\n    this.removeTag(\"unit\");\n    if (value?.startsWith(\"msat\")) throw new Error(\"msat is not allowed, use sat denomination instead\");\n    if (value) this.tag([\"unit\", value]);\n  }\n  get amount() {\n    const amount = this.proofs.reduce((total, proof) => total + proof.amount, 0);\n    return amount;\n  }\n  sender = this.author;\n  /**\n   * Set the target of the nutzap\n   * @param target The target of the nutzap (a user or an event)\n   */\n  set target(target) {\n    this.tags = this.tags.filter((t) => t[0] !== \"p\");\n    if (target instanceof NDKEvent) {\n      this.tags.push(target.tagReference());\n    }\n  }\n  set recipientPubkey(pubkey) {\n    this.removeTag(\"p\");\n    this.tag([\"p\", pubkey]);\n  }\n  get recipientPubkey() {\n    return this.tagValue(\"p\");\n  }\n  get recipient() {\n    const pubkey = this.recipientPubkey;\n    if (this.ndk) return this.ndk.getUser({ pubkey });\n    return new NDKUser({ pubkey });\n  }\n  async toNostrEvent() {\n    if (this.unit === \"msat\") {\n      this.unit = \"sat\";\n    }\n    this.removeTag(\"amount\");\n    this.tags.push([\"amount\", this.amount.toString()]);\n    const event = await super.toNostrEvent();\n    event.content = this.comment;\n    return event;\n  }\n  /**\n   * Validates that the nutzap conforms to NIP-61\n   */\n  get isValid() {\n    let eTagCount = 0;\n    let pTagCount = 0;\n    let mintTagCount = 0;\n    for (const tag of this.tags) {\n      if (tag[0] === \"e\") eTagCount++;\n      if (tag[0] === \"p\") pTagCount++;\n      if (tag[0] === \"u\") mintTagCount++;\n    }\n    return (\n      // exactly one recipient and mint\n      pTagCount === 1 && mintTagCount === 1 && // must have at most one e tag\n      eTagCount <= 1 && // must have at least one proof\n      this.proofs.length > 0\n    );\n  }\n};\nfunction proofP2pk(proof) {\n  try {\n    const secret = JSON.parse(proof.secret);\n    let payload = {};\n    if (typeof secret === \"string\") {\n      payload = JSON.parse(secret);\n    } else if (typeof secret === \"object\") {\n      payload = secret;\n    }\n    const isP2PKLocked = payload[0] === \"P2PK\" && payload[1]?.data;\n    if (isP2PKLocked) {\n      return payload[1].data;\n    }\n  } catch (e) {\n    console.error(\"error parsing p2pk pubkey\", e, proof);\n  }\n}\nfunction proofP2pkNostr(proof) {\n  const p2pk = proofP2pk(proof);\n  if (!p2pk) return;\n  if (p2pk.startsWith(\"02\") && p2pk.length === 66) return p2pk.slice(2);\n  return p2pk;\n}\nfunction cashuPubkeyToNostrPubkey(cashuPubkey) {\n  if (cashuPubkey.startsWith(\"02\") && cashuPubkey.length === 66) return cashuPubkey.slice(2);\n  return void 0;\n}\n\n// src/events/kinds/simple-group/member-list.ts\nvar NDKSimpleGroupMemberList = class _NDKSimpleGroupMemberList extends NDKEvent {\n  relaySet;\n  memberSet = /* @__PURE__ */ new Set();\n  static kind = 39002 /* GroupMembers */;\n  static kinds = [39002 /* GroupMembers */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 39002 /* GroupMembers */;\n    this.memberSet = new Set(this.members);\n  }\n  static from(event) {\n    return new _NDKSimpleGroupMemberList(event.ndk, event);\n  }\n  get members() {\n    return this.getMatchingTags(\"p\").map((tag) => tag[1]);\n  }\n  hasMember(member) {\n    return this.memberSet.has(member);\n  }\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    relaySet ??= this.relaySet;\n    return super.publishReplaceable(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/events/kinds/simple-group/metadata.ts\nvar NDKSimpleGroupMetadata = class _NDKSimpleGroupMetadata extends NDKEvent {\n  static kind = 39e3 /* GroupMetadata */;\n  static kinds = [39e3 /* GroupMetadata */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 39e3 /* GroupMetadata */;\n  }\n  static from(event) {\n    return new _NDKSimpleGroupMetadata(event.ndk, event);\n  }\n  get name() {\n    return this.tagValue(\"name\");\n  }\n  get picture() {\n    return this.tagValue(\"picture\");\n  }\n  get about() {\n    return this.tagValue(\"about\");\n  }\n  get scope() {\n    if (this.getMatchingTags(\"public\").length > 0) return \"public\";\n    if (this.getMatchingTags(\"public\").length > 0) return \"private\";\n    return void 0;\n  }\n  set scope(scope) {\n    this.removeTag(\"public\");\n    this.removeTag(\"private\");\n    if (scope === \"public\") {\n      this.tags.push([\"public\", \"\"]);\n    } else if (scope === \"private\") {\n      this.tags.push([\"private\", \"\"]);\n    }\n  }\n  get access() {\n    if (this.getMatchingTags(\"open\").length > 0) return \"open\";\n    if (this.getMatchingTags(\"closed\").length > 0) return \"closed\";\n    return void 0;\n  }\n  set access(access) {\n    this.removeTag(\"open\");\n    this.removeTag(\"closed\");\n    if (access === \"open\") {\n      this.tags.push([\"open\", \"\"]);\n    } else if (access === \"closed\") {\n      this.tags.push([\"closed\", \"\"]);\n    }\n  }\n};\n\n// src/events/kinds/story.ts\nvar NDKStoryStickerType = /* @__PURE__ */ ((NDKStoryStickerType2) => {\n  NDKStoryStickerType2[\"Pubkey\"] = \"pubkey\";\n  NDKStoryStickerType2[\"Event\"] = \"event\";\n  NDKStoryStickerType2[\"Prompt\"] = \"prompt\";\n  NDKStoryStickerType2[\"Text\"] = \"text\";\n  NDKStoryStickerType2[\"Countdown\"] = \"countdown\";\n  return NDKStoryStickerType2;\n})(NDKStoryStickerType || {});\nfunction strToPosition(positionStr) {\n  const [x, y] = positionStr.split(\",\").map(Number);\n  return { x, y };\n}\nfunction strToDimension(dimensionStr) {\n  const [width, height] = dimensionStr.split(\"x\").map(Number);\n  return { width, height };\n}\nvar NDKStorySticker = class _NDKStorySticker {\n  static Text = \"text\" /* Text */;\n  static Pubkey = \"pubkey\" /* Pubkey */;\n  static Event = \"event\" /* Event */;\n  static Prompt = \"prompt\" /* Prompt */;\n  static Countdown = \"countdown\" /* Countdown */;\n  type;\n  value;\n  position;\n  dimension;\n  properties;\n  constructor(arg) {\n    if (Array.isArray(arg)) {\n      const tag = arg;\n      if (tag[0] !== \"sticker\" || tag.length < 5) {\n        throw new Error(\"Invalid sticker tag\");\n      }\n      this.type = tag[1];\n      this.value = tag[2];\n      this.position = strToPosition(tag[3]);\n      this.dimension = strToDimension(tag[4]);\n      const props = {};\n      for (let i = 5; i < tag.length; i++) {\n        const [key, ...rest] = tag[i].split(\" \");\n        props[key] = rest.join(\" \");\n      }\n      if (Object.keys(props).length > 0) {\n        this.properties = props;\n      }\n    } else {\n      this.type = arg;\n      this.value = void 0;\n      this.position = { x: 0, y: 0 };\n      this.dimension = { width: 0, height: 0 };\n    }\n  }\n  static fromTag(tag) {\n    try {\n      return new _NDKStorySticker(tag);\n    } catch {\n      return null;\n    }\n  }\n  get style() {\n    return this.properties?.style;\n  }\n  set style(style) {\n    if (style) this.properties = { ...this.properties, style };\n    else delete this.properties?.style;\n  }\n  get rotation() {\n    return this.properties?.rot ? Number.parseFloat(this.properties.rot) : void 0;\n  }\n  set rotation(rotation) {\n    if (rotation !== void 0) {\n      this.properties = { ...this.properties, rot: rotation.toString() };\n    } else {\n      delete this.properties?.rot;\n    }\n  }\n  /**\n   * Checks if the sticker is valid.\n   *\n   * @returns {boolean} - True if the sticker is valid, false otherwise.\n   */\n  get isValid() {\n    return this.hasValidDimensions() && this.hasValidPosition();\n  }\n  hasValidDimensions = () => {\n    return typeof this.dimension.width === \"number\" && typeof this.dimension.height === \"number\" && !Number.isNaN(this.dimension.width) && !Number.isNaN(this.dimension.height);\n  };\n  hasValidPosition = () => {\n    return typeof this.position.x === \"number\" && typeof this.position.y === \"number\" && !Number.isNaN(this.position.x) && !Number.isNaN(this.position.y);\n  };\n  toTag() {\n    if (!this.isValid) {\n      const errors = [\n        !this.hasValidDimensions() ? \"dimensions is invalid\" : void 0,\n        !this.hasValidPosition() ? \"position is invalid\" : void 0\n      ].filter(Boolean);\n      throw new Error(`Invalid sticker: ${errors.join(\", \")}`);\n    }\n    let value;\n    switch (this.type) {\n      case \"event\" /* Event */:\n        value = this.value.tagId();\n        break;\n      case \"pubkey\" /* Pubkey */:\n        value = this.value.pubkey;\n        break;\n      default:\n        value = this.value;\n    }\n    const tag = [\"sticker\", this.type, value, coordinates(this.position), dimension(this.dimension)];\n    if (this.properties) {\n      for (const [key, propValue] of Object.entries(this.properties)) {\n        tag.push(`${key} ${propValue}`);\n      }\n    }\n    return tag;\n  }\n};\nvar NDKStory = class _NDKStory extends NDKEvent {\n  static kind = 23 /* Story */;\n  static kinds = [23 /* Story */];\n  _imeta;\n  _dimensions;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 23 /* Story */;\n    if (rawEvent) {\n      for (const tag of rawEvent.tags) {\n        switch (tag[0]) {\n          case \"imeta\":\n            this._imeta = mapImetaTag(tag);\n            break;\n          case \"dim\":\n            this.dimensions = strToDimension(tag[1]);\n            break;\n        }\n      }\n    }\n  }\n  /**\n   * Creates a NDKStory from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKStory from.\n   * @returns NDKStory\n   */\n  static from(event) {\n    return new _NDKStory(event.ndk, event);\n  }\n  /**\n   * Checks if the story is valid (has exactly one imeta tag).\n   */\n  get isValid() {\n    return !!this.imeta;\n  }\n  /**\n   * Gets the first imeta tag (there should only be one).\n   */\n  get imeta() {\n    return this._imeta;\n  }\n  /**\n   * Sets a single imeta tag, replacing any existing ones.\n   */\n  set imeta(tag) {\n    this._imeta = tag;\n    this.tags = this.tags.filter((t) => t[0] !== \"imeta\");\n    if (tag) {\n      this.tags.push(imetaTagToTag(tag));\n    }\n  }\n  /**\n   * Getter for the story dimensions.\n   *\n   * @returns {NDKStoryDimension | undefined} - The story dimensions if available, otherwise undefined.\n   */\n  get dimensions() {\n    const dimTag = this.tagValue(\"dim\");\n    if (!dimTag) return void 0;\n    return strToDimension(dimTag);\n  }\n  /**\n   * Setter for the story dimensions.\n   *\n   * @param {NDKStoryDimension | undefined} dimensions - The dimensions to set for the story.\n   */\n  set dimensions(dimensions) {\n    this.removeTag(\"dim\");\n    if (dimensions) {\n      this.tags.push([\"dim\", `${dimensions.width}x${dimensions.height}`]);\n    }\n  }\n  /**\n   * Getter for the story duration.\n   *\n   * @returns {number | undefined} - The story duration in seconds if available, otherwise undefined.\n   */\n  get duration() {\n    const durTag = this.tagValue(\"dur\");\n    if (!durTag) return void 0;\n    return Number.parseInt(durTag);\n  }\n  /**\n   * Setter for the story duration.\n   *\n   * @param {number | undefined} duration - The duration in seconds to set for the story.\n   */\n  set duration(duration) {\n    this.removeTag(\"dur\");\n    if (duration !== void 0) {\n      this.tags.push([\"dur\", duration.toString()]);\n    }\n  }\n  /**\n   * Gets all stickers from the story.\n   *\n   * @returns {NDKStorySticker[]} - Array of stickers in the story.\n   */\n  get stickers() {\n    const stickers = [];\n    for (const tag of this.tags) {\n      if (tag[0] !== \"sticker\" || tag.length < 5) continue;\n      const sticker = NDKStorySticker.fromTag(tag);\n      if (sticker) stickers.push(sticker);\n    }\n    return stickers;\n  }\n  /**\n   * Adds a sticker to the story.\n   *\n   * @param {NDKStorySticker|StorySticker} sticker - The sticker to add.\n   */\n  addSticker(sticker) {\n    let stickerToAdd;\n    if (sticker instanceof NDKStorySticker) {\n      stickerToAdd = sticker;\n    } else {\n      const tag = [\n        \"sticker\",\n        sticker.type,\n        typeof sticker.value === \"string\" ? sticker.value : \"\",\n        coordinates(sticker.position),\n        dimension(sticker.dimension)\n      ];\n      if (sticker.properties) {\n        for (const [key, value] of Object.entries(sticker.properties)) {\n          tag.push(`${key} ${value}`);\n        }\n      }\n      stickerToAdd = new NDKStorySticker(tag);\n      stickerToAdd.value = sticker.value;\n    }\n    if (stickerToAdd.type === \"pubkey\" /* Pubkey */) {\n      this.tag(stickerToAdd.value);\n    } else if (stickerToAdd.type === \"event\" /* Event */) {\n      this.tag(stickerToAdd.value);\n    }\n    this.tags.push(stickerToAdd.toTag());\n  }\n  /**\n   * Removes a sticker from the story.\n   *\n   * @param {number} index - The index of the sticker to remove.\n   */\n  removeSticker(index) {\n    const stickers = this.stickers;\n    if (index < 0 || index >= stickers.length) return;\n    let stickerCount = 0;\n    for (let i = 0; i < this.tags.length; i++) {\n      if (this.tags[i][0] === \"sticker\") {\n        if (stickerCount === index) {\n          this.tags.splice(i, 1);\n          break;\n        }\n        stickerCount++;\n      }\n    }\n  }\n};\nvar coordinates = (position) => `${position.x},${position.y}`;\nvar dimension = (dimension2) => `${dimension2.width}x${dimension2.height}`;\n\n// src/events/kinds/subscriptions/amount.ts\nvar possibleIntervalFrequencies = [\n  \"daily\",\n  \"weekly\",\n  \"monthly\",\n  \"quarterly\",\n  \"yearly\"\n];\nfunction calculateTermDurationInSeconds(term) {\n  switch (term) {\n    case \"daily\":\n      return 24 * 60 * 60;\n    case \"weekly\":\n      return 7 * 24 * 60 * 60;\n    case \"monthly\":\n      return 30 * 24 * 60 * 60;\n    case \"quarterly\":\n      return 3 * 30 * 24 * 60 * 60;\n    case \"yearly\":\n      return 365 * 24 * 60 * 60;\n  }\n}\nfunction newAmount(amount, currency, term) {\n  return [\"amount\", amount.toString(), currency, term];\n}\nfunction parseTagToSubscriptionAmount(tag) {\n  const amount = Number.parseInt(tag[1]);\n  if (Number.isNaN(amount) || amount === void 0 || amount === null || amount <= 0) return void 0;\n  const currency = tag[2];\n  if (currency === void 0 || currency === \"\") return void 0;\n  const term = tag[3];\n  if (term === void 0) return void 0;\n  if (!possibleIntervalFrequencies.includes(term)) return void 0;\n  return {\n    amount,\n    currency,\n    term\n  };\n}\n\n// src/events/kinds/subscriptions/tier.ts\nvar NDKSubscriptionTier = class _NDKSubscriptionTier extends NDKArticle {\n  static kind = 37001 /* SubscriptionTier */;\n  static kinds = [37001 /* SubscriptionTier */];\n  constructor(ndk, rawEvent) {\n    const k = rawEvent?.kind ?? 37001 /* SubscriptionTier */;\n    super(ndk, rawEvent);\n    this.kind = k;\n  }\n  /**\n   * Creates a new NDKSubscriptionTier from an event\n   * @param event\n   * @returns NDKSubscriptionTier\n   */\n  static from(event) {\n    return new _NDKSubscriptionTier(event.ndk, event);\n  }\n  /**\n   * Returns perks for this tier\n   */\n  get perks() {\n    return this.getMatchingTags(\"perk\").map((tag) => tag[1]).filter((perk) => perk !== void 0);\n  }\n  /**\n   * Adds a perk to this tier\n   */\n  addPerk(perk) {\n    this.tags.push([\"perk\", perk]);\n  }\n  /**\n   * Returns the amount for this tier\n   */\n  get amounts() {\n    return this.getMatchingTags(\"amount\").map((tag) => parseTagToSubscriptionAmount(tag)).filter((a) => a !== void 0);\n  }\n  /**\n   * Adds an amount to this tier\n   * @param amount Amount in the smallest unit of the currency (e.g. cents, msats)\n   * @param currency Currency code. Use msat for millisatoshis\n   * @param term One of daily, weekly, monthly, quarterly, yearly\n   */\n  addAmount(amount, currency, term) {\n    this.tags.push(newAmount(amount, currency, term));\n  }\n  /**\n   * Sets a relay where content related to this tier can be found\n   * @param relayUrl URL of the relay\n   */\n  set relayUrl(relayUrl) {\n    this.tags.push([\"r\", relayUrl]);\n  }\n  /**\n   * Returns the relay URLs for this tier\n   */\n  get relayUrls() {\n    return this.getMatchingTags(\"r\").map((tag) => tag[1]).filter((relay) => relay !== void 0);\n  }\n  /**\n   * Gets the verifier pubkey for this tier. This is the pubkey that will generate\n   * subscription payment receipts\n   */\n  get verifierPubkey() {\n    return this.tagValue(\"p\");\n  }\n  /**\n   * Sets the verifier pubkey for this tier.\n   */\n  set verifierPubkey(pubkey) {\n    this.removeTag(\"p\");\n    if (pubkey) this.tags.push([\"p\", pubkey]);\n  }\n  /**\n   * Checks if this tier is valid\n   */\n  get isValid() {\n    return this.title !== void 0 && // Must have a title\n    this.amounts.length > 0;\n  }\n};\n\n// src/events/kinds/video.ts\nvar NDKVideo = class _NDKVideo extends NDKEvent {\n  static kind = 21 /* Video */;\n  static kinds = [34235 /* HorizontalVideo */, 34236 /* VerticalVideo */, 22 /* ShortVideo */, 21 /* Video */];\n  _imetas;\n  /**\n   * Creates a NDKArticle from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKArticle from.\n   * @returns NDKArticle\n   */\n  static from(event) {\n    return new _NDKVideo(event.ndk, event.rawEvent());\n  }\n  /**\n   * Getter for the article title.\n   *\n   * @returns {string | undefined} - The article title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the article title.\n   *\n   * @param {string | undefined} title - The title to set for the article.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the article thumbnail.\n   *\n   * @returns {string | undefined} - The article thumbnail if available, otherwise undefined.\n   */\n  get thumbnail() {\n    let thumbnail;\n    if (this.imetas && this.imetas.length > 0) {\n      thumbnail = this.imetas[0].image?.[0];\n    }\n    return thumbnail ?? this.tagValue(\"thumb\");\n  }\n  get imetas() {\n    if (this._imetas) return this._imetas;\n    this._imetas = this.tags.filter((tag) => tag[0] === \"imeta\").map(mapImetaTag);\n    return this._imetas;\n  }\n  set imetas(tags) {\n    this._imetas = tags;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"imeta\");\n    this.tags.push(...tags.map(imetaTagToTag));\n  }\n  get url() {\n    if (this.imetas && this.imetas.length > 0) {\n      return this.imetas[0].url;\n    }\n    return this.tagValue(\"url\");\n  }\n  /**\n   * Getter for the article's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      return Number.parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Generates content tags for the article.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.kind) {\n      if (this.imetas?.[0]?.dim) {\n        const [width, height] = this.imetas[0].dim.split(\"x\");\n        const isPortrait = width && height && Number.parseInt(width) < Number.parseInt(height);\n        const isShort = this.duration && this.duration < 120;\n        if (isShort && isPortrait) this.kind = 22 /* ShortVideo */;\n        else this.kind = 21 /* Video */;\n      }\n    }\n    return super.generateTags();\n  }\n  get duration() {\n    const tag = this.tagValue(\"duration\");\n    if (tag) {\n      return Number.parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the video's duration\n   *\n   * @param {number | undefined} duration - The duration to set for the video (in seconds)\n   */\n  set duration(dur) {\n    this.removeTag(\"duration\");\n    if (dur !== void 0) {\n      this.tags.push([\"duration\", Math.floor(dur).toString()]);\n    }\n  }\n};\n\n// src/events/kinds/wiki.ts\nvar NDKWiki = class _NDKWiki extends NDKArticle {\n  static kind = 30818 /* Wiki */;\n  static kinds = [30818 /* Wiki */];\n  static from(event) {\n    return new _NDKWiki(event.ndk, event.rawEvent());\n  }\n  get isDefered() {\n    return this.hasTag(\"a\", \"defer\");\n  }\n  get deferedId() {\n    return this.tagValue(\"a\", \"defer\");\n  }\n  /**\n   * Defers the author's wiki event to another wiki event.\n   *\n   * Wiki-events can tag other wiki-events with a `defer` marker to indicate that it considers someone else's entry as a \"better\" version of itself. If using a `defer` marker both `a` and `e` tags SHOULD be used.\n   *\n   * @example\n   * myWiki.defer = betterWikiEntryOnTheSameTopic;\n   * myWiki.publishReplaceable()\n   */\n  set defer(deferedTo) {\n    this.removeTag(\"a\", \"defer\");\n    this.tag(deferedTo, \"defer\");\n  }\n};\nvar NDKWikiMergeRequest = class _NDKWikiMergeRequest extends NDKEvent {\n  static kind = 818 /* WikiMergeRequest */;\n  static kinds = [818 /* WikiMergeRequest */];\n  static from(event) {\n    return new _NDKWikiMergeRequest(event.ndk, event.rawEvent());\n  }\n  /**\n   * The target ID (<kind:pubkey:d-tag>) of the wiki event to merge into.\n   */\n  get targetId() {\n    return this.tagValue(\"a\");\n  }\n  /**\n   * Sets the target ID (<kind:pubkey:d-tag>) of the wiki event to merge into.\n   */\n  set target(targetEvent) {\n    this.tags = this.tags.filter((tag) => {\n      if (tag[0] === \"a\") return true;\n      if (tag[0] === \"e\" && tag[3] !== \"source\") return true;\n    });\n    this.tag(targetEvent);\n  }\n  /**\n   * The source ID of the wiki event to merge from.\n   */\n  get sourceId() {\n    return this.tagValue(\"e\", \"source\");\n  }\n  /**\n   * Sets the event we are asking to get merged into the target.\n   */\n  set source(sourceEvent) {\n    this.removeTag(\"e\", \"source\");\n    this.tag(sourceEvent, \"source\", false, \"e\");\n  }\n};\n\n// src/events/wrap.ts\nfunction wrapEvent(event) {\n  const eventWrappingMap = /* @__PURE__ */ new Map();\n  for (const klass2 of [\n    NDKImage,\n    NDKVideo,\n    NDKCashuMintList,\n    NDKArticle,\n    NDKHighlight,\n    NDKWiki,\n    NDKNutzap,\n    NDKSimpleGroupMemberList,\n    NDKSimpleGroupMetadata,\n    NDKSubscriptionTier,\n    NDKCashuToken,\n    NDKList,\n    NDKStory\n  ]) {\n    for (const kind of klass2.kinds) {\n      eventWrappingMap.set(kind, klass2);\n    }\n  }\n  const klass = eventWrappingMap.get(event.kind);\n  if (klass) return klass.from(event);\n  return event;\n}\n\n// src/subscription/utils.ts\n\nvar MAX_SUBID_LENGTH = 20;\nfunction queryFullyFilled(subscription) {\n  if (filterIncludesIds(subscription.filter)) {\n    if (resultHasAllRequestedIds(subscription)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction compareFilter(filter1, filter2) {\n  if (Object.keys(filter1).length !== Object.keys(filter2).length) return false;\n  for (const [key, value] of Object.entries(filter1)) {\n    const valuesInFilter2 = filter2[key];\n    if (!valuesInFilter2) return false;\n    if (Array.isArray(value) && Array.isArray(valuesInFilter2)) {\n      const v = value;\n      for (const valueInFilter2 of valuesInFilter2) {\n        const val = valueInFilter2;\n        if (!v.includes(val)) {\n          return false;\n        }\n      }\n    } else {\n      if (valuesInFilter2 !== value) return false;\n    }\n  }\n  return true;\n}\nfunction filterIncludesIds(filter) {\n  return !!filter.ids;\n}\nfunction resultHasAllRequestedIds(subscription) {\n  const ids = subscription.filter.ids;\n  return !!ids && ids.length === subscription.eventFirstSeen.size;\n}\nfunction generateSubId(subscriptions, filters) {\n  const subIds = subscriptions.map((sub) => sub.subId).filter(Boolean);\n  const subIdParts = [];\n  const filterNonKindKeys = /* @__PURE__ */ new Set();\n  const filterKinds = /* @__PURE__ */ new Set();\n  if (subIds.length > 0) {\n    subIdParts.push(Array.from(new Set(subIds)).join(\",\"));\n  } else {\n    for (const filter of filters) {\n      for (const key of Object.keys(filter)) {\n        if (key === \"kinds\") {\n          filter.kinds?.forEach((k) => filterKinds.add(k));\n        } else {\n          filterNonKindKeys.add(key);\n        }\n      }\n    }\n    if (filterKinds.size > 0) {\n      subIdParts.push(`kinds:${Array.from(filterKinds).join(\",\")}`);\n    }\n    if (filterNonKindKeys.size > 0) {\n      subIdParts.push(Array.from(filterNonKindKeys).join(\",\"));\n    }\n  }\n  let subId = subIdParts.join(\"-\");\n  if (subId.length > MAX_SUBID_LENGTH) subId = subId.substring(0, MAX_SUBID_LENGTH);\n  subId += `-${Math.floor(Math.random() * 999).toString()}`;\n  return subId;\n}\nfunction filterForEventsTaggingId(id) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(id);\n    switch (decoded.type) {\n      case \"naddr\":\n        return {\n          \"#a\": [`${decoded.data.kind}:${decoded.data.pubkey}:${decoded.data.identifier}`]\n        };\n      case \"nevent\":\n        return { \"#e\": [decoded.data.id] };\n      case \"note\":\n        return { \"#e\": [decoded.data] };\n      case \"nprofile\":\n        return { \"#p\": [decoded.data.pubkey] };\n      case \"npub\":\n        return { \"#p\": [decoded.data] };\n    }\n  } catch {\n  }\n}\nfunction filterAndRelaySetFromBech32(beche2, ndk) {\n  const filter = filterFromId(beche2);\n  const relays = relaysFromBech32(beche2, ndk);\n  if (relays.length === 0) return { filter };\n  return {\n    filter,\n    relaySet: new NDKRelaySet(new Set(relays), ndk)\n  };\n}\nfunction filterFromId(id) {\n  let decoded;\n  if (id.match(NIP33_A_REGEX)) {\n    const [kind, pubkey, identifier] = id.split(\":\");\n    const filter = {\n      authors: [pubkey],\n      kinds: [Number.parseInt(kind)]\n    };\n    if (identifier) {\n      filter[\"#d\"] = [identifier];\n    }\n    return filter;\n  }\n  if (id.match(BECH32_REGEX)) {\n    try {\n      decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(id);\n      switch (decoded.type) {\n        case \"nevent\": {\n          const filter = { ids: [decoded.data.id] };\n          if (decoded.data.author) filter.authors = [decoded.data.author];\n          if (decoded.data.kind) filter.kinds = [decoded.data.kind];\n          return filter;\n        }\n        case \"note\":\n          return { ids: [decoded.data] };\n        case \"naddr\": {\n          const filter = {\n            authors: [decoded.data.pubkey],\n            kinds: [decoded.data.kind]\n          };\n          if (decoded.data.identifier) filter[\"#d\"] = [decoded.data.identifier];\n          return filter;\n        }\n      }\n    } catch (e) {\n      console.error(\"Error decoding\", id, e);\n    }\n  }\n  return { ids: [id] };\n}\nfunction isNip33AValue(value) {\n  return value.match(NIP33_A_REGEX) !== null;\n}\nvar NIP33_A_REGEX = /^(\\d+):([0-9A-Fa-f]+)(?::(.*))?$/;\nvar BECH32_REGEX = /^n(event|ote|profile|pub|addr)1[\\d\\w]+$/;\nfunction relaysFromBech32(bech322, ndk) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(bech322);\n    if ([\"naddr\", \"nevent\"].includes(decoded?.type)) {\n      const data = decoded.data;\n      if (data?.relays) {\n        return data.relays.map((r) => new NDKRelay(r, ndk.relayAuthDefaultPolicy, ndk));\n      }\n    }\n  } catch (_e) {\n  }\n  return [];\n}\n\n// src/subscription/index.ts\nvar NDKSubscriptionCacheUsage = /* @__PURE__ */ ((NDKSubscriptionCacheUsage2) => {\n  NDKSubscriptionCacheUsage2[\"ONLY_CACHE\"] = \"ONLY_CACHE\";\n  NDKSubscriptionCacheUsage2[\"CACHE_FIRST\"] = \"CACHE_FIRST\";\n  NDKSubscriptionCacheUsage2[\"PARALLEL\"] = \"PARALLEL\";\n  NDKSubscriptionCacheUsage2[\"ONLY_RELAY\"] = \"ONLY_RELAY\";\n  return NDKSubscriptionCacheUsage2;\n})(NDKSubscriptionCacheUsage || {});\nvar defaultOpts = {\n  closeOnEose: false,\n  cacheUsage: \"CACHE_FIRST\" /* CACHE_FIRST */,\n  dontSaveToCache: false,\n  groupable: true,\n  groupableDelay: 100,\n  groupableDelayType: \"at-most\",\n  cacheUnconstrainFilter: [\"limit\", \"since\", \"until\"]\n};\nvar NDKSubscription = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  subId;\n  filters;\n  opts;\n  pool;\n  skipVerification = false;\n  skipValidation = false;\n  /**\n   * Tracks the filters as they are executed on each relay\n   */\n  relayFilters;\n  relaySet;\n  ndk;\n  debug;\n  /**\n   * Events that have been seen by the subscription, with the time they were first seen.\n   */\n  eventFirstSeen = /* @__PURE__ */ new Map();\n  /**\n   * Relays that have sent an EOSE.\n   */\n  eosesSeen = /* @__PURE__ */ new Set();\n  /**\n   * The time the last event was received by the subscription.\n   * This is used to calculate when EOSE should be emitted.\n   */\n  lastEventReceivedAt;\n  /**\n   * The most recent event timestamp from cache results.\n   * This is used for addSinceFromCache functionality.\n   */\n  mostRecentCacheEventTimestamp;\n  internalId;\n  /**\n   * Whether the subscription should close when all relays have reached the end of the event stream.\n   */\n  closeOnEose;\n  /**\n   * Pool monitor callback\n   */\n  poolMonitor;\n  skipOptimisticPublishEvent = false;\n  /**\n   * Filters to remove when querying the cache.\n   */\n  cacheUnconstrainFilter;\n  constructor(ndk, filters, opts, subId) {\n    super();\n    this.ndk = ndk;\n    this.opts = { ...defaultOpts, ...opts || {} };\n    this.pool = this.opts.pool || ndk.pool;\n    this.filters = Array.isArray(filters) ? filters : [filters];\n    this.subId = subId || this.opts.subId;\n    this.internalId = Math.random().toString(36).substring(7);\n    this.debug = ndk.debug.extend(`subscription[${this.opts.subId ?? this.internalId}]`);\n    if (this.opts.relaySet) {\n      this.relaySet = this.opts.relaySet;\n    } else if (this.opts.relayUrls) {\n      this.relaySet = NDKRelaySet.fromRelayUrls(this.opts.relayUrls, this.ndk);\n    }\n    this.skipVerification = this.opts.skipVerification || false;\n    this.skipValidation = this.opts.skipValidation || false;\n    this.closeOnEose = this.opts.closeOnEose || false;\n    this.skipOptimisticPublishEvent = this.opts.skipOptimisticPublishEvent || false;\n    this.cacheUnconstrainFilter = this.opts.cacheUnconstrainFilter;\n  }\n  /**\n   * Returns the relays that have not yet sent an EOSE.\n   */\n  relaysMissingEose() {\n    if (!this.relayFilters) return [];\n    const relaysMissingEose = Array.from(this.relayFilters?.keys()).filter(\n      (url) => !this.eosesSeen.has(this.pool.getRelay(url, false, false))\n    );\n    return relaysMissingEose;\n  }\n  /**\n   * Provides access to the first filter of the subscription for\n   * backwards compatibility.\n   */\n  get filter() {\n    return this.filters[0];\n  }\n  get groupableDelay() {\n    if (!this.isGroupable()) return void 0;\n    return this.opts?.groupableDelay;\n  }\n  get groupableDelayType() {\n    return this.opts?.groupableDelayType || \"at-most\";\n  }\n  isGroupable() {\n    return this.opts?.groupable || false;\n  }\n  shouldQueryCache() {\n    if (this.opts.addSinceFromCache) return true;\n    if (this.opts?.cacheUsage === \"ONLY_RELAY\" /* ONLY_RELAY */) return false;\n    const hasNonEphemeralKind = this.filters.some((f) => f.kinds?.some((k) => kindIsEphemeral(k)));\n    if (hasNonEphemeralKind) return true;\n    return true;\n  }\n  shouldQueryRelays() {\n    return this.opts?.cacheUsage !== \"ONLY_CACHE\" /* ONLY_CACHE */;\n  }\n  shouldWaitForCache() {\n    if (this.opts.addSinceFromCache) return true;\n    return (\n      // Must want to close on EOSE; subscriptions\n      // that want to receive further updates must\n      // always hit the relay\n      !!this.opts.closeOnEose && // Cache adapter must claim to be fast\n      !!this.ndk.cacheAdapter?.locking && // If explicitly told to run in parallel, then\n      // we should not wait for the cache\n      this.opts.cacheUsage !== \"PARALLEL\" /* PARALLEL */\n    );\n  }\n  /**\n   * Start the subscription. This is the main method that should be called\n   * after creating a subscription.\n   *\n   * @param emitCachedEvents - Whether to emit events coming from a synchronous cache\n   *\n   * When using a synchronous cache, the events will be returned immediately\n   * by this function. If you will use those returned events, you should\n   * set emitCachedEvents to false to prevent seeing them as duplicate events.\n   */\n  start(emitCachedEvents = true) {\n    let cacheResult;\n    const updateStateFromCacheResults = (events) => {\n      if (emitCachedEvents) {\n        for (const event of events) {\n          if (!this.mostRecentCacheEventTimestamp || event.created_at > this.mostRecentCacheEventTimestamp) {\n            this.mostRecentCacheEventTimestamp = event.created_at;\n          }\n          this.eventReceived(event, void 0, true, false);\n        }\n      } else {\n        cacheResult = [];\n        for (const event of events) {\n          if (!this.mostRecentCacheEventTimestamp || event.created_at > this.mostRecentCacheEventTimestamp) {\n            this.mostRecentCacheEventTimestamp = event.created_at;\n          }\n          event.ndk = this.ndk;\n          const e = this.opts.wrap ? wrapEvent(event) : event;\n          if (!e) break;\n          if (e instanceof Promise) {\n            e.then((wrappedEvent) => {\n              this.emitEvent(false, wrappedEvent, void 0, true, false);\n            });\n            break;\n          }\n          this.eventFirstSeen.set(e.id, Date.now());\n          cacheResult.push(e);\n        }\n      }\n    };\n    const loadFromRelays = () => {\n      if (this.shouldQueryRelays()) {\n        this.startWithRelays();\n        this.startPoolMonitor();\n      } else {\n        this.emit(\"eose\", this);\n      }\n    };\n    if (this.shouldQueryCache()) {\n      cacheResult = this.startWithCache();\n      if (cacheResult instanceof Promise) {\n        if (this.shouldWaitForCache()) {\n          cacheResult.then((events) => {\n            updateStateFromCacheResults(events);\n            if (queryFullyFilled(this)) {\n              this.emit(\"eose\", this);\n              return;\n            }\n            loadFromRelays();\n          });\n          return null;\n        }\n        cacheResult.then((events) => {\n          updateStateFromCacheResults(events);\n        });\n        loadFromRelays();\n        return null;\n      }\n      updateStateFromCacheResults(cacheResult);\n      if (queryFullyFilled(this)) {\n        this.emit(\"eose\", this);\n      } else {\n        loadFromRelays();\n      }\n      return cacheResult;\n    }\n    loadFromRelays();\n    return null;\n  }\n  /**\n   * We want to monitor for new relays that are coming online, in case\n   * they should be part of this subscription.\n   */\n  startPoolMonitor() {\n    const _d = this.debug.extend(\"pool-monitor\");\n    this.poolMonitor = (relay) => {\n      if (this.relayFilters?.has(relay.url)) return;\n      const calc = calculateRelaySetsFromFilters(this.ndk, this.filters, this.pool);\n      if (calc.get(relay.url)) {\n        this.relayFilters?.set(relay.url, this.filters);\n        relay.subscribe(this, this.filters);\n      }\n    };\n    this.pool.on(\"relay:connect\", this.poolMonitor);\n  }\n  onStopped;\n  stop() {\n    this.emit(\"close\", this);\n    this.poolMonitor && this.pool.off(\"relay:connect\", this.poolMonitor);\n    this.onStopped?.();\n  }\n  /**\n   * @returns Whether the subscription has an authors filter.\n   */\n  hasAuthorsFilter() {\n    return this.filters.some((f) => f.authors?.length);\n  }\n  startWithCache() {\n    if (this.ndk.cacheAdapter?.query) {\n      return this.ndk.cacheAdapter.query(this);\n    }\n    return [];\n  }\n  /**\n   * Find available relays that should be part of this subscription and execute in them.\n   *\n   * Note that this is executed in addition to using the pool monitor, so even if the relay set\n   * that is computed (i.e. we don't have any relays available), when relays come online, we will\n   * check if we need to execute in them.\n   */\n  startWithRelays() {\n    let filters = this.filters;\n    if (this.opts.addSinceFromCache && this.mostRecentCacheEventTimestamp) {\n      const sinceTimestamp = this.mostRecentCacheEventTimestamp + 1;\n      filters = filters.map((filter) => ({\n        ...filter,\n        since: Math.max(filter.since || 0, sinceTimestamp)\n      }));\n    }\n    if (!this.relaySet || this.relaySet.relays.size === 0) {\n      this.relayFilters = calculateRelaySetsFromFilters(this.ndk, filters, this.pool);\n    } else {\n      this.relayFilters = /* @__PURE__ */ new Map();\n      for (const relay of this.relaySet.relays) {\n        this.relayFilters.set(relay.url, filters);\n      }\n    }\n    for (const [relayUrl, filters2] of this.relayFilters) {\n      const relay = this.pool.getRelay(relayUrl, true, true, filters2);\n      relay.subscribe(this, filters2);\n    }\n  }\n  // EVENT handling\n  /**\n   * Called when an event is received from a relay or the cache\n   * @param event\n   * @param relay\n   * @param fromCache Whether the event was received from the cache\n   * @param optimisticPublish Whether this event is coming from an optimistic publish\n   */\n  eventReceived(event, relay, fromCache = false, optimisticPublish = false) {\n    const eventId = event.id;\n    const eventAlreadySeen = this.eventFirstSeen.has(eventId);\n    let ndkEvent;\n    if (event instanceof NDKEvent) ndkEvent = event;\n    if (!eventAlreadySeen) {\n      ndkEvent ??= new NDKEvent(this.ndk, event);\n      ndkEvent.ndk = this.ndk;\n      ndkEvent.relay = relay;\n      if (!fromCache && !optimisticPublish) {\n        if (!this.skipValidation) {\n          if (!ndkEvent.isValid) {\n            this.debug(\"Event failed validation %s from relay %s\", eventId, relay?.url);\n            return;\n          }\n        }\n        if (relay) {\n          if (relay?.shouldValidateEvent() !== false) {\n            if (!this.skipVerification) {\n              if (!ndkEvent.verifySignature(true) && !this.ndk.asyncSigVerification) {\n                this.debug(\"Event failed signature validation\", event);\n                return;\n              }\n              if (relay) {\n                relay.addValidatedEvent();\n              }\n            }\n          } else {\n            relay.addNonValidatedEvent();\n          }\n        }\n        if (this.ndk.cacheAdapter && !this.opts.dontSaveToCache) {\n          this.ndk.cacheAdapter.setEvent(ndkEvent, this.filters, relay);\n        }\n      }\n      if (!optimisticPublish || this.skipOptimisticPublishEvent !== true) {\n        this.emitEvent(this.opts?.wrap ?? false, ndkEvent, relay, fromCache, optimisticPublish);\n        this.eventFirstSeen.set(eventId, Date.now());\n      }\n    } else {\n      const timeSinceFirstSeen = Date.now() - (this.eventFirstSeen.get(eventId) || 0);\n      this.emit(\"event:dup\", event, relay, timeSinceFirstSeen, this, fromCache, optimisticPublish);\n      if (relay) {\n        const signature = verifiedSignatures.get(eventId);\n        if (signature && typeof signature === \"string\") {\n          if (event.sig === signature) {\n            relay.addValidatedEvent();\n          }\n        }\n      }\n    }\n    this.lastEventReceivedAt = Date.now();\n  }\n  /**\n   * Optionally wraps, sync or async, and emits the event (if one comes back from the wrapper)\n   */\n  emitEvent(wrap, evt, relay, fromCache, optimisticPublish) {\n    const wrapped = wrap ? wrapEvent(evt) : evt;\n    if (wrapped instanceof Promise) {\n      wrapped.then((e) => this.emitEvent(false, e, relay, fromCache, optimisticPublish));\n    } else if (wrapped) {\n      this.emit(\"event\", wrapped, relay, this, fromCache, optimisticPublish);\n    }\n  }\n  closedReceived(relay, reason) {\n    this.emit(\"closed\", relay, reason);\n  }\n  // EOSE handling\n  eoseTimeout;\n  eosed = false;\n  eoseReceived(relay) {\n    this.debug(\"EOSE received from %s\", relay.url);\n    this.eosesSeen.add(relay);\n    let lastEventSeen = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;\n    const hasSeenAllEoses = this.eosesSeen.size === this.relayFilters?.size;\n    const queryFilled = queryFullyFilled(this);\n    const performEose = (reason) => {\n      this.debug(\"Performing EOSE: %s %d\", reason, this.eosed);\n      if (this.eosed) return;\n      if (this.eoseTimeout) clearTimeout(this.eoseTimeout);\n      this.emit(\"eose\", this);\n      this.eosed = true;\n      if (this.opts?.closeOnEose) this.stop();\n    };\n    if (queryFilled || hasSeenAllEoses) {\n      performEose(\"query filled or seen all\");\n    } else if (this.relayFilters) {\n      let timeToWaitForNextEose = 1e3;\n      const connectedRelays = new Set(this.pool.connectedRelays().map((r) => r.url));\n      const connectedRelaysWithFilters = Array.from(this.relayFilters.keys()).filter(\n        (url) => connectedRelays.has(url)\n      );\n      if (connectedRelaysWithFilters.length === 0) {\n        this.debug(\n          \"No connected relays, waiting for all relays to connect\",\n          Array.from(this.relayFilters.keys()).join(\", \")\n        );\n        return;\n      }\n      const percentageOfRelaysThatHaveSentEose = this.eosesSeen.size / connectedRelaysWithFilters.length;\n      this.debug(\"Percentage of relays that have sent EOSE\", {\n        subId: this.subId,\n        percentageOfRelaysThatHaveSentEose,\n        seen: this.eosesSeen.size,\n        total: connectedRelaysWithFilters.length\n      });\n      if (this.eosesSeen.size >= 2 && percentageOfRelaysThatHaveSentEose >= 0.5) {\n        timeToWaitForNextEose = timeToWaitForNextEose * (1 - percentageOfRelaysThatHaveSentEose);\n        if (timeToWaitForNextEose === 0) {\n          performEose(\"time to wait was 0\");\n          return;\n        }\n        if (this.eoseTimeout) clearTimeout(this.eoseTimeout);\n        const sendEoseTimeout = () => {\n          lastEventSeen = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;\n          if (lastEventSeen !== void 0 && lastEventSeen < 20) {\n            this.eoseTimeout = setTimeout(sendEoseTimeout, timeToWaitForNextEose);\n          } else {\n            performEose(`send eose timeout: ${timeToWaitForNextEose}`);\n          }\n        };\n        this.eoseTimeout = setTimeout(sendEoseTimeout, timeToWaitForNextEose);\n      }\n    }\n  }\n};\nvar kindIsEphemeral = (kind) => kind >= 2e4 && kind < 3e4;\n\n// src/user/follows.ts\nasync function follows(opts, outbox, kind = 3 /* Contacts */) {\n  if (!this.ndk) throw new Error(\"NDK not set\");\n  const contactListEvent = await this.ndk.fetchEvent(\n    { kinds: [kind], authors: [this.pubkey] },\n    opts || { groupable: false }\n  );\n  if (contactListEvent) {\n    const pubkeys = /* @__PURE__ */ new Set();\n    contactListEvent.tags.forEach((tag) => {\n      if (tag[0] === \"p\") pubkeys.add(tag[1]);\n    });\n    if (outbox) {\n      this.ndk?.outboxTracker?.trackUsers(Array.from(pubkeys));\n    }\n    return [...pubkeys].reduce((acc, pubkey) => {\n      const user = new NDKUser({ pubkey });\n      user.ndk = this.ndk;\n      acc.add(user);\n      return acc;\n    }, /* @__PURE__ */ new Set());\n  }\n  return /* @__PURE__ */ new Set();\n}\n\n// src/user/nip05.ts\nvar NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w.-]+)$/;\nasync function getNip05For(ndk, fullname, _fetch = fetch, fetchOpts = {}) {\n  return await ndk.queuesNip05.add({\n    id: fullname,\n    func: async () => {\n      if (ndk.cacheAdapter?.loadNip05) {\n        const profile = await ndk.cacheAdapter.loadNip05(fullname);\n        if (profile !== \"missing\") {\n          if (profile) {\n            const user = new NDKUser({\n              pubkey: profile.pubkey,\n              relayUrls: profile.relays,\n              nip46Urls: profile.nip46\n            });\n            user.ndk = ndk;\n            return user;\n          }\n          if (fetchOpts.cache !== \"no-cache\") {\n            return null;\n          }\n        }\n      }\n      const match = fullname.match(NIP05_REGEX);\n      if (!match) return null;\n      const [_, name = \"_\", domain] = match;\n      try {\n        const res = await _fetch(`https://${domain}/.well-known/nostr.json?name=${name}`, fetchOpts);\n        const { names, relays, nip46 } = parseNIP05Result(await res.json());\n        const pubkey = names[name.toLowerCase()];\n        let profile = null;\n        if (pubkey) {\n          profile = { pubkey, relays: relays?.[pubkey], nip46: nip46?.[pubkey] };\n        }\n        if (ndk?.cacheAdapter?.saveNip05) {\n          ndk.cacheAdapter.saveNip05(fullname, profile);\n        }\n        return profile;\n      } catch (_e) {\n        if (ndk?.cacheAdapter?.saveNip05) {\n          ndk?.cacheAdapter.saveNip05(fullname, null);\n        }\n        console.error(\"Failed to fetch NIP05 for\", fullname, _e);\n        return null;\n      }\n    }\n  });\n}\nfunction parseNIP05Result(json) {\n  const result = {\n    names: {}\n  };\n  for (const [name, pubkey] of Object.entries(json.names)) {\n    if (typeof name === \"string\" && typeof pubkey === \"string\") {\n      result.names[name.toLowerCase()] = pubkey;\n    }\n  }\n  if (json.relays) {\n    result.relays = {};\n    for (const [pubkey, relays] of Object.entries(json.relays)) {\n      if (typeof pubkey === \"string\" && Array.isArray(relays)) {\n        result.relays[pubkey] = relays.filter((relay) => typeof relay === \"string\");\n      }\n    }\n  }\n  if (json.nip46) {\n    result.nip46 = {};\n    for (const [pubkey, nip46] of Object.entries(json.nip46)) {\n      if (typeof pubkey === \"string\" && Array.isArray(nip46)) {\n        result.nip46[pubkey] = nip46.filter((relay) => typeof relay === \"string\");\n      }\n    }\n  }\n  return result;\n}\n\n// src/user/profile.ts\nfunction profileFromEvent(event) {\n  const profile = {};\n  let payload;\n  try {\n    payload = JSON.parse(event.content);\n  } catch (error) {\n    throw new Error(`Failed to parse profile event: ${error}`);\n  }\n  profile.profileEvent = JSON.stringify(event.rawEvent());\n  for (const key of Object.keys(payload)) {\n    switch (key) {\n      case \"name\":\n        profile.name = payload.name;\n        break;\n      case \"display_name\":\n        profile.displayName = payload.display_name;\n        break;\n      case \"image\":\n      case \"picture\":\n        profile.picture = payload.picture || payload.image;\n        profile.image = profile.picture;\n        break;\n      case \"banner\":\n        profile.banner = payload.banner;\n        break;\n      case \"bio\":\n        profile.bio = payload.bio;\n        break;\n      case \"nip05\":\n        profile.nip05 = payload.nip05;\n        break;\n      case \"lud06\":\n        profile.lud06 = payload.lud06;\n        break;\n      case \"lud16\":\n        profile.lud16 = payload.lud16;\n        break;\n      case \"about\":\n        profile.about = payload.about;\n        break;\n      case \"website\":\n        profile.website = payload.website;\n        break;\n      default:\n        profile[key] = payload[key];\n        break;\n    }\n  }\n  profile.created_at = event.created_at;\n  return profile;\n}\nfunction serializeProfile(profile) {\n  const payload = {};\n  for (const [key, val] of Object.entries(profile)) {\n    switch (key) {\n      case \"username\":\n      case \"name\":\n        payload.name = val;\n        break;\n      case \"displayName\":\n        payload.display_name = val;\n        break;\n      case \"image\":\n      case \"picture\":\n        payload.picture = val;\n        break;\n      case \"bio\":\n      case \"about\":\n        payload.about = val;\n        break;\n      default:\n        payload[key] = val;\n        break;\n    }\n  }\n  return JSON.stringify(payload);\n}\n\n// src/user/index.ts\nvar NDKUser = class _NDKUser {\n  ndk;\n  profile;\n  profileEvent;\n  _npub;\n  _pubkey;\n  relayUrls = [];\n  nip46Urls = [];\n  constructor(opts) {\n    if (opts.npub) this._npub = opts.npub;\n    if (opts.hexpubkey) this._pubkey = opts.hexpubkey;\n    if (opts.pubkey) this._pubkey = opts.pubkey;\n    if (opts.relayUrls) this.relayUrls = opts.relayUrls;\n    if (opts.nip46Urls) this.nip46Urls = opts.nip46Urls;\n    if (opts.nprofile) {\n      try {\n        const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(opts.nprofile);\n        if (decoded.type === \"nprofile\") {\n          this._pubkey = decoded.data.pubkey;\n          if (decoded.data.relays && decoded.data.relays.length > 0) {\n            this.relayUrls.push(...decoded.data.relays);\n          }\n        }\n      } catch (e) {\n        console.error(\"Failed to decode nprofile\", e);\n      }\n    }\n  }\n  get npub() {\n    if (!this._npub) {\n      if (!this._pubkey) throw new Error(\"pubkey not set\");\n      this._npub = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.npubEncode(this.pubkey);\n    }\n    return this._npub;\n  }\n  get nprofile() {\n    const relays = this.profileEvent?.onRelays?.map((r) => r.url);\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.nprofileEncode({\n      pubkey: this.pubkey,\n      relays\n    });\n  }\n  set npub(npub2) {\n    this._npub = npub2;\n  }\n  /**\n   * Get the user's pubkey\n   * @returns {string} The user's pubkey\n   */\n  get pubkey() {\n    if (!this._pubkey) {\n      if (!this._npub) throw new Error(\"npub not set\");\n      this._pubkey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(this.npub).data;\n    }\n    return this._pubkey;\n  }\n  /**\n   * Set the user's pubkey\n   * @param pubkey {string} The user's pubkey\n   */\n  set pubkey(pubkey) {\n    this._pubkey = pubkey;\n  }\n  /**\n   * Equivalent to NDKEvent.filters().\n   * @returns {NDKFilter}\n   */\n  filter() {\n    return { \"#p\": [this.pubkey] };\n  }\n  /**\n   * Gets NIP-57 and NIP-61 information that this user has signaled\n   *\n   * @param getAll {boolean} Whether to get all zap info or just the first one\n   */\n  async getZapInfo(timeoutMs) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const promiseWithTimeout = async (promise) => {\n      if (!timeoutMs) return promise;\n      let timeoutId;\n      const timeoutPromise = new Promise((_, reject) => {\n        timeoutId = setTimeout(() => reject(new Error(\"Timeout\")), timeoutMs);\n      });\n      try {\n        const result = await Promise.race([promise, timeoutPromise]);\n        if (timeoutId) clearTimeout(timeoutId);\n        return result;\n      } catch (e) {\n        if (e instanceof Error && e.message === \"Timeout\") {\n          try {\n            const result = await promise;\n            return result;\n          } catch (_originalError) {\n            return void 0;\n          }\n        }\n        return void 0;\n      }\n    };\n    const [userProfile, mintListEvent] = await Promise.all([\n      promiseWithTimeout(this.fetchProfile()),\n      promiseWithTimeout(this.ndk.fetchEvent({ kinds: [10019 /* CashuMintList */], authors: [this.pubkey] }))\n    ]);\n    const res = /* @__PURE__ */ new Map();\n    if (mintListEvent) {\n      const mintList = NDKCashuMintList.from(mintListEvent);\n      if (mintList.mints.length > 0) {\n        res.set(\"nip61\", {\n          mints: mintList.mints,\n          relays: mintList.relays,\n          p2pk: mintList.p2pk\n        });\n      }\n    }\n    if (userProfile) {\n      const { lud06, lud16 } = userProfile;\n      res.set(\"nip57\", { lud06, lud16 });\n    }\n    return res;\n  }\n  /**\n   * Instantiate an NDKUser from a NIP-05 string\n   * @param nip05Id {string} The user's NIP-05\n   * @param ndk {NDK} An NDK instance\n   * @param skipCache {boolean} Whether to skip the cache or not\n   * @returns {NDKUser | undefined} An NDKUser if one is found for the given NIP-05, undefined otherwise.\n   */\n  static async fromNip05(nip05Id, ndk, skipCache = false) {\n    if (!ndk) throw new Error(\"No NDK instance found\");\n    const opts = {};\n    if (skipCache) opts.cache = \"no-cache\";\n    const profile = await getNip05For(ndk, nip05Id, ndk?.httpFetch, opts);\n    if (profile) {\n      const user = new _NDKUser({\n        pubkey: profile.pubkey,\n        relayUrls: profile.relays,\n        nip46Urls: profile.nip46\n      });\n      user.ndk = ndk;\n      return user;\n    }\n  }\n  /**\n   * Fetch a user's profile\n   * @param opts {NDKSubscriptionOptions} A set of NDKSubscriptionOptions\n   * @param storeProfileEvent {boolean} Whether to store the profile event or not\n   * @returns User Profile\n   */\n  async fetchProfile(opts, storeProfileEvent = false) {\n    if (!this.ndk) throw new Error(\"NDK not set\");\n    let setMetadataEvent = null;\n    if (this.ndk.cacheAdapter && (this.ndk.cacheAdapter.fetchProfile || this.ndk.cacheAdapter.fetchProfileSync) && opts?.cacheUsage !== \"ONLY_RELAY\" /* ONLY_RELAY */) {\n      let profile = null;\n      if (this.ndk.cacheAdapter.fetchProfileSync) {\n        profile = this.ndk.cacheAdapter.fetchProfileSync(this.pubkey);\n      } else if (this.ndk.cacheAdapter.fetchProfile) {\n        profile = await this.ndk.cacheAdapter.fetchProfile(this.pubkey);\n      }\n      if (profile) {\n        this.profile = profile;\n        return profile;\n      }\n    }\n    opts ??= {};\n    opts.cacheUsage ??= \"ONLY_RELAY\" /* ONLY_RELAY */;\n    opts.closeOnEose ??= true;\n    opts.groupable ??= true;\n    opts.groupableDelay ??= 250;\n    if (!setMetadataEvent) {\n      setMetadataEvent = await this.ndk.fetchEvent({ kinds: [0], authors: [this.pubkey] }, opts);\n    }\n    if (!setMetadataEvent) return null;\n    this.profile = profileFromEvent(setMetadataEvent);\n    if (storeProfileEvent && this.profile && this.ndk.cacheAdapter && this.ndk.cacheAdapter.saveProfile) {\n      this.ndk.cacheAdapter.saveProfile(this.pubkey, this.profile);\n    }\n    return this.profile;\n  }\n  /**\n   * Returns a set of users that this user follows.\n   *\n   * @deprecated Use followSet instead\n   */\n  follows = follows.bind(this);\n  /**\n   * Returns a set of pubkeys that this user follows.\n   *\n   * @param opts - NDKSubscriptionOptions\n   * @param outbox - boolean\n   * @param kind - number\n   */\n  async followSet(opts, outbox, kind = 3 /* Contacts */) {\n    const follows2 = await this.follows(opts, outbox, kind);\n    return new Set(Array.from(follows2).map((f) => f.pubkey));\n  }\n  /** @deprecated Use referenceTags instead. */\n  /**\n   * Get the tag that can be used to reference this user in an event\n   * @returns {NDKTag} an NDKTag\n   */\n  tagReference() {\n    return [\"p\", this.pubkey];\n  }\n  /**\n   * Get the tags that can be used to reference this user in an event\n   * @returns {NDKTag[]} an array of NDKTag\n   */\n  referenceTags(marker) {\n    const tag = [[\"p\", this.pubkey]];\n    if (!marker) return tag;\n    tag[0].push(\"\", marker);\n    return tag;\n  }\n  /**\n   * Publishes the current profile.\n   */\n  async publish() {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    if (!this.profile) throw new Error(\"No profile available\");\n    this.ndk.assertSigner();\n    const event = new NDKEvent(this.ndk, {\n      kind: 0,\n      content: serializeProfile(this.profile)\n    });\n    await event.publish();\n  }\n  /**\n   * Add a follow to this user's contact list\n   *\n   * @param newFollow {NDKUser} The user to follow\n   * @param currentFollowList {Set<NDKUser>} The current follow list\n   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)\n   * @returns {Promise<boolean>} True if the follow was added, false if the follow already exists\n   */\n  async follow(newFollow, currentFollowList, kind = 3 /* Contacts */) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    if (!currentFollowList) {\n      currentFollowList = await this.follows(void 0, void 0, kind);\n    }\n    if (currentFollowList.has(newFollow)) {\n      return false;\n    }\n    currentFollowList.add(newFollow);\n    const event = new NDKEvent(this.ndk, { kind });\n    for (const follow of currentFollowList) {\n      event.tag(follow);\n    }\n    await event.publish();\n    return true;\n  }\n  /**\n   * Remove a follow from this user's contact list\n   *\n   * @param user {NDKUser} The user to unfollow\n   * @param currentFollowList {Set<NDKUser>} The current follow list\n   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)\n   * @returns The relays were the follow list was published or false if the user wasn't found\n   */\n  async unfollow(user, currentFollowList, kind = 3 /* Contacts */) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    if (!currentFollowList) {\n      currentFollowList = await this.follows(void 0, void 0, kind);\n    }\n    const newUserFollowList = /* @__PURE__ */ new Set();\n    let foundUser = false;\n    for (const follow of currentFollowList) {\n      if (follow.pubkey !== user.pubkey) {\n        newUserFollowList.add(follow);\n      } else {\n        foundUser = true;\n      }\n    }\n    if (!foundUser) return false;\n    const event = new NDKEvent(this.ndk, { kind });\n    for (const follow of newUserFollowList) {\n      event.tag(follow);\n    }\n    return await event.publish();\n  }\n  /**\n   * Validate a user's NIP-05 identifier (usually fetched from their kind:0 profile data)\n   *\n   * @param nip05Id The NIP-05 string to validate\n   * @returns {Promise<boolean | null>} True if the NIP-05 is found and matches this user's pubkey,\n   * False if the NIP-05 is found but doesn't match this user's pubkey,\n   * null if the NIP-05 isn't found on the domain or we're unable to verify (because of network issues, etc.)\n   */\n  async validateNip05(nip05Id) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const profilePointer = await getNip05For(this.ndk, nip05Id);\n    if (profilePointer === null) return null;\n    return profilePointer.pubkey === this.pubkey;\n  }\n};\n\n// src/user/pin.ts\nasync function pinEvent(user, event, pinEvent2, publish) {\n  const kind = 10001 /* PinList */;\n  if (!user.ndk) throw new Error(\"No NDK instance found\");\n  user.ndk.assertSigner();\n  if (!pinEvent2) {\n    const events = await user.ndk.fetchEvents(\n      { kinds: [kind], authors: [user.pubkey] },\n      { cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */ }\n    );\n    if (events.size > 0) {\n      pinEvent2 = lists_default.from(Array.from(events)[0]);\n    } else {\n      pinEvent2 = new NDKEvent(user.ndk, {\n        kind\n      });\n    }\n  }\n  pinEvent2.tag(event);\n  if (publish) {\n    await pinEvent2.publish();\n  }\n  return pinEvent2;\n}\n\n// src/events/kinds/classified.ts\nvar NDKClassified = class _NDKClassified extends NDKEvent {\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30402 /* Classified */;\n  }\n  /**\n   * Creates a NDKClassified from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKClassified from.\n   * @returns NDKClassified\n   */\n  static from(event) {\n    return new _NDKClassified(event.ndk, event);\n  }\n  /**\n   * Getter for the classified title.\n   *\n   * @returns {string | undefined} - The classified title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the classified title.\n   *\n   * @param {string | undefined} title - The title to set for the classified.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the classified summary.\n   *\n   * @returns {string | undefined} - The classified summary if available, otherwise undefined.\n   */\n  get summary() {\n    return this.tagValue(\"summary\");\n  }\n  /**\n   * Setter for the classified summary.\n   *\n   * @param {string | undefined} summary - The summary to set for the classified.\n   */\n  set summary(summary) {\n    this.removeTag(\"summary\");\n    if (summary) this.tags.push([\"summary\", summary]);\n  }\n  /**\n   * Getter for the classified's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the classified was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      return Number.parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the classified's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the classified's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Getter for the classified location.\n   *\n   * @returns {string | undefined} - The classified location if available, otherwise undefined.\n   */\n  get location() {\n    return this.tagValue(\"location\");\n  }\n  /**\n   * Setter for the classified location.\n   *\n   * @param {string | undefined} location - The location to set for the classified.\n   */\n  set location(location) {\n    this.removeTag(\"location\");\n    if (location) this.tags.push([\"location\", location]);\n  }\n  /**\n   * Getter for the classified price.\n   *\n   * @returns {NDKClassifiedPriceTag | undefined} - The classified price if available, otherwise undefined.\n   */\n  get price() {\n    const priceTag = this.tags.find((tag) => tag[0] === \"price\");\n    if (priceTag) {\n      return {\n        amount: Number.parseFloat(priceTag[1]),\n        currency: priceTag[2],\n        frequency: priceTag[3]\n      };\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the classified price.\n   *\n   * @param price - The price to set for the classified.\n   */\n  set price(priceTag) {\n    if (typeof priceTag === \"string\") {\n      priceTag = {\n        amount: Number.parseFloat(priceTag)\n      };\n    }\n    if (priceTag?.amount) {\n      const tag = [\"price\", priceTag.amount.toString()];\n      if (priceTag.currency) tag.push(priceTag.currency);\n      if (priceTag.frequency) tag.push(priceTag.frequency);\n      this.tags.push(tag);\n    } else {\n      this.removeTag(\"price\");\n    }\n  }\n  /**\n   * Generates content tags for the classified.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n};\n\n// src/events/kinds/drafts.ts\nvar NDKDraft = class _NDKDraft extends NDKEvent {\n  _event;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 31234 /* Draft */;\n  }\n  static from(event) {\n    return new _NDKDraft(event.ndk, event);\n  }\n  /**\n   * Sets an identifier (i.e. d-tag)\n   */\n  set identifier(id) {\n    this.removeTag(\"d\");\n    this.tags.push([\"d\", id]);\n  }\n  get identifier() {\n    return this.dTag;\n  }\n  /**\n   * Event that is to be saved.\n   */\n  set event(e) {\n    if (e instanceof NDKEvent) this._event = e.rawEvent();\n    else this._event = e;\n    this.prepareEvent();\n  }\n  /**\n   * Gets the event.\n   * @param param0\n   * @returns NDKEvent of the draft event or null if the draft event has been deleted (emptied).\n   */\n  async getEvent(signer) {\n    if (this._event) return new NDKEvent(this.ndk, this._event);\n    signer ??= this.ndk?.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    if (this.content && this.content.length > 0) {\n      try {\n        await this.decrypt(user, signer);\n        const payload = JSON.parse(this.content);\n        this._event = payload;\n        return new NDKEvent(this.ndk, payload);\n      } catch (e) {\n        console.error(e);\n        return void 0;\n      }\n    } else {\n      return null;\n    }\n  }\n  prepareEvent() {\n    if (!this._event) throw new Error(\"No event has been provided\");\n    this.removeTag(\"k\");\n    if (this._event.kind) this.tags.push([\"k\", this._event.kind.toString()]);\n    this.content = JSON.stringify(this._event);\n  }\n  /**\n   * Generates draft event.\n   *\n   * @param signer: Optional signer to encrypt with\n   * @param publish: Whether to publish, optionally specifying relaySet to publish to\n   */\n  async save({ signer, publish, relaySet }) {\n    signer ??= this.ndk?.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    await this.encrypt(user, signer);\n    if (publish === false) return;\n    return this.publish(relaySet);\n  }\n};\n\n// src/events/kinds/dvm/feedback.ts\nvar NDKDvmJobFeedbackStatus = /* @__PURE__ */ ((NDKDvmJobFeedbackStatus2) => {\n  NDKDvmJobFeedbackStatus2[\"Processing\"] = \"processing\";\n  NDKDvmJobFeedbackStatus2[\"Success\"] = \"success\";\n  NDKDvmJobFeedbackStatus2[\"Scheduled\"] = \"scheduled\";\n  NDKDvmJobFeedbackStatus2[\"PayReq\"] = \"payment_required\";\n  return NDKDvmJobFeedbackStatus2;\n})(NDKDvmJobFeedbackStatus || {});\nvar NDKDVMJobFeedback = class _NDKDVMJobFeedback extends NDKEvent {\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7e3 /* DVMJobFeedback */;\n  }\n  static async from(event) {\n    const e = new _NDKDVMJobFeedback(event.ndk, event.rawEvent());\n    if (e.encrypted) await e.dvmDecrypt();\n    return e;\n  }\n  get status() {\n    return this.tagValue(\"status\");\n  }\n  set status(status) {\n    this.removeTag(\"status\");\n    if (status !== void 0) {\n      this.tags.push([\"status\", status]);\n    }\n  }\n  get encrypted() {\n    return !!this.getMatchingTags(\"encrypted\")[0];\n  }\n  async dvmDecrypt() {\n    await this.decrypt();\n    const decryptedContent = JSON.parse(this.content);\n    this.tags.push(...decryptedContent);\n  }\n};\n\n// src/events/kinds/dvm/request.ts\nvar NDKDVMRequest = class _NDKDVMRequest extends NDKEvent {\n  static from(event) {\n    return new _NDKDVMRequest(event.ndk, event.rawEvent());\n  }\n  set bid(msatAmount) {\n    if (msatAmount === void 0) {\n      this.removeTag(\"bid\");\n    } else {\n      this.tags.push([\"bid\", msatAmount.toString()]);\n    }\n  }\n  get bid() {\n    const v = this.tagValue(\"bid\");\n    if (v === void 0) return void 0;\n    return Number.parseInt(v);\n  }\n  /**\n   * Adds a new input to the job\n   * @param args The arguments to the input\n   */\n  addInput(...args) {\n    this.tags.push([\"i\", ...args]);\n  }\n  /**\n   * Adds a new parameter to the job\n   */\n  addParam(...args) {\n    this.tags.push([\"param\", ...args]);\n  }\n  set output(output) {\n    if (output === void 0) {\n      this.removeTag(\"output\");\n    } else {\n      if (typeof output === \"string\") output = [output];\n      this.tags.push([\"output\", ...output]);\n    }\n  }\n  get output() {\n    const outputTag = this.getMatchingTags(\"output\")[0];\n    return outputTag ? outputTag.slice(1) : void 0;\n  }\n  get params() {\n    const paramTags = this.getMatchingTags(\"param\");\n    return paramTags.map((t) => t.slice(1));\n  }\n  getParam(name) {\n    const paramTag = this.getMatchingTags(\"param\").find((t) => t[1] === name);\n    return paramTag ? paramTag[2] : void 0;\n  }\n  createFeedback(status) {\n    const feedback = new NDKDVMJobFeedback(this.ndk);\n    feedback.tag(this, \"job\");\n    feedback.status = status;\n    return feedback;\n  }\n  /**\n   * Enables job encryption for this event\n   * @param dvm DVM that will receive the event\n   * @param signer Signer to use for encryption\n   */\n  async encryption(dvm, signer) {\n    const dvmTags = [\"i\", \"param\", \"output\", \"relays\", \"bid\"];\n    const tags = this.tags.filter((t) => dvmTags.includes(t[0]));\n    this.tags = this.tags.filter((t) => !dvmTags.includes(t[0]));\n    this.content = JSON.stringify(tags);\n    this.tag(dvm);\n    this.tags.push([\"encrypted\"]);\n    await this.encrypt(dvm, signer);\n  }\n  /**\n   * Sets the DVM that will receive the event\n   */\n  set dvm(dvm) {\n    this.removeTag(\"p\");\n    if (dvm) this.tag(dvm);\n  }\n};\n\n// src/events/kinds/dvm/NDKTranscriptionDVM.ts\nvar NDKTranscriptionDVM = class _NDKTranscriptionDVM extends NDKDVMRequest {\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind = 5e3 /* DVMReqTextExtraction */;\n  }\n  static from(event) {\n    return new _NDKTranscriptionDVM(event.ndk, event.rawEvent());\n  }\n  /**\n   * Returns the original source of the transcription\n   */\n  get url() {\n    const inputTags = this.getMatchingTags(\"i\");\n    if (inputTags.length !== 1) {\n      return void 0;\n    }\n    return inputTags[0][1];\n  }\n  /**\n   * Getter for the title tag\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the title tag\n   */\n  set title(value) {\n    this.removeTag(\"title\");\n    if (value) {\n      this.tags.push([\"title\", value]);\n    }\n  }\n  /**\n   * Getter for the image tag\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Setter for the image tag\n   */\n  set image(value) {\n    this.removeTag(\"image\");\n    if (value) {\n      this.tags.push([\"image\", value]);\n    }\n  }\n};\n\n// src/events/kinds/dvm/result.ts\nvar NDKDVMJobResult = class _NDKDVMJobResult extends NDKEvent {\n  static from(event) {\n    return new _NDKDVMJobResult(event.ndk, event.rawEvent());\n  }\n  setAmount(msat, invoice) {\n    this.removeTag(\"amount\");\n    const tag = [\"amount\", msat.toString()];\n    if (invoice) tag.push(invoice);\n    this.tags.push(tag);\n  }\n  set result(result) {\n    if (result === void 0) {\n      this.content = \"\";\n    } else {\n      this.content = result;\n    }\n  }\n  get result() {\n    if (this.content === \"\") {\n      return void 0;\n    }\n    return this.content;\n  }\n  set status(status) {\n    this.removeTag(\"status\");\n    if (status !== void 0) {\n      this.tags.push([\"status\", status]);\n    }\n  }\n  get status() {\n    return this.tagValue(\"status\");\n  }\n  get jobRequestId() {\n    for (const eTag of this.getMatchingTags(\"e\")) {\n      if (eTag[2] === \"job\") return eTag[1];\n    }\n    if (this.jobRequest) return this.jobRequest.id;\n    return this.tagValue(\"e\");\n  }\n  set jobRequest(event) {\n    this.removeTag(\"request\");\n    if (event) {\n      this.kind = event.kind + 1e3;\n      this.tags.push([\"request\", JSON.stringify(event.rawEvent())]);\n      this.tag(event);\n    }\n  }\n  get jobRequest() {\n    const tag = this.tagValue(\"request\");\n    if (tag === void 0) {\n      return void 0;\n    }\n    return new NDKEvent(this.ndk, JSON.parse(tag));\n  }\n};\n\n// src/events/kinds/cashu/tx.ts\nvar MARKERS = {\n  REDEEMED: \"redeemed\",\n  CREATED: \"created\",\n  DESTROYED: \"destroyed\",\n  RESERVED: \"reserved\"\n};\nvar NDKCashuWalletTx = class _NDKCashuWalletTx extends NDKEvent {\n  static MARKERS = MARKERS;\n  static kind = 7376 /* CashuWalletTx */;\n  static kinds = [7376 /* CashuWalletTx */];\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7376 /* CashuWalletTx */;\n  }\n  static async from(event) {\n    const walletChange = new _NDKCashuWalletTx(event.ndk, event);\n    const prevContent = walletChange.content;\n    try {\n      await walletChange.decrypt();\n    } catch (_e) {\n      walletChange.content ??= prevContent;\n    }\n    try {\n      const contentTags = JSON.parse(walletChange.content);\n      walletChange.tags = [...contentTags, ...walletChange.tags];\n    } catch (_e) {\n      return;\n    }\n    return walletChange;\n  }\n  set direction(direction) {\n    this.removeTag(\"direction\");\n    if (direction) this.tags.push([\"direction\", direction]);\n  }\n  get direction() {\n    return this.tagValue(\"direction\");\n  }\n  set amount(amount) {\n    this.removeTag(\"amount\");\n    this.tags.push([\"amount\", amount.toString()]);\n  }\n  get amount() {\n    const val = this.tagValue(\"amount\");\n    if (val === void 0) return void 0;\n    return Number(val);\n  }\n  set fee(fee) {\n    this.removeTag(\"fee\");\n    this.tags.push([\"fee\", fee.toString()]);\n  }\n  get fee() {\n    const val = this.tagValue(\"fee\");\n    if (val === void 0) return void 0;\n    return Number(val);\n  }\n  set unit(unit) {\n    this.removeTag(\"unit\");\n    if (unit) this.tags.push([\"unit\", unit.toString()]);\n  }\n  get unit() {\n    return this.tagValue(\"unit\");\n  }\n  set description(description) {\n    this.removeTag(\"description\");\n    if (description) this.tags.push([\"description\", description.toString()]);\n  }\n  get description() {\n    return this.tagValue(\"description\");\n  }\n  set mint(mint) {\n    this.removeTag(\"mint\");\n    if (mint) this.tags.push([\"mint\", mint.toString()]);\n  }\n  get mint() {\n    return this.tagValue(\"mint\");\n  }\n  /**\n   * Tags tokens that were created in this history event\n   */\n  set destroyedTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.DESTROYED));\n    }\n  }\n  set destroyedTokenIds(ids) {\n    for (const id of ids) {\n      this.tags.push([\"e\", id, \"\", MARKERS.DESTROYED]);\n    }\n  }\n  /**\n   * Tags tokens that were created in this history event\n   */\n  set createdTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.CREATED));\n    }\n  }\n  set reservedTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.RESERVED));\n    }\n  }\n  addRedeemedNutzap(event) {\n    this.tag(event, MARKERS.REDEEMED);\n  }\n  async toNostrEvent(pubkey) {\n    const encryptedTags = [];\n    const unencryptedTags = [];\n    for (const tag of this.tags) {\n      if (!this.shouldEncryptTag(tag)) {\n        unencryptedTags.push(tag);\n      } else {\n        encryptedTags.push(tag);\n      }\n    }\n    this.tags = unencryptedTags.filter((t) => t[0] !== \"client\");\n    this.content = JSON.stringify(encryptedTags);\n    const user = await this.ndk?.signer?.user();\n    await this.encrypt(user, void 0, \"nip44\");\n    return super.toNostrEvent(pubkey);\n  }\n  /**\n   * Whether this entry includes a redemption of a Nutzap\n   */\n  get hasNutzapRedemption() {\n    return this.getMatchingTags(\"e\", MARKERS.REDEEMED).length > 0;\n  }\n  shouldEncryptTag(tag) {\n    const unencryptedTagNames = [\"client\"];\n    if (unencryptedTagNames.includes(tag[0])) {\n      return false;\n    }\n    if (tag[0] === \"e\" && tag[3] === MARKERS.REDEEMED) {\n      return false;\n    }\n    if (tag[0] === \"p\") return false;\n    return true;\n  }\n};\n\n// src/events/kinds/NDKRelayList.ts\nvar READ_MARKER = \"read\";\nvar WRITE_MARKER = \"write\";\nvar NDKRelayList = class _NDKRelayList extends NDKEvent {\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 10002 /* RelayList */;\n  }\n  static from(ndkEvent) {\n    return new _NDKRelayList(ndkEvent.ndk, ndkEvent.rawEvent());\n  }\n  get readRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2] || tag[2] && tag[2] === READ_MARKER).map((tag) => tryNormalizeRelayUrl(tag[1])).filter((url) => !!url);\n  }\n  set readRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay, READ_MARKER]);\n    }\n  }\n  get writeRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2] || tag[2] && tag[2] === WRITE_MARKER).map((tag) => tryNormalizeRelayUrl(tag[1])).filter((url) => !!url);\n  }\n  set writeRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay, WRITE_MARKER]);\n    }\n  }\n  get bothRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2]).map((tag) => tag[1]);\n  }\n  set bothRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay]);\n    }\n  }\n  get relays() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").map((tag) => tag[1]);\n  }\n  /**\n   * Provides a relaySet for the relays in this list.\n   */\n  get relaySet() {\n    if (!this.ndk) throw new Error(\"NDKRelayList has no NDK instance\");\n    return new NDKRelaySet(\n      new Set(this.relays.map((u) => this.ndk?.pool.getRelay(u)).filter((r) => !!r)),\n      this.ndk\n    );\n  }\n};\nfunction relayListFromKind3(ndk, contactList) {\n  try {\n    const content = JSON.parse(contactList.content);\n    const relayList = new NDKRelayList(ndk);\n    const readRelays = /* @__PURE__ */ new Set();\n    const writeRelays = /* @__PURE__ */ new Set();\n    for (let [key, config] of Object.entries(content)) {\n      try {\n        key = normalizeRelayUrl(key);\n      } catch {\n        continue;\n      }\n      if (!config) {\n        readRelays.add(key);\n        writeRelays.add(key);\n      } else {\n        const relayConfig = config;\n        if (relayConfig.write) writeRelays.add(key);\n        if (relayConfig.read) readRelays.add(key);\n      }\n    }\n    relayList.readRelayUrls = Array.from(readRelays);\n    relayList.writeRelayUrls = Array.from(writeRelays);\n    return relayList;\n  } catch {\n  }\n  return void 0;\n}\n\n// src/events/kinds/nip89/app-handler.ts\nvar NDKAppHandlerEvent = class _NDKAppHandlerEvent extends NDKEvent {\n  profile;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 31990 /* AppHandler */;\n  }\n  static from(ndkEvent) {\n    const event = new _NDKAppHandlerEvent(ndkEvent.ndk, ndkEvent.rawEvent());\n    if (event.isValid) {\n      return event;\n    }\n    return null;\n  }\n  get isValid() {\n    const combinations = /* @__PURE__ */ new Map();\n    const combinationFromTag = (tag) => [tag[0], tag[2]].join(\":\").toLowerCase();\n    const tagsToInspect = [\"web\", \"android\", \"ios\"];\n    for (const tag of this.tags) {\n      if (tagsToInspect.includes(tag[0])) {\n        const combination = combinationFromTag(tag);\n        if (combinations.has(combination)) {\n          if (combinations.get(combination) !== tag[1].toLowerCase()) {\n            return false;\n          }\n        }\n        combinations.set(combination, tag[1].toLowerCase());\n      }\n    }\n    return true;\n  }\n  /**\n   * Fetches app handler information\n   * If no app information is available on the kind:31990,\n   * we fetch the event's author's profile and return that instead.\n   */\n  async fetchProfile() {\n    if (this.profile === void 0 && this.content.length > 0) {\n      try {\n        const profile = JSON.parse(this.content);\n        if (profile?.name) {\n          return profile;\n        }\n        this.profile = null;\n      } catch (_e) {\n        this.profile = null;\n      }\n    }\n    return new Promise((resolve, reject) => {\n      const author = this.author;\n      author.fetchProfile().then(() => {\n        resolve(author.profile);\n      }).catch(reject);\n    });\n  }\n};\n\n// src/events/kinds/repost.ts\nvar NDKRepost = class _NDKRepost extends NDKEvent {\n  _repostedEvents;\n  static from(event) {\n    return new _NDKRepost(event.ndk, event.rawEvent());\n  }\n  /**\n   * Returns all reposted events by the current event.\n   *\n   * @param klass Optional class to convert the events to.\n   * @returns\n   */\n  async repostedEvents(klass, opts) {\n    const items = [];\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (this._repostedEvents !== void 0) return this._repostedEvents;\n    for (const eventId of this.repostedEventIds()) {\n      const filter = filterForId(eventId);\n      const event = await this.ndk.fetchEvent(filter, opts);\n      if (event) {\n        items.push(klass ? klass.from(event) : event);\n      }\n    }\n    return items;\n  }\n  /**\n   * Returns the reposted event IDs.\n   */\n  repostedEventIds() {\n    return this.tags.filter((t) => t[0] === \"e\" || t[0] === \"a\").map((t) => t[1]);\n  }\n};\nfunction filterForId(id) {\n  if (id.match(/:/)) {\n    const [kind, pubkey, identifier] = id.split(\":\");\n    return {\n      kinds: [Number.parseInt(kind)],\n      authors: [pubkey],\n      \"#d\": [identifier]\n    };\n  }\n  return { ids: [id] };\n}\n\n// src/events/kinds/subscriptions/receipt.ts\n\nvar NDKSubscriptionReceipt = class _NDKSubscriptionReceipt extends NDKEvent {\n  debug;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 7003 /* SubscriptionReceipt */;\n    this.debug = ndk?.debug.extend(\"subscription-start\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:subscription-start\");\n  }\n  static from(event) {\n    return new _NDKSubscriptionReceipt(event.ndk, event.rawEvent());\n  }\n  /**\n   * This is the person being subscribed to\n   */\n  get recipient() {\n    const pTag = this.getMatchingTags(\"p\")?.[0];\n    if (!pTag) return void 0;\n    const user = new NDKUser({ pubkey: pTag[1] });\n    return user;\n  }\n  set recipient(user) {\n    this.removeTag(\"p\");\n    if (!user) return;\n    this.tags.push([\"p\", user.pubkey]);\n  }\n  /**\n   * This is the person subscribing\n   */\n  get subscriber() {\n    const PTag = this.getMatchingTags(\"P\")?.[0];\n    if (!PTag) return void 0;\n    const user = new NDKUser({ pubkey: PTag[1] });\n    return user;\n  }\n  set subscriber(user) {\n    this.removeTag(\"P\");\n    if (!user) return;\n    this.tags.push([\"P\", user.pubkey]);\n  }\n  set subscriptionStart(event) {\n    this.debug(`before setting subscription start: ${this.rawEvent}`);\n    this.removeTag(\"e\");\n    this.tag(event, \"subscription\", true);\n    this.debug(`after setting subscription start: ${this.rawEvent}`);\n  }\n  get tierName() {\n    const tag = this.getMatchingTags(\"tier\")?.[0];\n    return tag?.[1];\n  }\n  get isValid() {\n    const period = this.validPeriod;\n    if (!period) {\n      return false;\n    }\n    if (period.start > period.end) {\n      return false;\n    }\n    const pTags = this.getMatchingTags(\"p\");\n    const PTags = this.getMatchingTags(\"P\");\n    if (pTags.length !== 1 || PTags.length !== 1) {\n      return false;\n    }\n    return true;\n  }\n  get validPeriod() {\n    const tag = this.getMatchingTags(\"valid\")?.[0];\n    if (!tag) return void 0;\n    try {\n      return {\n        start: new Date(Number.parseInt(tag[1]) * 1e3),\n        end: new Date(Number.parseInt(tag[2]) * 1e3)\n      };\n    } catch {\n      return void 0;\n    }\n  }\n  set validPeriod(period) {\n    this.removeTag(\"valid\");\n    if (!period) return;\n    this.tags.push([\n      \"valid\",\n      Math.floor(period.start.getTime() / 1e3).toString(),\n      Math.floor(period.end.getTime() / 1e3).toString()\n    ]);\n  }\n  get startPeriod() {\n    return this.validPeriod?.start;\n  }\n  get endPeriod() {\n    return this.validPeriod?.end;\n  }\n  /**\n   * Whether the subscription is currently active\n   */\n  isActive(time) {\n    time ??= /* @__PURE__ */ new Date();\n    const period = this.validPeriod;\n    if (!period) return false;\n    if (time < period.start) return false;\n    if (time > period.end) return false;\n    return true;\n  }\n};\n\n// src/events/kinds/subscriptions/subscription-start.ts\n\nvar NDKSubscriptionStart = class _NDKSubscriptionStart extends NDKEvent {\n  debug;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 7001 /* Subscribe */;\n    this.debug = ndk?.debug.extend(\"subscription-start\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:subscription-start\");\n  }\n  static from(event) {\n    return new _NDKSubscriptionStart(event.ndk, event.rawEvent());\n  }\n  /**\n   * Recipient of the subscription. I.e. The author of this event subscribes to this user.\n   */\n  get recipient() {\n    const pTag = this.getMatchingTags(\"p\")?.[0];\n    if (!pTag) return void 0;\n    const user = new NDKUser({ pubkey: pTag[1] });\n    return user;\n  }\n  set recipient(user) {\n    this.removeTag(\"p\");\n    if (!user) return;\n    this.tags.push([\"p\", user.pubkey]);\n  }\n  /**\n   * The amount of the subscription.\n   */\n  get amount() {\n    const amountTag = this.getMatchingTags(\"amount\")?.[0];\n    if (!amountTag) return void 0;\n    return parseTagToSubscriptionAmount(amountTag);\n  }\n  set amount(amount) {\n    this.removeTag(\"amount\");\n    if (!amount) return;\n    this.tags.push(newAmount(amount.amount, amount.currency, amount.term));\n  }\n  /**\n   * The event id or NIP-33 tag id of the tier that the user is subscribing to.\n   */\n  get tierId() {\n    const eTag = this.getMatchingTags(\"e\")?.[0];\n    const aTag = this.getMatchingTags(\"a\")?.[0];\n    if (!eTag || !aTag) return void 0;\n    return eTag[1] ?? aTag[1];\n  }\n  set tier(tier) {\n    this.removeTag(\"e\");\n    this.removeTag(\"a\");\n    this.removeTag(\"event\");\n    if (!tier) return;\n    this.tag(tier);\n    this.removeTag(\"p\");\n    this.tags.push([\"p\", tier.pubkey]);\n    this.tags.push([\"event\", JSON.stringify(tier.rawEvent())]);\n  }\n  /**\n   * Fetches the tier that the user is subscribing to.\n   */\n  async fetchTier() {\n    const eventTag = this.tagValue(\"event\");\n    if (eventTag) {\n      try {\n        const parsedEvent = JSON.parse(eventTag);\n        return new NDKSubscriptionTier(this.ndk, parsedEvent);\n      } catch {\n        this.debug(\"Failed to parse event tag\");\n      }\n    }\n    const tierId = this.tierId;\n    if (!tierId) return void 0;\n    const e = await this.ndk?.fetchEvent(tierId);\n    if (!e) return void 0;\n    return NDKSubscriptionTier.from(e);\n  }\n  get isValid() {\n    if (this.getMatchingTags(\"amount\").length !== 1) {\n      this.debug(\"Invalid # of amount tag\");\n      return false;\n    }\n    if (!this.amount) {\n      this.debug(\"Invalid amount tag\");\n      return false;\n    }\n    if (this.getMatchingTags(\"p\").length !== 1) {\n      this.debug(\"Invalid # of p tag\");\n      return false;\n    }\n    if (!this.recipient) {\n      this.debug(\"Invalid p tag\");\n      return false;\n    }\n    return true;\n  }\n};\n\n// src/events/gift-wrapping.ts\n\n\n// src/signers/private-key/index.ts\n\n\n\nvar NDKPrivateKeySigner = class _NDKPrivateKeySigner {\n  _user;\n  _privateKey;\n  _pubkey;\n  /**\n   * Create a new signer from a private key.\n   * @param privateKey - The private key to use in hex form or nsec.\n   * @param ndk - The NDK instance to use.\n   */\n  constructor(privateKeyOrNsec, ndk) {\n    if (typeof privateKeyOrNsec === \"string\") {\n      if (privateKeyOrNsec.startsWith(\"nsec1\")) {\n        const { type, data } = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(privateKeyOrNsec);\n        if (type === \"nsec\") this._privateKey = data;\n        else throw new Error(\"Invalid private key provided.\");\n      } else if (privateKeyOrNsec.length === 64) {\n        this._privateKey = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(privateKeyOrNsec);\n      } else {\n        throw new Error(\"Invalid private key provided.\");\n      }\n    } else {\n      this._privateKey = privateKeyOrNsec;\n    }\n    this._pubkey = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.getPublicKey)(this._privateKey);\n    if (ndk) this._user = ndk.getUser({ pubkey: this._pubkey });\n    this._user ??= new NDKUser({ pubkey: this._pubkey });\n  }\n  /**\n   * Get the private key in hex form.\n   */\n  get privateKey() {\n    if (!this._privateKey) throw new Error(\"Not ready\");\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(this._privateKey);\n  }\n  /**\n   * Get the public key in hex form.\n   */\n  get pubkey() {\n    if (!this._pubkey) throw new Error(\"Not ready\");\n    return this._pubkey;\n  }\n  /**\n   * Get the private key in nsec form.\n   */\n  get nsec() {\n    if (!this._privateKey) throw new Error(\"Not ready\");\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.nsecEncode(this._privateKey);\n  }\n  /**\n   * Get the public key in npub form.\n   */\n  get npub() {\n    if (!this._pubkey) throw new Error(\"Not ready\");\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.npubEncode(this._pubkey);\n  }\n  /**\n   * Generate a new private key.\n   */\n  static generate() {\n    const privateKey = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.generateSecretKey)();\n    return new _NDKPrivateKeySigner(privateKey);\n  }\n  /**\n   * Noop in NDKPrivateKeySigner.\n   */\n  async blockUntilReady() {\n    return this._user;\n  }\n  /**\n   * Get the user.\n   */\n  async user() {\n    return this._user;\n  }\n  /**\n   * Get the user.\n   */\n  get userSync() {\n    return this._user;\n  }\n  async sign(event) {\n    if (!this._privateKey) {\n      throw Error(\"Attempted to sign without a private key\");\n    }\n    return (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(event, this._privateKey).sig;\n  }\n  async encryptionEnabled(scheme) {\n    const enabled = [];\n    if (!scheme || scheme === \"nip04\") enabled.push(\"nip04\");\n    if (!scheme || scheme === \"nip44\") enabled.push(\"nip44\");\n    return enabled;\n  }\n  async encrypt(recipient, value, scheme) {\n    if (!this._privateKey || !this.privateKey) {\n      throw Error(\"Attempted to encrypt without a private key\");\n    }\n    const recipientHexPubKey = recipient.pubkey;\n    if (scheme === \"nip44\") {\n      const conversationKey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.utils.getConversationKey(this._privateKey, recipientHexPubKey);\n      return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.encrypt(value, conversationKey);\n    }\n    return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip04.encrypt(this._privateKey, recipientHexPubKey, value);\n  }\n  async decrypt(sender, value, scheme) {\n    if (!this._privateKey || !this.privateKey) {\n      throw Error(\"Attempted to decrypt without a private key\");\n    }\n    const senderHexPubKey = sender.pubkey;\n    if (scheme === \"nip44\") {\n      const conversationKey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.utils.getConversationKey(this._privateKey, senderHexPubKey);\n      return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.decrypt(value, conversationKey);\n    }\n    return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip04.decrypt(this._privateKey, senderHexPubKey, value);\n  }\n  /**\n   * Serializes the signer's private key into a storable format.\n   * @returns A JSON string containing the type and the hex private key.\n   */\n  toPayload() {\n    if (!this._privateKey) throw new Error(\"Private key not available\");\n    const payload = {\n      type: \"private-key\",\n      payload: this.privateKey\n      // Use the hex private key\n    };\n    return JSON.stringify(payload);\n  }\n  /**\n   * Deserializes the signer from a payload string.\n   * @param payloadString The JSON string obtained from toPayload().\n   * @param ndk Optional NDK instance.\n   * @returns An instance of NDKPrivateKeySigner.\n   */\n  static async fromPayload(payloadString, ndk) {\n    const payload = JSON.parse(payloadString);\n    if (payload.type !== \"private-key\") {\n      throw new Error(`Invalid payload type: expected 'private-key', got ${payload.type}`);\n    }\n    if (!payload.payload || typeof payload.payload !== \"string\") {\n      throw new Error(\"Invalid payload content for private-key signer\");\n    }\n    return new _NDKPrivateKeySigner(payload.payload, ndk);\n  }\n};\n\n// src/events/gift-wrapping.ts\nasync function giftWrap(event, recipient, signer, params = {}) {\n  let _signer = signer;\n  params.scheme ??= \"nip44\";\n  if (!_signer) {\n    if (!event.ndk) throw new Error(\"no signer available for giftWrap\");\n    _signer = event.ndk.signer;\n  }\n  if (!_signer) throw new Error(\"no signer\");\n  if (!_signer.encryptionEnabled || !_signer.encryptionEnabled(params.scheme))\n    throw new Error(\"signer is not able to giftWrap\");\n  const rumor = getRumorEvent(event, params?.rumorKind);\n  const seal = await getSealEvent(rumor, recipient, _signer, params.scheme);\n  const wrap = await getWrapEvent(seal, recipient, params);\n  return new NDKEvent(event.ndk, wrap);\n}\nasync function giftUnwrap(event, sender, signer, scheme = \"nip44\") {\n  const _sender = sender || new NDKUser({ pubkey: event.pubkey });\n  let _signer = signer;\n  if (!_signer) {\n    if (!event.ndk) throw new Error(\"no signer available for giftUnwrap\");\n    _signer = event.ndk.signer;\n  }\n  if (!signer) throw new Error(\"no signer\");\n  try {\n    const seal = JSON.parse(await signer.decrypt(_sender, event.content, scheme));\n    if (!seal) throw new Error(\"Failed to decrypt wrapper\");\n    if (!new NDKEvent(void 0, seal).verifySignature(false))\n      throw new Error(\"GiftSeal signature verification failed!\");\n    const rumorSender = new NDKUser({ pubkey: seal.pubkey });\n    const rumor = JSON.parse(await signer.decrypt(rumorSender, seal.content, scheme));\n    if (!rumor) throw new Error(\"Failed to decrypt seal\");\n    if (rumor.pubkey !== seal.pubkey) throw new Error(\"Invalid GiftWrap, sender validation failed!\");\n    return new NDKEvent(event.ndk, rumor);\n  } catch (_e) {\n    return Promise.reject(\"Got error unwrapping event! See console log.\");\n  }\n}\nfunction getRumorEvent(event, kind) {\n  const rumor = event.rawEvent();\n  rumor.kind = kind || rumor.kind || 14 /* PrivateDirectMessage */;\n  rumor.sig = void 0;\n  rumor.id = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.getEventHash)(rumor);\n  return new NDKEvent(event.ndk, rumor);\n}\nasync function getSealEvent(rumor, recipient, signer, scheme = \"nip44\") {\n  const seal = new NDKEvent(rumor.ndk);\n  seal.kind = 13 /* GiftWrapSeal */;\n  seal.created_at = approximateNow(5);\n  seal.content = JSON.stringify(rumor.rawEvent());\n  await seal.encrypt(recipient, signer, scheme);\n  await seal.sign(signer);\n  return seal;\n}\nasync function getWrapEvent(sealed, recipient, params, scheme = \"nip44\") {\n  const signer = NDKPrivateKeySigner.generate();\n  const wrap = new NDKEvent(sealed.ndk);\n  wrap.kind = 1059 /* GiftWrap */;\n  wrap.created_at = approximateNow(5);\n  if (params?.wrapTags) wrap.tags = params.wrapTags;\n  wrap.tag(recipient);\n  wrap.content = JSON.stringify(sealed.rawEvent());\n  await wrap.encrypt(recipient, signer, scheme);\n  await wrap.sign(signer);\n  return wrap;\n}\nfunction approximateNow(drift = 0) {\n  return Math.round(Date.now() / 1e3 - Math.random() * 10 ** drift);\n}\n\n// src/events/kinds/simple-group/index.ts\nvar NDKSimpleGroup = class _NDKSimpleGroup {\n  ndk;\n  groupId;\n  relaySet;\n  fetchingMetadata;\n  metadata;\n  memberList;\n  adminList;\n  constructor(ndk, relaySet, groupId) {\n    this.ndk = ndk;\n    this.groupId = groupId ?? randomId(24);\n    this.relaySet = relaySet;\n  }\n  get id() {\n    return this.groupId;\n  }\n  relayUrls() {\n    return this.relaySet?.relayUrls;\n  }\n  get name() {\n    return this.metadata?.name;\n  }\n  get about() {\n    return this.metadata?.about;\n  }\n  get picture() {\n    return this.metadata?.picture;\n  }\n  get members() {\n    return this.memberList?.members ?? [];\n  }\n  get admins() {\n    return this.adminList?.members ?? [];\n  }\n  async getMetadata() {\n    await this.ensureMetadataEvent();\n    return this.metadata;\n  }\n  /**\n   * Creates the group by publishing a kind:9007 event.\n   * @param signer\n   * @returns\n   */\n  async createGroup(signer) {\n    signer ??= this.ndk.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    if (!user) throw new Error(\"No user available\");\n    const event = new NDKEvent(this.ndk);\n    event.kind = 9007 /* GroupAdminCreateGroup */;\n    event.tags.push([\"h\", this.groupId]);\n    await event.sign(signer);\n    return event.publish(this.relaySet);\n  }\n  async setMetadata({ name, about, picture }) {\n    const event = new NDKEvent(this.ndk);\n    event.kind = 9002 /* GroupAdminEditMetadata */;\n    event.tags.push([\"h\", this.groupId]);\n    if (name) event.tags.push([\"name\", name]);\n    if (about) event.tags.push([\"about\", about]);\n    if (picture) event.tags.push([\"picture\", picture]);\n    await event.sign();\n    return event.publish(this.relaySet);\n  }\n  /**\n   * Adds a user to the group using a kind:9000 event\n   * @param user user to add\n   * @param opts options\n   */\n  async addUser(user) {\n    const addUserEvent = _NDKSimpleGroup.generateAddUserEvent(user.pubkey, this.groupId);\n    addUserEvent.ndk = this.ndk;\n    return addUserEvent;\n  }\n  async getMemberListEvent() {\n    const memberList = await this.ndk.fetchEvent(\n      {\n        kinds: [39002 /* GroupMembers */],\n        \"#d\": [this.groupId]\n      },\n      void 0,\n      this.relaySet\n    );\n    if (!memberList) return null;\n    return NDKSimpleGroupMemberList.from(memberList);\n  }\n  /**\n   * Gets a list of users that belong to this group\n   */\n  async getMembers() {\n    const members = [];\n    const memberPubkeys = /* @__PURE__ */ new Set();\n    const memberListEvent = await this.getMemberListEvent();\n    if (!memberListEvent) return [];\n    for (const pTag of memberListEvent.getMatchingTags(\"p\")) {\n      const pubkey = pTag[1];\n      if (memberPubkeys.has(pubkey)) continue;\n      memberPubkeys.add(pubkey);\n      try {\n        members.push(this.ndk.getUser({ pubkey }));\n      } catch {\n      }\n    }\n    return members;\n  }\n  /**\n   * Generates an event that lists the members of a group.\n   * @param groupId\n   * @returns\n   */\n  static generateUserListEvent(groupId) {\n    const event = new NDKEvent(void 0, {\n      kind: 39002 /* GroupMembers */,\n      tags: [\n        [\"h\", groupId],\n        [\"alt\", \"Group Member List\"]\n      ]\n    });\n    return event;\n  }\n  /**\n   * Generates an event that adds a user to a group.\n   * @param userPubkey pubkey of the user to add\n   * @param groupId group to add the user to\n   * @returns\n   */\n  static generateAddUserEvent(userPubkey, groupId) {\n    const event = new NDKEvent(void 0, {\n      kind: 9e3 /* GroupAdminAddUser */,\n      tags: [[\"h\", groupId]]\n    });\n    event.tags.push([\"p\", userPubkey]);\n    return event;\n  }\n  async requestToJoin(_pubkey, content) {\n    const event = new NDKEvent(this.ndk, {\n      kind: 9021 /* GroupAdminRequestJoin */,\n      content: content ?? \"\",\n      tags: [[\"h\", this.groupId]]\n    });\n    return event.publish(this.relaySet);\n  }\n  /**\n   * Makes sure that a metadata event exists locally\n   */\n  async ensureMetadataEvent() {\n    if (this.metadata) return;\n    if (this.fetchingMetadata) return this.fetchingMetadata;\n    this.fetchingMetadata = this.ndk.fetchEvent(\n      {\n        kinds: [39e3 /* GroupMetadata */],\n        \"#d\": [this.groupId]\n      },\n      void 0,\n      this.relaySet\n    ).then((event) => {\n      if (event) {\n        this.metadata = NDKSimpleGroupMetadata.from(event);\n      } else {\n        this.metadata = new NDKSimpleGroupMetadata(this.ndk);\n        this.metadata.dTag = this.groupId;\n      }\n    }).finally(() => {\n      this.fetchingMetadata = void 0;\n    }).catch(() => {\n      throw new Error(`Failed to fetch metadata for group ${this.groupId}`);\n    });\n    return this.fetchingMetadata;\n  }\n};\nfunction randomId(length) {\n  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  const charsLength = chars.length;\n  let result = \"\";\n  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * charsLength));\n  }\n  return result;\n}\n\n// src/app-settings/index.ts\nvar NDKAppSettings = class _NDKAppSettings extends NDKEvent {\n  appName;\n  settings = {};\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30078 /* AppSpecificData */;\n    this.dTag ??= this.appName;\n    if (this.content.length > 0) {\n      try {\n        this.settings = JSON.parse(this.content);\n      } catch (error) {\n        console.error(\"Error parsing app settings\", error);\n      }\n    }\n  }\n  static from(event) {\n    return new _NDKAppSettings(event.ndk, event);\n  }\n  /**\n   * Set a value for a given key.\n   *\n   * @param key\n   * @param value\n   */\n  set(key, value) {\n    this.settings[key] = value;\n  }\n  /**\n   * Get a value for a given key.\n   *\n   * @param key\n   * @returns\n   */\n  get(key) {\n    return this.settings[key];\n  }\n  async publishReplaceable(relaySet, timeoutMs, requiredRelayCount) {\n    this.content = JSON.stringify(this.settings);\n    return super.publishReplaceable(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/relay/auth-policies.ts\n\nfunction disconnect(pool, debug8) {\n  debug8 ??= debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:relay:auth-policies:disconnect\");\n  return async (relay) => {\n    debug8?.(`Relay ${relay.url} requested authentication, disconnecting`);\n    pool.removeRelay(relay.url);\n  };\n}\nasync function signAndAuth(event, relay, signer, debug8, resolve, reject) {\n  try {\n    await event.sign(signer);\n    resolve(event);\n  } catch (e) {\n    debug8?.(`Failed to publish auth event to relay ${relay.url}`, e);\n    reject(event);\n  }\n}\nfunction signIn({ ndk, signer, debug: debug8 } = {}) {\n  debug8 ??= debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:auth-policies:signIn\");\n  return async (relay, challenge) => {\n    debug8?.(`Relay ${relay.url} requested authentication, signing in`);\n    const event = new NDKEvent(ndk);\n    event.kind = 22242 /* ClientAuth */;\n    event.tags = [\n      [\"relay\", relay.url],\n      [\"challenge\", challenge]\n    ];\n    signer ??= ndk?.signer;\n    return new Promise(async (resolve, reject) => {\n      if (signer) {\n        await signAndAuth(event, relay, signer, debug8, resolve, reject);\n      } else {\n        ndk?.once(\"signer:ready\", async (signer2) => {\n          await signAndAuth(event, relay, signer2, debug8, resolve, reject);\n        });\n      }\n    });\n  };\n}\nvar NDKRelayAuthPolicies = {\n  disconnect,\n  signIn\n};\n\n// src/signers/nip07/index.ts\n\nvar NDKNip07Signer = class _NDKNip07Signer {\n  _userPromise;\n  encryptionQueue = [];\n  encryptionProcessing = false;\n  debug;\n  waitTimeout;\n  _pubkey;\n  ndk;\n  _user;\n  /**\n   * @param waitTimeout - The timeout in milliseconds to wait for the NIP-07 to become available\n   */\n  constructor(waitTimeout = 1e3, ndk) {\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:nip07\");\n    this.waitTimeout = waitTimeout;\n    this.ndk = ndk;\n  }\n  get pubkey() {\n    if (!this._pubkey) throw new Error(\"Not ready\");\n    return this._pubkey;\n  }\n  async blockUntilReady() {\n    await this.waitForExtension();\n    const pubkey = await window.nostr?.getPublicKey();\n    if (!pubkey) {\n      throw new Error(\"User rejected access\");\n    }\n    this._pubkey = pubkey;\n    let user;\n    if (this.ndk) user = this.ndk.getUser({ pubkey });\n    else user = new NDKUser({ pubkey });\n    this._user = user;\n    return user;\n  }\n  /**\n   * Getter for the user property.\n   * @returns The NDKUser instance.\n   */\n  async user() {\n    if (!this._userPromise) {\n      this._userPromise = this.blockUntilReady();\n    }\n    return this._userPromise;\n  }\n  get userSync() {\n    if (!this._user) throw new Error(\"User not ready\");\n    return this._user;\n  }\n  /**\n   * Signs the given Nostr event.\n   * @param event - The Nostr event to be signed.\n   * @returns The signature of the signed event.\n   * @throws Error if the NIP-07 is not available on the window object.\n   */\n  async sign(event) {\n    await this.waitForExtension();\n    const signedEvent = await window.nostr?.signEvent(event);\n    if (!signedEvent) throw new Error(\"Failed to sign event\");\n    return signedEvent.sig;\n  }\n  async relays(ndk) {\n    await this.waitForExtension();\n    const relays = await window.nostr?.getRelays?.() || {};\n    const activeRelays = [];\n    for (const url of Object.keys(relays)) {\n      if (relays[url].read && relays[url].write) {\n        activeRelays.push(url);\n      }\n    }\n    return activeRelays.map((url) => new NDKRelay(url, ndk?.relayAuthDefaultPolicy, ndk));\n  }\n  async encryptionEnabled(nip) {\n    const enabled = [];\n    if ((!nip || nip === \"nip04\") && Boolean(window.nostr?.nip04)) enabled.push(\"nip04\");\n    if ((!nip || nip === \"nip44\") && Boolean(window.nostr?.nip44)) enabled.push(\"nip44\");\n    return enabled;\n  }\n  async encrypt(recipient, value, nip = \"nip04\") {\n    if (!await this.encryptionEnabled(nip))\n      throw new Error(`${nip}encryption is not available from your browser extension`);\n    await this.waitForExtension();\n    const recipientHexPubKey = recipient.pubkey;\n    return this.queueEncryption(nip, \"encrypt\", recipientHexPubKey, value);\n  }\n  async decrypt(sender, value, nip = \"nip04\") {\n    if (!await this.encryptionEnabled(nip))\n      throw new Error(`${nip}encryption is not available from your browser extension`);\n    await this.waitForExtension();\n    const senderHexPubKey = sender.pubkey;\n    return this.queueEncryption(nip, \"decrypt\", senderHexPubKey, value);\n  }\n  async queueEncryption(scheme, method, counterpartyHexpubkey, value) {\n    return new Promise((resolve, reject) => {\n      this.encryptionQueue.push({\n        scheme,\n        method,\n        counterpartyHexpubkey,\n        value,\n        resolve,\n        reject\n      });\n      if (!this.encryptionProcessing) {\n        this.processEncryptionQueue();\n      }\n    });\n  }\n  async processEncryptionQueue(item, retries = 0) {\n    if (!item && this.encryptionQueue.length === 0) {\n      this.encryptionProcessing = false;\n      return;\n    }\n    this.encryptionProcessing = true;\n    const currentItem = item || this.encryptionQueue.shift();\n    if (!currentItem) {\n      this.encryptionProcessing = false;\n      return;\n    }\n    const { scheme, method, counterpartyHexpubkey, value, resolve, reject } = currentItem;\n    this.debug(\"Processing encryption queue item\", {\n      method,\n      counterpartyHexpubkey,\n      value\n    });\n    try {\n      const result = await window.nostr?.[scheme]?.[method](counterpartyHexpubkey, value);\n      if (!result) throw new Error(\"Failed to encrypt/decrypt\");\n      resolve(result);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      if (errorMessage.includes(\"call already executing\") && retries < 5) {\n        this.debug(\"Retrying encryption queue item\", {\n          method,\n          counterpartyHexpubkey,\n          value,\n          retries\n        });\n        setTimeout(() => {\n          this.processEncryptionQueue(currentItem, retries + 1);\n        }, 50 * retries);\n        return;\n      }\n      reject(error instanceof Error ? error : new Error(errorMessage));\n    }\n    this.processEncryptionQueue();\n  }\n  waitForExtension() {\n    return new Promise((resolve, reject) => {\n      if (window.nostr) {\n        resolve();\n        return;\n      }\n      let timerId;\n      const intervalId = setInterval(() => {\n        if (window.nostr) {\n          clearTimeout(timerId);\n          clearInterval(intervalId);\n          resolve();\n        }\n      }, 100);\n      timerId = setTimeout(() => {\n        clearInterval(intervalId);\n        reject(new Error(\"NIP-07 extension not available\"));\n      }, this.waitTimeout);\n    });\n  }\n  /**\n   * Serializes the signer type into a storable format.\n   * NIP-07 signers don't have persistent state to serialize beyond their type.\n   * @returns A JSON string containing the type.\n   */\n  toPayload() {\n    const payload = {\n      type: \"nip07\",\n      payload: \"\"\n      // No specific payload needed for NIP-07\n    };\n    return JSON.stringify(payload);\n  }\n  /**\n   * Deserializes the signer from a payload string.\n   * Creates a new NDKNip07Signer instance.\n   * @param payloadString The JSON string obtained from toPayload().\n   * @param ndk Optional NDK instance.\n   * @returns An instance of NDKNip07Signer.\n   */\n  static async fromPayload(payloadString, ndk) {\n    const payload = JSON.parse(payloadString);\n    if (payload.type !== \"nip07\") {\n      throw new Error(`Invalid payload type: expected 'nip07', got ${payload.type}`);\n    }\n    return new _NDKNip07Signer(void 0, ndk);\n  }\n};\n\n// src/signers/nip46/backend/index.ts\n\n\n// src/signers/nip46/rpc.ts\n\nvar NDKNostrRpc = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  signer;\n  relaySet;\n  debug;\n  encryptionType = \"nip04\";\n  pool;\n  constructor(ndk, signer, debug8, relayUrls) {\n    super();\n    this.ndk = ndk;\n    this.signer = signer;\n    if (relayUrls) {\n      this.pool = new NDKPool(relayUrls, [], ndk, {\n        debug: debug8.extend(\"rpc-pool\"),\n        name: \"Nostr RPC\"\n      });\n      this.relaySet = new NDKRelaySet(/* @__PURE__ */ new Set(), ndk, this.pool);\n      for (const url of relayUrls) {\n        const relay = this.pool.getRelay(url, false, false);\n        relay.authPolicy = NDKRelayAuthPolicies.signIn({ ndk, signer, debug: debug8 });\n        this.relaySet.addRelay(relay);\n        relay.connect();\n      }\n    }\n    this.debug = debug8.extend(\"rpc\");\n  }\n  /**\n   * Subscribe to a filter. This function will resolve once the subscription is ready.\n   */\n  subscribe(filter) {\n    const sub = this.ndk.subscribe(\n      filter,\n      {\n        closeOnEose: false,\n        groupable: false,\n        cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */,\n        pool: this.pool,\n        relaySet: this.relaySet\n      },\n      false\n    );\n    sub.on(\"event\", async (event) => {\n      try {\n        const parsedEvent = await this.parseEvent(event);\n        if (parsedEvent.method) {\n          this.emit(\"request\", parsedEvent);\n        } else {\n          this.emit(`response-${parsedEvent.id}`, parsedEvent);\n        }\n      } catch (e) {\n        this.debug(\"error parsing event\", e, event.rawEvent());\n      }\n    });\n    return new Promise((resolve) => {\n      sub.on(\"eose\", () => {\n        this.debug(\"eosed\");\n        resolve(sub);\n      });\n      sub.start();\n    });\n  }\n  async parseEvent(event) {\n    if (this.encryptionType === \"nip44\" && event.content.includes(\"?iv=\")) {\n      this.encryptionType = \"nip04\";\n    } else if (this.encryptionType === \"nip04\" && !event.content.includes(\"?iv=\")) {\n      this.encryptionType = \"nip44\";\n    }\n    const remoteUser = this.ndk.getUser({ pubkey: event.pubkey });\n    remoteUser.ndk = this.ndk;\n    let decryptedContent;\n    try {\n      decryptedContent = await this.signer.decrypt(remoteUser, event.content, this.encryptionType);\n    } catch (_e) {\n      const otherEncryptionType = this.encryptionType === \"nip04\" ? \"nip44\" : \"nip04\";\n      decryptedContent = await this.signer.decrypt(remoteUser, event.content, otherEncryptionType);\n      this.encryptionType = otherEncryptionType;\n    }\n    const parsedContent = JSON.parse(decryptedContent);\n    const { id, method, params, result, error } = parsedContent;\n    if (method) {\n      return { id, pubkey: event.pubkey, method, params, event };\n    }\n    return { id, result, error, event };\n  }\n  async sendResponse(id, remotePubkey, result, kind = 24133 /* NostrConnect */, error) {\n    const res = { id, result };\n    if (error) {\n      res.error = error;\n    }\n    const localUser = await this.signer.user();\n    const remoteUser = this.ndk.getUser({ pubkey: remotePubkey });\n    const event = new NDKEvent(this.ndk, {\n      kind,\n      content: JSON.stringify(res),\n      tags: [[\"p\", remotePubkey]],\n      pubkey: localUser.pubkey\n    });\n    event.content = await this.signer.encrypt(remoteUser, event.content, this.encryptionType);\n    await event.sign(this.signer);\n    await event.publish(this.relaySet);\n  }\n  /**\n   * Sends a request.\n   * @param remotePubkey\n   * @param method\n   * @param params\n   * @param kind\n   * @param id\n   */\n  async sendRequest(remotePubkey, method, params = [], kind = 24133, cb) {\n    const id = Math.random().toString(36).substring(7);\n    const localUser = await this.signer.user();\n    const remoteUser = this.ndk.getUser({ pubkey: remotePubkey });\n    const request = { id, method, params };\n    const promise = new Promise(() => {\n      const responseHandler = (response) => {\n        if (response.result === \"auth_url\") {\n          this.once(`response-${id}`, responseHandler);\n          this.emit(\"authUrl\", response.error);\n        } else if (cb) {\n          cb(response);\n        }\n      };\n      this.once(`response-${id}`, responseHandler);\n    });\n    const event = new NDKEvent(this.ndk, {\n      kind,\n      content: JSON.stringify(request),\n      tags: [[\"p\", remotePubkey]],\n      pubkey: localUser.pubkey\n    });\n    event.content = await this.signer.encrypt(remoteUser, event.content, this.encryptionType);\n    await event.sign(this.signer);\n    await event.publish(this.relaySet);\n    return promise;\n  }\n};\n\n// src/signers/nip46/backend/connect.ts\nvar ConnectEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [_, token] = params;\n    const debug8 = backend.debug.extend(\"connect\");\n    debug8(`connection request from ${remotePubkey}`);\n    if (token && backend.applyToken) {\n      debug8(\"applying token\");\n      await backend.applyToken(remotePubkey, token);\n    }\n    if (await backend.pubkeyAllowed({\n      id,\n      pubkey: remotePubkey,\n      method: \"connect\",\n      params: token\n    })) {\n      debug8(`connection request from ${remotePubkey} allowed`);\n      return \"ack\";\n    }\n    debug8(`connection request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n};\n\n// src/signers/nip46/backend/get-public-key.ts\nvar GetPublicKeyHandlingStrategy = class {\n  async handle(backend, _id, _remotePubkey, _params) {\n    return backend.localUser?.pubkey;\n  }\n};\n\n// src/signers/nip46/backend/nip04-decrypt.ts\nvar Nip04DecryptHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [senderPubkey, payload] = params;\n    const senderUser = new NDKUser({ pubkey: senderPubkey });\n    const decryptedPayload = await decrypt2(backend, id, remotePubkey, senderUser, payload);\n    return decryptedPayload;\n  }\n};\nasync function decrypt2(backend, id, remotePubkey, senderUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip04_decrypt\",\n    params: payload\n  })) {\n    backend.debug(`decrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.decrypt(senderUser, payload, \"nip04\");\n}\n\n// src/signers/nip46/backend/nip04-encrypt.ts\nvar Nip04EncryptHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [recipientPubkey, payload] = params;\n    const recipientUser = new NDKUser({ pubkey: recipientPubkey });\n    const encryptedPayload = await encrypt2(backend, id, remotePubkey, recipientUser, payload);\n    return encryptedPayload;\n  }\n};\nasync function encrypt2(backend, id, remotePubkey, recipientUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip04_encrypt\",\n    params: payload\n  })) {\n    backend.debug(`encrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.encrypt(recipientUser, payload, \"nip04\");\n}\n\n// src/signers/nip46/backend/nip44-decrypt.ts\nvar Nip04DecryptHandlingStrategy2 = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [senderPubkey, payload] = params;\n    const senderUser = new NDKUser({ pubkey: senderPubkey });\n    const decryptedPayload = await decrypt3(backend, id, remotePubkey, senderUser, payload);\n    return decryptedPayload;\n  }\n};\nasync function decrypt3(backend, id, remotePubkey, senderUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip44_decrypt\",\n    params: payload\n  })) {\n    backend.debug(`decrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.decrypt(senderUser, payload, \"nip44\");\n}\n\n// src/signers/nip46/backend/nip44-encrypt.ts\nvar Nip04EncryptHandlingStrategy2 = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [recipientPubkey, payload] = params;\n    const recipientUser = new NDKUser({ pubkey: recipientPubkey });\n    const encryptedPayload = await encrypt3(backend, id, remotePubkey, recipientUser, payload);\n    return encryptedPayload;\n  }\n};\nasync function encrypt3(backend, id, remotePubkey, recipientUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip44_encrypt\",\n    params: payload\n  })) {\n    backend.debug(`encrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.encrypt(recipientUser, payload, \"nip44\");\n}\n\n// src/signers/nip46/backend/ping.ts\nvar PingEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, _params) {\n    const debug8 = backend.debug.extend(\"ping\");\n    debug8(`ping request from ${remotePubkey}`);\n    if (await backend.pubkeyAllowed({ id, pubkey: remotePubkey, method: \"ping\" })) {\n      debug8(`connection request from ${remotePubkey} allowed`);\n      return \"pong\";\n    }\n    debug8(`connection request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n};\n\n// src/signers/nip46/backend/sign-event.ts\nvar SignEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const event = await signEvent(backend, id, remotePubkey, params);\n    if (!event) return void 0;\n    return JSON.stringify(await event.toNostrEvent());\n  }\n};\nasync function signEvent(backend, id, remotePubkey, params) {\n  const [eventString] = params;\n  backend.debug(`sign event request from ${remotePubkey}`);\n  const event = new NDKEvent(backend.ndk, JSON.parse(eventString));\n  backend.debug(\"event to sign\", event.rawEvent());\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"sign_event\",\n    params: event\n  })) {\n    backend.debug(`sign event request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  backend.debug(`sign event request from ${remotePubkey} allowed`);\n  await event.sign(backend.signer);\n  return event;\n}\n\n// src/signers/nip46/backend/index.ts\nvar NDKNip46Backend = class {\n  ndk;\n  signer;\n  localUser;\n  debug;\n  rpc;\n  permitCallback;\n  relayUrls;\n  /**\n   * @param ndk The NDK instance to use\n   * @param privateKeyOrSigner The private key or signer of the npub that wants to be published as\n   * @param permitCallback Callback executed when permission is requested\n   */\n  constructor(ndk, privateKeyOrSigner, permitCallback, relayUrls) {\n    this.ndk = ndk;\n    if (privateKeyOrSigner instanceof Uint8Array) {\n      this.signer = new NDKPrivateKeySigner(privateKeyOrSigner);\n    } else if (privateKeyOrSigner instanceof String) {\n      this.signer = new NDKPrivateKeySigner((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(privateKeyOrSigner));\n    } else if (privateKeyOrSigner instanceof NDKPrivateKeySigner) {\n      this.signer = privateKeyOrSigner;\n    } else {\n      throw new Error(\"Invalid signer\");\n    }\n    this.debug = ndk.debug.extend(\"nip46:backend\");\n    this.relayUrls = relayUrls ?? Array.from(ndk.pool.relays.keys());\n    this.rpc = new NDKNostrRpc(ndk, this.signer, this.debug, this.relayUrls);\n    this.permitCallback = permitCallback;\n  }\n  /**\n   * This method starts the backend, which will start listening for incoming\n   * requests.\n   */\n  async start() {\n    this.localUser = await this.signer.user();\n    const sub = this.ndk.subscribe(\n      {\n        kinds: [24133],\n        \"#p\": [this.localUser.pubkey]\n      },\n      { closeOnEose: false }\n    );\n    sub.on(\"event\", (e) => this.handleIncomingEvent(e));\n  }\n  handlers = {\n    connect: new ConnectEventHandlingStrategy(),\n    sign_event: new SignEventHandlingStrategy(),\n    nip04_encrypt: new Nip04EncryptHandlingStrategy(),\n    nip04_decrypt: new Nip04DecryptHandlingStrategy(),\n    nip44_encrypt: new Nip04EncryptHandlingStrategy2(),\n    nip44_decrypt: new Nip04DecryptHandlingStrategy2(),\n    get_public_key: new GetPublicKeyHandlingStrategy(),\n    ping: new PingEventHandlingStrategy()\n  };\n  /**\n   * Enables the user to set a custom strategy for handling incoming events.\n   * @param method - The method to set the strategy for\n   * @param strategy - The strategy to set\n   */\n  setStrategy(method, strategy) {\n    this.handlers[method] = strategy;\n  }\n  /**\n   * Overload this method to apply tokens, which can\n   * wrap permission sets to be applied to a pubkey.\n   * @param pubkey public key to apply token to\n   * @param token token to apply\n   */\n  async applyToken(_pubkey, _token) {\n    throw new Error(\"connection token not supported\");\n  }\n  async handleIncomingEvent(event) {\n    const { id, method, params } = await this.rpc.parseEvent(event);\n    const remotePubkey = event.pubkey;\n    let response;\n    this.debug(\"incoming event\", { id, method, params });\n    if (!event.verifySignature(false)) {\n      this.debug(\"invalid signature\", event.rawEvent());\n      return;\n    }\n    const strategy = this.handlers[method];\n    if (strategy) {\n      try {\n        response = await strategy.handle(this, id, remotePubkey, params);\n      } catch (e) {\n        this.debug(\"error handling event\", e, { id, method, params });\n        this.rpc.sendResponse(id, remotePubkey, \"error\", void 0, e.message);\n      }\n    } else {\n      this.debug(\"unsupported method\", { method, params });\n    }\n    if (response) {\n      this.debug(`sending response to ${remotePubkey}`, response);\n      this.rpc.sendResponse(id, remotePubkey, response);\n    } else {\n      this.rpc.sendResponse(id, remotePubkey, \"error\", void 0, \"Not authorized\");\n    }\n  }\n  /**\n   * This method should be overriden by the user to allow or reject incoming\n   * connections.\n   */\n  async pubkeyAllowed(params) {\n    return this.permitCallback(params);\n  }\n};\n\n// src/signers/nip46/index.ts\n\n\n// src/signers/deserialization.ts\nvar signerRegistry = /* @__PURE__ */ new Map();\nsignerRegistry.set(\"private-key\", NDKPrivateKeySigner);\nsignerRegistry.set(\"nip07\", NDKNip07Signer);\nsignerRegistry.set(\"nip46\", NDKNip46Signer);\nasync function ndkSignerFromPayload(payloadString, ndk) {\n  let parsed;\n  try {\n    parsed = JSON.parse(payloadString);\n  } catch (e) {\n    throw new Error(`Failed to parse signer payload: ${e instanceof Error ? e.message : String(e)}`);\n  }\n  const SignerClass = signerRegistry.get(parsed.type);\n  if (!SignerClass) {\n    throw new Error(`Unknown signer type: ${parsed.type}`);\n  }\n  try {\n    return await SignerClass.fromPayload(payloadString, ndk);\n  } catch (e) {\n    const errorMsg = e instanceof Error ? e.message : String(e);\n    throw new Error(`Failed to deserialize signer type ${parsed.type}: ${errorMsg}`);\n  }\n}\n\n// src/signers/nip46/index.ts\nvar NDKNip46Signer = class _NDKNip46Signer extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  _user;\n  /**\n   * The pubkey of the bunker that will be providing signatures\n   */\n  bunkerPubkey;\n  /**\n   * The pubkey of the user that events will be published as\n   */\n  userPubkey;\n  get pubkey() {\n    if (!this.userPubkey) throw new Error(\"Not ready\");\n    return this.userPubkey;\n  }\n  /**\n   * An optional secret value provided to connect to the bunker\n   */\n  secret;\n  localSigner;\n  nip05;\n  rpc;\n  debug;\n  relayUrls;\n  subscription;\n  /**\n   * @param ndk - The NDK instance to use\n   * @param userOrConnectionToken - The public key, or a connection token, of the npub that wants to be published as\n   * @param localSigner - The signer that will be used to request events to be signed\n   */\n  constructor(ndk, userOrConnectionToken, localSigner) {\n    super();\n    this.ndk = ndk;\n    this.debug = ndk.debug.extend(\"nip46:signer\");\n    if (userOrConnectionToken.startsWith(\"bunker://\")) {\n      this.connectionTokenInit(userOrConnectionToken);\n    } else {\n      this.nip05Init(userOrConnectionToken);\n    }\n    if (!localSigner) {\n      this.localSigner = NDKPrivateKeySigner.generate();\n    } else {\n      this.localSigner = localSigner;\n    }\n    this.rpc = new NDKNostrRpc(this.ndk, this.localSigner, this.debug, this.relayUrls);\n  }\n  connectionTokenInit(connectionToken) {\n    const bunkerUrl = new URL(connectionToken);\n    const bunkerPubkey = bunkerUrl.hostname || bunkerUrl.pathname.replace(/^\\/\\//, \"\");\n    const userPubkey = bunkerUrl.searchParams.get(\"pubkey\");\n    const relayUrls = bunkerUrl.searchParams.getAll(\"relay\");\n    const secret = bunkerUrl.searchParams.get(\"secret\");\n    this.bunkerPubkey = bunkerPubkey;\n    this.userPubkey = userPubkey;\n    this.relayUrls = relayUrls;\n    this.secret = secret;\n  }\n  nip05Init(nip05) {\n    this.nip05 = nip05;\n  }\n  /**\n   * We start listening for events from the bunker\n   */\n  async startListening() {\n    if (this.subscription) return;\n    const localUser = await this.localSigner.user();\n    if (!localUser) throw new Error(\"Local signer not ready\");\n    this.subscription = await this.rpc.subscribe({\n      kinds: [24133 /* NostrConnect */],\n      \"#p\": [localUser.pubkey]\n    });\n  }\n  /**\n   * Get the user that is being published as\n   */\n  async user() {\n    if (this._user) return this._user;\n    return this.blockUntilReady();\n  }\n  get userSync() {\n    if (!this._user) throw new Error(\"Remote user not ready synchronously\");\n    return this._user;\n  }\n  async blockUntilReady() {\n    if (this.nip05 && !this.userPubkey) {\n      const user = await NDKUser.fromNip05(this.nip05, this.ndk);\n      if (user) {\n        this._user = user;\n        this.userPubkey = user.pubkey;\n        this.relayUrls = user.nip46Urls;\n        this.rpc = new NDKNostrRpc(this.ndk, this.localSigner, this.debug, this.relayUrls);\n      }\n    }\n    if (!this.bunkerPubkey && this.userPubkey) {\n      this.bunkerPubkey = this.userPubkey;\n    } else if (!this.bunkerPubkey) {\n      throw new Error(\"Bunker pubkey not set\");\n    }\n    await this.startListening();\n    this.rpc.on(\"authUrl\", (...props) => {\n      this.emit(\"authUrl\", ...props);\n    });\n    return new Promise((resolve, reject) => {\n      const connectParams = [this.userPubkey ?? \"\"];\n      if (this.secret) connectParams.push(this.secret);\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(this.bunkerPubkey, \"connect\", connectParams, 24133, (response) => {\n        if (response.result === \"ack\") {\n          this.getPublicKey().then((pubkey) => {\n            this.userPubkey = pubkey;\n            this._user = this.ndk.getUser({ pubkey });\n            resolve(this._user);\n          });\n        } else {\n          reject(response.error);\n        }\n      });\n    });\n  }\n  async getPublicKey() {\n    if (this.userPubkey) return this.userPubkey;\n    return new Promise((resolve, _reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(this.bunkerPubkey, \"get_public_key\", [], 24133, (response) => {\n        resolve(response.result);\n      });\n    });\n  }\n  async encryptionEnabled(scheme) {\n    if (scheme) return [scheme];\n    return Promise.resolve([\"nip04\", \"nip44\"]);\n  }\n  async encrypt(recipient, value, scheme = \"nip04\") {\n    return this.encryption(recipient, value, scheme, \"encrypt\");\n  }\n  async decrypt(sender, value, scheme = \"nip04\") {\n    return this.encryption(sender, value, scheme, \"decrypt\");\n  }\n  async encryption(peer, value, scheme, method) {\n    const promise = new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        `${scheme}_${method}`,\n        [peer.pubkey, value],\n        24133,\n        (response) => {\n          if (!response.error) {\n            resolve(response.result);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n    return promise;\n  }\n  async sign(event) {\n    const promise = new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"sign_event\",\n        [JSON.stringify(event)],\n        24133,\n        (response) => {\n          if (!response.error) {\n            const json = JSON.parse(response.result);\n            resolve(json.sig);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n    return promise;\n  }\n  /**\n   * Allows creating a new account on the remote server.\n   * @param username Desired username for the NIP-05\n   * @param domain Desired domain for the NIP-05\n   * @param email Email address to associate with this account -- Remote servers may use this for recovery\n   * @returns The public key of the newly created account\n   */\n  async createAccount(username, domain, email) {\n    await this.startListening();\n    const req = [];\n    if (username) req.push(username);\n    if (domain) req.push(domain);\n    if (email) req.push(email);\n    return new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"create_account\",\n        req,\n        24133 /* NostrConnect */,\n        (response) => {\n          if (!response.error) {\n            const pubkey = response.result;\n            resolve(pubkey);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n  }\n  /**\n   * Serializes the signer's connection details and local signer state.\n   * @returns A JSON string containing the type, connection info, and local signer payload.\n   */\n  toPayload() {\n    if (!this.bunkerPubkey || !this.userPubkey) {\n      throw new Error(\"NIP-46 signer is not fully initialized for serialization\");\n    }\n    const payload = {\n      type: \"nip46\",\n      payload: {\n        bunkerPubkey: this.bunkerPubkey,\n        userPubkey: this.userPubkey,\n        relayUrls: this.relayUrls,\n        secret: this.secret,\n        localSignerPayload: this.localSigner.toPayload(),\n        // Store nip05 if it was used for initialization, otherwise null\n        nip05: this.nip05 || null\n      }\n    };\n    return JSON.stringify(payload);\n  }\n  /**\n   * Deserializes the signer from a payload string.\n   * @param payloadString The JSON string obtained from toPayload().\n   * @param ndk The NDK instance, required for NIP-46.\n   * @returns An instance of NDKNip46Signer.\n   */\n  static async fromPayload(payloadString, ndk) {\n    if (!ndk) {\n      throw new Error(\"NDK instance is required to deserialize NIP-46 signer\");\n    }\n    const parsed = JSON.parse(payloadString);\n    if (parsed.type !== \"nip46\") {\n      throw new Error(`Invalid payload type: expected 'nip46', got ${parsed.type}`);\n    }\n    const payload = parsed.payload;\n    if (!payload || typeof payload !== \"object\" || !payload.localSignerPayload) {\n      throw new Error(\"Invalid payload content for nip46 signer\");\n    }\n    const localSigner = await ndkSignerFromPayload(payload.localSignerPayload, ndk);\n    if (!localSigner) {\n      throw new Error(\"Failed to deserialize local signer for NIP-46\");\n    }\n    let signer;\n    if (payload.nip05) {\n      signer = new _NDKNip46Signer(ndk, payload.nip05, localSigner);\n      signer.userPubkey = payload.userPubkey;\n      signer.bunkerPubkey = payload.bunkerPubkey;\n      signer.relayUrls = payload.relayUrls;\n      signer.secret = payload.secret;\n    } else {\n      signer = new _NDKNip46Signer(ndk, payload.userPubkey, localSigner);\n      signer.bunkerPubkey = payload.bunkerPubkey;\n      signer.relayUrls = payload.relayUrls;\n      signer.secret = payload.secret;\n    }\n    return signer;\n  }\n};\n\n// src/dvm/schedule.ts\nfunction addRelays(event, relays) {\n  const tags = [];\n  if (!relays || relays.length === 0) {\n    const poolRelays = event.ndk?.pool.relays;\n    relays = poolRelays ? Object.keys(poolRelays) : void 0;\n  }\n  if (relays && relays.length > 0) tags.push([\"relays\", ...relays]);\n  return tags;\n}\nasync function dvmSchedule(events, dvm, relays, encrypted = true, waitForConfirmationForMs) {\n  if (!Array.isArray(events)) {\n    events = [events];\n  }\n  const ndk = events[0].ndk;\n  if (!ndk) throw new Error(\"NDK not set\");\n  for (const event of events) {\n    if (!event.sig) throw new Error(\"Event not signed\");\n    if (!event.created_at) throw new Error(\"Event has no date\");\n    if (!dvm) throw new Error(\"No DVM specified\");\n    if (event.created_at <= Date.now() / 1e3) throw new Error(\"Event needs to be in the future\");\n  }\n  const scheduleEvent = new NDKDVMRequest(ndk, {\n    kind: 5905 /* DVMEventSchedule */\n  });\n  for (const event of events) {\n    scheduleEvent.addInput(JSON.stringify(event.rawEvent()), \"text\");\n  }\n  scheduleEvent.tags.push(...addRelays(events[0], relays));\n  if (encrypted) {\n    await scheduleEvent.encryption(dvm);\n  } else {\n    scheduleEvent.dvm = dvm;\n  }\n  await scheduleEvent.sign();\n  let res;\n  if (waitForConfirmationForMs) {\n    res = ndk.subscribe(\n      {\n        kinds: [5905 /* DVMEventSchedule */ + 1e3, 7e3 /* DVMJobFeedback */],\n        ...scheduleEvent.filter()\n      },\n      { groupable: false, closeOnEose: false }\n    );\n  }\n  const timeoutPromise = new Promise((reject) => {\n    setTimeout(() => {\n      res?.stop();\n      reject(\"Timeout waiting for an answer from the DVM\");\n    }, waitForConfirmationForMs);\n  });\n  const schedulePromise = new Promise((resolve, reject) => {\n    if (waitForConfirmationForMs) {\n      res?.on(\"event\", async (e) => {\n        res?.stop();\n        if (e.kind === 7e3 /* DVMJobFeedback */) {\n          const feedback = await NDKDVMJobFeedback.from(e);\n          if (feedback.status === \"error\") {\n            const statusTag = feedback.getMatchingTags(\"status\");\n            reject(statusTag?.[2] ?? feedback);\n          } else {\n            resolve(feedback);\n          }\n        }\n        resolve(e);\n      });\n    }\n    scheduleEvent.publish().then(() => {\n      if (!waitForConfirmationForMs) resolve(void 0);\n    });\n  });\n  return new Promise((resolve, reject) => {\n    if (waitForConfirmationForMs) {\n      Promise.race([timeoutPromise, schedulePromise]).then((e) => {\n        resolve(e);\n      }).catch(reject);\n    } else {\n      schedulePromise.then(resolve);\n    }\n  });\n}\n\n// src/ndk/index.ts\n\n\n\n// src/events/dedup.ts\nfunction dedup(event1, event2) {\n  if (event1.created_at > event2.created_at) {\n    return event1;\n  }\n  return event2;\n}\n\n// src/outbox/tracker.ts\n\n\n\n// src/utils/get-users-relay-list.ts\nasync function getRelayListForUser(pubkey, ndk) {\n  const list = await getRelayListForUsers([pubkey], ndk);\n  return list.get(pubkey);\n}\nasync function getRelayListForUsers(pubkeys, ndk, skipCache = false, timeout = 1e3) {\n  const pool = ndk.outboxPool || ndk.pool;\n  const set = /* @__PURE__ */ new Set();\n  for (const relay of pool.relays.values()) set.add(relay);\n  const relayLists = /* @__PURE__ */ new Map();\n  const fromContactList = /* @__PURE__ */ new Map();\n  const relaySet = new NDKRelaySet(set, ndk);\n  if (ndk.cacheAdapter?.locking && !skipCache) {\n    const cachedList = await ndk.fetchEvents(\n      { kinds: [3, 10002], authors: Array.from(new Set(pubkeys)) },\n      { cacheUsage: \"ONLY_CACHE\" /* ONLY_CACHE */, subId: \"ndk-relay-list-fetch\" }\n    );\n    for (const relayList of cachedList) {\n      if (relayList.kind === 10002) relayLists.set(relayList.pubkey, NDKRelayList.from(relayList));\n    }\n    for (const relayList of cachedList) {\n      if (relayList.kind === 3) {\n        if (relayLists.has(relayList.pubkey)) continue;\n        const list = relayListFromKind3(ndk, relayList);\n        if (list) fromContactList.set(relayList.pubkey, list);\n      }\n    }\n    pubkeys = pubkeys.filter((pubkey) => !relayLists.has(pubkey) && !fromContactList.has(pubkey));\n  }\n  if (pubkeys.length === 0) return relayLists;\n  const relayListEvents = /* @__PURE__ */ new Map();\n  const contactListEvents = /* @__PURE__ */ new Map();\n  return new Promise((resolve) => {\n    const handleSubscription = async () => {\n      const subscribeOpts = {\n        closeOnEose: true,\n        pool,\n        groupable: true,\n        subId: \"ndk-relay-list-fetch\",\n        addSinceFromCache: true,\n        relaySet\n      };\n      if (relaySet) subscribeOpts.relaySet = relaySet;\n      ndk.subscribe({ kinds: [3, 10002], authors: pubkeys }, subscribeOpts, {\n        onEvent: (event) => {\n          if (event.kind === 10002 /* RelayList */) {\n            const existingEvent = relayListEvents.get(event.pubkey);\n            if (existingEvent && existingEvent.created_at > event.created_at) return;\n            relayListEvents.set(event.pubkey, event);\n          } else if (event.kind === 3 /* Contacts */) {\n            const existingEvent = contactListEvents.get(event.pubkey);\n            if (existingEvent && existingEvent.created_at > event.created_at) return;\n            contactListEvents.set(event.pubkey, event);\n          }\n        },\n        onEose: () => {\n          for (const event of relayListEvents.values()) {\n            relayLists.set(event.pubkey, NDKRelayList.from(event));\n          }\n          for (const pubkey of pubkeys) {\n            if (relayLists.has(pubkey)) continue;\n            const contactList = contactListEvents.get(pubkey);\n            if (!contactList) continue;\n            const list = relayListFromKind3(ndk, contactList);\n            if (list) relayLists.set(pubkey, list);\n          }\n          resolve(relayLists);\n        }\n      });\n      setTimeout(() => {\n        resolve(relayLists);\n      }, timeout);\n    };\n    handleSubscription();\n  });\n}\n\n// src/outbox/tracker.ts\nvar OutboxItem = class {\n  /**\n   * Type of item\n   */\n  type;\n  /**\n   * The relay URLs that are of interest to this item\n   */\n  relayUrlScores;\n  readRelays;\n  writeRelays;\n  constructor(type) {\n    this.type = type;\n    this.relayUrlScores = /* @__PURE__ */ new Map();\n    this.readRelays = /* @__PURE__ */ new Set();\n    this.writeRelays = /* @__PURE__ */ new Set();\n  }\n};\nvar OutboxTracker = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  data;\n  ndk;\n  debug;\n  constructor(ndk) {\n    super();\n    this.ndk = ndk;\n    this.debug = ndk.debug.extend(\"outbox-tracker\");\n    this.data = new typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({\n      maxSize: 1e5,\n      entryExpirationTimeInMS: 2 * 60 * 1e3\n    });\n  }\n  /**\n   * Adds a list of users to the tracker.\n   * @param items\n   * @param skipCache\n   */\n  async trackUsers(items, skipCache = false) {\n    const promises = [];\n    for (let i = 0; i < items.length; i += 400) {\n      const slice = items.slice(i, i + 400);\n      const pubkeys = slice.map((item) => getKeyFromItem(item)).filter((pubkey) => !this.data.has(pubkey));\n      if (pubkeys.length === 0) continue;\n      for (const pubkey of pubkeys) {\n        this.data.set(pubkey, new OutboxItem(\"user\"));\n      }\n      promises.push(\n        new Promise((resolve) => {\n          getRelayListForUsers(pubkeys, this.ndk, skipCache).then((relayLists) => {\n            for (const [pubkey, relayList] of relayLists) {\n              let outboxItem = this.data.get(pubkey);\n              outboxItem ??= new OutboxItem(\"user\");\n              if (relayList) {\n                outboxItem.readRelays = new Set(normalize(relayList.readRelayUrls));\n                outboxItem.writeRelays = new Set(normalize(relayList.writeRelayUrls));\n                for (const relayUrl of outboxItem.readRelays) {\n                  if (this.ndk.pool.blacklistRelayUrls.has(relayUrl)) {\n                    outboxItem.readRelays.delete(relayUrl);\n                  }\n                }\n                for (const relayUrl of outboxItem.writeRelays) {\n                  if (this.ndk.pool.blacklistRelayUrls.has(relayUrl)) {\n                    outboxItem.writeRelays.delete(relayUrl);\n                  }\n                }\n                this.data.set(pubkey, outboxItem);\n              }\n            }\n          }).finally(resolve);\n        })\n      );\n    }\n    return Promise.all(promises);\n  }\n  /**\n   *\n   * @param key\n   * @param score\n   */\n  track(item, type, _skipCache = true) {\n    const key = getKeyFromItem(item);\n    type ??= getTypeFromItem(item);\n    let outboxItem = this.data.get(key);\n    if (!outboxItem) {\n      outboxItem = new OutboxItem(type);\n      if (item instanceof NDKUser) {\n        this.trackUsers([item]);\n      }\n    }\n    return outboxItem;\n  }\n};\nfunction getKeyFromItem(item) {\n  if (item instanceof NDKUser) {\n    return item.pubkey;\n  }\n  return item;\n}\nfunction getTypeFromItem(item) {\n  if (item instanceof NDKUser) {\n    return \"user\";\n  }\n  return \"kind\";\n}\n\n// src/relay/sets/utils.ts\nfunction correctRelaySet(relaySet, pool) {\n  const connectedRelays = pool.connectedRelays();\n  const includesConnectedRelay = Array.from(relaySet.relays).some((relay) => {\n    return connectedRelays.map((r) => r.url).includes(relay.url);\n  });\n  if (!includesConnectedRelay) {\n    for (const relay of connectedRelays) {\n      relaySet.addRelay(relay);\n    }\n  }\n  if (connectedRelays.length === 0) {\n    for (const relay of pool.relays.values()) {\n      relaySet.addRelay(relay);\n    }\n  }\n  return relaySet;\n}\n\n// src/subscription/manager.ts\n\nvar NDKSubscriptionManager = class {\n  subscriptions;\n  seenEvents = /* @__PURE__ */ new Map();\n  constructor() {\n    this.subscriptions = /* @__PURE__ */ new Map();\n  }\n  add(sub) {\n    this.subscriptions.set(sub.internalId, sub);\n    if (sub.onStopped) {\n    }\n    sub.onStopped = () => {\n      this.subscriptions.delete(sub.internalId);\n    };\n    sub.on(\"close\", () => {\n      this.subscriptions.delete(sub.internalId);\n    });\n  }\n  seenEvent(eventId, relay) {\n    const current = this.seenEvents.get(eventId) || [];\n    current.push(relay);\n    this.seenEvents.set(eventId, current);\n  }\n  /**\n   * Whenever an event comes in, this function is called.\n   * This function matches the received event against all the\n   * known (i.e. active) NDKSubscriptions, and if it matches,\n   * it sends the event to the subscription.\n   *\n   * This is the single place in the codebase that matches\n   * incoming events with parties interested in the event.\n   *\n   * This is also what allows for reactivity in NDK apps, such that\n   * whenever an active subscription receives an event that some\n   * other active subscription would want to receive, both receive it.\n   *\n   * TODO This also allows for subscriptions that overlap in meaning\n   * to be collapsed into one.\n   *\n   * I.e. if a subscription with filter: kinds: [1], authors: [alice]\n   * is created and EOSEs, and then a subsequent subscription with\n   * kinds: [1], authors: [alice] is created, once the second subscription\n   * EOSEs we can safely close it, increment its refCount and close it,\n   * and when the first subscription receives a new event from Alice this\n   * code will make the second subscription receive the event even though\n   * it has no active subscription on a relay.\n   * @param event Raw event received from a relay\n   * @param relay Relay that sent the event\n   * @param optimisticPublish Whether the event is coming from an optimistic publish\n   */\n  dispatchEvent(event, relay, optimisticPublish = false) {\n    if (relay) this.seenEvent(event.id, relay);\n    const subscriptions = this.subscriptions.values();\n    const matchingSubs = [];\n    for (const sub of subscriptions) {\n      if ((0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.matchFilters)(sub.filters, event)) {\n        matchingSubs.push(sub);\n      }\n    }\n    for (const sub of matchingSubs) {\n      sub.eventReceived(event, relay, false, optimisticPublish);\n    }\n  }\n};\n\n// src/ndk/active-user.ts\n\nvar debug6 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:active-user\");\nasync function getUserRelayList(user) {\n  if (!this.autoConnectUserRelays) return;\n  const userRelays = await getRelayListForUser(user.pubkey, this);\n  if (!userRelays) return;\n  for (const url of userRelays.relays) {\n    let relay = this.pool.relays.get(url);\n    if (!relay) {\n      relay = new NDKRelay(url, this.relayAuthDefaultPolicy, this);\n      this.pool.addRelay(relay);\n    }\n  }\n  return userRelays;\n}\nasync function setActiveUser(user) {\n  const pool = this.outboxPool || this.pool;\n  if (pool.connectedRelays.length > 0) {\n    setActiveUserConnected.call(this, user);\n  } else {\n    pool.once(\"connect\", () => {\n      setActiveUserConnected.call(this, user);\n    });\n  }\n}\nasync function setActiveUserConnected(user) {\n  const userRelays = await getUserRelayList.call(this, user);\n  const filters = [\n    {\n      kinds: [10006 /* BlockRelayList */],\n      authors: [user.pubkey]\n    }\n  ];\n  if (this.autoFetchUserMutelist) {\n    filters[0].kinds?.push(1e4 /* MuteList */);\n  }\n  const events = /* @__PURE__ */ new Map();\n  const relaySet = userRelays ? userRelays.relaySet : void 0;\n  this.subscribe(\n    filters,\n    { subId: \"active-user-settings\", closeOnEose: true, relaySet },\n    {\n      onEvent: (event) => {\n        const prevEvent = events.get(event.kind);\n        if (prevEvent && prevEvent.created_at >= event.created_at) return;\n        events.set(event.kind, event);\n      },\n      onEose: () => {\n        for (const event of events.values()) {\n          processEvent.call(this, event);\n        }\n      }\n    }\n  );\n}\nasync function processEvent(event) {\n  if (event.kind === 10006 /* BlockRelayList */) {\n    processBlockRelayList.call(this, event);\n  } else if (event.kind === 1e4 /* MuteList */) {\n    processMuteList.call(this, event);\n  }\n}\nfunction processBlockRelayList(event) {\n  const list = lists_default.from(event);\n  for (const item of list.items) {\n    this.pool.blacklistRelayUrls.add(item[0]);\n  }\n  debug6(\"Added %d relays to relay blacklist\", list.items.length);\n}\nfunction processMuteList(muteList) {\n  const list = lists_default.from(muteList);\n  for (const item of list.items) {\n    this.mutedIds.set(item[1], item[0]);\n  }\n  debug6(\"Added %d users to mute list\", list.items.length);\n}\n\n// src/ndk/entity.ts\n\nfunction getEntity(entity) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(entity);\n    if (decoded.type === \"npub\") return npub(this, decoded.data);\n    if (decoded.type === \"nprofile\") return nprofile(this, decoded.data);\n    return decoded;\n  } catch (_e) {\n    return null;\n  }\n}\nfunction npub(ndk, pubkey) {\n  return ndk.getUser({ pubkey });\n}\nfunction nprofile(ndk, profile) {\n  const user = ndk.getUser({ pubkey: profile.pubkey });\n  if (profile.relays) user.relayUrls = profile.relays;\n  return user;\n}\n\n// src/ndk/fetch-event-from-tag.ts\nfunction isValidHint(hint) {\n  if (!hint || hint === \"\") return false;\n  try {\n    new URL(hint);\n    return true;\n  } catch (_e) {\n    return false;\n  }\n}\nasync function fetchEventFromTag(tag, originalEvent, subOpts, fallback = {\n  type: \"timeout\"\n}) {\n  const d4 = this.debug.extend(\"fetch-event-from-tag\");\n  const [_, id, hint] = tag;\n  subOpts = {};\n  d4(\"fetching event from tag\", tag, subOpts, fallback);\n  const authorRelays = getRelaysForSync(this, originalEvent.pubkey);\n  if (authorRelays && authorRelays.size > 0) {\n    d4(\"fetching event from author relays %o\", Array.from(authorRelays));\n    const relaySet2 = NDKRelaySet.fromRelayUrls(Array.from(authorRelays), this);\n    const event2 = await this.fetchEvent(id, subOpts, relaySet2);\n    if (event2) return event2;\n  } else {\n    d4(\"no author relays found for %s\", originalEvent.pubkey, originalEvent);\n  }\n  const relaySet = calculateRelaySetsFromFilters(this, [{ ids: [id] }], this.pool);\n  d4(\"fetching event without relay hint\", relaySet);\n  const event = await this.fetchEvent(id, subOpts);\n  if (event) return event;\n  if (hint && hint !== \"\") {\n    const event2 = await this.fetchEvent(id, subOpts, this.pool.getRelay(hint, true, true, [{ ids: [id] }]));\n    if (event2) return event2;\n  }\n  let result = void 0;\n  const relay = isValidHint(hint) ? this.pool.getRelay(hint, false, true, [{ ids: [id] }]) : void 0;\n  const fetchMaybeWithRelayHint = new Promise((resolve) => {\n    this.fetchEvent(id, subOpts, relay).then(resolve);\n  });\n  if (!isValidHint(hint) || fallback.type === \"none\") {\n    return fetchMaybeWithRelayHint;\n  }\n  const fallbackFetchPromise = new Promise(async (resolve) => {\n    const fallbackRelaySet = fallback.relaySet;\n    const timeout = fallback.timeout ?? 1500;\n    const timeoutPromise = new Promise((resolve2) => setTimeout(resolve2, timeout));\n    if (fallback.type === \"timeout\") await timeoutPromise;\n    if (result) {\n      resolve(result);\n    } else {\n      d4(\"fallback fetch triggered\");\n      const fallbackEvent = await this.fetchEvent(id, subOpts, fallbackRelaySet);\n      resolve(fallbackEvent);\n    }\n  });\n  switch (fallback.type) {\n    case \"timeout\":\n      return Promise.race([fetchMaybeWithRelayHint, fallbackFetchPromise]);\n    case \"eose\":\n      result = await fetchMaybeWithRelayHint;\n      if (result) return result;\n      return fallbackFetchPromise;\n  }\n}\n\n// src/ndk/queue/index.ts\nvar Queue = class {\n  queue = [];\n  maxConcurrency;\n  processing = /* @__PURE__ */ new Set();\n  promises = /* @__PURE__ */ new Map();\n  constructor(_name, maxConcurrency) {\n    this.maxConcurrency = maxConcurrency;\n  }\n  add(item) {\n    if (this.promises.has(item.id)) {\n      return this.promises.get(item.id);\n    }\n    const promise = new Promise((resolve, reject) => {\n      this.queue.push({\n        ...item,\n        func: () => item.func().then(\n          (result) => {\n            resolve(result);\n            return result;\n          },\n          (error) => {\n            reject(error);\n            throw error;\n          }\n        )\n      });\n      this.process();\n    });\n    this.promises.set(item.id, promise);\n    promise.finally(() => {\n      this.promises.delete(item.id);\n      this.processing.delete(item.id);\n      this.process();\n    });\n    return promise;\n  }\n  process() {\n    if (this.processing.size >= this.maxConcurrency || this.queue.length === 0) {\n      return;\n    }\n    const item = this.queue.shift();\n    if (!item || this.processing.has(item.id)) {\n      return;\n    }\n    this.processing.add(item.id);\n    item.func();\n  }\n  clear() {\n    this.queue = [];\n  }\n  clearProcessing() {\n    this.processing.clear();\n  }\n  clearAll() {\n    this.clear();\n    this.clearProcessing();\n  }\n  length() {\n    return this.queue.length;\n  }\n};\n\n// src/ndk/index.ts\nvar DEFAULT_OUTBOX_RELAYS = [\"wss://purplepag.es/\", \"wss://nos.lol/\"];\nvar DEFAULT_BLACKLISTED_RELAYS = [\n  \"wss://brb.io/\",\n  // BRB\n  \"wss://nostr.mutinywallet.com/\"\n  // Don't try to read from this relay since it's a write-only relay\n  // \"wss://purplepag.es/\", // This is a hack, since this is a mostly read-only relay, but not fully. Once we have relay routing this can be removed so it only receives the supported kinds\n];\nvar NDK = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  _explicitRelayUrls;\n  blacklistRelayUrls;\n  pool;\n  outboxPool;\n  _signer;\n  _activeUser;\n  cacheAdapter;\n  debug;\n  devWriteRelaySet;\n  outboxTracker;\n  mutedIds;\n  clientName;\n  clientNip89;\n  queuesZapConfig;\n  queuesNip05;\n  asyncSigVerification = false;\n  initialValidationRatio = 1;\n  lowestValidationRatio = 1;\n  validationRatioFn;\n  subManager;\n  publishingFailureHandled = false;\n  pools = [];\n  /**\n   * Default relay-auth policy that will be used when a relay requests authentication,\n   * if no other policy is specified for that relay.\n   *\n   * @example Disconnect from relays that request authentication:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.disconnect(ndk.pool);\n   * ```\n   *\n   * @example Sign in to relays that request authentication:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.signIn({ndk})\n   * ```\n   *\n   * @example Sign in to relays that request authentication, asking the user for confirmation:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = (relay: NDKRelay) => {\n   *     const signIn = NDKAuthPolicies.signIn({ndk});\n   *     if (confirm(`Relay ${relay.url} is requesting authentication, do you want to sign in?`)) {\n   *        signIn(relay);\n   *     }\n   * }\n   * ```\n   */\n  relayAuthDefaultPolicy;\n  /**\n   * Fetch function to use for HTTP requests.\n   *\n   * @example\n   * ```typescript\n   * import fetch from \"node-fetch\";\n   *\n   * ndk.httpFetch = fetch;\n   * ```\n   */\n  httpFetch;\n  /**\n   * Provide a caller function to receive all networking traffic from relays\n   */\n  netDebug;\n  autoConnectUserRelays = true;\n  autoFetchUserMutelist = true;\n  walletConfig;\n  constructor(opts = {}) {\n    super();\n    this.debug = opts.debug || debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk\");\n    this.netDebug = opts.netDebug;\n    this._explicitRelayUrls = opts.explicitRelayUrls || [];\n    this.blacklistRelayUrls = opts.blacklistRelayUrls || DEFAULT_BLACKLISTED_RELAYS;\n    this.subManager = new NDKSubscriptionManager();\n    this.pool = new NDKPool(opts.explicitRelayUrls || [], [], this);\n    this.pool.name = \"Main\";\n    this.pool.on(\"relay:auth\", async (relay, challenge) => {\n      if (this.relayAuthDefaultPolicy) {\n        await this.relayAuthDefaultPolicy(relay, challenge);\n      }\n    });\n    this.autoConnectUserRelays = opts.autoConnectUserRelays ?? true;\n    this.autoFetchUserMutelist = opts.autoFetchUserMutelist ?? true;\n    this.clientName = opts.clientName;\n    this.clientNip89 = opts.clientNip89;\n    this.relayAuthDefaultPolicy = opts.relayAuthDefaultPolicy;\n    if (opts.enableOutboxModel) {\n      this.outboxPool = new NDKPool(opts.outboxRelayUrls || DEFAULT_OUTBOX_RELAYS, [], this, {\n        debug: this.debug.extend(\"outbox-pool\"),\n        name: \"Outbox Pool\"\n      });\n      this.outboxTracker = new OutboxTracker(this);\n    }\n    this.signer = opts.signer;\n    this.cacheAdapter = opts.cacheAdapter;\n    this.mutedIds = opts.mutedIds || /* @__PURE__ */ new Map();\n    if (opts.devWriteRelayUrls) {\n      this.devWriteRelaySet = NDKRelaySet.fromRelayUrls(opts.devWriteRelayUrls, this);\n    }\n    this.queuesZapConfig = new Queue(\"zaps\", 3);\n    this.queuesNip05 = new Queue(\"nip05\", 10);\n    this.signatureVerificationWorker = opts.signatureVerificationWorker;\n    this.initialValidationRatio = opts.initialValidationRatio || 1;\n    this.lowestValidationRatio = opts.lowestValidationRatio || 1;\n    try {\n      this.httpFetch = fetch;\n    } catch {\n    }\n  }\n  set explicitRelayUrls(urls) {\n    this._explicitRelayUrls = urls.map(normalizeRelayUrl);\n    this.pool.relayUrls = urls;\n  }\n  get explicitRelayUrls() {\n    return this._explicitRelayUrls || [];\n  }\n  set signatureVerificationWorker(worker2) {\n    this.asyncSigVerification = !!worker2;\n    if (worker2) {\n      signatureVerificationInit(worker2);\n    }\n  }\n  /**\n   * Adds an explicit relay to the pool.\n   * @param url\n   * @param relayAuthPolicy Authentication policy to use if different from the default\n   * @param connect Whether to connect to the relay automatically\n   * @returns\n   */\n  addExplicitRelay(urlOrRelay, relayAuthPolicy, connect = true) {\n    let relay;\n    if (typeof urlOrRelay === \"string\") {\n      relay = new NDKRelay(urlOrRelay, relayAuthPolicy, this);\n    } else {\n      relay = urlOrRelay;\n    }\n    this.pool.addRelay(relay, connect);\n    this.explicitRelayUrls?.push(relay.url);\n    return relay;\n  }\n  toJSON() {\n    return { relayCount: this.pool.relays.size }.toString();\n  }\n  get activeUser() {\n    return this._activeUser;\n  }\n  /**\n   * Sets the active user for this NDK instance, typically this will be\n   * called when assigning a signer to the NDK instance.\n   *\n   * This function will automatically connect to the user's relays if\n   * `autoConnectUserRelays` is set to true.\n   *\n   * It will also fetch the user's mutelist if `autoFetchUserMutelist` is set to true.\n   */\n  set activeUser(user) {\n    const differentUser = this._activeUser?.pubkey !== user?.pubkey;\n    this._activeUser = user;\n    if (user && differentUser) {\n      setActiveUser.call(this, user);\n    } else if (!user) {\n      this.mutedIds = /* @__PURE__ */ new Map();\n    }\n  }\n  get signer() {\n    return this._signer;\n  }\n  set signer(newSigner) {\n    this._signer = newSigner;\n    if (newSigner) this.emit(\"signer:ready\", newSigner);\n    newSigner?.user().then((user) => {\n      user.ndk = this;\n      this.activeUser = user;\n    });\n  }\n  /**\n   * Connect to relays with optional timeout.\n   * If the timeout is reached, the connection will be continued to be established in the background.\n   */\n  async connect(timeoutMs) {\n    if (this._signer && this.autoConnectUserRelays) {\n      this.debug(\n        \"Attempting to connect to user relays specified by signer %o\",\n        await this._signer.relays?.(this)\n      );\n      if (this._signer.relays) {\n        const relays = await this._signer.relays(this);\n        relays.forEach((relay) => this.pool.addRelay(relay));\n      }\n    }\n    const connections = [this.pool.connect(timeoutMs)];\n    if (this.outboxPool) {\n      connections.push(this.outboxPool.connect(timeoutMs));\n    }\n    this.debug(\"Connecting to relays %o\", { timeoutMs });\n    return Promise.allSettled(connections).then(() => {\n    });\n  }\n  /**\n   * Get a NDKUser object\n   *\n   * @param opts\n   * @returns\n   */\n  getUser(opts) {\n    const user = new NDKUser(opts);\n    user.ndk = this;\n    return user;\n  }\n  /**\n   * Get a NDKUser from a NIP05\n   * @param nip05 NIP-05 ID\n   * @param skipCache Skip cache\n   * @returns\n   */\n  async getUserFromNip05(nip05, skipCache = false) {\n    return NDKUser.fromNip05(nip05, this, skipCache);\n  }\n  /**\n   * Creates and starts a new subscription.\n   *\n   * Subscriptions automatically start unless `autoStart` is set to `false`.\n   * You can control automatic closing on EOSE via `opts.closeOnEose`.\n   *\n   * @param filters - A single NDKFilter object or an array of filters.\n   * @param opts - Optional NDKSubscriptionOptions to customize behavior (e.g., caching, grouping).\n   * @param handlers - Optional handlers for subscription events. Passing handlers is the preferred method of using ndk.subscribe.\n   *   - `onEvent`: Called for each event received.\n   *  - `onEvents`: Called once with an array of events when the subscription starts (from the cache).\n   *  - `onEose`: Called when the subscription receives EOSE.\n   *  For backwards compatibility, this third parameter also accepts a relaySet, the relaySet should be passed via `opts.relaySet`.\n   *\n   * @param _autoStart - For backwards compatibility, this can be a boolean indicating whether to start the subscription immediately.\n   *  This parameter is deprecated and will be removed in a future version.\n   *   - `false`: Creates the subscription but does not start it (call `subscription.start()` manually).\n   * @returns The created NDKSubscription instance.\n   *\n   * @example Basic subscription\n   * ```typescript\n   * const sub = ndk.subscribe({ kinds: [1], authors: [pubkey] });\n   * sub.on(\"event\", (event) => console.log(\"Kind 1 event:\", event.content));\n   * ```\n   *\n   * @example Subscription with options and direct handlers\n   * ```typescript\n   * const sub = ndk.subscribe(\n   *   { kinds: [0], authors: [pubkey] },\n   *   { closeOnEose: true, cacheUsage: NDKSubscriptionCacheUsage.PARALLEL },\n   *   undefined, // Use default relay set calculation\n   *   {\n   *     onEvents: (events) => { // Renamed parameter\n   *       if (events.length > 0) {\n   *         console.log(`Got ${events.length} profile events from cache:`, events[0].content);\n   *       }\n   *     },\n   *     onEvent: (event) => { // Renamed parameter\n   *       console.log(\"Got profile update from relay:\", event.content); // Clarified source\n   *     },\n   *     onEose: () => console.log(\"Profile subscription finished.\")\n   *   }\n   * );\n   * ```\n   *\n   * @since 2.13.0 `relaySet` parameter removed; pass `relaySet` or `relayUrls` via `opts`.\n   */\n  subscribe(filters, opts, autoStartOrRelaySet = true, _autoStart = true) {\n    let _relaySet = opts?.relaySet;\n    let autoStart = _autoStart;\n    if (autoStartOrRelaySet instanceof NDKRelaySet) {\n      console.warn(\"relaySet is deprecated, use opts.relaySet instead. This will be removed in version v2.14.0\");\n      _relaySet = autoStartOrRelaySet;\n      autoStart = _autoStart;\n    } else if (typeof autoStartOrRelaySet === \"boolean\" || typeof autoStartOrRelaySet === \"object\") {\n      autoStart = autoStartOrRelaySet;\n    }\n    const subscription = new NDKSubscription(this, filters, { relaySet: _relaySet, ...opts });\n    this.subManager.add(subscription);\n    const pool = subscription.pool;\n    if (subscription.relaySet) {\n      for (const relay of subscription.relaySet.relays) {\n        pool.useTemporaryRelay(relay, void 0, subscription.filters);\n      }\n    }\n    if (this.outboxPool && subscription.hasAuthorsFilter()) {\n      const authors = subscription.filters.filter((filter) => filter.authors && filter.authors?.length > 0).flatMap((filter) => filter.authors);\n      this.outboxTracker?.trackUsers(authors);\n    }\n    if (autoStart) {\n      let eventsHandler;\n      if (typeof autoStart === \"object\") {\n        if (autoStart.onEvent) subscription.on(\"event\", autoStart.onEvent);\n        if (autoStart.onEose) subscription.on(\"eose\", autoStart.onEose);\n        if (autoStart.onEvents) eventsHandler = autoStart.onEvents;\n      }\n      setTimeout(() => {\n        const cachedEvents = subscription.start(!eventsHandler);\n        if (cachedEvents && cachedEvents.length > 0 && !!eventsHandler) eventsHandler(cachedEvents);\n      }, 0);\n    }\n    return subscription;\n  }\n  /**\n   * Publish an event to a relay\n   * @param event event to publish\n   * @param relaySet explicit relay set to use\n   * @param timeoutMs timeout in milliseconds to wait for the event to be published\n   * @returns The relays the event was published to\n   *\n   * @deprecated Use `event.publish()` instead\n   */\n  async publish(event, relaySet, timeoutMs) {\n    this.debug(\"Deprecated: Use `event.publish()` instead\");\n    return event.publish(relaySet, timeoutMs);\n  }\n  /**\n   * Attempts to fetch an event from a tag, following relay hints and\n   * other best practices.\n   * @param tag Tag to fetch the event from\n   * @param originalEvent Event where the tag came from\n   * @param subOpts Subscription options to use when fetching the event\n   * @param fallback Fallback options to use when the hint relay doesn't respond\n   * @returns\n   */\n  fetchEventFromTag = fetchEventFromTag.bind(this);\n  /**\n   * Fetch an event from the cache synchronously.\n   * @param idOrFilter event id in bech32 format or filter\n   * @returns events from the cache or null if the cache is empty\n   */\n  fetchEventSync(idOrFilter) {\n    if (!this.cacheAdapter) throw new Error(\"Cache adapter not set\");\n    let filters;\n    if (typeof idOrFilter === \"string\") filters = [filterFromId(idOrFilter)];\n    else filters = idOrFilter;\n    const sub = new NDKSubscription(this, filters);\n    const events = this.cacheAdapter.query(sub);\n    if (events instanceof Promise) throw new Error(\"Cache adapter is async\");\n    return events.map((e) => {\n      e.ndk = this;\n      return e;\n    });\n  }\n  /**\n   * Fetch a single event.\n   *\n   * @param idOrFilter event id in bech32 format or filter\n   * @param opts subscription options\n   * @param relaySetOrRelay explicit relay set to use\n   */\n  async fetchEvent(idOrFilter, opts, relaySetOrRelay) {\n    let filters;\n    let relaySet;\n    if (relaySetOrRelay instanceof NDKRelay) {\n      relaySet = new NDKRelaySet(/* @__PURE__ */ new Set([relaySetOrRelay]), this);\n    } else if (relaySetOrRelay instanceof NDKRelaySet) {\n      relaySet = relaySetOrRelay;\n    }\n    if (!relaySetOrRelay && typeof idOrFilter === \"string\") {\n      if (!isNip33AValue(idOrFilter)) {\n        const relays = relaysFromBech32(idOrFilter, this);\n        if (relays.length > 0) {\n          relaySet = new NDKRelaySet(new Set(relays), this);\n          relaySet = correctRelaySet(relaySet, this.pool);\n        }\n      }\n    }\n    if (typeof idOrFilter === \"string\") {\n      filters = [filterFromId(idOrFilter)];\n    } else if (Array.isArray(idOrFilter)) {\n      filters = idOrFilter;\n    } else {\n      filters = [idOrFilter];\n    }\n    if (filters.length === 0) {\n      throw new Error(`Invalid filter: ${JSON.stringify(idOrFilter)}`);\n    }\n    return new Promise((resolve) => {\n      let fetchedEvent = null;\n      const subscribeOpts = {\n        ...opts || {},\n        closeOnEose: true\n      };\n      if (relaySet) subscribeOpts.relaySet = relaySet;\n      const s = this.subscribe(\n        filters,\n        subscribeOpts,\n        // relaySet, // Removed: Passed via opts\n        false\n        // autoStart = false\n      );\n      const t2 = setTimeout(() => {\n        s.stop();\n        resolve(fetchedEvent);\n      }, 1e4);\n      s.on(\"event\", (event) => {\n        event.ndk = this;\n        if (!event.isReplaceable()) {\n          clearTimeout(t2);\n          resolve(event);\n        } else if (!fetchedEvent || fetchedEvent.created_at < event.created_at) {\n          fetchedEvent = event;\n        }\n      });\n      s.on(\"eose\", () => {\n        clearTimeout(t2);\n        resolve(fetchedEvent);\n      });\n      s.start();\n    });\n  }\n  /**\n   * Fetch events\n   */\n  async fetchEvents(filters, opts, relaySet) {\n    return new Promise((resolve) => {\n      const events = /* @__PURE__ */ new Map();\n      const subscribeOpts = {\n        ...opts || {},\n        closeOnEose: true\n      };\n      if (relaySet) subscribeOpts.relaySet = relaySet;\n      const relaySetSubscription = this.subscribe(\n        filters,\n        subscribeOpts,\n        // relaySet, // Removed: Passed via opts\n        false\n        // autoStart = false\n      );\n      const onEvent = (event) => {\n        let _event;\n        if (!(event instanceof NDKEvent)) _event = new NDKEvent(void 0, event);\n        else _event = event;\n        const dedupKey = _event.deduplicationKey();\n        const existingEvent = events.get(dedupKey);\n        if (existingEvent) {\n          _event = dedup(existingEvent, _event);\n        }\n        _event.ndk = this;\n        events.set(dedupKey, _event);\n      };\n      relaySetSubscription.on(\"event\", onEvent);\n      relaySetSubscription.on(\"eose\", () => {\n        resolve(new Set(events.values()));\n      });\n      relaySetSubscription.start();\n    });\n  }\n  /**\n   * Ensures that a signer is available to sign an event.\n   */\n  assertSigner() {\n    if (!this.signer) {\n      this.emit(\"signer:required\");\n      throw new Error(\"Signer required\");\n    }\n  }\n  getEntity = getEntity.bind(this);\n  set wallet(wallet) {\n    if (!wallet) {\n      this.walletConfig = void 0;\n      return;\n    }\n    this.walletConfig ??= {};\n    this.walletConfig.lnPay = wallet?.lnPay?.bind(wallet);\n    this.walletConfig.cashuPay = wallet?.cashuPay?.bind(wallet);\n  }\n};\n\n// src/zap/invoice.ts\n\nfunction zapInvoiceFromEvent(event) {\n  const description = event.getMatchingTags(\"description\")[0];\n  const bolt11 = event.getMatchingTags(\"bolt11\")[0];\n  let decodedInvoice;\n  let zapRequest;\n  if (!description || !bolt11 || !bolt11[1]) {\n    return null;\n  }\n  try {\n    let zapRequestPayload = description[1];\n    if (zapRequestPayload.startsWith(\"%\")) {\n      zapRequestPayload = decodeURIComponent(zapRequestPayload);\n    }\n    if (zapRequestPayload === \"\") {\n      return null;\n    }\n    zapRequest = JSON.parse(zapRequestPayload);\n    decodedInvoice = (0,light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_7__.decode)(bolt11[1]);\n  } catch (_e) {\n    return null;\n  }\n  const amountSection = decodedInvoice.sections.find((s) => s.name === \"amount\");\n  if (!amountSection) {\n    return null;\n  }\n  const amount = Number.parseInt(amountSection.value);\n  if (!amount) {\n    return null;\n  }\n  const content = zapRequest.content;\n  const sender = zapRequest.pubkey;\n  const recipientTag = event.getMatchingTags(\"p\")[0];\n  const recipient = recipientTag[1];\n  let zappedEvent = event.getMatchingTags(\"e\")[0];\n  if (!zappedEvent) {\n    zappedEvent = event.getMatchingTags(\"a\")[0];\n  }\n  const zappedEventId = zappedEvent ? zappedEvent[1] : void 0;\n  const zapInvoice = {\n    id: event.id,\n    zapper: event.pubkey,\n    zappee: sender,\n    zapped: recipient,\n    zappedEvent: zappedEventId,\n    amount,\n    comment: content\n  };\n  return zapInvoice;\n}\n\n// src/zapper/index.ts\n\n\n\n// src/zapper/ln.ts\n\n\nvar d2 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:zapper:ln\");\nasync function getNip57ZapSpecFromLud({ lud06, lud16 }, ndk) {\n  let zapEndpoint;\n  if (lud16 && !lud16.startsWith(\"LNURL\")) {\n    const [name, domain] = lud16.split(\"@\");\n    zapEndpoint = `https://${domain}/.well-known/lnurlp/${name}`;\n  } else if (lud06) {\n    const { words } = _scure_base__WEBPACK_IMPORTED_MODULE_8__.bech32.decode(lud06, 1e3);\n    const data = _scure_base__WEBPACK_IMPORTED_MODULE_8__.bech32.fromWords(words);\n    const utf8Decoder = new TextDecoder(\"utf-8\");\n    zapEndpoint = utf8Decoder.decode(data);\n  }\n  if (!zapEndpoint) {\n    d2(\"No zap endpoint found %o\", { lud06, lud16 });\n    throw new Error(\"No zap endpoint found\");\n  }\n  try {\n    const _fetch = ndk.httpFetch || fetch;\n    const response = await _fetch(zapEndpoint);\n    if (response.status !== 200) {\n      const text = await response.text();\n      throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${text}`);\n    }\n    return await response.json();\n  } catch (e) {\n    throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${e}`);\n  }\n}\n\n// src/zapper/nip57.ts\n\nasync function generateZapRequest(target, ndk, data, pubkey, amount, relays, comment, tags, signer) {\n  const zapEndpoint = data.callback;\n  const zapRequest = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip57.makeZapRequest({\n    profile: pubkey,\n    // set the event to null since nostr-tools doesn't support nip-33 zaps\n    event: null,\n    amount,\n    comment: comment || \"\",\n    relays: relays.slice(0, 4)\n  });\n  if (target instanceof NDKEvent) {\n    const tags2 = target.referenceTags();\n    const nonPTags = tags2.filter((tag) => tag[0] !== \"p\");\n    zapRequest.tags.push(...nonPTags);\n  }\n  zapRequest.tags.push([\"lnurl\", zapEndpoint]);\n  const event = new NDKEvent(ndk, zapRequest);\n  if (tags) {\n    event.tags = event.tags.concat(tags);\n  }\n  const eTaggedEvents = /* @__PURE__ */ new Set();\n  const aTaggedEvents = /* @__PURE__ */ new Set();\n  for (const tag of event.tags) {\n    if (tag[0] === \"e\") {\n      eTaggedEvents.add(tag[1]);\n    } else if (tag[0] === \"a\") {\n      aTaggedEvents.add(tag[1]);\n    }\n  }\n  if (eTaggedEvents.size > 1) throw new Error(\"Only one e-tag is allowed\");\n  if (aTaggedEvents.size > 1) throw new Error(\"Only one a-tag is allowed\");\n  event.tags = event.tags.filter((tag) => tag[0] !== \"p\");\n  event.tags.push([\"p\", pubkey]);\n  await event.sign(signer);\n  return event;\n}\n\n// src/zapper/index.ts\nvar d3 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:zapper\");\nvar NDKZapper = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  target;\n  ndk;\n  comment;\n  amount;\n  unit;\n  tags;\n  signer;\n  zapMethod;\n  nutzapAsFallback;\n  lnPay;\n  /**\n   * Called when a cashu payment is to be made.\n   * This function should swap/mint proofs for the required amount, in the required unit,\n   * in any of the provided mints and return the proofs and mint used.\n   */\n  cashuPay;\n  onComplete;\n  maxRelays = 3;\n  /**\n   *\n   * @param target The target of the zap\n   * @param amount The amount to send indicated in the unit\n   * @param unit The unit of the amount\n   * @param opts Options for the zap\n   */\n  constructor(target, amount, unit = \"msat\", opts = {}) {\n    super();\n    this.target = target;\n    this.ndk = opts.ndk || target.ndk;\n    if (!this.ndk) {\n      throw new Error(\"No NDK instance provided\");\n    }\n    this.amount = amount;\n    this.comment = opts.comment;\n    this.unit = unit;\n    this.tags = opts.tags;\n    this.signer = opts.signer;\n    this.nutzapAsFallback = opts.nutzapAsFallback ?? false;\n    this.lnPay = opts.lnPay || this.ndk.walletConfig?.lnPay;\n    this.cashuPay = opts.cashuPay || this.ndk.walletConfig?.cashuPay;\n    this.onComplete = opts.onComplete || this.ndk.walletConfig?.onPaymentComplete;\n  }\n  /**\n   * Initiate zapping process\n   *\n   * This function will calculate the splits for this zap and initiate each zap split.\n   */\n  async zap(methods) {\n    const splits = this.getZapSplits();\n    const results = /* @__PURE__ */ new Map();\n    await Promise.all(\n      splits.map(async (split) => {\n        let result;\n        try {\n          result = await this.zapSplit(split, methods);\n        } catch (e) {\n          result = new Error(e.message);\n        }\n        this.emit(\"split:complete\", split, result);\n        results.set(split, result);\n      })\n    );\n    this.emit(\"complete\", results);\n    if (this.onComplete) this.onComplete(results);\n    return results;\n  }\n  async zapNip57(split, data) {\n    if (!this.lnPay) throw new Error(\"No lnPay function available\");\n    const zapSpec = await getNip57ZapSpecFromLud(data, this.ndk);\n    if (!zapSpec) throw new Error(\"No zap spec available for recipient\");\n    const relays = await this.relays(split.pubkey);\n    const zapRequest = await generateZapRequest(\n      this.target,\n      this.ndk,\n      zapSpec,\n      split.pubkey,\n      split.amount,\n      relays,\n      this.comment,\n      this.tags,\n      this.signer\n    );\n    if (!zapRequest) {\n      d3(\"Unable to generate zap request\");\n      throw new Error(\"Unable to generate zap request\");\n    }\n    const pr = await this.getLnInvoice(zapRequest, split.amount, zapSpec);\n    if (!pr) {\n      d3(\"Unable to get payment request\");\n      throw new Error(\"Unable to get payment request\");\n    }\n    this.emit(\"ln_invoice\", {\n      amount: split.amount,\n      recipientPubkey: split.pubkey,\n      unit: this.unit,\n      nip57ZapRequest: zapRequest,\n      pr,\n      type: \"nip57\"\n    });\n    const res = await this.lnPay({\n      target: this.target,\n      recipientPubkey: split.pubkey,\n      paymentDescription: \"NIP-57 Zap\",\n      pr,\n      amount: split.amount,\n      unit: this.unit,\n      nip57ZapRequest: zapRequest\n    });\n    if (res?.preimage) {\n      this.emit(\"ln_payment\", {\n        preimage: res.preimage,\n        amount: split.amount,\n        recipientPubkey: split.pubkey,\n        pr,\n        unit: this.unit,\n        nip57ZapRequest: zapRequest,\n        type: \"nip57\"\n      });\n    }\n    return res;\n  }\n  /**\n   * Fetches information about a NIP-61 zap and asks the caller to create cashu proofs for the zap.\n   *\n   * (note that the cashuPay function can use any method to create the proofs, including using lightning\n   * to mint proofs in the specified mint, the responsibility of minting the proofs is delegated to the caller (e.g. ndk-wallet))\n   */\n  async zapNip61(split, data) {\n    if (!this.cashuPay) throw new Error(\"No cashuPay function available\");\n    let ret;\n    ret = await this.cashuPay(\n      {\n        target: this.target,\n        recipientPubkey: split.pubkey,\n        paymentDescription: \"NIP-61 Zap\",\n        amount: split.amount,\n        unit: this.unit,\n        ...data ?? {}\n      },\n      (pr) => {\n        this.emit(\"ln_invoice\", {\n          pr,\n          amount: split.amount,\n          recipientPubkey: split.pubkey,\n          unit: this.unit,\n          type: \"nip61\"\n        });\n      }\n    );\n    d3(\"NIP-61 Zap result: %o\", ret);\n    if (ret instanceof Error) {\n      return ret;\n    }\n    if (ret) {\n      const { proofs, mint } = ret;\n      if (!proofs || !mint) throw new Error(`Invalid zap confirmation: missing proofs or mint: ${ret}`);\n      const relays = await this.relays(split.pubkey);\n      const relaySet = NDKRelaySet.fromRelayUrls(relays, this.ndk);\n      const nutzap = new NDKNutzap(this.ndk);\n      nutzap.tags = [...nutzap.tags, ...this.tags || []];\n      nutzap.proofs = proofs;\n      nutzap.mint = mint;\n      nutzap.target = this.target;\n      nutzap.comment = this.comment;\n      nutzap.unit = \"sat\";\n      nutzap.recipientPubkey = split.pubkey;\n      await nutzap.sign(this.signer);\n      nutzap.publish(relaySet);\n      return nutzap;\n    }\n  }\n  /**\n   * Get the zap methods available for the recipient and initiates the zap\n   * in the desired method.\n   * @param split\n   * @param methods - The methods to try, if not provided, all methods will be tried.\n   * @returns\n   */\n  async zapSplit(split, methods) {\n    const recipient = this.ndk.getUser({ pubkey: split.pubkey });\n    const zapMethods = await recipient.getZapInfo(2500);\n    let retVal;\n    const canFallbackToNip61 = this.nutzapAsFallback && this.cashuPay;\n    if (zapMethods.size === 0 && !canFallbackToNip61)\n      throw new Error(\"No zap method available for recipient and NIP-61 fallback is disabled\");\n    const nip61Fallback = async () => {\n      if (!this.nutzapAsFallback) return;\n      const relayLists = await getRelayListForUsers([split.pubkey], this.ndk);\n      let relayUrls = relayLists.get(split.pubkey)?.readRelayUrls;\n      relayUrls = this.ndk.pool.connectedRelays().map((r) => r.url);\n      return await this.zapNip61(split, {\n        // use the user's relay list\n        relays: relayUrls,\n        // lock to the user's actual pubkey\n        p2pk: split.pubkey,\n        // allow intramint fallback\n        allowIntramintFallback: !!canFallbackToNip61\n      });\n    };\n    const canUseNip61 = !methods || methods.includes(\"nip61\");\n    const canUseNip57 = !methods || methods.includes(\"nip57\");\n    const nip61Method = zapMethods.get(\"nip61\");\n    if (nip61Method && canUseNip61) {\n      try {\n        retVal = await this.zapNip61(split, nip61Method);\n        if (retVal instanceof NDKNutzap) return retVal;\n      } catch (e) {\n        this.emit(\"notice\", `NIP-61 attempt failed: ${e.message}`);\n      }\n    }\n    const nip57Method = zapMethods.get(\"nip57\");\n    if (nip57Method && canUseNip57) {\n      try {\n        retVal = await this.zapNip57(split, nip57Method);\n        if (!(retVal instanceof Error)) return retVal;\n      } catch (e) {\n        this.emit(\"notice\", `NIP-57 attempt failed: ${e.message}`);\n      }\n    }\n    if (canFallbackToNip61) {\n      retVal = await nip61Fallback();\n      if (retVal instanceof Error) throw retVal;\n      return retVal;\n    }\n    this.emit(\"notice\", \"Zap methods exhausted and there was no fallback to NIP-61\");\n    if (retVal instanceof Error) throw retVal;\n    return retVal;\n  }\n  /**\n   * Gets a bolt11 for a nip57 zap\n   * @param event\n   * @param amount\n   * @param zapEndpoint\n   * @returns\n   */\n  async getLnInvoice(zapRequest, amount, data) {\n    const zapEndpoint = data.callback;\n    const eventPayload = JSON.stringify(zapRequest.rawEvent());\n    d3(\n      `Fetching invoice from ${zapEndpoint}?${new URLSearchParams({\n        amount: amount.toString(),\n        nostr: eventPayload\n      })}`\n    );\n    const url = new URL(zapEndpoint);\n    url.searchParams.append(\"amount\", amount.toString());\n    url.searchParams.append(\"nostr\", eventPayload);\n    d3(`Fetching invoice from ${url.toString()}`);\n    const response = await fetch(url.toString());\n    d3(`Got response from zap endpoint: ${zapEndpoint}`, { status: response.status });\n    if (response.status !== 200) {\n      d3(`Received non-200 status from zap endpoint: ${zapEndpoint}`, {\n        status: response.status,\n        amount,\n        nostr: eventPayload\n      });\n      const text = await response.text();\n      throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${text}`);\n    }\n    const body = await response.json();\n    return body.pr;\n  }\n  getZapSplits() {\n    if (this.target instanceof NDKUser) {\n      return [\n        {\n          pubkey: this.target.pubkey,\n          amount: this.amount\n        }\n      ];\n    }\n    const zapTags = this.target.getMatchingTags(\"zap\");\n    if (zapTags.length === 0) {\n      return [\n        {\n          pubkey: this.target.pubkey,\n          amount: this.amount\n        }\n      ];\n    }\n    const splits = [];\n    const total = zapTags.reduce((acc, tag) => acc + Number.parseInt(tag[2]), 0);\n    for (const tag of zapTags) {\n      const pubkey = tag[1];\n      const amount = Math.floor(Number.parseInt(tag[2]) / total * this.amount);\n      splits.push({ pubkey, amount });\n    }\n    return splits;\n  }\n  /**\n   * Gets the zap method that should be used to zap a pubbkey\n   * @param ndk\n   * @param pubkey\n   * @returns\n   */\n  async getZapMethods(ndk, recipient, timeout = 2500) {\n    const user = ndk.getUser({ pubkey: recipient });\n    return await user.getZapInfo(timeout);\n  }\n  /**\n   * @returns the relays to use for the zap request\n   */\n  async relays(pubkey) {\n    let r = [];\n    if (this.ndk?.activeUser) {\n      const relayLists = await getRelayListForUsers([this.ndk.activeUser.pubkey, pubkey], this.ndk);\n      const relayScores = /* @__PURE__ */ new Map();\n      for (const relayList of relayLists.values()) {\n        for (const url of relayList.readRelayUrls) {\n          const score = relayScores.get(url) || 0;\n          relayScores.set(url, score + 1);\n        }\n      }\n      r = Array.from(relayScores.entries()).sort((a, b) => b[1] - a[1]).map(([url]) => url).slice(0, this.maxRelays);\n    }\n    if (this.ndk?.pool?.permanentAndConnectedRelays().length) {\n      r = this.ndk.pool.permanentAndConnectedRelays().map((relay) => relay.url);\n    }\n    if (!r.length) {\n      r = [];\n    }\n    return r;\n  }\n};\n\n// src/utils/filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    return false;\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {\n    return false;\n  }\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    return false;\n  }\n  for (const f in filter) {\n    if (f[0] === \"#\") {\n      const tagName = f.slice(1);\n      if (tagName === \"t\") {\n        const values = filter[`#${tagName}`]?.map((v) => v.toLowerCase());\n        if (values && !event.tags.find(([t, v]) => t === tagName && values?.indexOf(v.toLowerCase()) !== -1))\n          return false;\n      } else {\n        const values = filter[`#${tagName}`];\n        if (values && !event.tags.find(([t, v]) => t === tagName && values?.indexOf(v) !== -1)) return false;\n      }\n    }\n  }\n  if (filter.since && event.created_at < filter.since) return false;\n  if (filter.until && event.created_at > filter.until) return false;\n  return true;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLWhvb2tzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLLGFBQWEsS0FBSztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzBCO0FBQ1c7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxHQUFHO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sK0NBQStDLGtCQUFrQixJQUFJLGNBQWM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQ0FBSyxjQUFjLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVUsSUFBSSxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsdUZBQXVGLFVBQVU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxVQUFVO0FBQzdFO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0NBQWtDLG1DQUFtQztBQUNyRTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrQ0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ29DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWEsRUFBRSw4Q0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkMsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscUJBQXFCO0FBQ25ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzhDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVyw4Q0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxTQUFTLDhDQUFNO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDc0Q7QUFDdEQsNEJBQTRCLCtDQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVMsd0JBQXdCLE1BQU07QUFDckY7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxVQUFVO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxlQUFlO0FBQzlCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0IsUUFBUSx5QkFBeUIsVUFBVSxVQUFVO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EscURBQXFELFVBQVU7QUFDL0QsU0FBUztBQUNUO0FBQ0E7QUFDQSxxREFBcUQsVUFBVSxJQUFJLDJCQUEyQjtBQUM5RixXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVcsS0FBSyxlQUFlO0FBQ2xFO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLLEVBQUUsRUFBRTtBQUM3QjtBQUNBLE1BQU07QUFDTixrQkFBa0IsS0FBSyxFQUFFLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsdUJBQXVCLEtBQUssR0FBRyxPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxrQ0FBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRCx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjtBQUM1QjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSyxFQUFFLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCLEdBQUcsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSyxFQUFFLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVyxHQUFHLFdBQVc7QUFDNUQsbUNBQW1DLGlCQUFpQixHQUFHLGtCQUFrQjs7QUFFekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtDQUFrQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkNBQTJDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhDQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0IsR0FBRyxvQkFBb0IsR0FBRyx3QkFBd0I7QUFDeEY7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQU07QUFDdEI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4Q0FBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQ0FBaUM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtDQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxtQ0FBbUM7QUFDckY7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFB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O0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLCtCQUErQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxrQ0FBTTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsY0FBYztBQUNuRTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsa0NBQU07QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzREOztBQUU1RDtBQUMyRjtBQUNmO0FBQzlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLEVBQUUsOENBQU07QUFDckM7QUFDQTtBQUNBLFFBQVE7QUFDUiwyQkFBMkIsK0RBQVU7QUFDckMsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG1CQUFtQix5REFBWTtBQUMvQix3Q0FBd0Msc0JBQXNCO0FBQzlELGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrREFBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhEQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBEQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhDQUFLO0FBQ25DLG1CQUFtQiw4Q0FBSztBQUN4QjtBQUNBLGlCQUFpQiw4Q0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4Q0FBSztBQUNuQyxtQkFBbUIsOENBQUs7QUFDeEI7QUFDQSxpQkFBaUIsOENBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxhQUFhO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlEQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsNERBQTRELGFBQWE7QUFDekUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDaUM7QUFDakM7QUFDQSxhQUFhLGtDQUFZO0FBQ3pCO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osc0RBQXNELFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZCQUE2QixJQUFJO0FBQ25ELGFBQWEsa0NBQVk7QUFDekI7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQ0FBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRCw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRUFBZ0U7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxhQUFhO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2dFOztBQUVoRTtBQUNzRDtBQUN0RCxnQ0FBZ0MsK0NBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsNEJBQTRCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9DQUFvQztBQUNoRDtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0I7QUFDaEUsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxHQUFHO0FBQ25DO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixHQUFHO0FBQy9CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYztBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNCQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx5QkFBeUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0JBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDLHNDQUFzQywwQ0FBMEM7QUFDaEYsd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0QywrREFBVztBQUN2RCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0EsbUNBQW1DLG9CQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGdEQUFnRCxvQkFBb0I7QUFDcEU7QUFDQTtBQUNBLE1BQU07QUFDTix5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3NEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdURBQXVELDJDQUEyQztBQUNsRztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx5REFBeUQsWUFBWSxJQUFJLFNBQVM7QUFDbEY7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCwrQ0FBYTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPLEdBQUcsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5REFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2lDO0FBQ2pDLGFBQWEsa0NBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxN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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsa0NBQVk7QUFDckIsOEJBQThCLCtDQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QixpR0FBaUcsSUFBSTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHNCQUFzQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0RBQXNELFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0RBQXNELFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWSxHQUFHO0FBQzlDO0FBQ0E7QUFDQSxPQUFPLEVBQUU7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0EsMENBQTBDLFlBQVksS0FBSyx5QkFBeUI7QUFDcEY7QUFDQSx1REFBdUQsWUFBWTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzREFBc0QsWUFBWSxJQUFJLEtBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXFIRSIsInNvdXJjZXMiOlsiL1VzZXJzL3BhYmxvZmVybmFuZGV6L3Rlc3QxMjMvVEVORVgtcGZrbWM5L21haW4vbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay1ob29rcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy90eXBlcy50c1xudmFyIE5ka051dHphcFN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ka051dHphcFN0YXR1czIpID0+IHtcbiAgTmRrTnV0emFwU3RhdHVzMltcIklOSVRJQUxcIl0gPSBcImluaXRpYWxcIjtcbiAgTmRrTnV0emFwU3RhdHVzMltcIlBST0NFU1NJTkdcIl0gPSBcInByb2Nlc3NpbmdcIjtcbiAgTmRrTnV0emFwU3RhdHVzMltcIlJFREVFTUVEXCJdID0gXCJyZWRlZW1lZFwiO1xuICBOZGtOdXR6YXBTdGF0dXMyW1wiU1BFTlRcIl0gPSBcInNwZW50XCI7XG4gIE5ka051dHphcFN0YXR1czJbXCJNSVNTSU5HX1BSSVZLRVlcIl0gPSBcIm1pc3NpbmdfcHJpdmtleVwiO1xuICBOZGtOdXR6YXBTdGF0dXMyW1wiVEVNUE9SQVJZX0VSUk9SXCJdID0gXCJ0ZW1wb3JhcnlfZXJyb3JcIjtcbiAgTmRrTnV0emFwU3RhdHVzMltcIlBFUk1BTkVOVF9FUlJPUlwiXSA9IFwicGVybWFuZW50X2Vycm9yXCI7XG4gIE5ka051dHphcFN0YXR1czJbXCJJTlZBTElEX05VVFpBUFwiXSA9IFwiaW52YWxpZF9udXR6YXBcIjtcbiAgcmV0dXJuIE5ka051dHphcFN0YXR1czI7XG59KShOZGtOdXR6YXBTdGF0dXMgfHwge30pO1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2luZGV4LnRzXG52YXIgTkRLS2luZCA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ES0tpbmQyKSA9PiB7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTWV0YWRhdGFcIl0gPSAwXSA9IFwiTWV0YWRhdGFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJUZXh0XCJdID0gMV0gPSBcIlRleHRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJSZWNvbW1lbmRSZWxheVwiXSA9IDJdID0gXCJSZWNvbW1lbmRSZWxheVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNvbnRhY3RzXCJdID0gM10gPSBcIkNvbnRhY3RzXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRW5jcnlwdGVkRGlyZWN0TWVzc2FnZVwiXSA9IDRdID0gXCJFbmNyeXB0ZWREaXJlY3RNZXNzYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRXZlbnREZWxldGlvblwiXSA9IDVdID0gXCJFdmVudERlbGV0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUmVwb3N0XCJdID0gNl0gPSBcIlJlcG9zdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlJlYWN0aW9uXCJdID0gN10gPSBcIlJlYWN0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQmFkZ2VBd2FyZFwiXSA9IDhdID0gXCJCYWRnZUF3YXJkXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBDaGF0XCJdID0gOV0gPSBcIkdyb3VwQ2hhdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwTm90ZVwiXSA9IDExXSA9IFwiR3JvdXBOb3RlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBSZXBseVwiXSA9IDEyXSA9IFwiR3JvdXBSZXBseVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdpZnRXcmFwU2VhbFwiXSA9IDEzXSA9IFwiR2lmdFdyYXBTZWFsXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUHJpdmF0ZURpcmVjdE1lc3NhZ2VcIl0gPSAxNF0gPSBcIlByaXZhdGVEaXJlY3RNZXNzYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSW1hZ2VcIl0gPSAyMF0gPSBcIkltYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiVmlkZW9cIl0gPSAyMV0gPSBcIlZpZGVvXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU2hvcnRWaWRlb1wiXSA9IDIyXSA9IFwiU2hvcnRWaWRlb1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlN0b3J5XCJdID0gMjNdID0gXCJTdG9yeVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlZhbmlzaFwiXSA9IDYyXSA9IFwiVmFuaXNoXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVXYWxsZXRCYWNrdXBcIl0gPSAzNzVdID0gXCJDYXNodVdhbGxldEJhY2t1cFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdpZnRXcmFwXCJdID0gMTA1OV0gPSBcIkdpZnRXcmFwXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR2VuZXJpY1JlcG9zdFwiXSA9IDE2XSA9IFwiR2VuZXJpY1JlcG9zdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNoYW5uZWxDcmVhdGlvblwiXSA9IDQwXSA9IFwiQ2hhbm5lbENyZWF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2hhbm5lbE1ldGFkYXRhXCJdID0gNDFdID0gXCJDaGFubmVsTWV0YWRhdGFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDaGFubmVsTWVzc2FnZVwiXSA9IDQyXSA9IFwiQ2hhbm5lbE1lc3NhZ2VcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDaGFubmVsSGlkZU1lc3NhZ2VcIl0gPSA0M10gPSBcIkNoYW5uZWxIaWRlTWVzc2FnZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNoYW5uZWxNdXRlVXNlclwiXSA9IDQ0XSA9IFwiQ2hhbm5lbE11dGVVc2VyXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiV2lraU1lcmdlUmVxdWVzdFwiXSA9IDgxOF0gPSBcIldpa2lNZXJnZVJlcXVlc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHZW5lcmljUmVwbHlcIl0gPSAxMTExXSA9IFwiR2VuZXJpY1JlcGx5XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTWVkaWFcIl0gPSAxMDYzXSA9IFwiTWVkaWFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJSZXBvcnRcIl0gPSAxOTg0XSA9IFwiUmVwb3J0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTGFiZWxcIl0gPSAxOTg1XSA9IFwiTGFiZWxcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFUZXh0RXh0cmFjdGlvblwiXSA9IDVlM10gPSBcIkRWTVJlcVRleHRFeHRyYWN0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxVGV4dFN1bW1hcml6YXRpb25cIl0gPSA1MDAxXSA9IFwiRFZNUmVxVGV4dFN1bW1hcml6YXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFUZXh0VHJhbnNsYXRpb25cIl0gPSA1MDAyXSA9IFwiRFZNUmVxVGV4dFRyYW5zbGF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxVGV4dEdlbmVyYXRpb25cIl0gPSA1MDUwXSA9IFwiRFZNUmVxVGV4dEdlbmVyYXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFJbWFnZUdlbmVyYXRpb25cIl0gPSA1MTAwXSA9IFwiRFZNUmVxSW1hZ2VHZW5lcmF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxVGV4dFRvU3BlZWNoXCJdID0gNTI1MF0gPSBcIkRWTVJlcVRleHRUb1NwZWVjaFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcURpc2NvdmVyeU5vc3RyQ29udGVudFwiXSA9IDUzMDBdID0gXCJEVk1SZXFEaXNjb3ZlcnlOb3N0ckNvbnRlbnRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFEaXNjb3ZlcnlOb3N0clBlb3BsZVwiXSA9IDUzMDFdID0gXCJEVk1SZXFEaXNjb3ZlcnlOb3N0clBlb3BsZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcVRpbWVzdGFtcGluZ1wiXSA9IDU5MDBdID0gXCJEVk1SZXFUaW1lc3RhbXBpbmdcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1FdmVudFNjaGVkdWxlXCJdID0gNTkwNV0gPSBcIkRWTUV2ZW50U2NoZWR1bGVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1Kb2JGZWVkYmFja1wiXSA9IDdlM10gPSBcIkRWTUpvYkZlZWRiYWNrXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU3Vic2NyaWJlXCJdID0gNzAwMV0gPSBcIlN1YnNjcmliZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlVuc3Vic2NyaWJlXCJdID0gNzAwMl0gPSBcIlVuc3Vic2NyaWJlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU3Vic2NyaXB0aW9uUmVjZWlwdFwiXSA9IDcwMDNdID0gXCJTdWJzY3JpcHRpb25SZWNlaXB0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVSZXNlcnZlXCJdID0gNzM3M10gPSBcIkNhc2h1UmVzZXJ2ZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhc2h1UXVvdGVcIl0gPSA3Mzc0XSA9IFwiQ2FzaHVRdW90ZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhc2h1VG9rZW5cIl0gPSA3Mzc1XSA9IFwiQ2FzaHVUb2tlblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhc2h1V2FsbGV0VHhcIl0gPSA3Mzc2XSA9IFwiQ2FzaHVXYWxsZXRUeFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5BZGRVc2VyXCJdID0gOWUzXSA9IFwiR3JvdXBBZG1pbkFkZFVzZXJcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cEFkbWluUmVtb3ZlVXNlclwiXSA9IDkwMDFdID0gXCJHcm91cEFkbWluUmVtb3ZlVXNlclwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5FZGl0TWV0YWRhdGFcIl0gPSA5MDAyXSA9IFwiR3JvdXBBZG1pbkVkaXRNZXRhZGF0YVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5FZGl0U3RhdHVzXCJdID0gOTAwNl0gPSBcIkdyb3VwQWRtaW5FZGl0U3RhdHVzXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pbkNyZWF0ZUdyb3VwXCJdID0gOTAwN10gPSBcIkdyb3VwQWRtaW5DcmVhdGVHcm91cFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5SZXF1ZXN0Sm9pblwiXSA9IDkwMjFdID0gXCJHcm91cEFkbWluUmVxdWVzdEpvaW5cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNdXRlTGlzdFwiXSA9IDFlNF0gPSBcIk11dGVMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUGluTGlzdFwiXSA9IDEwMDAxXSA9IFwiUGluTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlJlbGF5TGlzdFwiXSA9IDEwMDAyXSA9IFwiUmVsYXlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQm9va21hcmtMaXN0XCJdID0gMTAwMDNdID0gXCJCb29rbWFya0xpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDb21tdW5pdHlMaXN0XCJdID0gMTAwMDRdID0gXCJDb21tdW5pdHlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUHVibGljQ2hhdExpc3RcIl0gPSAxMDAwNV0gPSBcIlB1YmxpY0NoYXRMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQmxvY2tSZWxheUxpc3RcIl0gPSAxMDAwNl0gPSBcIkJsb2NrUmVsYXlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU2VhcmNoUmVsYXlMaXN0XCJdID0gMTAwMDddID0gXCJTZWFyY2hSZWxheUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJTaW1wbGVHcm91cExpc3RcIl0gPSAxMDAwOV0gPSBcIlNpbXBsZUdyb3VwTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkludGVyZXN0TGlzdFwiXSA9IDEwMDE1XSA9IFwiSW50ZXJlc3RMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVNaW50TGlzdFwiXSA9IDEwMDE5XSA9IFwiQ2FzaHVNaW50TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkVtb2ppTGlzdFwiXSA9IDEwMDMwXSA9IFwiRW1vamlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRGlyZWN0TWVzc2FnZVJlY2VpdmVSZWxheUxpc3RcIl0gPSAxMDA1MF0gPSBcIkRpcmVjdE1lc3NhZ2VSZWNlaXZlUmVsYXlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQmxvc3NvbUxpc3RcIl0gPSAxMDA2M10gPSBcIkJsb3Nzb21MaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTm9zdHJXYWxldENvbm5lY3RJbmZvXCJdID0gMTMxOTRdID0gXCJOb3N0cldhbGV0Q29ubmVjdEluZm9cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJUaWVyTGlzdFwiXSA9IDE3ZTNdID0gXCJUaWVyTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhc2h1V2FsbGV0XCJdID0gMTczNzVdID0gXCJDYXNodVdhbGxldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkZvbGxvd1NldFwiXSA9IDNlNF0gPSBcIkZvbGxvd1NldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhdGVnb3JpemVkUGVvcGxlTGlzdFwiXSA9IDNlNCAvKiBGb2xsb3dTZXQgKi9dID0gXCJDYXRlZ29yaXplZFBlb3BsZUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXRlZ29yaXplZEJvb2ttYXJrTGlzdFwiXSA9IDMwMDAxXSA9IFwiQ2F0ZWdvcml6ZWRCb29rbWFya0xpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJSZWxheVNldFwiXSA9IDMwMDAyXSA9IFwiUmVsYXlTZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXRlZ29yaXplZFJlbGF5TGlzdFwiXSA9IDMwMDAyIC8qIFJlbGF5U2V0ICovXSA9IFwiQ2F0ZWdvcml6ZWRSZWxheUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCb29rbWFya1NldFwiXSA9IDMwMDAzXSA9IFwiQm9va21hcmtTZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDdXJhdGlvblNldFwiXSA9IDMwMDA0XSA9IFwiQ3VyYXRpb25TZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJBcnRpY2xlQ3VyYXRpb25TZXRcIl0gPSAzMDAwNF0gPSBcIkFydGljbGVDdXJhdGlvblNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlZpZGVvQ3VyYXRpb25TZXRcIl0gPSAzMDAwNV0gPSBcIlZpZGVvQ3VyYXRpb25TZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJJbWFnZUN1cmF0aW9uU2V0XCJdID0gMzAwMDZdID0gXCJJbWFnZUN1cmF0aW9uU2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSW50ZXJlc3RTZXRcIl0gPSAzMDAxNV0gPSBcIkludGVyZXN0U2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSW50ZXJlc3RzTGlzdFwiXSA9IDMwMDE1IC8qIEludGVyZXN0U2V0ICovXSA9IFwiSW50ZXJlc3RzTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkVtb2ppU2V0XCJdID0gMzAwMzBdID0gXCJFbW9qaVNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk1vZHVsYXJBcnRpY2xlXCJdID0gMzAwNDBdID0gXCJNb2R1bGFyQXJ0aWNsZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk1vZHVsYXJBcnRpY2xlSXRlbVwiXSA9IDMwMDQxXSA9IFwiTW9kdWxhckFydGljbGVJdGVtXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiV2lraVwiXSA9IDMwODE4XSA9IFwiV2lraVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRyYWZ0XCJdID0gMzEyMzRdID0gXCJEcmFmdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlN1YnNjcmlwdGlvblRpZXJcIl0gPSAzNzAwMV0gPSBcIlN1YnNjcmlwdGlvblRpZXJcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJFY2FzaE1pbnRSZWNvbW1lbmRhdGlvblwiXSA9IDM4ZTNdID0gXCJFY2FzaE1pbnRSZWNvbW1lbmRhdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkhpZ2hsaWdodFNldFwiXSA9IDM5ODAyXSA9IFwiSGlnaGxpZ2h0U2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2F0ZWdvcml6ZWRIaWdobGlnaHRMaXN0XCJdID0gMzk4MDIgLyogSGlnaGxpZ2h0U2V0ICovXSA9IFwiQ2F0ZWdvcml6ZWRIaWdobGlnaHRMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTnV0emFwXCJdID0gOTMyMV0gPSBcIk51dHphcFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlphcFJlcXVlc3RcIl0gPSA5NzM0XSA9IFwiWmFwUmVxdWVzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlphcFwiXSA9IDk3MzVdID0gXCJaYXBcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJIaWdobGlnaHRcIl0gPSA5ODAyXSA9IFwiSGlnaGxpZ2h0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2xpZW50QXV0aFwiXSA9IDIyMjQyXSA9IFwiQ2xpZW50QXV0aFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk5vc3RyV2FsbGV0Q29ubmVjdFJlcVwiXSA9IDIzMTk0XSA9IFwiTm9zdHJXYWxsZXRDb25uZWN0UmVxXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTm9zdHJXYWxsZXRDb25uZWN0UmVzXCJdID0gMjMxOTVdID0gXCJOb3N0cldhbGxldENvbm5lY3RSZXNcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJOb3N0ckNvbm5lY3RcIl0gPSAyNDEzM10gPSBcIk5vc3RyQ29ubmVjdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkJsb3Nzb21VcGxvYWRcIl0gPSAyNDI0Ml0gPSBcIkJsb3Nzb21VcGxvYWRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJIdHRwQXV0aFwiXSA9IDI3MjM1XSA9IFwiSHR0cEF1dGhcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJQcm9maWxlQmFkZ2VcIl0gPSAzMDAwOF0gPSBcIlByb2ZpbGVCYWRnZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkJhZGdlRGVmaW5pdGlvblwiXSA9IDMwMDA5XSA9IFwiQmFkZ2VEZWZpbml0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTWFya2V0U3RhbGxcIl0gPSAzMDAxN10gPSBcIk1hcmtldFN0YWxsXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTWFya2V0UHJvZHVjdFwiXSA9IDMwMDE4XSA9IFwiTWFya2V0UHJvZHVjdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkFydGljbGVcIl0gPSAzMDAyM10gPSBcIkFydGljbGVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJBcHBTcGVjaWZpY0RhdGFcIl0gPSAzMDA3OF0gPSBcIkFwcFNwZWNpZmljRGF0YVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNsYXNzaWZpZWRcIl0gPSAzMDQwMl0gPSBcIkNsYXNzaWZpZWRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJIb3Jpem9udGFsVmlkZW9cIl0gPSAzNDIzNV0gPSBcIkhvcml6b250YWxWaWRlb1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlZlcnRpY2FsVmlkZW9cIl0gPSAzNDIzNl0gPSBcIlZlcnRpY2FsVmlkZW9cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJMZWdhY3lDYXNodVdhbGxldFwiXSA9IDM3Mzc1XSA9IFwiTGVnYWN5Q2FzaHVXYWxsZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cE1ldGFkYXRhXCJdID0gMzllM10gPSBcIkdyb3VwTWV0YWRhdGFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cEFkbWluc1wiXSA9IDM5MDAxXSA9IFwiR3JvdXBBZG1pbnNcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cE1lbWJlcnNcIl0gPSAzOTAwMl0gPSBcIkdyb3VwTWVtYmVyc1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkFwcFJlY29tbWVuZGF0aW9uXCJdID0gMzE5ODldID0gXCJBcHBSZWNvbW1lbmRhdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkFwcEhhbmRsZXJcIl0gPSAzMTk5MF0gPSBcIkFwcEhhbmRsZXJcIjtcbiAgcmV0dXJuIE5ES0tpbmQyO1xufSkoTkRLS2luZCB8fCB7fSk7XG52YXIgTkRLTGlzdEtpbmRzID0gW1xuICAxZTQgLyogTXV0ZUxpc3QgKi8sXG4gIDEwMDAxIC8qIFBpbkxpc3QgKi8sXG4gIDEwMDAyIC8qIFJlbGF5TGlzdCAqLyxcbiAgMTAwMDMgLyogQm9va21hcmtMaXN0ICovLFxuICAxMDAwNCAvKiBDb21tdW5pdHlMaXN0ICovLFxuICAxMDAwNSAvKiBQdWJsaWNDaGF0TGlzdCAqLyxcbiAgMTAwMDYgLyogQmxvY2tSZWxheUxpc3QgKi8sXG4gIDEwMDA3IC8qIFNlYXJjaFJlbGF5TGlzdCAqLyxcbiAgMTAwMTUgLyogSW50ZXJlc3RMaXN0ICovLFxuICAxMDAzMCAvKiBFbW9qaUxpc3QgKi8sXG4gIDEwMDUwIC8qIERpcmVjdE1lc3NhZ2VSZWNlaXZlUmVsYXlMaXN0ICovLFxuICAzZTQgLyogRm9sbG93U2V0ICovLFxuICAzMDAwMyAvKiBCb29rbWFya1NldCAqLyxcbiAgMzAwMDEgLyogQ2F0ZWdvcml6ZWRCb29rbWFya0xpc3QgKi8sXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIDMwMDAyIC8qIFJlbGF5U2V0ICovLFxuICAzMDAwNCAvKiBBcnRpY2xlQ3VyYXRpb25TZXQgKi8sXG4gIDMwMDA1IC8qIFZpZGVvQ3VyYXRpb25TZXQgKi8sXG4gIDMwMDE1IC8qIEludGVyZXN0U2V0ICovLFxuICAzMDAzMCAvKiBFbW9qaVNldCAqLyxcbiAgMzk4MDIgLyogSGlnaGxpZ2h0U2V0ICovXG5dO1xuXG4vLyBzcmMvZXZlbnRzL2luZGV4LnRzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgYXMgRXZlbnRFbWl0dGVyMiB9IGZyb20gXCJ0c2VlcFwiO1xuXG4vLyBzcmMvcmVsYXkvc2V0cy9jYWxjdWxhdGUudHNcbmltcG9ydCBjcmVhdGVEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcblxuLy8gc3JjL291dGJveC93cml0ZS50c1xuZnVuY3Rpb24gZ2V0UmVsYXlzRm9yU3luYyhuZGssIGF1dGhvciwgdHlwZSA9IFwid3JpdGVcIikge1xuICBpZiAoIW5kay5vdXRib3hUcmFja2VyKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBpdGVtID0gbmRrLm91dGJveFRyYWNrZXIuZGF0YS5nZXQoYXV0aG9yKTtcbiAgaWYgKCFpdGVtKSByZXR1cm4gdm9pZCAwO1xuICBpZiAodHlwZSA9PT0gXCJ3cml0ZVwiKSB7XG4gICAgcmV0dXJuIGl0ZW0ud3JpdGVSZWxheXM7XG4gIH1cbiAgcmV0dXJuIGl0ZW0ucmVhZFJlbGF5cztcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFdyaXRlUmVsYXlzRm9yKG5kaywgYXV0aG9yLCB0eXBlID0gXCJ3cml0ZVwiKSB7XG4gIGlmICghbmRrLm91dGJveFRyYWNrZXIpIHJldHVybiB2b2lkIDA7XG4gIGlmICghbmRrLm91dGJveFRyYWNrZXIuZGF0YS5oYXMoYXV0aG9yKSkge1xuICAgIGF3YWl0IG5kay5vdXRib3hUcmFja2VyLnRyYWNrVXNlcnMoW2F1dGhvcl0pO1xuICB9XG4gIHJldHVybiBnZXRSZWxheXNGb3JTeW5jKG5kaywgYXV0aG9yLCB0eXBlKTtcbn1cblxuLy8gc3JjL291dGJveC9yZWxheS1yYW5raW5nLnRzXG5mdW5jdGlvbiBnZXRUb3BSZWxheXNGb3JBdXRob3JzKG5kaywgYXV0aG9ycykge1xuICBjb25zdCByZWxheXNXaXRoQ291bnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBhdXRob3JzLmZvckVhY2goKGF1dGhvcikgPT4ge1xuICAgIGNvbnN0IHdyaXRlUmVsYXlzID0gZ2V0UmVsYXlzRm9yU3luYyhuZGssIGF1dGhvcik7XG4gICAgaWYgKHdyaXRlUmVsYXlzKSB7XG4gICAgICB3cml0ZVJlbGF5cy5mb3JFYWNoKChyZWxheSkgPT4ge1xuICAgICAgICBjb25zdCBjb3VudCA9IHJlbGF5c1dpdGhDb3VudC5nZXQocmVsYXkpIHx8IDA7XG4gICAgICAgIHJlbGF5c1dpdGhDb3VudC5zZXQocmVsYXksIGNvdW50ICsgMSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzb3J0ZWRSZWxheXMgPSBBcnJheS5mcm9tKHJlbGF5c1dpdGhDb3VudC5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKTtcbiAgcmV0dXJuIHNvcnRlZFJlbGF5cy5tYXAoKGVudHJ5KSA9PiBlbnRyeVswXSk7XG59XG5cbi8vIHNyYy9vdXRib3gvaW5kZXgudHNcbmZ1bmN0aW9uIGdldEFsbFJlbGF5c0ZvckFsbFB1YmtleXMobmRrLCBwdWJrZXlzLCB0eXBlID0gXCJyZWFkXCIpIHtcbiAgY29uc3QgcHVia2V5c1RvUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgYXV0aG9yc01pc3NpbmdSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBwdWJrZXlzLmZvckVhY2goKHB1YmtleSkgPT4ge1xuICAgIGNvbnN0IHJlbGF5cyA9IGdldFJlbGF5c0ZvclN5bmMobmRrLCBwdWJrZXksIHR5cGUpO1xuICAgIGlmIChyZWxheXMgJiYgcmVsYXlzLnNpemUgPiAwKSB7XG4gICAgICByZWxheXMuZm9yRWFjaCgocmVsYXkpID0+IHtcbiAgICAgICAgY29uc3QgcHVia2V5c0luUmVsYXkgPSBwdWJrZXlzVG9SZWxheXMuZ2V0KHJlbGF5KSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICBwdWJrZXlzSW5SZWxheS5hZGQocHVia2V5KTtcbiAgICAgIH0pO1xuICAgICAgcHVia2V5c1RvUmVsYXlzLnNldChwdWJrZXksIHJlbGF5cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF1dGhvcnNNaXNzaW5nUmVsYXlzLmFkZChwdWJrZXkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7IHB1YmtleXNUb1JlbGF5cywgYXV0aG9yc01pc3NpbmdSZWxheXMgfTtcbn1cbmZ1bmN0aW9uIGNob29zZVJlbGF5Q29tYmluYXRpb25Gb3JQdWJrZXlzKG5kaywgcHVia2V5cywgdHlwZSwgeyBjb3VudCwgcHJlZmVycmVkUmVsYXlzIH0gPSB7fSkge1xuICBjb3VudCA/Pz0gMjtcbiAgcHJlZmVycmVkUmVsYXlzID8/PSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBwb29sID0gbmRrLnBvb2w7XG4gIGNvbnN0IGNvbm5lY3RlZFJlbGF5cyA9IHBvb2wuY29ubmVjdGVkUmVsYXlzKCk7XG4gIGNvbm5lY3RlZFJlbGF5cy5mb3JFYWNoKChyZWxheSkgPT4ge1xuICAgIHByZWZlcnJlZFJlbGF5cz8uYWRkKHJlbGF5LnVybCk7XG4gIH0pO1xuICBjb25zdCByZWxheVRvQXV0aG9yc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHsgcHVia2V5c1RvUmVsYXlzLCBhdXRob3JzTWlzc2luZ1JlbGF5cyB9ID0gZ2V0QWxsUmVsYXlzRm9yQWxsUHVia2V5cyhuZGssIHB1YmtleXMsIHR5cGUpO1xuICBjb25zdCBzb3J0ZWRSZWxheXMgPSBnZXRUb3BSZWxheXNGb3JBdXRob3JzKG5kaywgcHVia2V5cyk7XG4gIGNvbnN0IGFkZEF1dGhvclRvUmVsYXkgPSAoYXV0aG9yLCByZWxheSkgPT4ge1xuICAgIGNvbnN0IGF1dGhvcnNJblJlbGF5ID0gcmVsYXlUb0F1dGhvcnNNYXAuZ2V0KHJlbGF5KSB8fCBbXTtcbiAgICBhdXRob3JzSW5SZWxheS5wdXNoKGF1dGhvcik7XG4gICAgcmVsYXlUb0F1dGhvcnNNYXAuc2V0KHJlbGF5LCBhdXRob3JzSW5SZWxheSk7XG4gIH07XG4gIGZvciAoY29uc3QgW2F1dGhvciwgYXV0aG9yUmVsYXlzXSBvZiBwdWJrZXlzVG9SZWxheXMuZW50cmllcygpKSB7XG4gICAgbGV0IG1pc3NpbmdSZWxheUNvdW50ID0gY291bnQ7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiBjb25uZWN0ZWRSZWxheXMpIHtcbiAgICAgIGlmIChhdXRob3JSZWxheXMuaGFzKHJlbGF5LnVybCkpIHtcbiAgICAgICAgYWRkQXV0aG9yVG9SZWxheShhdXRob3IsIHJlbGF5LnVybCk7XG4gICAgICAgIG1pc3NpbmdSZWxheUNvdW50LS07XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXV0aG9yUmVsYXkgb2YgYXV0aG9yUmVsYXlzKSB7XG4gICAgICBpZiAocmVsYXlUb0F1dGhvcnNNYXAuaGFzKGF1dGhvclJlbGF5KSkge1xuICAgICAgICBhZGRBdXRob3JUb1JlbGF5KGF1dGhvciwgYXV0aG9yUmVsYXkpO1xuICAgICAgICBtaXNzaW5nUmVsYXlDb3VudC0tO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWlzc2luZ1JlbGF5Q291bnQgPD0gMCkgY29udGludWU7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiBzb3J0ZWRSZWxheXMpIHtcbiAgICAgIGlmIChtaXNzaW5nUmVsYXlDb3VudCA8PSAwKSBicmVhaztcbiAgICAgIGlmIChhdXRob3JSZWxheXMuaGFzKHJlbGF5KSkge1xuICAgICAgICBhZGRBdXRob3JUb1JlbGF5KGF1dGhvciwgcmVsYXkpO1xuICAgICAgICBtaXNzaW5nUmVsYXlDb3VudC0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGF1dGhvciBvZiBhdXRob3JzTWlzc2luZ1JlbGF5cykge1xuICAgIHBvb2wucGVybWFuZW50QW5kQ29ubmVjdGVkUmVsYXlzKCkuZm9yRWFjaCgocmVsYXkpID0+IHtcbiAgICAgIGNvbnN0IGF1dGhvcnNJblJlbGF5ID0gcmVsYXlUb0F1dGhvcnNNYXAuZ2V0KHJlbGF5LnVybCkgfHwgW107XG4gICAgICBhdXRob3JzSW5SZWxheS5wdXNoKGF1dGhvcik7XG4gICAgICByZWxheVRvQXV0aG9yc01hcC5zZXQocmVsYXkudXJsLCBhdXRob3JzSW5SZWxheSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlbGF5VG9BdXRob3JzTWFwO1xufVxuXG4vLyBzcmMvb3V0Ym94L3JlYWQvd2l0aC1hdXRob3JzLnRzXG5mdW5jdGlvbiBnZXRSZWxheXNGb3JGaWx0ZXJXaXRoQXV0aG9ycyhuZGssIGF1dGhvcnMsIHJlbGF5R29hbFBlckF1dGhvciA9IDIpIHtcbiAgcmV0dXJuIGNob29zZVJlbGF5Q29tYmluYXRpb25Gb3JQdWJrZXlzKG5kaywgYXV0aG9ycywgXCJ3cml0ZVwiLCB7IGNvdW50OiByZWxheUdvYWxQZXJBdXRob3IgfSk7XG59XG5cbi8vIHNyYy91dGlscy9ub3JtYWxpemUtdXJsLnRzXG5mdW5jdGlvbiB0cnlOb3JtYWxpemVSZWxheVVybCh1cmwpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbm9ybWFsaXplUmVsYXlVcmwodXJsKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplUmVsYXlVcmwodXJsKSB7XG4gIGxldCByID0gbm9ybWFsaXplVXJsKHVybCwge1xuICAgIHN0cmlwQXV0aGVudGljYXRpb246IGZhbHNlLFxuICAgIHN0cmlwV1dXOiBmYWxzZSxcbiAgICBzdHJpcEhhc2g6IHRydWVcbiAgfSk7XG4gIGlmICghci5lbmRzV2l0aChcIi9cIikpIHtcbiAgICByICs9IFwiL1wiO1xuICB9XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplKHVybHMpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgdXJsIG9mIHVybHMpIHtcbiAgICB0cnkge1xuICAgICAgbm9ybWFsaXplZC5hZGQobm9ybWFsaXplUmVsYXlVcmwodXJsKSk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKG5vcm1hbGl6ZWQpO1xufVxudmFyIERBVEFfVVJMX0RFRkFVTFRfTUlNRV9UWVBFID0gXCJ0ZXh0L3BsYWluXCI7XG52YXIgREFUQV9VUkxfREVGQVVMVF9DSEFSU0VUID0gXCJ1cy1hc2NpaVwiO1xudmFyIHRlc3RQYXJhbWV0ZXIgPSAobmFtZSwgZmlsdGVycykgPT4gZmlsdGVycy5zb21lKChmaWx0ZXIpID0+IGZpbHRlciBpbnN0YW5jZW9mIFJlZ0V4cCA/IGZpbHRlci50ZXN0KG5hbWUpIDogZmlsdGVyID09PSBuYW1lKTtcbnZhciBzdXBwb3J0ZWRQcm90b2NvbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJodHRwczpcIiwgXCJodHRwOlwiLCBcImZpbGU6XCJdKTtcbnZhciBoYXNDdXN0b21Qcm90b2NvbCA9ICh1cmxTdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IHByb3RvY29sIH0gPSBuZXcgVVJMKHVybFN0cmluZyk7XG4gICAgcmV0dXJuIHByb3RvY29sLmVuZHNXaXRoKFwiOlwiKSAmJiAhcHJvdG9jb2wuaW5jbHVkZXMoXCIuXCIpICYmICFzdXBwb3J0ZWRQcm90b2NvbHMuaGFzKHByb3RvY29sKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIG5vcm1hbGl6ZURhdGFVUkwgPSAodXJsU3RyaW5nLCB7IHN0cmlwSGFzaCB9KSA9PiB7XG4gIGNvbnN0IG1hdGNoID0gL15kYXRhOig/PHR5cGU+W14sXSo/KSwoPzxkYXRhPlteI10qPykoPzojKD88aGFzaD4uKikpPyQvLmV4ZWModXJsU3RyaW5nKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVUkw6ICR7dXJsU3RyaW5nfWApO1xuICB9XG4gIGNvbnN0IHR5cGUgPSBtYXRjaC5ncm91cHM/LnR5cGUgPz8gXCJcIjtcbiAgY29uc3QgZGF0YSA9IG1hdGNoLmdyb3Vwcz8uZGF0YSA/PyBcIlwiO1xuICBsZXQgaGFzaCA9IG1hdGNoLmdyb3Vwcz8uaGFzaCA/PyBcIlwiO1xuICBjb25zdCBtZWRpYVR5cGUgPSB0eXBlLnNwbGl0KFwiO1wiKTtcbiAgaGFzaCA9IHN0cmlwSGFzaCA/IFwiXCIgOiBoYXNoO1xuICBsZXQgaXNCYXNlNjQgPSBmYWxzZTtcbiAgaWYgKG1lZGlhVHlwZVttZWRpYVR5cGUubGVuZ3RoIC0gMV0gPT09IFwiYmFzZTY0XCIpIHtcbiAgICBtZWRpYVR5cGUucG9wKCk7XG4gICAgaXNCYXNlNjQgPSB0cnVlO1xuICB9XG4gIGNvbnN0IG1pbWVUeXBlID0gbWVkaWFUeXBlLnNoaWZ0KCk/LnRvTG93ZXJDYXNlKCkgPz8gXCJcIjtcbiAgY29uc3QgYXR0cmlidXRlcyA9IG1lZGlhVHlwZS5tYXAoKGF0dHJpYnV0ZSkgPT4ge1xuICAgIGxldCBba2V5LCB2YWx1ZSA9IFwiXCJdID0gYXR0cmlidXRlLnNwbGl0KFwiPVwiKS5tYXAoKHN0cmluZykgPT4gc3RyaW5nLnRyaW0oKSk7XG4gICAgaWYgKGtleSA9PT0gXCJjaGFyc2V0XCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gREFUQV9VUkxfREVGQVVMVF9DSEFSU0VUKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYCR7a2V5fSR7dmFsdWUgPyBgPSR7dmFsdWV9YCA6IFwiXCJ9YDtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBub3JtYWxpemVkTWVkaWFUeXBlID0gWy4uLmF0dHJpYnV0ZXNdO1xuICBpZiAoaXNCYXNlNjQpIHtcbiAgICBub3JtYWxpemVkTWVkaWFUeXBlLnB1c2goXCJiYXNlNjRcIik7XG4gIH1cbiAgaWYgKG5vcm1hbGl6ZWRNZWRpYVR5cGUubGVuZ3RoID4gMCB8fCBtaW1lVHlwZSAmJiBtaW1lVHlwZSAhPT0gREFUQV9VUkxfREVGQVVMVF9NSU1FX1RZUEUpIHtcbiAgICBub3JtYWxpemVkTWVkaWFUeXBlLnVuc2hpZnQobWltZVR5cGUpO1xuICB9XG4gIHJldHVybiBgZGF0YToke25vcm1hbGl6ZWRNZWRpYVR5cGUuam9pbihcIjtcIil9LCR7aXNCYXNlNjQgPyBkYXRhLnRyaW0oKSA6IGRhdGF9JHtoYXNoID8gYCMke2hhc2h9YCA6IFwiXCJ9YDtcbn07XG5mdW5jdGlvbiBub3JtYWxpemVVcmwodXJsU3RyaW5nLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucyA9IHtcbiAgICBkZWZhdWx0UHJvdG9jb2w6IFwiaHR0cFwiLFxuICAgIG5vcm1hbGl6ZVByb3RvY29sOiB0cnVlLFxuICAgIGZvcmNlSHR0cDogZmFsc2UsXG4gICAgZm9yY2VIdHRwczogZmFsc2UsXG4gICAgc3RyaXBBdXRoZW50aWNhdGlvbjogdHJ1ZSxcbiAgICBzdHJpcEhhc2g6IGZhbHNlLFxuICAgIHN0cmlwVGV4dEZyYWdtZW50OiB0cnVlLFxuICAgIHN0cmlwV1dXOiB0cnVlLFxuICAgIHJlbW92ZVF1ZXJ5UGFyYW1ldGVyczogWy9edXRtX1xcdysvaV0sXG4gICAgcmVtb3ZlVHJhaWxpbmdTbGFzaDogdHJ1ZSxcbiAgICByZW1vdmVTaW5nbGVTbGFzaDogdHJ1ZSxcbiAgICByZW1vdmVEaXJlY3RvcnlJbmRleDogZmFsc2UsXG4gICAgcmVtb3ZlRXhwbGljaXRQb3J0OiBmYWxzZSxcbiAgICBzb3J0UXVlcnlQYXJhbWV0ZXJzOiB0cnVlLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmRlZmF1bHRQcm90b2NvbCA9PT0gXCJzdHJpbmdcIiAmJiAhb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wuZW5kc1dpdGgoXCI6XCIpKSB7XG4gICAgb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wgPSBgJHtvcHRpb25zLmRlZmF1bHRQcm90b2NvbH06YDtcbiAgfVxuICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcudHJpbSgpO1xuICBpZiAoL15kYXRhOi9pLnRlc3QodXJsU3RyaW5nKSkge1xuICAgIHJldHVybiBub3JtYWxpemVEYXRhVVJMKHVybFN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGhhc0N1c3RvbVByb3RvY29sKHVybFN0cmluZykpIHtcbiAgICByZXR1cm4gdXJsU3RyaW5nO1xuICB9XG4gIGNvbnN0IGhhc1JlbGF0aXZlUHJvdG9jb2wgPSB1cmxTdHJpbmcuc3RhcnRzV2l0aChcIi8vXCIpO1xuICBjb25zdCBpc1JlbGF0aXZlVXJsID0gIWhhc1JlbGF0aXZlUHJvdG9jb2wgJiYgL15cXC4qXFwvLy50ZXN0KHVybFN0cmluZyk7XG4gIGlmICghaXNSZWxhdGl2ZVVybCkge1xuICAgIHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9eKD8hKD86XFx3KzopP1xcL1xcLyl8XlxcL1xcLy8sIG9wdGlvbnMuZGVmYXVsdFByb3RvY29sKTtcbiAgfVxuICBjb25zdCB1cmxPYmplY3QgPSBuZXcgVVJMKHVybFN0cmluZyk7XG4gIHVybE9iamVjdC5ob3N0bmFtZSA9IHVybE9iamVjdC5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAob3B0aW9ucy5mb3JjZUh0dHAgJiYgb3B0aW9ucy5mb3JjZUh0dHBzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGBmb3JjZUh0dHBgIGFuZCBgZm9yY2VIdHRwc2Agb3B0aW9ucyBjYW5ub3QgYmUgdXNlZCB0b2dldGhlclwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5mb3JjZUh0dHAgJiYgdXJsT2JqZWN0LnByb3RvY29sID09PSBcImh0dHBzOlwiKSB7XG4gICAgdXJsT2JqZWN0LnByb3RvY29sID0gXCJodHRwOlwiO1xuICB9XG4gIGlmIChvcHRpb25zLmZvcmNlSHR0cHMgJiYgdXJsT2JqZWN0LnByb3RvY29sID09PSBcImh0dHA6XCIpIHtcbiAgICB1cmxPYmplY3QucHJvdG9jb2wgPSBcImh0dHBzOlwiO1xuICB9XG4gIGlmIChvcHRpb25zLnN0cmlwQXV0aGVudGljYXRpb24pIHtcbiAgICB1cmxPYmplY3QudXNlcm5hbWUgPSBcIlwiO1xuICAgIHVybE9iamVjdC5wYXNzd29yZCA9IFwiXCI7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RyaXBIYXNoKSB7XG4gICAgdXJsT2JqZWN0Lmhhc2ggPSBcIlwiO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuc3RyaXBUZXh0RnJhZ21lbnQpIHtcbiAgICB1cmxPYmplY3QuaGFzaCA9IHVybE9iamVjdC5oYXNoLnJlcGxhY2UoLyM/On46dGV4dC4qPyQvaSwgXCJcIik7XG4gIH1cbiAgaWYgKHVybE9iamVjdC5wYXRobmFtZSkge1xuICAgIGNvbnN0IHByb3RvY29sUmVnZXggPSAvXFxiW2Etel1bYS16XFxkK1xcLS5dezEsNTB9OlxcL1xcLy9nO1xuICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAoOyA7ICkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBwcm90b2NvbFJlZ2V4LmV4ZWModXJsT2JqZWN0LnBhdGhuYW1lKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm90b2NvbCA9IG1hdGNoWzBdO1xuICAgICAgY29uc3QgcHJvdG9jb2xBdEluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICBjb25zdCBpbnRlcm1lZGlhdGUgPSB1cmxPYmplY3QucGF0aG5hbWUuc2xpY2UobGFzdEluZGV4LCBwcm90b2NvbEF0SW5kZXgpO1xuICAgICAgcmVzdWx0ICs9IGludGVybWVkaWF0ZS5yZXBsYWNlKC9cXC97Mix9L2csIFwiL1wiKTtcbiAgICAgIHJlc3VsdCArPSBwcm90b2NvbDtcbiAgICAgIGxhc3RJbmRleCA9IHByb3RvY29sQXRJbmRleCArIHByb3RvY29sLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVtbmFudCA9IHVybE9iamVjdC5wYXRobmFtZS5zbGljZShsYXN0SW5kZXgsIHVybE9iamVjdC5wYXRobmFtZS5sZW5ndGgpO1xuICAgIHJlc3VsdCArPSByZW1uYW50LnJlcGxhY2UoL1xcL3syLH0vZywgXCIvXCIpO1xuICAgIHVybE9iamVjdC5wYXRobmFtZSA9IHJlc3VsdDtcbiAgfVxuICBpZiAodXJsT2JqZWN0LnBhdGhuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHVybE9iamVjdC5wYXRobmFtZSA9IGRlY29kZVVSSSh1cmxPYmplY3QucGF0aG5hbWUpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5yZW1vdmVEaXJlY3RvcnlJbmRleCA9PT0gdHJ1ZSkge1xuICAgIG9wdGlvbnMucmVtb3ZlRGlyZWN0b3J5SW5kZXggPSBbL15pbmRleFxcLlthLXpdKyQvXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4KSAmJiBvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4Lmxlbmd0aCA+IDApIHtcbiAgICBsZXQgcGF0aENvbXBvbmVudHMgPSB1cmxPYmplY3QucGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuICAgIGNvbnN0IGxhc3RDb21wb25lbnQgPSBwYXRoQ29tcG9uZW50c1twYXRoQ29tcG9uZW50cy5sZW5ndGggLSAxXTtcbiAgICBpZiAodGVzdFBhcmFtZXRlcihsYXN0Q29tcG9uZW50LCBvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4KSkge1xuICAgICAgcGF0aENvbXBvbmVudHMgPSBwYXRoQ29tcG9uZW50cy5zbGljZSgwLCAtMSk7XG4gICAgICB1cmxPYmplY3QucGF0aG5hbWUgPSBgJHtwYXRoQ29tcG9uZW50cy5zbGljZSgxKS5qb2luKFwiL1wiKX0vYDtcbiAgICB9XG4gIH1cbiAgaWYgKHVybE9iamVjdC5ob3N0bmFtZSkge1xuICAgIHVybE9iamVjdC5ob3N0bmFtZSA9IHVybE9iamVjdC5ob3N0bmFtZS5yZXBsYWNlKC9cXC4kLywgXCJcIik7XG4gICAgaWYgKG9wdGlvbnMuc3RyaXBXV1cgJiYgL153d3dcXC4oPyF3d3dcXC4pW2EtelxcLVxcZF17MSw2M31cXC5bYS16LlxcLVxcZF17Miw2M30kLy50ZXN0KHVybE9iamVjdC5ob3N0bmFtZSkpIHtcbiAgICAgIHVybE9iamVjdC5ob3N0bmFtZSA9IHVybE9iamVjdC5ob3N0bmFtZS5yZXBsYWNlKC9ed3d3XFwuLywgXCJcIik7XG4gICAgfVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucmVtb3ZlUXVlcnlQYXJhbWV0ZXJzKSkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFsuLi51cmxPYmplY3Quc2VhcmNoUGFyYW1zLmtleXMoKV0pIHtcbiAgICAgIGlmICh0ZXN0UGFyYW1ldGVyKGtleSwgb3B0aW9ucy5yZW1vdmVRdWVyeVBhcmFtZXRlcnMpKSB7XG4gICAgICAgIHVybE9iamVjdC5zZWFyY2hQYXJhbXMuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmtlZXBRdWVyeVBhcmFtZXRlcnMpICYmIG9wdGlvbnMucmVtb3ZlUXVlcnlQYXJhbWV0ZXJzID09PSB0cnVlKSB7XG4gICAgdXJsT2JqZWN0LnNlYXJjaCA9IFwiXCI7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5rZWVwUXVlcnlQYXJhbWV0ZXJzKSAmJiBvcHRpb25zLmtlZXBRdWVyeVBhcmFtZXRlcnMubGVuZ3RoID4gMCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFsuLi51cmxPYmplY3Quc2VhcmNoUGFyYW1zLmtleXMoKV0pIHtcbiAgICAgIGlmICghdGVzdFBhcmFtZXRlcihrZXksIG9wdGlvbnMua2VlcFF1ZXJ5UGFyYW1ldGVycykpIHtcbiAgICAgICAgdXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuc29ydFF1ZXJ5UGFyYW1ldGVycykge1xuICAgIHVybE9iamVjdC5zZWFyY2hQYXJhbXMuc29ydCgpO1xuICAgIHRyeSB7XG4gICAgICB1cmxPYmplY3Quc2VhcmNoID0gZGVjb2RlVVJJQ29tcG9uZW50KHVybE9iamVjdC5zZWFyY2gpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5yZW1vdmVUcmFpbGluZ1NsYXNoKSB7XG4gICAgdXJsT2JqZWN0LnBhdGhuYW1lID0gdXJsT2JqZWN0LnBhdGhuYW1lLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5yZW1vdmVFeHBsaWNpdFBvcnQgJiYgdXJsT2JqZWN0LnBvcnQpIHtcbiAgICB1cmxPYmplY3QucG9ydCA9IFwiXCI7XG4gIH1cbiAgY29uc3Qgb2xkVXJsU3RyaW5nID0gdXJsU3RyaW5nO1xuICB1cmxTdHJpbmcgPSB1cmxPYmplY3QudG9TdHJpbmcoKTtcbiAgaWYgKCFvcHRpb25zLnJlbW92ZVNpbmdsZVNsYXNoICYmIHVybE9iamVjdC5wYXRobmFtZSA9PT0gXCIvXCIgJiYgIW9sZFVybFN0cmluZy5lbmRzV2l0aChcIi9cIikgJiYgdXJsT2JqZWN0Lmhhc2ggPT09IFwiXCIpIHtcbiAgICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICB9XG4gIGlmICgob3B0aW9ucy5yZW1vdmVUcmFpbGluZ1NsYXNoIHx8IHVybE9iamVjdC5wYXRobmFtZSA9PT0gXCIvXCIpICYmIHVybE9iamVjdC5oYXNoID09PSBcIlwiICYmIG9wdGlvbnMucmVtb3ZlU2luZ2xlU2xhc2gpIHtcbiAgICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICB9XG4gIGlmIChoYXNSZWxhdGl2ZVByb3RvY29sICYmICFvcHRpb25zLm5vcm1hbGl6ZVByb3RvY29sKSB7XG4gICAgdXJsU3RyaW5nID0gdXJsU3RyaW5nLnJlcGxhY2UoL15odHRwOlxcL1xcLy8sIFwiLy9cIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RyaXBQcm90b2NvbCkge1xuICAgIHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9eKD86aHR0cHM/Oik/XFwvXFwvLywgXCJcIik7XG4gIH1cbiAgcmV0dXJuIHVybFN0cmluZztcbn1cblxuLy8gc3JjL3JlbGF5L2luZGV4LnRzXG5pbXBvcnQgZGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tIFwidHNlZXBcIjtcblxuLy8gc3JjL3JlbGF5L2Nvbm5lY3Rpdml0eS50c1xudmFyIE1BWF9SRUNPTk5FQ1RfQVRURU1QVFMgPSA1O1xudmFyIEZMQVBQSU5HX1RIUkVTSE9MRF9NUyA9IDFlMztcbnZhciBOREtSZWxheUNvbm5lY3Rpdml0eSA9IGNsYXNzIHtcbiAgbmRrUmVsYXk7XG4gIHdzO1xuICBfc3RhdHVzO1xuICB0aW1lb3V0TXM7XG4gIGNvbm5lY3RlZEF0O1xuICBfY29ubmVjdGlvblN0YXRzID0ge1xuICAgIGF0dGVtcHRzOiAwLFxuICAgIHN1Y2Nlc3M6IDAsXG4gICAgZHVyYXRpb25zOiBbXVxuICB9O1xuICBkZWJ1ZztcbiAgbmV0RGVidWc7XG4gIGNvbm5lY3RUaW1lb3V0O1xuICByZWNvbm5lY3RUaW1lb3V0O1xuICBuZGs7XG4gIG9wZW5TdWJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgb3BlbkNvdW50UmVxdWVzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBvcGVuRXZlbnRQdWJsaXNoZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzZXJpYWwgPSAwO1xuICBiYXNlRW9zZVRpbWVvdXQgPSA0NDAwO1xuICBjb25zdHJ1Y3RvcihuZGtSZWxheSwgbmRrKSB7XG4gICAgdGhpcy5uZGtSZWxheSA9IG5ka1JlbGF5O1xuICAgIHRoaXMuX3N0YXR1cyA9IDEgLyogRElTQ09OTkVDVEVEICovO1xuICAgIGNvbnN0IHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTMpO1xuICAgIHRoaXMuZGVidWcgPSB0aGlzLm5ka1JlbGF5LmRlYnVnLmV4dGVuZChgY29ubmVjdGl2aXR5JHtyYW5kfWApO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byB0aGUgTkRLIHJlbGF5IGFuZCBoYW5kbGVzIHRoZSBjb25uZWN0aW9uIGxpZmVjeWNsZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgYXR0ZW1wdHMgdG8gZXN0YWJsaXNoIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIE5ESyByZWxheSBzcGVjaWZpZWQgaW4gdGhlIGBuZGtSZWxheWAgb2JqZWN0LlxuICAgKiBJZiB0aGUgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsLCBpdCB1cGRhdGVzIHRoZSBjb25uZWN0aW9uIHN0YXRpc3RpY3MsIHNldHMgdGhlIGNvbm5lY3Rpb24gc3RhdHVzIHRvIGBDT05ORUNURURgLFxuICAgKiBhbmQgZW1pdHMgYGNvbm5lY3RgIGFuZCBgcmVhZHlgIGV2ZW50cyBvbiB0aGUgYG5ka1JlbGF5YCBvYmplY3QuXG4gICAqXG4gICAqIElmIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQgZmFpbHMsIGl0IGhhbmRsZXMgdGhlIGVycm9yIGJ5IGVpdGhlciBpbml0aWF0aW5nIGEgcmVjb25uZWN0aW9uIGF0dGVtcHQgb3IgZW1pdHRpbmcgYVxuICAgKiBgZGVsYXllZC1jb25uZWN0YCBldmVudCBvbiB0aGUgYG5ka1JlbGF5YCBvYmplY3QsIGRlcGVuZGluZyBvbiB0aGUgYHJlY29ubmVjdGAgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0gdGltZW91dE1zIC0gVGhlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgY29ubmVjdGlvbiBhdHRlbXB0LiBJZiBub3QgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IHRpbWVvdXQgZnJvbSB0aGUgYG5ka1JlbGF5YCBvYmplY3QgaXMgdXNlZC5cbiAgICogQHBhcmFtIHJlY29ubmVjdCAtIEluZGljYXRlcyB3aGV0aGVyIGEgcmVjb25uZWN0aW9uIHNob3VsZCBiZSBhdHRlbXB0ZWQgaWYgdGhlIGNvbm5lY3Rpb24gZmFpbHMuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgb3IgcmVqZWN0cyBpZiB0aGUgY29ubmVjdGlvbiBmYWlscy5cbiAgICovXG4gIGFzeW5jIGNvbm5lY3QodGltZW91dE1zLCByZWNvbm5lY3QgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuX3N0YXR1cyAhPT0gMiAvKiBSRUNPTk5FQ1RJTkcgKi8gJiYgdGhpcy5fc3RhdHVzICE9PSAxIC8qIERJU0NPTk5FQ1RFRCAqLyB8fCB0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgIFwiUmVsYXkgcmVxdWVzdGVkIHRvIGJlIGNvbm5lY3RlZCBidXQgd2FzIGluIHN0YXRlICVzIG9yIGl0IGhhZCBhIHJlY29ubmVjdCB0aW1lb3V0XCIsXG4gICAgICAgIHRoaXMuX3N0YXR1c1xuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dCk7XG4gICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0ID0gdm9pZCAwO1xuICAgIH1cbiAgICB0aW1lb3V0TXMgPz89IHRoaXMudGltZW91dE1zO1xuICAgIGlmICghdGhpcy50aW1lb3V0TXMgJiYgdGltZW91dE1zKSB0aGlzLnRpbWVvdXRNcyA9IHRpbWVvdXRNcztcbiAgICBpZiAodGhpcy50aW1lb3V0TXMpIHRoaXMuY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMub25Db25uZWN0aW9uRXJyb3IocmVjb25uZWN0KSwgdGhpcy50aW1lb3V0TXMpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25TdGF0cy5hdHRlbXB0KCk7XG4gICAgICBpZiAodGhpcy5fc3RhdHVzID09PSAxIC8qIERJU0NPTk5FQ1RFRCAqLykgdGhpcy5fc3RhdHVzID0gNCAvKiBDT05ORUNUSU5HICovO1xuICAgICAgZWxzZSB0aGlzLl9zdGF0dXMgPSAyIC8qIFJFQ09OTkVDVElORyAqLztcbiAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHRoaXMubmRrUmVsYXkudXJsKTtcbiAgICAgIHRoaXMud3Mub25vcGVuID0gdGhpcy5vbkNvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMud3Mub25jbG9zZSA9IHRoaXMub25EaXNjb25uZWN0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IHRoaXMub25NZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLndzLm9uZXJyb3IgPSB0aGlzLm9uRXJyb3IuYmluZCh0aGlzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmRlYnVnKGBGYWlsZWQgdG8gY29ubmVjdCB0byAke3RoaXMubmRrUmVsYXkudXJsfWAsIGUpO1xuICAgICAgdGhpcy5fc3RhdHVzID0gMSAvKiBESVNDT05ORUNURUQgKi87XG4gICAgICBpZiAocmVjb25uZWN0KSB0aGlzLmhhbmRsZVJlY29ubmVjdGlvbigpO1xuICAgICAgZWxzZSB0aGlzLm5ka1JlbGF5LmVtaXQoXCJkZWxheWVkLWNvbm5lY3RcIiwgMiAqIDI0ICogNjAgKiA2MCAqIDFlMyk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGlzY29ubmVjdHMgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIHRvIHRoZSBOREsgcmVsYXkuXG4gICAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIGNvbm5lY3Rpb24gc3RhdHVzIHRvIGBOREtSZWxheVN0YXR1cy5ESVNDT05ORUNUSU5HYCxcbiAgICogYXR0ZW1wdHMgdG8gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLCBhbmQgc2V0cyB0aGUgc3RhdHVzIHRvXG4gICAqIGBOREtSZWxheVN0YXR1cy5ESVNDT05ORUNURURgIGlmIHRoZSBkaXNjb25uZWN0IG9wZXJhdGlvbiBmYWlscy5cbiAgICovXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5fc3RhdHVzID0gMCAvKiBESVNDT05ORUNUSU5HICovO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLndzPy5jbG9zZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJGYWlsZWQgdG8gZGlzY29ubmVjdFwiLCBlKTtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IDEgLyogRElTQ09OTkVDVEVEICovO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgZXJyb3IgdGhhdCBvY2N1cnJlZCB3aGVuIGF0dGVtcHRpbmcgdG8gY29ubmVjdCB0byB0aGUgTkRLIHJlbGF5LlxuICAgKiBJZiBgcmVjb25uZWN0YCBpcyBgdHJ1ZWAsIHRoaXMgbWV0aG9kIHdpbGwgaW5pdGlhdGUgYSByZWNvbm5lY3Rpb24gYXR0ZW1wdC5cbiAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIGVtaXQgYSBgZGVsYXllZC1jb25uZWN0YCBldmVudCBvbiB0aGUgYG5ka1JlbGF5YCBvYmplY3QsXG4gICAqIGluZGljYXRpbmcgdGhhdCBhIHJlY29ubmVjdGlvbiBzaG91bGQgYmUgYXR0ZW1wdGVkIGFmdGVyIGEgZGVsYXkuXG4gICAqXG4gICAqIEBwYXJhbSByZWNvbm5lY3QgLSBJbmRpY2F0ZXMgd2hldGhlciBhIHJlY29ubmVjdGlvbiBzaG91bGQgYmUgYXR0ZW1wdGVkLlxuICAgKi9cbiAgb25Db25uZWN0aW9uRXJyb3IocmVjb25uZWN0KSB7XG4gICAgdGhpcy5kZWJ1ZyhgRXJyb3IgY29ubmVjdGluZyB0byAke3RoaXMubmRrUmVsYXkudXJsfWAsIHRoaXMudGltZW91dE1zKTtcbiAgICBpZiAocmVjb25uZWN0ICYmICF0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIHRoaXMuaGFuZGxlUmVjb25uZWN0aW9uKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBjb25uZWN0aW9uIGV2ZW50IHdoZW4gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bGx5IG9wZW5lZC5cbiAgICogSXQgY2xlYXJzIGFueSBleGlzdGluZyBjb25uZWN0aW9uIGFuZCByZWNvbm5lY3Rpb24gdGltZW91dHMsIHVwZGF0ZXMgdGhlIGNvbm5lY3Rpb24gc3RhdGlzdGljcyxcbiAgICogc2V0cyB0aGUgY29ubmVjdGlvbiBzdGF0dXMgdG8gYENPTk5FQ1RFRGAsIGFuZCBlbWl0cyBgY29ubmVjdGAgYW5kIGByZWFkeWAgZXZlbnRzIG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdC5cbiAgICovXG4gIG9uQ29ubmVjdCgpIHtcbiAgICB0aGlzLm5ldERlYnVnPy4oXCJjb25uZWN0ZWRcIiwgdGhpcy5uZGtSZWxheSk7XG4gICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dCk7XG4gICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0ID0gdm9pZCAwO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWQoKTtcbiAgICB0aGlzLl9zdGF0dXMgPSA1IC8qIENPTk5FQ1RFRCAqLztcbiAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJjb25uZWN0XCIpO1xuICAgIHRoaXMubmRrUmVsYXkuZW1pdChcInJlYWR5XCIpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBkaXNjb25uZWN0aW9uIGV2ZW50IHdoZW4gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGNsb3NlZC5cbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWxseSBjbG9zZWQuXG4gICAqIEl0IHVwZGF0ZXMgdGhlIGNvbm5lY3Rpb24gc3RhdGlzdGljcywgc2V0cyB0aGUgY29ubmVjdGlvbiBzdGF0dXMgdG8gYERJU0NPTk5FQ1RFRGAsXG4gICAqIGluaXRpYXRlcyBhIHJlY29ubmVjdGlvbiBhdHRlbXB0IGlmIHdlIGRpZG4ndCBkaXNjb25uZWN0IG91cnNlbHZlcyxcbiAgICogYW5kIGVtaXRzIGEgYGRpc2Nvbm5lY3RgIGV2ZW50IG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdC5cbiAgICovXG4gIG9uRGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLm5ldERlYnVnPy4oXCJkaXNjb25uZWN0ZWRcIiwgdGhpcy5uZGtSZWxheSk7XG4gICAgdGhpcy51cGRhdGVDb25uZWN0aW9uU3RhdHMuZGlzY29ubmVjdGVkKCk7XG4gICAgaWYgKHRoaXMuX3N0YXR1cyA9PT0gNSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgIHRoaXMuaGFuZGxlUmVjb25uZWN0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuX3N0YXR1cyA9IDEgLyogRElTQ09OTkVDVEVEICovO1xuICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImRpc2Nvbm5lY3RcIik7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgaW5jb21pbmcgbWVzc2FnZXMgZnJvbSB0aGUgTkRLIHJlbGF5IFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBtZXNzYWdlIGlzIHJlY2VpdmVkIGZyb20gdGhlIHJlbGF5LlxuICAgKiBJdCBwYXJzZXMgdGhlIG1lc3NhZ2UgZGF0YSBhbmQgZGlzcGF0Y2hlcyB0aGUgYXBwcm9wcmlhdGUgaGFuZGxpbmcgbG9naWMgYmFzZWQgb24gdGhlIG1lc3NhZ2UgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIE1lc3NhZ2VFdmVudCBjb250YWluaW5nIHRoZSByZWNlaXZlZCBtZXNzYWdlIGRhdGEuXG4gICAqL1xuICBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICB0aGlzLm5ldERlYnVnPy4oZXZlbnQuZGF0YSwgdGhpcy5uZGtSZWxheSwgXCJyZWN2XCIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgIGNvbnN0IFtjbWQsIGlkLCAuLi5fcmVzdF0gPSBkYXRhO1xuICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgY2FzZSBcIkVWRU5UXCI6IHtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGlkKTtcbiAgICAgICAgICBjb25zdCBldmVudDIgPSBkYXRhWzJdO1xuICAgICAgICAgIGlmICghc28pIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoYFJlY2VpdmVkIGV2ZW50IGZvciB1bmtub3duIHN1YnNjcmlwdGlvbiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzby5vbmV2ZW50KGV2ZW50Mik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJDT1VOVFwiOiB7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGFbMl07XG4gICAgICAgICAgY29uc3QgY3IgPSB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLmdldChpZCk7XG4gICAgICAgICAgaWYgKGNyKSB7XG4gICAgICAgICAgICBjci5yZXNvbHZlKHBheWxvYWQuY291bnQpO1xuICAgICAgICAgICAgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5kZWxldGUoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkVPU0VcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoaWQpO1xuICAgICAgICAgIGlmICghc28pIHJldHVybjtcbiAgICAgICAgICBzby5vbmVvc2UoaWQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiT0tcIjoge1xuICAgICAgICAgIGNvbnN0IG9rID0gZGF0YVsyXTtcbiAgICAgICAgICBjb25zdCByZWFzb24gPSBkYXRhWzNdO1xuICAgICAgICAgIGNvbnN0IGVwID0gdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZ2V0KGlkKTtcbiAgICAgICAgICBjb25zdCBmaXJzdEVwID0gZXA/LnBvcCgpO1xuICAgICAgICAgIGlmICghZXAgfHwgIWZpcnN0RXApIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoXCJSZWNlaXZlZCBPSyBmb3IgdW5rbm93biBldmVudCBwdWJsaXNoXCIsIGlkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9rKSBmaXJzdEVwLnJlc29sdmUocmVhc29uKTtcbiAgICAgICAgICBlbHNlIGZpcnN0RXAucmVqZWN0KG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICAgICAgICBpZiAoZXAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5kZWxldGUoaWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5zZXQoaWQsIGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJDTE9TRURcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoaWQpO1xuICAgICAgICAgIGlmICghc28pIHJldHVybjtcbiAgICAgICAgICBzby5vbmNsb3NlZChkYXRhWzJdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk5PVElDRVwiOlxuICAgICAgICAgIHRoaXMub25Ob3RpY2UoZGF0YVsxXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwiQVVUSFwiOiB7XG4gICAgICAgICAgdGhpcy5vbkF1dGhSZXF1ZXN0ZWQoZGF0YVsxXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZGVidWcoYEVycm9yIHBhcnNpbmcgbWVzc2FnZSBmcm9tICR7dGhpcy5uZGtSZWxheS51cmx9OiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3I/LnN0YWNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgYW4gYXV0aGVudGljYXRpb24gcmVxdWVzdCBmcm9tIHRoZSBOREsgcmVsYXkuXG4gICAqXG4gICAqIElmIGFuIGF1dGhlbnRpY2F0aW9uIHBvbGljeSBpcyBjb25maWd1cmVkLCBpdCB3aWxsIGJlIHVzZWQgdG8gYXV0aGVudGljYXRlIHRoZSBjb25uZWN0aW9uLlxuICAgKiBPdGhlcndpc2UsIHRoZSBgYXV0aGAgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIHRvIGFsbG93IHRoZSBhcHBsaWNhdGlvbiB0byBoYW5kbGUgdGhlIGF1dGhlbnRpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gY2hhbGxlbmdlIC0gVGhlIGF1dGhlbnRpY2F0aW9uIGNoYWxsZW5nZSBwcm92aWRlZCBieSB0aGUgTkRLIHJlbGF5LlxuICAgKi9cbiAgYXN5bmMgb25BdXRoUmVxdWVzdGVkKGNoYWxsZW5nZSkge1xuICAgIGNvbnN0IGF1dGhQb2xpY3kgPSB0aGlzLm5ka1JlbGF5LmF1dGhQb2xpY3kgPz8gdGhpcy5uZGs/LnJlbGF5QXV0aERlZmF1bHRQb2xpY3k7XG4gICAgdGhpcy5kZWJ1ZyhcIlJlbGF5IHJlcXVlc3RlZCBhdXRoZW50aWNhdGlvblwiLCB7XG4gICAgICBoYXZlUG9saWN5OiAhIWF1dGhQb2xpY3lcbiAgICB9KTtcbiAgICBpZiAodGhpcy5fc3RhdHVzID09PSA3IC8qIEFVVEhFTlRJQ0FUSU5HICovKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiQWxyZWFkeSBhdXRoZW50aWNhdGluZywgaWdub3JpbmdcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3N0YXR1cyA9IDYgLyogQVVUSF9SRVFVRVNURUQgKi87XG4gICAgaWYgKGF1dGhQb2xpY3kpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0dXMgPj0gNSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gNyAvKiBBVVRIRU5USUNBVElORyAqLztcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMgPSBhd2FpdCBhdXRoUG9saWN5KHRoaXMubmRrUmVsYXksIGNoYWxsZW5nZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmRlYnVnKFwiQXV0aGVudGljYXRpb24gcG9saWN5IHRocmV3IGFuIGVycm9yXCIsIGUpO1xuICAgICAgICAgIHJlcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVidWcoXCJBdXRoZW50aWNhdGlvbiBwb2xpY3kgcmV0dXJuZWRcIiwgISFyZXMpO1xuICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgTkRLRXZlbnQgfHwgcmVzID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIE5ES0V2ZW50KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmF1dGgocmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYXV0aGVudGljYXRlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXR1cyA+PSA1IC8qIENPTk5FQ1RFRCAqLyAmJiB0aGlzLl9zdGF0dXMgPCA4IC8qIEFVVEhFTlRJQ0FURUQgKi8pIHtcbiAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGspO1xuICAgICAgICAgICAgICBldmVudC5raW5kID0gMjIyNDIgLyogQ2xpZW50QXV0aCAqLztcbiAgICAgICAgICAgICAgZXZlbnQudGFncyA9IFtcbiAgICAgICAgICAgICAgICBbXCJyZWxheVwiLCB0aGlzLm5ka1JlbGF5LnVybF0sXG4gICAgICAgICAgICAgICAgW1wiY2hhbGxlbmdlXCIsIGNoYWxsZW5nZV1cbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgYXdhaXQgZXZlbnQuc2lnbigpO1xuICAgICAgICAgICAgICB0aGlzLmF1dGgoZXZlbnQpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IDggLyogQVVUSEVOVElDQVRFRCAqLztcbiAgICAgICAgICAgICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJhdXRoZWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIkF1dGhlbnRpY2F0aW9uIHN1Y2Nlc3NmdWxcIik7XG4gICAgICAgICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gNiAvKiBBVVRIX1JFUVVFU1RFRCAqLztcbiAgICAgICAgICAgICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJhdXRoOmZhaWxlZFwiLCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKFwiQXV0aGVudGljYXRpb24gZmFpbGVkXCIsIGUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVidWcoXCJBdXRoZW50aWNhdGlvbiBmYWlsZWQsIGl0IGNoYW5nZWQgc3RhdHVzLCBzdGF0dXMgaXMgJWRcIiwgdGhpcy5fc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChyZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5uZGs/LnNpZ25lcikge1xuICAgICAgICAgICAgICB0aGlzLmRlYnVnKFwiTm8gc2lnbmVyIGF2YWlsYWJsZSBmb3IgYXV0aGVudGljYXRpb24gbG9jYWxob3N0XCIpO1xuICAgICAgICAgICAgICB0aGlzLm5kaz8ub25jZShcInNpZ25lcjpyZWFkeVwiLCBhdXRoZW50aWNhdGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXV0aGVudGljYXRlKCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYXV0aGVudGljYXRpbmdcIiwgZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zdGF0dXMgPSA1IC8qIENPTk5FQ1RFRCAqLztcbiAgICAgICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJhdXRoZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uZGtSZWxheS5lbWl0KFwiYXV0aFwiLCBjaGFsbGVuZ2UpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBlcnJvcnMgdGhhdCBvY2N1ciBvbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIHJlbGF5LlxuICAgKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3Igb3IgZXZlbnQgdGhhdCBvY2N1cnJlZC5cbiAgICovXG4gIG9uRXJyb3IoZXJyb3IpIHtcbiAgICB0aGlzLmRlYnVnKGBXZWJTb2NrZXQgZXJyb3Igb24gJHt0aGlzLm5ka1JlbGF5LnVybH06YCwgZXJyb3IpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgTkRLIHJlbGF5IGNvbm5lY3Rpb24uXG4gICAqIEByZXR1cm5zIHtOREtSZWxheVN0YXR1c30gVGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBOREsgcmVsYXkgY29ubmVjdGlvbi5cbiAgICovXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBOREsgcmVsYXkgY29ubmVjdGlvbiBpcyBjdXJyZW50bHkgYXZhaWxhYmxlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSByZWxheSBjb25uZWN0aW9uIGlzIGluIHRoZSBgQ09OTkVDVEVEYCBzdGF0dXMsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNBdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PT0gNSAvKiBDT05ORUNURUQgKi87XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgTkRLIHJlbGF5IGNvbm5lY3Rpb24gaXMgZmxhcHBpbmcsIHdoaWNoIG1lYW5zIHRoZSBjb25uZWN0aW9uIGlzIHJhcGlkbHlcbiAgICogZGlzY29ubmVjdGluZyBhbmQgcmVjb25uZWN0aW5nLiBUaGlzIGlzIGRldGVybWluZWQgYnkgYW5hbHl6aW5nIHRoZSBkdXJhdGlvbnMgb2YgdGhlXG4gICAqIGxhc3QgdGhyZWUgY29ubmVjdGlvbiBhdHRlbXB0cy4gSWYgdGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgZHVyYXRpb25zIGlzIGxlc3NcbiAgICogdGhhbiAxMDAwIG1pbGxpc2Vjb25kcywgdGhlIGNvbm5lY3Rpb24gaXMgY29uc2lkZXJlZCB0byBiZSBmbGFwcGluZy5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgY29ubmVjdGlvbiBpcyBmbGFwcGluZywgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqL1xuICBpc0ZsYXBwaW5nKCkge1xuICAgIGNvbnN0IGR1cmF0aW9ucyA9IHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5kdXJhdGlvbnM7XG4gICAgaWYgKGR1cmF0aW9ucy5sZW5ndGggJSAzICE9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qgc3VtID0gZHVyYXRpb25zLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICAgIGNvbnN0IGF2ZyA9IHN1bSAvIGR1cmF0aW9ucy5sZW5ndGg7XG4gICAgY29uc3QgdmFyaWFuY2UgPSBkdXJhdGlvbnMubWFwKCh4KSA9PiAoeCAtIGF2ZykgKiogMikucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBkdXJhdGlvbnMubGVuZ3RoO1xuICAgIGNvbnN0IHN0ZERldiA9IE1hdGguc3FydCh2YXJpYW5jZSk7XG4gICAgY29uc3QgaXNGbGFwcGluZyA9IHN0ZERldiA8IEZMQVBQSU5HX1RIUkVTSE9MRF9NUztcbiAgICByZXR1cm4gaXNGbGFwcGluZztcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBhIG5vdGljZSByZWNlaXZlZCBmcm9tIHRoZSBOREsgcmVsYXkuXG4gICAqIElmIHRoZSBub3RpY2UgaW5kaWNhdGVzIHRoZSByZWxheSBpcyBjb21wbGFpbmluZyAoZS5nLiBcInRvbyBtYW55XCIgb3IgXCJtYXhpbXVtXCIpLFxuICAgKiB0aGUgbWV0aG9kIGRpc2Nvbm5lY3RzIGZyb20gdGhlIHJlbGF5IGFuZCBhdHRlbXB0cyB0byByZWNvbm5lY3QgYWZ0ZXIgYSAyLXNlY29uZCBkZWxheS5cbiAgICogQSBkZWJ1ZyBtZXNzYWdlIGlzIGxvZ2dlZCB3aXRoIHRoZSByZWxheSBVUkwgYW5kIHRoZSBub3RpY2UgdGV4dC5cbiAgICogVGhlIFwibm90aWNlXCIgZXZlbnQgaXMgZW1pdHRlZCBvbiB0aGUgbmRrUmVsYXkgaW5zdGFuY2Ugd2l0aCB0aGUgbm90aWNlIHRleHQuXG4gICAqXG4gICAqIEBwYXJhbSBub3RpY2UgLSBUaGUgbm90aWNlIHRleHQgcmVjZWl2ZWQgZnJvbSB0aGUgTkRLIHJlbGF5LlxuICAgKi9cbiAgYXN5bmMgb25Ob3RpY2Uobm90aWNlKSB7XG4gICAgdGhpcy5uZGtSZWxheS5lbWl0KFwibm90aWNlXCIsIG5vdGljZSk7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIHJlY29ubmVjdCB0byB0aGUgTkRLIHJlbGF5IGFmdGVyIGEgY29ubmVjdGlvbiBpcyBsb3N0LlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCByZWN1cnNpdmVseSB0byBoYW5kbGUgbXVsdGlwbGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzLlxuICAgKiBJdCBjaGVja3MgaWYgdGhlIHJlbGF5IGlzIGZsYXBwaW5nIGFuZCBlbWl0cyBhIFwiZmxhcHBpbmdcIiBldmVudCBpZiBzby5cbiAgICogSXQgdGhlbiBjYWxjdWxhdGVzIGEgZGVsYXkgYmVmb3JlIHRoZSBuZXh0IHJlY29ubmVjdGlvbiBhdHRlbXB0IGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgcHJldmlvdXMgYXR0ZW1wdHMuXG4gICAqIFRoZSBmdW5jdGlvbiBzZXRzIGEgdGltZW91dCB0byBleGVjdXRlIHRoZSBuZXh0IHJlY29ubmVjdGlvbiBhdHRlbXB0IGFmdGVyIHRoZSBjYWxjdWxhdGVkIGRlbGF5LlxuICAgKiBJZiB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGlzIHJlYWNoZWQsIGEgZGVidWcgbWVzc2FnZSBpcyBsb2dnZWQuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRlbXB0IC0gVGhlIGN1cnJlbnQgYXR0ZW1wdCBudW1iZXIgKGRlZmF1bHQgaXMgMCkuXG4gICAqL1xuICBoYW5kbGVSZWNvbm5lY3Rpb24oYXR0ZW1wdCA9IDApIHtcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0KSByZXR1cm47XG4gICAgaWYgKHRoaXMuaXNGbGFwcGluZygpKSB7XG4gICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJmbGFwcGluZ1wiLCB0aGlzLl9jb25uZWN0aW9uU3RhdHMpO1xuICAgICAgdGhpcy5fc3RhdHVzID0gMyAvKiBGTEFQUElORyAqLztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVjb25uZWN0RGVsYXkgPSB0aGlzLmNvbm5lY3RlZEF0ID8gTWF0aC5tYXgoMCwgNmU0IC0gKERhdGUubm93KCkgLSB0aGlzLmNvbm5lY3RlZEF0KSkgOiA1ZTMgKiAodGhpcy5fY29ubmVjdGlvblN0YXRzLmF0dGVtcHRzICsgMSk7XG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9zdGF0dXMgPSAyIC8qIFJFQ09OTkVDVElORyAqLztcbiAgICAgIHRoaXMuY29ubmVjdCgpLmNhdGNoKChfZXJyKSA9PiB7XG4gICAgICAgIGlmIChhdHRlbXB0IDwgTUFYX1JFQ09OTkVDVF9BVFRFTVBUUykge1xuICAgICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVjb25uZWN0aW9uKGF0dGVtcHQgKyAxKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAxZTMgKiAoYXR0ZW1wdCArIDEpIF4gNFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZyhcIlJlY29ubmVjdCBmYWlsZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHJlY29ubmVjdERlbGF5KTtcbiAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJkZWxheWVkLWNvbm5lY3RcIiwgcmVjb25uZWN0RGVsYXkpO1xuICAgIHRoaXMuZGVidWcoXCJSZWNvbm5lY3RpbmcgaW5cIiwgcmVjb25uZWN0RGVsYXkpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5uZXh0UmVjb25uZWN0QXQgPSBEYXRlLm5vdygpICsgcmVjb25uZWN0RGVsYXk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgTkRLIHJlbGF5IGlmIHRoZSBjb25uZWN0aW9uIGlzIGluIHRoZSBDT05ORUNURUQgc3RhdGUgYW5kIHRoZSBXZWJTb2NrZXQgaXMgb3Blbi5cbiAgICogSWYgdGhlIGNvbm5lY3Rpb24gaXMgbm90IGluIHRoZSBDT05ORUNURUQgc3RhdGUgb3IgdGhlIFdlYlNvY2tldCBpcyBub3Qgb3BlbiwgbG9ncyBhIGRlYnVnIG1lc3NhZ2UgYW5kIHRocm93cyBhbiBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBzZW5kIHRvIHRoZSBOREsgcmVsYXkuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhdHRlbXB0aW5nIHRvIHNlbmQgb24gYSBjbG9zZWQgcmVsYXkgY29ubmVjdGlvbi5cbiAgICovXG4gIGFzeW5jIHNlbmQobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLl9zdGF0dXMgPj0gNSAvKiBDT05ORUNURUQgKi8gJiYgdGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHRoaXMud3M/LnNlbmQobWVzc2FnZSk7XG4gICAgICB0aGlzLm5ldERlYnVnPy4obWVzc2FnZSwgdGhpcy5uZGtSZWxheSwgXCJzZW5kXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlYnVnKGBOb3QgY29ubmVjdGVkIHRvICR7dGhpcy5uZGtSZWxheS51cmx9ICglZCksIG5vdCBzZW5kaW5nIG1lc3NhZ2UgJHttZXNzYWdlfWAsIHRoaXMuX3N0YXR1cyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBdXRoZW50aWNhdGVzIHRoZSBOREsgZXZlbnQgYnkgc2VuZGluZyBpdCB0byB0aGUgTkRLIHJlbGF5IGFuZCByZXR1cm5pbmcgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgTkRLIGV2ZW50IHRvIGF1dGhlbnRpY2F0ZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgYXV0aGVudGljYXRpb24gcmVzdWx0LlxuICAgKi9cbiAgYXN5bmMgYXV0aChldmVudCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHZhbCA9IHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmdldChldmVudC5pZCkgPz8gW107XG4gICAgICB2YWwucHVzaCh7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChldmVudC5pZCwgdmFsKTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoYFtcIkFVVEhcIiwke0pTT04uc3RyaW5naWZ5KGV2ZW50LnJhd0V2ZW50KCkpfV1gKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoZXMgYW4gTkRLIGV2ZW50IHRvIHRoZSByZWxheSBhbmQgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBOREsgZXZlbnQgdG8gcHVibGlzaC5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBldmVudCBwdWJsaWNhdGlvbi5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIGF0dGVtcHRpbmcgdG8gcHVibGlzaCBvbiBhIGNsb3NlZCByZWxheSBjb25uZWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgcHVibGlzaChldmVudCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHZhbCA9IHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmdldChldmVudC5pZCkgPz8gW107XG4gICAgICBpZiAodmFsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBEdXBsaWNhdGUgZXZlbnQgcHVibGlzaGluZyBkZXRlY3RlZCwgeW91IGFyZSBwdWJsaXNoaW5nIGV2ZW50ICR7ZXZlbnQuaWR9IHR3aWNlYCk7XG4gICAgICB9XG4gICAgICB2YWwucHVzaCh7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChldmVudC5pZCwgdmFsKTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoYFtcIkVWRU5UXCIsJHtKU09OLnN0cmluZ2lmeShldmVudCl9XWApO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgLyoqXG4gICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGV2ZW50cyB0aGF0IG1hdGNoIHRoZSBwcm92aWRlZCBmaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gZmlsdGVycyAtIFRoZSBmaWx0ZXJzIHRvIGFwcGx5IHRvIHRoZSBjb3VudCByZXF1ZXN0LlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IGNvbnRhaW5pbmcgYSBjdXN0b20gaWQgZm9yIHRoZSBjb3VudCByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBudW1iZXIgb2YgbWF0Y2hpbmcgZXZlbnRzLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYXR0ZW1wdGluZyB0byBzZW5kIHRoZSBjb3VudCByZXF1ZXN0IG9uIGEgY2xvc2VkIHJlbGF5IGNvbm5lY3Rpb24uXG4gICAqL1xuICBhc3luYyBjb3VudChmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICB0aGlzLnNlcmlhbCsrO1xuICAgIGNvbnN0IGlkID0gcGFyYW1zPy5pZCB8fCBgY291bnQ6JHt0aGlzLnNlcmlhbH1gO1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuc2V0KGlkLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoYFtcIkNPVU5UXCIsXCIke2lkfVwiLCR7SlNPTi5zdHJpbmdpZnkoZmlsdGVycykuc3Vic3RyaW5nKDEpfWApO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgY2xvc2Uoc3ViSWQsIHJlYXNvbikge1xuICAgIHRoaXMuc2VuZChgW1wiQ0xPU0VcIixcIiR7c3ViSWR9XCJdYCk7XG4gICAgY29uc3Qgc3ViID0gdGhpcy5vcGVuU3Vicy5nZXQoc3ViSWQpO1xuICAgIHRoaXMub3BlblN1YnMuZGVsZXRlKHN1YklkKTtcbiAgICBpZiAoc3ViKSBzdWIub25jbG9zZShyZWFzb24pO1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmVzIHRvIHRoZSBOREsgcmVsYXkgd2l0aCB0aGUgcHJvdmlkZWQgZmlsdGVycyBhbmQgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIGZpbHRlcnMgLSBUaGUgZmlsdGVycyB0byBhcHBseSB0byB0aGUgc3Vic2NyaXB0aW9uLlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHN1YnNjcmlwdGlvbiBwYXJhbWV0ZXJzLCBpbmNsdWRpbmcgYW4gb3B0aW9uYWwgY3VzdG9tIGlkLlxuICAgKiBAcmV0dXJucyBBIG5ldyBOREtSZWxheVN1YnNjcmlwdGlvbiBpbnN0YW5jZS5cbiAgICovXG4gIHJlcShyZWxheVN1Yikge1xuICAgIGAke3RoaXMuc2VuZChgW1wiUkVRXCIsXCIke3JlbGF5U3ViLnN1YklkfVwiLCR7SlNPTi5zdHJpbmdpZnkocmVsYXlTdWIuZXhlY3V0ZUZpbHRlcnMpLnN1YnN0cmluZygxKX1gKX1dYDtcbiAgICB0aGlzLm9wZW5TdWJzLnNldChyZWxheVN1Yi5zdWJJZCwgcmVsYXlTdWIpO1xuICB9XG4gIC8qKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB1cGRhdGUgdGhlIGNvbm5lY3Rpb24gc3RhdHMuXG4gICAqL1xuICB1cGRhdGVDb25uZWN0aW9uU3RhdHMgPSB7XG4gICAgY29ubmVjdGVkOiAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuc3VjY2VzcysrO1xuICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmNvbm5lY3RlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuICAgIGRpc2Nvbm5lY3RlZDogKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuZHVyYXRpb25zLnB1c2goRGF0ZS5ub3coKSAtIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCk7XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0aW9uU3RhdHMuZHVyYXRpb25zLmxlbmd0aCA+IDEwMCkge1xuICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5kdXJhdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmNvbm5lY3RlZEF0ID0gdm9pZCAwO1xuICAgIH0sXG4gICAgYXR0ZW1wdDogKCkgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmF0dGVtcHRzKys7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuY29ubmVjdGVkQXQgPSBEYXRlLm5vdygpO1xuICAgIH1cbiAgfTtcbiAgLyoqIFJldHVybnMgdGhlIGNvbm5lY3Rpb24gc3RhdHMuICovXG4gIGdldCBjb25uZWN0aW9uU3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cztcbiAgfVxuICAvKiogUmV0dXJucyB0aGUgcmVsYXkgVVJMICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMubmRrUmVsYXkudXJsO1xuICB9XG4gIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cyA+PSA1IC8qIENPTk5FQ1RFRCAqLyAmJiB0aGlzLndzPy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTjtcbiAgfVxufTtcblxuLy8gc3JjL3JlbGF5L3B1Ymxpc2hlci50c1xudmFyIE5ES1JlbGF5UHVibGlzaGVyID0gY2xhc3Mge1xuICBuZGtSZWxheTtcbiAgZGVidWc7XG4gIGNvbnN0cnVjdG9yKG5ka1JlbGF5KSB7XG4gICAgdGhpcy5uZGtSZWxheSA9IG5ka1JlbGF5O1xuICAgIHRoaXMuZGVidWcgPSBuZGtSZWxheS5kZWJ1Zy5leHRlbmQoXCJwdWJsaXNoZXJcIik7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2hlZCBhbiBldmVudCB0byB0aGUgcmVsYXk7IGlmIHRoZSByZWxheSBpcyBub3QgY29ubmVjdGVkLCBpdCB3aWxsXG4gICAqIHdhaXQgZm9yIHRoZSByZWxheSB0byBjb25uZWN0IGJlZm9yZSBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAgICpcbiAgICogSWYgdGhlIHJlbGF5IGRvZXMgbm90IGNvbm5lY3Qgd2l0aGluIHRoZSB0aW1lb3V0LCB0aGUgcHVibGlzaCBvcGVyYXRpb25cbiAgICogd2lsbCBmYWlsLlxuICAgKiBAcGFyYW0gZXZlbnQgIFRoZSBldmVudCB0byBwdWJsaXNoXG4gICAqIEBwYXJhbSB0aW1lb3V0TXMgIFRoZSB0aW1lb3V0IGZvciB0aGUgcHVibGlzaCBvcGVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGV2ZW50IGhhcyBiZWVuIHB1Ymxpc2hlZCBvciByZWplY3RzIGlmIHRoZSBvcGVyYXRpb24gdGltZXMgb3V0XG4gICAqL1xuICBhc3luYyBwdWJsaXNoKGV2ZW50LCB0aW1lb3V0TXMgPSAyNTAwKSB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgY29uc3QgcHVibGlzaENvbm5lY3RlZCA9ICgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5wdWJsaXNoRXZlbnQoZXZlbnQpLnRoZW4oKF9yZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcInB1Ymxpc2hlZFwiLCBldmVudCk7XG4gICAgICAgICAgICBldmVudC5lbWl0KFwicmVsYXk6cHVibGlzaGVkXCIsIHRoaXMubmRrUmVsYXkpO1xuICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGltZW91dCA9IHZvaWQgMDtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgVGltZW91dDogJHt0aW1lb3V0TXN9bXNgKSk7XG4gICAgICB9LCB0aW1lb3V0TXMpO1xuICAgIH0pO1xuICAgIGNvbnN0IG9uQ29ubmVjdEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBwdWJsaXNoQ29ubmVjdGVkKCkudGhlbigocmVzdWx0KSA9PiBjb25uZWN0UmVzb2x2ZShyZXN1bHQpKS5jYXRjaCgoZXJyKSA9PiBjb25uZWN0UmVqZWN0KGVycikpO1xuICAgIH07XG4gICAgbGV0IGNvbm5lY3RSZXNvbHZlO1xuICAgIGxldCBjb25uZWN0UmVqZWN0O1xuICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICB0aGlzLm5ka1JlbGF5LmRlYnVnKFwiUHVibGlzaCBmYWlsZWRcIiwgZXJyLCBldmVudC5pZCk7XG4gICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJwdWJsaXNoOmZhaWxlZFwiLCBldmVudCwgZXJyKTtcbiAgICAgIGV2ZW50LmVtaXQoXCJyZWxheTpwdWJsaXNoOmZhaWxlZFwiLCB0aGlzLm5ka1JlbGF5LCBlcnIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH07XG4gICAgY29uc3Qgb25GaW5hbGx5ID0gKCkgPT4ge1xuICAgICAgaWYgKHRpbWVvdXQpIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRoaXMubmRrUmVsYXkucmVtb3ZlTGlzdGVuZXIoXCJjb25uZWN0XCIsIG9uQ29ubmVjdEhhbmRsZXIpO1xuICAgIH07XG4gICAgaWYgKHRoaXMubmRrUmVsYXkuc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtwdWJsaXNoQ29ubmVjdGVkKCksIHRpbWVvdXRQcm9taXNlXSkuY2F0Y2gob25FcnJvcikuZmluYWxseShvbkZpbmFsbHkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZGtSZWxheS5zdGF0dXMgPD0gMSAvKiBESVNDT05ORUNURUQgKi8pIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlJlbGF5IGlzIGRpc2Nvbm5lY3RlZCwgdHJ5aW5nIHRvIGNvbm5lY3QgdG8gcHVibGlzaCBhbiBldmVudFwiLCB0aGlzLm5ka1JlbGF5LnVybCk7XG4gICAgICB0aGlzLm5ka1JlbGF5LmNvbm5lY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiUmVsYXkgbm90IGNvbm5lY3RlZCwgd2FpdGluZyBmb3IgY29ubmVjdGlvbiB0byBwdWJsaXNoIGFuIGV2ZW50XCIsIHRoaXMubmRrUmVsYXkudXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbm5lY3RSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgY29ubmVjdFJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgdGhpcy5uZGtSZWxheS5vbmNlKFwiY29ubmVjdFwiLCBvbkNvbm5lY3RIYW5kbGVyKTtcbiAgICAgIH0pLFxuICAgICAgdGltZW91dFByb21pc2VcbiAgICBdKS5jYXRjaChvbkVycm9yKS5maW5hbGx5KG9uRmluYWxseSk7XG4gIH1cbiAgYXN5bmMgcHVibGlzaEV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMubmRrUmVsYXkuY29ubmVjdGl2aXR5LnB1Ymxpc2goZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9zdWJzY3JpcHRpb24vZ3JvdXBpbmcudHNcbmZ1bmN0aW9uIGZpbHRlckZpbmdlcnByaW50KGZpbHRlcnMsIGNsb3NlT25Fb3NlKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gW107XG4gIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlcnMpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmVudHJpZXMoZmlsdGVyIHx8IHt9KS5tYXAoKFtrZXksIHZhbHVlc10pID0+IHtcbiAgICAgIGlmIChbXCJzaW5jZVwiLCBcInVudGlsXCJdLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGAke2tleX06JHt2YWx1ZXN9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXk7XG4gICAgfSkuc29ydCgpLmpvaW4oXCItXCIpO1xuICAgIGVsZW1lbnRzLnB1c2goa2V5cyk7XG4gIH1cbiAgbGV0IGlkID0gY2xvc2VPbkVvc2UgPyBcIitcIiA6IFwiXCI7XG4gIGlkICs9IGVsZW1lbnRzLmpvaW4oXCJ8XCIpO1xuICByZXR1cm4gaWQ7XG59XG5mdW5jdGlvbiBtZXJnZUZpbHRlcnMoZmlsdGVycykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgbGFzdFJlc3VsdCA9IHt9O1xuICBmaWx0ZXJzLmZpbHRlcigoZikgPT4gISFmLmxpbWl0KS5mb3JFYWNoKChmaWx0ZXJXaXRoTGltaXQpID0+IHJlc3VsdC5wdXNoKGZpbHRlcldpdGhMaW1pdCkpO1xuICBmaWx0ZXJzID0gZmlsdGVycy5maWx0ZXIoKGYpID0+ICFmLmxpbWl0KTtcbiAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzdWx0O1xuICBmaWx0ZXJzLmZvckVhY2goKGZpbHRlcikgPT4ge1xuICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGxhc3RSZXN1bHRba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgbGFzdFJlc3VsdFtrZXldID0gWy4uLnZhbHVlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0UmVzdWx0W2tleV0gPSBBcnJheS5mcm9tKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi5sYXN0UmVzdWx0W2tleV0sIC4uLnZhbHVlXSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0UmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBbLi4ucmVzdWx0LCBsYXN0UmVzdWx0XTtcbn1cblxuLy8gc3JjL3JlbGF5L3N1YnNjcmlwdGlvbi50c1xudmFyIE5ES1JlbGF5U3Vic2NyaXB0aW9uID0gY2xhc3Mge1xuICBmaW5nZXJwcmludDtcbiAgaXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB0b3BTdWJNYW5hZ2VyO1xuICBkZWJ1ZztcbiAgLyoqXG4gICAqIFRyYWNrcyB0aGUgc3RhdHVzIG9mIHRoaXMgUkVRLlxuICAgKi9cbiAgc3RhdHVzID0gMCAvKiBJTklUSUFMICovO1xuICBvbkNsb3NlO1xuICByZWxheTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBzdWJzY3JpcHRpb24gaGFzIHJlYWNoZWQgRU9TRS5cbiAgICovXG4gIGVvc2VkID0gZmFsc2U7XG4gIC8qKlxuICAgKiBUaW1lb3V0IGF0IHdoaWNoIHRoaXMgc3Vic2NyaXB0aW9uIHdpbGxcbiAgICogc3RhcnQgZXhlY3V0aW5nLlxuICAgKi9cbiAgZXhlY3V0aW9uVGltZXI7XG4gIC8qKlxuICAgKiBUcmFjayB0aGUgdGltZSBhdCB3aGljaCB0aGlzIHN1YnNjcmlwdGlvbiB3aWxsIGZpcmUuXG4gICAqL1xuICBmaXJlVGltZTtcbiAgLyoqXG4gICAqIFRoZSBkZWxheSB0eXBlIHRoYXQgdGhlIGN1cnJlbnQgZmlyZVRpbWUgd2FzIGNhbGN1bGF0ZWQgd2l0aC5cbiAgICovXG4gIGRlbGF5VHlwZTtcbiAgLyoqXG4gICAqIFRoZSBmaWx0ZXJzIHRoYXQgaGF2ZSBiZWVuIGV4ZWN1dGVkLlxuICAgKi9cbiAgZXhlY3V0ZUZpbHRlcnM7XG4gIGlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpO1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGZpbmdlcnByaW50IFRoZSBmaW5nZXJwcmludCBvZiB0aGlzIHN1YnNjcmlwdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbGF5LCBmaW5nZXJwcmludCwgdG9wU3ViTWFuYWdlcikge1xuICAgIHRoaXMucmVsYXkgPSByZWxheTtcbiAgICB0aGlzLnRvcFN1Yk1hbmFnZXIgPSB0b3BTdWJNYW5hZ2VyO1xuICAgIHRoaXMuZGVidWcgPSByZWxheS5kZWJ1Zy5leHRlbmQoYHN1Ylske3RoaXMuaWR9XWApO1xuICAgIHRoaXMuZmluZ2VycHJpbnQgPSBmaW5nZXJwcmludCB8fCBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyk7XG4gIH1cbiAgX3N1YklkO1xuICBnZXQgc3ViSWQoKSB7XG4gICAgaWYgKHRoaXMuX3N1YklkKSByZXR1cm4gdGhpcy5fc3ViSWQ7XG4gICAgdGhpcy5fc3ViSWQgPSB0aGlzLmZpbmdlcnByaW50LnNsaWNlKDAsIDE1KTtcbiAgICByZXR1cm4gdGhpcy5fc3ViSWQ7XG4gIH1cbiAgc3ViSWRQYXJ0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGFkZFN1YklkUGFydChwYXJ0KSB7XG4gICAgdGhpcy5zdWJJZFBhcnRzLmFkZChwYXJ0KTtcbiAgfVxuICBhZGRJdGVtKHN1YnNjcmlwdGlvbiwgZmlsdGVycykge1xuICAgIHRoaXMuZGVidWcoXCJBZGRpbmcgaXRlbVwiLCB7XG4gICAgICBmaWx0ZXJzLFxuICAgICAgaW50ZXJuYWxJZDogc3Vic2NyaXB0aW9uLmludGVybmFsSWQsXG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgZmluZ2VycHJpbnQ6IHRoaXMuZmluZ2VycHJpbnQsXG4gICAgICBpZDogdGhpcy5zdWJJZCxcbiAgICAgIGl0ZW1zOiB0aGlzLml0ZW1zLFxuICAgICAgaXRlbXNTaXplOiB0aGlzLml0ZW1zLnNpemVcbiAgICB9KTtcbiAgICBpZiAodGhpcy5pdGVtcy5oYXMoc3Vic2NyaXB0aW9uLmludGVybmFsSWQpKSByZXR1cm47XG4gICAgc3Vic2NyaXB0aW9uLm9uKFwiY2xvc2VcIiwgdGhpcy5yZW1vdmVJdGVtLmJpbmQodGhpcywgc3Vic2NyaXB0aW9uKSk7XG4gICAgdGhpcy5pdGVtcy5zZXQoc3Vic2NyaXB0aW9uLmludGVybmFsSWQsIHsgc3Vic2NyaXB0aW9uLCBmaWx0ZXJzIH0pO1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gMyAvKiBSVU5OSU5HICovKSB7XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uLnN1YklkICYmICghdGhpcy5fc3ViSWQgfHwgdGhpcy5fc3ViSWQubGVuZ3RoIDwgNDgpKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMCAvKiBJTklUSUFMICovIHx8IHRoaXMuc3RhdHVzID09PSAxIC8qIFBFTkRJTkcgKi8pIHtcbiAgICAgICAgICB0aGlzLmFkZFN1YklkUGFydChzdWJzY3JpcHRpb24uc3ViSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5zdGF0dXMpIHtcbiAgICAgIGNhc2UgMCAvKiBJTklUSUFMICovOlxuICAgICAgICB0aGlzLmV2YWx1YXRlRXhlY3V0aW9uUGxhbihzdWJzY3JpcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMyAvKiBSVU5OSU5HICovOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMSAvKiBQRU5ESU5HICovOlxuICAgICAgICB0aGlzLmV2YWx1YXRlRXhlY3V0aW9uUGxhbihzdWJzY3JpcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNCAvKiBDTE9TRUQgKi86XG4gICAgICAgIHRoaXMuZGVidWcoXCJTdWJzY3JpcHRpb24gaXMgY2xvc2VkLCBjYW5ub3QgYWRkIG5ldyBpdGVtcyAlbyAoJW8pXCIsIHN1YnNjcmlwdGlvbiwgZmlsdGVycyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgbmV3IGl0ZW1zIHRvIGEgY2xvc2VkIHN1YnNjcmlwdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEEgc3Vic2NyaXB0aW9uIGhhcyBiZWVuIGNsb3NlZCwgcmVtb3ZlIGl0IGZyb20gdGhlIGxpc3Qgb2YgaXRlbXMuXG4gICAqIEBwYXJhbSBzdWJzY3JpcHRpb25cbiAgICovXG4gIHJlbW92ZUl0ZW0oc3Vic2NyaXB0aW9uKSB7XG4gICAgdGhpcy5pdGVtcy5kZWxldGUoc3Vic2NyaXB0aW9uLmludGVybmFsSWQpO1xuICAgIGlmICh0aGlzLml0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIGlmICghdGhpcy5lb3NlZCkgcmV0dXJuO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfVxuICB9XG4gIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gNCAvKiBDTE9TRUQgKi8pIHJldHVybjtcbiAgICBjb25zdCBwcmV2U3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gICAgdGhpcy5zdGF0dXMgPSA0IC8qIENMT1NFRCAqLztcbiAgICBpZiAocHJldlN0YXR1cyA9PT0gMyAvKiBSVU5OSU5HICovKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnJlbGF5LmNsb3NlKHRoaXMuc3ViSWQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiRXJyb3IgY2xvc2luZyBzdWJzY3JpcHRpb25cIiwgZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVidWcoXCJTdWJzY3JpcHRpb24gd2FudGVkIHRvIGNsb3NlIGJ1dCBpdCB3YXNuJ3QgcnVubmluZywgdGhpcyBpcyBwcm9iYWJseSBva1wiLCB7XG4gICAgICAgIHN1YklkOiB0aGlzLnN1YklkLFxuICAgICAgICBwcmV2U3RhdHVzLFxuICAgICAgICBzdWI6IHRoaXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLmV4ZWN1dGlvblRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5leGVjdXRpb25UaW1lcik7XG4gICAgdGhpcy5yZWxheS5vZmYoXCJyZWFkeVwiLCB0aGlzLmV4ZWN1dGVPblJlbGF5UmVhZHkpO1xuICAgIHRoaXMucmVsYXkub2ZmKFwiYXV0aGVkXCIsIHRoaXMucmVFeGVjdXRlQWZ0ZXJBdXRoKTtcbiAgICBpZiAodGhpcy5vbkNsb3NlKSB0aGlzLm9uQ2xvc2UodGhpcyk7XG4gIH1cbiAgZXZhbHVhdGVFeGVjdXRpb25QbGFuKHN1YnNjcmlwdGlvbikge1xuICAgIGlmICghc3Vic2NyaXB0aW9uLmlzR3JvdXBhYmxlKCkpIHtcbiAgICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgICAgdGhpcy5leGVjdXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdWJzY3JpcHRpb24uZmlsdGVycy5maW5kKChmaWx0ZXIpID0+ICEhZmlsdGVyLmxpbWl0KSkge1xuICAgICAgdGhpcy5leGVjdXRlRmlsdGVycyA9IHRoaXMuY29tcGlsZUZpbHRlcnMoKTtcbiAgICAgIGlmICh0aGlzLmV4ZWN1dGVGaWx0ZXJzLmxlbmd0aCA+PSAxMCkge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IDEgLyogUEVORElORyAqLztcbiAgICAgICAgdGhpcy5leGVjdXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVsYXkgPSBzdWJzY3JpcHRpb24uZ3JvdXBhYmxlRGVsYXk7XG4gICAgY29uc3QgZGVsYXlUeXBlID0gc3Vic2NyaXB0aW9uLmdyb3VwYWJsZURlbGF5VHlwZTtcbiAgICBpZiAoIWRlbGF5KSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ3JvdXAgYSBzdWJzY3JpcHRpb24gd2l0aG91dCBhIGRlbGF5XCIpO1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMCAvKiBJTklUSUFMICovKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlKGRlbGF5LCBkZWxheVR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBleGlzdGluZ0RlbGF5VHlwZSA9IHRoaXMuZGVsYXlUeXBlO1xuICAgICAgY29uc3QgdGltZVVudGlsRmlyZSA9IHRoaXMuZmlyZVRpbWUgLSBEYXRlLm5vdygpO1xuICAgICAgaWYgKGV4aXN0aW5nRGVsYXlUeXBlID09PSBcImF0LWxlYXN0XCIgJiYgZGVsYXlUeXBlID09PSBcImF0LWxlYXN0XCIpIHtcbiAgICAgICAgaWYgKHRpbWVVbnRpbEZpcmUgPCBkZWxheSkge1xuICAgICAgICAgIGlmICh0aGlzLmV4ZWN1dGlvblRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5leGVjdXRpb25UaW1lcik7XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZShkZWxheSwgZGVsYXlUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleGlzdGluZ0RlbGF5VHlwZSA9PT0gXCJhdC1sZWFzdFwiICYmIGRlbGF5VHlwZSA9PT0gXCJhdC1tb3N0XCIpIHtcbiAgICAgICAgaWYgKHRpbWVVbnRpbEZpcmUgPiBkZWxheSkge1xuICAgICAgICAgIGlmICh0aGlzLmV4ZWN1dGlvblRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5leGVjdXRpb25UaW1lcik7XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZShkZWxheSwgZGVsYXlUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleGlzdGluZ0RlbGF5VHlwZSA9PT0gXCJhdC1tb3N0XCIgJiYgZGVsYXlUeXBlID09PSBcImF0LW1vc3RcIikge1xuICAgICAgICBpZiAodGltZVVudGlsRmlyZSA+IGRlbGF5KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmV4ZWN1dGlvblRpbWVyKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlKGRlbGF5LCBkZWxheVR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nRGVsYXlUeXBlID09PSBcImF0LW1vc3RcIiAmJiBkZWxheVR5cGUgPT09IFwiYXQtbGVhc3RcIikge1xuICAgICAgICBpZiAodGltZVVudGlsRmlyZSA+IGRlbGF5KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmV4ZWN1dGlvblRpbWVyKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlKGRlbGF5LCBkZWxheVR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGVsYXkgdHlwZSBjb21iaW5hdGlvbiAke2V4aXN0aW5nRGVsYXlUeXBlfSAke2RlbGF5VHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2NoZWR1bGUoZGVsYXksIGRlbGF5VHlwZSkge1xuICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmZpcmVUaW1lID0gY3VycmVudFRpbWUgKyBkZWxheTtcbiAgICB0aGlzLmRlbGF5VHlwZSA9IGRlbGF5VHlwZTtcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQodGhpcy5leGVjdXRlLmJpbmQodGhpcyksIGRlbGF5KTtcbiAgICBpZiAoZGVsYXlUeXBlID09PSBcImF0LWxlYXN0XCIpIHtcbiAgICAgIHRoaXMuZXhlY3V0aW9uVGltZXIgPSB0aW1lcjtcbiAgICB9XG4gIH1cbiAgZXhlY3V0ZU9uUmVsYXlSZWFkeSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IDIgLyogV0FJVElORyAqLykgcmV0dXJuO1xuICAgIGlmICh0aGlzLml0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuZGVidWcoXCJObyBpdGVtcyB0byBleGVjdXRlOyB0aGlzIHJlbGF5IHdhcyBwcm9iYWJseSB0b28gc2xvdyB0byByZXNwb25kIGFuZCB0aGUgY2FsbGVyIGdhdmUgdXBcIiwge1xuICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICBmaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCxcbiAgICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICAgIGl0ZW1zU2l6ZTogdGhpcy5pdGVtcy5zaXplLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgc3ViSWQ6IHRoaXMuc3ViSWRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGVidWcoXCJFeGVjdXRpbmcgb24gcmVsYXkgcmVhZHlcIiwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIGZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LFxuICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICBpdGVtc1NpemU6IHRoaXMuaXRlbXMuc2l6ZVxuICAgIH0pO1xuICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgIHRoaXMuZXhlY3V0ZSgpO1xuICB9O1xuICBmaW5hbGl6ZVN1YklkKCkge1xuICAgIGlmICh0aGlzLnN1YklkUGFydHMuc2l6ZSA+IDApIHtcbiAgICAgIHRoaXMuX3N1YklkID0gQXJyYXkuZnJvbSh0aGlzLnN1YklkUGFydHMpLmpvaW4oXCItXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdWJJZCA9IHRoaXMuZmluZ2VycHJpbnQuc2xpY2UoMCwgMTUpO1xuICAgIH1cbiAgICB0aGlzLl9zdWJJZCArPSBgLSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDcpfWA7XG4gIH1cbiAgLy8gd2UgZG8gaXQgdGhpcyB3YXkgc28gdGhhdCB3ZSBjYW4gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuICByZUV4ZWN1dGVBZnRlckF1dGggPSAoKCkgPT4ge1xuICAgIGNvbnN0IG9sZFN1YklkID0gdGhpcy5zdWJJZDtcbiAgICB0aGlzLmRlYnVnKFwiUmUtZXhlY3V0aW5nIGFmdGVyIGF1dGhcIiwgdGhpcy5pdGVtcy5zaXplKTtcbiAgICBpZiAodGhpcy5lb3NlZCkge1xuICAgICAgdGhpcy5yZWxheS5jbG9zZSh0aGlzLnN1YklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWJ1ZyhcIldlIGFyZSBhYmFuZG9uaW5nIGFuIG9wZW5lZCBzdWJzY3JpcHRpb24sIG9uY2UgaXQgRU9TRSdzLCB0aGUgaGFuZGxlciB3aWxsIGNsb3NlIGl0XCIsIHtcbiAgICAgICAgb2xkU3ViSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9zdWJJZCA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXR1cyA9IDEgLyogUEVORElORyAqLztcbiAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICB0aGlzLmRlYnVnKFwiUmUtZXhlY3V0ZWQgYWZ0ZXIgYXV0aCAlcyBcXHV7MUY0NDl9ICVzXCIsIG9sZFN1YklkLCB0aGlzLnN1YklkKTtcbiAgfSkuYmluZCh0aGlzKTtcbiAgZXhlY3V0ZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IDEgLyogUEVORElORyAqLykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVsYXkuY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IDIgLyogV0FJVElORyAqLztcbiAgICAgIHRoaXMuZGVidWcoXCJXYWl0aW5nIGZvciByZWxheSB0byBiZSByZWFkeVwiLCB7XG4gICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgIGlkOiB0aGlzLnN1YklkLFxuICAgICAgICBmaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCxcbiAgICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICAgIGl0ZW1zU2l6ZTogdGhpcy5pdGVtcy5zaXplXG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVsYXkub25jZShcInJlYWR5XCIsIHRoaXMuZXhlY3V0ZU9uUmVsYXlSZWFkeSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnJlbGF5LnN0YXR1cyA8IDggLyogQVVUSEVOVElDQVRFRCAqLykge1xuICAgICAgdGhpcy5yZWxheS5vbmNlKFwiYXV0aGVkXCIsIHRoaXMucmVFeGVjdXRlQWZ0ZXJBdXRoKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0dXMgPSAzIC8qIFJVTk5JTkcgKi87XG4gICAgdGhpcy5maW5hbGl6ZVN1YklkKCk7XG4gICAgdGhpcy5leGVjdXRlRmlsdGVycyA9IHRoaXMuY29tcGlsZUZpbHRlcnMoKTtcbiAgICB0aGlzLnJlbGF5LnJlcSh0aGlzKTtcbiAgfVxuICBvbnN0YXJ0KCkge1xuICB9XG4gIG9uZXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLnRvcFN1Yk1hbmFnZXIuZGlzcGF0Y2hFdmVudChldmVudCwgdGhpcy5yZWxheSk7XG4gIH1cbiAgb25lb3NlKHN1YklkKSB7XG4gICAgdGhpcy5lb3NlZCA9IHRydWU7XG4gICAgaWYgKHN1YklkICE9PSB0aGlzLnN1YklkKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiUmVjZWl2ZWQgRU9TRSBmb3IgYW4gYWJhbmRvbmVkIHN1YnNjcmlwdGlvblwiLCBzdWJJZCwgdGhpcy5zdWJJZCk7XG4gICAgICB0aGlzLnJlbGF5LmNsb3NlKHN1YklkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXRlbXMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHsgc3Vic2NyaXB0aW9uIH0gb2YgdGhpcy5pdGVtcy52YWx1ZXMoKSkge1xuICAgICAgc3Vic2NyaXB0aW9uLmVvc2VSZWNlaXZlZCh0aGlzLnJlbGF5KTtcbiAgICAgIGlmIChzdWJzY3JpcHRpb24uY2xvc2VPbkVvc2UpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIlJlbW92aW5nIGl0ZW0gYmVjYXVzZSBvZiBFT1NFXCIsIHtcbiAgICAgICAgICBmaWx0ZXJzOiBzdWJzY3JpcHRpb24uZmlsdGVycyxcbiAgICAgICAgICBpbnRlcm5hbElkOiBzdWJzY3JpcHRpb24uaW50ZXJuYWxJZCxcbiAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgIGZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LFxuICAgICAgICAgIGl0ZW1zOiB0aGlzLml0ZW1zLFxuICAgICAgICAgIGl0ZW1zU2l6ZTogdGhpcy5pdGVtcy5zaXplXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlbW92ZUl0ZW0oc3Vic2NyaXB0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25jbG9zZShfcmVhc29uKSB7XG4gICAgdGhpcy5zdGF0dXMgPSA0IC8qIENMT1NFRCAqLztcbiAgfVxuICBvbmNsb3NlZChyZWFzb24pIHtcbiAgICBpZiAoIXJlYXNvbikgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgeyBzdWJzY3JpcHRpb24gfSBvZiB0aGlzLml0ZW1zLnZhbHVlcygpKSB7XG4gICAgICBzdWJzY3JpcHRpb24uY2xvc2VkUmVjZWl2ZWQodGhpcy5yZWxheSwgcmVhc29uKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdyYWJzIHRoZSBmaWx0ZXJzIGZyb20gYWxsIHRoZSBzdWJzY3JpcHRpb25zXG4gICAqIGFuZCBtZXJnZXMgdGhlbSBpbnRvIGEgc2luZ2xlIGZpbHRlci5cbiAgICovXG4gIGNvbXBpbGVGaWx0ZXJzKCkge1xuICAgIGNvbnN0IG1lcmdlZEZpbHRlcnMgPSBbXTtcbiAgICBjb25zdCBmaWx0ZXJzID0gQXJyYXkuZnJvbSh0aGlzLml0ZW1zLnZhbHVlcygpKS5tYXAoKGl0ZW0pID0+IGl0ZW0uZmlsdGVycyk7XG4gICAgaWYgKCFmaWx0ZXJzWzBdKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiXFx1ezFGNDQwfSBObyBmaWx0ZXJzIHRvIG1lcmdlXCIsIHRoaXMuaXRlbXMpO1xuICAgICAgY29uc29sZS5lcnJvcihcIkJVRzogTm8gZmlsdGVycyB0byBtZXJnZSFcIiwgdGhpcy5pdGVtcyk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlckNvdW50ID0gZmlsdGVyc1swXS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhbGxGaWx0ZXJzQXRJbmRleCA9IGZpbHRlcnMubWFwKChmaWx0ZXIpID0+IGZpbHRlcltpXSk7XG4gICAgICBtZXJnZWRGaWx0ZXJzLnB1c2goLi4ubWVyZ2VGaWx0ZXJzKGFsbEZpbHRlcnNBdEluZGV4KSk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWRGaWx0ZXJzO1xuICB9XG59O1xuXG4vLyBzcmMvcmVsYXkvc3ViLW1hbmFnZXIudHNcbnZhciBOREtSZWxheVN1YnNjcmlwdGlvbk1hbmFnZXIgPSBjbGFzcyB7XG4gIHJlbGF5O1xuICBzdWJzY3JpcHRpb25zO1xuICBnZW5lcmFsU3ViTWFuYWdlcjtcbiAgLyoqXG4gICAqIEBwYXJhbSByZWxheSAtIFRoZSByZWxheSBpbnN0YW5jZS5cbiAgICogQHBhcmFtIGdlbmVyYWxTdWJNYW5hZ2VyIC0gVGhlIHN1YnNjcmlwdGlvbiBtYW5hZ2VyIGluc3RhbmNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVsYXksIGdlbmVyYWxTdWJNYW5hZ2VyKSB7XG4gICAgdGhpcy5yZWxheSA9IHJlbGF5O1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5nZW5lcmFsU3ViTWFuYWdlciA9IGdlbmVyYWxTdWJNYW5hZ2VyO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgc3Vic2NyaXB0aW9uIHRvIHRoZSBtYW5hZ2VyLlxuICAgKi9cbiAgYWRkU3Vic2NyaXB0aW9uKHN1YiwgZmlsdGVycykge1xuICAgIGxldCByZWxheVN1YjtcbiAgICBpZiAoIXN1Yi5pc0dyb3VwYWJsZSgpKSB7XG4gICAgICByZWxheVN1YiA9IHRoaXMuY3JlYXRlU3Vic2NyaXB0aW9uKHN1YiwgZmlsdGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpbHRlckZwID0gZmlsdGVyRmluZ2VycHJpbnQoZmlsdGVycywgc3ViLmNsb3NlT25Fb3NlKTtcbiAgICAgIGlmIChmaWx0ZXJGcCkge1xuICAgICAgICBjb25zdCBleGlzdGluZ1N1YnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KGZpbHRlckZwKTtcbiAgICAgICAgcmVsYXlTdWIgPSAoZXhpc3RpbmdTdWJzIHx8IFtdKS5maW5kKChzdWIyKSA9PiBzdWIyLnN0YXR1cyA8IDMgLyogUlVOTklORyAqLyk7XG4gICAgICB9XG4gICAgICByZWxheVN1YiA/Pz0gdGhpcy5jcmVhdGVTdWJzY3JpcHRpb24oc3ViLCBmaWx0ZXJzLCBmaWx0ZXJGcCk7XG4gICAgfVxuICAgIHJlbGF5U3ViLmFkZEl0ZW0oc3ViLCBmaWx0ZXJzKTtcbiAgfVxuICBjcmVhdGVTdWJzY3JpcHRpb24oX3N1YiwgX2ZpbHRlcnMsIGZpbmdlcnByaW50KSB7XG4gICAgY29uc3QgcmVsYXlTdWIgPSBuZXcgTkRLUmVsYXlTdWJzY3JpcHRpb24odGhpcy5yZWxheSwgZmluZ2VycHJpbnQgfHwgbnVsbCwgdGhpcy5nZW5lcmFsU3ViTWFuYWdlcik7XG4gICAgcmVsYXlTdWIub25DbG9zZSA9IHRoaXMub25SZWxheVN1YnNjcmlwdGlvbkNsb3NlLmJpbmQodGhpcyk7XG4gICAgY29uc3QgY3VycmVudFZhbCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQocmVsYXlTdWIuZmluZ2VycHJpbnQpID8/IFtdO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQocmVsYXlTdWIuZmluZ2VycHJpbnQsIFsuLi5jdXJyZW50VmFsLCByZWxheVN1Yl0pO1xuICAgIHJldHVybiByZWxheVN1YjtcbiAgfVxuICBvblJlbGF5U3Vic2NyaXB0aW9uQ2xvc2Uoc3ViKSB7XG4gICAgbGV0IGN1cnJlbnRWYWwgPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KHN1Yi5maW5nZXJwcmludCkgPz8gW107XG4gICAgaWYgKCFjdXJyZW50VmFsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJVbmV4cGVjdGVkbHkgZGlkIG5vdCBmaW5kIGEgc3Vic2NyaXB0aW9uIHdpdGggZmluZ2VycHJpbnRcIiwgc3ViLmZpbmdlcnByaW50KTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRWYWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1Yi5maW5nZXJwcmludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRWYWwgPSBjdXJyZW50VmFsLmZpbHRlcigocykgPT4gcy5pZCAhPT0gc3ViLmlkKTtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQoc3ViLmZpbmdlcnByaW50LCBjdXJyZW50VmFsKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9yZWxheS9pbmRleC50c1xudmFyIE5ES1JlbGF5U3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoTkRLUmVsYXlTdGF0dXMyKSA9PiB7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJESVNDT05ORUNUSU5HXCJdID0gMF0gPSBcIkRJU0NPTk5FQ1RJTkdcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkRJU0NPTk5FQ1RFRFwiXSA9IDFdID0gXCJESVNDT05ORUNURURcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIlJFQ09OTkVDVElOR1wiXSA9IDJdID0gXCJSRUNPTk5FQ1RJTkdcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkZMQVBQSU5HXCJdID0gM10gPSBcIkZMQVBQSU5HXCI7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJDT05ORUNUSU5HXCJdID0gNF0gPSBcIkNPTk5FQ1RJTkdcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkNPTk5FQ1RFRFwiXSA9IDVdID0gXCJDT05ORUNURURcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkFVVEhfUkVRVUVTVEVEXCJdID0gNl0gPSBcIkFVVEhfUkVRVUVTVEVEXCI7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJBVVRIRU5USUNBVElOR1wiXSA9IDddID0gXCJBVVRIRU5USUNBVElOR1wiO1xuICBOREtSZWxheVN0YXR1czJbTkRLUmVsYXlTdGF0dXMyW1wiQVVUSEVOVElDQVRFRFwiXSA9IDhdID0gXCJBVVRIRU5USUNBVEVEXCI7XG4gIHJldHVybiBOREtSZWxheVN0YXR1czI7XG59KShOREtSZWxheVN0YXR1cyB8fCB7fSk7XG52YXIgTkRLUmVsYXkgPSBjbGFzcyBfTkRLUmVsYXkgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICB1cmw7XG4gIHNjb3JlcztcbiAgY29ubmVjdGl2aXR5O1xuICBzdWJzO1xuICBwdWJsaXNoZXI7XG4gIGF1dGhQb2xpY3k7XG4gIC8qKlxuICAgKiBUaGUgbG93ZXN0IHZhbGlkYXRpb24gcmF0aW8gdGhpcyByZWxheSBjYW4gcmVhY2guXG4gICAqL1xuICBsb3dlc3RWYWxpZGF0aW9uUmF0aW87XG4gIC8qKlxuICAgKiBDdXJyZW50IHZhbGlkYXRpb24gcmF0aW8gdGhpcyByZWxheSBpcyB0YXJnZXRpbmcuXG4gICAqL1xuICB0YXJnZXRWYWxpZGF0aW9uUmF0aW87XG4gIHZhbGlkYXRpb25SYXRpb0ZuO1xuICAvKipcbiAgICogVGhpcyB0cmFja3MgZXZlbnRzIHRoYXQgaGF2ZSBiZWVuIHNlZW4gYnkgdGhpcyByZWxheVxuICAgKiB3aXRoIGEgdmFsaWQgc2lnbmF0dXJlLlxuICAgKi9cbiAgdmFsaWRhdGVkRXZlbnRDb3VudCA9IDA7XG4gIC8qKlxuICAgKiBUaGlzIHRyYWNrcyBldmVudHMgdGhhdCBoYXZlIGJlZW4gc2VlbiBieSB0aGlzIHJlbGF5XG4gICAqIGJ1dCBoYXZlIG5vdCBiZWVuIHZhbGlkYXRlZC5cbiAgICovXG4gIG5vblZhbGlkYXRlZEV2ZW50Q291bnQgPSAwO1xuICAvKipcbiAgICogV2hldGhlciB0aGlzIHJlbGF5IGlzIHRydXN0ZWQuXG4gICAqXG4gICAqIFRydXN0ZWQgcmVsYXkncyBldmVudHMgZG8gbm90IGdldCB0aGVpciBzaWduYXR1cmUgdmVyaWZpZWQuXG4gICAqL1xuICB0cnVzdGVkID0gZmFsc2U7XG4gIGNvbXBsYWluaW5nID0gZmFsc2U7XG4gIGRlYnVnO1xuICBzdGF0aWMgZGVmYXVsdFZhbGlkYXRpb25SYXRpb1VwZGF0ZUZuID0gKHJlbGF5LCB2YWxpZGF0ZWRDb3VudCwgX25vblZhbGlkYXRlZENvdW50KSA9PiB7XG4gICAgaWYgKHJlbGF5Lmxvd2VzdFZhbGlkYXRpb25SYXRpbyA9PT0gdm9pZCAwIHx8IHJlbGF5LnRhcmdldFZhbGlkYXRpb25SYXRpbyA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICBsZXQgbmV3UmF0aW8gPSByZWxheS52YWxpZGF0aW9uUmF0aW87XG4gICAgaWYgKHJlbGF5LnZhbGlkYXRpb25SYXRpbyA+IHJlbGF5LnRhcmdldFZhbGlkYXRpb25SYXRpbykge1xuICAgICAgY29uc3QgZmFjdG9yID0gdmFsaWRhdGVkQ291bnQgLyAxMDA7XG4gICAgICBuZXdSYXRpbyA9IE1hdGgubWF4KHJlbGF5Lmxvd2VzdFZhbGlkYXRpb25SYXRpbywgcmVsYXkudmFsaWRhdGlvblJhdGlvIC0gZmFjdG9yKTtcbiAgICB9XG4gICAgaWYgKG5ld1JhdGlvIDwgcmVsYXkudmFsaWRhdGlvblJhdGlvKSB7XG4gICAgICByZXR1cm4gbmV3UmF0aW87XG4gICAgfVxuICAgIHJldHVybiByZWxheS52YWxpZGF0aW9uUmF0aW87XG4gIH07XG4gIGNvbnN0cnVjdG9yKHVybCwgYXV0aFBvbGljeSwgbmRrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVybCA9IG5vcm1hbGl6ZVJlbGF5VXJsKHVybCk7XG4gICAgdGhpcy5zY29yZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVidWcgPSBkZWJ1ZyhgbmRrOnJlbGF5OiR7dXJsfWApO1xuICAgIHRoaXMuY29ubmVjdGl2aXR5ID0gbmV3IE5ES1JlbGF5Q29ubmVjdGl2aXR5KHRoaXMsIG5kayk7XG4gICAgdGhpcy5jb25uZWN0aXZpdHkubmV0RGVidWcgPSBuZGs/Lm5ldERlYnVnO1xuICAgIHRoaXMucmVxID0gdGhpcy5jb25uZWN0aXZpdHkucmVxLmJpbmQodGhpcy5jb25uZWN0aXZpdHkpO1xuICAgIHRoaXMuY2xvc2UgPSB0aGlzLmNvbm5lY3Rpdml0eS5jbG9zZS5iaW5kKHRoaXMuY29ubmVjdGl2aXR5KTtcbiAgICB0aGlzLnN1YnMgPSBuZXcgTkRLUmVsYXlTdWJzY3JpcHRpb25NYW5hZ2VyKHRoaXMsIG5kay5zdWJNYW5hZ2VyKTtcbiAgICB0aGlzLnB1Ymxpc2hlciA9IG5ldyBOREtSZWxheVB1Ymxpc2hlcih0aGlzKTtcbiAgICB0aGlzLmF1dGhQb2xpY3kgPSBhdXRoUG9saWN5O1xuICAgIHRoaXMudGFyZ2V0VmFsaWRhdGlvblJhdGlvID0gbmRrPy5pbml0aWFsVmFsaWRhdGlvblJhdGlvO1xuICAgIHRoaXMubG93ZXN0VmFsaWRhdGlvblJhdGlvID0gbmRrPy5sb3dlc3RWYWxpZGF0aW9uUmF0aW87XG4gICAgdGhpcy52YWxpZGF0aW9uUmF0aW9GbiA9IChuZGs/LnZhbGlkYXRpb25SYXRpb0ZuID8/IF9OREtSZWxheS5kZWZhdWx0VmFsaWRhdGlvblJhdGlvVXBkYXRlRm4pLmJpbmQodGhpcyk7XG4gICAgdGhpcy51cGRhdGVWYWxpZGF0aW9uUmF0aW8oKTtcbiAgICBpZiAoIW5kaykge1xuICAgICAgY29uc29sZS50cmFjZShcInJlbGF5IGNyZWF0ZWQgd2l0aG91dCBuZGtcIik7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVZhbGlkYXRpb25SYXRpbygpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlVmFsaWRhdGlvblJhdGlvKCk7XG4gICAgfSwgM2U0KTtcbiAgfVxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eS5zdGF0dXM7XG4gIH1cbiAgZ2V0IGNvbm5lY3Rpb25TdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aXZpdHkuY29ubmVjdGlvblN0YXRzO1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byB0aGUgcmVsYXkuXG4gICAqL1xuICBhc3luYyBjb25uZWN0KHRpbWVvdXRNcywgcmVjb25uZWN0ID0gdHJ1ZSkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eS5jb25uZWN0KHRpbWVvdXRNcywgcmVjb25uZWN0KTtcbiAgfVxuICAvKipcbiAgICogRGlzY29ubmVjdHMgZnJvbSB0aGUgcmVsYXkuXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMSAvKiBESVNDT05ORUNURUQgKi8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0aXZpdHkuZGlzY29ubmVjdCgpO1xuICB9XG4gIC8qKlxuICAgKiBRdWV1ZXMgb3IgZXhlY3V0ZXMgdGhlIHN1YnNjcmlwdGlvbiBvZiBhIHNwZWNpZmljIHNldCBvZiBmaWx0ZXJzXG4gICAqIHdpdGhpbiB0aGlzIHJlbGF5LlxuICAgKlxuICAgKiBAcGFyYW0gc3Vic2NyaXB0aW9uIE5ES1N1YnNjcmlwdGlvbiB0aGlzIGZpbHRlcnMgYmVsb25nIHRvLlxuICAgKiBAcGFyYW0gZmlsdGVycyBGaWx0ZXJzIHRvIGV4ZWN1dGVcbiAgICovXG4gIHN1YnNjcmliZShzdWJzY3JpcHRpb24sIGZpbHRlcnMpIHtcbiAgICB0aGlzLnN1YnMuYWRkU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbiwgZmlsdGVycyk7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2hlcyBhbiBldmVudCB0byB0aGUgcmVsYXkgd2l0aCBhbiBvcHRpb25hbCB0aW1lb3V0LlxuICAgKlxuICAgKiBJZiB0aGUgcmVsYXkgaXMgbm90IGNvbm5lY3RlZCwgdGhlIGV2ZW50IHdpbGwgYmUgcHVibGlzaGVkIHdoZW4gdGhlIHJlbGF5IGNvbm5lY3RzLFxuICAgKiB1bmxlc3MgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZCBiZWZvcmUgdGhlIHJlbGF5IGNvbm5lY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHB1Ymxpc2hcbiAgICogQHBhcmFtIHRpbWVvdXRNcyBUaGUgdGltZW91dCBmb3IgdGhlIHB1Ymxpc2ggb3BlcmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBldmVudCBoYXMgYmVlbiBwdWJsaXNoZWQgb3IgcmVqZWN0cyBpZiB0aGUgb3BlcmF0aW9uIHRpbWVzIG91dFxuICAgKi9cbiAgYXN5bmMgcHVibGlzaChldmVudCwgdGltZW91dE1zID0gMjUwMCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5wdWJsaXNoKGV2ZW50LCB0aW1lb3V0TXMpO1xuICB9XG4gIHJlZmVyZW5jZVRhZ3MoKSB7XG4gICAgcmV0dXJuIFtbXCJyXCIsIHRoaXMudXJsXV07XG4gIH1cbiAgYWRkVmFsaWRhdGVkRXZlbnQoKSB7XG4gICAgdGhpcy52YWxpZGF0ZWRFdmVudENvdW50Kys7XG4gIH1cbiAgYWRkTm9uVmFsaWRhdGVkRXZlbnQoKSB7XG4gICAgdGhpcy5ub25WYWxpZGF0ZWRFdmVudENvdW50Kys7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHZhbGlkYXRpb24gcmF0aW8gdGhpcyByZWxheSBoYXMgYWNoaWV2ZWQuXG4gICAqL1xuICBnZXQgdmFsaWRhdGlvblJhdGlvKCkge1xuICAgIGlmICh0aGlzLm5vblZhbGlkYXRlZEV2ZW50Q291bnQgPT09IDApIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZWRFdmVudENvdW50IC8gKHRoaXMudmFsaWRhdGVkRXZlbnRDb3VudCArIHRoaXMubm9uVmFsaWRhdGVkRXZlbnRDb3VudCk7XG4gIH1cbiAgc2hvdWxkVmFsaWRhdGVFdmVudCgpIHtcbiAgICBpZiAodGhpcy50cnVzdGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnRhcmdldFZhbGlkYXRpb25SYXRpbyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGlvblJhdGlvIDwgdGhpcy50YXJnZXRWYWxpZGF0aW9uUmF0aW87XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aXZpdHkuY29ubmVjdGVkO1xuICB9XG4gIHJlcTtcbiAgY2xvc2U7XG59O1xuXG4vLyBzcmMvcmVsYXkvc2V0cy9pbmRleC50c1xudmFyIE5ES1B1Ymxpc2hFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBlcnJvcnM7XG4gIHB1Ymxpc2hlZFRvUmVsYXlzO1xuICAvKipcbiAgICogSW50ZW5kZWQgcmVsYXkgc2V0IHdoZXJlIHRoZSBwdWJsaXNoaW5nIHdhcyBpbnRlbmRlZCB0byBoYXBwZW4uXG4gICAqL1xuICBpbnRlbmRlZFJlbGF5U2V0O1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvcnMsIHB1Ymxpc2hlZFRvUmVsYXlzLCBpbnRlbmRlZFJlbGF5U2V0KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5wdWJsaXNoZWRUb1JlbGF5cyA9IHB1Ymxpc2hlZFRvUmVsYXlzO1xuICAgIHRoaXMuaW50ZW5kZWRSZWxheVNldCA9IGludGVuZGVkUmVsYXlTZXQ7XG4gIH1cbiAgZ2V0IHJlbGF5RXJyb3JzKCkge1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgW3JlbGF5LCBlcnJdIG9mIHRoaXMuZXJyb3JzKSB7XG4gICAgICBlcnJvcnMucHVzaChgJHtyZWxheS51cmx9OiAke2Vycn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycy5qb2luKFwiXFxuXCIpO1xuICB9XG59O1xudmFyIE5ES1JlbGF5U2V0ID0gY2xhc3MgX05ES1JlbGF5U2V0IHtcbiAgcmVsYXlzO1xuICBkZWJ1ZztcbiAgbmRrO1xuICBwb29sO1xuICBjb25zdHJ1Y3RvcihyZWxheXMsIG5kaywgcG9vbCkge1xuICAgIHRoaXMucmVsYXlzID0gcmVsYXlzO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMucG9vbCA9IHBvb2wgPz8gbmRrLnBvb2w7XG4gICAgdGhpcy5kZWJ1ZyA9IG5kay5kZWJ1Zy5leHRlbmQoXCJyZWxheXNldFwiKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHJlbGF5IHRvIHRoaXMgc2V0LlxuICAgKi9cbiAgYWRkUmVsYXkocmVsYXkpIHtcbiAgICB0aGlzLnJlbGF5cy5hZGQocmVsYXkpO1xuICB9XG4gIGdldCByZWxheVVybHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWxheXMpLm1hcCgocikgPT4gci51cmwpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVsYXkgc2V0IGZyb20gYSBsaXN0IG9mIHJlbGF5IFVSTHMuXG4gICAqXG4gICAqIElmIG5vIGNvbm5lY3Rpb24gdG8gdGhlIHJlbGF5IGlzIGZvdW5kIGluIHRoZSBwb29sIGl0IHdpbGwgdGVtcG9yYXJpbHlcbiAgICogY29ubmVjdCB0byBpdC5cbiAgICpcbiAgICogQHBhcmFtIHJlbGF5VXJscyAtIGxpc3Qgb2YgcmVsYXkgVVJMcyB0byBpbmNsdWRlIGluIHRoaXMgc2V0XG4gICAqIEBwYXJhbSBuZGtcbiAgICogQHBhcmFtIGNvbm5lY3QgLSB3aGV0aGVyIHRvIGNvbm5lY3QgdG8gdGhlIHJlbGF5IGltbWVkaWF0ZWx5IGlmIGl0IHdhcyBhbHJlYWR5IGluIHRoZSBwb29sIGJ1dCBub3QgY29ubmVjdGVkXG4gICAqIEByZXR1cm5zIE5ES1JlbGF5U2V0XG4gICAqL1xuICBzdGF0aWMgZnJvbVJlbGF5VXJscyhyZWxheVVybHMsIG5kaywgY29ubmVjdCA9IHRydWUsIHBvb2wpIHtcbiAgICBwb29sID0gcG9vbCA/PyBuZGsucG9vbDtcbiAgICBpZiAoIXBvb2wpIHRocm93IG5ldyBFcnJvcihcIk5vIHBvb2wgcHJvdmlkZWRcIik7XG4gICAgY29uc3QgcmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHVybCBvZiByZWxheVVybHMpIHtcbiAgICAgIGNvbnN0IHJlbGF5ID0gcG9vbC5yZWxheXMuZ2V0KG5vcm1hbGl6ZVJlbGF5VXJsKHVybCkpO1xuICAgICAgaWYgKHJlbGF5KSB7XG4gICAgICAgIGlmIChyZWxheS5zdGF0dXMgPCA1IC8qIENPTk5FQ1RFRCAqLyAmJiBjb25uZWN0KSB7XG4gICAgICAgICAgcmVsYXkuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlbGF5cy5hZGQocmVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGVtcG9yYXJ5UmVsYXkgPSBuZXcgTkRLUmVsYXkobm9ybWFsaXplUmVsYXlVcmwodXJsKSwgbmRrPy5yZWxheUF1dGhEZWZhdWx0UG9saWN5LCBuZGspO1xuICAgICAgICBwb29sLnVzZVRlbXBvcmFyeVJlbGF5KHRlbXBvcmFyeVJlbGF5LCB2b2lkIDAsIGByZXF1ZXN0ZWQgZnJvbSBmcm9tUmVsYXlVcmxzICR7cmVsYXlVcmxzfWApO1xuICAgICAgICByZWxheXMuYWRkKHRlbXBvcmFyeVJlbGF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfTkRLUmVsYXlTZXQobmV3IFNldChyZWxheXMpLCBuZGssIHBvb2wpO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoIGFuIGV2ZW50IHRvIGFsbCByZWxheXMgaW4gdGhpcyByZWxheSBzZXQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgYSByb2J1c3QgbWVjaGFuaXNtIGZvciBwdWJsaXNoaW5nIGV2ZW50cyB0byBtdWx0aXBsZSByZWxheXMgd2l0aFxuICAgKiBidWlsdC1pbiBoYW5kbGluZyBmb3IgcmFjZSBjb25kaXRpb25zLCB0aW1lb3V0cywgYW5kIHBhcnRpYWwgZmFpbHVyZXMuIFRoZSBpbXBsZW1lbnRhdGlvblxuICAgKiB1c2VzIGEgZHVhbC10cmFja2luZyBtZWNoYW5pc20gdG8gZW5zdXJlIGFjY3VyYXRlIHJlcG9ydGluZyBvZiB3aGljaCByZWxheXMgc3VjY2Vzc2Z1bGx5XG4gICAqIHJlY2VpdmVkIGFuIGV2ZW50LlxuICAgKlxuICAgKiBLZXkgYXNwZWN0cyBvZiB0aGlzIGltcGxlbWVudGF0aW9uOlxuICAgKlxuICAgKiAxLiBEVUFMLVRSQUNLSU5HIE1FQ0hBTklTTTpcbiAgICogICAgLSBQcm9taXNlLWJhc2VkIHRyYWNraW5nOiBSZWNvcmRzIHN1Y2Nlc3Nlcy9mYWlsdXJlcyBmcm9tIHRoZSBwcm9taXNlcyByZXR1cm5lZCBieSByZWxheS5wdWJsaXNoKClcbiAgICogICAgLSBFdmVudC1iYXNlZCB0cmFja2luZzogTGlzdGVucyBmb3IgJ3JlbGF5OnB1Ymxpc2hlZCcgZXZlbnRzIHRoYXQgaW5kaWNhdGUgc3VjY2Vzc2Z1bCBwdWJsaXNoaW5nXG4gICAqICAgIFRoaXMgYXBwcm9hY2ggZW5zdXJlcyB3ZSBkb24ndCBtaXNzIHN1Y2Nlc3NmdWwgcHVibGlzaGVzIGV2ZW4gaWYgdGhlcmUgYXJlIHN1YnNlcXVlbnQgZXJyb3JzIGluXG4gICAqICAgIHRoZSBwcm9taXNlIGNoYWluLlxuICAgKlxuICAgKiAyLiBSQUNFIENPTkRJVElPTiBIQU5ETElORzpcbiAgICogICAgLSBJZiBhIHJlbGF5IGVtaXRzIGEgc3VjY2VzcyBldmVudCBidXQgbGF0ZXIgZmFpbHMgaW4gdGhlIHByb21pc2UgY2hhaW4sIHdlIHN0aWxsIGNvdW50IGl0IGFzIGEgc3VjY2Vzc1xuICAgKiAgICAtIElmIGEgcmVsYXkgdGltZXMgb3V0IGFmdGVyIHN1Y2Nlc3NmdWxseSBwdWJsaXNoaW5nLCB3ZSBzdGlsbCBjb3VudCBpdCBhcyBhIHN1Y2Nlc3NcbiAgICogICAgLSBBbGwgcmVsYXkgb3BlcmF0aW9ucyBoYXBwZW4gaW4gcGFyYWxsZWwsIHdpdGggcHJvcGVyIHRyYWNraW5nIHJlZ2FyZGxlc3Mgb2YgY29tcGxldGlvbiBvcmRlclxuICAgKlxuICAgKiAzLiBUSU1FT1VUIE1BTkFHRU1FTlQ6XG4gICAqICAgIC0gSW5kaXZpZHVhbCB0aW1lb3V0cyBmb3IgZWFjaCByZWxheSBvcGVyYXRpb25cbiAgICogICAgLSBQcm9wZXIgY2xlYW51cCBvZiB0aW1lb3V0cyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgKiAgICAtIENsZWFyIHRpbWVvdXQgZXJyb3IgcmVwb3J0aW5nXG4gICAqXG4gICAqIDQuIEVSUk9SIEhBTkRMSU5HOlxuICAgKiAgICAtIERldGFpbGVkIHRyYWNraW5nIG9mIHNwZWNpZmljIGVycm9ycyBmb3IgZWFjaCBmYWlsZWQgcmVsYXlcbiAgICogICAgLSBTcGVjaWFsIGhhbmRsaW5nIGZvciBlcGhlbWVyYWwgZXZlbnRzICh3aGljaCBkb24ndCBleHBlY3QgYWNrbm93bGVkZ2VtZW50KVxuICAgKiAgICAtIFJlcXVpcmVkUmVsYXlDb3VudCBwYXJhbWV0ZXIgdG8gY29udHJvbCB0aGUgbWluaW11bSBzdWNjZXNzIHRocmVzaG9sZFxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgRXZlbnQgdG8gcHVibGlzaFxuICAgKiBAcGFyYW0gdGltZW91dE1zIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciBlYWNoIHJlbGF5IHB1Ymxpc2ggb3BlcmF0aW9uXG4gICAqIEBwYXJhbSByZXF1aXJlZFJlbGF5Q291bnQgVGhlIG1pbmltdW0gbnVtYmVyIG9mIHJlbGF5cyB3ZSBleHBlY3QgdGhlIGV2ZW50IHRvIGJlIHB1Ymxpc2hlZCB0b1xuICAgKiBAcmV0dXJucyBBIHNldCBvZiByZWxheXMgdGhlIGV2ZW50IHdhcyBwdWJsaXNoZWQgdG9cbiAgICogQHRocm93cyB7TkRLUHVibGlzaEVycm9yfSBJZiB0aGUgZXZlbnQgY291bGQgbm90IGJlIHB1Ymxpc2hlZCB0byBhdCBsZWFzdCBgcmVxdWlyZWRSZWxheUNvdW50YCByZWxheXNcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZWxheVNldCA9IG5ldyBOREtSZWxheVNldChuZXcgU2V0KFtyZWxheTEsIHJlbGF5Ml0pLCBuZGspO1xuICAgKiBjb25zdCBwdWJsaXNoZWRUb1JlbGF5cyA9IGF3YWl0IHJlbGF5U2V0LnB1Ymxpc2goZXZlbnQpO1xuICAgKiAvLyBwdWJsaXNoZWRUb1JlbGF5cyBjYW4gY29udGFpbiByZWxheTEsIHJlbGF5MiwgYm90aCwgb3Igbm9uZVxuICAgKiAvLyBkZXBlbmRpbmcgb24gd2hpY2ggcmVsYXlzIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZCB0b1xuICAgKiBpZiAocHVibGlzaGVkVG9SZWxheXMuc2l6ZSA+IDApIHtcbiAgICogICBjb25zb2xlLmxvZyhcIkV2ZW50IHB1Ymxpc2hlZCB0byBhdCBsZWFzdCBvbmUgcmVsYXlcIik7XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBwdWJsaXNoKGV2ZW50LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCA9IDEpIHtcbiAgICBjb25zdCBwdWJsaXNoZWRUb1JlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgZXJyb3JzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBpc0VwaGVtZXJhbDIgPSBldmVudC5pc0VwaGVtZXJhbCgpO1xuICAgIGV2ZW50LnB1Ymxpc2hTdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICBjb25zdCByZWxheVB1Ymxpc2hlZEhhbmRsZXIgPSAocmVsYXkpID0+IHtcbiAgICAgIHB1Ymxpc2hlZFRvUmVsYXlzLmFkZChyZWxheSk7XG4gICAgfTtcbiAgICBldmVudC5vbihcInJlbGF5OnB1Ymxpc2hlZFwiLCByZWxheVB1Ymxpc2hlZEhhbmRsZXIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IEFycmF5LmZyb20odGhpcy5yZWxheXMpLm1hcCgocmVsYXkpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGltZW91dElkID0gdGltZW91dE1zID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXB1Ymxpc2hlZFRvUmVsYXlzLmhhcyhyZWxheSkpIHtcbiAgICAgICAgICAgICAgZXJyb3JzLnNldChyZWxheSwgbmV3IEVycm9yKGBQdWJsaXNoIHRpbWVvdXQgYWZ0ZXIgJHt0aW1lb3V0TXN9bXNgKSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRpbWVvdXRNcykgOiBudWxsO1xuICAgICAgICAgIHJlbGF5LnB1Ymxpc2goZXZlbnQsIHRpbWVvdXRNcykudGhlbigoc3VjY2VzcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXRJZCkgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICBwdWJsaXNoZWRUb1JlbGF5cy5hZGQocmVsYXkpO1xuICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXRJZCkgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICBpZiAoIWlzRXBoZW1lcmFsMikge1xuICAgICAgICAgICAgICBlcnJvcnMuc2V0KHJlbGF5LCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICBpZiAocHVibGlzaGVkVG9SZWxheXMuc2l6ZSA8IHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgICAgICBpZiAoIWlzRXBoZW1lcmFsMikge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IE5ES1B1Ymxpc2hFcnJvcihcbiAgICAgICAgICAgIFwiTm90IGVub3VnaCByZWxheXMgcmVjZWl2ZWQgdGhlIGV2ZW50XCIsXG4gICAgICAgICAgICBlcnJvcnMsXG4gICAgICAgICAgICBwdWJsaXNoZWRUb1JlbGF5cyxcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICApO1xuICAgICAgICAgIGV2ZW50LnB1Ymxpc2hTdGF0dXMgPSBcImVycm9yXCI7XG4gICAgICAgICAgZXZlbnQucHVibGlzaEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgdGhpcy5uZGs/LmVtaXQoXCJldmVudDpwdWJsaXNoLWZhaWxlZFwiLCBldmVudCwgZXJyb3IsIHRoaXMucmVsYXlVcmxzKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZlbnQucHVibGlzaFN0YXR1cyA9IFwic3VjY2Vzc1wiO1xuICAgICAgICBldmVudC5lbWl0KFwicHVibGlzaGVkXCIsIHsgcmVsYXlTZXQ6IHRoaXMsIHB1Ymxpc2hlZFRvUmVsYXlzIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHB1Ymxpc2hlZFRvUmVsYXlzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBldmVudC5vZmYoXCJyZWxheTpwdWJsaXNoZWRcIiwgcmVsYXlQdWJsaXNoZWRIYW5kbGVyKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXlzLnNpemU7XG4gIH1cbn07XG5cbi8vIHNyYy9yZWxheS9zZXRzL2NhbGN1bGF0ZS50c1xudmFyIGQgPSBjcmVhdGVEZWJ1ZyhcIm5kazpvdXRib3g6Y2FsY3VsYXRlXCIpO1xuYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXlTZXRGcm9tRXZlbnQobmRrLCBldmVudCkge1xuICBjb25zdCByZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBhdXRob3JXcml0ZVJlbGF5cyA9IGF3YWl0IGdldFdyaXRlUmVsYXlzRm9yKG5kaywgZXZlbnQucHVia2V5KTtcbiAgaWYgKGF1dGhvcldyaXRlUmVsYXlzKSB7XG4gICAgYXV0aG9yV3JpdGVSZWxheXMuZm9yRWFjaCgocmVsYXlVcmwpID0+IHtcbiAgICAgIGNvbnN0IHJlbGF5ID0gbmRrLnBvb2w/LmdldFJlbGF5KHJlbGF5VXJsKTtcbiAgICAgIGlmIChyZWxheSkgcmVsYXlzLmFkZChyZWxheSk7XG4gICAgfSk7XG4gIH1cbiAgbGV0IHJlbGF5SGludHMgPSBldmVudC50YWdzLmZpbHRlcigodGFnKSA9PiBbXCJhXCIsIFwiZVwiXS5pbmNsdWRlcyh0YWdbMF0pKS5tYXAoKHRhZykgPT4gdGFnWzJdKS5maWx0ZXIoKHVybCkgPT4gdXJsPy5zdGFydHNXaXRoKFwid3NzOi8vXCIpKS5maWx0ZXIoKHVybCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBuZXcgVVJMKHVybCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pLm1hcCgodXJsKSA9PiBub3JtYWxpemVSZWxheVVybCh1cmwpKTtcbiAgcmVsYXlIaW50cyA9IEFycmF5LmZyb20obmV3IFNldChyZWxheUhpbnRzKSkuc2xpY2UoMCwgNSk7XG4gIHJlbGF5SGludHMuZm9yRWFjaCgocmVsYXlVcmwpID0+IHtcbiAgICBjb25zdCByZWxheSA9IG5kay5wb29sPy5nZXRSZWxheShyZWxheVVybCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgaWYgKHJlbGF5KSB7XG4gICAgICBkKFwiQWRkaW5nIHJlbGF5IGhpbnQgJXNcIiwgcmVsYXlVcmwpO1xuICAgICAgcmVsYXlzLmFkZChyZWxheSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgcFRhZ3MgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICBpZiAocFRhZ3MubGVuZ3RoIDwgNSkge1xuICAgIGNvbnN0IHBUYWdnZWRSZWxheXMgPSBBcnJheS5mcm9tKFxuICAgICAgY2hvb3NlUmVsYXlDb21iaW5hdGlvbkZvclB1YmtleXMobmRrLCBwVGFncywgXCJyZWFkXCIsIHtcbiAgICAgICAgcHJlZmVycmVkUmVsYXlzOiBuZXcgU2V0KGF1dGhvcldyaXRlUmVsYXlzKVxuICAgICAgfSkua2V5cygpXG4gICAgKTtcbiAgICBwVGFnZ2VkUmVsYXlzLmZvckVhY2goKHJlbGF5VXJsKSA9PiB7XG4gICAgICBjb25zdCByZWxheSA9IG5kay5wb29sPy5nZXRSZWxheShyZWxheVVybCwgZmFsc2UsIHRydWUpO1xuICAgICAgaWYgKHJlbGF5KSB7XG4gICAgICAgIGQoXCJBZGRpbmcgcC10YWdnZWQgcmVsYXkgJXNcIiwgcmVsYXlVcmwpO1xuICAgICAgICByZWxheXMuYWRkKHJlbGF5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkKFwiVG9vIG1hbnkgcC10YWdzIHRvIGNvbnNpZGVyICVkXCIsIHBUYWdzLmxlbmd0aCk7XG4gIH1cbiAgbmRrLnBvb2w/LnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLmZvckVhY2goKHJlbGF5KSA9PiByZWxheXMuYWRkKHJlbGF5KSk7XG4gIHJldHVybiBuZXcgTkRLUmVsYXlTZXQocmVsYXlzLCBuZGspO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXlTZXRzRnJvbUZpbHRlcihuZGssIGZpbHRlcnMsIHBvb2wpIHtcbiAgY29uc3QgcmVzdWx0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgYXV0aG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZpbHRlcnMuZm9yRWFjaCgoZmlsdGVyKSA9PiB7XG4gICAgaWYgKGZpbHRlci5hdXRob3JzKSB7XG4gICAgICBmaWx0ZXIuYXV0aG9ycy5mb3JFYWNoKChhdXRob3IpID0+IGF1dGhvcnMuYWRkKGF1dGhvcikpO1xuICAgIH1cbiAgfSk7XG4gIGlmIChhdXRob3JzLnNpemUgPiAwKSB7XG4gICAgY29uc3QgYXV0aG9yVG9SZWxheXNNYXAgPSBnZXRSZWxheXNGb3JGaWx0ZXJXaXRoQXV0aG9ycyhuZGssIEFycmF5LmZyb20oYXV0aG9ycykpO1xuICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2YgYXV0aG9yVG9SZWxheXNNYXAua2V5cygpKSB7XG4gICAgICByZXN1bHQuc2V0KHJlbGF5VXJsLCBbXSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlcnMpIHtcbiAgICAgIGlmIChmaWx0ZXIuYXV0aG9ycykge1xuICAgICAgICBmb3IgKGNvbnN0IFtyZWxheVVybCwgYXV0aG9yczJdIG9mIGF1dGhvclRvUmVsYXlzTWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgIGNvbnN0IGF1dGhvckZpbHRlckFuZFJlbGF5UHVia2V5SW50ZXJzZWN0aW9uID0gZmlsdGVyLmF1dGhvcnMuZmlsdGVyKFxuICAgICAgICAgICAgKGF1dGhvcikgPT4gYXV0aG9yczIuaW5jbHVkZXMoYXV0aG9yKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzdWx0LnNldChyZWxheVVybCwgW1xuICAgICAgICAgICAgLi4ucmVzdWx0LmdldChyZWxheVVybCksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLmZpbHRlcixcbiAgICAgICAgICAgICAgLy8gT3ZlcndyaXRlIGF1dGhvcnMgc2VudCB0byB0aGlzIHJlbGF5IHdpdGggdGhlIGF1dGhvcnMgdGhhdCB3ZXJlXG4gICAgICAgICAgICAgIC8vIHByZXNlbnQgaW4gdGhlIGZpbHRlciBhbmQgYXJlIGFsc28gcHJlc2VudCBpbiB0aGUgcmVsYXlcbiAgICAgICAgICAgICAgYXV0aG9yczogYXV0aG9yRmlsdGVyQW5kUmVsYXlQdWJrZXlJbnRlcnNlY3Rpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCByZWxheVVybCBvZiBhdXRob3JUb1JlbGF5c01hcC5rZXlzKCkpIHtcbiAgICAgICAgICByZXN1bHQuc2V0KHJlbGF5VXJsLCBbLi4ucmVzdWx0LmdldChyZWxheVVybCksIGZpbHRlcl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChuZGsuZXhwbGljaXRSZWxheVVybHMpIHtcbiAgICAgIG5kay5leHBsaWNpdFJlbGF5VXJscy5mb3JFYWNoKChyZWxheVVybCkgPT4ge1xuICAgICAgICByZXN1bHQuc2V0KHJlbGF5VXJsLCBmaWx0ZXJzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAocmVzdWx0LnNpemUgPT09IDApIHtcbiAgICBwb29sLnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLnNsaWNlKDAsIDUpLmZvckVhY2goKHJlbGF5KSA9PiB7XG4gICAgICByZXN1bHQuc2V0KHJlbGF5LnVybCwgZmlsdGVycyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlbGF5U2V0c0Zyb21GaWx0ZXJzKG5kaywgZmlsdGVycywgcG9vbCkge1xuICBjb25zdCBhID0gY2FsY3VsYXRlUmVsYXlTZXRzRnJvbUZpbHRlcihuZGssIGZpbHRlcnMsIHBvb2wpO1xuICByZXR1cm4gYTtcbn1cblxuLy8gc3JjL2V2ZW50cy9jb250ZW50LXRhZ2dlci50c1xuaW1wb3J0IHsgbmlwMTkgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbmZ1bmN0aW9uIG1lcmdlVGFncyh0YWdzMSwgdGFnczIpIHtcbiAgY29uc3QgdGFnTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgZ2VuZXJhdGVLZXkgPSAodGFnKSA9PiB0YWcuam9pbihcIixcIik7XG4gIGNvbnN0IGlzQ29udGFpbmVkID0gKHNtYWxsZXIsIGxhcmdlcikgPT4ge1xuICAgIHJldHVybiBzbWFsbGVyLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlID09PSBsYXJnZXJbaW5kZXhdKTtcbiAgfTtcbiAgY29uc3QgcHJvY2Vzc1RhZyA9ICh0YWcpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIGV4aXN0aW5nVGFnXSBvZiB0YWdNYXApIHtcbiAgICAgIGlmIChpc0NvbnRhaW5lZChleGlzdGluZ1RhZywgdGFnKSB8fCBpc0NvbnRhaW5lZCh0YWcsIGV4aXN0aW5nVGFnKSkge1xuICAgICAgICBpZiAodGFnLmxlbmd0aCA+PSBleGlzdGluZ1RhZy5sZW5ndGgpIHtcbiAgICAgICAgICB0YWdNYXAuc2V0KGtleSwgdGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRhZ01hcC5zZXQoZ2VuZXJhdGVLZXkodGFnKSwgdGFnKTtcbiAgfTtcbiAgdGFnczEuY29uY2F0KHRhZ3MyKS5mb3JFYWNoKHByb2Nlc3NUYWcpO1xuICByZXR1cm4gQXJyYXkuZnJvbSh0YWdNYXAudmFsdWVzKCkpO1xufVxuZnVuY3Rpb24gdW5pcXVlVGFnKGEsIGIpIHtcbiAgY29uc3QgYUxlbmd0aCA9IGEubGVuZ3RoO1xuICBjb25zdCBiTGVuZ3RoID0gYi5sZW5ndGg7XG4gIGNvbnN0IHNhbWVMZW5ndGggPSBhTGVuZ3RoID09PSBiTGVuZ3RoO1xuICBpZiAoc2FtZUxlbmd0aCkge1xuICAgIGlmIChhLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBiW2ldKSkge1xuICAgICAgcmV0dXJuIFthXTtcbiAgICB9XG4gICAgcmV0dXJuIFthLCBiXTtcbiAgfVxuICBpZiAoYUxlbmd0aCA+IGJMZW5ndGggJiYgYS5ldmVyeSgodiwgaSkgPT4gdiA9PT0gYltpXSkpIHtcbiAgICByZXR1cm4gW2FdO1xuICB9XG4gIGlmIChiTGVuZ3RoID4gYUxlbmd0aCAmJiBiLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBhW2ldKSkge1xuICAgIHJldHVybiBbYl07XG4gIH1cbiAgcmV0dXJuIFthLCBiXTtcbn1cbnZhciBoYXNodGFnUmVnZXggPSAvKD88PVxcc3xeKSgjW15cXHMhQCMkJV4mKigpPSsuLyxbe1xcXX07OidcIj8+PF0rKS9nO1xuZnVuY3Rpb24gZ2VuZXJhdGVIYXNodGFncyhjb250ZW50KSB7XG4gIGNvbnN0IGhhc2h0YWdzID0gY29udGVudC5tYXRjaChoYXNodGFnUmVnZXgpO1xuICBjb25zdCB0YWdJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCB0YWcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBpZiAoaGFzaHRhZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGhhc2h0YWcgb2YgaGFzaHRhZ3MpIHtcbiAgICAgIGlmICh0YWdJZHMuaGFzKGhhc2h0YWcuc2xpY2UoMSkpKSBjb250aW51ZTtcbiAgICAgIHRhZy5hZGQoaGFzaHRhZy5zbGljZSgxKSk7XG4gICAgICB0YWdJZHMuYWRkKGhhc2h0YWcuc2xpY2UoMSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbSh0YWcpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50VGFncyhjb250ZW50LCB0YWdzID0gW10pIHtcbiAgY29uc3QgdGFnUmVnZXggPSAvKEB8bm9zdHI6KShucHVifG5wcm9maWxlfG5vdGV8bmV2ZW50fG5hZGRyKVthLXpBLVowLTldKy9nO1xuICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICBjb25zdCBhZGRUYWdJZk5ldyA9ICh0KSA9PiB7XG4gICAgaWYgKCF0YWdzLmZpbmQoKHQyKSA9PiBbXCJxXCIsIHRbMF1dLmluY2x1ZGVzKHQyWzBdKSAmJiB0MlsxXSA9PT0gdFsxXSkpIHtcbiAgICAgIHRhZ3MucHVzaCh0KTtcbiAgICB9XG4gIH07XG4gIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UodGFnUmVnZXgsICh0YWcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZW50aXR5ID0gdGFnLnNwbGl0KC8oQHxub3N0cjopLylbMl07XG4gICAgICBjb25zdCB7IHR5cGUsIGRhdGEgfSA9IG5pcDE5LmRlY29kZShlbnRpdHkpO1xuICAgICAgbGV0IHQ7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm5wdWJcIjpcbiAgICAgICAgICB0ID0gW1wicFwiLCBkYXRhXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5wcm9maWxlXCI6XG4gICAgICAgICAgdCA9IFtcInBcIiwgZGF0YS5wdWJrZXldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibm90ZVwiOlxuICAgICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICBhZGRUYWdJZk5ldyhbXCJxXCIsIGRhdGEsIGF3YWl0IG1heWJlR2V0RXZlbnRSZWxheVVybChlbnRpdHkpXSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5ldmVudFwiOlxuICAgICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7IGlkLCBhdXRob3IgfSA9IGRhdGE7XG4gICAgICAgICAgICAgIGxldCB7IHJlbGF5cyB9ID0gZGF0YTtcbiAgICAgICAgICAgICAgaWYgKCFyZWxheXMgfHwgcmVsYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlbGF5cyA9IFthd2FpdCBtYXliZUdldEV2ZW50UmVsYXlVcmwoZW50aXR5KV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYWRkVGFnSWZOZXcoW1wicVwiLCBpZCwgcmVsYXlzWzBdXSk7XG4gICAgICAgICAgICAgIGlmIChhdXRob3IpIGFkZFRhZ0lmTmV3KFtcInBcIiwgYXV0aG9yXSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5hZGRyXCI6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGlkID0gW2RhdGEua2luZCwgZGF0YS5wdWJrZXksIGRhdGEuaWRlbnRpZmllcl0uam9pbihcIjpcIik7XG4gICAgICAgICAgICAgIGxldCByZWxheXMgPSBkYXRhLnJlbGF5cyA/PyBbXTtcbiAgICAgICAgICAgICAgaWYgKHJlbGF5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZWxheXMgPSBbYXdhaXQgbWF5YmVHZXRFdmVudFJlbGF5VXJsKGVudGl0eSldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFkZFRhZ0lmTmV3KFtcInFcIiwgaWQsIHJlbGF5c1swXV0pO1xuICAgICAgICAgICAgICBhZGRUYWdJZk5ldyhbXCJwXCIsIGRhdGEucHVia2V5XSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgfVxuICAgICAgaWYgKHQpIGFkZFRhZ0lmTmV3KHQpO1xuICAgICAgcmV0dXJuIGBub3N0cjoke2VudGl0eX1gO1xuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG4gIH0pO1xuICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIGNvbnN0IG5ld1RhZ3MgPSBnZW5lcmF0ZUhhc2h0YWdzKGNvbnRlbnQpLm1hcCgoaGFzaHRhZykgPT4gW1widFwiLCBoYXNodGFnXSk7XG4gIHRhZ3MgPSBtZXJnZVRhZ3ModGFncywgbmV3VGFncyk7XG4gIHJldHVybiB7IGNvbnRlbnQsIHRhZ3MgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG1heWJlR2V0RXZlbnRSZWxheVVybChfbmlwMTlJZCkge1xuICByZXR1cm4gXCJcIjtcbn1cblxuLy8gc3JjL2V2ZW50cy9lbmNyeXB0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0KHJlY2lwaWVudCwgc2lnbmVyLCBzY2hlbWUgPSBcIm5pcDQ0XCIpIHtcbiAgbGV0IGVuY3J5cHRlZDtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kIVwiKTtcbiAgbGV0IGN1cnJlbnRTaWduZXIgPSBzaWduZXI7XG4gIGlmICghY3VycmVudFNpZ25lcikge1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGN1cnJlbnRTaWduZXIgPSB0aGlzLm5kay5zaWduZXI7XG4gIH1cbiAgaWYgKCFjdXJyZW50U2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBOREsgc2lnbmVyXCIpO1xuICBjb25zdCBjdXJyZW50UmVjaXBpZW50ID0gcmVjaXBpZW50IHx8ICgoKSA9PiB7XG4gICAgY29uc3QgcFRhZ3MgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIik7XG4gICAgaWYgKHBUYWdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVjaXBpZW50IGNvdWxkIGJlIGRldGVybWluZWQgYW5kIG5vIGV4cGxpY2l0IHJlY2lwaWVudCB3YXMgcHJvdmlkZWRcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5OiBwVGFnc1swXVsxXSB9KTtcbiAgfSkoKTtcbiAgaWYgKHNjaGVtZSA9PT0gXCJuaXA0NFwiICYmIGF3YWl0IGlzRW5jcnlwdGlvbkVuYWJsZWQoY3VycmVudFNpZ25lciwgXCJuaXA0NFwiKSkge1xuICAgIGVuY3J5cHRlZCA9IGF3YWl0IGN1cnJlbnRTaWduZXIuZW5jcnlwdChjdXJyZW50UmVjaXBpZW50LCB0aGlzLmNvbnRlbnQsIFwibmlwNDRcIik7XG4gIH1cbiAgaWYgKCghZW5jcnlwdGVkIHx8IHNjaGVtZSA9PT0gXCJuaXAwNFwiKSAmJiBhd2FpdCBpc0VuY3J5cHRpb25FbmFibGVkKGN1cnJlbnRTaWduZXIsIFwibmlwMDRcIikpIHtcbiAgICBlbmNyeXB0ZWQgPSBhd2FpdCBjdXJyZW50U2lnbmVyLmVuY3J5cHQoY3VycmVudFJlY2lwaWVudCwgdGhpcy5jb250ZW50LCBcIm5pcDA0XCIpO1xuICB9XG4gIGlmICghZW5jcnlwdGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZW5jcnlwdCBldmVudC5cIik7XG4gIHRoaXMuY29udGVudCA9IGVuY3J5cHRlZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQoc2VuZGVyLCBzaWduZXIsIHNjaGVtZSkge1xuICBpZiAodGhpcy5uZGs/LmNhY2hlQWRhcHRlcj8uZ2V0RGVjcnlwdGVkRXZlbnQpIHtcbiAgICBsZXQgY2FjaGVkRXZlbnQgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmdldERlY3J5cHRlZEV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNhY2hlZEV2ZW50ID0gdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmdldERlY3J5cHRlZEV2ZW50KHRoaXMuaWQpO1xuICAgIH1cbiAgICBpZiAoY2FjaGVkRXZlbnQpIHtcbiAgICAgIHRoaXMuY29udGVudCA9IGNhY2hlZEV2ZW50LmNvbnRlbnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGxldCBkZWNyeXB0ZWQ7XG4gIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZCFcIik7XG4gIGxldCBjdXJyZW50U2lnbmVyID0gc2lnbmVyO1xuICBpZiAoIWN1cnJlbnRTaWduZXIpIHtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBjdXJyZW50U2lnbmVyID0gdGhpcy5uZGsuc2lnbmVyO1xuICB9XG4gIGlmICghY3VycmVudFNpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwibm8gTkRLIHNpZ25lclwiKTtcbiAgY29uc3QgY3VycmVudFNlbmRlciA9IHNlbmRlciB8fCB0aGlzLmF1dGhvcjtcbiAgaWYgKCFjdXJyZW50U2VuZGVyKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzZW5kZXIgcHJvdmlkZWQgYW5kIG5vIGF1dGhvciBhdmFpbGFibGVcIik7XG4gIGNvbnN0IGN1cnJlbnRTY2hlbWUgPSBzY2hlbWUgfHwgKHRoaXMuY29udGVudC5tYXRjaCgvXFxcXD9pdj0vKSA/IFwibmlwMDRcIiA6IFwibmlwNDRcIik7XG4gIGlmICgoY3VycmVudFNjaGVtZSA9PT0gXCJuaXAwNFwiIHx8IHRoaXMua2luZCA9PT0gNCkgJiYgYXdhaXQgaXNFbmNyeXB0aW9uRW5hYmxlZChjdXJyZW50U2lnbmVyLCBcIm5pcDA0XCIpICYmIHRoaXMuY29udGVudC5zZWFyY2goXCJcXFxcP2l2PVwiKSkge1xuICAgIGRlY3J5cHRlZCA9IGF3YWl0IGN1cnJlbnRTaWduZXIuZGVjcnlwdChjdXJyZW50U2VuZGVyLCB0aGlzLmNvbnRlbnQsIFwibmlwMDRcIik7XG4gIH1cbiAgaWYgKCFkZWNyeXB0ZWQgJiYgY3VycmVudFNjaGVtZSA9PT0gXCJuaXA0NFwiICYmIGF3YWl0IGlzRW5jcnlwdGlvbkVuYWJsZWQoY3VycmVudFNpZ25lciwgXCJuaXA0NFwiKSkge1xuICAgIGRlY3J5cHRlZCA9IGF3YWl0IGN1cnJlbnRTaWduZXIuZGVjcnlwdChjdXJyZW50U2VuZGVyLCB0aGlzLmNvbnRlbnQsIFwibmlwNDRcIik7XG4gIH1cbiAgaWYgKCFkZWNyeXB0ZWQpIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNyeXB0IGV2ZW50LlwiKTtcbiAgdGhpcy5jb250ZW50ID0gZGVjcnlwdGVkO1xuICBpZiAodGhpcy5uZGs/LmNhY2hlQWRhcHRlcj8uYWRkRGVjcnlwdGVkRXZlbnQpIHtcbiAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuYWRkRGVjcnlwdGVkRXZlbnQodGhpcyk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGlzRW5jcnlwdGlvbkVuYWJsZWQoc2lnbmVyLCBzY2hlbWUpIHtcbiAgaWYgKCFzaWduZXIuZW5jcnlwdGlvbkVuYWJsZWQpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFzY2hlbWUpIHJldHVybiB0cnVlO1xuICByZXR1cm4gQm9vbGVhbihhd2FpdCBzaWduZXIuZW5jcnlwdGlvbkVuYWJsZWQoc2NoZW1lKSk7XG59XG5cbi8vIHNyYy90aHJlYWQvaW5kZXgudHNcbmZ1bmN0aW9uIGV2ZW50c0J5U2FtZUF1dGhvcihvcCwgZXZlbnRzKSB7XG4gIGNvbnN0IGV2ZW50c0J5QXV0aG9yID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZXZlbnRzQnlBdXRob3Iuc2V0KG9wLmlkLCBvcCk7XG4gIGV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5wdWJrZXkgPT09IG9wLnB1YmtleSkge1xuICAgICAgZXZlbnRzQnlBdXRob3Iuc2V0KGV2ZW50LmlkLCBldmVudCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGV2ZW50c0J5QXV0aG9yO1xufVxudmFyIGhhc01hcmtlcnMgPSAoZXZlbnQsIHRhZ1R5cGUpID0+IHtcbiAgcmV0dXJuIGV2ZW50LmdldE1hdGNoaW5nVGFncyh0YWdUeXBlKS5zb21lKCh0YWcpID0+IHRhZ1szXSAmJiB0YWdbM10gIT09IFwiXCIpO1xufTtcbmZ1bmN0aW9uIGV2ZW50SXNSZXBseShvcCwgZXZlbnQsIHRocmVhZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIHRhZ1R5cGUpIHtcbiAgdGFnVHlwZSA/Pz0gb3AudGFnVHlwZSgpO1xuICBjb25zdCB0YWdzID0gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKHRhZ1R5cGUpO1xuICB0aHJlYWRJZHMuYWRkKG9wLnRhZ0lkKCkpO1xuICBpZiAodGhyZWFkSWRzLmhhcyhldmVudC50YWdJZCgpKSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBoZWVkRXhwbGljaXRSZXBseU1hcmtlciA9ICgpID0+IHtcbiAgICBsZXQgZXZlbnRJc1RhZ2dlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgIGlmICh0YWdbM10gPT09IFwicmVwbHlcIikgcmV0dXJuIHRocmVhZElkcy5oYXModGFnWzFdKTtcbiAgICAgIGNvbnN0IG1hcmtlcklzRW1wdHkgPSB0YWdbM10gPT09IFwiXCIgfHwgdGFnWzNdID09PSB2b2lkIDA7XG4gICAgICBjb25zdCBtYXJrZXJJc1Jvb3QgPSB0YWdbM10gPT09IFwicm9vdFwiO1xuICAgICAgaWYgKHRhZ1sxXSA9PT0gb3AudGFnSWQoKSAmJiAobWFya2VySXNFbXB0eSB8fCBtYXJrZXJJc1Jvb3QpKSB7XG4gICAgICAgIGV2ZW50SXNUYWdnZWQgPSBtYXJrZXJJc1Jvb3QgPyBcInJvb3RcIiA6IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZXZlbnRJc1RhZ2dlZCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChldmVudElzVGFnZ2VkID09PSBcInJvb3RcIikgcmV0dXJuIHRydWU7XG4gIH07XG4gIGNvbnN0IGV4cGxpY2l0UmVwbHlNYXJrZXIgPSBoZWVkRXhwbGljaXRSZXBseU1hcmtlcigpO1xuICBpZiAoZXhwbGljaXRSZXBseU1hcmtlciAhPT0gdm9pZCAwKSByZXR1cm4gZXhwbGljaXRSZXBseU1hcmtlcjtcbiAgaWYgKGhhc01hcmtlcnMoZXZlbnQsIHRhZ1R5cGUpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGV4cGVjdGVkVGFncyA9IG9wLmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gIGV4cGVjdGVkVGFncy5wdXNoKG9wLmlkKTtcbiAgcmV0dXJuIGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImVcIikuZXZlcnkoKHRhZykgPT4gZXhwZWN0ZWRUYWdzLmluY2x1ZGVzKHRhZ1sxXSkpO1xufVxuZnVuY3Rpb24gZXZlbnRUaHJlYWRzKG9wLCBldmVudHMpIHtcbiAgY29uc3QgZXZlbnRzQnlBdXRob3IgPSBldmVudHNCeVNhbWVBdXRob3Iob3AsIGV2ZW50cyk7XG4gIGNvbnN0IHRocmVhZEV2ZW50cyA9IGV2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiBldmVudElzUGFydE9mVGhyZWFkKG9wLCBldmVudCwgZXZlbnRzQnlBdXRob3IpKTtcbiAgcmV0dXJuIHRocmVhZEV2ZW50cy5zb3J0KChhLCBiKSA9PiBhLmNyZWF0ZWRfYXQgLSBiLmNyZWF0ZWRfYXQpO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRSZXBseUlkKGV2ZW50KSB7XG4gIGNvbnN0IHJlcGx5VGFnID0gZ2V0UmVwbHlUYWcoZXZlbnQpO1xuICBpZiAocmVwbHlUYWcpIHJldHVybiByZXBseVRhZ1sxXTtcbiAgY29uc3Qgcm9vdFRhZyA9IGdldFJvb3RUYWcoZXZlbnQpO1xuICBpZiAocm9vdFRhZykgcmV0dXJuIHJvb3RUYWdbMV07XG59XG5mdW5jdGlvbiBpc0V2ZW50T3JpZ2luYWxQb3N0KGV2ZW50KSB7XG4gIHJldHVybiBnZXRFdmVudFJlcGx5SWQoZXZlbnQpID09PSB2b2lkIDA7XG59XG5mdW5jdGlvbiBldmVudFRocmVhZElkcyhvcCwgZXZlbnRzKSB7XG4gIGNvbnN0IHRocmVhZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHRocmVhZEV2ZW50cyA9IGV2ZW50VGhyZWFkcyhvcCwgZXZlbnRzKTtcbiAgdGhyZWFkRXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB0aHJlYWRJZHMuc2V0KGV2ZW50LmlkLCBldmVudCkpO1xuICByZXR1cm4gdGhyZWFkSWRzO1xufVxuZnVuY3Rpb24gZXZlbnRSZXBsaWVzKG9wLCBldmVudHMsIHRocmVhZEV2ZW50SWRzKSB7XG4gIHRocmVhZEV2ZW50SWRzID8/PSBuZXcgU2V0KGV2ZW50VGhyZWFkSWRzKG9wLCBldmVudHMpLmtleXMoKSk7XG4gIHJldHVybiBldmVudHMuZmlsdGVyKChldmVudCkgPT4gZXZlbnRJc1JlcGx5KG9wLCBldmVudCwgdGhyZWFkRXZlbnRJZHMpKTtcbn1cbmZ1bmN0aW9uIGV2ZW50SXNQYXJ0T2ZUaHJlYWQob3AsIGV2ZW50LCBldmVudHNCeUF1dGhvcikge1xuICBpZiAob3AucHVia2V5ICE9PSBldmVudC5wdWJrZXkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgdGFnZ2VkRXZlbnRJZHMgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJlXCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICBjb25zdCBhbGxUYWdnZWRFdmVudHNBcmVCeU9yaWdpbmFsQXV0aG9yID0gdGFnZ2VkRXZlbnRJZHMuZXZlcnkoKGlkKSA9PiBldmVudHNCeUF1dGhvci5oYXMoaWQpKTtcbiAgcmV0dXJuIGFsbFRhZ2dlZEV2ZW50c0FyZUJ5T3JpZ2luYWxBdXRob3I7XG59XG5mdW5jdGlvbiBldmVudEhhc0VUYWdNYXJrZXJzKGV2ZW50KSB7XG4gIGZvciAoY29uc3QgdGFnIG9mIGV2ZW50LnRhZ3MpIHtcbiAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiAodGFnWzNdID8/IFwiXCIpLmxlbmd0aCA+IDApIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFJvb3RFdmVudElkKGV2ZW50LCBzZWFyY2hUYWcpIHtcbiAgc2VhcmNoVGFnID8/PSBldmVudC50YWdUeXBlKCk7XG4gIGNvbnN0IHJvb3RFdmVudFRhZyA9IGdldFJvb3RUYWcoZXZlbnQsIHNlYXJjaFRhZyk7XG4gIGlmIChyb290RXZlbnRUYWcpIHJldHVybiByb290RXZlbnRUYWdbMV07XG4gIGNvbnN0IHJlcGx5VGFnID0gZ2V0UmVwbHlUYWcoZXZlbnQsIHNlYXJjaFRhZyk7XG4gIHJldHVybiByZXBseVRhZz8uWzFdO1xufVxuZnVuY3Rpb24gZ2V0Um9vdFRhZyhldmVudCwgc2VhcmNoVGFnKSB7XG4gIHNlYXJjaFRhZyA/Pz0gZXZlbnQudGFnVHlwZSgpO1xuICBjb25zdCByb290RXZlbnRUYWcgPSBldmVudC50YWdzLmZpbmQoaXNUYWdSb290VGFnKTtcbiAgaWYgKCFyb290RXZlbnRUYWcpIHtcbiAgICBpZiAoZXZlbnRIYXNFVGFnTWFya2VycyhldmVudCkpIHJldHVybjtcbiAgICBjb25zdCBtYXRjaGluZ1RhZ3MgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3Moc2VhcmNoVGFnKTtcbiAgICBpZiAobWF0Y2hpbmdUYWdzLmxlbmd0aCA8IDMpIHJldHVybiBtYXRjaGluZ1RhZ3NbMF07XG4gIH1cbiAgcmV0dXJuIHJvb3RFdmVudFRhZztcbn1cbnZhciBuaXAyMlJvb3RUYWdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiQVwiLCBcIkVcIiwgXCJJXCJdKTtcbnZhciBuaXAyMlJlcGx5VGFncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImFcIiwgXCJlXCIsIFwiaVwiXSk7XG5mdW5jdGlvbiBnZXRSZXBseVRhZyhldmVudCwgc2VhcmNoVGFnKSB7XG4gIGlmIChldmVudC5raW5kID09PSAxMTExIC8qIEdlbmVyaWNSZXBseSAqLykge1xuICAgIGxldCByZXBseVRhZzI7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgZXZlbnQudGFncykge1xuICAgICAgaWYgKG5pcDIyUm9vdFRhZ3MuaGFzKHRhZ1swXSkpIHJlcGx5VGFnMiA9IHRhZztcbiAgICAgIGVsc2UgaWYgKG5pcDIyUmVwbHlUYWdzLmhhcyh0YWdbMF0pKSB7XG4gICAgICAgIHJlcGx5VGFnMiA9IHRhZztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBseVRhZzI7XG4gIH1cbiAgc2VhcmNoVGFnID8/PSBldmVudC50YWdUeXBlKCk7XG4gIGxldCBoYXNNYXJrZXJzMiA9IGZhbHNlO1xuICBsZXQgcmVwbHlUYWc7XG4gIGZvciAoY29uc3QgdGFnIG9mIGV2ZW50LnRhZ3MpIHtcbiAgICBpZiAodGFnWzBdICE9PSBzZWFyY2hUYWcpIGNvbnRpbnVlO1xuICAgIGlmICgodGFnWzNdID8/IFwiXCIpLmxlbmd0aCA+IDApIGhhc01hcmtlcnMyID0gdHJ1ZTtcbiAgICBpZiAoaGFzTWFya2VyczIgJiYgdGFnWzNdID09PSBcInJlcGx5XCIpIHJldHVybiB0YWc7XG4gICAgaWYgKGhhc01hcmtlcnMyICYmIHRhZ1szXSA9PT0gXCJyb290XCIpIHJlcGx5VGFnID0gdGFnO1xuICAgIGlmICghaGFzTWFya2VyczIpIHJlcGx5VGFnID0gdGFnO1xuICB9XG4gIHJldHVybiByZXBseVRhZztcbn1cbmZ1bmN0aW9uIGlzVGFnUm9vdFRhZyh0YWcpIHtcbiAgcmV0dXJuIHRhZ1swXSA9PT0gXCJFXCIgfHwgdGFnWzNdID09PSBcInJvb3RcIjtcbn1cblxuLy8gc3JjL2V2ZW50cy9mZXRjaC10YWdnZWQtZXZlbnQudHNcbmFzeW5jIGZ1bmN0aW9uIGZldGNoVGFnZ2VkRXZlbnQodGFnLCBtYXJrZXIpIHtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBmb3VuZFwiKTtcbiAgY29uc3QgdCA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKHRhZywgbWFya2VyKTtcbiAgaWYgKHQubGVuZ3RoID09PSAwKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBbXywgaWQsIGhpbnRdID0gdFswXTtcbiAgbGV0IHJlbGF5ID0gaGludCAhPT0gXCJcIiA/IHRoaXMubmRrLnBvb2wuZ2V0UmVsYXkoaGludCkgOiB2b2lkIDA7XG4gIGNvbnN0IGV2ZW50ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudChpZCwge30sIHJlbGF5KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSb290RXZlbnQoc3ViT3B0cykge1xuICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IGZvdW5kXCIpO1xuICBjb25zdCByb290VGFnID0gZ2V0Um9vdFRhZyh0aGlzKTtcbiAgaWYgKCFyb290VGFnKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4gdGhpcy5uZGsuZmV0Y2hFdmVudEZyb21UYWcocm9vdFRhZywgdGhpcywgc3ViT3B0cyk7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFJlcGx5RXZlbnQoc3ViT3B0cykge1xuICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IGZvdW5kXCIpO1xuICBjb25zdCByZXBseVRhZyA9IGdldFJlcGx5VGFnKHRoaXMpO1xuICBpZiAoIXJlcGx5VGFnKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4gdGhpcy5uZGsuZmV0Y2hFdmVudEZyb21UYWcocmVwbHlUYWcsIHRoaXMsIHN1Yk9wdHMpO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmQudHNcbmZ1bmN0aW9uIGlzUmVwbGFjZWFibGUoKSB7XG4gIGlmICh0aGlzLmtpbmQgPT09IHZvaWQgMCkgdGhyb3cgbmV3IEVycm9yKFwiS2luZCBub3Qgc2V0XCIpO1xuICByZXR1cm4gWzAsIDNdLmluY2x1ZGVzKHRoaXMua2luZCkgfHwgdGhpcy5raW5kID49IDFlNCAmJiB0aGlzLmtpbmQgPCAyZTQgfHwgdGhpcy5raW5kID49IDNlNCAmJiB0aGlzLmtpbmQgPCA0ZTQ7XG59XG5mdW5jdGlvbiBpc0VwaGVtZXJhbCgpIHtcbiAgaWYgKHRoaXMua2luZCA9PT0gdm9pZCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJLaW5kIG5vdCBzZXRcIik7XG4gIHJldHVybiB0aGlzLmtpbmQgPj0gMmU0ICYmIHRoaXMua2luZCA8IDNlNDtcbn1cbmZ1bmN0aW9uIGlzUGFyYW1SZXBsYWNlYWJsZSgpIHtcbiAgaWYgKHRoaXMua2luZCA9PT0gdm9pZCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJLaW5kIG5vdCBzZXRcIik7XG4gIHJldHVybiB0aGlzLmtpbmQgPj0gM2U0ICYmIHRoaXMua2luZCA8IDRlNDtcbn1cblxuLy8gc3JjL2V2ZW50cy9uaXAxOS50c1xuaW1wb3J0IHsgbmlwMTkgYXMgbmlwMTkyIH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG52YXIgREVGQVVMVF9SRUxBWV9DT1VOVCA9IDI7XG5mdW5jdGlvbiBlbmNvZGUobWF4UmVsYXlDb3VudCA9IERFRkFVTFRfUkVMQVlfQ09VTlQpIHtcbiAgbGV0IHJlbGF5cyA9IFtdO1xuICBpZiAodGhpcy5vblJlbGF5cy5sZW5ndGggPiAwKSB7XG4gICAgcmVsYXlzID0gdGhpcy5vblJlbGF5cy5tYXAoKHJlbGF5KSA9PiByZWxheS51cmwpO1xuICB9IGVsc2UgaWYgKHRoaXMucmVsYXkpIHtcbiAgICByZWxheXMgPSBbdGhpcy5yZWxheS51cmxdO1xuICB9XG4gIGlmIChyZWxheXMubGVuZ3RoID4gbWF4UmVsYXlDb3VudCkge1xuICAgIHJlbGF5cyA9IHJlbGF5cy5zbGljZSgwLCBtYXhSZWxheUNvdW50KTtcbiAgfVxuICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgIHJldHVybiBuaXAxOTIubmFkZHJFbmNvZGUoe1xuICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgcHVia2V5OiB0aGlzLnB1YmtleSxcbiAgICAgIGlkZW50aWZpZXI6IHRoaXMucmVwbGFjZWFibGVEVGFnKCksXG4gICAgICByZWxheXNcbiAgICB9KTtcbiAgfVxuICBpZiAocmVsYXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gbmlwMTkyLm5ldmVudEVuY29kZSh7XG4gICAgICBpZDogdGhpcy50YWdJZCgpLFxuICAgICAgcmVsYXlzLFxuICAgICAgYXV0aG9yOiB0aGlzLnB1YmtleVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBuaXAxOTIubm90ZUVuY29kZSh0aGlzLnRhZ0lkKCkpO1xufVxuXG4vLyBzcmMvZXZlbnRzL3JlcG9zdC50c1xuYXN5bmMgZnVuY3Rpb24gcmVwb3N0KHB1Ymxpc2ggPSB0cnVlLCBzaWduZXIpIHtcbiAgaWYgKCFzaWduZXIgJiYgcHVibGlzaCkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBzaWduZXIgPSB0aGlzLm5kay5zaWduZXI7XG4gIH1cbiAgY29uc3QgZSA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywge1xuICAgIGtpbmQ6IGdldEtpbmQodGhpcylcbiAgfSk7XG4gIGlmICghdGhpcy5pc1Byb3RlY3RlZCkgZS5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkodGhpcy5yYXdFdmVudCgpKTtcbiAgZS50YWcodGhpcyk7XG4gIGlmICh0aGlzLmtpbmQgIT09IDEgLyogVGV4dCAqLykge1xuICAgIGUudGFncy5wdXNoKFtcImtcIiwgYCR7dGhpcy5raW5kfWBdKTtcbiAgfVxuICBpZiAoc2lnbmVyKSBhd2FpdCBlLnNpZ24oc2lnbmVyKTtcbiAgaWYgKHB1Ymxpc2gpIGF3YWl0IGUucHVibGlzaCgpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGdldEtpbmQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmtpbmQgPT09IDEpIHtcbiAgICByZXR1cm4gNiAvKiBSZXBvc3QgKi87XG4gIH1cbiAgcmV0dXJuIDE2IC8qIEdlbmVyaWNSZXBvc3QgKi87XG59XG5cbi8vIHNyYy9ldmVudHMvc2VyaWFsaXplci50c1xuZnVuY3Rpb24gc2VyaWFsaXplKGluY2x1ZGVTaWcgPSBmYWxzZSwgaW5jbHVkZUlkID0gZmFsc2UpIHtcbiAgY29uc3QgcGF5bG9hZCA9IFswLCB0aGlzLnB1YmtleSwgdGhpcy5jcmVhdGVkX2F0LCB0aGlzLmtpbmQsIHRoaXMudGFncywgdGhpcy5jb250ZW50XTtcbiAgaWYgKGluY2x1ZGVTaWcpIHBheWxvYWQucHVzaCh0aGlzLnNpZyk7XG4gIGlmIChpbmNsdWRlSWQpIHBheWxvYWQucHVzaCh0aGlzLmlkKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZEV2ZW50KSB7XG4gIGNvbnN0IGV2ZW50QXJyYXkgPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWRFdmVudCk7XG4gIGNvbnN0IHJldCA9IHtcbiAgICBwdWJrZXk6IGV2ZW50QXJyYXlbMV0sXG4gICAgY3JlYXRlZF9hdDogZXZlbnRBcnJheVsyXSxcbiAgICBraW5kOiBldmVudEFycmF5WzNdLFxuICAgIHRhZ3M6IGV2ZW50QXJyYXlbNF0sXG4gICAgY29udGVudDogZXZlbnRBcnJheVs1XVxuICB9O1xuICBpZiAoZXZlbnRBcnJheS5sZW5ndGggPj0gNykge1xuICAgIGNvbnN0IGZpcnN0ID0gZXZlbnRBcnJheVs2XTtcbiAgICBjb25zdCBzZWNvbmQgPSBldmVudEFycmF5WzddO1xuICAgIGlmIChmaXJzdCAmJiBmaXJzdC5sZW5ndGggPT09IDEyOCkge1xuICAgICAgcmV0LnNpZyA9IGZpcnN0O1xuICAgICAgaWYgKHNlY29uZCAmJiBzZWNvbmQubGVuZ3RoID09PSA2NCkge1xuICAgICAgICByZXQuaWQgPSBzZWNvbmQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaXJzdCAmJiBmaXJzdC5sZW5ndGggPT09IDY0KSB7XG4gICAgICByZXQuaWQgPSBmaXJzdDtcbiAgICAgIGlmIChzZWNvbmQgJiYgc2Vjb25kLmxlbmd0aCA9PT0gMTI4KSB7XG4gICAgICAgIHJldC5zaWcgPSBzZWNvbmQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIHNyYy9ldmVudHMvdmFsaWRhdGlvbi50c1xuaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5pbXBvcnQgeyBieXRlc1RvSGV4IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IExSVUNhY2hlIH0gZnJvbSBcInR5cGVzY3JpcHQtbHJ1LWNhY2hlXCI7XG5cbi8vIHNyYy9ldmVudHMvc2lnbmF0dXJlLnRzXG52YXIgd29ya2VyO1xudmFyIHByb2Nlc3NpbmdRdWV1ZSA9IHt9O1xuZnVuY3Rpb24gc2lnbmF0dXJlVmVyaWZpY2F0aW9uSW5pdCh3KSB7XG4gIHdvcmtlciA9IHc7XG4gIHdvcmtlci5vbm1lc3NhZ2UgPSAobXNnKSA9PiB7XG4gICAgY29uc3QgW2V2ZW50SWQsIHJlc3VsdF0gPSBtc2cuZGF0YTtcbiAgICBjb25zdCByZWNvcmQgPSBwcm9jZXNzaW5nUXVldWVbZXZlbnRJZF07XG4gICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyByZWNvcmQgZm91bmQgZm9yIGV2ZW50XCIsIGV2ZW50SWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgcHJvY2Vzc2luZ1F1ZXVlW2V2ZW50SWRdO1xuICAgIGZvciAoY29uc3QgcmVzb2x2ZSBvZiByZWNvcmQucmVzb2x2ZXMpIHtcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmVBc3luYyhldmVudCwgX3BlcnNpc3QpIHtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IGV2ZW50LnNlcmlhbGl6ZSgpO1xuICAgIGxldCBlbnF1ZXVlID0gZmFsc2U7XG4gICAgaWYgKCFwcm9jZXNzaW5nUXVldWVbZXZlbnQuaWRdKSB7XG4gICAgICBwcm9jZXNzaW5nUXVldWVbZXZlbnQuaWRdID0geyBldmVudCwgcmVzb2x2ZXM6IFtdIH07XG4gICAgICBlbnF1ZXVlID0gdHJ1ZTtcbiAgICB9XG4gICAgcHJvY2Vzc2luZ1F1ZXVlW2V2ZW50LmlkXS5yZXNvbHZlcy5wdXNoKHJlc29sdmUpO1xuICAgIGlmICghZW5xdWV1ZSkgcmV0dXJuO1xuICAgIHdvcmtlcj8ucG9zdE1lc3NhZ2Uoe1xuICAgICAgc2VyaWFsaXplZCxcbiAgICAgIGlkOiBldmVudC5pZCxcbiAgICAgIHNpZzogZXZlbnQuc2lnLFxuICAgICAgcHVia2V5OiBldmVudC5wdWJrZXlcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBzcmMvZXZlbnRzL3ZhbGlkYXRpb24udHNcbnZhciBQVUJLRVlfUkVHRVggPSAvXlthLWYwLTldezY0fSQvO1xuZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIGlmICh0eXBlb2YgdGhpcy5raW5kICE9PSBcIm51bWJlclwiKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgdGhpcy5jb250ZW50ICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgdGhpcy5jcmVhdGVkX2F0ICE9PSBcIm51bWJlclwiKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgdGhpcy5wdWJrZXkgIT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcbiAgaWYgKCF0aGlzLnB1YmtleS5tYXRjaChQVUJLRVlfUkVHRVgpKSByZXR1cm4gZmFsc2U7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLnRhZ3MpKSByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdzW2ldO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWcpKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YWcubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnW2pdID09PSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxudmFyIHZlcmlmaWVkU2lnbmF0dXJlcyA9IG5ldyBMUlVDYWNoZSh7XG4gIG1heFNpemU6IDFlMyxcbiAgZW50cnlFeHBpcmF0aW9uVGltZUluTVM6IDZlNFxufSk7XG5mdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmUocGVyc2lzdCkge1xuICBpZiAodHlwZW9mIHRoaXMuc2lnbmF0dXJlVmVyaWZpZWQgPT09IFwiYm9vbGVhblwiKSByZXR1cm4gdGhpcy5zaWduYXR1cmVWZXJpZmllZDtcbiAgY29uc3QgcHJldlZlcmlmaWNhdGlvbiA9IHZlcmlmaWVkU2lnbmF0dXJlcy5nZXQodGhpcy5pZCk7XG4gIGlmIChwcmV2VmVyaWZpY2F0aW9uICE9PSBudWxsKSB7XG4gICAgdGhpcy5zaWduYXR1cmVWZXJpZmllZCA9ICEhcHJldlZlcmlmaWNhdGlvbjtcbiAgICByZXR1cm4gdGhpcy5zaWduYXR1cmVWZXJpZmllZDtcbiAgfVxuICB0cnkge1xuICAgIGlmICh0aGlzLm5kaz8uYXN5bmNTaWdWZXJpZmljYXRpb24pIHtcbiAgICAgIHZlcmlmeVNpZ25hdHVyZUFzeW5jKHRoaXMsIHBlcnNpc3QpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICBpZiAocGVyc2lzdCkge1xuICAgICAgICAgIHRoaXMuc2lnbmF0dXJlVmVyaWZpZWQgPSByZXN1bHQ7XG4gICAgICAgICAgaWYgKHJlc3VsdCkgdmVyaWZpZWRTaWduYXR1cmVzLnNldCh0aGlzLmlkLCB0aGlzLnNpZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICB0aGlzLm5kaz8uZW1pdChcImV2ZW50OmludmFsaWQtc2lnXCIsIHRoaXMpO1xuICAgICAgICAgIHZlcmlmaWVkU2lnbmF0dXJlcy5zZXQodGhpcy5pZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGFzaCA9IHNoYTI1NihuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGhpcy5zZXJpYWxpemUoKSkpO1xuICAgICAgY29uc3QgcmVzID0gc2Nobm9yci52ZXJpZnkodGhpcy5zaWcsIGhhc2gsIHRoaXMucHVia2V5KTtcbiAgICAgIGlmIChyZXMpIHZlcmlmaWVkU2lnbmF0dXJlcy5zZXQodGhpcy5pZCwgdGhpcy5zaWcpO1xuICAgICAgZWxzZSB2ZXJpZmllZFNpZ25hdHVyZXMuc2V0KHRoaXMuaWQsIGZhbHNlKTtcbiAgICAgIHRoaXMuc2lnbmF0dXJlVmVyaWZpZWQgPSByZXM7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfSBjYXRjaCAoX2Vycikge1xuICAgIHRoaXMuc2lnbmF0dXJlVmVyaWZpZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEV2ZW50SGFzaCgpIHtcbiAgcmV0dXJuIGdldEV2ZW50SGFzaEZyb21TZXJpYWxpemVkRXZlbnQodGhpcy5zZXJpYWxpemUoKSk7XG59XG5mdW5jdGlvbiBnZXRFdmVudEhhc2hGcm9tU2VyaWFsaXplZEV2ZW50KHNlcmlhbGl6ZWRFdmVudCkge1xuICBjb25zdCBldmVudEhhc2ggPSBzaGEyNTYobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlcmlhbGl6ZWRFdmVudCkpO1xuICByZXR1cm4gYnl0ZXNUb0hleChldmVudEhhc2gpO1xufVxuXG4vLyBzcmMvZXZlbnRzL2luZGV4LnRzXG52YXIgc2tpcENsaWVudFRhZ09uS2luZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIDAgLyogTWV0YWRhdGEgKi8sXG4gIDQgLyogRW5jcnlwdGVkRGlyZWN0TWVzc2FnZSAqLyxcbiAgMTA1OSAvKiBHaWZ0V3JhcCAqLyxcbiAgMTMgLyogR2lmdFdyYXBTZWFsICovLFxuICAzIC8qIENvbnRhY3RzICovLFxuICA5NzM0IC8qIFphcFJlcXVlc3QgKi8sXG4gIDUgLyogRXZlbnREZWxldGlvbiAqL1xuXSk7XG52YXIgTkRLRXZlbnQgPSBjbGFzcyBfTkRLRXZlbnQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIyIHtcbiAgbmRrO1xuICBjcmVhdGVkX2F0O1xuICBjb250ZW50ID0gXCJcIjtcbiAgdGFncyA9IFtdO1xuICBraW5kO1xuICBpZCA9IFwiXCI7XG4gIHNpZztcbiAgcHVia2V5ID0gXCJcIjtcbiAgc2lnbmF0dXJlVmVyaWZpZWQ7XG4gIF9hdXRob3IgPSB2b2lkIDA7XG4gIC8qKlxuICAgKiBUaGUgcmVsYXkgdGhhdCB0aGlzIGV2ZW50IHdhcyBmaXJzdCByZWNlaXZlZCBmcm9tLlxuICAgKi9cbiAgcmVsYXk7XG4gIC8qKlxuICAgKiBUaGUgcmVsYXlzIHRoYXQgdGhpcyBldmVudCB3YXMgcmVjZWl2ZWQgZnJvbSBhbmQvb3Igc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZCB0by5cbiAgICovXG4gIGdldCBvblJlbGF5cygpIHtcbiAgICBsZXQgcmVzID0gW107XG4gICAgaWYgKCF0aGlzLm5kaykge1xuICAgICAgaWYgKHRoaXMucmVsYXkpIHJlcy5wdXNoKHRoaXMucmVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB0aGlzLm5kay5zdWJNYW5hZ2VyLnNlZW5FdmVudHMuZ2V0KHRoaXMuaWQpIHx8IFtdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc3RhdHVzIG9mIHRoZSBwdWJsaXNoIG9wZXJhdGlvbi5cbiAgICovXG4gIHB1Ymxpc2hTdGF0dXMgPSBcInN1Y2Nlc3NcIjtcbiAgcHVibGlzaEVycm9yO1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLmNyZWF0ZWRfYXQgPSBldmVudD8uY3JlYXRlZF9hdDtcbiAgICB0aGlzLmNvbnRlbnQgPSBldmVudD8uY29udGVudCB8fCBcIlwiO1xuICAgIHRoaXMudGFncyA9IGV2ZW50Py50YWdzIHx8IFtdO1xuICAgIHRoaXMuaWQgPSBldmVudD8uaWQgfHwgXCJcIjtcbiAgICB0aGlzLnNpZyA9IGV2ZW50Py5zaWc7XG4gICAgdGhpcy5wdWJrZXkgPSBldmVudD8ucHVia2V5IHx8IFwiXCI7XG4gICAgdGhpcy5raW5kID0gZXZlbnQ/LmtpbmQ7XG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgX05ES0V2ZW50KSB7XG4gICAgICBpZiAodGhpcy5yZWxheSkge1xuICAgICAgICB0aGlzLnJlbGF5ID0gZXZlbnQucmVsYXk7XG4gICAgICAgIHRoaXMubmRrPy5zdWJNYW5hZ2VyLnNlZW5FdmVudChldmVudC5pZCwgdGhpcy5yZWxheSk7XG4gICAgICB9XG4gICAgICB0aGlzLnB1Ymxpc2hTdGF0dXMgPSBldmVudC5wdWJsaXNoU3RhdHVzO1xuICAgICAgdGhpcy5wdWJsaXNoRXJyb3IgPSBldmVudC5wdWJsaXNoRXJyb3I7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBhbiBOREtFdmVudCBmcm9tIGEgc2VyaWFsaXplZCBwYXlsb2FkLlxuICAgKiBAcGFyYW0gbmRrXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RhdGljIGRlc2VyaWFsaXplKG5kaywgZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtFdmVudChuZGssIGRlc2VyaWFsaXplKGV2ZW50KSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGV2ZW50IGFzIGlzLlxuICAgKi9cbiAgcmF3RXZlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZWRfYXQ6IHRoaXMuY3JlYXRlZF9hdCxcbiAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudCxcbiAgICAgIHRhZ3M6IHRoaXMudGFncyxcbiAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgIHB1YmtleTogdGhpcy5wdWJrZXksXG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIHNpZzogdGhpcy5zaWdcbiAgICB9O1xuICB9XG4gIHNldCBhdXRob3IodXNlcikge1xuICAgIHRoaXMucHVia2V5ID0gdXNlci5wdWJrZXk7XG4gICAgdGhpcy5fYXV0aG9yID0gdXNlcjtcbiAgICB0aGlzLl9hdXRob3IubmRrID8/PSB0aGlzLm5kaztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBOREtVc2VyIGZvciB0aGUgYXV0aG9yIG9mIHRoZSBldmVudC5cbiAgICovXG4gIGdldCBhdXRob3IoKSB7XG4gICAgaWYgKHRoaXMuX2F1dGhvcikgcmV0dXJuIHRoaXMuX2F1dGhvcjtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgY29uc3QgdXNlciA9IHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXk6IHRoaXMucHVia2V5IH0pO1xuICAgIHRoaXMuX2F1dGhvciA9IHVzZXI7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgLyoqXG4gICAqIE5JUC03MyB0YWdnaW5nIG9mIGV4dGVybmFsIGVudGl0aWVzXG4gICAqIEBwYXJhbSBlbnRpdHkgdG8gYmUgdGFnZ2VkXG4gICAqIEBwYXJhbSB0eXBlIG9mIHRoZSBlbnRpdHlcbiAgICogQHBhcmFtIG1hcmtlclVybCB0byBiZSB1c2VkIGFzIHRoZSBtYXJrZXIgVVJMXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogZXZlbnQudGFnRXh0ZXJuYWwoXCJodHRwczovL2V4YW1wbGUuY29tL2FydGljbGUvMTIzI25vc3RyXCIsIFwidXJsXCIpO1xuICAgKiBldmVudC50YWdzID0+IFtbXCJpXCIsIFwiaHR0cHM6Ly9leGFtcGxlLmNvbS8xMjNcIl0sIFtcImtcIiwgXCJodHRwczovL2V4YW1wbGUuY29tXCJdXVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGUgdGFnIGEgcG9kY2FzdDppdGVtOmd1aWRcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBldmVudC50YWdFeHRlcm5hbChcImUzMmI0ODkwLWI5ZWEtNGFlZi1hMGJmLTU0Yjc4NzgzM2RjNVwiLCBcInBvZGNhc3Q6aXRlbTpndWlkXCIpO1xuICAgKiBldmVudC50YWdzID0+IFtbXCJpXCIsIFwicG9kY2FzdDppdGVtOmd1aWQ6ZTMyYjQ4OTAtYjllYS00YWVmLWEwYmYtNTRiNzg3ODMzZGM1XCJdLCBbXCJrXCIsIFwicG9kY2FzdDppdGVtOmd1aWRcIl1dXG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzczLm1kXG4gICAqL1xuICB0YWdFeHRlcm5hbChlbnRpdHksIHR5cGUsIG1hcmtlclVybCkge1xuICAgIGNvbnN0IGlUYWcgPSBbXCJpXCJdO1xuICAgIGNvbnN0IGtUYWcgPSBbXCJrXCJdO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcInVybFwiOiB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoZW50aXR5KTtcbiAgICAgICAgdXJsLmhhc2ggPSBcIlwiO1xuICAgICAgICBpVGFnLnB1c2godXJsLnRvU3RyaW5nKCkpO1xuICAgICAgICBrVGFnLnB1c2goYCR7dXJsLnByb3RvY29sfS8vJHt1cmwuaG9zdH1gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiaGFzaHRhZ1wiOlxuICAgICAgICBpVGFnLnB1c2goYCMke2VudGl0eS50b0xvd2VyQ2FzZSgpfWApO1xuICAgICAgICBrVGFnLnB1c2goXCIjXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJnZW9oYXNoXCI6XG4gICAgICAgIGlUYWcucHVzaChgZ2VvOiR7ZW50aXR5LnRvTG93ZXJDYXNlKCl9YCk7XG4gICAgICAgIGtUYWcucHVzaChcImdlb1wiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaXNiblwiOlxuICAgICAgICBpVGFnLnB1c2goYGlzYm46JHtlbnRpdHkucmVwbGFjZSgvLS9nLCBcIlwiKX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwiaXNiblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicG9kY2FzdDpndWlkXCI6XG4gICAgICAgIGlUYWcucHVzaChgcG9kY2FzdDpndWlkOiR7ZW50aXR5fWApO1xuICAgICAgICBrVGFnLnB1c2goXCJwb2RjYXN0Omd1aWRcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvZGNhc3Q6aXRlbTpndWlkXCI6XG4gICAgICAgIGlUYWcucHVzaChgcG9kY2FzdDppdGVtOmd1aWQ6JHtlbnRpdHl9YCk7XG4gICAgICAgIGtUYWcucHVzaChcInBvZGNhc3Q6aXRlbTpndWlkXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb2RjYXN0OnB1Ymxpc2hlcjpndWlkXCI6XG4gICAgICAgIGlUYWcucHVzaChgcG9kY2FzdDpwdWJsaXNoZXI6Z3VpZDoke2VudGl0eX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwicG9kY2FzdDpwdWJsaXNoZXI6Z3VpZFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaXNhblwiOlxuICAgICAgICBpVGFnLnB1c2goYGlzYW46JHtlbnRpdHkuc3BsaXQoXCItXCIpLnNsaWNlKDAsIDQpLmpvaW4oXCItXCIpfWApO1xuICAgICAgICBrVGFnLnB1c2goXCJpc2FuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkb2lcIjpcbiAgICAgICAgaVRhZy5wdXNoKGBkb2k6JHtlbnRpdHkudG9Mb3dlckNhc2UoKX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwiZG9pXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgTklQLTczIGVudGl0eSB0eXBlOiAke3R5cGV9YCk7XG4gICAgfVxuICAgIGlmIChtYXJrZXJVcmwpIHtcbiAgICAgIGlUYWcucHVzaChtYXJrZXJVcmwpO1xuICAgIH1cbiAgICB0aGlzLnRhZ3MucHVzaChpVGFnKTtcbiAgICB0aGlzLnRhZ3MucHVzaChrVGFnKTtcbiAgfVxuICAvKipcbiAgICogVGFnIGEgdXNlciB3aXRoIGFuIG9wdGlvbmFsIG1hcmtlci5cbiAgICogQHBhcmFtIHRhcmdldCBXaGF0IGlzIHRvIGJlIHRhZ2dlZC4gQ2FuIGJlIGFuIE5ES1VzZXIsIE5ES0V2ZW50LCBvciBhbiBOREtUYWcuXG4gICAqIEBwYXJhbSBtYXJrZXIgVGhlIG1hcmtlciB0byB1c2UgaW4gdGhlIHRhZy5cbiAgICogQHBhcmFtIHNraXBBdXRob3JUYWcgV2hldGhlciB0byBleHBsaWNpdGx5IHNraXAgYWRkaW5nIHRoZSBhdXRob3IgdGFnIG9mIHRoZSBldmVudC5cbiAgICogQHBhcmFtIGZvcmNlVGFnIEZvcmNlIGEgc3BlY2lmaWMgdGFnIHRvIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBcImVcIiBvciBcImFcIiB0YWcuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogcmVwbHkudGFnKG9wRXZlbnQsIFwicmVwbHlcIik7XG4gICAqIC8vIHJlcGx5LnRhZ3MgPT4gW1tcImVcIiwgPGlkPiwgPHJlbGF5PiwgXCJyZXBseVwiXV1cbiAgICogYGBgXG4gICAqL1xuICB0YWcodGFyZ2V0LCBtYXJrZXIsIHNraXBBdXRob3JUYWcsIGZvcmNlVGFnKSB7XG4gICAgbGV0IHRhZ3MgPSBbXTtcbiAgICBjb25zdCBpc05ES1VzZXIgPSB0YXJnZXQuZmV0Y2hQcm9maWxlICE9PSB2b2lkIDA7XG4gICAgaWYgKGlzTkRLVXNlcikge1xuICAgICAgZm9yY2VUYWcgPz89IFwicFwiO1xuICAgICAgY29uc3QgdGFnID0gW2ZvcmNlVGFnLCB0YXJnZXQucHVia2V5XTtcbiAgICAgIGlmIChtYXJrZXIpIHRhZy5wdXNoKC4uLltcIlwiLCBtYXJrZXJdKTtcbiAgICAgIHRhZ3MucHVzaCh0YWcpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgX05ES0V2ZW50KSB7XG4gICAgICBjb25zdCBldmVudCA9IHRhcmdldDtcbiAgICAgIHNraXBBdXRob3JUYWcgPz89IGV2ZW50Py5wdWJrZXkgPT09IHRoaXMucHVia2V5O1xuICAgICAgdGFncyA9IGV2ZW50LnJlZmVyZW5jZVRhZ3MobWFya2VyLCBza2lwQXV0aG9yVGFnLCBmb3JjZVRhZyk7XG4gICAgICBmb3IgKGNvbnN0IHBUYWcgb2YgZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKSkge1xuICAgICAgICBpZiAocFRhZ1sxXSA9PT0gdGhpcy5wdWJrZXkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAodGhpcy50YWdzLmZpbmQoKHQpID0+IHRbMF0gPT09IFwicFwiICYmIHRbMV0gPT09IHBUYWdbMV0pKSBjb250aW51ZTtcbiAgICAgICAgdGhpcy50YWdzLnB1c2goW1wicFwiLCBwVGFnWzFdXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgIHRhZ3MgPSBbdGFyZ2V0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiLCB0YXJnZXQpO1xuICAgIH1cbiAgICB0aGlzLnRhZ3MgPSBtZXJnZVRhZ3ModGhpcy50YWdzLCB0YWdzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgTm9zdHJFdmVudCBvYmplY3QsIHRyeWluZyB0byBmaWxsIGluIG1pc3NpbmcgZmllbGRzXG4gICAqIHdoZW4gcG9zc2libGUsIGFkZGluZyB0YWdzIHdoZW4gbmVjZXNzYXJ5LlxuICAgKiBAcGFyYW0gcHVia2V5IHtzdHJpbmd9IFRoZSBwdWJrZXkgb2YgdGhlIHVzZXIgd2hvIHRoZSBldmVudCBiZWxvbmdzIHRvLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOb3N0ckV2ZW50Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBOb3N0ckV2ZW50LlxuICAgKi9cbiAgYXN5bmMgdG9Ob3N0ckV2ZW50KHB1YmtleSkge1xuICAgIGlmICghcHVia2V5ICYmIHRoaXMucHVia2V5ID09PSBcIlwiKSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGs/LnNpZ25lcj8udXNlcigpO1xuICAgICAgdGhpcy5wdWJrZXkgPSB1c2VyPy5wdWJrZXkgfHwgXCJcIjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNyZWF0ZWRfYXQpIHtcbiAgICAgIHRoaXMuY3JlYXRlZF9hdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGVudCwgdGFncyB9ID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVRhZ3MoKTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50IHx8IFwiXCI7XG4gICAgdGhpcy50YWdzID0gdGFncztcbiAgICB0cnkge1xuICAgICAgdGhpcy5pZCA9IHRoaXMuZ2V0RXZlbnRIYXNoKCk7XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmF3RXZlbnQoKTtcbiAgfVxuICBzZXJpYWxpemUgPSBzZXJpYWxpemUuYmluZCh0aGlzKTtcbiAgZ2V0RXZlbnRIYXNoID0gZ2V0RXZlbnRIYXNoLmJpbmQodGhpcyk7XG4gIHZhbGlkYXRlID0gdmFsaWRhdGUuYmluZCh0aGlzKTtcbiAgdmVyaWZ5U2lnbmF0dXJlID0gdmVyaWZ5U2lnbmF0dXJlLmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBJcyB0aGlzIGV2ZW50IHJlcGxhY2VhYmxlICh3aGV0aGVyIHBhcmFtZXRlcml6ZWQgb3Igbm90KT9cbiAgICpcbiAgICogVGhpcyB3aWxsIHJldHVybiB0cnVlIGZvciBraW5kIDAsIDMsIDEway0yMGsgYW5kIDMway00MGtcbiAgICovXG4gIGlzUmVwbGFjZWFibGUgPSBpc1JlcGxhY2VhYmxlLmJpbmQodGhpcyk7XG4gIGlzRXBoZW1lcmFsID0gaXNFcGhlbWVyYWwuYmluZCh0aGlzKTtcbiAgaXNEdm0gPSAoKSA9PiB0aGlzLmtpbmQgJiYgdGhpcy5raW5kID49IDVlMyAmJiB0aGlzLmtpbmQgPD0gN2UzO1xuICAvKipcbiAgICogSXMgdGhpcyBldmVudCBwYXJhbWV0ZXJpemVkIHJlcGxhY2VhYmxlP1xuICAgKlxuICAgKiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgZm9yIGtpbmQgMzBrLTQwa1xuICAgKi9cbiAgaXNQYXJhbVJlcGxhY2VhYmxlID0gaXNQYXJhbVJlcGxhY2VhYmxlLmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBFbmNvZGVzIGEgYmVjaDMyIGlkLlxuICAgKlxuICAgKiBAcGFyYW0gcmVsYXlzIHtzdHJpbmdbXX0gVGhlIHJlbGF5cyB0byBlbmNvZGUgaW4gdGhlIGlkXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gRW5jb2RlZCBuYWRkciwgbm90ZSBvciBuZXZlbnQuXG4gICAqL1xuICBlbmNvZGUgPSBlbmNvZGUuYmluZCh0aGlzKTtcbiAgZW5jcnlwdCA9IGVuY3J5cHQuYmluZCh0aGlzKTtcbiAgZGVjcnlwdCA9IGRlY3J5cHQuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIEdldCBhbGwgdGFncyB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqIEBwYXJhbSB0YWdOYW1lIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSB0YWcgdG8gc2VhcmNoIGZvclxuICAgKiBAcmV0dXJucyB7TkRLVGFnW119IEFuIGFycmF5IG9mIHRoZSBtYXRjaGluZyB0YWdzXG4gICAqL1xuICBnZXRNYXRjaGluZ1RhZ3ModGFnTmFtZSwgbWFya2VyKSB7XG4gICAgY29uc3QgdCA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdID09PSB0YWdOYW1lKTtcbiAgICBpZiAobWFya2VyID09PSB2b2lkIDApIHJldHVybiB0O1xuICAgIHJldHVybiB0LmZpbHRlcigodGFnKSA9PiB0YWdbM10gPT09IG1hcmtlcik7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBldmVudCBoYXMgYSB0YWcgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKiBAcGFyYW0gdGFnTmFtZVxuICAgKiBAcGFyYW0gbWFya2VyXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBoYXNUYWcodGFnTmFtZSwgbWFya2VyKSB7XG4gICAgcmV0dXJuIHRoaXMudGFncy5zb21lKCh0YWcpID0+IHRhZ1swXSA9PT0gdGFnTmFtZSAmJiAoIW1hcmtlciB8fCB0YWdbM10gPT09IG1hcmtlcikpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpcnN0IHRhZyB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqIEBwYXJhbSB0YWdOYW1lIFRhZyBuYW1lIHRvIHNlYXJjaCBmb3JcbiAgICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCB0YWcgd2l0aCB0aGUgZ2l2ZW4gbmFtZSwgb3IgdW5kZWZpbmVkIGlmIG5vIHN1Y2ggdGFnIGV4aXN0c1xuICAgKi9cbiAgdGFnVmFsdWUodGFnTmFtZSwgbWFya2VyKSB7XG4gICAgY29uc3QgdGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKHRhZ05hbWUsIG1hcmtlcik7XG4gICAgaWYgKHRhZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiB0YWdzWzBdWzFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBOSVAtMzEgXCJhbHRcIiB0YWcgb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgZ2V0IGFsdCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImFsdFwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgTklQLTMxIFwiYWx0XCIgdGFnIG9mIHRoZSBldmVudC4gVXNlIHRoaXMgdG8gc2V0IGFuIGFsdCB0YWcgc29cbiAgICogY2xpZW50cyB0aGF0IGRvbid0IGhhbmRsZSBhIHBhcnRpY3VsYXIgZXZlbnQga2luZCBjYW4gZGlzcGxheSBzb21ldGhpbmdcbiAgICogdXNlZnVsIGZvciB1c2Vycy5cbiAgICovXG4gIHNldCBhbHQoYWx0KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhbHRcIik7XG4gICAgaWYgKGFsdCkgdGhpcy50YWdzLnB1c2goW1wiYWx0XCIsIGFsdF0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBOSVAtMzMgXCJkXCIgdGFnIG9mIHRoZSBldmVudC5cbiAgICovXG4gIGdldCBkVGFnKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZFwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgTklQLTMzIFwiZFwiIHRhZyBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBzZXQgZFRhZyh2YWx1ZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZFwiKTtcbiAgICBpZiAodmFsdWUpIHRoaXMudGFncy5wdXNoKFtcImRcIiwgdmFsdWVdKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGFsbCB0YWdzIHdpdGggdGhlIGdpdmVuIG5hbWUgKGUuZy4gXCJkXCIsIFwiYVwiLCBcInBcIilcbiAgICogQHBhcmFtIHRhZ05hbWUgVGFnIG5hbWUocykgdG8gc2VhcmNoIGZvciBhbmQgcmVtb3ZlXG4gICAqIEBwYXJhbSBtYXJrZXIgT3B0aW9uYWwgbWFya2VyIHRvIGNoZWNrIGZvciB0b29cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogUmVtb3ZlIGEgdGFncyB3aXRoIGEgXCJkZWZlclwiIG1hcmtlclxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGV2ZW50LnRhZ3MgPSBbXG4gICAqICAgW1wiYVwiLCBcIi4uLi5cIiwgXCJkZWZlclwiXSxcbiAgICogICBbXCJhXCIsIFwiLi4uLlwiLCBcIm5vLWRlZmVyXCJdLFxuICAgKiBdXG4gICAqXG4gICAqIGV2ZW50LnJlbW92ZVRhZyhcImFcIiwgXCJkZWZlclwiKTtcbiAgICpcbiAgICogLy8gZXZlbnQudGFncyA9PiBbW1wiYVwiLCBcIi4uLi5cIiwgXCJuby1kZWZlclwiXV1cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICByZW1vdmVUYWcodGFnTmFtZSwgbWFya2VyKSB7XG4gICAgY29uc3QgdGFnTmFtZXMgPSBBcnJheS5pc0FycmF5KHRhZ05hbWUpID8gdGFnTmFtZSA6IFt0YWdOYW1lXTtcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHtcbiAgICAgIGNvbnN0IGluY2x1ZGUgPSB0YWdOYW1lcy5pbmNsdWRlcyh0YWdbMF0pO1xuICAgICAgY29uc3QgaGFzTWFya2VyID0gbWFya2VyID8gdGFnWzNdID09PSBtYXJrZXIgOiB0cnVlO1xuICAgICAgcmV0dXJuICEoaW5jbHVkZSAmJiBoYXNNYXJrZXIpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlIGEgdGFnIHdpdGggYSBuZXcgdmFsdWUuIElmIG5vdCBmb3VuZCwgaXQgd2lsbCBiZSBhZGRlZC5cbiAgICogQHBhcmFtIHRhZyBUaGUgdGFnIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgbmV3IHZhbHVlIGZvciB0aGUgdGFnLlxuICAgKi9cbiAgcmVwbGFjZVRhZyh0YWcpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyh0YWdbMF0pO1xuICAgIHRoaXMudGFncy5wdXNoKHRhZyk7XG4gIH1cbiAgLyoqXG4gICAqIFNpZ24gdGhlIGV2ZW50IGlmIGEgc2lnbmVyIGlzIHByZXNlbnQuXG4gICAqXG4gICAqIEl0IHdpbGwgZ2VuZXJhdGUgdGFncy5cbiAgICogUmVwbGVhY2FibGUgZXZlbnRzIHdpbGwgaGF2ZSB0aGVpciBjcmVhdGVkX2F0IGZpZWxkIHNldCB0byB0aGUgY3VycmVudCB0aW1lLlxuICAgKiBAcGFyYW0gc2lnbmVyIHtOREtTaWduZXJ9IFRoZSBOREtTaWduZXIgdG8gdXNlIHRvIHNpZ24gdGhlIGV2ZW50XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzaWduYXR1cmUgb2YgdGhlIHNpZ25lZCBldmVudC5cbiAgICovXG4gIGFzeW5jIHNpZ24oc2lnbmVyKSB7XG4gICAgaWYgKCFzaWduZXIpIHtcbiAgICAgIHRoaXMubmRrPy5hc3NlcnRTaWduZXIoKTtcbiAgICAgIHNpZ25lciA9IHRoaXMubmRrPy5zaWduZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXV0aG9yID0gYXdhaXQgc2lnbmVyLnVzZXIoKTtcbiAgICB9XG4gICAgY29uc3Qgbm9zdHJFdmVudCA9IGF3YWl0IHRoaXMudG9Ob3N0ckV2ZW50KCk7XG4gICAgdGhpcy5zaWcgPSBhd2FpdCBzaWduZXIuc2lnbihub3N0ckV2ZW50KTtcbiAgICByZXR1cm4gdGhpcy5zaWc7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSByZWxheVNldFxuICAgKiBAcGFyYW0gdGltZW91dE1zXG4gICAqIEBwYXJhbSByZXF1aXJlZFJlbGF5Q291bnRcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIHB1Ymxpc2hSZXBsYWNlYWJsZShyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpIHtcbiAgICB0aGlzLmlkID0gXCJcIjtcbiAgICB0aGlzLmNyZWF0ZWRfYXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpO1xuICAgIHRoaXMuc2lnID0gXCJcIjtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gc2lnbiBhbmQgdGhlbiBwdWJsaXNoIGFuIE5ES0V2ZW50IHRvIGEgZ2l2ZW4gcmVsYXlTZXQuXG4gICAqIElmIG5vIHJlbGF5U2V0IGlzIHByb3ZpZGVkLCB0aGUgcmVsYXlTZXQgd2lsbCBiZSBjYWxjdWxhdGVkIGJ5IE5ESy5cbiAgICogQHBhcmFtIHJlbGF5U2V0IHtOREtSZWxheVNldH0gVGhlIHJlbGF5U2V0IHRvIHB1Ymxpc2ggdGhlIGV2ZW4gdG8uXG4gICAqIEBwYXJhbSB0aW1lb3V0TSB7bnVtYmVyfSBUaGUgdGltZW91dCBmb3IgdGhlIHB1Ymxpc2ggb3BlcmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICogQHBhcmFtIHJlcXVpcmVkUmVsYXlDb3VudCBUaGUgbnVtYmVyIG9mIHJlbGF5cyB0aGF0IG11c3QgcmVjZWl2ZSB0aGUgZXZlbnQgZm9yIHRoZSBwdWJsaXNoIHRvIGJlIGNvbnNpZGVyZWQgc3VjY2Vzc2Z1bC5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlbGF5cyB0aGUgZXZlbnQgd2FzIHB1Ymxpc2hlZCB0by5cbiAgICovXG4gIGFzeW5jIHB1Ymxpc2gocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KSB7XG4gICAgaWYgKCF0aGlzLnNpZykgYXdhaXQgdGhpcy5zaWduKCk7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLRXZlbnQgbXVzdCBiZSBhc3NvY2lhdGVkIHdpdGggYW4gTkRLIGluc3RhbmNlIHRvIHB1Ymxpc2hcIik7XG4gICAgaWYgKCFyZWxheVNldCB8fCByZWxheVNldC5zaXplID09PSAwKSB7XG4gICAgICByZWxheVNldCA9IHRoaXMubmRrLmRldldyaXRlUmVsYXlTZXQgfHwgYXdhaXQgY2FsY3VsYXRlUmVsYXlTZXRGcm9tRXZlbnQodGhpcy5uZGssIHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSA1IC8qIEV2ZW50RGVsZXRpb24gKi8gJiYgdGhpcy5uZGsuY2FjaGVBZGFwdGVyPy5kZWxldGVFdmVudElkcykge1xuICAgICAgY29uc3QgZVRhZ3MgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gICAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZGVsZXRlRXZlbnRJZHMoZVRhZ3MpO1xuICAgIH1cbiAgICBjb25zdCByYXdFdmVudCA9IHRoaXMucmF3RXZlbnQoKTtcbiAgICBpZiAodGhpcy5uZGsuY2FjaGVBZGFwdGVyPy5hZGRVbnB1Ymxpc2hlZEV2ZW50ICYmIHNob3VsZFRyYWNrVW5wdWJsaXNoZWRFdmVudCh0aGlzKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmFkZFVucHVibGlzaGVkRXZlbnQodGhpcywgcmVsYXlTZXQucmVsYXlVcmxzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFkZGluZyB1bnB1Ymxpc2hlZCBldmVudCB0byBjYWNoZVwiLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gNSAvKiBFdmVudERlbGV0aW9uICovICYmIHRoaXMubmRrLmNhY2hlQWRhcHRlcj8uZGVsZXRlRXZlbnRJZHMpIHtcbiAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5kZWxldGVFdmVudElkcyh0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSkpO1xuICAgIH1cbiAgICB0aGlzLm5kay5zdWJNYW5hZ2VyLmRpc3BhdGNoRXZlbnQocmF3RXZlbnQsIHZvaWQgMCwgdHJ1ZSk7XG4gICAgY29uc3QgcmVsYXlzID0gYXdhaXQgcmVsYXlTZXQucHVibGlzaCh0aGlzLCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gICAgcmVsYXlzLmZvckVhY2goKHJlbGF5KSA9PiB0aGlzLm5kaz8uc3ViTWFuYWdlci5zZWVuRXZlbnQodGhpcy5pZCwgcmVsYXkpKTtcbiAgICByZXR1cm4gcmVsYXlzO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGFncyBmb3IgdXNlcnMsIG5vdGVzLCBhbmQgb3RoZXIgZXZlbnRzIHRhZ2dlZCBpbiBjb250ZW50LlxuICAgKiBXaWxsIGFsc28gZ2VuZXJhdGUgcmFuZG9tIFwiZFwiIHRhZyBmb3IgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZSBldmVudHMgd2hlcmUgbmVlZGVkLlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gVGhlIHRhZ3MgYW5kIGNvbnRlbnQgb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVUYWdzKCkge1xuICAgIGxldCB0YWdzID0gW107XG4gICAgY29uc3QgZyA9IGF3YWl0IGdlbmVyYXRlQ29udGVudFRhZ3ModGhpcy5jb250ZW50LCB0aGlzLnRhZ3MpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBnLmNvbnRlbnQ7XG4gICAgdGFncyA9IGcudGFncztcbiAgICBpZiAodGhpcy5raW5kICYmIHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIGNvbnN0IGRUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImRcIilbMF07XG4gICAgICBpZiAoIWRUYWcpIHtcbiAgICAgICAgY29uc3QgdGl0bGUgPSB0aGlzLnRhZ1ZhbHVlKFwidGl0bGVcIik7XG4gICAgICAgIGNvbnN0IHJhbmRMZW5ndGggPSB0aXRsZSA/IDYgOiAxNjtcbiAgICAgICAgbGV0IHN0ciA9IFsuLi5BcnJheShyYW5kTGVuZ3RoKV0ubWFwKCgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpWzJdKS5qb2luKFwiXCIpO1xuICAgICAgICBpZiAodGl0bGUgJiYgdGl0bGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0ciA9IGAke3RpdGxlLnJlcGxhY2UoL1teYS16MC05XSsvZ2ksIFwiLVwiKS5yZXBsYWNlKC9eLXwtJC9nLCBcIlwiKX0tJHtzdHJ9YDtcbiAgICAgICAgfVxuICAgICAgICB0YWdzLnB1c2goW1wiZFwiLCBzdHJdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc2hvdWxkQWRkQ2xpZW50VGFnKSB7XG4gICAgICBjb25zdCBjbGllbnRUYWcgPSBbXCJjbGllbnRcIiwgdGhpcy5uZGs/LmNsaWVudE5hbWUgPz8gXCJcIl07XG4gICAgICBpZiAodGhpcy5uZGs/LmNsaWVudE5pcDg5KSBjbGllbnRUYWcucHVzaCh0aGlzLm5kaz8uY2xpZW50TmlwODkpO1xuICAgICAgdGFncy5wdXNoKGNsaWVudFRhZyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNob3VsZFN0cmlwQ2xpZW50VGFnKSB7XG4gICAgICB0YWdzID0gdGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcImNsaWVudFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29udGVudDogY29udGVudCB8fCBcIlwiLCB0YWdzIH07XG4gIH1cbiAgZ2V0IHNob3VsZEFkZENsaWVudFRhZygpIHtcbiAgICBpZiAoIXRoaXMubmRrPy5jbGllbnROYW1lICYmICF0aGlzLm5kaz8uY2xpZW50TmlwODkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoc2tpcENsaWVudFRhZ09uS2luZHMuaGFzKHRoaXMua2luZCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy5pc0VwaGVtZXJhbCgpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuaXNSZXBsYWNlYWJsZSgpICYmICF0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuaXNEdm0oKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aGlzLmhhc1RhZyhcImNsaWVudFwiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCBzaG91bGRTdHJpcENsaWVudFRhZygpIHtcbiAgICByZXR1cm4gc2tpcENsaWVudFRhZ09uS2luZHMuaGFzKHRoaXMua2luZCk7XG4gIH1cbiAgbXV0ZWQoKSB7XG4gICAgY29uc3QgYXV0aG9yTXV0ZWRFbnRyeSA9IHRoaXMubmRrPy5tdXRlZElkcy5nZXQodGhpcy5wdWJrZXkpO1xuICAgIGlmIChhdXRob3JNdXRlZEVudHJ5ICYmIGF1dGhvck11dGVkRW50cnkgPT09IFwicFwiKSByZXR1cm4gXCJhdXRob3JcIjtcbiAgICBjb25zdCBldmVudFRhZ1JlZmVyZW5jZSA9IHRoaXMudGFnUmVmZXJlbmNlKCk7XG4gICAgY29uc3QgZXZlbnRNdXRlZEVudHJ5ID0gdGhpcy5uZGs/Lm11dGVkSWRzLmdldChldmVudFRhZ1JlZmVyZW5jZVsxXSk7XG4gICAgaWYgKGV2ZW50TXV0ZWRFbnRyeSAmJiBldmVudE11dGVkRW50cnkgPT09IGV2ZW50VGFnUmVmZXJlbmNlWzBdKSByZXR1cm4gXCJldmVudFwiO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBcImRcIiB0YWcgb2YgYSBwYXJhbWV0ZXJpemVkIHJlcGxhY2VhYmxlIGV2ZW50IG9yIHRocm93cyBhbiBlcnJvciBpZiB0aGUgZXZlbnQgaXNuJ3RcbiAgICogYSBwYXJhbWV0ZXJpemVkIHJlcGxhY2VhYmxlIGV2ZW50LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgXCJkXCIgdGFnIG9mIHRoZSBldmVudC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBkVGFnYCBpbnN0ZWFkLlxuICAgKi9cbiAgcmVwbGFjZWFibGVEVGFnKCkge1xuICAgIGlmICh0aGlzLmtpbmQgJiYgdGhpcy5raW5kID49IDNlNCAmJiB0aGlzLmtpbmQgPD0gNGU0KSB7XG4gICAgICBjb25zdCBkVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJkXCIpWzBdO1xuICAgICAgY29uc3QgZFRhZ0lkID0gZFRhZyA/IGRUYWdbMV0gOiBcIlwiO1xuICAgICAgcmV0dXJuIGRUYWdJZDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgaXMgbm90IGEgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZSBldmVudFwiKTtcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgYSBkZWR1cGxpY2F0aW9uIGtleSBmb3IgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBGb3Iga2luZHMgMCwgMywgMTBrLTIwayB0aGlzIHdpbGwgYmUgdGhlIGV2ZW50IDxraW5kPjo8cHVia2V5PlxuICAgKiBGb3Iga2luZHMgMzBrLTQwayB0aGlzIHdpbGwgYmUgdGhlIGV2ZW50IDxraW5kPjo8cHVia2V5Pjo8ZC10YWc+XG4gICAqIEZvciBhbGwgb3RoZXIga2luZHMgdGhpcyB3aWxsIGJlIHRoZSBldmVudCBpZFxuICAgKi9cbiAgZGVkdXBsaWNhdGlvbktleSgpIHtcbiAgICBpZiAodGhpcy5raW5kID09PSAwIHx8IHRoaXMua2luZCA9PT0gMyB8fCB0aGlzLmtpbmQgJiYgdGhpcy5raW5kID49IDFlNCAmJiB0aGlzLmtpbmQgPCAyZTQpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLmtpbmR9OiR7dGhpcy5wdWJrZXl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGFnSWQoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaWQgb2YgdGhlIGV2ZW50IG9yLCBpZiBpdCdzIGEgcGFyYW1ldGVyaXplZCBldmVudCwgdGhlIGdlbmVyYXRlZCBpZCBvZiB0aGUgZXZlbnQgdXNpbmcgXCJkXCIgdGFnLCBwdWJrZXksIGFuZCBraW5kLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgaWRcbiAgICovXG4gIHRhZ0lkKCkge1xuICAgIGlmICh0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWdBZGRyZXNzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlkO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RhYmxlIHJlZmVyZW5jZSB2YWx1ZSBmb3IgYSByZXBsYWNlYWJsZSBldmVudC5cbiAgICpcbiAgICogUGFyYW0gcmVwbGFjZWFibGUgZXZlbnRzIGFyZSByZXR1cm5lZCBpbiB0aGUgZXhwZWN0ZWQgZm9ybWF0IG9mIGA8a2luZD46PHB1YmtleT46PGQtdGFnPmAuXG4gICAqIEtpbmQtcmVwbGFjZWFibGUgZXZlbnRzIGFyZSByZXR1cm5lZCBpbiB0aGUgZm9ybWF0IG9mIGA8a2luZD46PHB1YmtleT46YC5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gQSBzdGFibGUgcmVmZXJlbmNlIHZhbHVlIGZvciByZXBsYWNlYWJsZSBldmVudHNcbiAgICovXG4gIHRhZ0FkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIGNvbnN0IGRUYWdJZCA9IHRoaXMuZFRhZyA/PyBcIlwiO1xuICAgICAgcmV0dXJuIGAke3RoaXMua2luZH06JHt0aGlzLnB1YmtleX06JHtkVGFnSWR9YDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNSZXBsYWNlYWJsZSgpKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5raW5kfToke3RoaXMucHVia2V5fTpgO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBpcyBub3QgYSByZXBsYWNlYWJsZSBldmVudFwiKTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgdHlwZSBvZiB0YWcgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyBldmVudCBmcm9tIGFub3RoZXIgZXZlbnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0YWcgdHlwZVxuICAgKiBAZXhhbXBsZVxuICAgKiBldmVudCA9IG5ldyBOREtFdmVudChuZGssIHsga2luZDogMzAwMDAsIHB1YmtleTogJ3B1YmtleScsIHRhZ3M6IFsgW1wiZFwiLCBcImQtY29kZVwiXSBdIH0pO1xuICAgKiBldmVudC50YWdUeXBlKCk7IC8vIFwiYVwiXG4gICAqL1xuICB0YWdUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpID8gXCJhXCIgOiBcImVcIjtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB0YWcgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyBldmVudCBmcm9tIGFub3RoZXIgZXZlbnQuXG4gICAqXG4gICAqIENvbnNpZGVyIHVzaW5nIHJlZmVyZW5jZVRhZ3MoKSBpbnN0ZWFkICh1bmxlc3MgeW91IGhhdmUgYSBnb29kIHJlYXNvbiB0byB1c2UgdGhpcylcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAzMDAwMCwgcHVia2V5OiAncHVia2V5JywgdGFnczogWyBbXCJkXCIsIFwiZC1jb2RlXCJdIF0gfSk7XG4gICAqICAgICBldmVudC50YWdSZWZlcmVuY2UoKTsgLy8gW1wiYVwiLCBcIjMwMDAwOnB1YmtleTpkLWNvZGVcIl1cbiAgICpcbiAgICogICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAxLCBwdWJrZXk6ICdwdWJrZXknLCBpZDogXCJldmVudGlkXCIgfSk7XG4gICAqICAgICBldmVudC50YWdSZWZlcmVuY2UoKTsgLy8gW1wiZVwiLCBcImV2ZW50aWRcIl1cbiAgICogQHJldHVybnMge05ES1RhZ30gVGhlIE5ES1RhZyBvYmplY3QgcmVmZXJlbmNpbmcgdGhpcyBldmVudFxuICAgKi9cbiAgdGFnUmVmZXJlbmNlKG1hcmtlcikge1xuICAgIGxldCB0YWc7XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHRhZyA9IFtcImFcIiwgdGhpcy50YWdBZGRyZXNzKCldO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWcgPSBbXCJlXCIsIHRoaXMudGFnSWQoKV07XG4gICAgfVxuICAgIGlmICh0aGlzLnJlbGF5KSB7XG4gICAgICB0YWcucHVzaCh0aGlzLnJlbGF5LnVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZy5wdXNoKFwiXCIpO1xuICAgIH1cbiAgICB0YWcucHVzaChtYXJrZXIgPz8gXCJcIik7XG4gICAgaWYgKCF0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSB7XG4gICAgICB0YWcucHVzaCh0aGlzLnB1YmtleSk7XG4gICAgfVxuICAgIHJldHVybiB0YWc7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdGFncyB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGlzIGV2ZW50IGZyb20gYW5vdGhlciBldmVudFxuICAgKiBAcGFyYW0gbWFya2VyIFRoZSBtYXJrZXIgdG8gdXNlIGluIHRoZSB0YWdcbiAgICogQHBhcmFtIHNraXBBdXRob3JUYWcgV2hldGhlciB0byBleHBsaWNpdGx5IHNraXAgYWRkaW5nIHRoZSBhdXRob3IgdGFnIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0gZm9yY2VUYWcgRm9yY2UgYSBzcGVjaWZpYyB0YWcgdG8gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IFwiZVwiIG9yIFwiYVwiIHRhZ1xuICAgKiBAZXhhbXBsZVxuICAgKiAgICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDMwMDAwLCBwdWJrZXk6ICdwdWJrZXknLCB0YWdzOiBbIFtcImRcIiwgXCJkLWNvZGVcIl0gXSB9KTtcbiAgICogICAgIGV2ZW50LnJlZmVyZW5jZVRhZ3MoKTsgLy8gW1tcImFcIiwgXCIzMDAwMDpwdWJrZXk6ZC1jb2RlXCJdLCBbXCJlXCIsIFwicGFyZW50LWlkXCJdXVxuICAgKlxuICAgKiAgICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDEsIHB1YmtleTogJ3B1YmtleScsIGlkOiBcImV2ZW50aWRcIiB9KTtcbiAgICogICAgIGV2ZW50LnJlZmVyZW5jZVRhZ3MoKTsgLy8gW1tcImVcIiwgXCJwYXJlbnQtaWRcIl1dXG4gICAqIEByZXR1cm5zIHtOREtUYWd9IFRoZSBOREtUYWcgb2JqZWN0IHJlZmVyZW5jaW5nIHRoaXMgZXZlbnRcbiAgICovXG4gIHJlZmVyZW5jZVRhZ3MobWFya2VyLCBza2lwQXV0aG9yVGFnLCBmb3JjZVRhZykge1xuICAgIGxldCB0YWdzID0gW107XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHRhZ3MgPSBbXG4gICAgICAgIFtmb3JjZVRhZyA/PyBcImFcIiwgdGhpcy50YWdBZGRyZXNzKCldLFxuICAgICAgICBbZm9yY2VUYWcgPz8gXCJlXCIsIHRoaXMuaWRdXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWdzID0gW1tmb3JjZVRhZyA/PyBcImVcIiwgdGhpcy5pZF1dO1xuICAgIH1cbiAgICB0YWdzID0gdGFncy5tYXAoKHRhZykgPT4ge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgfHwgbWFya2VyKSB7XG4gICAgICAgIHRhZy5wdXNoKHRoaXMucmVsYXk/LnVybCA/PyBcIlwiKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZWxheT8udXJsKSB7XG4gICAgICAgIHRhZy5wdXNoKHRoaXMucmVsYXk/LnVybCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH0pO1xuICAgIHRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIikge1xuICAgICAgICB0YWcucHVzaChtYXJrZXIgPz8gXCJcIik7XG4gICAgICAgIHRhZy5wdXNoKHRoaXMucHVia2V5KTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyKSB7XG4gICAgICAgIHRhZy5wdXNoKG1hcmtlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFncyA9IFsuLi50YWdzLCAuLi50aGlzLmdldE1hdGNoaW5nVGFncyhcImhcIildO1xuICAgIGlmICghc2tpcEF1dGhvclRhZykgdGFncy5wdXNoKC4uLnRoaXMuYXV0aG9yLnJlZmVyZW5jZVRhZ3MoKSk7XG4gICAgcmV0dXJuIHRhZ3M7XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIHRoZSBmaWx0ZXIgdGhhdCB3aWxsIHJldHVybiBtYXRjaGluZyBldmVudHMgZm9yIHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAzMDAwMCwgcHVia2V5OiAncHVia2V5JywgdGFnczogWyBbXCJkXCIsIFwiZC1jb2RlXCJdIF0gfSk7XG4gICAqICAgIGV2ZW50LmZpbHRlcigpOyAvLyB7IFwiI2FcIjogW1wiMzAwMDA6cHVia2V5OmQtY29kZVwiXSB9XG4gICAqIEBleGFtcGxlXG4gICAqICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAxLCBwdWJrZXk6ICdwdWJrZXknLCBpZDogXCJldmVudGlkXCIgfSk7XG4gICAqICAgIGV2ZW50LmZpbHRlcigpOyAvLyB7IFwiI2VcIjogW1wiZXZlbnRpZFwiXSB9XG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBmaWx0ZXIgdGhhdCB3aWxsIHJldHVybiBtYXRjaGluZyBldmVudHMgZm9yIHRoaXMgZXZlbnRcbiAgICovXG4gIGZpbHRlcigpIHtcbiAgICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgICAgcmV0dXJuIHsgXCIjYVwiOiBbdGhpcy50YWdJZCgpXSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBcIiNlXCI6IFt0aGlzLnRhZ0lkKCldIH07XG4gIH1cbiAgbmlwMjJGaWx0ZXIoKSB7XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHJldHVybiB7IFwiI0FcIjogW3RoaXMudGFnSWQoKV0gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgXCIjRVwiOiBbdGhpcy50YWdJZCgpXSB9O1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBkZWxldGlvbiBldmVudCBvZiB0aGUgY3VycmVudCBldmVudFxuICAgKlxuICAgKiBAcGFyYW0gcmVhc29uIFRoZSByZWFzb24gZm9yIHRoZSBkZWxldGlvblxuICAgKiBAcGFyYW0gcHVibGlzaCBXaGV0aGVyIHRvIHB1Ymxpc2ggdGhlIGRlbGV0aW9uIGV2ZW50IGF1dG9tYXRpY2FsbHlcbiAgICogQHJldHVybnMgVGhlIGRlbGV0aW9uIGV2ZW50XG4gICAqL1xuICBhc3luYyBkZWxldGUocmVhc29uLCBwdWJsaXNoID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBjb25zdCBlID0gbmV3IF9OREtFdmVudCh0aGlzLm5kaywge1xuICAgICAga2luZDogNSAvKiBFdmVudERlbGV0aW9uICovLFxuICAgICAgY29udGVudDogcmVhc29uIHx8IFwiXCJcbiAgICB9KTtcbiAgICBlLnRhZyh0aGlzLCB2b2lkIDAsIHRydWUpO1xuICAgIGUudGFncy5wdXNoKFtcImtcIiwgdGhpcy5raW5kPy50b1N0cmluZygpXSk7XG4gICAgaWYgKHB1Ymxpc2gpIHtcbiAgICAgIHRoaXMuZW1pdChcImRlbGV0ZWRcIik7XG4gICAgICBhd2FpdCBlLnB1Ymxpc2goKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgLyoqXG4gICAqIEVzdGFibGlzaGVzIHdoZXRoZXIgdGhpcyBpcyBhIE5JUC03MC1wcm90ZWN0ZWRlIGV2ZW50LlxuICAgKiBAQHNhdGlzZmllcyBOSVAtNzBcbiAgICovXG4gIHNldCBpc1Byb3RlY3RlZCh2YWwpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcIi1cIik7XG4gICAgaWYgKHZhbCkgdGhpcy50YWdzLnB1c2goW1wiLVwiXSk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBpcyBhIE5JUC03MC1wcm90ZWN0ZWQgZXZlbnQuXG4gICAqIEBAc2F0aXNmaWVzIE5JUC03MFxuICAgKi9cbiAgZ2V0IGlzUHJvdGVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc1RhZyhcIi1cIik7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGFuIGV2ZW50IHRhZ2dlZCB3aXRoIHRoZSBnaXZlbiB0YWcgZm9sbG93aW5nIHJlbGF5IGhpbnRzIGlmIHByb3ZpZGVkLlxuICAgKiBAcGFyYW0gdGFnIFRoZSB0YWcgdG8gc2VhcmNoIGZvclxuICAgKiBAcGFyYW0gbWFya2VyIFRoZSBtYXJrZXIgdG8gdXNlIGluIHRoZSB0YWcgKGUuZy4gXCJyb290XCIpXG4gICAqIEByZXR1cm5zIFRoZSBmZXRjaGVkIGV2ZW50IG9yIG51bGwgaWYgbm8gZXZlbnQgd2FzIGZvdW5kLCB1bmRlZmluZWQgaWYgbm8gbWF0Y2hpbmcgdGFnIHdhcyBmb3VuZCBpbiB0aGUgZXZlbnRcbiAgICogKiBAZXhhbXBsZVxuICAgKiBjb25zdCByZXBseUV2ZW50ID0gYXdhaXQgbmRrLmZldGNoRXZlbnQoXCJuZXZlbnQxcXFzOHg4dm55Y3loYTczZ3J2MzgwZ212bHVyeTR3dG14MG5yOWE1ZHMyZG5ncXdndTg3d242Z3B6ZW1oeHVlNjl1aGh5ZXR2djl1anV1cmpkOWtrem1wd2RlamhncTNxbDJ2eWg0N21rMnAwcWxza3U3aGcwdm4yOWZhZWh5OWh5MzR5Z2FjbHBuNjZ1a3FwM2FmcXo0Y3dqZFwiKVxuICAgKiBjb25zdCBvcmlnaW5hbEV2ZW50ID0gYXdhaXQgcmVwbHlFdmVudC5mZXRjaFRhZ2dlZEV2ZW50KFwiZVwiLCBcInJlcGx5XCIpO1xuICAgKiBjb25zb2xlLmxvZyhyZXBseUV2ZW50LmVuY29kZSgpICsgXCIgaXMgYSByZXBseSB0byBldmVudCBcIiArIG9yaWdpbmFsRXZlbnQ/LmVuY29kZSgpKTtcbiAgICovXG4gIGZldGNoVGFnZ2VkRXZlbnQgPSBmZXRjaFRhZ2dlZEV2ZW50LmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgcm9vdCBldmVudCBvZiB0aGUgY3VycmVudCBldmVudC5cbiAgICogQHJldHVybnMgVGhlIGZldGNoZWQgcm9vdCBldmVudCBvciBudWxsIGlmIG5vIGV2ZW50IHdhcyBmb3VuZFxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByZXBseUV2ZW50ID0gYXdhaXQgbmRrLmZldGNoRXZlbnQoXCJuZXZlbnQxcXFzOHg4dm55Y3loYTczZ3J2MzgwZ212bHVyeTR3dG14MG5yOWE1ZHMyZG5ncXdndTg3d242Z3B6ZW1oeHVlNjl1aGh5ZXR2djl1anV1cmpkOWtrem1wd2RlamhncTNxbDJ2eWg0N21rMnAwcWxza3U3aGcwdm4yOWZhZWh5OWh5MzR5Z2FjbHBuNjZ1a3FwM2FmcXo0Y3dqZFwiKVxuICAgKiBjb25zdCByb290RXZlbnQgPSBhd2FpdCByZXBseUV2ZW50LmZldGNoUm9vdEV2ZW50KCk7XG4gICAqIGNvbnNvbGUubG9nKHJlcGx5RXZlbnQuZW5jb2RlKCkgKyBcIiBpcyBhIHJlcGx5IGluIHRoZSB0aHJlYWQgXCIgKyByb290RXZlbnQ/LmVuY29kZSgpKTtcbiAgICovXG4gIGZldGNoUm9vdEV2ZW50ID0gZmV0Y2hSb290RXZlbnQuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIEZldGNoIHRoZSBldmVudCB0aGUgY3VycmVudCBldmVudCBpcyByZXBseWluZyB0by5cbiAgICogQHJldHVybnMgVGhlIGZldGNoZWQgcmVwbHkgZXZlbnQgb3IgbnVsbCBpZiBubyBldmVudCB3YXMgZm91bmRcbiAgICovXG4gIGZldGNoUmVwbHlFdmVudCA9IGZldGNoUmVwbHlFdmVudC5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogTklQLTE4IHJlcG9zdGluZyBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHB1Ymxpc2ggV2hldGhlciB0byBwdWJsaXNoIHRoZSByZXBvc3RlZCBldmVudCBhdXRvbWF0aWNhbGx5IEBkZWZhdWx0IHRydWVcbiAgICogQHBhcmFtIHNpZ25lciBUaGUgc2lnbmVyIHRvIHVzZSBmb3Igc2lnbmluZyB0aGUgcmVwb3N0ZWQgZXZlbnRcbiAgICogQHJldHVybnMgVGhlIHJlcG9zdGVkIGV2ZW50XG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgcmVwb3N0ID0gcmVwb3N0LmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBSZWFjdCB0byBhbiBleGlzdGluZyBldmVudFxuICAgKlxuICAgKiBAcGFyYW0gY29udGVudCBUaGUgY29udGVudCBvZiB0aGUgcmVhY3Rpb25cbiAgICovXG4gIGFzeW5jIHJlYWN0KGNvbnRlbnQsIHB1Ymxpc2ggPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGNvbnN0IGUgPSBuZXcgX05ES0V2ZW50KHRoaXMubmRrLCB7XG4gICAgICBraW5kOiA3IC8qIFJlYWN0aW9uICovLFxuICAgICAgY29udGVudFxuICAgIH0pO1xuICAgIGUudGFnKHRoaXMpO1xuICAgIGlmIChwdWJsaXNoKSBhd2FpdCBlLnB1Ymxpc2goKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGV2ZW50IGlzIHZhbGlkIHBlciB1bmRlcmx5aW5nIE5JUHMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3NlcyB0aGF0IGltcGxlbWVudCBzcGVjaWZpYyBOSVBzXG4gICAqIHRvIGFsbG93IHRoZSBlbmZvcmNlbWVudCBvZiBOSVAtc3BlY2lmaWMgdmFsaWRhdGlvbiBydWxlcy5cbiAgICpcbiAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIG9ubHkgY2hlY2sgZm9yIGJhc2ljIGV2ZW50IHByb3BlcnRpZXMuXG4gICAqXG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZSgpO1xuICB9XG4gIGdldCBpbnNwZWN0KCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnJhd0V2ZW50KCksIG51bGwsIDQpO1xuICB9XG4gIC8qKlxuICAgKiBEdW1wIHRoZSBldmVudCB0byBjb25zb2xlIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG4gICAqIFByaW50cyBhIEpTT04gc3RyaW5naWZpZWQgdmVyc2lvbiBvZiByYXdFdmVudCgpIHdpdGggaW5kZW50YXRpb25cbiAgICogYW5kIGFsc28gbGlzdHMgYWxsIHJlbGF5IFVSTHMgZm9yIG9uUmVsYXlzLlxuICAgKi9cbiAgZHVtcCgpIHtcbiAgICBjb25zb2xlLmRlYnVnKEpTT04uc3RyaW5naWZ5KHRoaXMucmF3RXZlbnQoKSwgbnVsbCwgNCkpO1xuICAgIGNvbnNvbGUuZGVidWcoXCJFdmVudCBvbiByZWxheXM6XCIsIHRoaXMub25SZWxheXMubWFwKChyZWxheSkgPT4gcmVsYXkudXJsKS5qb2luKFwiLCBcIikpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVwbHkgZXZlbnQgZm9yIHRoZSBjdXJyZW50IGV2ZW50LlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdXNlIE5JUC0yMiB3aGVuIGFwcHJvcHJpYXRlIChpLmUuIHJlcGxpZXMgdG8gbm9uLWtpbmQ6MSBldmVudHMpLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGhhdmUgc2lkZS1lZmZlY3RzOyBpdCB3aWxsIGp1c3QgcmV0dXJuIGFuIGV2ZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIHRhZ3NcbiAgICogdG8gZ2VuZXJhdGUgdGhlIHJlcGx5IGV2ZW50OyB0aGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAgICovXG4gIHJlcGx5KCkge1xuICAgIGNvbnN0IHJlcGx5ID0gbmV3IF9OREtFdmVudCh0aGlzLm5kayk7XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMSkge1xuICAgICAgcmVwbHkua2luZCA9IDE7XG4gICAgICBjb25zdCBvcEhhc0VUYWcgPSB0aGlzLmhhc1RhZyhcImVcIik7XG4gICAgICBpZiAob3BIYXNFVGFnKSB7XG4gICAgICAgIHJlcGx5LnRhZ3MgPSBbXG4gICAgICAgICAgLi4ucmVwbHkudGFncyxcbiAgICAgICAgICAuLi50aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIiksXG4gICAgICAgICAgLi4udGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpLFxuICAgICAgICAgIC4uLnRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiYVwiKSxcbiAgICAgICAgICAuLi50aGlzLnJlZmVyZW5jZVRhZ3MoXCJyZXBseVwiKVxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVwbHkudGFnKHRoaXMsIFwicm9vdFwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbHkua2luZCA9IDExMTEgLyogR2VuZXJpY1JlcGx5ICovO1xuICAgICAgY29uc3QgY2FycnlPdmVyVGFncyA9IFtcIkFcIiwgXCJFXCIsIFwiSVwiLCBcIlBcIl07XG4gICAgICBjb25zdCByb290VGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gY2FycnlPdmVyVGFncy5pbmNsdWRlcyh0YWdbMF0pKTtcbiAgICAgIGlmIChyb290VGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJvb3RLaW5kID0gdGhpcy50YWdWYWx1ZShcIktcIik7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaCguLi5yb290VGFncyk7XG4gICAgICAgIGlmIChyb290S2luZCkgcmVwbHkudGFncy5wdXNoKFtcIktcIiwgcm9vdEtpbmRdKTtcbiAgICAgICAgY29uc3QgW3R5cGUsIGlkLCBfLCAuLi5leHRyYV0gPSB0aGlzLnRhZ1JlZmVyZW5jZSgpO1xuICAgICAgICBjb25zdCB0YWcgPSBbdHlwZSwgaWQsIC4uLmV4dHJhXTtcbiAgICAgICAgcmVwbHkudGFncy5wdXNoKHRhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBbdHlwZSwgaWQsIF8sIHJlbGF5SGludF0gPSB0aGlzLnRhZ1JlZmVyZW5jZSgpO1xuICAgICAgICBjb25zdCB0YWcgPSBbdHlwZSwgaWQsIHJlbGF5SGludCA/PyBcIlwiXTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZVwiKSB0YWcucHVzaCh0aGlzLnB1YmtleSk7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaCh0YWcpO1xuICAgICAgICBjb25zdCB1cHBlcmNhc2VUYWcgPSBbLi4udGFnXTtcbiAgICAgICAgdXBwZXJjYXNlVGFnWzBdID0gdXBwZXJjYXNlVGFnWzBdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaCh1cHBlcmNhc2VUYWcpO1xuICAgICAgICByZXBseS50YWdzLnB1c2goW1wiS1wiLCB0aGlzLmtpbmQ/LnRvU3RyaW5nKCldKTtcbiAgICAgICAgcmVwbHkudGFncy5wdXNoKFtcIlBcIiwgdGhpcy5wdWJrZXldKTtcbiAgICAgIH1cbiAgICAgIHJlcGx5LnRhZ3MucHVzaChbXCJrXCIsIHRoaXMua2luZD8udG9TdHJpbmcoKV0pO1xuICAgICAgcmVwbHkudGFncy5wdXNoKC4uLnRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKSk7XG4gICAgICByZXBseS50YWdzLnB1c2goW1wicFwiLCB0aGlzLnB1YmtleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVwbHk7XG4gIH1cbn07XG52YXIgdW50cmFja2VkVW5wdWJsaXNoZWRFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIDI0MTMzIC8qIE5vc3RyQ29ubmVjdCAqLyxcbiAgMTMxOTQgLyogTm9zdHJXYWxldENvbm5lY3RJbmZvICovLFxuICAyMzE5NCAvKiBOb3N0cldhbGxldENvbm5lY3RSZXEgKi8sXG4gIDIzMTk1IC8qIE5vc3RyV2FsbGV0Q29ubmVjdFJlcyAqL1xuXSk7XG5mdW5jdGlvbiBzaG91bGRUcmFja1VucHVibGlzaGVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICF1bnRyYWNrZWRVbnB1Ymxpc2hlZEV2ZW50cy5oYXMoZXZlbnQua2luZCk7XG59XG5cbi8vIHNyYy9yZWxheS9wb29sL2luZGV4LnRzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgYXMgRXZlbnRFbWl0dGVyMyB9IGZyb20gXCJ0c2VlcFwiO1xudmFyIE5ES1Bvb2wgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjMge1xuICAvLyBUT0RPOiBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBhbiBMUlUgY2FjaGVcbiAgX3JlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHN0YXR1cyA9IFwiaWRsZVwiO1xuICBhdXRvQ29ubmVjdFJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHBvb2xCbGFja2xpc3RSZWxheVVybHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBkZWJ1ZztcbiAgdGVtcG9yYXJ5UmVsYXlUaW1lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmbGFwcGluZ1JlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIC8vIEEgbWFwIHRvIHN0b3JlIHRpbWVvdXRzIGZvciBlYWNoIGZsYXBwaW5nIHJlbGF5LlxuICBiYWNrb2ZmVGltZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBuZGs7XG4gIGdldCBibGFja2xpc3RSZWxheVVybHMoKSB7XG4gICAgY29uc3QgdmFsID0gbmV3IFNldCh0aGlzLm5kay5ibGFja2xpc3RSZWxheVVybHMpO1xuICAgIHRoaXMucG9vbEJsYWNrbGlzdFJlbGF5VXJscy5mb3JFYWNoKCh1cmwpID0+IHZhbC5hZGQodXJsKSk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHJlbGF5VXJscyAtIFRoZSBVUkxzIG9mIHRoZSByZWxheXMgdG8gY29ubmVjdCB0by5cbiAgICogQHBhcmFtIGJsYWNrbGlzdGVkUmVsYXlVcmxzIC0gVVJMcyB0byBibGFja2xpc3QgZm9yIHRoaXMgcG9vbCBJTiBBRERJVElPTiB0byB0aG9zZSBibGFja2xpc3RlZCBhdCB0aGUgbmRrLWxldmVsXG4gICAqIEBwYXJhbSBuZGsgLSBUaGUgTkRLIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgZm9yIHRoZSBwb29sLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVsYXlVcmxzLCBibGFja2xpc3RlZFJlbGF5VXJscywgbmRrLCB7XG4gICAgZGVidWc6IGRlYnVnOCxcbiAgICBuYW1lXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnOCA/PyBuZGsuZGVidWcuZXh0ZW5kKFwicG9vbFwiKTtcbiAgICBpZiAobmFtZSkgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgdGhpcy5yZWxheVVybHMgPSByZWxheVVybHM7XG4gICAgdGhpcy5wb29sQmxhY2tsaXN0UmVsYXlVcmxzID0gbmV3IFNldChibGFja2xpc3RlZFJlbGF5VXJscyk7XG4gICAgdGhpcy5uZGsucG9vbHMucHVzaCh0aGlzKTtcbiAgfVxuICBnZXQgcmVsYXlzKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWxheXM7XG4gIH1cbiAgc2V0IHJlbGF5VXJscyh1cmxzKSB7XG4gICAgdGhpcy5fcmVsYXlzLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCByZWxheVVybCBvZiB1cmxzKSB7XG4gICAgICBjb25zdCByZWxheSA9IG5ldyBOREtSZWxheShyZWxheVVybCwgdm9pZCAwLCB0aGlzLm5kayk7XG4gICAgICByZWxheS5jb25uZWN0aXZpdHkubmV0RGVidWcgPSB0aGlzLm5kay5uZXREZWJ1ZztcbiAgICAgIHRoaXMuYWRkUmVsYXkocmVsYXkpO1xuICAgIH1cbiAgfVxuICBfbmFtZSA9IFwidW5uYW1lZFwiO1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgfVxuICBzZXQgbmFtZShuYW1lKSB7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5kZWJ1ZyA9IHRoaXMuZGVidWcuZXh0ZW5kKG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcmVsYXkgdG8gdGhlIHBvb2wsIGFuZCBzZXRzIGEgdGltZXIgdG8gcmVtb3ZlIGl0IGlmIGl0IGlzIG5vdCB1c2VkIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHRpbWUuXG4gICAqIEBwYXJhbSByZWxheSAtIFRoZSByZWxheSB0byBhZGQgdG8gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSByZW1vdmVJZlVudXNlZEFmdGVyIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJlbW92aW5nIHRoZSByZWxheSBmcm9tIHRoZSBwb29sIGFmdGVyIGl0IGlzIG5vIGxvbmdlciB1c2VkLlxuICAgKi9cbiAgdXNlVGVtcG9yYXJ5UmVsYXkocmVsYXksIHJlbW92ZUlmVW51c2VkQWZ0ZXIgPSAzZTQsIGZpbHRlcnMpIHtcbiAgICBjb25zdCByZWxheUFscmVhZHlJblBvb2wgPSB0aGlzLnJlbGF5cy5oYXMocmVsYXkudXJsKTtcbiAgICBpZiAoIXJlbGF5QWxyZWFkeUluUG9vbCkge1xuICAgICAgdGhpcy5hZGRSZWxheShyZWxheSk7XG4gICAgICB0aGlzLmRlYnVnKFwiQWRkaW5nIHRlbXBvcmFyeSByZWxheSAlcyBmb3IgZmlsdGVycyAlb1wiLCByZWxheS51cmwsIGZpbHRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ1RpbWVyID0gdGhpcy50ZW1wb3JhcnlSZWxheVRpbWVycy5nZXQocmVsYXkudXJsKTtcbiAgICBpZiAoZXhpc3RpbmdUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KGV4aXN0aW5nVGltZXIpO1xuICAgIH1cbiAgICBpZiAoIXJlbGF5QWxyZWFkeUluUG9vbCB8fCBleGlzdGluZ1RpbWVyKSB7XG4gICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5uZGsuZXhwbGljaXRSZWxheVVybHM/LmluY2x1ZGVzKHJlbGF5LnVybCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5yZW1vdmVSZWxheShyZWxheS51cmwpO1xuICAgICAgfSwgcmVtb3ZlSWZVbnVzZWRBZnRlcik7XG4gICAgICB0aGlzLnRlbXBvcmFyeVJlbGF5VGltZXJzLnNldChyZWxheS51cmwsIHRpbWVyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSByZWxheSB0byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHBhcmFtIHJlbGF5IC0gVGhlIHJlbGF5IHRvIGFkZCB0byB0aGUgcG9vbC5cbiAgICogQHBhcmFtIGNvbm5lY3QgLSBXaGV0aGVyIG9yIG5vdCB0byBjb25uZWN0IHRvIHRoZSByZWxheS5cbiAgICovXG4gIGFkZFJlbGF5KHJlbGF5LCBjb25uZWN0ID0gdHJ1ZSkge1xuICAgIGNvbnN0IGlzQWxyZWFkeUluUG9vbCA9IHRoaXMucmVsYXlzLmhhcyhyZWxheS51cmwpO1xuICAgIGNvbnN0IGlzQmxhY2tsaXN0ZWQgPSB0aGlzLmJsYWNrbGlzdFJlbGF5VXJscz8uaGFzKHJlbGF5LnVybCk7XG4gICAgY29uc3QgaXNDdXN0b21SZWxheVVybCA9IHJlbGF5LnVybC5pbmNsdWRlcyhcIi9ucHViMVwiKTtcbiAgICBsZXQgcmVjb25uZWN0ID0gdHJ1ZTtcbiAgICBjb25zdCByZWxheVVybCA9IHJlbGF5LnVybDtcbiAgICBpZiAoaXNBbHJlYWR5SW5Qb29sKSByZXR1cm47XG4gICAgaWYgKGlzQmxhY2tsaXN0ZWQpIHtcbiAgICAgIHRoaXMuZGVidWcoYFJlZnVzaW5nIHRvIGFkZCByZWxheSAke3JlbGF5VXJsfTogYmxhY2tsaXN0ZWRgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzQ3VzdG9tUmVsYXlVcmwpIHtcbiAgICAgIHRoaXMuZGVidWcoYFJlZnVzaW5nIHRvIGFkZCByZWxheSAke3JlbGF5VXJsfTogaXMgYSBmaWx0ZXIgcmVsYXlgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlcj8uZ2V0UmVsYXlTdGF0dXMpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZ2V0UmVsYXlTdGF0dXMocmVsYXlVcmwpO1xuICAgICAgaWYgKGluZm8/LmRvbnRDb25uZWN0QmVmb3JlKSB7XG4gICAgICAgIGlmIChpbmZvLmRvbnRDb25uZWN0QmVmb3JlID4gRGF0ZS5ub3coKSkge1xuICAgICAgICAgIGNvbnN0IGRlbGF5ID0gaW5mby5kb250Q29ubmVjdEJlZm9yZSAtIERhdGUubm93KCk7XG4gICAgICAgICAgdGhpcy5kZWJ1ZyhgUmVmdXNpbmcgdG8gYWRkIHJlbGF5ICR7cmVsYXlVcmx9OiBkZWxheWVkIGNvbm5lY3QgZm9yICR7ZGVsYXl9bXNgKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkUmVsYXkocmVsYXksIGNvbm5lY3QpO1xuICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vdGljZUhhbmRsZXIgPSAobm90aWNlKSA9PiB0aGlzLmVtaXQoXCJub3RpY2VcIiwgcmVsYXksIG5vdGljZSk7XG4gICAgY29uc3QgY29ubmVjdEhhbmRsZXIgPSAoKSA9PiB0aGlzLmhhbmRsZVJlbGF5Q29ubmVjdChyZWxheVVybCk7XG4gICAgY29uc3QgcmVhZHlIYW5kbGVyID0gKCkgPT4gdGhpcy5oYW5kbGVSZWxheVJlYWR5KHJlbGF5KTtcbiAgICBjb25zdCBkaXNjb25uZWN0SGFuZGxlciA9ICgpID0+IHRoaXMuZW1pdChcInJlbGF5OmRpc2Nvbm5lY3RcIiwgcmVsYXkpO1xuICAgIGNvbnN0IGZsYXBwaW5nSGFuZGxlciA9ICgpID0+IHRoaXMuaGFuZGxlRmxhcHBpbmcocmVsYXkpO1xuICAgIGNvbnN0IGF1dGhIYW5kbGVyID0gKGNoYWxsZW5nZSkgPT4gdGhpcy5lbWl0KFwicmVsYXk6YXV0aFwiLCByZWxheSwgY2hhbGxlbmdlKTtcbiAgICBjb25zdCBhdXRoZWRIYW5kbGVyID0gKCkgPT4gdGhpcy5lbWl0KFwicmVsYXk6YXV0aGVkXCIsIHJlbGF5KTtcbiAgICByZWxheS5vZmYoXCJub3RpY2VcIiwgbm90aWNlSGFuZGxlcik7XG4gICAgcmVsYXkub2ZmKFwiY29ubmVjdFwiLCBjb25uZWN0SGFuZGxlcik7XG4gICAgcmVsYXkub2ZmKFwicmVhZHlcIiwgcmVhZHlIYW5kbGVyKTtcbiAgICByZWxheS5vZmYoXCJkaXNjb25uZWN0XCIsIGRpc2Nvbm5lY3RIYW5kbGVyKTtcbiAgICByZWxheS5vZmYoXCJmbGFwcGluZ1wiLCBmbGFwcGluZ0hhbmRsZXIpO1xuICAgIHJlbGF5Lm9mZihcImF1dGhcIiwgYXV0aEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9mZihcImF1dGhlZFwiLCBhdXRoZWRIYW5kbGVyKTtcbiAgICByZWxheS5vbihcIm5vdGljZVwiLCBub3RpY2VIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImNvbm5lY3RcIiwgY29ubmVjdEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwicmVhZHlcIiwgcmVhZHlIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImRpc2Nvbm5lY3RcIiwgZGlzY29ubmVjdEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwiZmxhcHBpbmdcIiwgZmxhcHBpbmdIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImF1dGhcIiwgYXV0aEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwiYXV0aGVkXCIsIGF1dGhlZEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwiZGVsYXllZC1jb25uZWN0XCIsIChkZWxheSkgPT4ge1xuICAgICAgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlcj8udXBkYXRlUmVsYXlTdGF0dXMpIHtcbiAgICAgICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLnVwZGF0ZVJlbGF5U3RhdHVzKHJlbGF5LnVybCwge1xuICAgICAgICAgIGRvbnRDb25uZWN0QmVmb3JlOiBEYXRlLm5vdygpICsgZGVsYXlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fcmVsYXlzLnNldChyZWxheVVybCwgcmVsYXkpO1xuICAgIGlmIChjb25uZWN0KSB0aGlzLmF1dG9Db25uZWN0UmVsYXlzLmFkZChyZWxheVVybCk7XG4gICAgaWYgKGNvbm5lY3QgJiYgdGhpcy5zdGF0dXMgPT09IFwiYWN0aXZlXCIpIHtcbiAgICAgIHRoaXMuZW1pdChcInJlbGF5OmNvbm5lY3RpbmdcIiwgcmVsYXkpO1xuICAgICAgcmVsYXkuY29ubmVjdCh2b2lkIDAsIHJlY29ubmVjdCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhgRmFpbGVkIHRvIGNvbm5lY3QgdG8gcmVsYXkgJHtyZWxheVVybH1gLCBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhIHJlbGF5IGZyb20gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSByZWxheVVybCAtIFRoZSBVUkwgb2YgdGhlIHJlbGF5IHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHJlbGF5IHdhcyByZW1vdmVkLCBmYWxzZSBpZiBpdCB3YXMgbm90IGZvdW5kLlxuICAgKi9cbiAgcmVtb3ZlUmVsYXkocmVsYXlVcmwpIHtcbiAgICBjb25zdCByZWxheSA9IHRoaXMucmVsYXlzLmdldChyZWxheVVybCk7XG4gICAgaWYgKHJlbGF5KSB7XG4gICAgICByZWxheS5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLnJlbGF5cy5kZWxldGUocmVsYXlVcmwpO1xuICAgICAgdGhpcy5hdXRvQ29ubmVjdFJlbGF5cy5kZWxldGUocmVsYXlVcmwpO1xuICAgICAgdGhpcy5lbWl0KFwicmVsYXk6ZGlzY29ubmVjdFwiLCByZWxheSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdUaW1lciA9IHRoaXMudGVtcG9yYXJ5UmVsYXlUaW1lcnMuZ2V0KHJlbGF5VXJsKTtcbiAgICBpZiAoZXhpc3RpbmdUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KGV4aXN0aW5nVGltZXIpO1xuICAgICAgdGhpcy50ZW1wb3JhcnlSZWxheVRpbWVycy5kZWxldGUocmVsYXlVcmwpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGEgcmVsYXkgaXMgYWxyZWFkeSBjb25uZWN0ZWQgaW4gdGhlIHBvb2wuXG4gICAqL1xuICBpc1JlbGF5Q29ubmVjdGVkKHVybCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRVcmwgPSBub3JtYWxpemVSZWxheVVybCh1cmwpO1xuICAgIGNvbnN0IHJlbGF5ID0gdGhpcy5yZWxheXMuZ2V0KG5vcm1hbGl6ZWRVcmwpO1xuICAgIGlmICghcmVsYXkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gcmVsYXkuc3RhdHVzID09PSA1IC8qIENPTk5FQ1RFRCAqLztcbiAgfVxuICAvKipcbiAgICogRmV0Y2hlcyBhIHJlbGF5IGZyb20gdGhlIHBvb2wsIG9yIGNyZWF0ZXMgYSBuZXcgb25lIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBOZXcgcmVsYXlzIHdpbGwgYmUgYXR0ZW1wdGVkIHRvIGJlIGNvbm5lY3RlZC5cbiAgICovXG4gIGdldFJlbGF5KHVybCwgY29ubmVjdCA9IHRydWUsIHRlbXBvcmFyeSA9IGZhbHNlLCBmaWx0ZXJzKSB7XG4gICAgbGV0IHJlbGF5ID0gdGhpcy5yZWxheXMuZ2V0KG5vcm1hbGl6ZVJlbGF5VXJsKHVybCkpO1xuICAgIGlmICghcmVsYXkpIHtcbiAgICAgIHJlbGF5ID0gbmV3IE5ES1JlbGF5KHVybCwgdm9pZCAwLCB0aGlzLm5kayk7XG4gICAgICByZWxheS5jb25uZWN0aXZpdHkubmV0RGVidWcgPSB0aGlzLm5kay5uZXREZWJ1ZztcbiAgICAgIGlmICh0ZW1wb3JhcnkpIHtcbiAgICAgICAgdGhpcy51c2VUZW1wb3JhcnlSZWxheShyZWxheSwgM2U0LCBmaWx0ZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkUmVsYXkocmVsYXksIGNvbm5lY3QpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbiAgaGFuZGxlUmVsYXlDb25uZWN0KHJlbGF5VXJsKSB7XG4gICAgY29uc3QgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQocmVsYXlVcmwpO1xuICAgIGlmICghcmVsYXkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJOREsgQlVHOiByZWxheSBub3QgZm91bmQgaW4gcG9vbFwiLCB7IHJlbGF5VXJsIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJyZWxheTpjb25uZWN0XCIsIHJlbGF5KTtcbiAgICBpZiAodGhpcy5zdGF0cygpLmNvbm5lY3RlZCA9PT0gdGhpcy5yZWxheXMuc2l6ZSkge1xuICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdFwiKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlUmVsYXlSZWFkeShyZWxheSkge1xuICAgIHRoaXMuZW1pdChcInJlbGF5OnJlYWR5XCIsIHJlbGF5KTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB0byBlYWNoIHJlbGF5IGluIHRoZSBwb29sLlxuICAgKlxuICAgKiBAYXN5bmNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0TXNdIC0gT3B0aW9uYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIGVhY2ggY29ubmVjdGlvbiBhdHRlbXB0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgY29ubmVjdGlvbiBhdHRlbXB0cyBoYXZlIGNvbXBsZXRlZC5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIGFueSBvZiB0aGUgY29ubmVjdGlvbiBhdHRlbXB0cyByZXN1bHQgaW4gYW4gZXJyb3Igb3IgdGltZW91dC5cbiAgICovXG4gIGFzeW5jIGNvbm5lY3QodGltZW91dE1zKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICB0aGlzLnN0YXR1cyA9IFwiYWN0aXZlXCI7XG4gICAgdGhpcy5kZWJ1ZyhgQ29ubmVjdGluZyB0byAke3RoaXMucmVsYXlzLnNpemV9IHJlbGF5cyR7dGltZW91dE1zID8gYCwgdGltZW91dCAke3RpbWVvdXRNc30uLi5gIDogXCJcIn1gKTtcbiAgICBjb25zdCByZWxheXNUb0Nvbm5lY3QgPSBuZXcgU2V0KHRoaXMuYXV0b0Nvbm5lY3RSZWxheXMua2V5cygpKTtcbiAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIHJlbGF5c1RvQ29ubmVjdCkge1xuICAgICAgY29uc3QgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQocmVsYXlVcmwpO1xuICAgICAgaWYgKCFyZWxheSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbm5lY3RQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoXCJyZWxheTpjb25uZWN0aW5nXCIsIHJlbGF5KTtcbiAgICAgICAgcmV0dXJuIHJlbGF5LmNvbm5lY3QodGltZW91dE1zKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aW1lb3V0TXMpIHtcbiAgICAgICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QoYFRpbWVkIG91dCBhZnRlciAke3RpbWVvdXRNc31tc2ApLCB0aW1lb3V0TXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICBQcm9taXNlLnJhY2UoW2Nvbm5lY3RQcm9taXNlLCB0aW1lb3V0UHJvbWlzZV0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKGBGYWlsZWQgdG8gY29ubmVjdCB0byByZWxheSAke3JlbGF5LnVybH06ICR7ZSA/PyBcIk5vIHJlYXNvbiBzcGVjaWZpZWRcIn1gKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChjb25uZWN0UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1heWJlRW1pdENvbm5lY3QgPSAoKSA9PiB7XG4gICAgICBjb25zdCBhbGxDb25uZWN0ZWQgPSB0aGlzLnN0YXRzKCkuY29ubmVjdGVkID09PSB0aGlzLnJlbGF5cy5zaXplO1xuICAgICAgY29uc3Qgc29tZUNvbm5lY3RlZCA9IHRoaXMuc3RhdHMoKS5jb25uZWN0ZWQgPiAwO1xuICAgICAgaWYgKCFhbGxDb25uZWN0ZWQgJiYgc29tZUNvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0XCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHRpbWVvdXRNcykgc2V0VGltZW91dChtYXliZUVtaXRDb25uZWN0LCB0aW1lb3V0TXMpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICBtYXliZUVtaXRDb25uZWN0KCk7XG4gIH1cbiAgY2hlY2tPbkZsYXBwaW5nUmVsYXlzKCkge1xuICAgIGNvbnN0IGZsYXBwaW5nUmVsYXlzQ291bnQgPSB0aGlzLmZsYXBwaW5nUmVsYXlzLnNpemU7XG4gICAgY29uc3QgdG90YWxSZWxheXMgPSB0aGlzLnJlbGF5cy5zaXplO1xuICAgIGlmIChmbGFwcGluZ1JlbGF5c0NvdW50IC8gdG90YWxSZWxheXMgPj0gMC44KSB7XG4gICAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIHRoaXMuZmxhcHBpbmdSZWxheXMpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZXMuc2V0KHJlbGF5VXJsLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlRmxhcHBpbmcocmVsYXkpIHtcbiAgICB0aGlzLmRlYnVnKGBSZWxheSAke3JlbGF5LnVybH0gaXMgZmxhcHBpbmdgKTtcbiAgICBsZXQgY3VycmVudEJhY2tvZmYgPSB0aGlzLmJhY2tvZmZUaW1lcy5nZXQocmVsYXkudXJsKSB8fCA1ZTM7XG4gICAgY3VycmVudEJhY2tvZmYgPSBjdXJyZW50QmFja29mZiAqIDI7XG4gICAgdGhpcy5iYWNrb2ZmVGltZXMuc2V0KHJlbGF5LnVybCwgY3VycmVudEJhY2tvZmYpO1xuICAgIHRoaXMuZGVidWcoYEJhY2tvZmYgdGltZSBmb3IgJHtyZWxheS51cmx9IGlzICR7Y3VycmVudEJhY2tvZmZ9bXNgKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZGVidWcoYEF0dGVtcHRpbmcgdG8gcmVjb25uZWN0IHRvICR7cmVsYXkudXJsfWApO1xuICAgICAgdGhpcy5lbWl0KFwicmVsYXk6Y29ubmVjdGluZ1wiLCByZWxheSk7XG4gICAgICByZWxheS5jb25uZWN0KCk7XG4gICAgICB0aGlzLmNoZWNrT25GbGFwcGluZ1JlbGF5cygpO1xuICAgIH0sIGN1cnJlbnRCYWNrb2ZmKTtcbiAgICByZWxheS5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5lbWl0KFwiZmxhcHBpbmdcIiwgcmVsYXkpO1xuICB9XG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXlzLnNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXR1cyBvZiBlYWNoIHJlbGF5IGluIHRoZSBwb29sLlxuICAgKiBAcmV0dXJucyB7TkRLUG9vbFN0YXRzfSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbnVtYmVyIG9mIHJlbGF5cyBpbiBlYWNoIHN0YXR1cy5cbiAgICovXG4gIHN0YXRzKCkge1xuICAgIGNvbnN0IHN0YXRzID0ge1xuICAgICAgdG90YWw6IDAsXG4gICAgICBjb25uZWN0ZWQ6IDAsXG4gICAgICBkaXNjb25uZWN0ZWQ6IDAsXG4gICAgICBjb25uZWN0aW5nOiAwXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHRoaXMucmVsYXlzLnZhbHVlcygpKSB7XG4gICAgICBzdGF0cy50b3RhbCsrO1xuICAgICAgaWYgKHJlbGF5LnN0YXR1cyA9PT0gNSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgICAgc3RhdHMuY29ubmVjdGVkKys7XG4gICAgICB9IGVsc2UgaWYgKHJlbGF5LnN0YXR1cyA9PT0gMSAvKiBESVNDT05ORUNURUQgKi8pIHtcbiAgICAgICAgc3RhdHMuZGlzY29ubmVjdGVkKys7XG4gICAgICB9IGVsc2UgaWYgKHJlbGF5LnN0YXR1cyA9PT0gNCAvKiBDT05ORUNUSU5HICovKSB7XG4gICAgICAgIHN0YXRzLmNvbm5lY3RpbmcrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRzO1xuICB9XG4gIGNvbm5lY3RlZFJlbGF5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlbGF5cy52YWx1ZXMoKSkuZmlsdGVyKChyZWxheSkgPT4gcmVsYXkuc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovKTtcbiAgfVxuICBwZXJtYW5lbnRBbmRDb25uZWN0ZWRSZWxheXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWxheXMudmFsdWVzKCkpLmZpbHRlcihcbiAgICAgIChyZWxheSkgPT4gcmVsYXkuc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovICYmICF0aGlzLnRlbXBvcmFyeVJlbGF5VGltZXJzLmhhcyhyZWxheS51cmwpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBhbGwgcmVsYXkgdXJscyBpbiB0aGUgcG9vbC5cbiAgICovXG4gIHVybHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWxheXMua2V5cygpKTtcbiAgfVxufTtcblxuLy8gc3JjL3VzZXIvaW5kZXgudHNcbmltcG9ydCB7IG5pcDE5IGFzIG5pcDE5NSB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL251dHphcC9taW50LWxpc3QudHNcbnZhciBOREtDYXNodU1pbnRMaXN0ID0gY2xhc3MgX05ES0Nhc2h1TWludExpc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMTAwMTkgLyogQ2FzaHVNaW50TGlzdCAqLztcbiAgc3RhdGljIGtpbmRzID0gWzEwMDE5IC8qIENhc2h1TWludExpc3QgKi9dO1xuICBfcDJwaztcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMTAwMTkgLyogQ2FzaHVNaW50TGlzdCAqLztcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0Nhc2h1TWludExpc3QoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgc2V0IHJlbGF5cyh1cmxzKSB7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gdFswXSAhPT0gXCJyZWxheVwiKTtcbiAgICBmb3IgKGNvbnN0IHVybCBvZiB1cmxzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJyZWxheVwiLCB1cmxdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlbGF5cygpIHtcbiAgICBjb25zdCByID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcInJlbGF5XCIpIHtcbiAgICAgICAgci5wdXNoKHRhZ1sxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHNldCBtaW50cyh1cmxzKSB7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gdFswXSAhPT0gXCJtaW50XCIpO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIHVybHMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcIm1pbnRcIiwgdXJsXSk7XG4gICAgfVxuICB9XG4gIGdldCBtaW50cygpIHtcbiAgICBjb25zdCByID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcIm1pbnRcIikge1xuICAgICAgICByLnB1c2godGFnWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChyKSk7XG4gIH1cbiAgZ2V0IHAycGsoKSB7XG4gICAgaWYgKHRoaXMuX3AycGspIHtcbiAgICAgIHJldHVybiB0aGlzLl9wMnBrO1xuICAgIH1cbiAgICB0aGlzLl9wMnBrID0gdGhpcy50YWdWYWx1ZShcInB1YmtleVwiKSA/PyB0aGlzLnB1YmtleTtcbiAgICByZXR1cm4gdGhpcy5fcDJwaztcbiAgfVxuICBzZXQgcDJwayhwdWJrZXkpIHtcbiAgICB0aGlzLl9wMnBrID0gcHVia2V5O1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicHVia2V5XCIpO1xuICAgIGlmIChwdWJrZXkpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInB1YmtleVwiLCBwdWJrZXldKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlbGF5U2V0KCkge1xuICAgIHJldHVybiBOREtSZWxheVNldC5mcm9tUmVsYXlVcmxzKHRoaXMucmVsYXlzLCB0aGlzLm5kayk7XG4gIH1cbn07XG5cbi8vIHNyYy9zdWJzY3JpcHRpb24vaW5kZXgudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI0IH0gZnJvbSBcInRzZWVwXCI7XG5cbi8vIHNyYy9ldmVudHMva2luZHMvYXJ0aWNsZS50c1xudmFyIE5ES0FydGljbGUgPSBjbGFzcyBfTkRLQXJ0aWNsZSBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGtpbmQgPSAzMDAyMyAvKiBBcnRpY2xlICovO1xuICBzdGF0aWMga2luZHMgPSBbMzAwMjMgLyogQXJ0aWNsZSAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMwMDIzIC8qIEFydGljbGUgKi87XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOREtBcnRpY2xlIGZyb20gYW4gZXhpc3RpbmcgTkRLRXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBOREtFdmVudCB0byBjcmVhdGUgdGhlIE5ES0FydGljbGUgZnJvbS5cbiAgICogQHJldHVybnMgTkRLQXJ0aWNsZVxuICAgKi9cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtBcnRpY2xlKGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRpdGxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBhcnRpY2xlIHRpdGxlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRpdGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gdGl0bGUgLSBUaGUgdGl0bGUgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZS5cbiAgICovXG4gIHNldCB0aXRsZSh0aXRsZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHRpdGxlKSB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB0aXRsZV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIGltYWdlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBhcnRpY2xlIGltYWdlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBpbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImltYWdlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIGltYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gaW1hZ2UgLSBUaGUgaW1hZ2UgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZS5cbiAgICovXG4gIHNldCBpbWFnZShpbWFnZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiaW1hZ2VcIik7XG4gICAgaWYgKGltYWdlKSB0aGlzLnRhZ3MucHVzaChbXCJpbWFnZVwiLCBpbWFnZV0pO1xuICB9XG4gIGdldCBzdW1tYXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwic3VtbWFyeVwiKTtcbiAgfVxuICBzZXQgc3VtbWFyeShzdW1tYXJ5KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJzdW1tYXJ5XCIpO1xuICAgIGlmIChzdW1tYXJ5KSB0aGlzLnRhZ3MucHVzaChbXCJzdW1tYXJ5XCIsIHN1bW1hcnldKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYXJ0aWNsZSdzIHB1YmxpY2F0aW9uIHRpbWVzdGFtcC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH0gLSBUaGUgVW5peCB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgYXJ0aWNsZSB3YXMgcHVibGlzaGVkIG9yIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBwdWJsaXNoZWRfYXQoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdWYWx1ZShcInB1Ymxpc2hlZF9hdFwiKTtcbiAgICBpZiAodGFnKSB7XG4gICAgICBsZXQgdmFsID0gTnVtYmVyLnBhcnNlSW50KHRhZyk7XG4gICAgICBpZiAodmFsID4gMWUxMikge1xuICAgICAgICB2YWwgPSBNYXRoLmZsb29yKHZhbCAvIDFlMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlJ3MgcHVibGljYXRpb24gdGltZXN0YW1wLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gdGltZXN0YW1wIC0gVGhlIFVuaXggdGltZXN0YW1wIHRvIHNldCBmb3IgdGhlIGFydGljbGUncyBwdWJsaWNhdGlvbiBkYXRlLlxuICAgKi9cbiAgc2V0IHB1Ymxpc2hlZF9hdCh0aW1lc3RhbXApIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInB1Ymxpc2hlZF9hdFwiKTtcbiAgICBpZiAodGltZXN0YW1wICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInB1Ymxpc2hlZF9hdFwiLCB0aW1lc3RhbXAudG9TdHJpbmcoKV0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvbnRlbnQgdGFncyBmb3IgdGhlIGFydGljbGUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGZpcnN0IGNoZWNrcyBhbmQgc2V0cyB0aGUgcHVibGljYXRpb24gZGF0ZSBpZiBub3QgYXZhaWxhYmxlLFxuICAgKiBhbmQgdGhlbiBnZW5lcmF0ZXMgY29udGVudCB0YWdzIGJhc2VkIG9uIHRoZSBiYXNlIE5ES0V2ZW50IGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gLSBUaGUgZ2VuZXJhdGVkIGNvbnRlbnQgdGFncy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlVGFncygpIHtcbiAgICBzdXBlci5nZW5lcmF0ZVRhZ3MoKTtcbiAgICBpZiAoIXRoaXMucHVibGlzaGVkX2F0KSB7XG4gICAgICB0aGlzLnB1Ymxpc2hlZF9hdCA9IHRoaXMuY3JlYXRlZF9hdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlJ3MgVVJMLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBhcnRpY2xlJ3MgVVJMIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ1cmxcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGFydGljbGUncyBVUkwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSB1cmwgLSBUaGUgVVJMIHRvIHNldCBmb3IgdGhlIGFydGljbGUuXG4gICAqL1xuICBzZXQgdXJsKHVybCkge1xuICAgIGlmICh1cmwpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInVybFwiLCB1cmxdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVUYWcoXCJ1cmxcIik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2Nhc2h1L3Rva2VuLnRzXG5mdW5jdGlvbiBwcm9vZnNUb3RhbEJhbGFuY2UocHJvb2ZzKSB7XG4gIHJldHVybiBwcm9vZnMucmVkdWNlKChhY2MsIHByb29mKSA9PiB7XG4gICAgaWYgKHByb29mLmFtb3VudCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInByb29mIGFtb3VudCBpcyBuZWdhdGl2ZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYyArIHByb29mLmFtb3VudDtcbiAgfSwgMCk7XG59XG52YXIgTkRLQ2FzaHVUb2tlbiA9IGNsYXNzIF9OREtDYXNodVRva2VuIGV4dGVuZHMgTkRLRXZlbnQge1xuICBfcHJvb2ZzID0gW107XG4gIF9taW50O1xuICBzdGF0aWMga2luZCA9IDczNzUgLyogQ2FzaHVUb2tlbiAqLztcbiAgc3RhdGljIGtpbmRzID0gWzczNzUgLyogQ2FzaHVUb2tlbiAqL107XG4gIC8qKlxuICAgKiBUb2tlbnMgdGhhdCB0aGlzIHRva2VuIHN1cGVyc2VlZHNcbiAgICovXG4gIF9kZWxldGVzID0gW107XG4gIG9yaWdpbmFsO1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIobmRrLCBldmVudCk7XG4gICAgdGhpcy5raW5kID8/PSA3Mzc1IC8qIENhc2h1VG9rZW4gKi87XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb20oZXZlbnQpIHtcbiAgICBjb25zdCB0b2tlbiA9IG5ldyBfTkRLQ2FzaHVUb2tlbihldmVudC5uZGssIGV2ZW50KTtcbiAgICB0b2tlbi5vcmlnaW5hbCA9IGV2ZW50O1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0b2tlbi5kZWNyeXB0KCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0b2tlbi5jb250ZW50ID0gdG9rZW4ub3JpZ2luYWwuY29udGVudDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBKU09OLnBhcnNlKHRva2VuLmNvbnRlbnQpO1xuICAgICAgdG9rZW4ucHJvb2ZzID0gY29udGVudC5wcm9vZnM7XG4gICAgICB0b2tlbi5taW50ID0gY29udGVudC5taW50ID8/IHRva2VuLnRhZ1ZhbHVlKFwibWludFwiKTtcbiAgICAgIHRva2VuLmRlbGV0ZWRUb2tlbnMgPSBjb250ZW50LmRlbCA/PyBbXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0b2tlbi5wcm9vZnMpKSByZXR1cm47XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG4gIGdldCBwcm9vZnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb29mcztcbiAgfVxuICBzZXQgcHJvb2ZzKHByb29mcykge1xuICAgIGNvbnN0IGNzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLl9wcm9vZnMgPSBwcm9vZnMuZmlsdGVyKChwcm9vZikgPT4ge1xuICAgICAgaWYgKGNzLmhhcyhwcm9vZi5DKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJQYXNzZWQgaW4gcHJvb2ZzIGhhZCBkdXBsaWNhdGVzLCBpZ25vcmluZ1wiLCBwcm9vZi5DKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHByb29mLmFtb3VudCA8IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCBwcm9vZiB3aXRoIG5lZ2F0aXZlIGFtb3VudFwiLCBwcm9vZik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNzLmFkZChwcm9vZi5DKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pLm1hcCh0aGlzLmNsZWFuUHJvb2YpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbWluaW1hbCBwcm9vZiBvYmplY3Qgd2l0aCBvbmx5IGVzc2VudGlhbCBwcm9wZXJ0aWVzXG4gICAqL1xuICBjbGVhblByb29mKHByb29mKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBwcm9vZi5pZCxcbiAgICAgIGFtb3VudDogcHJvb2YuYW1vdW50LFxuICAgICAgQzogcHJvb2YuQyxcbiAgICAgIHNlY3JldDogcHJvb2Yuc2VjcmV0XG4gICAgfTtcbiAgfVxuICBhc3luYyB0b05vc3RyRXZlbnQocHVia2V5KSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwibm8gbmRrXCIpO1xuICAgIGlmICghdGhpcy5uZGsuc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBzaWduZXJcIik7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIHByb29mczogdGhpcy5wcm9vZnMubWFwKHRoaXMuY2xlYW5Qcm9vZiksXG4gICAgICBtaW50OiB0aGlzLm1pbnQsXG4gICAgICBkZWw6IHRoaXMuZGVsZXRlZFRva2VucyA/PyBbXVxuICAgIH07XG4gICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci51c2VyKCk7XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIsIHZvaWQgMCwgXCJuaXA0NFwiKTtcbiAgICByZXR1cm4gc3VwZXIudG9Ob3N0ckV2ZW50KHB1YmtleSk7XG4gIH1cbiAgc2V0IG1pbnQobWludCkge1xuICAgIHRoaXMuX21pbnQgPSBtaW50O1xuICB9XG4gIGdldCBtaW50KCkge1xuICAgIHJldHVybiB0aGlzLl9taW50O1xuICB9XG4gIC8qKlxuICAgKiBUb2tlbnMgdGhhdCB3ZXJlIGRlbGV0ZWQgYnkgdGhlIGNyZWF0aW9uIG9mIHRoaXMgdG9rZW4uXG4gICAqL1xuICBnZXQgZGVsZXRlZFRva2VucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVsZXRlcztcbiAgfVxuICAvKipcbiAgICogTWFya3MgdG9rZW5zIHRoYXQgd2VyZSBkZWxldGVkIGJ5IHRoZSBjcmVhdGlvbiBvZiB0aGlzIHRva2VuLlxuICAgKi9cbiAgc2V0IGRlbGV0ZWRUb2tlbnModG9rZW5JZHMpIHtcbiAgICB0aGlzLl9kZWxldGVzID0gdG9rZW5JZHM7XG4gIH1cbiAgZ2V0IGFtb3VudCgpIHtcbiAgICByZXR1cm4gcHJvb2ZzVG90YWxCYWxhbmNlKHRoaXMucHJvb2ZzKTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgIGlmICh0aGlzLm9yaWdpbmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbC5wdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvaGlnaGxpZ2h0LnRzXG5pbXBvcnQgeyBuaXAxOSBhcyBuaXAxOTMgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbnZhciBOREtIaWdobGlnaHQgPSBjbGFzcyBfTkRLSGlnaGxpZ2h0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBfYXJ0aWNsZTtcbiAgc3RhdGljIGtpbmQgPSA5ODAyIC8qIEhpZ2hsaWdodCAqLztcbiAgc3RhdGljIGtpbmRzID0gWzk4MDIgLyogSGlnaGxpZ2h0ICovXTtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gOTgwMiAvKiBIaWdobGlnaHQgKi87XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtIaWdobGlnaHQoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInJcIik7XG4gIH1cbiAgLyoqXG4gICAqIENvbnRleHQgdGFnLlxuICAgKi9cbiAgc2V0IGNvbnRleHQoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKFt0YWcsIF92YWx1ZV0pID0+IHRhZyAhPT0gXCJjb250ZXh0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKChbdGFnLCBfdmFsdWVdKSA9PiB0YWcgIT09IFwiY29udGV4dFwiKTtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcImNvbnRleHRcIiwgY29udGV4dF0pO1xuICAgIH1cbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbmQoKFt0YWcsIF92YWx1ZV0pID0+IHRhZyA9PT0gXCJjb250ZXh0XCIpPy5bMV0gPz8gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBXaWxsIHJldHVybiB0aGUgYXJ0aWNsZSBVUkwgb3IgTkRLRXZlbnQgaWYgdGhleSBoYXZlIGFscmVhZHkgYmVlblxuICAgKiBzZXQgKGl0IHdvbid0IGF0dGVtcHQgdG8gbG9hZCByZW1vdGUgZXZlbnRzKVxuICAgKi9cbiAgZ2V0IGFydGljbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FydGljbGU7XG4gIH1cbiAgLyoqXG4gICAqIEFydGljbGUgdGhlIGhpZ2hsaWdodCBpcyBjb21pbmcgZnJvbS5cbiAgICpcbiAgICogQHBhcmFtIGFydGljbGUgQXJ0aWNsZSBVUkwgb3IgTkRLRXZlbnQuXG4gICAqL1xuICBzZXQgYXJ0aWNsZShhcnRpY2xlKSB7XG4gICAgdGhpcy5fYXJ0aWNsZSA9IGFydGljbGU7XG4gICAgaWYgKHR5cGVvZiBhcnRpY2xlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJyXCIsIGFydGljbGVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWcoYXJ0aWNsZSk7XG4gICAgfVxuICB9XG4gIGdldEFydGljbGVUYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiYVwiKVswXSB8fCB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIilbMF0gfHwgdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJyXCIpWzBdO1xuICB9XG4gIGFzeW5jIGdldEFydGljbGUoKSB7XG4gICAgaWYgKHRoaXMuX2FydGljbGUgIT09IHZvaWQgMCkgcmV0dXJuIHRoaXMuX2FydGljbGU7XG4gICAgbGV0IHRhZ2dlZEJlY2gzMjtcbiAgICBjb25zdCBhcnRpY2xlVGFnID0gdGhpcy5nZXRBcnRpY2xlVGFnKCk7XG4gICAgaWYgKCFhcnRpY2xlVGFnKSByZXR1cm4gdm9pZCAwO1xuICAgIHN3aXRjaCAoYXJ0aWNsZVRhZ1swXSkge1xuICAgICAgY2FzZSBcImFcIjoge1xuICAgICAgICBjb25zdCBba2luZCwgcHVia2V5LCBpZGVudGlmaWVyXSA9IGFydGljbGVUYWdbMV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICB0YWdnZWRCZWNoMzIgPSBuaXAxOTMubmFkZHJFbmNvZGUoe1xuICAgICAgICAgIGtpbmQ6IE51bWJlci5wYXJzZUludChraW5kKSxcbiAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgaWRlbnRpZmllclxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZVwiOlxuICAgICAgICB0YWdnZWRCZWNoMzIgPSBuaXAxOTMubm90ZUVuY29kZShhcnRpY2xlVGFnWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiclwiOlxuICAgICAgICB0aGlzLl9hcnRpY2xlID0gYXJ0aWNsZVRhZ1sxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0YWdnZWRCZWNoMzIpIHtcbiAgICAgIGxldCBhID0gYXdhaXQgdGhpcy5uZGs/LmZldGNoRXZlbnQodGFnZ2VkQmVjaDMyKTtcbiAgICAgIGlmIChhKSB7XG4gICAgICAgIGlmIChhLmtpbmQgPT09IDMwMDIzIC8qIEFydGljbGUgKi8pIHtcbiAgICAgICAgICBhID0gTkRLQXJ0aWNsZS5mcm9tKGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FydGljbGUgPSBhO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYXJ0aWNsZTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2ltZXRhLnRzXG5mdW5jdGlvbiBtYXBJbWV0YVRhZyh0YWcpIHtcbiAgY29uc3QgZGF0YSA9IHt9O1xuICBpZiAodGFnLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IHBhcnRzID0gdGFnWzFdLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCBrZXkgPSBwYXJ0c1tpXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcGFydHNbaSArIDFdO1xuICAgICAgaWYgKGtleSA9PT0gXCJmYWxsYmFja1wiKSB7XG4gICAgICAgIGlmICghZGF0YS5mYWxsYmFjaykgZGF0YS5mYWxsYmFjayA9IFtdO1xuICAgICAgICBkYXRhLmZhbGxiYWNrLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGNvbnN0IHRhZ3MgPSB0YWcuc2xpY2UoMSk7XG4gIGZvciAoY29uc3QgdmFsIG9mIHRhZ3MpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHZhbC5zcGxpdChcIiBcIik7XG4gICAgY29uc3Qga2V5ID0gcGFydHNbMF07XG4gICAgY29uc3QgdmFsdWUgPSBwYXJ0cy5zbGljZSgxKS5qb2luKFwiIFwiKTtcbiAgICBpZiAoa2V5ID09PSBcImZhbGxiYWNrXCIpIHtcbiAgICAgIGlmICghZGF0YS5mYWxsYmFjaykgZGF0YS5mYWxsYmFjayA9IFtdO1xuICAgICAgZGF0YS5mYWxsYmFjay5wdXNoKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gaW1ldGFUYWdUb1RhZyhpbWV0YSkge1xuICBjb25zdCB0YWcgPSBbXCJpbWV0YVwiXTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW1ldGEpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgdGFnLnB1c2goYCR7a2V5fSAke3Z9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgdGFnLnB1c2goYCR7a2V5fSAke3ZhbHVlfWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFnO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2ltYWdlLnRzXG52YXIgTkRLSW1hZ2UgPSBjbGFzcyBfTkRLSW1hZ2UgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMjAgLyogSW1hZ2UgKi87XG4gIHN0YXRpYyBraW5kcyA9IFsyMCAvKiBJbWFnZSAqL107XG4gIF9pbWV0YXM7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDIwIC8qIEltYWdlICovO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTkRLSW1hZ2UgZnJvbSBhbiBleGlzdGluZyBOREtFdmVudC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IE5ES0V2ZW50IHRvIGNyZWF0ZSB0aGUgTkRLSW1hZ2UgZnJvbS5cbiAgICogQHJldHVybnMgTkRLSW1hZ2VcbiAgICovXG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLSW1hZ2UoZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWV0YXMubGVuZ3RoID4gMDtcbiAgfVxuICBnZXQgaW1ldGFzKCkge1xuICAgIGlmICh0aGlzLl9pbWV0YXMpIHJldHVybiB0aGlzLl9pbWV0YXM7XG4gICAgdGhpcy5faW1ldGFzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiaW1ldGFcIikubWFwKG1hcEltZXRhVGFnKS5maWx0ZXIoKGltZXRhKSA9PiAhIWltZXRhLnVybCk7XG4gICAgcmV0dXJuIHRoaXMuX2ltZXRhcztcbiAgfVxuICBzZXQgaW1ldGFzKHRhZ3MpIHtcbiAgICB0aGlzLl9pbWV0YXMgPSB0YWdzO1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcImltZXRhXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKC4uLnRhZ3MubWFwKGltZXRhVGFnVG9UYWcpKTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9saXN0cy9pbmRleC50c1xudmFyIE5ES0xpc3QgPSBjbGFzcyBfTkRLTGlzdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgX2VuY3J5cHRlZFRhZ3M7XG4gIHN0YXRpYyBraW5kcyA9IFtcbiAgICAxMDA2MyAvKiBCbG9zc29tTGlzdCAqLyxcbiAgICAzMDAwMSAvKiBDYXRlZ29yaXplZEJvb2ttYXJrTGlzdCAqLyxcbiAgICAxMDAwNCAvKiBDb21tdW5pdHlMaXN0ICovLFxuICAgIDEwMDUwIC8qIERpcmVjdE1lc3NhZ2VSZWNlaXZlUmVsYXlMaXN0ICovLFxuICAgIDEwMDMwIC8qIEVtb2ppTGlzdCAqLyxcbiAgICAxMDAxNSAvKiBJbnRlcmVzdExpc3QgKi8sXG4gICAgMTAwMDEgLyogUGluTGlzdCAqLyxcbiAgICAxMDAwMiAvKiBSZWxheUxpc3QgKi8sXG4gICAgMTAwMDcgLyogU2VhcmNoUmVsYXlMaXN0ICovLFxuICAgIDEwMDA2IC8qIEJsb2NrUmVsYXlMaXN0ICovLFxuICAgIDEwMDAzIC8qIEJvb2ttYXJrTGlzdCAqL1xuICBdO1xuICAvKipcbiAgICogU3RvcmVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGNvbnRlbnQgd2FzIGJlZm9yZSBkZWNyeXB0aW9uXG4gICAqIHRvIGV4cGlyZSB0aGUgY2FjaGUgd2hlbiB0aGUgY29udGVudCBjaGFuZ2VzLlxuICAgKi9cbiAgZW5jcnlwdGVkVGFnc0xlbmd0aDtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzAwMDEgLyogQ2F0ZWdvcml6ZWRCb29rbWFya0xpc3QgKi87XG4gIH1cbiAgLyoqXG4gICAqIFdyYXAgYSBOREtFdmVudCBpbnRvIGEgTkRLTGlzdFxuICAgKi9cbiAgc3RhdGljIGZyb20obmRrRXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtMaXN0KG5ka0V2ZW50Lm5kaywgbmRrRXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0aXRsZSBvZiB0aGUgbGlzdC4gRmFsbHMgYmFjayBvbiBmZXRjaGluZyB0aGUgbmFtZSB0YWcgdmFsdWUuXG4gICAqL1xuICBnZXQgdGl0bGUoKSB7XG4gICAgY29uc3QgdGl0bGVUYWcgPSB0aGlzLnRhZ1ZhbHVlKFwidGl0bGVcIikgfHwgdGhpcy50YWdWYWx1ZShcIm5hbWVcIik7XG4gICAgaWYgKHRpdGxlVGFnKSByZXR1cm4gdGl0bGVUYWc7XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMyAvKiBDb250YWN0cyAqLykge1xuICAgICAgcmV0dXJuIFwiQ29udGFjdHNcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMWU0IC8qIE11dGVMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJNdXRlXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDAxIC8qIFBpbkxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIlBpbm5lZCBOb3Rlc1wiO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSAxMDAwMiAvKiBSZWxheUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIlJlbGF5IE1ldGFkYXRhXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDAzIC8qIEJvb2ttYXJrTGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiQm9va21hcmtzXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDA0IC8qIENvbW11bml0eUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIkNvbW11bml0aWVzXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDA1IC8qIFB1YmxpY0NoYXRMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJQdWJsaWMgQ2hhdHNcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMTAwMDYgLyogQmxvY2tSZWxheUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIkJsb2NrZWQgUmVsYXlzXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDA3IC8qIFNlYXJjaFJlbGF5TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiU2VhcmNoIFJlbGF5c1wiO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSAxMDA1MCAvKiBEaXJlY3RNZXNzYWdlUmVjZWl2ZVJlbGF5TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiRGlyZWN0IE1lc3NhZ2UgUmVjZWl2ZSBSZWxheXNcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMTAwMTUgLyogSW50ZXJlc3RMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJJbnRlcmVzdHNcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMTAwMzAgLyogRW1vamlMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJFbW9qaXNcIjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0aXRsZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIHNldCB0aXRsZSh0aXRsZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFtcInRpdGxlXCIsIFwibmFtZVwiXSk7XG4gICAgaWYgKHRpdGxlKSB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB0aXRsZV0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBsaXN0LlxuICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIFwidGl0bGVcIiBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5hbWUgb2YgdGhlIGxpc3QuXG4gICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgXCJ0aXRsZVwiIGluc3RlYWQuIFRoaXMgbWV0aG9kIHdpbGwgdXNlIHRoZSBgdGl0bGVgIHRhZyBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0IG5hbWUobmFtZSkge1xuICAgIHRoaXMudGl0bGUgPSBuYW1lO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImRlc2NyaXB0aW9uXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgbGlzdC5cbiAgICovXG4gIHNldCBkZXNjcmlwdGlvbihuYW1lKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkZXNjcmlwdGlvblwiKTtcbiAgICBpZiAobmFtZSkgdGhpcy50YWdzLnB1c2goW1wiZGVzY3JpcHRpb25cIiwgbmFtZV0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbWFnZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGdldCBpbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImltYWdlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbWFnZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIHNldCBpbWFnZShuYW1lKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJpbWFnZVwiKTtcbiAgICBpZiAobmFtZSkgdGhpcy50YWdzLnB1c2goW1wiaW1hZ2VcIiwgbmFtZV0pO1xuICB9XG4gIGlzRW5jcnlwdGVkVGFnc0NhY2hlVmFsaWQoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuX2VuY3J5cHRlZFRhZ3MgJiYgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID09PSB0aGlzLmNvbnRlbnQubGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVjcnlwdGVkIGNvbnRlbnQgb2YgdGhlIGxpc3QuXG4gICAqL1xuICBhc3luYyBlbmNyeXB0ZWRUYWdzKHVzZUNhY2hlID0gdHJ1ZSkge1xuICAgIGlmICh1c2VDYWNoZSAmJiB0aGlzLmlzRW5jcnlwdGVkVGFnc0NhY2hlVmFsaWQoKSkgcmV0dXJuIHRoaXMuX2VuY3J5cHRlZFRhZ3M7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBzZXRcIik7XG4gICAgaWYgKCF0aGlzLm5kay5zaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5ESyBzaWduZXIgbm90IHNldFwiKTtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLnVzZXIoKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZGVjcnlwdGVkQ29udGVudCA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci5kZWNyeXB0KHVzZXIsIHRoaXMuY29udGVudCk7XG4gICAgICAgICAgY29uc3QgYSA9IEpTT04ucGFyc2UoZGVjcnlwdGVkQ29udGVudCk7XG4gICAgICAgICAgaWYgKGE/LlswXSkge1xuICAgICAgICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmNyeXB0ZWRUYWdzID0gYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZW5jcnlwdGVkVGFncyA9IFtdO1xuICAgICAgICB9IGNhdGNoIChfZSkge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGVuIHRvIHZhbGlkYXRlIHRoYXQgYSB0YWcgaXMgdmFsaWQgZm9yIHRoaXMgbGlzdC5cbiAgICpcbiAgICogKGkuZS4gdGhlIE5ES1BlcnNvbkxpc3QgY2FuIHZhbGlkYXRlIHRoYXQgaXRlbXMgYXJlIE5ES1VzZXIgaW5zdGFuY2VzKVxuICAgKi9cbiAgdmFsaWRhdGVUYWcoX3RhZ1ZhbHVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0SXRlbXModHlwZSkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gdHlwZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVuZWNyeXB0ZWQgaXRlbXMgaW4gdGhpcyBsaXN0LlxuICAgKi9cbiAgZ2V0IGl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0KSA9PiB7XG4gICAgICByZXR1cm4gIVtcbiAgICAgICAgXCJkXCIsXG4gICAgICAgIFwiTFwiLFxuICAgICAgICBcImxcIixcbiAgICAgICAgXCJ0aXRsZVwiLFxuICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiLFxuICAgICAgICBcInB1Ymxpc2hlZF9hdFwiLFxuICAgICAgICBcInN1bW1hcnlcIixcbiAgICAgICAgXCJpbWFnZVwiLFxuICAgICAgICBcInRodW1iXCIsXG4gICAgICAgIFwiYWx0XCIsXG4gICAgICAgIFwiZXhwaXJhdGlvblwiLFxuICAgICAgICBcInN1YmplY3RcIixcbiAgICAgICAgXCJjbGllbnRcIlxuICAgICAgXS5pbmNsdWRlcyh0WzBdKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG5ldyBpdGVtIHRvIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0gcmVsYXkgUmVsYXkgdG8gYWRkXG4gICAqIEBwYXJhbSBtYXJrIE9wdGlvbmFsIG1hcmsgdG8gYWRkIHRvIHRoZSBpdGVtXG4gICAqIEBwYXJhbSBlbmNyeXB0ZWQgV2hldGhlciB0byBlbmNyeXB0IHRoZSBpdGVtXG4gICAqIEBwYXJhbSBwb3NpdGlvbiBXaGVyZSB0byBhZGQgdGhlIGl0ZW0gaW4gdGhlIGxpc3QgKHRvcCBvciBib3R0b20pXG4gICAqL1xuICBhc3luYyBhZGRJdGVtKGl0ZW0sIG1hcmsgPSB2b2lkIDAsIGVuY3J5cHRlZCA9IGZhbHNlLCBwb3NpdGlvbiA9IFwiYm90dG9tXCIpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IHNldFwiKTtcbiAgICBpZiAoIXRoaXMubmRrLnNpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwiTkRLIHNpZ25lciBub3Qgc2V0XCIpO1xuICAgIGxldCB0YWdzO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICAgIHRhZ3MgPSBbaXRlbS50YWdSZWZlcmVuY2UobWFyayldO1xuICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES1VzZXIpIHtcbiAgICAgIHRhZ3MgPSBpdGVtLnJlZmVyZW5jZVRhZ3MoKTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtSZWxheSkge1xuICAgICAgdGFncyA9IGl0ZW0ucmVmZXJlbmNlVGFncygpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgdGFncyA9IFtpdGVtXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvYmplY3QgdHlwZVwiKTtcbiAgICB9XG4gICAgaWYgKG1hcmspIHRhZ3NbMF0ucHVzaChtYXJrKTtcbiAgICBpZiAoZW5jcnlwdGVkKSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLnVzZXIoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRMaXN0ID0gYXdhaXQgdGhpcy5lbmNyeXB0ZWRUYWdzKCk7XG4gICAgICBpZiAocG9zaXRpb24gPT09IFwidG9wXCIpIGN1cnJlbnRMaXN0LnVuc2hpZnQoLi4udGFncyk7XG4gICAgICBlbHNlIGN1cnJlbnRMaXN0LnB1c2goLi4udGFncyk7XG4gICAgICB0aGlzLl9lbmNyeXB0ZWRUYWdzID0gY3VycmVudExpc3Q7XG4gICAgICB0aGlzLmVuY3J5cHRlZFRhZ3NMZW5ndGggPSB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoY3VycmVudExpc3QpO1xuICAgICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09IFwidG9wXCIpIHRoaXMudGFncy51bnNoaWZ0KC4uLnRhZ3MpO1xuICAgICAgZWxzZSB0aGlzLnRhZ3MucHVzaCguLi50YWdzKTtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVkX2F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBsaXN0IGZyb20gYm90aCB0aGUgZW5jcnlwdGVkIGFuZCB1bmVuY3J5cHRlZCBsaXN0cy5cbiAgICogQHBhcmFtIHZhbHVlIHZhbHVlIG9mIGl0ZW0gdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3RcbiAgICogQHBhcmFtIHB1Ymxpc2ggd2hldGhlciB0byBwdWJsaXNoIHRoZSBjaGFuZ2VcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIHJlbW92ZUl0ZW1CeVZhbHVlKHZhbHVlLCBwdWJsaXNoID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3Qgc2V0XCIpO1xuICAgIGlmICghdGhpcy5uZGsuc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgc2lnbmVyIG5vdCBzZXRcIik7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnRhZ3MuZmluZEluZGV4KCh0YWcpID0+IHRhZ1sxXSA9PT0gdmFsdWUpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLnRhZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3QgZW5jcnlwdGVkVGFncyA9IGF3YWl0IHRoaXMuZW5jcnlwdGVkVGFncygpO1xuICAgIGNvbnN0IGVuY3J5cHRlZEluZGV4ID0gZW5jcnlwdGVkVGFncy5maW5kSW5kZXgoKHRhZykgPT4gdGFnWzFdID09PSB2YWx1ZSk7XG4gICAgaWYgKGVuY3J5cHRlZEluZGV4ID49IDApIHtcbiAgICAgIGVuY3J5cHRlZFRhZ3Muc3BsaWNlKGVuY3J5cHRlZEluZGV4LCAxKTtcbiAgICAgIHRoaXMuX2VuY3J5cHRlZFRhZ3MgPSBlbmNyeXB0ZWRUYWdzO1xuICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGVuY3J5cHRlZFRhZ3MpO1xuICAgICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIpO1xuICAgIH1cbiAgICBpZiAocHVibGlzaCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVibGlzaFJlcGxhY2VhYmxlKCk7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlZF9hdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgaXRlbSB0byByZW1vdmUuXG4gICAqIEBwYXJhbSBlbmNyeXB0ZWQgV2hldGhlciB0byByZW1vdmUgZnJvbSB0aGUgZW5jcnlwdGVkIGxpc3Qgb3Igbm90LlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlSXRlbShpbmRleCwgZW5jcnlwdGVkKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBzZXRcIik7XG4gICAgaWYgKCF0aGlzLm5kay5zaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5ESyBzaWduZXIgbm90IHNldFwiKTtcbiAgICBpZiAoZW5jcnlwdGVkKSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLnVzZXIoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRMaXN0ID0gYXdhaXQgdGhpcy5lbmNyeXB0ZWRUYWdzKCk7XG4gICAgICBjdXJyZW50TGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdGhpcy5fZW5jcnlwdGVkVGFncyA9IGN1cnJlbnRMaXN0O1xuICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRMaXN0KTtcbiAgICAgIGF3YWl0IHRoaXMuZW5jcnlwdCh1c2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlZF9hdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGhhcyhpdGVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMuc29tZSgodGFnKSA9PiB0YWdbMV0gPT09IGl0ZW0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZmlsdGVyIHRoYXQgd2lsbCByZXN1bHQgaW4gZmV0Y2hpbmdcbiAgICogdGhlIGl0ZW1zIG9mIHRoaXMgbGlzdFxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBsaXN0ID0gbmV3IE5ES0xpc3QoLi4uKTtcbiAgICogY29uc3QgZmlsdGVycyA9IGxpc3QuZmlsdGVyRm9ySXRlbXMoKTtcbiAgICogY29uc3QgZXZlbnRzID0gYXdhaXQgbmRrLmZldGNoRXZlbnRzKGZpbHRlcnMpO1xuICAgKi9cbiAgZmlsdGVyRm9ySXRlbXMoKSB7XG4gICAgY29uc3QgaWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBuaXAzM1F1ZXJpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiB0YWdbMV0pIHtcbiAgICAgICAgaWRzLmFkZCh0YWdbMV0pO1xuICAgICAgfSBlbHNlIGlmICh0YWdbMF0gPT09IFwiYVwiICYmIHRhZ1sxXSkge1xuICAgICAgICBjb25zdCBba2luZCwgcHVia2V5LCBkVGFnXSA9IHRhZ1sxXS5zcGxpdChcIjpcIik7XG4gICAgICAgIGlmICgha2luZCB8fCAhcHVia2V5KSBjb250aW51ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gYCR7a2luZH06JHtwdWJrZXl9YDtcbiAgICAgICAgY29uc3QgaXRlbSA9IG5pcDMzUXVlcmllcy5nZXQoa2V5KSB8fCBbXTtcbiAgICAgICAgaXRlbS5wdXNoKGRUYWcgfHwgXCJcIik7XG4gICAgICAgIG5pcDMzUXVlcmllcy5zZXQoa2V5LCBpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlkcy5zaXplID4gMCkge1xuICAgICAgZmlsdGVycy5wdXNoKHsgaWRzOiBBcnJheS5mcm9tKGlkcykgfSk7XG4gICAgfVxuICAgIGlmIChuaXAzM1F1ZXJpZXMuc2l6ZSA+IDApIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVzXSBvZiBuaXAzM1F1ZXJpZXMuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IFtraW5kLCBwdWJrZXldID0ga2V5LnNwbGl0KFwiOlwiKTtcbiAgICAgICAgZmlsdGVycy5wdXNoKHtcbiAgICAgICAgICBraW5kczogW051bWJlci5wYXJzZUludChraW5kKV0sXG4gICAgICAgICAgYXV0aG9yczogW3B1YmtleV0sXG4gICAgICAgICAgXCIjZFwiOiB2YWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJzO1xuICB9XG59O1xudmFyIGxpc3RzX2RlZmF1bHQgPSBOREtMaXN0O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL251dHphcC9pbmRleC50c1xuaW1wb3J0IGRlYnVnMiBmcm9tIFwiZGVidWdcIjtcbnZhciBOREtOdXR6YXAgPSBjbGFzcyBfTkRLTnV0emFwIGV4dGVuZHMgTkRLRXZlbnQge1xuICBkZWJ1ZztcbiAgX3Byb29mcyA9IFtdO1xuICBzdGF0aWMga2luZCA9IDkzMjEgLyogTnV0emFwICovO1xuICBzdGF0aWMga2luZHMgPSBbX05ES051dHphcC5raW5kXTtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gOTMyMSAvKiBOdXR6YXAgKi87XG4gICAgdGhpcy5kZWJ1ZyA9IG5kaz8uZGVidWcuZXh0ZW5kKFwibnV0emFwXCIpID8/IGRlYnVnMihcIm5kazpudXR6YXBcIik7XG4gICAgaWYgKCF0aGlzLmFsdCkgdGhpcy5hbHQgPSBcIlRoaXMgaXMgYSBudXR6YXBcIjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvb2ZUYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwcm9vZlwiKTtcbiAgICAgIGlmIChwcm9vZlRhZ3MubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3Byb29mcyA9IHByb29mVGFncy5tYXAoKHRhZykgPT4gSlNPTi5wYXJzZSh0YWdbMV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Byb29mcyA9IEpTT04ucGFyc2UodGhpcy5jb250ZW50KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICBjb25zdCBlID0gbmV3IF9OREtOdXR6YXAoZXZlbnQubmRrLCBldmVudCk7XG4gICAgaWYgKCFlLl9wcm9vZnMgfHwgIWUuX3Byb29mcy5sZW5ndGgpIHJldHVybjtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBzZXQgY29tbWVudChjb21tZW50KSB7XG4gICAgdGhpcy5jb250ZW50ID0gY29tbWVudCA/PyBcIlwiO1xuICB9XG4gIGdldCBjb21tZW50KCkge1xuICAgIGNvbnN0IGMgPSB0aGlzLnRhZ1ZhbHVlKFwiY29tbWVudFwiKTtcbiAgICBpZiAoYykgcmV0dXJuIGM7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgfVxuICBzZXQgcHJvb2ZzKHByb29mcykge1xuICAgIHRoaXMuX3Byb29mcyA9IHByb29mcztcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSAhPT0gXCJwcm9vZlwiKTtcbiAgICBmb3IgKGNvbnN0IHByb29mIG9mIHByb29mcykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicHJvb2ZcIiwgSlNPTi5zdHJpbmdpZnkocHJvb2YpXSk7XG4gICAgfVxuICB9XG4gIGdldCBwcm9vZnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb29mcztcbiAgfVxuICBnZXQgcmF3UDJwaygpIHtcbiAgICBjb25zdCBmaXJzdFByb29mID0gdGhpcy5wcm9vZnNbMF07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlY3JldCA9IEpTT04ucGFyc2UoZmlyc3RQcm9vZi5zZWNyZXQpO1xuICAgICAgbGV0IHBheWxvYWQ7XG4gICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShzZWNyZXQpO1xuICAgICAgICB0aGlzLmRlYnVnKFwic3RyaW5naWZpZWQgcGF5bG9hZFwiLCBmaXJzdFByb29mLnNlY3JldCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWNyZXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcGF5bG9hZCA9IHNlY3JldDtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpICYmIHBheWxvYWRbMF0gPT09IFwiUDJQS1wiICYmIHBheWxvYWQubGVuZ3RoID4gMSAmJiB0eXBlb2YgcGF5bG9hZFsxXSA9PT0gXCJvYmplY3RcIiAmJiBwYXlsb2FkWzFdICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkWzFdLmRhdGE7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09IFwib2JqZWN0XCIgJiYgcGF5bG9hZCAhPT0gbnVsbCAmJiB0eXBlb2YgcGF5bG9hZFsxXT8uZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gcGF5bG9hZFsxXS5kYXRhO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJlcnJvciBwYXJzaW5nIHAycGsgcHVia2V5XCIsIGUsIHRoaXMucHJvb2ZzWzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcDJwayBwdWJrZXkgdGhhdCBpcyBlbWJlZGRlZCBpbiB0aGUgZmlyc3QgcHJvb2YuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgYSBub3N0ciBwdWJrZXksIG5vdCBhIGNhc2h1IHB1YmtleSAobm8gXCIwMlwiIHByZWZpeClcbiAgICovXG4gIGdldCBwMnBrKCkge1xuICAgIGNvbnN0IHJhd1AycGsgPSB0aGlzLnJhd1AycGs7XG4gICAgaWYgKCFyYXdQMnBrKSByZXR1cm47XG4gICAgcmV0dXJuIHJhd1AycGsuc3RhcnRzV2l0aChcIjAyXCIpID8gcmF3UDJway5zbGljZSgyKSA6IHJhd1AycGs7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbWludCB3aGVyZSB0aGlzIG51dHphcCBwcm9vZnMgZXhpc3RcbiAgICovXG4gIGdldCBtaW50KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwidVwiKTtcbiAgfVxuICBzZXQgbWludCh2YWx1ZSkge1xuICAgIHRoaXMucmVwbGFjZVRhZyhbXCJ1XCIsIHZhbHVlXSk7XG4gIH1cbiAgZ2V0IHVuaXQoKSB7XG4gICAgbGV0IF91bml0ID0gdGhpcy50YWdWYWx1ZShcInVuaXRcIikgPz8gXCJzYXRcIjtcbiAgICBpZiAoX3VuaXQ/LnN0YXJ0c1dpdGgoXCJtc2F0XCIpKSBfdW5pdCA9IFwic2F0XCI7XG4gICAgcmV0dXJuIF91bml0O1xuICB9XG4gIHNldCB1bml0KHZhbHVlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJ1bml0XCIpO1xuICAgIGlmICh2YWx1ZT8uc3RhcnRzV2l0aChcIm1zYXRcIikpIHRocm93IG5ldyBFcnJvcihcIm1zYXQgaXMgbm90IGFsbG93ZWQsIHVzZSBzYXQgZGVub21pbmF0aW9uIGluc3RlYWRcIik7XG4gICAgaWYgKHZhbHVlKSB0aGlzLnRhZyhbXCJ1bml0XCIsIHZhbHVlXSk7XG4gIH1cbiAgZ2V0IGFtb3VudCgpIHtcbiAgICBjb25zdCBhbW91bnQgPSB0aGlzLnByb29mcy5yZWR1Y2UoKHRvdGFsLCBwcm9vZikgPT4gdG90YWwgKyBwcm9vZi5hbW91bnQsIDApO1xuICAgIHJldHVybiBhbW91bnQ7XG4gIH1cbiAgc2VuZGVyID0gdGhpcy5hdXRob3I7XG4gIC8qKlxuICAgKiBTZXQgdGhlIHRhcmdldCBvZiB0aGUgbnV0emFwXG4gICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvZiB0aGUgbnV0emFwIChhIHVzZXIgb3IgYW4gZXZlbnQpXG4gICAqL1xuICBzZXQgdGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+IHRbMF0gIT09IFwicFwiKTtcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKHRhcmdldC50YWdSZWZlcmVuY2UoKSk7XG4gICAgfVxuICB9XG4gIHNldCByZWNpcGllbnRQdWJrZXkocHVia2V5KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwXCIpO1xuICAgIHRoaXMudGFnKFtcInBcIiwgcHVia2V5XSk7XG4gIH1cbiAgZ2V0IHJlY2lwaWVudFB1YmtleSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInBcIik7XG4gIH1cbiAgZ2V0IHJlY2lwaWVudCgpIHtcbiAgICBjb25zdCBwdWJrZXkgPSB0aGlzLnJlY2lwaWVudFB1YmtleTtcbiAgICBpZiAodGhpcy5uZGspIHJldHVybiB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5IH0pO1xuICAgIHJldHVybiBuZXcgTkRLVXNlcih7IHB1YmtleSB9KTtcbiAgfVxuICBhc3luYyB0b05vc3RyRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMudW5pdCA9PT0gXCJtc2F0XCIpIHtcbiAgICAgIHRoaXMudW5pdCA9IFwic2F0XCI7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlVGFnKFwiYW1vdW50XCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImFtb3VudFwiLCB0aGlzLmFtb3VudC50b1N0cmluZygpXSk7XG4gICAgY29uc3QgZXZlbnQgPSBhd2FpdCBzdXBlci50b05vc3RyRXZlbnQoKTtcbiAgICBldmVudC5jb250ZW50ID0gdGhpcy5jb21tZW50O1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIG51dHphcCBjb25mb3JtcyB0byBOSVAtNjFcbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIGxldCBlVGFnQ291bnQgPSAwO1xuICAgIGxldCBwVGFnQ291bnQgPSAwO1xuICAgIGxldCBtaW50VGFnQ291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIpIGVUYWdDb3VudCsrO1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJwXCIpIHBUYWdDb3VudCsrO1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJ1XCIpIG1pbnRUYWdDb3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgLy8gZXhhY3RseSBvbmUgcmVjaXBpZW50IGFuZCBtaW50XG4gICAgICBwVGFnQ291bnQgPT09IDEgJiYgbWludFRhZ0NvdW50ID09PSAxICYmIC8vIG11c3QgaGF2ZSBhdCBtb3N0IG9uZSBlIHRhZ1xuICAgICAgZVRhZ0NvdW50IDw9IDEgJiYgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBwcm9vZlxuICAgICAgdGhpcy5wcm9vZnMubGVuZ3RoID4gMFxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBwcm9vZlAycGsocHJvb2YpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZWNyZXQgPSBKU09OLnBhcnNlKHByb29mLnNlY3JldCk7XG4gICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2Uoc2VjcmV0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWNyZXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHBheWxvYWQgPSBzZWNyZXQ7XG4gICAgfVxuICAgIGNvbnN0IGlzUDJQS0xvY2tlZCA9IHBheWxvYWRbMF0gPT09IFwiUDJQS1wiICYmIHBheWxvYWRbMV0/LmRhdGE7XG4gICAgaWYgKGlzUDJQS0xvY2tlZCkge1xuICAgICAgcmV0dXJuIHBheWxvYWRbMV0uZGF0YTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiZXJyb3IgcGFyc2luZyBwMnBrIHB1YmtleVwiLCBlLCBwcm9vZik7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb29mUDJwa05vc3RyKHByb29mKSB7XG4gIGNvbnN0IHAycGsgPSBwcm9vZlAycGsocHJvb2YpO1xuICBpZiAoIXAycGspIHJldHVybjtcbiAgaWYgKHAycGsuc3RhcnRzV2l0aChcIjAyXCIpICYmIHAycGsubGVuZ3RoID09PSA2NikgcmV0dXJuIHAycGsuc2xpY2UoMik7XG4gIHJldHVybiBwMnBrO1xufVxuZnVuY3Rpb24gY2FzaHVQdWJrZXlUb05vc3RyUHVia2V5KGNhc2h1UHVia2V5KSB7XG4gIGlmIChjYXNodVB1YmtleS5zdGFydHNXaXRoKFwiMDJcIikgJiYgY2FzaHVQdWJrZXkubGVuZ3RoID09PSA2NikgcmV0dXJuIGNhc2h1UHVia2V5LnNsaWNlKDIpO1xuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3NpbXBsZS1ncm91cC9tZW1iZXItbGlzdC50c1xudmFyIE5ES1NpbXBsZUdyb3VwTWVtYmVyTGlzdCA9IGNsYXNzIF9OREtTaW1wbGVHcm91cE1lbWJlckxpc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHJlbGF5U2V0O1xuICBtZW1iZXJTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBzdGF0aWMga2luZCA9IDM5MDAyIC8qIEdyb3VwTWVtYmVycyAqLztcbiAgc3RhdGljIGtpbmRzID0gWzM5MDAyIC8qIEdyb3VwTWVtYmVycyAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDM5MDAyIC8qIEdyb3VwTWVtYmVycyAqLztcbiAgICB0aGlzLm1lbWJlclNldCA9IG5ldyBTZXQodGhpcy5tZW1iZXJzKTtcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1NpbXBsZUdyb3VwTWVtYmVyTGlzdChldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICBnZXQgbWVtYmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICB9XG4gIGhhc01lbWJlcihtZW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5tZW1iZXJTZXQuaGFzKG1lbWJlcik7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpIHtcbiAgICByZWxheVNldCA/Pz0gdGhpcy5yZWxheVNldDtcbiAgICByZXR1cm4gc3VwZXIucHVibGlzaFJlcGxhY2VhYmxlKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc2ltcGxlLWdyb3VwL21ldGFkYXRhLnRzXG52YXIgTkRLU2ltcGxlR3JvdXBNZXRhZGF0YSA9IGNsYXNzIF9OREtTaW1wbGVHcm91cE1ldGFkYXRhIGV4dGVuZHMgTkRLRXZlbnQge1xuICBzdGF0aWMga2luZCA9IDM5ZTMgLyogR3JvdXBNZXRhZGF0YSAqLztcbiAgc3RhdGljIGtpbmRzID0gWzM5ZTMgLyogR3JvdXBNZXRhZGF0YSAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDM5ZTMgLyogR3JvdXBNZXRhZGF0YSAqLztcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1NpbXBsZUdyb3VwTWV0YWRhdGEoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJuYW1lXCIpO1xuICB9XG4gIGdldCBwaWN0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwicGljdHVyZVwiKTtcbiAgfVxuICBnZXQgYWJvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJhYm91dFwiKTtcbiAgfVxuICBnZXQgc2NvcGUoKSB7XG4gICAgaWYgKHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicHVibGljXCIpLmxlbmd0aCA+IDApIHJldHVybiBcInB1YmxpY1wiO1xuICAgIGlmICh0aGlzLmdldE1hdGNoaW5nVGFncyhcInB1YmxpY1wiKS5sZW5ndGggPiAwKSByZXR1cm4gXCJwcml2YXRlXCI7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBzZXQgc2NvcGUoc2NvcGUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInB1YmxpY1wiKTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInByaXZhdGVcIik7XG4gICAgaWYgKHNjb3BlID09PSBcInB1YmxpY1wiKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwdWJsaWNcIiwgXCJcIl0pO1xuICAgIH0gZWxzZSBpZiAoc2NvcGUgPT09IFwicHJpdmF0ZVwiKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwcml2YXRlXCIsIFwiXCJdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFjY2VzcygpIHtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJvcGVuXCIpLmxlbmd0aCA+IDApIHJldHVybiBcIm9wZW5cIjtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJjbG9zZWRcIikubGVuZ3RoID4gMCkgcmV0dXJuIFwiY2xvc2VkXCI7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBzZXQgYWNjZXNzKGFjY2Vzcykge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwib3BlblwiKTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImNsb3NlZFwiKTtcbiAgICBpZiAoYWNjZXNzID09PSBcIm9wZW5cIikge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wib3BlblwiLCBcIlwiXSk7XG4gICAgfSBlbHNlIGlmIChhY2Nlc3MgPT09IFwiY2xvc2VkXCIpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcImNsb3NlZFwiLCBcIlwiXSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3N0b3J5LnRzXG52YXIgTkRLU3RvcnlTdGlja2VyVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ES1N0b3J5U3RpY2tlclR5cGUyKSA9PiB7XG4gIE5ES1N0b3J5U3RpY2tlclR5cGUyW1wiUHVia2V5XCJdID0gXCJwdWJrZXlcIjtcbiAgTkRLU3RvcnlTdGlja2VyVHlwZTJbXCJFdmVudFwiXSA9IFwiZXZlbnRcIjtcbiAgTkRLU3RvcnlTdGlja2VyVHlwZTJbXCJQcm9tcHRcIl0gPSBcInByb21wdFwiO1xuICBOREtTdG9yeVN0aWNrZXJUeXBlMltcIlRleHRcIl0gPSBcInRleHRcIjtcbiAgTkRLU3RvcnlTdGlja2VyVHlwZTJbXCJDb3VudGRvd25cIl0gPSBcImNvdW50ZG93blwiO1xuICByZXR1cm4gTkRLU3RvcnlTdGlja2VyVHlwZTI7XG59KShOREtTdG9yeVN0aWNrZXJUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIHN0clRvUG9zaXRpb24ocG9zaXRpb25TdHIpIHtcbiAgY29uc3QgW3gsIHldID0gcG9zaXRpb25TdHIuc3BsaXQoXCIsXCIpLm1hcChOdW1iZXIpO1xuICByZXR1cm4geyB4LCB5IH07XG59XG5mdW5jdGlvbiBzdHJUb0RpbWVuc2lvbihkaW1lbnNpb25TdHIpIHtcbiAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gZGltZW5zaW9uU3RyLnNwbGl0KFwieFwiKS5tYXAoTnVtYmVyKTtcbiAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCB9O1xufVxudmFyIE5ES1N0b3J5U3RpY2tlciA9IGNsYXNzIF9OREtTdG9yeVN0aWNrZXIge1xuICBzdGF0aWMgVGV4dCA9IFwidGV4dFwiIC8qIFRleHQgKi87XG4gIHN0YXRpYyBQdWJrZXkgPSBcInB1YmtleVwiIC8qIFB1YmtleSAqLztcbiAgc3RhdGljIEV2ZW50ID0gXCJldmVudFwiIC8qIEV2ZW50ICovO1xuICBzdGF0aWMgUHJvbXB0ID0gXCJwcm9tcHRcIiAvKiBQcm9tcHQgKi87XG4gIHN0YXRpYyBDb3VudGRvd24gPSBcImNvdW50ZG93blwiIC8qIENvdW50ZG93biAqLztcbiAgdHlwZTtcbiAgdmFsdWU7XG4gIHBvc2l0aW9uO1xuICBkaW1lbnNpb247XG4gIHByb3BlcnRpZXM7XG4gIGNvbnN0cnVjdG9yKGFyZykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgIGNvbnN0IHRhZyA9IGFyZztcbiAgICAgIGlmICh0YWdbMF0gIT09IFwic3RpY2tlclwiIHx8IHRhZy5sZW5ndGggPCA1KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RpY2tlciB0YWdcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnR5cGUgPSB0YWdbMV07XG4gICAgICB0aGlzLnZhbHVlID0gdGFnWzJdO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IHN0clRvUG9zaXRpb24odGFnWzNdKTtcbiAgICAgIHRoaXMuZGltZW5zaW9uID0gc3RyVG9EaW1lbnNpb24odGFnWzRdKTtcbiAgICAgIGNvbnN0IHByb3BzID0ge307XG4gICAgICBmb3IgKGxldCBpID0gNTsgaSA8IHRhZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHRhZ1tpXS5zcGxpdChcIiBcIik7XG4gICAgICAgIHByb3BzW2tleV0gPSByZXN0LmpvaW4oXCIgXCIpO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnR5cGUgPSBhcmc7XG4gICAgICB0aGlzLnZhbHVlID0gdm9pZCAwO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgdGhpcy5kaW1lbnNpb24gPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb21UYWcodGFnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgX05ES1N0b3J5U3RpY2tlcih0YWcpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGdldCBzdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzPy5zdHlsZTtcbiAgfVxuICBzZXQgc3R5bGUoc3R5bGUpIHtcbiAgICBpZiAoc3R5bGUpIHRoaXMucHJvcGVydGllcyA9IHsgLi4udGhpcy5wcm9wZXJ0aWVzLCBzdHlsZSB9O1xuICAgIGVsc2UgZGVsZXRlIHRoaXMucHJvcGVydGllcz8uc3R5bGU7XG4gIH1cbiAgZ2V0IHJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXM/LnJvdCA/IE51bWJlci5wYXJzZUZsb2F0KHRoaXMucHJvcGVydGllcy5yb3QpIDogdm9pZCAwO1xuICB9XG4gIHNldCByb3RhdGlvbihyb3RhdGlvbikge1xuICAgIGlmIChyb3RhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IC4uLnRoaXMucHJvcGVydGllcywgcm90OiByb3RhdGlvbi50b1N0cmluZygpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnByb3BlcnRpZXM/LnJvdDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgc3RpY2tlciBpcyB2YWxpZC5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgc3RpY2tlciBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzVmFsaWREaW1lbnNpb25zKCkgJiYgdGhpcy5oYXNWYWxpZFBvc2l0aW9uKCk7XG4gIH1cbiAgaGFzVmFsaWREaW1lbnNpb25zID0gKCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5kaW1lbnNpb24ud2lkdGggPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHRoaXMuZGltZW5zaW9uLmhlaWdodCA9PT0gXCJudW1iZXJcIiAmJiAhTnVtYmVyLmlzTmFOKHRoaXMuZGltZW5zaW9uLndpZHRoKSAmJiAhTnVtYmVyLmlzTmFOKHRoaXMuZGltZW5zaW9uLmhlaWdodCk7XG4gIH07XG4gIGhhc1ZhbGlkUG9zaXRpb24gPSAoKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLnBvc2l0aW9uLnggPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHRoaXMucG9zaXRpb24ueSA9PT0gXCJudW1iZXJcIiAmJiAhTnVtYmVyLmlzTmFOKHRoaXMucG9zaXRpb24ueCkgJiYgIU51bWJlci5pc05hTih0aGlzLnBvc2l0aW9uLnkpO1xuICB9O1xuICB0b1RhZygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgY29uc3QgZXJyb3JzID0gW1xuICAgICAgICAhdGhpcy5oYXNWYWxpZERpbWVuc2lvbnMoKSA/IFwiZGltZW5zaW9ucyBpcyBpbnZhbGlkXCIgOiB2b2lkIDAsXG4gICAgICAgICF0aGlzLmhhc1ZhbGlkUG9zaXRpb24oKSA/IFwicG9zaXRpb24gaXMgaW52YWxpZFwiIDogdm9pZCAwXG4gICAgICBdLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGlja2VyOiAke2Vycm9ycy5qb2luKFwiLCBcIil9YCk7XG4gICAgfVxuICAgIGxldCB2YWx1ZTtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSBcImV2ZW50XCIgLyogRXZlbnQgKi86XG4gICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZS50YWdJZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwdWJrZXlcIiAvKiBQdWJrZXkgKi86XG4gICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZS5wdWJrZXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICBjb25zdCB0YWcgPSBbXCJzdGlja2VyXCIsIHRoaXMudHlwZSwgdmFsdWUsIGNvb3JkaW5hdGVzKHRoaXMucG9zaXRpb24pLCBkaW1lbnNpb24odGhpcy5kaW1lbnNpb24pXTtcbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHByb3BWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5wcm9wZXJ0aWVzKSkge1xuICAgICAgICB0YWcucHVzaChgJHtrZXl9ICR7cHJvcFZhbHVlfWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFnO1xuICB9XG59O1xudmFyIE5ES1N0b3J5ID0gY2xhc3MgX05ES1N0b3J5IGV4dGVuZHMgTkRLRXZlbnQge1xuICBzdGF0aWMga2luZCA9IDIzIC8qIFN0b3J5ICovO1xuICBzdGF0aWMga2luZHMgPSBbMjMgLyogU3RvcnkgKi9dO1xuICBfaW1ldGE7XG4gIF9kaW1lbnNpb25zO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAyMyAvKiBTdG9yeSAqLztcbiAgICBpZiAocmF3RXZlbnQpIHtcbiAgICAgIGZvciAoY29uc3QgdGFnIG9mIHJhd0V2ZW50LnRhZ3MpIHtcbiAgICAgICAgc3dpdGNoICh0YWdbMF0pIHtcbiAgICAgICAgICBjYXNlIFwiaW1ldGFcIjpcbiAgICAgICAgICAgIHRoaXMuX2ltZXRhID0gbWFwSW1ldGFUYWcodGFnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJkaW1cIjpcbiAgICAgICAgICAgIHRoaXMuZGltZW5zaW9ucyA9IHN0clRvRGltZW5zaW9uKHRhZ1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIE5ES1N0b3J5IGZyb20gYW4gZXhpc3RpbmcgTkRLRXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBOREtFdmVudCB0byBjcmVhdGUgdGhlIE5ES1N0b3J5IGZyb20uXG4gICAqIEByZXR1cm5zIE5ES1N0b3J5XG4gICAqL1xuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1N0b3J5KGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHN0b3J5IGlzIHZhbGlkIChoYXMgZXhhY3RseSBvbmUgaW1ldGEgdGFnKS5cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiAhIXRoaXMuaW1ldGE7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGZpcnN0IGltZXRhIHRhZyAodGhlcmUgc2hvdWxkIG9ubHkgYmUgb25lKS5cbiAgICovXG4gIGdldCBpbWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW1ldGE7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYSBzaW5nbGUgaW1ldGEgdGFnLCByZXBsYWNpbmcgYW55IGV4aXN0aW5nIG9uZXMuXG4gICAqL1xuICBzZXQgaW1ldGEodGFnKSB7XG4gICAgdGhpcy5faW1ldGEgPSB0YWc7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gdFswXSAhPT0gXCJpbWV0YVwiKTtcbiAgICBpZiAodGFnKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChpbWV0YVRhZ1RvVGFnKHRhZykpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgc3RvcnkgZGltZW5zaW9ucy5cbiAgICpcbiAgICogQHJldHVybnMge05ES1N0b3J5RGltZW5zaW9uIHwgdW5kZWZpbmVkfSAtIFRoZSBzdG9yeSBkaW1lbnNpb25zIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBkaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IGRpbVRhZyA9IHRoaXMudGFnVmFsdWUoXCJkaW1cIik7XG4gICAgaWYgKCFkaW1UYWcpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIHN0clRvRGltZW5zaW9uKGRpbVRhZyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIHN0b3J5IGRpbWVuc2lvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7TkRLU3RvcnlEaW1lbnNpb24gfCB1bmRlZmluZWR9IGRpbWVuc2lvbnMgLSBUaGUgZGltZW5zaW9ucyB0byBzZXQgZm9yIHRoZSBzdG9yeS5cbiAgICovXG4gIHNldCBkaW1lbnNpb25zKGRpbWVuc2lvbnMpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImRpbVwiKTtcbiAgICBpZiAoZGltZW5zaW9ucykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiZGltXCIsIGAke2RpbWVuc2lvbnMud2lkdGh9eCR7ZGltZW5zaW9ucy5oZWlnaHR9YF0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgc3RvcnkgZHVyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9IC0gVGhlIHN0b3J5IGR1cmF0aW9uIGluIHNlY29uZHMgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIGNvbnN0IGR1clRhZyA9IHRoaXMudGFnVmFsdWUoXCJkdXJcIik7XG4gICAgaWYgKCFkdXJUYWcpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIE51bWJlci5wYXJzZUludChkdXJUYWcpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBzdG9yeSBkdXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGR1cmF0aW9uIC0gVGhlIGR1cmF0aW9uIGluIHNlY29uZHMgdG8gc2V0IGZvciB0aGUgc3RvcnkuXG4gICAqL1xuICBzZXQgZHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImR1clwiKTtcbiAgICBpZiAoZHVyYXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiZHVyXCIsIGR1cmF0aW9uLnRvU3RyaW5nKCldKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYWxsIHN0aWNrZXJzIGZyb20gdGhlIHN0b3J5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7TkRLU3RvcnlTdGlja2VyW119IC0gQXJyYXkgb2Ygc3RpY2tlcnMgaW4gdGhlIHN0b3J5LlxuICAgKi9cbiAgZ2V0IHN0aWNrZXJzKCkge1xuICAgIGNvbnN0IHN0aWNrZXJzID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICBpZiAodGFnWzBdICE9PSBcInN0aWNrZXJcIiB8fCB0YWcubGVuZ3RoIDwgNSkgY29udGludWU7XG4gICAgICBjb25zdCBzdGlja2VyID0gTkRLU3RvcnlTdGlja2VyLmZyb21UYWcodGFnKTtcbiAgICAgIGlmIChzdGlja2VyKSBzdGlja2Vycy5wdXNoKHN0aWNrZXIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RpY2tlcnM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBzdGlja2VyIHRvIHRoZSBzdG9yeS5cbiAgICpcbiAgICogQHBhcmFtIHtOREtTdG9yeVN0aWNrZXJ8U3RvcnlTdGlja2VyfSBzdGlja2VyIC0gVGhlIHN0aWNrZXIgdG8gYWRkLlxuICAgKi9cbiAgYWRkU3RpY2tlcihzdGlja2VyKSB7XG4gICAgbGV0IHN0aWNrZXJUb0FkZDtcbiAgICBpZiAoc3RpY2tlciBpbnN0YW5jZW9mIE5ES1N0b3J5U3RpY2tlcikge1xuICAgICAgc3RpY2tlclRvQWRkID0gc3RpY2tlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFnID0gW1xuICAgICAgICBcInN0aWNrZXJcIixcbiAgICAgICAgc3RpY2tlci50eXBlLFxuICAgICAgICB0eXBlb2Ygc3RpY2tlci52YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHN0aWNrZXIudmFsdWUgOiBcIlwiLFxuICAgICAgICBjb29yZGluYXRlcyhzdGlja2VyLnBvc2l0aW9uKSxcbiAgICAgICAgZGltZW5zaW9uKHN0aWNrZXIuZGltZW5zaW9uKVxuICAgICAgXTtcbiAgICAgIGlmIChzdGlja2VyLnByb3BlcnRpZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc3RpY2tlci5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgIHRhZy5wdXNoKGAke2tleX0gJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RpY2tlclRvQWRkID0gbmV3IE5ES1N0b3J5U3RpY2tlcih0YWcpO1xuICAgICAgc3RpY2tlclRvQWRkLnZhbHVlID0gc3RpY2tlci52YWx1ZTtcbiAgICB9XG4gICAgaWYgKHN0aWNrZXJUb0FkZC50eXBlID09PSBcInB1YmtleVwiIC8qIFB1YmtleSAqLykge1xuICAgICAgdGhpcy50YWcoc3RpY2tlclRvQWRkLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHN0aWNrZXJUb0FkZC50eXBlID09PSBcImV2ZW50XCIgLyogRXZlbnQgKi8pIHtcbiAgICAgIHRoaXMudGFnKHN0aWNrZXJUb0FkZC52YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMudGFncy5wdXNoKHN0aWNrZXJUb0FkZC50b1RhZygpKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhIHN0aWNrZXIgZnJvbSB0aGUgc3RvcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgc3RpY2tlciB0byByZW1vdmUuXG4gICAqL1xuICByZW1vdmVTdGlja2VyKGluZGV4KSB7XG4gICAgY29uc3Qgc3RpY2tlcnMgPSB0aGlzLnN0aWNrZXJzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc3RpY2tlcnMubGVuZ3RoKSByZXR1cm47XG4gICAgbGV0IHN0aWNrZXJDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLnRhZ3NbaV1bMF0gPT09IFwic3RpY2tlclwiKSB7XG4gICAgICAgIGlmIChzdGlja2VyQ291bnQgPT09IGluZGV4KSB7XG4gICAgICAgICAgdGhpcy50YWdzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGlja2VyQ291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgY29vcmRpbmF0ZXMgPSAocG9zaXRpb24pID0+IGAke3Bvc2l0aW9uLnh9LCR7cG9zaXRpb24ueX1gO1xudmFyIGRpbWVuc2lvbiA9IChkaW1lbnNpb24yKSA9PiBgJHtkaW1lbnNpb24yLndpZHRofXgke2RpbWVuc2lvbjIuaGVpZ2h0fWA7XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc3Vic2NyaXB0aW9ucy9hbW91bnQudHNcbnZhciBwb3NzaWJsZUludGVydmFsRnJlcXVlbmNpZXMgPSBbXG4gIFwiZGFpbHlcIixcbiAgXCJ3ZWVrbHlcIixcbiAgXCJtb250aGx5XCIsXG4gIFwicXVhcnRlcmx5XCIsXG4gIFwieWVhcmx5XCJcbl07XG5mdW5jdGlvbiBjYWxjdWxhdGVUZXJtRHVyYXRpb25JblNlY29uZHModGVybSkge1xuICBzd2l0Y2ggKHRlcm0pIHtcbiAgICBjYXNlIFwiZGFpbHlcIjpcbiAgICAgIHJldHVybiAyNCAqIDYwICogNjA7XG4gICAgY2FzZSBcIndlZWtseVwiOlxuICAgICAgcmV0dXJuIDcgKiAyNCAqIDYwICogNjA7XG4gICAgY2FzZSBcIm1vbnRobHlcIjpcbiAgICAgIHJldHVybiAzMCAqIDI0ICogNjAgKiA2MDtcbiAgICBjYXNlIFwicXVhcnRlcmx5XCI6XG4gICAgICByZXR1cm4gMyAqIDMwICogMjQgKiA2MCAqIDYwO1xuICAgIGNhc2UgXCJ5ZWFybHlcIjpcbiAgICAgIHJldHVybiAzNjUgKiAyNCAqIDYwICogNjA7XG4gIH1cbn1cbmZ1bmN0aW9uIG5ld0Ftb3VudChhbW91bnQsIGN1cnJlbmN5LCB0ZXJtKSB7XG4gIHJldHVybiBbXCJhbW91bnRcIiwgYW1vdW50LnRvU3RyaW5nKCksIGN1cnJlbmN5LCB0ZXJtXTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGFnVG9TdWJzY3JpcHRpb25BbW91bnQodGFnKSB7XG4gIGNvbnN0IGFtb3VudCA9IE51bWJlci5wYXJzZUludCh0YWdbMV0pO1xuICBpZiAoTnVtYmVyLmlzTmFOKGFtb3VudCkgfHwgYW1vdW50ID09PSB2b2lkIDAgfHwgYW1vdW50ID09PSBudWxsIHx8IGFtb3VudCA8PSAwKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBjdXJyZW5jeSA9IHRhZ1syXTtcbiAgaWYgKGN1cnJlbmN5ID09PSB2b2lkIDAgfHwgY3VycmVuY3kgPT09IFwiXCIpIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IHRlcm0gPSB0YWdbM107XG4gIGlmICh0ZXJtID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7XG4gIGlmICghcG9zc2libGVJbnRlcnZhbEZyZXF1ZW5jaWVzLmluY2x1ZGVzKHRlcm0pKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4ge1xuICAgIGFtb3VudCxcbiAgICBjdXJyZW5jeSxcbiAgICB0ZXJtXG4gIH07XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc3Vic2NyaXB0aW9ucy90aWVyLnRzXG52YXIgTkRLU3Vic2NyaXB0aW9uVGllciA9IGNsYXNzIF9OREtTdWJzY3JpcHRpb25UaWVyIGV4dGVuZHMgTkRLQXJ0aWNsZSB7XG4gIHN0YXRpYyBraW5kID0gMzcwMDEgLyogU3Vic2NyaXB0aW9uVGllciAqLztcbiAgc3RhdGljIGtpbmRzID0gWzM3MDAxIC8qIFN1YnNjcmlwdGlvblRpZXIgKi9dO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgY29uc3QgayA9IHJhd0V2ZW50Py5raW5kID8/IDM3MDAxIC8qIFN1YnNjcmlwdGlvblRpZXIgKi87XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID0gaztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBOREtTdWJzY3JpcHRpb25UaWVyIGZyb20gYW4gZXZlbnRcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEByZXR1cm5zIE5ES1N1YnNjcmlwdGlvblRpZXJcbiAgICovXG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLU3Vic2NyaXB0aW9uVGllcihldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwZXJrcyBmb3IgdGhpcyB0aWVyXG4gICAqL1xuICBnZXQgcGVya3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicGVya1wiKS5tYXAoKHRhZykgPT4gdGFnWzFdKS5maWx0ZXIoKHBlcmspID0+IHBlcmsgIT09IHZvaWQgMCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBwZXJrIHRvIHRoaXMgdGllclxuICAgKi9cbiAgYWRkUGVyayhwZXJrKSB7XG4gICAgdGhpcy50YWdzLnB1c2goW1wicGVya1wiLCBwZXJrXSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFtb3VudCBmb3IgdGhpcyB0aWVyXG4gICAqL1xuICBnZXQgYW1vdW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhbW91bnRcIikubWFwKCh0YWcpID0+IHBhcnNlVGFnVG9TdWJzY3JpcHRpb25BbW91bnQodGFnKSkuZmlsdGVyKChhKSA9PiBhICE9PSB2b2lkIDApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIGFtb3VudCB0byB0aGlzIHRpZXJcbiAgICogQHBhcmFtIGFtb3VudCBBbW91bnQgaW4gdGhlIHNtYWxsZXN0IHVuaXQgb2YgdGhlIGN1cnJlbmN5IChlLmcuIGNlbnRzLCBtc2F0cylcbiAgICogQHBhcmFtIGN1cnJlbmN5IEN1cnJlbmN5IGNvZGUuIFVzZSBtc2F0IGZvciBtaWxsaXNhdG9zaGlzXG4gICAqIEBwYXJhbSB0ZXJtIE9uZSBvZiBkYWlseSwgd2Vla2x5LCBtb250aGx5LCBxdWFydGVybHksIHllYXJseVxuICAgKi9cbiAgYWRkQW1vdW50KGFtb3VudCwgY3VycmVuY3ksIHRlcm0pIHtcbiAgICB0aGlzLnRhZ3MucHVzaChuZXdBbW91bnQoYW1vdW50LCBjdXJyZW5jeSwgdGVybSkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgcmVsYXkgd2hlcmUgY29udGVudCByZWxhdGVkIHRvIHRoaXMgdGllciBjYW4gYmUgZm91bmRcbiAgICogQHBhcmFtIHJlbGF5VXJsIFVSTCBvZiB0aGUgcmVsYXlcbiAgICovXG4gIHNldCByZWxheVVybChyZWxheVVybCkge1xuICAgIHRoaXMudGFncy5wdXNoKFtcInJcIiwgcmVsYXlVcmxdKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVsYXkgVVJMcyBmb3IgdGhpcyB0aWVyXG4gICAqL1xuICBnZXQgcmVsYXlVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVGFncyhcInJcIikubWFwKCh0YWcpID0+IHRhZ1sxXSkuZmlsdGVyKChyZWxheSkgPT4gcmVsYXkgIT09IHZvaWQgMCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZlcmlmaWVyIHB1YmtleSBmb3IgdGhpcyB0aWVyLiBUaGlzIGlzIHRoZSBwdWJrZXkgdGhhdCB3aWxsIGdlbmVyYXRlXG4gICAqIHN1YnNjcmlwdGlvbiBwYXltZW50IHJlY2VpcHRzXG4gICAqL1xuICBnZXQgdmVyaWZpZXJQdWJrZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJwXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2ZXJpZmllciBwdWJrZXkgZm9yIHRoaXMgdGllci5cbiAgICovXG4gIHNldCB2ZXJpZmllclB1YmtleShwdWJrZXkpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInBcIik7XG4gICAgaWYgKHB1YmtleSkgdGhpcy50YWdzLnB1c2goW1wicFwiLCBwdWJrZXldKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgdGllciBpcyB2YWxpZFxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGl0bGUgIT09IHZvaWQgMCAmJiAvLyBNdXN0IGhhdmUgYSB0aXRsZVxuICAgIHRoaXMuYW1vdW50cy5sZW5ndGggPiAwO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3ZpZGVvLnRzXG52YXIgTkRLVmlkZW8gPSBjbGFzcyBfTkRLVmlkZW8gZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMjEgLyogVmlkZW8gKi87XG4gIHN0YXRpYyBraW5kcyA9IFszNDIzNSAvKiBIb3Jpem9udGFsVmlkZW8gKi8sIDM0MjM2IC8qIFZlcnRpY2FsVmlkZW8gKi8sIDIyIC8qIFNob3J0VmlkZW8gKi8sIDIxIC8qIFZpZGVvICovXTtcbiAgX2ltZXRhcztcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOREtBcnRpY2xlIGZyb20gYW4gZXhpc3RpbmcgTkRLRXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBOREtFdmVudCB0byBjcmVhdGUgdGhlIE5ES0FydGljbGUgZnJvbS5cbiAgICogQHJldHVybnMgTkRLQXJ0aWNsZVxuICAgKi9cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtWaWRlbyhldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRpdGxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBhcnRpY2xlIHRpdGxlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRpdGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gdGl0bGUgLSBUaGUgdGl0bGUgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZS5cbiAgICovXG4gIHNldCB0aXRsZSh0aXRsZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHRpdGxlKSB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB0aXRsZV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRodW1ibmFpbC5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gLSBUaGUgYXJ0aWNsZSB0aHVtYm5haWwgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHRodW1ibmFpbCgpIHtcbiAgICBsZXQgdGh1bWJuYWlsO1xuICAgIGlmICh0aGlzLmltZXRhcyAmJiB0aGlzLmltZXRhcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHVtYm5haWwgPSB0aGlzLmltZXRhc1swXS5pbWFnZT8uWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdGh1bWJuYWlsID8/IHRoaXMudGFnVmFsdWUoXCJ0aHVtYlwiKTtcbiAgfVxuICBnZXQgaW1ldGFzKCkge1xuICAgIGlmICh0aGlzLl9pbWV0YXMpIHJldHVybiB0aGlzLl9pbWV0YXM7XG4gICAgdGhpcy5faW1ldGFzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiaW1ldGFcIikubWFwKG1hcEltZXRhVGFnKTtcbiAgICByZXR1cm4gdGhpcy5faW1ldGFzO1xuICB9XG4gIHNldCBpbWV0YXModGFncykge1xuICAgIHRoaXMuX2ltZXRhcyA9IHRhZ3M7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwiaW1ldGFcIik7XG4gICAgdGhpcy50YWdzLnB1c2goLi4udGFncy5tYXAoaW1ldGFUYWdUb1RhZykpO1xuICB9XG4gIGdldCB1cmwoKSB7XG4gICAgaWYgKHRoaXMuaW1ldGFzICYmIHRoaXMuaW1ldGFzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmltZXRhc1swXS51cmw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwidXJsXCIpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlJ3MgcHVibGljYXRpb24gdGltZXN0YW1wLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfSAtIFRoZSBVbml4IHRpbWVzdGFtcCBvZiB3aGVuIHRoZSBhcnRpY2xlIHdhcyBwdWJsaXNoZWQgb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHB1Ymxpc2hlZF9hdCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwicHVibGlzaGVkX2F0XCIpO1xuICAgIGlmICh0YWcpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQodGFnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvbnRlbnQgdGFncyBmb3IgdGhlIGFydGljbGUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGZpcnN0IGNoZWNrcyBhbmQgc2V0cyB0aGUgcHVibGljYXRpb24gZGF0ZSBpZiBub3QgYXZhaWxhYmxlLFxuICAgKiBhbmQgdGhlbiBnZW5lcmF0ZXMgY29udGVudCB0YWdzIGJhc2VkIG9uIHRoZSBiYXNlIE5ES0V2ZW50IGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gLSBUaGUgZ2VuZXJhdGVkIGNvbnRlbnQgdGFncy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlVGFncygpIHtcbiAgICBzdXBlci5nZW5lcmF0ZVRhZ3MoKTtcbiAgICBpZiAoIXRoaXMua2luZCkge1xuICAgICAgaWYgKHRoaXMuaW1ldGFzPy5bMF0/LmRpbSkge1xuICAgICAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLmltZXRhc1swXS5kaW0uc3BsaXQoXCJ4XCIpO1xuICAgICAgICBjb25zdCBpc1BvcnRyYWl0ID0gd2lkdGggJiYgaGVpZ2h0ICYmIE51bWJlci5wYXJzZUludCh3aWR0aCkgPCBOdW1iZXIucGFyc2VJbnQoaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgaXNTaG9ydCA9IHRoaXMuZHVyYXRpb24gJiYgdGhpcy5kdXJhdGlvbiA8IDEyMDtcbiAgICAgICAgaWYgKGlzU2hvcnQgJiYgaXNQb3J0cmFpdCkgdGhpcy5raW5kID0gMjIgLyogU2hvcnRWaWRlbyAqLztcbiAgICAgICAgZWxzZSB0aGlzLmtpbmQgPSAyMSAvKiBWaWRlbyAqLztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICB9XG4gIGdldCBkdXJhdGlvbigpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwiZHVyYXRpb25cIik7XG4gICAgaWYgKHRhZykge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludCh0YWcpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSB2aWRlbydzIGR1cmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBkdXJhdGlvbiAtIFRoZSBkdXJhdGlvbiB0byBzZXQgZm9yIHRoZSB2aWRlbyAoaW4gc2Vjb25kcylcbiAgICovXG4gIHNldCBkdXJhdGlvbihkdXIpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImR1cmF0aW9uXCIpO1xuICAgIGlmIChkdXIgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiZHVyYXRpb25cIiwgTWF0aC5mbG9vcihkdXIpLnRvU3RyaW5nKCldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvd2lraS50c1xudmFyIE5ES1dpa2kgPSBjbGFzcyBfTkRLV2lraSBleHRlbmRzIE5ES0FydGljbGUge1xuICBzdGF0aWMga2luZCA9IDMwODE4IC8qIFdpa2kgKi87XG4gIHN0YXRpYyBraW5kcyA9IFszMDgxOCAvKiBXaWtpICovXTtcbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtXaWtpKGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgZ2V0IGlzRGVmZXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNUYWcoXCJhXCIsIFwiZGVmZXJcIik7XG4gIH1cbiAgZ2V0IGRlZmVyZWRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImFcIiwgXCJkZWZlclwiKTtcbiAgfVxuICAvKipcbiAgICogRGVmZXJzIHRoZSBhdXRob3IncyB3aWtpIGV2ZW50IHRvIGFub3RoZXIgd2lraSBldmVudC5cbiAgICpcbiAgICogV2lraS1ldmVudHMgY2FuIHRhZyBvdGhlciB3aWtpLWV2ZW50cyB3aXRoIGEgYGRlZmVyYCBtYXJrZXIgdG8gaW5kaWNhdGUgdGhhdCBpdCBjb25zaWRlcnMgc29tZW9uZSBlbHNlJ3MgZW50cnkgYXMgYSBcImJldHRlclwiIHZlcnNpb24gb2YgaXRzZWxmLiBJZiB1c2luZyBhIGBkZWZlcmAgbWFya2VyIGJvdGggYGFgIGFuZCBgZWAgdGFncyBTSE9VTEQgYmUgdXNlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogbXlXaWtpLmRlZmVyID0gYmV0dGVyV2lraUVudHJ5T25UaGVTYW1lVG9waWM7XG4gICAqIG15V2lraS5wdWJsaXNoUmVwbGFjZWFibGUoKVxuICAgKi9cbiAgc2V0IGRlZmVyKGRlZmVyZWRUbykge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiYVwiLCBcImRlZmVyXCIpO1xuICAgIHRoaXMudGFnKGRlZmVyZWRUbywgXCJkZWZlclwiKTtcbiAgfVxufTtcbnZhciBOREtXaWtpTWVyZ2VSZXF1ZXN0ID0gY2xhc3MgX05ES1dpa2lNZXJnZVJlcXVlc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gODE4IC8qIFdpa2lNZXJnZVJlcXVlc3QgKi87XG4gIHN0YXRpYyBraW5kcyA9IFs4MTggLyogV2lraU1lcmdlUmVxdWVzdCAqL107XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLV2lraU1lcmdlUmVxdWVzdChldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IElEICg8a2luZDpwdWJrZXk6ZC10YWc+KSBvZiB0aGUgd2lraSBldmVudCB0byBtZXJnZSBpbnRvLlxuICAgKi9cbiAgZ2V0IHRhcmdldElkKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiYVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGFyZ2V0IElEICg8a2luZDpwdWJrZXk6ZC10YWc+KSBvZiB0aGUgd2lraSBldmVudCB0byBtZXJnZSBpbnRvLlxuICAgKi9cbiAgc2V0IHRhcmdldCh0YXJnZXRFdmVudCkge1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4ge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJhXCIpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgJiYgdGFnWzNdICE9PSBcInNvdXJjZVwiKSByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICB0aGlzLnRhZyh0YXJnZXRFdmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzb3VyY2UgSUQgb2YgdGhlIHdpa2kgZXZlbnQgdG8gbWVyZ2UgZnJvbS5cbiAgICovXG4gIGdldCBzb3VyY2VJZCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImVcIiwgXCJzb3VyY2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGV2ZW50IHdlIGFyZSBhc2tpbmcgdG8gZ2V0IG1lcmdlZCBpbnRvIHRoZSB0YXJnZXQuXG4gICAqL1xuICBzZXQgc291cmNlKHNvdXJjZUV2ZW50KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJlXCIsIFwic291cmNlXCIpO1xuICAgIHRoaXMudGFnKHNvdXJjZUV2ZW50LCBcInNvdXJjZVwiLCBmYWxzZSwgXCJlXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL3dyYXAudHNcbmZ1bmN0aW9uIHdyYXBFdmVudChldmVudCkge1xuICBjb25zdCBldmVudFdyYXBwaW5nTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBrbGFzczIgb2YgW1xuICAgIE5ES0ltYWdlLFxuICAgIE5ES1ZpZGVvLFxuICAgIE5ES0Nhc2h1TWludExpc3QsXG4gICAgTkRLQXJ0aWNsZSxcbiAgICBOREtIaWdobGlnaHQsXG4gICAgTkRLV2lraSxcbiAgICBOREtOdXR6YXAsXG4gICAgTkRLU2ltcGxlR3JvdXBNZW1iZXJMaXN0LFxuICAgIE5ES1NpbXBsZUdyb3VwTWV0YWRhdGEsXG4gICAgTkRLU3Vic2NyaXB0aW9uVGllcixcbiAgICBOREtDYXNodVRva2VuLFxuICAgIE5ES0xpc3QsXG4gICAgTkRLU3RvcnlcbiAgXSkge1xuICAgIGZvciAoY29uc3Qga2luZCBvZiBrbGFzczIua2luZHMpIHtcbiAgICAgIGV2ZW50V3JhcHBpbmdNYXAuc2V0KGtpbmQsIGtsYXNzMik7XG4gICAgfVxuICB9XG4gIGNvbnN0IGtsYXNzID0gZXZlbnRXcmFwcGluZ01hcC5nZXQoZXZlbnQua2luZCk7XG4gIGlmIChrbGFzcykgcmV0dXJuIGtsYXNzLmZyb20oZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8vIHNyYy9zdWJzY3JpcHRpb24vdXRpbHMudHNcbmltcG9ydCB7IG5pcDE5IGFzIG5pcDE5NCB9IGZyb20gXCJub3N0ci10b29sc1wiO1xudmFyIE1BWF9TVUJJRF9MRU5HVEggPSAyMDtcbmZ1bmN0aW9uIHF1ZXJ5RnVsbHlGaWxsZWQoc3Vic2NyaXB0aW9uKSB7XG4gIGlmIChmaWx0ZXJJbmNsdWRlc0lkcyhzdWJzY3JpcHRpb24uZmlsdGVyKSkge1xuICAgIGlmIChyZXN1bHRIYXNBbGxSZXF1ZXN0ZWRJZHMoc3Vic2NyaXB0aW9uKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVGaWx0ZXIoZmlsdGVyMSwgZmlsdGVyMikge1xuICBpZiAoT2JqZWN0LmtleXMoZmlsdGVyMSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhmaWx0ZXIyKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmlsdGVyMSkpIHtcbiAgICBjb25zdCB2YWx1ZXNJbkZpbHRlcjIgPSBmaWx0ZXIyW2tleV07XG4gICAgaWYgKCF2YWx1ZXNJbkZpbHRlcjIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZXNJbkZpbHRlcjIpKSB7XG4gICAgICBjb25zdCB2ID0gdmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlSW5GaWx0ZXIyIG9mIHZhbHVlc0luRmlsdGVyMikge1xuICAgICAgICBjb25zdCB2YWwgPSB2YWx1ZUluRmlsdGVyMjtcbiAgICAgICAgaWYgKCF2LmluY2x1ZGVzKHZhbCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlc0luRmlsdGVyMiAhPT0gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBmaWx0ZXJJbmNsdWRlc0lkcyhmaWx0ZXIpIHtcbiAgcmV0dXJuICEhZmlsdGVyLmlkcztcbn1cbmZ1bmN0aW9uIHJlc3VsdEhhc0FsbFJlcXVlc3RlZElkcyhzdWJzY3JpcHRpb24pIHtcbiAgY29uc3QgaWRzID0gc3Vic2NyaXB0aW9uLmZpbHRlci5pZHM7XG4gIHJldHVybiAhIWlkcyAmJiBpZHMubGVuZ3RoID09PSBzdWJzY3JpcHRpb24uZXZlbnRGaXJzdFNlZW4uc2l6ZTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU3ViSWQoc3Vic2NyaXB0aW9ucywgZmlsdGVycykge1xuICBjb25zdCBzdWJJZHMgPSBzdWJzY3JpcHRpb25zLm1hcCgoc3ViKSA9PiBzdWIuc3ViSWQpLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3Qgc3ViSWRQYXJ0cyA9IFtdO1xuICBjb25zdCBmaWx0ZXJOb25LaW5kS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGZpbHRlcktpbmRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgaWYgKHN1Yklkcy5sZW5ndGggPiAwKSB7XG4gICAgc3ViSWRQYXJ0cy5wdXNoKEFycmF5LmZyb20obmV3IFNldChzdWJJZHMpKS5qb2luKFwiLFwiKSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgZmlsdGVycykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZmlsdGVyKSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcImtpbmRzXCIpIHtcbiAgICAgICAgICBmaWx0ZXIua2luZHM/LmZvckVhY2goKGspID0+IGZpbHRlcktpbmRzLmFkZChrKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsdGVyTm9uS2luZEtleXMuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpbHRlcktpbmRzLnNpemUgPiAwKSB7XG4gICAgICBzdWJJZFBhcnRzLnB1c2goYGtpbmRzOiR7QXJyYXkuZnJvbShmaWx0ZXJLaW5kcykuam9pbihcIixcIil9YCk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJOb25LaW5kS2V5cy5zaXplID4gMCkge1xuICAgICAgc3ViSWRQYXJ0cy5wdXNoKEFycmF5LmZyb20oZmlsdGVyTm9uS2luZEtleXMpLmpvaW4oXCIsXCIpKTtcbiAgICB9XG4gIH1cbiAgbGV0IHN1YklkID0gc3ViSWRQYXJ0cy5qb2luKFwiLVwiKTtcbiAgaWYgKHN1YklkLmxlbmd0aCA+IE1BWF9TVUJJRF9MRU5HVEgpIHN1YklkID0gc3ViSWQuc3Vic3RyaW5nKDAsIE1BWF9TVUJJRF9MRU5HVEgpO1xuICBzdWJJZCArPSBgLSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogOTk5KS50b1N0cmluZygpfWA7XG4gIHJldHVybiBzdWJJZDtcbn1cbmZ1bmN0aW9uIGZpbHRlckZvckV2ZW50c1RhZ2dpbmdJZChpZCkge1xuICB0cnkge1xuICAgIGNvbnN0IGRlY29kZWQgPSBuaXAxOTQuZGVjb2RlKGlkKTtcbiAgICBzd2l0Y2ggKGRlY29kZWQudHlwZSkge1xuICAgICAgY2FzZSBcIm5hZGRyXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgXCIjYVwiOiBbYCR7ZGVjb2RlZC5kYXRhLmtpbmR9OiR7ZGVjb2RlZC5kYXRhLnB1YmtleX06JHtkZWNvZGVkLmRhdGEuaWRlbnRpZmllcn1gXVxuICAgICAgICB9O1xuICAgICAgY2FzZSBcIm5ldmVudFwiOlxuICAgICAgICByZXR1cm4geyBcIiNlXCI6IFtkZWNvZGVkLmRhdGEuaWRdIH07XG4gICAgICBjYXNlIFwibm90ZVwiOlxuICAgICAgICByZXR1cm4geyBcIiNlXCI6IFtkZWNvZGVkLmRhdGFdIH07XG4gICAgICBjYXNlIFwibnByb2ZpbGVcIjpcbiAgICAgICAgcmV0dXJuIHsgXCIjcFwiOiBbZGVjb2RlZC5kYXRhLnB1YmtleV0gfTtcbiAgICAgIGNhc2UgXCJucHViXCI6XG4gICAgICAgIHJldHVybiB7IFwiI3BcIjogW2RlY29kZWQuZGF0YV0gfTtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICB9XG59XG5mdW5jdGlvbiBmaWx0ZXJBbmRSZWxheVNldEZyb21CZWNoMzIoYmVjaGUyLCBuZGspIHtcbiAgY29uc3QgZmlsdGVyID0gZmlsdGVyRnJvbUlkKGJlY2hlMik7XG4gIGNvbnN0IHJlbGF5cyA9IHJlbGF5c0Zyb21CZWNoMzIoYmVjaGUyLCBuZGspO1xuICBpZiAocmVsYXlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHsgZmlsdGVyIH07XG4gIHJldHVybiB7XG4gICAgZmlsdGVyLFxuICAgIHJlbGF5U2V0OiBuZXcgTkRLUmVsYXlTZXQobmV3IFNldChyZWxheXMpLCBuZGspXG4gIH07XG59XG5mdW5jdGlvbiBmaWx0ZXJGcm9tSWQoaWQpIHtcbiAgbGV0IGRlY29kZWQ7XG4gIGlmIChpZC5tYXRjaChOSVAzM19BX1JFR0VYKSkge1xuICAgIGNvbnN0IFtraW5kLCBwdWJrZXksIGlkZW50aWZpZXJdID0gaWQuc3BsaXQoXCI6XCIpO1xuICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgIGF1dGhvcnM6IFtwdWJrZXldLFxuICAgICAga2luZHM6IFtOdW1iZXIucGFyc2VJbnQoa2luZCldXG4gICAgfTtcbiAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgZmlsdGVyW1wiI2RcIl0gPSBbaWRlbnRpZmllcl07XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXI7XG4gIH1cbiAgaWYgKGlkLm1hdGNoKEJFQ0gzMl9SRUdFWCkpIHtcbiAgICB0cnkge1xuICAgICAgZGVjb2RlZCA9IG5pcDE5NC5kZWNvZGUoaWQpO1xuICAgICAgc3dpdGNoIChkZWNvZGVkLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm5ldmVudFwiOiB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyID0geyBpZHM6IFtkZWNvZGVkLmRhdGEuaWRdIH07XG4gICAgICAgICAgaWYgKGRlY29kZWQuZGF0YS5hdXRob3IpIGZpbHRlci5hdXRob3JzID0gW2RlY29kZWQuZGF0YS5hdXRob3JdO1xuICAgICAgICAgIGlmIChkZWNvZGVkLmRhdGEua2luZCkgZmlsdGVyLmtpbmRzID0gW2RlY29kZWQuZGF0YS5raW5kXTtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICAgICAgcmV0dXJuIHsgaWRzOiBbZGVjb2RlZC5kYXRhXSB9O1xuICAgICAgICBjYXNlIFwibmFkZHJcIjoge1xuICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICAgIGF1dGhvcnM6IFtkZWNvZGVkLmRhdGEucHVia2V5XSxcbiAgICAgICAgICAgIGtpbmRzOiBbZGVjb2RlZC5kYXRhLmtpbmRdXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoZGVjb2RlZC5kYXRhLmlkZW50aWZpZXIpIGZpbHRlcltcIiNkXCJdID0gW2RlY29kZWQuZGF0YS5pZGVudGlmaWVyXTtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRlY29kaW5nXCIsIGlkLCBlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgaWRzOiBbaWRdIH07XG59XG5mdW5jdGlvbiBpc05pcDMzQVZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5tYXRjaChOSVAzM19BX1JFR0VYKSAhPT0gbnVsbDtcbn1cbnZhciBOSVAzM19BX1JFR0VYID0gL14oXFxkKyk6KFswLTlBLUZhLWZdKykoPzo6KC4qKSk/JC87XG52YXIgQkVDSDMyX1JFR0VYID0gL15uKGV2ZW50fG90ZXxwcm9maWxlfHB1YnxhZGRyKTFbXFxkXFx3XSskLztcbmZ1bmN0aW9uIHJlbGF5c0Zyb21CZWNoMzIoYmVjaDMyMiwgbmRrKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IG5pcDE5NC5kZWNvZGUoYmVjaDMyMik7XG4gICAgaWYgKFtcIm5hZGRyXCIsIFwibmV2ZW50XCJdLmluY2x1ZGVzKGRlY29kZWQ/LnR5cGUpKSB7XG4gICAgICBjb25zdCBkYXRhID0gZGVjb2RlZC5kYXRhO1xuICAgICAgaWYgKGRhdGE/LnJlbGF5cykge1xuICAgICAgICByZXR1cm4gZGF0YS5yZWxheXMubWFwKChyKSA9PiBuZXcgTkRLUmVsYXkociwgbmRrLnJlbGF5QXV0aERlZmF1bHRQb2xpY3ksIG5kaykpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoX2UpIHtcbiAgfVxuICByZXR1cm4gW107XG59XG5cbi8vIHNyYy9zdWJzY3JpcHRpb24vaW5kZXgudHNcbnZhciBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlID0gLyogQF9fUFVSRV9fICovICgoTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTIpID0+IHtcbiAgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTJbXCJPTkxZX0NBQ0hFXCJdID0gXCJPTkxZX0NBQ0hFXCI7XG4gIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UyW1wiQ0FDSEVfRklSU1RcIl0gPSBcIkNBQ0hFX0ZJUlNUXCI7XG4gIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UyW1wiUEFSQUxMRUxcIl0gPSBcIlBBUkFMTEVMXCI7XG4gIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UyW1wiT05MWV9SRUxBWVwiXSA9IFwiT05MWV9SRUxBWVwiO1xuICByZXR1cm4gTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTI7XG59KShOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlIHx8IHt9KTtcbnZhciBkZWZhdWx0T3B0cyA9IHtcbiAgY2xvc2VPbkVvc2U6IGZhbHNlLFxuICBjYWNoZVVzYWdlOiBcIkNBQ0hFX0ZJUlNUXCIgLyogQ0FDSEVfRklSU1QgKi8sXG4gIGRvbnRTYXZlVG9DYWNoZTogZmFsc2UsXG4gIGdyb3VwYWJsZTogdHJ1ZSxcbiAgZ3JvdXBhYmxlRGVsYXk6IDEwMCxcbiAgZ3JvdXBhYmxlRGVsYXlUeXBlOiBcImF0LW1vc3RcIixcbiAgY2FjaGVVbmNvbnN0cmFpbkZpbHRlcjogW1wibGltaXRcIiwgXCJzaW5jZVwiLCBcInVudGlsXCJdXG59O1xudmFyIE5ES1N1YnNjcmlwdGlvbiA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyNCB7XG4gIHN1YklkO1xuICBmaWx0ZXJzO1xuICBvcHRzO1xuICBwb29sO1xuICBza2lwVmVyaWZpY2F0aW9uID0gZmFsc2U7XG4gIHNraXBWYWxpZGF0aW9uID0gZmFsc2U7XG4gIC8qKlxuICAgKiBUcmFja3MgdGhlIGZpbHRlcnMgYXMgdGhleSBhcmUgZXhlY3V0ZWQgb24gZWFjaCByZWxheVxuICAgKi9cbiAgcmVsYXlGaWx0ZXJzO1xuICByZWxheVNldDtcbiAgbmRrO1xuICBkZWJ1ZztcbiAgLyoqXG4gICAqIEV2ZW50cyB0aGF0IGhhdmUgYmVlbiBzZWVuIGJ5IHRoZSBzdWJzY3JpcHRpb24sIHdpdGggdGhlIHRpbWUgdGhleSB3ZXJlIGZpcnN0IHNlZW4uXG4gICAqL1xuICBldmVudEZpcnN0U2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8qKlxuICAgKiBSZWxheXMgdGhhdCBoYXZlIHNlbnQgYW4gRU9TRS5cbiAgICovXG4gIGVvc2VzU2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIC8qKlxuICAgKiBUaGUgdGltZSB0aGUgbGFzdCBldmVudCB3YXMgcmVjZWl2ZWQgYnkgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICogVGhpcyBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB3aGVuIEVPU0Ugc2hvdWxkIGJlIGVtaXR0ZWQuXG4gICAqL1xuICBsYXN0RXZlbnRSZWNlaXZlZEF0O1xuICAvKipcbiAgICogVGhlIG1vc3QgcmVjZW50IGV2ZW50IHRpbWVzdGFtcCBmcm9tIGNhY2hlIHJlc3VsdHMuXG4gICAqIFRoaXMgaXMgdXNlZCBmb3IgYWRkU2luY2VGcm9tQ2FjaGUgZnVuY3Rpb25hbGl0eS5cbiAgICovXG4gIG1vc3RSZWNlbnRDYWNoZUV2ZW50VGltZXN0YW1wO1xuICBpbnRlcm5hbElkO1xuICAvKipcbiAgICogV2hldGhlciB0aGUgc3Vic2NyaXB0aW9uIHNob3VsZCBjbG9zZSB3aGVuIGFsbCByZWxheXMgaGF2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGV2ZW50IHN0cmVhbS5cbiAgICovXG4gIGNsb3NlT25Fb3NlO1xuICAvKipcbiAgICogUG9vbCBtb25pdG9yIGNhbGxiYWNrXG4gICAqL1xuICBwb29sTW9uaXRvcjtcbiAgc2tpcE9wdGltaXN0aWNQdWJsaXNoRXZlbnQgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEZpbHRlcnMgdG8gcmVtb3ZlIHdoZW4gcXVlcnlpbmcgdGhlIGNhY2hlLlxuICAgKi9cbiAgY2FjaGVVbmNvbnN0cmFpbkZpbHRlcjtcbiAgY29uc3RydWN0b3IobmRrLCBmaWx0ZXJzLCBvcHRzLCBzdWJJZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0cywgLi4ub3B0cyB8fCB7fSB9O1xuICAgIHRoaXMucG9vbCA9IHRoaXMub3B0cy5wb29sIHx8IG5kay5wb29sO1xuICAgIHRoaXMuZmlsdGVycyA9IEFycmF5LmlzQXJyYXkoZmlsdGVycykgPyBmaWx0ZXJzIDogW2ZpbHRlcnNdO1xuICAgIHRoaXMuc3ViSWQgPSBzdWJJZCB8fCB0aGlzLm9wdHMuc3ViSWQ7XG4gICAgdGhpcy5pbnRlcm5hbElkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpO1xuICAgIHRoaXMuZGVidWcgPSBuZGsuZGVidWcuZXh0ZW5kKGBzdWJzY3JpcHRpb25bJHt0aGlzLm9wdHMuc3ViSWQgPz8gdGhpcy5pbnRlcm5hbElkfV1gKTtcbiAgICBpZiAodGhpcy5vcHRzLnJlbGF5U2V0KSB7XG4gICAgICB0aGlzLnJlbGF5U2V0ID0gdGhpcy5vcHRzLnJlbGF5U2V0O1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLnJlbGF5VXJscykge1xuICAgICAgdGhpcy5yZWxheVNldCA9IE5ES1JlbGF5U2V0LmZyb21SZWxheVVybHModGhpcy5vcHRzLnJlbGF5VXJscywgdGhpcy5uZGspO1xuICAgIH1cbiAgICB0aGlzLnNraXBWZXJpZmljYXRpb24gPSB0aGlzLm9wdHMuc2tpcFZlcmlmaWNhdGlvbiB8fCBmYWxzZTtcbiAgICB0aGlzLnNraXBWYWxpZGF0aW9uID0gdGhpcy5vcHRzLnNraXBWYWxpZGF0aW9uIHx8IGZhbHNlO1xuICAgIHRoaXMuY2xvc2VPbkVvc2UgPSB0aGlzLm9wdHMuY2xvc2VPbkVvc2UgfHwgZmFsc2U7XG4gICAgdGhpcy5za2lwT3B0aW1pc3RpY1B1Ymxpc2hFdmVudCA9IHRoaXMub3B0cy5za2lwT3B0aW1pc3RpY1B1Ymxpc2hFdmVudCB8fCBmYWxzZTtcbiAgICB0aGlzLmNhY2hlVW5jb25zdHJhaW5GaWx0ZXIgPSB0aGlzLm9wdHMuY2FjaGVVbmNvbnN0cmFpbkZpbHRlcjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVsYXlzIHRoYXQgaGF2ZSBub3QgeWV0IHNlbnQgYW4gRU9TRS5cbiAgICovXG4gIHJlbGF5c01pc3NpbmdFb3NlKCkge1xuICAgIGlmICghdGhpcy5yZWxheUZpbHRlcnMpIHJldHVybiBbXTtcbiAgICBjb25zdCByZWxheXNNaXNzaW5nRW9zZSA9IEFycmF5LmZyb20odGhpcy5yZWxheUZpbHRlcnM/LmtleXMoKSkuZmlsdGVyKFxuICAgICAgKHVybCkgPT4gIXRoaXMuZW9zZXNTZWVuLmhhcyh0aGlzLnBvb2wuZ2V0UmVsYXkodXJsLCBmYWxzZSwgZmFsc2UpKVxuICAgICk7XG4gICAgcmV0dXJuIHJlbGF5c01pc3NpbmdFb3NlO1xuICB9XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGZpcnN0IGZpbHRlciBvZiB0aGUgc3Vic2NyaXB0aW9uIGZvclxuICAgKiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICovXG4gIGdldCBmaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyc1swXTtcbiAgfVxuICBnZXQgZ3JvdXBhYmxlRGVsYXkoKSB7XG4gICAgaWYgKCF0aGlzLmlzR3JvdXBhYmxlKCkpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIHRoaXMub3B0cz8uZ3JvdXBhYmxlRGVsYXk7XG4gIH1cbiAgZ2V0IGdyb3VwYWJsZURlbGF5VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRzPy5ncm91cGFibGVEZWxheVR5cGUgfHwgXCJhdC1tb3N0XCI7XG4gIH1cbiAgaXNHcm91cGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0cz8uZ3JvdXBhYmxlIHx8IGZhbHNlO1xuICB9XG4gIHNob3VsZFF1ZXJ5Q2FjaGUoKSB7XG4gICAgaWYgKHRoaXMub3B0cy5hZGRTaW5jZUZyb21DYWNoZSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMub3B0cz8uY2FjaGVVc2FnZSA9PT0gXCJPTkxZX1JFTEFZXCIgLyogT05MWV9SRUxBWSAqLykgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGhhc05vbkVwaGVtZXJhbEtpbmQgPSB0aGlzLmZpbHRlcnMuc29tZSgoZikgPT4gZi5raW5kcz8uc29tZSgoaykgPT4ga2luZElzRXBoZW1lcmFsKGspKSk7XG4gICAgaWYgKGhhc05vbkVwaGVtZXJhbEtpbmQpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNob3VsZFF1ZXJ5UmVsYXlzKCkge1xuICAgIHJldHVybiB0aGlzLm9wdHM/LmNhY2hlVXNhZ2UgIT09IFwiT05MWV9DQUNIRVwiIC8qIE9OTFlfQ0FDSEUgKi87XG4gIH1cbiAgc2hvdWxkV2FpdEZvckNhY2hlKCkge1xuICAgIGlmICh0aGlzLm9wdHMuYWRkU2luY2VGcm9tQ2FjaGUpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiAoXG4gICAgICAvLyBNdXN0IHdhbnQgdG8gY2xvc2Ugb24gRU9TRTsgc3Vic2NyaXB0aW9uc1xuICAgICAgLy8gdGhhdCB3YW50IHRvIHJlY2VpdmUgZnVydGhlciB1cGRhdGVzIG11c3RcbiAgICAgIC8vIGFsd2F5cyBoaXQgdGhlIHJlbGF5XG4gICAgICAhIXRoaXMub3B0cy5jbG9zZU9uRW9zZSAmJiAvLyBDYWNoZSBhZGFwdGVyIG11c3QgY2xhaW0gdG8gYmUgZmFzdFxuICAgICAgISF0aGlzLm5kay5jYWNoZUFkYXB0ZXI/LmxvY2tpbmcgJiYgLy8gSWYgZXhwbGljaXRseSB0b2xkIHRvIHJ1biBpbiBwYXJhbGxlbCwgdGhlblxuICAgICAgLy8gd2Ugc2hvdWxkIG5vdCB3YWl0IGZvciB0aGUgY2FjaGVcbiAgICAgIHRoaXMub3B0cy5jYWNoZVVzYWdlICE9PSBcIlBBUkFMTEVMXCIgLyogUEFSQUxMRUwgKi9cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCB0aGUgc3Vic2NyaXB0aW9uLiBUaGlzIGlzIHRoZSBtYWluIG1ldGhvZCB0aGF0IHNob3VsZCBiZSBjYWxsZWRcbiAgICogYWZ0ZXIgY3JlYXRpbmcgYSBzdWJzY3JpcHRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBlbWl0Q2FjaGVkRXZlbnRzIC0gV2hldGhlciB0byBlbWl0IGV2ZW50cyBjb21pbmcgZnJvbSBhIHN5bmNocm9ub3VzIGNhY2hlXG4gICAqXG4gICAqIFdoZW4gdXNpbmcgYSBzeW5jaHJvbm91cyBjYWNoZSwgdGhlIGV2ZW50cyB3aWxsIGJlIHJldHVybmVkIGltbWVkaWF0ZWx5XG4gICAqIGJ5IHRoaXMgZnVuY3Rpb24uIElmIHlvdSB3aWxsIHVzZSB0aG9zZSByZXR1cm5lZCBldmVudHMsIHlvdSBzaG91bGRcbiAgICogc2V0IGVtaXRDYWNoZWRFdmVudHMgdG8gZmFsc2UgdG8gcHJldmVudCBzZWVpbmcgdGhlbSBhcyBkdXBsaWNhdGUgZXZlbnRzLlxuICAgKi9cbiAgc3RhcnQoZW1pdENhY2hlZEV2ZW50cyA9IHRydWUpIHtcbiAgICBsZXQgY2FjaGVSZXN1bHQ7XG4gICAgY29uc3QgdXBkYXRlU3RhdGVGcm9tQ2FjaGVSZXN1bHRzID0gKGV2ZW50cykgPT4ge1xuICAgICAgaWYgKGVtaXRDYWNoZWRFdmVudHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMubW9zdFJlY2VudENhY2hlRXZlbnRUaW1lc3RhbXAgfHwgZXZlbnQuY3JlYXRlZF9hdCA+IHRoaXMubW9zdFJlY2VudENhY2hlRXZlbnRUaW1lc3RhbXApIHtcbiAgICAgICAgICAgIHRoaXMubW9zdFJlY2VudENhY2hlRXZlbnRUaW1lc3RhbXAgPSBldmVudC5jcmVhdGVkX2F0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmV2ZW50UmVjZWl2ZWQoZXZlbnQsIHZvaWQgMCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICAgIGlmICghdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCB8fCBldmVudC5jcmVhdGVkX2F0ID4gdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCkge1xuICAgICAgICAgICAgdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCA9IGV2ZW50LmNyZWF0ZWRfYXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV2ZW50Lm5kayA9IHRoaXMubmRrO1xuICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLm9wdHMud3JhcCA/IHdyYXBFdmVudChldmVudCkgOiBldmVudDtcbiAgICAgICAgICBpZiAoIWUpIGJyZWFrO1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgZS50aGVuKCh3cmFwcGVkRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoZmFsc2UsIHdyYXBwZWRFdmVudCwgdm9pZCAwLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmV2ZW50Rmlyc3RTZWVuLnNldChlLmlkLCBEYXRlLm5vdygpKTtcbiAgICAgICAgICBjYWNoZVJlc3VsdC5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsb2FkRnJvbVJlbGF5cyA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNob3VsZFF1ZXJ5UmVsYXlzKCkpIHtcbiAgICAgICAgdGhpcy5zdGFydFdpdGhSZWxheXMoKTtcbiAgICAgICAgdGhpcy5zdGFydFBvb2xNb25pdG9yKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoXCJlb3NlXCIsIHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHRoaXMuc2hvdWxkUXVlcnlDYWNoZSgpKSB7XG4gICAgICBjYWNoZVJlc3VsdCA9IHRoaXMuc3RhcnRXaXRoQ2FjaGUoKTtcbiAgICAgIGlmIChjYWNoZVJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkV2FpdEZvckNhY2hlKCkpIHtcbiAgICAgICAgICBjYWNoZVJlc3VsdC50aGVuKChldmVudHMpID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlRnJvbUNhY2hlUmVzdWx0cyhldmVudHMpO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5RnVsbHlGaWxsZWQodGhpcykpIHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZW9zZVwiLCB0aGlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9hZEZyb21SZWxheXMoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZVJlc3VsdC50aGVuKChldmVudHMpID0+IHtcbiAgICAgICAgICB1cGRhdGVTdGF0ZUZyb21DYWNoZVJlc3VsdHMoZXZlbnRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxvYWRGcm9tUmVsYXlzKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdXBkYXRlU3RhdGVGcm9tQ2FjaGVSZXN1bHRzKGNhY2hlUmVzdWx0KTtcbiAgICAgIGlmIChxdWVyeUZ1bGx5RmlsbGVkKHRoaXMpKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImVvc2VcIiwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkRnJvbVJlbGF5cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlUmVzdWx0O1xuICAgIH1cbiAgICBsb2FkRnJvbVJlbGF5cygpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBXZSB3YW50IHRvIG1vbml0b3IgZm9yIG5ldyByZWxheXMgdGhhdCBhcmUgY29taW5nIG9ubGluZSwgaW4gY2FzZVxuICAgKiB0aGV5IHNob3VsZCBiZSBwYXJ0IG9mIHRoaXMgc3Vic2NyaXB0aW9uLlxuICAgKi9cbiAgc3RhcnRQb29sTW9uaXRvcigpIHtcbiAgICBjb25zdCBfZCA9IHRoaXMuZGVidWcuZXh0ZW5kKFwicG9vbC1tb25pdG9yXCIpO1xuICAgIHRoaXMucG9vbE1vbml0b3IgPSAocmVsYXkpID0+IHtcbiAgICAgIGlmICh0aGlzLnJlbGF5RmlsdGVycz8uaGFzKHJlbGF5LnVybCkpIHJldHVybjtcbiAgICAgIGNvbnN0IGNhbGMgPSBjYWxjdWxhdGVSZWxheVNldHNGcm9tRmlsdGVycyh0aGlzLm5kaywgdGhpcy5maWx0ZXJzLCB0aGlzLnBvb2wpO1xuICAgICAgaWYgKGNhbGMuZ2V0KHJlbGF5LnVybCkpIHtcbiAgICAgICAgdGhpcy5yZWxheUZpbHRlcnM/LnNldChyZWxheS51cmwsIHRoaXMuZmlsdGVycyk7XG4gICAgICAgIHJlbGF5LnN1YnNjcmliZSh0aGlzLCB0aGlzLmZpbHRlcnMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5wb29sLm9uKFwicmVsYXk6Y29ubmVjdFwiLCB0aGlzLnBvb2xNb25pdG9yKTtcbiAgfVxuICBvblN0b3BwZWQ7XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5lbWl0KFwiY2xvc2VcIiwgdGhpcyk7XG4gICAgdGhpcy5wb29sTW9uaXRvciAmJiB0aGlzLnBvb2wub2ZmKFwicmVsYXk6Y29ubmVjdFwiLCB0aGlzLnBvb2xNb25pdG9yKTtcbiAgICB0aGlzLm9uU3RvcHBlZD8uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHN1YnNjcmlwdGlvbiBoYXMgYW4gYXV0aG9ycyBmaWx0ZXIuXG4gICAqL1xuICBoYXNBdXRob3JzRmlsdGVyKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcnMuc29tZSgoZikgPT4gZi5hdXRob3JzPy5sZW5ndGgpO1xuICB9XG4gIHN0YXJ0V2l0aENhY2hlKCkge1xuICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXI/LnF1ZXJ5KSB7XG4gICAgICByZXR1cm4gdGhpcy5uZGsuY2FjaGVBZGFwdGVyLnF1ZXJ5KHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgYXZhaWxhYmxlIHJlbGF5cyB0aGF0IHNob3VsZCBiZSBwYXJ0IG9mIHRoaXMgc3Vic2NyaXB0aW9uIGFuZCBleGVjdXRlIGluIHRoZW0uXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIGlzIGV4ZWN1dGVkIGluIGFkZGl0aW9uIHRvIHVzaW5nIHRoZSBwb29sIG1vbml0b3IsIHNvIGV2ZW4gaWYgdGhlIHJlbGF5IHNldFxuICAgKiB0aGF0IGlzIGNvbXB1dGVkIChpLmUuIHdlIGRvbid0IGhhdmUgYW55IHJlbGF5cyBhdmFpbGFibGUpLCB3aGVuIHJlbGF5cyBjb21lIG9ubGluZSwgd2Ugd2lsbFxuICAgKiBjaGVjayBpZiB3ZSBuZWVkIHRvIGV4ZWN1dGUgaW4gdGhlbS5cbiAgICovXG4gIHN0YXJ0V2l0aFJlbGF5cygpIHtcbiAgICBsZXQgZmlsdGVycyA9IHRoaXMuZmlsdGVycztcbiAgICBpZiAodGhpcy5vcHRzLmFkZFNpbmNlRnJvbUNhY2hlICYmIHRoaXMubW9zdFJlY2VudENhY2hlRXZlbnRUaW1lc3RhbXApIHtcbiAgICAgIGNvbnN0IHNpbmNlVGltZXN0YW1wID0gdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCArIDE7XG4gICAgICBmaWx0ZXJzID0gZmlsdGVycy5tYXAoKGZpbHRlcikgPT4gKHtcbiAgICAgICAgLi4uZmlsdGVyLFxuICAgICAgICBzaW5jZTogTWF0aC5tYXgoZmlsdGVyLnNpbmNlIHx8IDAsIHNpbmNlVGltZXN0YW1wKVxuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVsYXlTZXQgfHwgdGhpcy5yZWxheVNldC5yZWxheXMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5yZWxheUZpbHRlcnMgPSBjYWxjdWxhdGVSZWxheVNldHNGcm9tRmlsdGVycyh0aGlzLm5kaywgZmlsdGVycywgdGhpcy5wb29sKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWxheUZpbHRlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCByZWxheSBvZiB0aGlzLnJlbGF5U2V0LnJlbGF5cykge1xuICAgICAgICB0aGlzLnJlbGF5RmlsdGVycy5zZXQocmVsYXkudXJsLCBmaWx0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbcmVsYXlVcmwsIGZpbHRlcnMyXSBvZiB0aGlzLnJlbGF5RmlsdGVycykge1xuICAgICAgY29uc3QgcmVsYXkgPSB0aGlzLnBvb2wuZ2V0UmVsYXkocmVsYXlVcmwsIHRydWUsIHRydWUsIGZpbHRlcnMyKTtcbiAgICAgIHJlbGF5LnN1YnNjcmliZSh0aGlzLCBmaWx0ZXJzMik7XG4gICAgfVxuICB9XG4gIC8vIEVWRU5UIGhhbmRsaW5nXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhbiBldmVudCBpcyByZWNlaXZlZCBmcm9tIGEgcmVsYXkgb3IgdGhlIGNhY2hlXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcGFyYW0gcmVsYXlcbiAgICogQHBhcmFtIGZyb21DYWNoZSBXaGV0aGVyIHRoZSBldmVudCB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgY2FjaGVcbiAgICogQHBhcmFtIG9wdGltaXN0aWNQdWJsaXNoIFdoZXRoZXIgdGhpcyBldmVudCBpcyBjb21pbmcgZnJvbSBhbiBvcHRpbWlzdGljIHB1Ymxpc2hcbiAgICovXG4gIGV2ZW50UmVjZWl2ZWQoZXZlbnQsIHJlbGF5LCBmcm9tQ2FjaGUgPSBmYWxzZSwgb3B0aW1pc3RpY1B1Ymxpc2ggPSBmYWxzZSkge1xuICAgIGNvbnN0IGV2ZW50SWQgPSBldmVudC5pZDtcbiAgICBjb25zdCBldmVudEFscmVhZHlTZWVuID0gdGhpcy5ldmVudEZpcnN0U2Vlbi5oYXMoZXZlbnRJZCk7XG4gICAgbGV0IG5ka0V2ZW50O1xuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIE5ES0V2ZW50KSBuZGtFdmVudCA9IGV2ZW50O1xuICAgIGlmICghZXZlbnRBbHJlYWR5U2Vlbikge1xuICAgICAgbmRrRXZlbnQgPz89IG5ldyBOREtFdmVudCh0aGlzLm5kaywgZXZlbnQpO1xuICAgICAgbmRrRXZlbnQubmRrID0gdGhpcy5uZGs7XG4gICAgICBuZGtFdmVudC5yZWxheSA9IHJlbGF5O1xuICAgICAgaWYgKCFmcm9tQ2FjaGUgJiYgIW9wdGltaXN0aWNQdWJsaXNoKSB7XG4gICAgICAgIGlmICghdGhpcy5za2lwVmFsaWRhdGlvbikge1xuICAgICAgICAgIGlmICghbmRrRXZlbnQuaXNWYWxpZCkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIkV2ZW50IGZhaWxlZCB2YWxpZGF0aW9uICVzIGZyb20gcmVsYXkgJXNcIiwgZXZlbnRJZCwgcmVsYXk/LnVybCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxheSkge1xuICAgICAgICAgIGlmIChyZWxheT8uc2hvdWxkVmFsaWRhdGVFdmVudCgpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNraXBWZXJpZmljYXRpb24pIHtcbiAgICAgICAgICAgICAgaWYgKCFuZGtFdmVudC52ZXJpZnlTaWduYXR1cmUodHJ1ZSkgJiYgIXRoaXMubmRrLmFzeW5jU2lnVmVyaWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIkV2ZW50IGZhaWxlZCBzaWduYXR1cmUgdmFsaWRhdGlvblwiLCBldmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZWxheSkge1xuICAgICAgICAgICAgICAgIHJlbGF5LmFkZFZhbGlkYXRlZEV2ZW50KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVsYXkuYWRkTm9uVmFsaWRhdGVkRXZlbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlciAmJiAhdGhpcy5vcHRzLmRvbnRTYXZlVG9DYWNoZSkge1xuICAgICAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5zZXRFdmVudChuZGtFdmVudCwgdGhpcy5maWx0ZXJzLCByZWxheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW1pc3RpY1B1Ymxpc2ggfHwgdGhpcy5za2lwT3B0aW1pc3RpY1B1Ymxpc2hFdmVudCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVtaXRFdmVudCh0aGlzLm9wdHM/LndyYXAgPz8gZmFsc2UsIG5ka0V2ZW50LCByZWxheSwgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCk7XG4gICAgICAgIHRoaXMuZXZlbnRGaXJzdFNlZW4uc2V0KGV2ZW50SWQsIERhdGUubm93KCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0aW1lU2luY2VGaXJzdFNlZW4gPSBEYXRlLm5vdygpIC0gKHRoaXMuZXZlbnRGaXJzdFNlZW4uZ2V0KGV2ZW50SWQpIHx8IDApO1xuICAgICAgdGhpcy5lbWl0KFwiZXZlbnQ6ZHVwXCIsIGV2ZW50LCByZWxheSwgdGltZVNpbmNlRmlyc3RTZWVuLCB0aGlzLCBmcm9tQ2FjaGUsIG9wdGltaXN0aWNQdWJsaXNoKTtcbiAgICAgIGlmIChyZWxheSkge1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB2ZXJpZmllZFNpZ25hdHVyZXMuZ2V0KGV2ZW50SWQpO1xuICAgICAgICBpZiAoc2lnbmF0dXJlICYmIHR5cGVvZiBzaWduYXR1cmUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuc2lnID09PSBzaWduYXR1cmUpIHtcbiAgICAgICAgICAgIHJlbGF5LmFkZFZhbGlkYXRlZEV2ZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGFzdEV2ZW50UmVjZWl2ZWRBdCA9IERhdGUubm93KCk7XG4gIH1cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgd3JhcHMsIHN5bmMgb3IgYXN5bmMsIGFuZCBlbWl0cyB0aGUgZXZlbnQgKGlmIG9uZSBjb21lcyBiYWNrIGZyb20gdGhlIHdyYXBwZXIpXG4gICAqL1xuICBlbWl0RXZlbnQod3JhcCwgZXZ0LCByZWxheSwgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCkge1xuICAgIGNvbnN0IHdyYXBwZWQgPSB3cmFwID8gd3JhcEV2ZW50KGV2dCkgOiBldnQ7XG4gICAgaWYgKHdyYXBwZWQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICB3cmFwcGVkLnRoZW4oKGUpID0+IHRoaXMuZW1pdEV2ZW50KGZhbHNlLCBlLCByZWxheSwgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCkpO1xuICAgIH0gZWxzZSBpZiAod3JhcHBlZCkge1xuICAgICAgdGhpcy5lbWl0KFwiZXZlbnRcIiwgd3JhcHBlZCwgcmVsYXksIHRoaXMsIGZyb21DYWNoZSwgb3B0aW1pc3RpY1B1Ymxpc2gpO1xuICAgIH1cbiAgfVxuICBjbG9zZWRSZWNlaXZlZChyZWxheSwgcmVhc29uKSB7XG4gICAgdGhpcy5lbWl0KFwiY2xvc2VkXCIsIHJlbGF5LCByZWFzb24pO1xuICB9XG4gIC8vIEVPU0UgaGFuZGxpbmdcbiAgZW9zZVRpbWVvdXQ7XG4gIGVvc2VkID0gZmFsc2U7XG4gIGVvc2VSZWNlaXZlZChyZWxheSkge1xuICAgIHRoaXMuZGVidWcoXCJFT1NFIHJlY2VpdmVkIGZyb20gJXNcIiwgcmVsYXkudXJsKTtcbiAgICB0aGlzLmVvc2VzU2Vlbi5hZGQocmVsYXkpO1xuICAgIGxldCBsYXN0RXZlbnRTZWVuID0gdGhpcy5sYXN0RXZlbnRSZWNlaXZlZEF0ID8gRGF0ZS5ub3coKSAtIHRoaXMubGFzdEV2ZW50UmVjZWl2ZWRBdCA6IHZvaWQgMDtcbiAgICBjb25zdCBoYXNTZWVuQWxsRW9zZXMgPSB0aGlzLmVvc2VzU2Vlbi5zaXplID09PSB0aGlzLnJlbGF5RmlsdGVycz8uc2l6ZTtcbiAgICBjb25zdCBxdWVyeUZpbGxlZCA9IHF1ZXJ5RnVsbHlGaWxsZWQodGhpcyk7XG4gICAgY29uc3QgcGVyZm9ybUVvc2UgPSAocmVhc29uKSA9PiB7XG4gICAgICB0aGlzLmRlYnVnKFwiUGVyZm9ybWluZyBFT1NFOiAlcyAlZFwiLCByZWFzb24sIHRoaXMuZW9zZWQpO1xuICAgICAgaWYgKHRoaXMuZW9zZWQpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmVvc2VUaW1lb3V0KSBjbGVhclRpbWVvdXQodGhpcy5lb3NlVGltZW91dCk7XG4gICAgICB0aGlzLmVtaXQoXCJlb3NlXCIsIHRoaXMpO1xuICAgICAgdGhpcy5lb3NlZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5vcHRzPy5jbG9zZU9uRW9zZSkgdGhpcy5zdG9wKCk7XG4gICAgfTtcbiAgICBpZiAocXVlcnlGaWxsZWQgfHwgaGFzU2VlbkFsbEVvc2VzKSB7XG4gICAgICBwZXJmb3JtRW9zZShcInF1ZXJ5IGZpbGxlZCBvciBzZWVuIGFsbFwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVsYXlGaWx0ZXJzKSB7XG4gICAgICBsZXQgdGltZVRvV2FpdEZvck5leHRFb3NlID0gMWUzO1xuICAgICAgY29uc3QgY29ubmVjdGVkUmVsYXlzID0gbmV3IFNldCh0aGlzLnBvb2wuY29ubmVjdGVkUmVsYXlzKCkubWFwKChyKSA9PiByLnVybCkpO1xuICAgICAgY29uc3QgY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMgPSBBcnJheS5mcm9tKHRoaXMucmVsYXlGaWx0ZXJzLmtleXMoKSkuZmlsdGVyKFxuICAgICAgICAodXJsKSA9PiBjb25uZWN0ZWRSZWxheXMuaGFzKHVybClcbiAgICAgICk7XG4gICAgICBpZiAoY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgICAgXCJObyBjb25uZWN0ZWQgcmVsYXlzLCB3YWl0aW5nIGZvciBhbGwgcmVsYXlzIHRvIGNvbm5lY3RcIixcbiAgICAgICAgICBBcnJheS5mcm9tKHRoaXMucmVsYXlGaWx0ZXJzLmtleXMoKSkuam9pbihcIiwgXCIpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2VPZlJlbGF5c1RoYXRIYXZlU2VudEVvc2UgPSB0aGlzLmVvc2VzU2Vlbi5zaXplIC8gY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMubGVuZ3RoO1xuICAgICAgdGhpcy5kZWJ1ZyhcIlBlcmNlbnRhZ2Ugb2YgcmVsYXlzIHRoYXQgaGF2ZSBzZW50IEVPU0VcIiwge1xuICAgICAgICBzdWJJZDogdGhpcy5zdWJJZCxcbiAgICAgICAgcGVyY2VudGFnZU9mUmVsYXlzVGhhdEhhdmVTZW50RW9zZSxcbiAgICAgICAgc2VlbjogdGhpcy5lb3Nlc1NlZW4uc2l6ZSxcbiAgICAgICAgdG90YWw6IGNvbm5lY3RlZFJlbGF5c1dpdGhGaWx0ZXJzLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5lb3Nlc1NlZW4uc2l6ZSA+PSAyICYmIHBlcmNlbnRhZ2VPZlJlbGF5c1RoYXRIYXZlU2VudEVvc2UgPj0gMC41KSB7XG4gICAgICAgIHRpbWVUb1dhaXRGb3JOZXh0RW9zZSA9IHRpbWVUb1dhaXRGb3JOZXh0RW9zZSAqICgxIC0gcGVyY2VudGFnZU9mUmVsYXlzVGhhdEhhdmVTZW50RW9zZSk7XG4gICAgICAgIGlmICh0aW1lVG9XYWl0Rm9yTmV4dEVvc2UgPT09IDApIHtcbiAgICAgICAgICBwZXJmb3JtRW9zZShcInRpbWUgdG8gd2FpdCB3YXMgMFwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW9zZVRpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLmVvc2VUaW1lb3V0KTtcbiAgICAgICAgY29uc3Qgc2VuZEVvc2VUaW1lb3V0ID0gKCkgPT4ge1xuICAgICAgICAgIGxhc3RFdmVudFNlZW4gPSB0aGlzLmxhc3RFdmVudFJlY2VpdmVkQXQgPyBEYXRlLm5vdygpIC0gdGhpcy5sYXN0RXZlbnRSZWNlaXZlZEF0IDogdm9pZCAwO1xuICAgICAgICAgIGlmIChsYXN0RXZlbnRTZWVuICE9PSB2b2lkIDAgJiYgbGFzdEV2ZW50U2VlbiA8IDIwKSB7XG4gICAgICAgICAgICB0aGlzLmVvc2VUaW1lb3V0ID0gc2V0VGltZW91dChzZW5kRW9zZVRpbWVvdXQsIHRpbWVUb1dhaXRGb3JOZXh0RW9zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlcmZvcm1Fb3NlKGBzZW5kIGVvc2UgdGltZW91dDogJHt0aW1lVG9XYWl0Rm9yTmV4dEVvc2V9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVvc2VUaW1lb3V0ID0gc2V0VGltZW91dChzZW5kRW9zZVRpbWVvdXQsIHRpbWVUb1dhaXRGb3JOZXh0RW9zZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIGtpbmRJc0VwaGVtZXJhbCA9IChraW5kKSA9PiBraW5kID49IDJlNCAmJiBraW5kIDwgM2U0O1xuXG4vLyBzcmMvdXNlci9mb2xsb3dzLnRzXG5hc3luYyBmdW5jdGlvbiBmb2xsb3dzKG9wdHMsIG91dGJveCwga2luZCA9IDMgLyogQ29udGFjdHMgKi8pIHtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIG5vdCBzZXRcIik7XG4gIGNvbnN0IGNvbnRhY3RMaXN0RXZlbnQgPSBhd2FpdCB0aGlzLm5kay5mZXRjaEV2ZW50KFxuICAgIHsga2luZHM6IFtraW5kXSwgYXV0aG9yczogW3RoaXMucHVia2V5XSB9LFxuICAgIG9wdHMgfHwgeyBncm91cGFibGU6IGZhbHNlIH1cbiAgKTtcbiAgaWYgKGNvbnRhY3RMaXN0RXZlbnQpIHtcbiAgICBjb25zdCBwdWJrZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb250YWN0TGlzdEV2ZW50LnRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICBpZiAodGFnWzBdID09PSBcInBcIikgcHVia2V5cy5hZGQodGFnWzFdKTtcbiAgICB9KTtcbiAgICBpZiAob3V0Ym94KSB7XG4gICAgICB0aGlzLm5kaz8ub3V0Ym94VHJhY2tlcj8udHJhY2tVc2VycyhBcnJheS5mcm9tKHB1YmtleXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIFsuLi5wdWJrZXlzXS5yZWR1Y2UoKGFjYywgcHVia2V5KSA9PiB7XG4gICAgICBjb25zdCB1c2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXkgfSk7XG4gICAgICB1c2VyLm5kayA9IHRoaXMubmRrO1xuICAgICAgYWNjLmFkZCh1c2VyKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG59XG5cbi8vIHNyYy91c2VyL25pcDA1LnRzXG52YXIgTklQMDVfUkVHRVggPSAvXig/OihbXFx3ListXSspQCk/KFtcXHcuLV0rKSQvO1xuYXN5bmMgZnVuY3Rpb24gZ2V0TmlwMDVGb3IobmRrLCBmdWxsbmFtZSwgX2ZldGNoID0gZmV0Y2gsIGZldGNoT3B0cyA9IHt9KSB7XG4gIHJldHVybiBhd2FpdCBuZGsucXVldWVzTmlwMDUuYWRkKHtcbiAgICBpZDogZnVsbG5hbWUsXG4gICAgZnVuYzogYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKG5kay5jYWNoZUFkYXB0ZXI/LmxvYWROaXAwNSkge1xuICAgICAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgbmRrLmNhY2hlQWRhcHRlci5sb2FkTmlwMDUoZnVsbG5hbWUpO1xuICAgICAgICBpZiAocHJvZmlsZSAhPT0gXCJtaXNzaW5nXCIpIHtcbiAgICAgICAgICBpZiAocHJvZmlsZSkge1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHtcbiAgICAgICAgICAgICAgcHVia2V5OiBwcm9maWxlLnB1YmtleSxcbiAgICAgICAgICAgICAgcmVsYXlVcmxzOiBwcm9maWxlLnJlbGF5cyxcbiAgICAgICAgICAgICAgbmlwNDZVcmxzOiBwcm9maWxlLm5pcDQ2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVzZXIubmRrID0gbmRrO1xuICAgICAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmZXRjaE9wdHMuY2FjaGUgIT09IFwibm8tY2FjaGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBtYXRjaCA9IGZ1bGxuYW1lLm1hdGNoKE5JUDA1X1JFR0VYKTtcbiAgICAgIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgW18sIG5hbWUgPSBcIl9cIiwgZG9tYWluXSA9IG1hdGNoO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgX2ZldGNoKGBodHRwczovLyR7ZG9tYWlufS8ud2VsbC1rbm93bi9ub3N0ci5qc29uP25hbWU9JHtuYW1lfWAsIGZldGNoT3B0cyk7XG4gICAgICAgIGNvbnN0IHsgbmFtZXMsIHJlbGF5cywgbmlwNDYgfSA9IHBhcnNlTklQMDVSZXN1bHQoYXdhaXQgcmVzLmpzb24oKSk7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IG5hbWVzW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGxldCBwcm9maWxlID0gbnVsbDtcbiAgICAgICAgaWYgKHB1YmtleSkge1xuICAgICAgICAgIHByb2ZpbGUgPSB7IHB1YmtleSwgcmVsYXlzOiByZWxheXM/LltwdWJrZXldLCBuaXA0NjogbmlwNDY/LltwdWJrZXldIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5kaz8uY2FjaGVBZGFwdGVyPy5zYXZlTmlwMDUpIHtcbiAgICAgICAgICBuZGsuY2FjaGVBZGFwdGVyLnNhdmVOaXAwNShmdWxsbmFtZSwgcHJvZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2ZpbGU7XG4gICAgICB9IGNhdGNoIChfZSkge1xuICAgICAgICBpZiAobmRrPy5jYWNoZUFkYXB0ZXI/LnNhdmVOaXAwNSkge1xuICAgICAgICAgIG5kaz8uY2FjaGVBZGFwdGVyLnNhdmVOaXAwNShmdWxsbmFtZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBOSVAwNSBmb3JcIiwgZnVsbG5hbWUsIF9lKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlTklQMDVSZXN1bHQoanNvbikge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgbmFtZXM6IHt9XG4gIH07XG4gIGZvciAoY29uc3QgW25hbWUsIHB1YmtleV0gb2YgT2JqZWN0LmVudHJpZXMoanNvbi5uYW1lcykpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHB1YmtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVzdWx0Lm5hbWVzW25hbWUudG9Mb3dlckNhc2UoKV0gPSBwdWJrZXk7XG4gICAgfVxuICB9XG4gIGlmIChqc29uLnJlbGF5cykge1xuICAgIHJlc3VsdC5yZWxheXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtwdWJrZXksIHJlbGF5c10gb2YgT2JqZWN0LmVudHJpZXMoanNvbi5yZWxheXMpKSB7XG4gICAgICBpZiAodHlwZW9mIHB1YmtleSA9PT0gXCJzdHJpbmdcIiAmJiBBcnJheS5pc0FycmF5KHJlbGF5cykpIHtcbiAgICAgICAgcmVzdWx0LnJlbGF5c1twdWJrZXldID0gcmVsYXlzLmZpbHRlcigocmVsYXkpID0+IHR5cGVvZiByZWxheSA9PT0gXCJzdHJpbmdcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChqc29uLm5pcDQ2KSB7XG4gICAgcmVzdWx0Lm5pcDQ2ID0ge307XG4gICAgZm9yIChjb25zdCBbcHVia2V5LCBuaXA0Nl0gb2YgT2JqZWN0LmVudHJpZXMoanNvbi5uaXA0NikpIHtcbiAgICAgIGlmICh0eXBlb2YgcHVia2V5ID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkobmlwNDYpKSB7XG4gICAgICAgIHJlc3VsdC5uaXA0NltwdWJrZXldID0gbmlwNDYuZmlsdGVyKChyZWxheSkgPT4gdHlwZW9mIHJlbGF5ID09PSBcInN0cmluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3VzZXIvcHJvZmlsZS50c1xuZnVuY3Rpb24gcHJvZmlsZUZyb21FdmVudChldmVudCkge1xuICBjb25zdCBwcm9maWxlID0ge307XG4gIGxldCBwYXlsb2FkO1xuICB0cnkge1xuICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGV2ZW50LmNvbnRlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHByb2ZpbGUgZXZlbnQ6ICR7ZXJyb3J9YCk7XG4gIH1cbiAgcHJvZmlsZS5wcm9maWxlRXZlbnQgPSBKU09OLnN0cmluZ2lmeShldmVudC5yYXdFdmVudCgpKTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGF5bG9hZCkpIHtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgcHJvZmlsZS5uYW1lID0gcGF5bG9hZC5uYW1lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXNwbGF5X25hbWVcIjpcbiAgICAgICAgcHJvZmlsZS5kaXNwbGF5TmFtZSA9IHBheWxvYWQuZGlzcGxheV9uYW1lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgY2FzZSBcInBpY3R1cmVcIjpcbiAgICAgICAgcHJvZmlsZS5waWN0dXJlID0gcGF5bG9hZC5waWN0dXJlIHx8IHBheWxvYWQuaW1hZ2U7XG4gICAgICAgIHByb2ZpbGUuaW1hZ2UgPSBwcm9maWxlLnBpY3R1cmU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJhbm5lclwiOlxuICAgICAgICBwcm9maWxlLmJhbm5lciA9IHBheWxvYWQuYmFubmVyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJiaW9cIjpcbiAgICAgICAgcHJvZmlsZS5iaW8gPSBwYXlsb2FkLmJpbztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibmlwMDVcIjpcbiAgICAgICAgcHJvZmlsZS5uaXAwNSA9IHBheWxvYWQubmlwMDU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImx1ZDA2XCI6XG4gICAgICAgIHByb2ZpbGUubHVkMDYgPSBwYXlsb2FkLmx1ZDA2O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsdWQxNlwiOlxuICAgICAgICBwcm9maWxlLmx1ZDE2ID0gcGF5bG9hZC5sdWQxNjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYWJvdXRcIjpcbiAgICAgICAgcHJvZmlsZS5hYm91dCA9IHBheWxvYWQuYWJvdXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIndlYnNpdGVcIjpcbiAgICAgICAgcHJvZmlsZS53ZWJzaXRlID0gcGF5bG9hZC53ZWJzaXRlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHByb2ZpbGVba2V5XSA9IHBheWxvYWRba2V5XTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHByb2ZpbGUuY3JlYXRlZF9hdCA9IGV2ZW50LmNyZWF0ZWRfYXQ7XG4gIHJldHVybiBwcm9maWxlO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplUHJvZmlsZShwcm9maWxlKSB7XG4gIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHByb2ZpbGUpKSB7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgXCJ1c2VybmFtZVwiOlxuICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgcGF5bG9hZC5uYW1lID0gdmFsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXNwbGF5TmFtZVwiOlxuICAgICAgICBwYXlsb2FkLmRpc3BsYXlfbmFtZSA9IHZhbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgIGNhc2UgXCJwaWN0dXJlXCI6XG4gICAgICAgIHBheWxvYWQucGljdHVyZSA9IHZhbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmlvXCI6XG4gICAgICBjYXNlIFwiYWJvdXRcIjpcbiAgICAgICAgcGF5bG9hZC5hYm91dCA9IHZhbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBwYXlsb2FkW2tleV0gPSB2YWw7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG59XG5cbi8vIHNyYy91c2VyL2luZGV4LnRzXG52YXIgTkRLVXNlciA9IGNsYXNzIF9OREtVc2VyIHtcbiAgbmRrO1xuICBwcm9maWxlO1xuICBwcm9maWxlRXZlbnQ7XG4gIF9ucHViO1xuICBfcHVia2V5O1xuICByZWxheVVybHMgPSBbXTtcbiAgbmlwNDZVcmxzID0gW107XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBpZiAob3B0cy5ucHViKSB0aGlzLl9ucHViID0gb3B0cy5ucHViO1xuICAgIGlmIChvcHRzLmhleHB1YmtleSkgdGhpcy5fcHVia2V5ID0gb3B0cy5oZXhwdWJrZXk7XG4gICAgaWYgKG9wdHMucHVia2V5KSB0aGlzLl9wdWJrZXkgPSBvcHRzLnB1YmtleTtcbiAgICBpZiAob3B0cy5yZWxheVVybHMpIHRoaXMucmVsYXlVcmxzID0gb3B0cy5yZWxheVVybHM7XG4gICAgaWYgKG9wdHMubmlwNDZVcmxzKSB0aGlzLm5pcDQ2VXJscyA9IG9wdHMubmlwNDZVcmxzO1xuICAgIGlmIChvcHRzLm5wcm9maWxlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gbmlwMTk1LmRlY29kZShvcHRzLm5wcm9maWxlKTtcbiAgICAgICAgaWYgKGRlY29kZWQudHlwZSA9PT0gXCJucHJvZmlsZVwiKSB7XG4gICAgICAgICAgdGhpcy5fcHVia2V5ID0gZGVjb2RlZC5kYXRhLnB1YmtleTtcbiAgICAgICAgICBpZiAoZGVjb2RlZC5kYXRhLnJlbGF5cyAmJiBkZWNvZGVkLmRhdGEucmVsYXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVsYXlVcmxzLnB1c2goLi4uZGVjb2RlZC5kYXRhLnJlbGF5cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZGVjb2RlIG5wcm9maWxlXCIsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgbnB1YigpIHtcbiAgICBpZiAoIXRoaXMuX25wdWIpIHtcbiAgICAgIGlmICghdGhpcy5fcHVia2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMuX25wdWIgPSBuaXAxOTUubnB1YkVuY29kZSh0aGlzLnB1YmtleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ucHViO1xuICB9XG4gIGdldCBucHJvZmlsZSgpIHtcbiAgICBjb25zdCByZWxheXMgPSB0aGlzLnByb2ZpbGVFdmVudD8ub25SZWxheXM/Lm1hcCgocikgPT4gci51cmwpO1xuICAgIHJldHVybiBuaXAxOTUubnByb2ZpbGVFbmNvZGUoe1xuICAgICAgcHVia2V5OiB0aGlzLnB1YmtleSxcbiAgICAgIHJlbGF5c1xuICAgIH0pO1xuICB9XG4gIHNldCBucHViKG5wdWIyKSB7XG4gICAgdGhpcy5fbnB1YiA9IG5wdWIyO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIncyBwdWJrZXlcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHVzZXIncyBwdWJrZXlcbiAgICovXG4gIGdldCBwdWJrZXkoKSB7XG4gICAgaWYgKCF0aGlzLl9wdWJrZXkpIHtcbiAgICAgIGlmICghdGhpcy5fbnB1YikgdGhyb3cgbmV3IEVycm9yKFwibnB1YiBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5fcHVia2V5ID0gbmlwMTk1LmRlY29kZSh0aGlzLm5wdWIpLmRhdGE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wdWJrZXk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgdXNlcidzIHB1YmtleVxuICAgKiBAcGFyYW0gcHVia2V5IHtzdHJpbmd9IFRoZSB1c2VyJ3MgcHVia2V5XG4gICAqL1xuICBzZXQgcHVia2V5KHB1YmtleSkge1xuICAgIHRoaXMuX3B1YmtleSA9IHB1YmtleTtcbiAgfVxuICAvKipcbiAgICogRXF1aXZhbGVudCB0byBOREtFdmVudC5maWx0ZXJzKCkuXG4gICAqIEByZXR1cm5zIHtOREtGaWx0ZXJ9XG4gICAqL1xuICBmaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHsgXCIjcFwiOiBbdGhpcy5wdWJrZXldIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgTklQLTU3IGFuZCBOSVAtNjEgaW5mb3JtYXRpb24gdGhhdCB0aGlzIHVzZXIgaGFzIHNpZ25hbGVkXG4gICAqXG4gICAqIEBwYXJhbSBnZXRBbGwge2Jvb2xlYW59IFdoZXRoZXIgdG8gZ2V0IGFsbCB6YXAgaW5mbyBvciBqdXN0IHRoZSBmaXJzdCBvbmVcbiAgICovXG4gIGFzeW5jIGdldFphcEluZm8odGltZW91dE1zKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIGNvbnN0IHByb21pc2VXaXRoVGltZW91dCA9IGFzeW5jIChwcm9taXNlKSA9PiB7XG4gICAgICBpZiAoIXRpbWVvdXRNcykgcmV0dXJuIHByb21pc2U7XG4gICAgICBsZXQgdGltZW91dElkO1xuICAgICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcihcIlRpbWVvdXRcIikpLCB0aW1lb3V0TXMpO1xuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW3Byb21pc2UsIHRpbWVvdXRQcm9taXNlXSk7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZSA9PT0gXCJUaW1lb3V0XCIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSBjYXRjaCAoX29yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBbdXNlclByb2ZpbGUsIG1pbnRMaXN0RXZlbnRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgcHJvbWlzZVdpdGhUaW1lb3V0KHRoaXMuZmV0Y2hQcm9maWxlKCkpLFxuICAgICAgcHJvbWlzZVdpdGhUaW1lb3V0KHRoaXMubmRrLmZldGNoRXZlbnQoeyBraW5kczogWzEwMDE5IC8qIENhc2h1TWludExpc3QgKi9dLCBhdXRob3JzOiBbdGhpcy5wdWJrZXldIH0pKVxuICAgIF0pO1xuICAgIGNvbnN0IHJlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKG1pbnRMaXN0RXZlbnQpIHtcbiAgICAgIGNvbnN0IG1pbnRMaXN0ID0gTkRLQ2FzaHVNaW50TGlzdC5mcm9tKG1pbnRMaXN0RXZlbnQpO1xuICAgICAgaWYgKG1pbnRMaXN0Lm1pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzLnNldChcIm5pcDYxXCIsIHtcbiAgICAgICAgICBtaW50czogbWludExpc3QubWludHMsXG4gICAgICAgICAgcmVsYXlzOiBtaW50TGlzdC5yZWxheXMsXG4gICAgICAgICAgcDJwazogbWludExpc3QucDJwa1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVzZXJQcm9maWxlKSB7XG4gICAgICBjb25zdCB7IGx1ZDA2LCBsdWQxNiB9ID0gdXNlclByb2ZpbGU7XG4gICAgICByZXMuc2V0KFwibmlwNTdcIiwgeyBsdWQwNiwgbHVkMTYgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIGFuIE5ES1VzZXIgZnJvbSBhIE5JUC0wNSBzdHJpbmdcbiAgICogQHBhcmFtIG5pcDA1SWQge3N0cmluZ30gVGhlIHVzZXIncyBOSVAtMDVcbiAgICogQHBhcmFtIG5kayB7TkRLfSBBbiBOREsgaW5zdGFuY2VcbiAgICogQHBhcmFtIHNraXBDYWNoZSB7Ym9vbGVhbn0gV2hldGhlciB0byBza2lwIHRoZSBjYWNoZSBvciBub3RcbiAgICogQHJldHVybnMge05ES1VzZXIgfCB1bmRlZmluZWR9IEFuIE5ES1VzZXIgaWYgb25lIGlzIGZvdW5kIGZvciB0aGUgZ2l2ZW4gTklQLTA1LCB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21OaXAwNShuaXAwNUlkLCBuZGssIHNraXBDYWNoZSA9IGZhbHNlKSB7XG4gICAgaWYgKCFuZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICBjb25zdCBvcHRzID0ge307XG4gICAgaWYgKHNraXBDYWNoZSkgb3B0cy5jYWNoZSA9IFwibm8tY2FjaGVcIjtcbiAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgZ2V0TmlwMDVGb3IobmRrLCBuaXAwNUlkLCBuZGs/Lmh0dHBGZXRjaCwgb3B0cyk7XG4gICAgaWYgKHByb2ZpbGUpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBuZXcgX05ES1VzZXIoe1xuICAgICAgICBwdWJrZXk6IHByb2ZpbGUucHVia2V5LFxuICAgICAgICByZWxheVVybHM6IHByb2ZpbGUucmVsYXlzLFxuICAgICAgICBuaXA0NlVybHM6IHByb2ZpbGUubmlwNDZcbiAgICAgIH0pO1xuICAgICAgdXNlci5uZGsgPSBuZGs7XG4gICAgICByZXR1cm4gdXNlcjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgdXNlcidzIHByb2ZpbGVcbiAgICogQHBhcmFtIG9wdHMge05ES1N1YnNjcmlwdGlvbk9wdGlvbnN9IEEgc2V0IG9mIE5ES1N1YnNjcmlwdGlvbk9wdGlvbnNcbiAgICogQHBhcmFtIHN0b3JlUHJvZmlsZUV2ZW50IHtib29sZWFufSBXaGV0aGVyIHRvIHN0b3JlIHRoZSBwcm9maWxlIGV2ZW50IG9yIG5vdFxuICAgKiBAcmV0dXJucyBVc2VyIFByb2ZpbGVcbiAgICovXG4gIGFzeW5jIGZldGNoUHJvZmlsZShvcHRzLCBzdG9yZVByb2ZpbGVFdmVudCA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIG5vdCBzZXRcIik7XG4gICAgbGV0IHNldE1ldGFkYXRhRXZlbnQgPSBudWxsO1xuICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXIgJiYgKHRoaXMubmRrLmNhY2hlQWRhcHRlci5mZXRjaFByb2ZpbGUgfHwgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmZldGNoUHJvZmlsZVN5bmMpICYmIG9wdHM/LmNhY2hlVXNhZ2UgIT09IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi8pIHtcbiAgICAgIGxldCBwcm9maWxlID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZmV0Y2hQcm9maWxlU3luYykge1xuICAgICAgICBwcm9maWxlID0gdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmZldGNoUHJvZmlsZVN5bmModGhpcy5wdWJrZXkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZmV0Y2hQcm9maWxlKSB7XG4gICAgICAgIHByb2ZpbGUgPSBhd2FpdCB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZmV0Y2hQcm9maWxlKHRoaXMucHVia2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9maWxlKSB7XG4gICAgICAgIHRoaXMucHJvZmlsZSA9IHByb2ZpbGU7XG4gICAgICAgIHJldHVybiBwcm9maWxlO1xuICAgICAgfVxuICAgIH1cbiAgICBvcHRzID8/PSB7fTtcbiAgICBvcHRzLmNhY2hlVXNhZ2UgPz89IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi87XG4gICAgb3B0cy5jbG9zZU9uRW9zZSA/Pz0gdHJ1ZTtcbiAgICBvcHRzLmdyb3VwYWJsZSA/Pz0gdHJ1ZTtcbiAgICBvcHRzLmdyb3VwYWJsZURlbGF5ID8/PSAyNTA7XG4gICAgaWYgKCFzZXRNZXRhZGF0YUV2ZW50KSB7XG4gICAgICBzZXRNZXRhZGF0YUV2ZW50ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudCh7IGtpbmRzOiBbMF0sIGF1dGhvcnM6IFt0aGlzLnB1YmtleV0gfSwgb3B0cyk7XG4gICAgfVxuICAgIGlmICghc2V0TWV0YWRhdGFFdmVudCkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5wcm9maWxlID0gcHJvZmlsZUZyb21FdmVudChzZXRNZXRhZGF0YUV2ZW50KTtcbiAgICBpZiAoc3RvcmVQcm9maWxlRXZlbnQgJiYgdGhpcy5wcm9maWxlICYmIHRoaXMubmRrLmNhY2hlQWRhcHRlciAmJiB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuc2F2ZVByb2ZpbGUpIHtcbiAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5zYXZlUHJvZmlsZSh0aGlzLnB1YmtleSwgdGhpcy5wcm9maWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvZmlsZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNldCBvZiB1c2VycyB0aGF0IHRoaXMgdXNlciBmb2xsb3dzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZm9sbG93U2V0IGluc3RlYWRcbiAgICovXG4gIGZvbGxvd3MgPSBmb2xsb3dzLmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2V0IG9mIHB1YmtleXMgdGhhdCB0aGlzIHVzZXIgZm9sbG93cy5cbiAgICpcbiAgICogQHBhcmFtIG9wdHMgLSBOREtTdWJzY3JpcHRpb25PcHRpb25zXG4gICAqIEBwYXJhbSBvdXRib3ggLSBib29sZWFuXG4gICAqIEBwYXJhbSBraW5kIC0gbnVtYmVyXG4gICAqL1xuICBhc3luYyBmb2xsb3dTZXQob3B0cywgb3V0Ym94LCBraW5kID0gMyAvKiBDb250YWN0cyAqLykge1xuICAgIGNvbnN0IGZvbGxvd3MyID0gYXdhaXQgdGhpcy5mb2xsb3dzKG9wdHMsIG91dGJveCwga2luZCk7XG4gICAgcmV0dXJuIG5ldyBTZXQoQXJyYXkuZnJvbShmb2xsb3dzMikubWFwKChmKSA9PiBmLnB1YmtleSkpO1xuICB9XG4gIC8qKiBAZGVwcmVjYXRlZCBVc2UgcmVmZXJlbmNlVGFncyBpbnN0ZWFkLiAqL1xuICAvKipcbiAgICogR2V0IHRoZSB0YWcgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyB1c2VyIGluIGFuIGV2ZW50XG4gICAqIEByZXR1cm5zIHtOREtUYWd9IGFuIE5ES1RhZ1xuICAgKi9cbiAgdGFnUmVmZXJlbmNlKCkge1xuICAgIHJldHVybiBbXCJwXCIsIHRoaXMucHVia2V5XTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB0YWdzIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVmZXJlbmNlIHRoaXMgdXNlciBpbiBhbiBldmVudFxuICAgKiBAcmV0dXJucyB7TkRLVGFnW119IGFuIGFycmF5IG9mIE5ES1RhZ1xuICAgKi9cbiAgcmVmZXJlbmNlVGFncyhtYXJrZXIpIHtcbiAgICBjb25zdCB0YWcgPSBbW1wicFwiLCB0aGlzLnB1YmtleV1dO1xuICAgIGlmICghbWFya2VyKSByZXR1cm4gdGFnO1xuICAgIHRhZ1swXS5wdXNoKFwiXCIsIG1hcmtlcik7XG4gICAgcmV0dXJuIHRhZztcbiAgfVxuICAvKipcbiAgICogUHVibGlzaGVzIHRoZSBjdXJyZW50IHByb2ZpbGUuXG4gICAqL1xuICBhc3luYyBwdWJsaXNoKCkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICBpZiAoIXRoaXMucHJvZmlsZSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gcHJvZmlsZSBhdmFpbGFibGVcIik7XG4gICAgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IDAsXG4gICAgICBjb250ZW50OiBzZXJpYWxpemVQcm9maWxlKHRoaXMucHJvZmlsZSlcbiAgICB9KTtcbiAgICBhd2FpdCBldmVudC5wdWJsaXNoKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIGZvbGxvdyB0byB0aGlzIHVzZXIncyBjb250YWN0IGxpc3RcbiAgICpcbiAgICogQHBhcmFtIG5ld0ZvbGxvdyB7TkRLVXNlcn0gVGhlIHVzZXIgdG8gZm9sbG93XG4gICAqIEBwYXJhbSBjdXJyZW50Rm9sbG93TGlzdCB7U2V0PE5ES1VzZXI+fSBUaGUgY3VycmVudCBmb2xsb3cgbGlzdFxuICAgKiBAcGFyYW0ga2luZCB7TkRLS2luZH0gVGhlIGtpbmQgdG8gdXNlIGZvciB0aGlzIGNvbnRhY3QgbGlzdCAoZGVmYXVsdHMgdG8gYDNgKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gVHJ1ZSBpZiB0aGUgZm9sbG93IHdhcyBhZGRlZCwgZmFsc2UgaWYgdGhlIGZvbGxvdyBhbHJlYWR5IGV4aXN0c1xuICAgKi9cbiAgYXN5bmMgZm9sbG93KG5ld0ZvbGxvdywgY3VycmVudEZvbGxvd0xpc3QsIGtpbmQgPSAzIC8qIENvbnRhY3RzICovKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGlmICghY3VycmVudEZvbGxvd0xpc3QpIHtcbiAgICAgIGN1cnJlbnRGb2xsb3dMaXN0ID0gYXdhaXQgdGhpcy5mb2xsb3dzKHZvaWQgMCwgdm9pZCAwLCBraW5kKTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRGb2xsb3dMaXN0LmhhcyhuZXdGb2xsb3cpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGN1cnJlbnRGb2xsb3dMaXN0LmFkZChuZXdGb2xsb3cpO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KHRoaXMubmRrLCB7IGtpbmQgfSk7XG4gICAgZm9yIChjb25zdCBmb2xsb3cgb2YgY3VycmVudEZvbGxvd0xpc3QpIHtcbiAgICAgIGV2ZW50LnRhZyhmb2xsb3cpO1xuICAgIH1cbiAgICBhd2FpdCBldmVudC5wdWJsaXNoKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGZvbGxvdyBmcm9tIHRoaXMgdXNlcidzIGNvbnRhY3QgbGlzdFxuICAgKlxuICAgKiBAcGFyYW0gdXNlciB7TkRLVXNlcn0gVGhlIHVzZXIgdG8gdW5mb2xsb3dcbiAgICogQHBhcmFtIGN1cnJlbnRGb2xsb3dMaXN0IHtTZXQ8TkRLVXNlcj59IFRoZSBjdXJyZW50IGZvbGxvdyBsaXN0XG4gICAqIEBwYXJhbSBraW5kIHtOREtLaW5kfSBUaGUga2luZCB0byB1c2UgZm9yIHRoaXMgY29udGFjdCBsaXN0IChkZWZhdWx0cyB0byBgM2ApXG4gICAqIEByZXR1cm5zIFRoZSByZWxheXMgd2VyZSB0aGUgZm9sbG93IGxpc3Qgd2FzIHB1Ymxpc2hlZCBvciBmYWxzZSBpZiB0aGUgdXNlciB3YXNuJ3QgZm91bmRcbiAgICovXG4gIGFzeW5jIHVuZm9sbG93KHVzZXIsIGN1cnJlbnRGb2xsb3dMaXN0LCBraW5kID0gMyAvKiBDb250YWN0cyAqLykge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBpZiAoIWN1cnJlbnRGb2xsb3dMaXN0KSB7XG4gICAgICBjdXJyZW50Rm9sbG93TGlzdCA9IGF3YWl0IHRoaXMuZm9sbG93cyh2b2lkIDAsIHZvaWQgMCwga2luZCk7XG4gICAgfVxuICAgIGNvbnN0IG5ld1VzZXJGb2xsb3dMaXN0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgZm91bmRVc2VyID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBmb2xsb3cgb2YgY3VycmVudEZvbGxvd0xpc3QpIHtcbiAgICAgIGlmIChmb2xsb3cucHVia2V5ICE9PSB1c2VyLnB1YmtleSkge1xuICAgICAgICBuZXdVc2VyRm9sbG93TGlzdC5hZGQoZm9sbG93KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kVXNlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm91bmRVc2VyKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHsga2luZCB9KTtcbiAgICBmb3IgKGNvbnN0IGZvbGxvdyBvZiBuZXdVc2VyRm9sbG93TGlzdCkge1xuICAgICAgZXZlbnQudGFnKGZvbGxvdyk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBldmVudC5wdWJsaXNoKCk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGEgdXNlcidzIE5JUC0wNSBpZGVudGlmaWVyICh1c3VhbGx5IGZldGNoZWQgZnJvbSB0aGVpciBraW5kOjAgcHJvZmlsZSBkYXRhKVxuICAgKlxuICAgKiBAcGFyYW0gbmlwMDVJZCBUaGUgTklQLTA1IHN0cmluZyB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuIHwgbnVsbD59IFRydWUgaWYgdGhlIE5JUC0wNSBpcyBmb3VuZCBhbmQgbWF0Y2hlcyB0aGlzIHVzZXIncyBwdWJrZXksXG4gICAqIEZhbHNlIGlmIHRoZSBOSVAtMDUgaXMgZm91bmQgYnV0IGRvZXNuJ3QgbWF0Y2ggdGhpcyB1c2VyJ3MgcHVia2V5LFxuICAgKiBudWxsIGlmIHRoZSBOSVAtMDUgaXNuJ3QgZm91bmQgb24gdGhlIGRvbWFpbiBvciB3ZSdyZSB1bmFibGUgdG8gdmVyaWZ5IChiZWNhdXNlIG9mIG5ldHdvcmsgaXNzdWVzLCBldGMuKVxuICAgKi9cbiAgYXN5bmMgdmFsaWRhdGVOaXAwNShuaXAwNUlkKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIGNvbnN0IHByb2ZpbGVQb2ludGVyID0gYXdhaXQgZ2V0TmlwMDVGb3IodGhpcy5uZGssIG5pcDA1SWQpO1xuICAgIGlmIChwcm9maWxlUG9pbnRlciA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHByb2ZpbGVQb2ludGVyLnB1YmtleSA9PT0gdGhpcy5wdWJrZXk7XG4gIH1cbn07XG5cbi8vIHNyYy91c2VyL3Bpbi50c1xuYXN5bmMgZnVuY3Rpb24gcGluRXZlbnQodXNlciwgZXZlbnQsIHBpbkV2ZW50MiwgcHVibGlzaCkge1xuICBjb25zdCBraW5kID0gMTAwMDEgLyogUGluTGlzdCAqLztcbiAgaWYgKCF1c2VyLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICB1c2VyLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgaWYgKCFwaW5FdmVudDIpIHtcbiAgICBjb25zdCBldmVudHMgPSBhd2FpdCB1c2VyLm5kay5mZXRjaEV2ZW50cyhcbiAgICAgIHsga2luZHM6IFtraW5kXSwgYXV0aG9yczogW3VzZXIucHVia2V5XSB9LFxuICAgICAgeyBjYWNoZVVzYWdlOiBcIk9OTFlfUkVMQVlcIiAvKiBPTkxZX1JFTEFZICovIH1cbiAgICApO1xuICAgIGlmIChldmVudHMuc2l6ZSA+IDApIHtcbiAgICAgIHBpbkV2ZW50MiA9IGxpc3RzX2RlZmF1bHQuZnJvbShBcnJheS5mcm9tKGV2ZW50cylbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwaW5FdmVudDIgPSBuZXcgTkRLRXZlbnQodXNlci5uZGssIHtcbiAgICAgICAga2luZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHBpbkV2ZW50Mi50YWcoZXZlbnQpO1xuICBpZiAocHVibGlzaCkge1xuICAgIGF3YWl0IHBpbkV2ZW50Mi5wdWJsaXNoKCk7XG4gIH1cbiAgcmV0dXJuIHBpbkV2ZW50Mjtcbn1cblxuLy8gc3JjL2V2ZW50cy9raW5kcy9jbGFzc2lmaWVkLnRzXG52YXIgTkRLQ2xhc3NpZmllZCA9IGNsYXNzIF9OREtDbGFzc2lmaWVkIGV4dGVuZHMgTkRLRXZlbnQge1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzMDQwMiAvKiBDbGFzc2lmaWVkICovO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTkRLQ2xhc3NpZmllZCBmcm9tIGFuIGV4aXN0aW5nIE5ES0V2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgTkRLRXZlbnQgdG8gY3JlYXRlIHRoZSBOREtDbGFzc2lmaWVkIGZyb20uXG4gICAqIEByZXR1cm5zIE5ES0NsYXNzaWZpZWRcbiAgICovXG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLQ2xhc3NpZmllZChldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCB0aXRsZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gLSBUaGUgY2xhc3NpZmllZCB0aXRsZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgdGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ0aXRsZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCB0aXRsZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHRpdGxlIC0gVGhlIHRpdGxlIHRvIHNldCBmb3IgdGhlIGNsYXNzaWZpZWQuXG4gICAqL1xuICBzZXQgdGl0bGUodGl0bGUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInRpdGxlXCIpO1xuICAgIGlmICh0aXRsZSkgdGhpcy50YWdzLnB1c2goW1widGl0bGVcIiwgdGl0bGVdKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCBzdW1tYXJ5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBjbGFzc2lmaWVkIHN1bW1hcnkgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHN1bW1hcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJzdW1tYXJ5XCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIHN1bW1hcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBzdW1tYXJ5IC0gVGhlIHN1bW1hcnkgdG8gc2V0IGZvciB0aGUgY2xhc3NpZmllZC5cbiAgICovXG4gIHNldCBzdW1tYXJ5KHN1bW1hcnkpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInN1bW1hcnlcIik7XG4gICAgaWYgKHN1bW1hcnkpIHRoaXMudGFncy5wdXNoKFtcInN1bW1hcnlcIiwgc3VtbWFyeV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkJ3MgcHVibGljYXRpb24gdGltZXN0YW1wLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfSAtIFRoZSBVbml4IHRpbWVzdGFtcCBvZiB3aGVuIHRoZSBjbGFzc2lmaWVkIHdhcyBwdWJsaXNoZWQgb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHB1Ymxpc2hlZF9hdCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwicHVibGlzaGVkX2F0XCIpO1xuICAgIGlmICh0YWcpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQodGFnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCdzIHB1YmxpY2F0aW9uIHRpbWVzdGFtcC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IHRpbWVzdGFtcCAtIFRoZSBVbml4IHRpbWVzdGFtcCB0byBzZXQgZm9yIHRoZSBjbGFzc2lmaWVkJ3MgcHVibGljYXRpb24gZGF0ZS5cbiAgICovXG4gIHNldCBwdWJsaXNoZWRfYXQodGltZXN0YW1wKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwdWJsaXNoZWRfYXRcIik7XG4gICAgaWYgKHRpbWVzdGFtcCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwdWJsaXNoZWRfYXRcIiwgdGltZXN0YW1wLnRvU3RyaW5nKCldKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgbG9jYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGNsYXNzaWZpZWQgbG9jYXRpb24gaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IGxvY2F0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwibG9jYXRpb25cIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgbG9jYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiB0byBzZXQgZm9yIHRoZSBjbGFzc2lmaWVkLlxuICAgKi9cbiAgc2V0IGxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJsb2NhdGlvblwiKTtcbiAgICBpZiAobG9jYXRpb24pIHRoaXMudGFncy5wdXNoKFtcImxvY2F0aW9uXCIsIGxvY2F0aW9uXSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgcHJpY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtOREtDbGFzc2lmaWVkUHJpY2VUYWcgfCB1bmRlZmluZWR9IC0gVGhlIGNsYXNzaWZpZWQgcHJpY2UgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHByaWNlKCkge1xuICAgIGNvbnN0IHByaWNlVGFnID0gdGhpcy50YWdzLmZpbmQoKHRhZykgPT4gdGFnWzBdID09PSBcInByaWNlXCIpO1xuICAgIGlmIChwcmljZVRhZykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYW1vdW50OiBOdW1iZXIucGFyc2VGbG9hdChwcmljZVRhZ1sxXSksXG4gICAgICAgIGN1cnJlbmN5OiBwcmljZVRhZ1syXSxcbiAgICAgICAgZnJlcXVlbmN5OiBwcmljZVRhZ1szXVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCBwcmljZS5cbiAgICpcbiAgICogQHBhcmFtIHByaWNlIC0gVGhlIHByaWNlIHRvIHNldCBmb3IgdGhlIGNsYXNzaWZpZWQuXG4gICAqL1xuICBzZXQgcHJpY2UocHJpY2VUYWcpIHtcbiAgICBpZiAodHlwZW9mIHByaWNlVGFnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwcmljZVRhZyA9IHtcbiAgICAgICAgYW1vdW50OiBOdW1iZXIucGFyc2VGbG9hdChwcmljZVRhZylcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChwcmljZVRhZz8uYW1vdW50KSB7XG4gICAgICBjb25zdCB0YWcgPSBbXCJwcmljZVwiLCBwcmljZVRhZy5hbW91bnQudG9TdHJpbmcoKV07XG4gICAgICBpZiAocHJpY2VUYWcuY3VycmVuY3kpIHRhZy5wdXNoKHByaWNlVGFnLmN1cnJlbmN5KTtcbiAgICAgIGlmIChwcmljZVRhZy5mcmVxdWVuY3kpIHRhZy5wdXNoKHByaWNlVGFnLmZyZXF1ZW5jeSk7XG4gICAgICB0aGlzLnRhZ3MucHVzaCh0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZVRhZyhcInByaWNlXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvbnRlbnQgdGFncyBmb3IgdGhlIGNsYXNzaWZpZWQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGZpcnN0IGNoZWNrcyBhbmQgc2V0cyB0aGUgcHVibGljYXRpb24gZGF0ZSBpZiBub3QgYXZhaWxhYmxlLFxuICAgKiBhbmQgdGhlbiBnZW5lcmF0ZXMgY29udGVudCB0YWdzIGJhc2VkIG9uIHRoZSBiYXNlIE5ES0V2ZW50IGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gLSBUaGUgZ2VuZXJhdGVkIGNvbnRlbnQgdGFncy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlVGFncygpIHtcbiAgICBzdXBlci5nZW5lcmF0ZVRhZ3MoKTtcbiAgICBpZiAoIXRoaXMucHVibGlzaGVkX2F0KSB7XG4gICAgICB0aGlzLnB1Ymxpc2hlZF9hdCA9IHRoaXMuY3JlYXRlZF9hdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2RyYWZ0cy50c1xudmFyIE5ES0RyYWZ0ID0gY2xhc3MgX05ES0RyYWZ0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBfZXZlbnQ7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMxMjM0IC8qIERyYWZ0ICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLRHJhZnQoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYW4gaWRlbnRpZmllciAoaS5lLiBkLXRhZylcbiAgICovXG4gIHNldCBpZGVudGlmaWVyKGlkKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImRcIiwgaWRdKTtcbiAgfVxuICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5kVGFnO1xuICB9XG4gIC8qKlxuICAgKiBFdmVudCB0aGF0IGlzIHRvIGJlIHNhdmVkLlxuICAgKi9cbiAgc2V0IGV2ZW50KGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIE5ES0V2ZW50KSB0aGlzLl9ldmVudCA9IGUucmF3RXZlbnQoKTtcbiAgICBlbHNlIHRoaXMuX2V2ZW50ID0gZTtcbiAgICB0aGlzLnByZXBhcmVFdmVudCgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBldmVudC5cbiAgICogQHBhcmFtIHBhcmFtMFxuICAgKiBAcmV0dXJucyBOREtFdmVudCBvZiB0aGUgZHJhZnQgZXZlbnQgb3IgbnVsbCBpZiB0aGUgZHJhZnQgZXZlbnQgaGFzIGJlZW4gZGVsZXRlZCAoZW1wdGllZCkuXG4gICAqL1xuICBhc3luYyBnZXRFdmVudChzaWduZXIpIHtcbiAgICBpZiAodGhpcy5fZXZlbnQpIHJldHVybiBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHRoaXMuX2V2ZW50KTtcbiAgICBzaWduZXIgPz89IHRoaXMubmRrPy5zaWduZXI7XG4gICAgaWYgKCFzaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHNpZ25lci51c2VyKCk7XG4gICAgaWYgKHRoaXMuY29udGVudCAmJiB0aGlzLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5kZWNyeXB0KHVzZXIsIHNpZ25lcik7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgICAgIHRoaXMuX2V2ZW50ID0gcGF5bG9hZDtcbiAgICAgICAgcmV0dXJuIG5ldyBOREtFdmVudCh0aGlzLm5kaywgcGF5bG9hZCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBwcmVwYXJlRXZlbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gZXZlbnQgaGFzIGJlZW4gcHJvdmlkZWRcIik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJrXCIpO1xuICAgIGlmICh0aGlzLl9ldmVudC5raW5kKSB0aGlzLnRhZ3MucHVzaChbXCJrXCIsIHRoaXMuX2V2ZW50LmtpbmQudG9TdHJpbmcoKV0pO1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHRoaXMuX2V2ZW50KTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGRyYWZ0IGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gc2lnbmVyOiBPcHRpb25hbCBzaWduZXIgdG8gZW5jcnlwdCB3aXRoXG4gICAqIEBwYXJhbSBwdWJsaXNoOiBXaGV0aGVyIHRvIHB1Ymxpc2gsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyByZWxheVNldCB0byBwdWJsaXNoIHRvXG4gICAqL1xuICBhc3luYyBzYXZlKHsgc2lnbmVyLCBwdWJsaXNoLCByZWxheVNldCB9KSB7XG4gICAgc2lnbmVyID8/PSB0aGlzLm5kaz8uc2lnbmVyO1xuICAgIGlmICghc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBzaWduZXIudXNlcigpO1xuICAgIGF3YWl0IHRoaXMuZW5jcnlwdCh1c2VyLCBzaWduZXIpO1xuICAgIGlmIChwdWJsaXNoID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2gocmVsYXlTZXQpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2R2bS9mZWVkYmFjay50c1xudmFyIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMyKSA9PiB7XG4gIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzMltcIlByb2Nlc3NpbmdcIl0gPSBcInByb2Nlc3NpbmdcIjtcbiAgTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMyW1wiU3VjY2Vzc1wiXSA9IFwic3VjY2Vzc1wiO1xuICBOREtEdm1Kb2JGZWVkYmFja1N0YXR1czJbXCJTY2hlZHVsZWRcIl0gPSBcInNjaGVkdWxlZFwiO1xuICBOREtEdm1Kb2JGZWVkYmFja1N0YXR1czJbXCJQYXlSZXFcIl0gPSBcInBheW1lbnRfcmVxdWlyZWRcIjtcbiAgcmV0dXJuIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzMjtcbn0pKE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzIHx8IHt9KTtcbnZhciBOREtEVk1Kb2JGZWVkYmFjayA9IGNsYXNzIF9OREtEVk1Kb2JGZWVkYmFjayBleHRlbmRzIE5ES0V2ZW50IHtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gN2UzIC8qIERWTUpvYkZlZWRiYWNrICovO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tKGV2ZW50KSB7XG4gICAgY29uc3QgZSA9IG5ldyBfTkRLRFZNSm9iRmVlZGJhY2soZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgICBpZiAoZS5lbmNyeXB0ZWQpIGF3YWl0IGUuZHZtRGVjcnlwdCgpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJzdGF0dXNcIik7XG4gIH1cbiAgc2V0IHN0YXR1cyhzdGF0dXMpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInN0YXR1c1wiKTtcbiAgICBpZiAoc3RhdHVzICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInN0YXR1c1wiLCBzdGF0dXNdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGVuY3J5cHRlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldE1hdGNoaW5nVGFncyhcImVuY3J5cHRlZFwiKVswXTtcbiAgfVxuICBhc3luYyBkdm1EZWNyeXB0KCkge1xuICAgIGF3YWl0IHRoaXMuZGVjcnlwdCgpO1xuICAgIGNvbnN0IGRlY3J5cHRlZENvbnRlbnQgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgdGhpcy50YWdzLnB1c2goLi4uZGVjcnlwdGVkQ29udGVudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvZHZtL3JlcXVlc3QudHNcbnZhciBOREtEVk1SZXF1ZXN0ID0gY2xhc3MgX05ES0RWTVJlcXVlc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLRFZNUmVxdWVzdChldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIHNldCBiaWQobXNhdEFtb3VudCkge1xuICAgIGlmIChtc2F0QW1vdW50ID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVtb3ZlVGFnKFwiYmlkXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJiaWRcIiwgbXNhdEFtb3VudC50b1N0cmluZygpXSk7XG4gICAgfVxuICB9XG4gIGdldCBiaWQoKSB7XG4gICAgY29uc3QgdiA9IHRoaXMudGFnVmFsdWUoXCJiaWRcIik7XG4gICAgaWYgKHYgPT09IHZvaWQgMCkgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHYpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGlucHV0IHRvIHRoZSBqb2JcbiAgICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3VtZW50cyB0byB0aGUgaW5wdXRcbiAgICovXG4gIGFkZElucHV0KC4uLmFyZ3MpIHtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJpXCIsIC4uLmFyZ3NdKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG5ldyBwYXJhbWV0ZXIgdG8gdGhlIGpvYlxuICAgKi9cbiAgYWRkUGFyYW0oLi4uYXJncykge1xuICAgIHRoaXMudGFncy5wdXNoKFtcInBhcmFtXCIsIC4uLmFyZ3NdKTtcbiAgfVxuICBzZXQgb3V0cHV0KG91dHB1dCkge1xuICAgIGlmIChvdXRwdXQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW1vdmVUYWcoXCJvdXRwdXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygb3V0cHV0ID09PSBcInN0cmluZ1wiKSBvdXRwdXQgPSBbb3V0cHV0XTtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcIm91dHB1dFwiLCAuLi5vdXRwdXRdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG91dHB1dCgpIHtcbiAgICBjb25zdCBvdXRwdXRUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcIm91dHB1dFwiKVswXTtcbiAgICByZXR1cm4gb3V0cHV0VGFnID8gb3V0cHV0VGFnLnNsaWNlKDEpIDogdm9pZCAwO1xuICB9XG4gIGdldCBwYXJhbXMoKSB7XG4gICAgY29uc3QgcGFyYW1UYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwYXJhbVwiKTtcbiAgICByZXR1cm4gcGFyYW1UYWdzLm1hcCgodCkgPT4gdC5zbGljZSgxKSk7XG4gIH1cbiAgZ2V0UGFyYW0obmFtZSkge1xuICAgIGNvbnN0IHBhcmFtVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwYXJhbVwiKS5maW5kKCh0KSA9PiB0WzFdID09PSBuYW1lKTtcbiAgICByZXR1cm4gcGFyYW1UYWcgPyBwYXJhbVRhZ1syXSA6IHZvaWQgMDtcbiAgfVxuICBjcmVhdGVGZWVkYmFjayhzdGF0dXMpIHtcbiAgICBjb25zdCBmZWVkYmFjayA9IG5ldyBOREtEVk1Kb2JGZWVkYmFjayh0aGlzLm5kayk7XG4gICAgZmVlZGJhY2sudGFnKHRoaXMsIFwiam9iXCIpO1xuICAgIGZlZWRiYWNrLnN0YXR1cyA9IHN0YXR1cztcbiAgICByZXR1cm4gZmVlZGJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgam9iIGVuY3J5cHRpb24gZm9yIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIGR2bSBEVk0gdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBzaWduZXIgU2lnbmVyIHRvIHVzZSBmb3IgZW5jcnlwdGlvblxuICAgKi9cbiAgYXN5bmMgZW5jcnlwdGlvbihkdm0sIHNpZ25lcikge1xuICAgIGNvbnN0IGR2bVRhZ3MgPSBbXCJpXCIsIFwicGFyYW1cIiwgXCJvdXRwdXRcIiwgXCJyZWxheXNcIiwgXCJiaWRcIl07XG4gICAgY29uc3QgdGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+IGR2bVRhZ3MuaW5jbHVkZXModFswXSkpO1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+ICFkdm1UYWdzLmluY2x1ZGVzKHRbMF0pKTtcbiAgICB0aGlzLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0YWdzKTtcbiAgICB0aGlzLnRhZyhkdm0pO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImVuY3J5cHRlZFwiXSk7XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0KGR2bSwgc2lnbmVyKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgRFZNIHRoYXQgd2lsbCByZWNlaXZlIHRoZSBldmVudFxuICAgKi9cbiAgc2V0IGR2bShkdm0pIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInBcIik7XG4gICAgaWYgKGR2bSkgdGhpcy50YWcoZHZtKTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9kdm0vTkRLVHJhbnNjcmlwdGlvbkRWTS50c1xudmFyIE5ES1RyYW5zY3JpcHRpb25EVk0gPSBjbGFzcyBfTkRLVHJhbnNjcmlwdGlvbkRWTSBleHRlbmRzIE5ES0RWTVJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIobmRrLCBldmVudCk7XG4gICAgdGhpcy5raW5kID0gNWUzIC8qIERWTVJlcVRleHRFeHRyYWN0aW9uICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLVHJhbnNjcmlwdGlvbkRWTShldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2Ugb2YgdGhlIHRyYW5zY3JpcHRpb25cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgY29uc3QgaW5wdXRUYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJpXCIpO1xuICAgIGlmIChpbnB1dFRhZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRUYWdzWzBdWzFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSB0aXRsZSB0YWdcbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSB0aXRsZSB0YWdcbiAgICovXG4gIHNldCB0aXRsZSh2YWx1ZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB2YWx1ZV0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgaW1hZ2UgdGFnXG4gICAqL1xuICBnZXQgaW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJpbWFnZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgaW1hZ2UgdGFnXG4gICAqL1xuICBzZXQgaW1hZ2UodmFsdWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImltYWdlXCIpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiaW1hZ2VcIiwgdmFsdWVdKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvZHZtL3Jlc3VsdC50c1xudmFyIE5ES0RWTUpvYlJlc3VsdCA9IGNsYXNzIF9OREtEVk1Kb2JSZXN1bHQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLRFZNSm9iUmVzdWx0KGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgc2V0QW1vdW50KG1zYXQsIGludm9pY2UpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImFtb3VudFwiKTtcbiAgICBjb25zdCB0YWcgPSBbXCJhbW91bnRcIiwgbXNhdC50b1N0cmluZygpXTtcbiAgICBpZiAoaW52b2ljZSkgdGFnLnB1c2goaW52b2ljZSk7XG4gICAgdGhpcy50YWdzLnB1c2godGFnKTtcbiAgfVxuICBzZXQgcmVzdWx0KHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5jb250ZW50ID0gXCJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250ZW50ID0gcmVzdWx0O1xuICAgIH1cbiAgfVxuICBnZXQgcmVzdWx0KCkge1xuICAgIGlmICh0aGlzLmNvbnRlbnQgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gIH1cbiAgc2V0IHN0YXR1cyhzdGF0dXMpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInN0YXR1c1wiKTtcbiAgICBpZiAoc3RhdHVzICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInN0YXR1c1wiLCBzdGF0dXNdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInN0YXR1c1wiKTtcbiAgfVxuICBnZXQgam9iUmVxdWVzdElkKCkge1xuICAgIGZvciAoY29uc3QgZVRhZyBvZiB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIikpIHtcbiAgICAgIGlmIChlVGFnWzJdID09PSBcImpvYlwiKSByZXR1cm4gZVRhZ1sxXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuam9iUmVxdWVzdCkgcmV0dXJuIHRoaXMuam9iUmVxdWVzdC5pZDtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImVcIik7XG4gIH1cbiAgc2V0IGpvYlJlcXVlc3QoZXZlbnQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInJlcXVlc3RcIik7XG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICB0aGlzLmtpbmQgPSBldmVudC5raW5kICsgMWUzO1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicmVxdWVzdFwiLCBKU09OLnN0cmluZ2lmeShldmVudC5yYXdFdmVudCgpKV0pO1xuICAgICAgdGhpcy50YWcoZXZlbnQpO1xuICAgIH1cbiAgfVxuICBnZXQgam9iUmVxdWVzdCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwicmVxdWVzdFwiKTtcbiAgICBpZiAodGFnID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTkRLRXZlbnQodGhpcy5uZGssIEpTT04ucGFyc2UodGFnKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvY2FzaHUvdHgudHNcbnZhciBNQVJLRVJTID0ge1xuICBSRURFRU1FRDogXCJyZWRlZW1lZFwiLFxuICBDUkVBVEVEOiBcImNyZWF0ZWRcIixcbiAgREVTVFJPWUVEOiBcImRlc3Ryb3llZFwiLFxuICBSRVNFUlZFRDogXCJyZXNlcnZlZFwiXG59O1xudmFyIE5ES0Nhc2h1V2FsbGV0VHggPSBjbGFzcyBfTkRLQ2FzaHVXYWxsZXRUeCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIE1BUktFUlMgPSBNQVJLRVJTO1xuICBzdGF0aWMga2luZCA9IDczNzYgLyogQ2FzaHVXYWxsZXRUeCAqLztcbiAgc3RhdGljIGtpbmRzID0gWzczNzYgLyogQ2FzaHVXYWxsZXRUeCAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcihuZGssIGV2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDczNzYgLyogQ2FzaHVXYWxsZXRUeCAqLztcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbShldmVudCkge1xuICAgIGNvbnN0IHdhbGxldENoYW5nZSA9IG5ldyBfTkRLQ2FzaHVXYWxsZXRUeChldmVudC5uZGssIGV2ZW50KTtcbiAgICBjb25zdCBwcmV2Q29udGVudCA9IHdhbGxldENoYW5nZS5jb250ZW50O1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB3YWxsZXRDaGFuZ2UuZGVjcnlwdCgpO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICB3YWxsZXRDaGFuZ2UuY29udGVudCA/Pz0gcHJldkNvbnRlbnQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb250ZW50VGFncyA9IEpTT04ucGFyc2Uod2FsbGV0Q2hhbmdlLmNvbnRlbnQpO1xuICAgICAgd2FsbGV0Q2hhbmdlLnRhZ3MgPSBbLi4uY29udGVudFRhZ3MsIC4uLndhbGxldENoYW5nZS50YWdzXTtcbiAgICB9IGNhdGNoIChfZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gd2FsbGV0Q2hhbmdlO1xuICB9XG4gIHNldCBkaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkaXJlY3Rpb25cIik7XG4gICAgaWYgKGRpcmVjdGlvbikgdGhpcy50YWdzLnB1c2goW1wiZGlyZWN0aW9uXCIsIGRpcmVjdGlvbl0pO1xuICB9XG4gIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJkaXJlY3Rpb25cIik7XG4gIH1cbiAgc2V0IGFtb3VudChhbW91bnQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImFtb3VudFwiKTtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJhbW91bnRcIiwgYW1vdW50LnRvU3RyaW5nKCldKTtcbiAgfVxuICBnZXQgYW1vdW50KCkge1xuICAgIGNvbnN0IHZhbCA9IHRoaXMudGFnVmFsdWUoXCJhbW91bnRcIik7XG4gICAgaWYgKHZhbCA9PT0gdm9pZCAwKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBOdW1iZXIodmFsKTtcbiAgfVxuICBzZXQgZmVlKGZlZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZmVlXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImZlZVwiLCBmZWUudG9TdHJpbmcoKV0pO1xuICB9XG4gIGdldCBmZWUoKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy50YWdWYWx1ZShcImZlZVwiKTtcbiAgICBpZiAodmFsID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIE51bWJlcih2YWwpO1xuICB9XG4gIHNldCB1bml0KHVuaXQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInVuaXRcIik7XG4gICAgaWYgKHVuaXQpIHRoaXMudGFncy5wdXNoKFtcInVuaXRcIiwgdW5pdC50b1N0cmluZygpXSk7XG4gIH1cbiAgZ2V0IHVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ1bml0XCIpO1xuICB9XG4gIHNldCBkZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZGVzY3JpcHRpb25cIik7XG4gICAgaWYgKGRlc2NyaXB0aW9uKSB0aGlzLnRhZ3MucHVzaChbXCJkZXNjcmlwdGlvblwiLCBkZXNjcmlwdGlvbi50b1N0cmluZygpXSk7XG4gIH1cbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZGVzY3JpcHRpb25cIik7XG4gIH1cbiAgc2V0IG1pbnQobWludCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwibWludFwiKTtcbiAgICBpZiAobWludCkgdGhpcy50YWdzLnB1c2goW1wibWludFwiLCBtaW50LnRvU3RyaW5nKCldKTtcbiAgfVxuICBnZXQgbWludCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcIm1pbnRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFRhZ3MgdG9rZW5zIHRoYXQgd2VyZSBjcmVhdGVkIGluIHRoaXMgaGlzdG9yeSBldmVudFxuICAgKi9cbiAgc2V0IGRlc3Ryb3llZFRva2VucyhldmVudHMpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goZXZlbnQudGFnUmVmZXJlbmNlKE1BUktFUlMuREVTVFJPWUVEKSk7XG4gICAgfVxuICB9XG4gIHNldCBkZXN0cm95ZWRUb2tlbklkcyhpZHMpIHtcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiZVwiLCBpZCwgXCJcIiwgTUFSS0VSUy5ERVNUUk9ZRURdKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRhZ3MgdG9rZW5zIHRoYXQgd2VyZSBjcmVhdGVkIGluIHRoaXMgaGlzdG9yeSBldmVudFxuICAgKi9cbiAgc2V0IGNyZWF0ZWRUb2tlbnMoZXZlbnRzKSB7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKGV2ZW50LnRhZ1JlZmVyZW5jZShNQVJLRVJTLkNSRUFURUQpKTtcbiAgICB9XG4gIH1cbiAgc2V0IHJlc2VydmVkVG9rZW5zKGV2ZW50cykge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChldmVudC50YWdSZWZlcmVuY2UoTUFSS0VSUy5SRVNFUlZFRCkpO1xuICAgIH1cbiAgfVxuICBhZGRSZWRlZW1lZE51dHphcChldmVudCkge1xuICAgIHRoaXMudGFnKGV2ZW50LCBNQVJLRVJTLlJFREVFTUVEKTtcbiAgfVxuICBhc3luYyB0b05vc3RyRXZlbnQocHVia2V5KSB7XG4gICAgY29uc3QgZW5jcnlwdGVkVGFncyA9IFtdO1xuICAgIGNvbnN0IHVuZW5jcnlwdGVkVGFncyA9IFtdO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgaWYgKCF0aGlzLnNob3VsZEVuY3J5cHRUYWcodGFnKSkge1xuICAgICAgICB1bmVuY3J5cHRlZFRhZ3MucHVzaCh0YWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5jcnlwdGVkVGFncy5wdXNoKHRhZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudGFncyA9IHVuZW5jcnlwdGVkVGFncy5maWx0ZXIoKHQpID0+IHRbMF0gIT09IFwiY2xpZW50XCIpO1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGVuY3J5cHRlZFRhZ3MpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5kaz8uc2lnbmVyPy51c2VyKCk7XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIsIHZvaWQgMCwgXCJuaXA0NFwiKTtcbiAgICByZXR1cm4gc3VwZXIudG9Ob3N0ckV2ZW50KHB1YmtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBlbnRyeSBpbmNsdWRlcyBhIHJlZGVtcHRpb24gb2YgYSBOdXR6YXBcbiAgICovXG4gIGdldCBoYXNOdXR6YXBSZWRlbXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIiwgTUFSS0VSUy5SRURFRU1FRCkubGVuZ3RoID4gMDtcbiAgfVxuICBzaG91bGRFbmNyeXB0VGFnKHRhZykge1xuICAgIGNvbnN0IHVuZW5jcnlwdGVkVGFnTmFtZXMgPSBbXCJjbGllbnRcIl07XG4gICAgaWYgKHVuZW5jcnlwdGVkVGFnTmFtZXMuaW5jbHVkZXModGFnWzBdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiB0YWdbM10gPT09IE1BUktFUlMuUkVERUVNRUQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRhZ1swXSA9PT0gXCJwXCIpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9OREtSZWxheUxpc3QudHNcbnZhciBSRUFEX01BUktFUiA9IFwicmVhZFwiO1xudmFyIFdSSVRFX01BUktFUiA9IFwid3JpdGVcIjtcbnZhciBOREtSZWxheUxpc3QgPSBjbGFzcyBfTkRLUmVsYXlMaXN0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAxMDAwMiAvKiBSZWxheUxpc3QgKi87XG4gIH1cbiAgc3RhdGljIGZyb20obmRrRXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtSZWxheUxpc3QobmRrRXZlbnQubmRrLCBuZGtFdmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICBnZXQgcmVhZFJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiclwiIHx8IHRhZ1swXSA9PT0gXCJyZWxheVwiKS5maWx0ZXIoKHRhZykgPT4gIXRhZ1syXSB8fCB0YWdbMl0gJiYgdGFnWzJdID09PSBSRUFEX01BUktFUikubWFwKCh0YWcpID0+IHRyeU5vcm1hbGl6ZVJlbGF5VXJsKHRhZ1sxXSkpLmZpbHRlcigodXJsKSA9PiAhIXVybCk7XG4gIH1cbiAgc2V0IHJlYWRSZWxheVVybHMocmVsYXlzKSB7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiByZWxheXMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInJcIiwgcmVsYXksIFJFQURfTUFSS0VSXSk7XG4gICAgfVxuICB9XG4gIGdldCB3cml0ZVJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiclwiIHx8IHRhZ1swXSA9PT0gXCJyZWxheVwiKS5maWx0ZXIoKHRhZykgPT4gIXRhZ1syXSB8fCB0YWdbMl0gJiYgdGFnWzJdID09PSBXUklURV9NQVJLRVIpLm1hcCgodGFnKSA9PiB0cnlOb3JtYWxpemVSZWxheVVybCh0YWdbMV0pKS5maWx0ZXIoKHVybCkgPT4gISF1cmwpO1xuICB9XG4gIHNldCB3cml0ZVJlbGF5VXJscyhyZWxheXMpIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHJlbGF5cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiclwiLCByZWxheSwgV1JJVEVfTUFSS0VSXSk7XG4gICAgfVxuICB9XG4gIGdldCBib3RoUmVsYXlVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJyXCIgfHwgdGFnWzBdID09PSBcInJlbGF5XCIpLmZpbHRlcigodGFnKSA9PiAhdGFnWzJdKS5tYXAoKHRhZykgPT4gdGFnWzFdKTtcbiAgfVxuICBzZXQgYm90aFJlbGF5VXJscyhyZWxheXMpIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHJlbGF5cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiclwiLCByZWxheV0pO1xuICAgIH1cbiAgfVxuICBnZXQgcmVsYXlzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJyXCIgfHwgdGFnWzBdID09PSBcInJlbGF5XCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICB9XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIHJlbGF5U2V0IGZvciB0aGUgcmVsYXlzIGluIHRoaXMgbGlzdC5cbiAgICovXG4gIGdldCByZWxheVNldCgpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREtSZWxheUxpc3QgaGFzIG5vIE5ESyBpbnN0YW5jZVwiKTtcbiAgICByZXR1cm4gbmV3IE5ES1JlbGF5U2V0KFxuICAgICAgbmV3IFNldCh0aGlzLnJlbGF5cy5tYXAoKHUpID0+IHRoaXMubmRrPy5wb29sLmdldFJlbGF5KHUpKS5maWx0ZXIoKHIpID0+ICEhcikpLFxuICAgICAgdGhpcy5uZGtcbiAgICApO1xuICB9XG59O1xuZnVuY3Rpb24gcmVsYXlMaXN0RnJvbUtpbmQzKG5kaywgY29udGFjdExpc3QpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjb250ZW50ID0gSlNPTi5wYXJzZShjb250YWN0TGlzdC5jb250ZW50KTtcbiAgICBjb25zdCByZWxheUxpc3QgPSBuZXcgTkRLUmVsYXlMaXN0KG5kayk7XG4gICAgY29uc3QgcmVhZFJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgd3JpdGVSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IFtrZXksIGNvbmZpZ10gb2YgT2JqZWN0LmVudHJpZXMoY29udGVudCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZVJlbGF5VXJsKGtleSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICByZWFkUmVsYXlzLmFkZChrZXkpO1xuICAgICAgICB3cml0ZVJlbGF5cy5hZGQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlbGF5Q29uZmlnID0gY29uZmlnO1xuICAgICAgICBpZiAocmVsYXlDb25maWcud3JpdGUpIHdyaXRlUmVsYXlzLmFkZChrZXkpO1xuICAgICAgICBpZiAocmVsYXlDb25maWcucmVhZCkgcmVhZFJlbGF5cy5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVsYXlMaXN0LnJlYWRSZWxheVVybHMgPSBBcnJheS5mcm9tKHJlYWRSZWxheXMpO1xuICAgIHJlbGF5TGlzdC53cml0ZVJlbGF5VXJscyA9IEFycmF5LmZyb20od3JpdGVSZWxheXMpO1xuICAgIHJldHVybiByZWxheUxpc3Q7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvbmlwODkvYXBwLWhhbmRsZXIudHNcbnZhciBOREtBcHBIYW5kbGVyRXZlbnQgPSBjbGFzcyBfTkRLQXBwSGFuZGxlckV2ZW50IGV4dGVuZHMgTkRLRXZlbnQge1xuICBwcm9maWxlO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzMTk5MCAvKiBBcHBIYW5kbGVyICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKG5ka0V2ZW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgX05ES0FwcEhhbmRsZXJFdmVudChuZGtFdmVudC5uZGssIG5ka0V2ZW50LnJhd0V2ZW50KCkpO1xuICAgIGlmIChldmVudC5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIGNvbnN0IGNvbWJpbmF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgY29tYmluYXRpb25Gcm9tVGFnID0gKHRhZykgPT4gW3RhZ1swXSwgdGFnWzJdXS5qb2luKFwiOlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHRhZ3NUb0luc3BlY3QgPSBbXCJ3ZWJcIiwgXCJhbmRyb2lkXCIsIFwiaW9zXCJdO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgaWYgKHRhZ3NUb0luc3BlY3QuaW5jbHVkZXModGFnWzBdKSkge1xuICAgICAgICBjb25zdCBjb21iaW5hdGlvbiA9IGNvbWJpbmF0aW9uRnJvbVRhZyh0YWcpO1xuICAgICAgICBpZiAoY29tYmluYXRpb25zLmhhcyhjb21iaW5hdGlvbikpIHtcbiAgICAgICAgICBpZiAoY29tYmluYXRpb25zLmdldChjb21iaW5hdGlvbikgIT09IHRhZ1sxXS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbWJpbmF0aW9ucy5zZXQoY29tYmluYXRpb24sIHRhZ1sxXS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoZXMgYXBwIGhhbmRsZXIgaW5mb3JtYXRpb25cbiAgICogSWYgbm8gYXBwIGluZm9ybWF0aW9uIGlzIGF2YWlsYWJsZSBvbiB0aGUga2luZDozMTk5MCxcbiAgICogd2UgZmV0Y2ggdGhlIGV2ZW50J3MgYXV0aG9yJ3MgcHJvZmlsZSBhbmQgcmV0dXJuIHRoYXQgaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGZldGNoUHJvZmlsZSgpIHtcbiAgICBpZiAodGhpcy5wcm9maWxlID09PSB2b2lkIDAgJiYgdGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHByb2ZpbGUgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgICAgIGlmIChwcm9maWxlPy5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2ZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9maWxlID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICAgIHRoaXMucHJvZmlsZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBhdXRob3IgPSB0aGlzLmF1dGhvcjtcbiAgICAgIGF1dGhvci5mZXRjaFByb2ZpbGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShhdXRob3IucHJvZmlsZSk7XG4gICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3JlcG9zdC50c1xudmFyIE5ES1JlcG9zdCA9IGNsYXNzIF9OREtSZXBvc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIF9yZXBvc3RlZEV2ZW50cztcbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtSZXBvc3QoZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgcmVwb3N0ZWQgZXZlbnRzIGJ5IHRoZSBjdXJyZW50IGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ga2xhc3MgT3B0aW9uYWwgY2xhc3MgdG8gY29udmVydCB0aGUgZXZlbnRzIHRvLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgcmVwb3N0ZWRFdmVudHMoa2xhc3MsIG9wdHMpIHtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3Qgc2V0XCIpO1xuICAgIGlmICh0aGlzLl9yZXBvc3RlZEV2ZW50cyAhPT0gdm9pZCAwKSByZXR1cm4gdGhpcy5fcmVwb3N0ZWRFdmVudHM7XG4gICAgZm9yIChjb25zdCBldmVudElkIG9mIHRoaXMucmVwb3N0ZWRFdmVudElkcygpKSB7XG4gICAgICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJGb3JJZChldmVudElkKTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudChmaWx0ZXIsIG9wdHMpO1xuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGl0ZW1zLnB1c2goa2xhc3MgPyBrbGFzcy5mcm9tKGV2ZW50KSA6IGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXBvc3RlZCBldmVudCBJRHMuXG4gICAqL1xuICByZXBvc3RlZEV2ZW50SWRzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0KSA9PiB0WzBdID09PSBcImVcIiB8fCB0WzBdID09PSBcImFcIikubWFwKCh0KSA9PiB0WzFdKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZpbHRlckZvcklkKGlkKSB7XG4gIGlmIChpZC5tYXRjaCgvOi8pKSB7XG4gICAgY29uc3QgW2tpbmQsIHB1YmtleSwgaWRlbnRpZmllcl0gPSBpZC5zcGxpdChcIjpcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmRzOiBbTnVtYmVyLnBhcnNlSW50KGtpbmQpXSxcbiAgICAgIGF1dGhvcnM6IFtwdWJrZXldLFxuICAgICAgXCIjZFwiOiBbaWRlbnRpZmllcl1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7IGlkczogW2lkXSB9O1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3N1YnNjcmlwdGlvbnMvcmVjZWlwdC50c1xuaW1wb3J0IGRlYnVnMyBmcm9tIFwiZGVidWdcIjtcbnZhciBOREtTdWJzY3JpcHRpb25SZWNlaXB0ID0gY2xhc3MgX05ES1N1YnNjcmlwdGlvblJlY2VpcHQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGRlYnVnO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSA3MDAzIC8qIFN1YnNjcmlwdGlvblJlY2VpcHQgKi87XG4gICAgdGhpcy5kZWJ1ZyA9IG5kaz8uZGVidWcuZXh0ZW5kKFwic3Vic2NyaXB0aW9uLXN0YXJ0XCIpID8/IGRlYnVnMyhcIm5kazpzdWJzY3JpcHRpb24tc3RhcnRcIik7XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtTdWJzY3JpcHRpb25SZWNlaXB0KGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIHBlcnNvbiBiZWluZyBzdWJzY3JpYmVkIHRvXG4gICAqL1xuICBnZXQgcmVjaXBpZW50KCkge1xuICAgIGNvbnN0IHBUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIik/LlswXTtcbiAgICBpZiAoIXBUYWcpIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBwVGFnWzFdIH0pO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIHNldCByZWNpcGllbnQodXNlcikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicFwiKTtcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJwXCIsIHVzZXIucHVia2V5XSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIHBlcnNvbiBzdWJzY3JpYmluZ1xuICAgKi9cbiAgZ2V0IHN1YnNjcmliZXIoKSB7XG4gICAgY29uc3QgUFRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiUFwiKT8uWzBdO1xuICAgIGlmICghUFRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCB1c2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXk6IFBUYWdbMV0gfSk7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgc2V0IHN1YnNjcmliZXIodXNlcikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiUFwiKTtcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJQXCIsIHVzZXIucHVia2V5XSk7XG4gIH1cbiAgc2V0IHN1YnNjcmlwdGlvblN0YXJ0KGV2ZW50KSB7XG4gICAgdGhpcy5kZWJ1ZyhgYmVmb3JlIHNldHRpbmcgc3Vic2NyaXB0aW9uIHN0YXJ0OiAke3RoaXMucmF3RXZlbnR9YCk7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJlXCIpO1xuICAgIHRoaXMudGFnKGV2ZW50LCBcInN1YnNjcmlwdGlvblwiLCB0cnVlKTtcbiAgICB0aGlzLmRlYnVnKGBhZnRlciBzZXR0aW5nIHN1YnNjcmlwdGlvbiBzdGFydDogJHt0aGlzLnJhd0V2ZW50fWApO1xuICB9XG4gIGdldCB0aWVyTmFtZSgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInRpZXJcIik/LlswXTtcbiAgICByZXR1cm4gdGFnPy5bMV07XG4gIH1cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgY29uc3QgcGVyaW9kID0gdGhpcy52YWxpZFBlcmlvZDtcbiAgICBpZiAoIXBlcmlvZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGVyaW9kLnN0YXJ0ID4gcGVyaW9kLmVuZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwVGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKTtcbiAgICBjb25zdCBQVGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiUFwiKTtcbiAgICBpZiAocFRhZ3MubGVuZ3RoICE9PSAxIHx8IFBUYWdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXQgdmFsaWRQZXJpb2QoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJ2YWxpZFwiKT8uWzBdO1xuICAgIGlmICghdGFnKSByZXR1cm4gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogbmV3IERhdGUoTnVtYmVyLnBhcnNlSW50KHRhZ1sxXSkgKiAxZTMpLFxuICAgICAgICBlbmQ6IG5ldyBEYXRlKE51bWJlci5wYXJzZUludCh0YWdbMl0pICogMWUzKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHNldCB2YWxpZFBlcmlvZChwZXJpb2QpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInZhbGlkXCIpO1xuICAgIGlmICghcGVyaW9kKSByZXR1cm47XG4gICAgdGhpcy50YWdzLnB1c2goW1xuICAgICAgXCJ2YWxpZFwiLFxuICAgICAgTWF0aC5mbG9vcihwZXJpb2Quc3RhcnQuZ2V0VGltZSgpIC8gMWUzKS50b1N0cmluZygpLFxuICAgICAgTWF0aC5mbG9vcihwZXJpb2QuZW5kLmdldFRpbWUoKSAvIDFlMykudG9TdHJpbmcoKVxuICAgIF0pO1xuICB9XG4gIGdldCBzdGFydFBlcmlvZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZFBlcmlvZD8uc3RhcnQ7XG4gIH1cbiAgZ2V0IGVuZFBlcmlvZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZFBlcmlvZD8uZW5kO1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdWJzY3JpcHRpb24gaXMgY3VycmVudGx5IGFjdGl2ZVxuICAgKi9cbiAgaXNBY3RpdmUodGltZSkge1xuICAgIHRpbWUgPz89IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IHBlcmlvZCA9IHRoaXMudmFsaWRQZXJpb2Q7XG4gICAgaWYgKCFwZXJpb2QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGltZSA8IHBlcmlvZC5zdGFydCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aW1lID4gcGVyaW9kLmVuZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3N1YnNjcmlwdGlvbnMvc3Vic2NyaXB0aW9uLXN0YXJ0LnRzXG5pbXBvcnQgZGVidWc0IGZyb20gXCJkZWJ1Z1wiO1xudmFyIE5ES1N1YnNjcmlwdGlvblN0YXJ0ID0gY2xhc3MgX05ES1N1YnNjcmlwdGlvblN0YXJ0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBkZWJ1ZztcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gNzAwMSAvKiBTdWJzY3JpYmUgKi87XG4gICAgdGhpcy5kZWJ1ZyA9IG5kaz8uZGVidWcuZXh0ZW5kKFwic3Vic2NyaXB0aW9uLXN0YXJ0XCIpID8/IGRlYnVnNChcIm5kazpzdWJzY3JpcHRpb24tc3RhcnRcIik7XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtTdWJzY3JpcHRpb25TdGFydChldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWNpcGllbnQgb2YgdGhlIHN1YnNjcmlwdGlvbi4gSS5lLiBUaGUgYXV0aG9yIG9mIHRoaXMgZXZlbnQgc3Vic2NyaWJlcyB0byB0aGlzIHVzZXIuXG4gICAqL1xuICBnZXQgcmVjaXBpZW50KCkge1xuICAgIGNvbnN0IHBUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIik/LlswXTtcbiAgICBpZiAoIXBUYWcpIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBwVGFnWzFdIH0pO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIHNldCByZWNpcGllbnQodXNlcikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicFwiKTtcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJwXCIsIHVzZXIucHVia2V5XSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICovXG4gIGdldCBhbW91bnQoKSB7XG4gICAgY29uc3QgYW1vdW50VGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhbW91bnRcIik/LlswXTtcbiAgICBpZiAoIWFtb3VudFRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gcGFyc2VUYWdUb1N1YnNjcmlwdGlvbkFtb3VudChhbW91bnRUYWcpO1xuICB9XG4gIHNldCBhbW91bnQoYW1vdW50KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhbW91bnRcIik7XG4gICAgaWYgKCFhbW91bnQpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChuZXdBbW91bnQoYW1vdW50LmFtb3VudCwgYW1vdW50LmN1cnJlbmN5LCBhbW91bnQudGVybSkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgaWQgb3IgTklQLTMzIHRhZyBpZCBvZiB0aGUgdGllciB0aGF0IHRoZSB1c2VyIGlzIHN1YnNjcmliaW5nIHRvLlxuICAgKi9cbiAgZ2V0IHRpZXJJZCgpIHtcbiAgICBjb25zdCBlVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJlXCIpPy5bMF07XG4gICAgY29uc3QgYVRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiYVwiKT8uWzBdO1xuICAgIGlmICghZVRhZyB8fCAhYVRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gZVRhZ1sxXSA/PyBhVGFnWzFdO1xuICB9XG4gIHNldCB0aWVyKHRpZXIpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImVcIik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhXCIpO1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZXZlbnRcIik7XG4gICAgaWYgKCF0aWVyKSByZXR1cm47XG4gICAgdGhpcy50YWcodGllcik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcInBcIiwgdGllci5wdWJrZXldKTtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJldmVudFwiLCBKU09OLnN0cmluZ2lmeSh0aWVyLnJhd0V2ZW50KCkpXSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoZXMgdGhlIHRpZXIgdGhhdCB0aGUgdXNlciBpcyBzdWJzY3JpYmluZyB0by5cbiAgICovXG4gIGFzeW5jIGZldGNoVGllcigpIHtcbiAgICBjb25zdCBldmVudFRhZyA9IHRoaXMudGFnVmFsdWUoXCJldmVudFwiKTtcbiAgICBpZiAoZXZlbnRUYWcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEV2ZW50ID0gSlNPTi5wYXJzZShldmVudFRhZyk7XG4gICAgICAgIHJldHVybiBuZXcgTkRLU3Vic2NyaXB0aW9uVGllcih0aGlzLm5kaywgcGFyc2VkRXZlbnQpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJGYWlsZWQgdG8gcGFyc2UgZXZlbnQgdGFnXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0aWVySWQgPSB0aGlzLnRpZXJJZDtcbiAgICBpZiAoIXRpZXJJZCkgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5uZGs/LmZldGNoRXZlbnQodGllcklkKTtcbiAgICBpZiAoIWUpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIE5ES1N1YnNjcmlwdGlvblRpZXIuZnJvbShlKTtcbiAgfVxuICBnZXQgaXNWYWxpZCgpIHtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhbW91bnRcIikubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiSW52YWxpZCAjIG9mIGFtb3VudCB0YWdcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5hbW91bnQpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJJbnZhbGlkIGFtb3VudCB0YWdcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIikubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiSW52YWxpZCAjIG9mIHAgdGFnXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVjaXBpZW50KSB7XG4gICAgICB0aGlzLmRlYnVnKFwiSW52YWxpZCBwIHRhZ1wiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMvZ2lmdC13cmFwcGluZy50c1xuaW1wb3J0IHsgZ2V0RXZlbnRIYXNoIGFzIGdldEV2ZW50SGFzaDIgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcblxuLy8gc3JjL3NpZ25lcnMvcHJpdmF0ZS1rZXkvaW5kZXgudHNcbmltcG9ydCB7IGZpbmFsaXplRXZlbnQsIGdlbmVyYXRlU2VjcmV0S2V5LCBnZXRQdWJsaWNLZXksIG5pcDA0LCBuaXA0NCB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4MiwgaGV4VG9CeXRlcyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBuaXAxOSBhcyBuaXAxOTYgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbnZhciBOREtQcml2YXRlS2V5U2lnbmVyID0gY2xhc3MgX05ES1ByaXZhdGVLZXlTaWduZXIge1xuICBfdXNlcjtcbiAgX3ByaXZhdGVLZXk7XG4gIF9wdWJrZXk7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgc2lnbmVyIGZyb20gYSBwcml2YXRlIGtleS5cbiAgICogQHBhcmFtIHByaXZhdGVLZXkgLSBUaGUgcHJpdmF0ZSBrZXkgdG8gdXNlIGluIGhleCBmb3JtIG9yIG5zZWMuXG4gICAqIEBwYXJhbSBuZGsgLSBUaGUgTkRLIGluc3RhbmNlIHRvIHVzZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGVLZXlPck5zZWMsIG5kaykge1xuICAgIGlmICh0eXBlb2YgcHJpdmF0ZUtleU9yTnNlYyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHByaXZhdGVLZXlPck5zZWMuc3RhcnRzV2l0aChcIm5zZWMxXCIpKSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgZGF0YSB9ID0gbmlwMTk2LmRlY29kZShwcml2YXRlS2V5T3JOc2VjKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwibnNlY1wiKSB0aGlzLl9wcml2YXRlS2V5ID0gZGF0YTtcbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByaXZhdGUga2V5IHByb3ZpZGVkLlwiKTtcbiAgICAgIH0gZWxzZSBpZiAocHJpdmF0ZUtleU9yTnNlYy5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVLZXkgPSBoZXhUb0J5dGVzKHByaXZhdGVLZXlPck5zZWMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcml2YXRlIGtleSBwcm92aWRlZC5cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3ByaXZhdGVLZXkgPSBwcml2YXRlS2V5T3JOc2VjO1xuICAgIH1cbiAgICB0aGlzLl9wdWJrZXkgPSBnZXRQdWJsaWNLZXkodGhpcy5fcHJpdmF0ZUtleSk7XG4gICAgaWYgKG5kaykgdGhpcy5fdXNlciA9IG5kay5nZXRVc2VyKHsgcHVia2V5OiB0aGlzLl9wdWJrZXkgfSk7XG4gICAgdGhpcy5fdXNlciA/Pz0gbmV3IE5ES1VzZXIoeyBwdWJrZXk6IHRoaXMuX3B1YmtleSB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBwcml2YXRlIGtleSBpbiBoZXggZm9ybS5cbiAgICovXG4gIGdldCBwcml2YXRlS2V5KCkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSkgdGhyb3cgbmV3IEVycm9yKFwiTm90IHJlYWR5XCIpO1xuICAgIHJldHVybiBieXRlc1RvSGV4Mih0aGlzLl9wcml2YXRlS2V5KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBwdWJsaWMga2V5IGluIGhleCBmb3JtLlxuICAgKi9cbiAgZ2V0IHB1YmtleSgpIHtcbiAgICBpZiAoIXRoaXMuX3B1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiTm90IHJlYWR5XCIpO1xuICAgIHJldHVybiB0aGlzLl9wdWJrZXk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJpdmF0ZSBrZXkgaW4gbnNlYyBmb3JtLlxuICAgKi9cbiAgZ2V0IG5zZWMoKSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlS2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgcmVhZHlcIik7XG4gICAgcmV0dXJuIG5pcDE5Ni5uc2VjRW5jb2RlKHRoaXMuX3ByaXZhdGVLZXkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1YmxpYyBrZXkgaW4gbnB1YiBmb3JtLlxuICAgKi9cbiAgZ2V0IG5wdWIoKSB7XG4gICAgaWYgKCF0aGlzLl9wdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIk5vdCByZWFkeVwiKTtcbiAgICByZXR1cm4gbmlwMTk2Lm5wdWJFbmNvZGUodGhpcy5fcHVia2V5KTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgYSBuZXcgcHJpdmF0ZSBrZXkuXG4gICAqL1xuICBzdGF0aWMgZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGdlbmVyYXRlU2VjcmV0S2V5KCk7XG4gICAgcmV0dXJuIG5ldyBfTkRLUHJpdmF0ZUtleVNpZ25lcihwcml2YXRlS2V5KTtcbiAgfVxuICAvKipcbiAgICogTm9vcCBpbiBOREtQcml2YXRlS2V5U2lnbmVyLlxuICAgKi9cbiAgYXN5bmMgYmxvY2tVbnRpbFJlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIuXG4gICAqL1xuICBhc3luYyB1c2VyKCkge1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIuXG4gICAqL1xuICBnZXQgdXNlclN5bmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXI7XG4gIH1cbiAgYXN5bmMgc2lnbihldmVudCkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gc2lnbiB3aXRob3V0IGEgcHJpdmF0ZSBrZXlcIik7XG4gICAgfVxuICAgIHJldHVybiBmaW5hbGl6ZUV2ZW50KGV2ZW50LCB0aGlzLl9wcml2YXRlS2V5KS5zaWc7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdGlvbkVuYWJsZWQoc2NoZW1lKSB7XG4gICAgY29uc3QgZW5hYmxlZCA9IFtdO1xuICAgIGlmICghc2NoZW1lIHx8IHNjaGVtZSA9PT0gXCJuaXAwNFwiKSBlbmFibGVkLnB1c2goXCJuaXAwNFwiKTtcbiAgICBpZiAoIXNjaGVtZSB8fCBzY2hlbWUgPT09IFwibmlwNDRcIikgZW5hYmxlZC5wdXNoKFwibmlwNDRcIik7XG4gICAgcmV0dXJuIGVuYWJsZWQ7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdChyZWNpcGllbnQsIHZhbHVlLCBzY2hlbWUpIHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGVLZXkgfHwgIXRoaXMucHJpdmF0ZUtleSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gZW5jcnlwdCB3aXRob3V0IGEgcHJpdmF0ZSBrZXlcIik7XG4gICAgfVxuICAgIGNvbnN0IHJlY2lwaWVudEhleFB1YktleSA9IHJlY2lwaWVudC5wdWJrZXk7XG4gICAgaWYgKHNjaGVtZSA9PT0gXCJuaXA0NFwiKSB7XG4gICAgICBjb25zdCBjb252ZXJzYXRpb25LZXkgPSBuaXA0NC52Mi51dGlscy5nZXRDb252ZXJzYXRpb25LZXkodGhpcy5fcHJpdmF0ZUtleSwgcmVjaXBpZW50SGV4UHViS2V5KTtcbiAgICAgIHJldHVybiBhd2FpdCBuaXA0NC52Mi5lbmNyeXB0KHZhbHVlLCBjb252ZXJzYXRpb25LZXkpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgbmlwMDQuZW5jcnlwdCh0aGlzLl9wcml2YXRlS2V5LCByZWNpcGllbnRIZXhQdWJLZXksIHZhbHVlKTtcbiAgfVxuICBhc3luYyBkZWNyeXB0KHNlbmRlciwgdmFsdWUsIHNjaGVtZSkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSB8fCAhdGhpcy5wcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkF0dGVtcHRlZCB0byBkZWNyeXB0IHdpdGhvdXQgYSBwcml2YXRlIGtleVwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2VuZGVySGV4UHViS2V5ID0gc2VuZGVyLnB1YmtleTtcbiAgICBpZiAoc2NoZW1lID09PSBcIm5pcDQ0XCIpIHtcbiAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbktleSA9IG5pcDQ0LnYyLnV0aWxzLmdldENvbnZlcnNhdGlvbktleSh0aGlzLl9wcml2YXRlS2V5LCBzZW5kZXJIZXhQdWJLZXkpO1xuICAgICAgcmV0dXJuIGF3YWl0IG5pcDQ0LnYyLmRlY3J5cHQodmFsdWUsIGNvbnZlcnNhdGlvbktleSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBuaXAwNC5kZWNyeXB0KHRoaXMuX3ByaXZhdGVLZXksIHNlbmRlckhleFB1YktleSwgdmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBzaWduZXIncyBwcml2YXRlIGtleSBpbnRvIGEgc3RvcmFibGUgZm9ybWF0LlxuICAgKiBAcmV0dXJucyBBIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHR5cGUgYW5kIHRoZSBoZXggcHJpdmF0ZSBrZXkuXG4gICAqL1xuICB0b1BheWxvYWQoKSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlS2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJQcml2YXRlIGtleSBub3QgYXZhaWxhYmxlXCIpO1xuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICB0eXBlOiBcInByaXZhdGUta2V5XCIsXG4gICAgICBwYXlsb2FkOiB0aGlzLnByaXZhdGVLZXlcbiAgICAgIC8vIFVzZSB0aGUgaGV4IHByaXZhdGUga2V5XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gIH1cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplcyB0aGUgc2lnbmVyIGZyb20gYSBwYXlsb2FkIHN0cmluZy5cbiAgICogQHBhcmFtIHBheWxvYWRTdHJpbmcgVGhlIEpTT04gc3RyaW5nIG9idGFpbmVkIGZyb20gdG9QYXlsb2FkKCkuXG4gICAqIEBwYXJhbSBuZGsgT3B0aW9uYWwgTkRLIGluc3RhbmNlLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBOREtQcml2YXRlS2V5U2lnbmVyLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21QYXlsb2FkKHBheWxvYWRTdHJpbmcsIG5kaykge1xuICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKHBheWxvYWRTdHJpbmcpO1xuICAgIGlmIChwYXlsb2FkLnR5cGUgIT09IFwicHJpdmF0ZS1rZXlcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBheWxvYWQgdHlwZTogZXhwZWN0ZWQgJ3ByaXZhdGUta2V5JywgZ290ICR7cGF5bG9hZC50eXBlfWApO1xuICAgIH1cbiAgICBpZiAoIXBheWxvYWQucGF5bG9hZCB8fCB0eXBlb2YgcGF5bG9hZC5wYXlsb2FkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBheWxvYWQgY29udGVudCBmb3IgcHJpdmF0ZS1rZXkgc2lnbmVyXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9OREtQcml2YXRlS2V5U2lnbmVyKHBheWxvYWQucGF5bG9hZCwgbmRrKTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9naWZ0LXdyYXBwaW5nLnRzXG5hc3luYyBmdW5jdGlvbiBnaWZ0V3JhcChldmVudCwgcmVjaXBpZW50LCBzaWduZXIsIHBhcmFtcyA9IHt9KSB7XG4gIGxldCBfc2lnbmVyID0gc2lnbmVyO1xuICBwYXJhbXMuc2NoZW1lID8/PSBcIm5pcDQ0XCI7XG4gIGlmICghX3NpZ25lcikge1xuICAgIGlmICghZXZlbnQubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBzaWduZXIgYXZhaWxhYmxlIGZvciBnaWZ0V3JhcFwiKTtcbiAgICBfc2lnbmVyID0gZXZlbnQubmRrLnNpZ25lcjtcbiAgfVxuICBpZiAoIV9zaWduZXIpIHRocm93IG5ldyBFcnJvcihcIm5vIHNpZ25lclwiKTtcbiAgaWYgKCFfc2lnbmVyLmVuY3J5cHRpb25FbmFibGVkIHx8ICFfc2lnbmVyLmVuY3J5cHRpb25FbmFibGVkKHBhcmFtcy5zY2hlbWUpKVxuICAgIHRocm93IG5ldyBFcnJvcihcInNpZ25lciBpcyBub3QgYWJsZSB0byBnaWZ0V3JhcFwiKTtcbiAgY29uc3QgcnVtb3IgPSBnZXRSdW1vckV2ZW50KGV2ZW50LCBwYXJhbXM/LnJ1bW9yS2luZCk7XG4gIGNvbnN0IHNlYWwgPSBhd2FpdCBnZXRTZWFsRXZlbnQocnVtb3IsIHJlY2lwaWVudCwgX3NpZ25lciwgcGFyYW1zLnNjaGVtZSk7XG4gIGNvbnN0IHdyYXAgPSBhd2FpdCBnZXRXcmFwRXZlbnQoc2VhbCwgcmVjaXBpZW50LCBwYXJhbXMpO1xuICByZXR1cm4gbmV3IE5ES0V2ZW50KGV2ZW50Lm5kaywgd3JhcCk7XG59XG5hc3luYyBmdW5jdGlvbiBnaWZ0VW53cmFwKGV2ZW50LCBzZW5kZXIsIHNpZ25lciwgc2NoZW1lID0gXCJuaXA0NFwiKSB7XG4gIGNvbnN0IF9zZW5kZXIgPSBzZW5kZXIgfHwgbmV3IE5ES1VzZXIoeyBwdWJrZXk6IGV2ZW50LnB1YmtleSB9KTtcbiAgbGV0IF9zaWduZXIgPSBzaWduZXI7XG4gIGlmICghX3NpZ25lcikge1xuICAgIGlmICghZXZlbnQubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBzaWduZXIgYXZhaWxhYmxlIGZvciBnaWZ0VW53cmFwXCIpO1xuICAgIF9zaWduZXIgPSBldmVudC5uZGsuc2lnbmVyO1xuICB9XG4gIGlmICghc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBzaWduZXJcIik7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2VhbCA9IEpTT04ucGFyc2UoYXdhaXQgc2lnbmVyLmRlY3J5cHQoX3NlbmRlciwgZXZlbnQuY29udGVudCwgc2NoZW1lKSk7XG4gICAgaWYgKCFzZWFsKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVjcnlwdCB3cmFwcGVyXCIpO1xuICAgIGlmICghbmV3IE5ES0V2ZW50KHZvaWQgMCwgc2VhbCkudmVyaWZ5U2lnbmF0dXJlKGZhbHNlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkdpZnRTZWFsIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkIVwiKTtcbiAgICBjb25zdCBydW1vclNlbmRlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBzZWFsLnB1YmtleSB9KTtcbiAgICBjb25zdCBydW1vciA9IEpTT04ucGFyc2UoYXdhaXQgc2lnbmVyLmRlY3J5cHQocnVtb3JTZW5kZXIsIHNlYWwuY29udGVudCwgc2NoZW1lKSk7XG4gICAgaWYgKCFydW1vcikgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY3J5cHQgc2VhbFwiKTtcbiAgICBpZiAocnVtb3IucHVia2V5ICE9PSBzZWFsLnB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBHaWZ0V3JhcCwgc2VuZGVyIHZhbGlkYXRpb24gZmFpbGVkIVwiKTtcbiAgICByZXR1cm4gbmV3IE5ES0V2ZW50KGV2ZW50Lm5kaywgcnVtb3IpO1xuICB9IGNhdGNoIChfZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIkdvdCBlcnJvciB1bndyYXBwaW5nIGV2ZW50ISBTZWUgY29uc29sZSBsb2cuXCIpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSdW1vckV2ZW50KGV2ZW50LCBraW5kKSB7XG4gIGNvbnN0IHJ1bW9yID0gZXZlbnQucmF3RXZlbnQoKTtcbiAgcnVtb3Iua2luZCA9IGtpbmQgfHwgcnVtb3Iua2luZCB8fCAxNCAvKiBQcml2YXRlRGlyZWN0TWVzc2FnZSAqLztcbiAgcnVtb3Iuc2lnID0gdm9pZCAwO1xuICBydW1vci5pZCA9IGdldEV2ZW50SGFzaDIocnVtb3IpO1xuICByZXR1cm4gbmV3IE5ES0V2ZW50KGV2ZW50Lm5kaywgcnVtb3IpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U2VhbEV2ZW50KHJ1bW9yLCByZWNpcGllbnQsIHNpZ25lciwgc2NoZW1lID0gXCJuaXA0NFwiKSB7XG4gIGNvbnN0IHNlYWwgPSBuZXcgTkRLRXZlbnQocnVtb3IubmRrKTtcbiAgc2VhbC5raW5kID0gMTMgLyogR2lmdFdyYXBTZWFsICovO1xuICBzZWFsLmNyZWF0ZWRfYXQgPSBhcHByb3hpbWF0ZU5vdyg1KTtcbiAgc2VhbC5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkocnVtb3IucmF3RXZlbnQoKSk7XG4gIGF3YWl0IHNlYWwuZW5jcnlwdChyZWNpcGllbnQsIHNpZ25lciwgc2NoZW1lKTtcbiAgYXdhaXQgc2VhbC5zaWduKHNpZ25lcik7XG4gIHJldHVybiBzZWFsO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0V3JhcEV2ZW50KHNlYWxlZCwgcmVjaXBpZW50LCBwYXJhbXMsIHNjaGVtZSA9IFwibmlwNDRcIikge1xuICBjb25zdCBzaWduZXIgPSBOREtQcml2YXRlS2V5U2lnbmVyLmdlbmVyYXRlKCk7XG4gIGNvbnN0IHdyYXAgPSBuZXcgTkRLRXZlbnQoc2VhbGVkLm5kayk7XG4gIHdyYXAua2luZCA9IDEwNTkgLyogR2lmdFdyYXAgKi87XG4gIHdyYXAuY3JlYXRlZF9hdCA9IGFwcHJveGltYXRlTm93KDUpO1xuICBpZiAocGFyYW1zPy53cmFwVGFncykgd3JhcC50YWdzID0gcGFyYW1zLndyYXBUYWdzO1xuICB3cmFwLnRhZyhyZWNpcGllbnQpO1xuICB3cmFwLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShzZWFsZWQucmF3RXZlbnQoKSk7XG4gIGF3YWl0IHdyYXAuZW5jcnlwdChyZWNpcGllbnQsIHNpZ25lciwgc2NoZW1lKTtcbiAgYXdhaXQgd3JhcC5zaWduKHNpZ25lcik7XG4gIHJldHVybiB3cmFwO1xufVxuZnVuY3Rpb24gYXBwcm94aW1hdGVOb3coZHJpZnQgPSAwKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxZTMgLSBNYXRoLnJhbmRvbSgpICogMTAgKiogZHJpZnQpO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3NpbXBsZS1ncm91cC9pbmRleC50c1xudmFyIE5ES1NpbXBsZUdyb3VwID0gY2xhc3MgX05ES1NpbXBsZUdyb3VwIHtcbiAgbmRrO1xuICBncm91cElkO1xuICByZWxheVNldDtcbiAgZmV0Y2hpbmdNZXRhZGF0YTtcbiAgbWV0YWRhdGE7XG4gIG1lbWJlckxpc3Q7XG4gIGFkbWluTGlzdDtcbiAgY29uc3RydWN0b3IobmRrLCByZWxheVNldCwgZ3JvdXBJZCkge1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMuZ3JvdXBJZCA9IGdyb3VwSWQgPz8gcmFuZG9tSWQoMjQpO1xuICAgIHRoaXMucmVsYXlTZXQgPSByZWxheVNldDtcbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXBJZDtcbiAgfVxuICByZWxheVVybHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXlTZXQ/LnJlbGF5VXJscztcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRhZGF0YT8ubmFtZTtcbiAgfVxuICBnZXQgYWJvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGE/LmFib3V0O1xuICB9XG4gIGdldCBwaWN0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhPy5waWN0dXJlO1xuICB9XG4gIGdldCBtZW1iZXJzKCkge1xuICAgIHJldHVybiB0aGlzLm1lbWJlckxpc3Q/Lm1lbWJlcnMgPz8gW107XG4gIH1cbiAgZ2V0IGFkbWlucygpIHtcbiAgICByZXR1cm4gdGhpcy5hZG1pbkxpc3Q/Lm1lbWJlcnMgPz8gW107XG4gIH1cbiAgYXN5bmMgZ2V0TWV0YWRhdGEoKSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVNZXRhZGF0YUV2ZW50KCk7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGdyb3VwIGJ5IHB1Ymxpc2hpbmcgYSBraW5kOjkwMDcgZXZlbnQuXG4gICAqIEBwYXJhbSBzaWduZXJcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUdyb3VwKHNpZ25lcikge1xuICAgIHNpZ25lciA/Pz0gdGhpcy5uZGsuc2lnbmVyO1xuICAgIGlmICghc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBzaWduZXIudXNlcigpO1xuICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKFwiTm8gdXNlciBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGspO1xuICAgIGV2ZW50LmtpbmQgPSA5MDA3IC8qIEdyb3VwQWRtaW5DcmVhdGVHcm91cCAqLztcbiAgICBldmVudC50YWdzLnB1c2goW1wiaFwiLCB0aGlzLmdyb3VwSWRdKTtcbiAgICBhd2FpdCBldmVudC5zaWduKHNpZ25lcik7XG4gICAgcmV0dXJuIGV2ZW50LnB1Ymxpc2godGhpcy5yZWxheVNldCk7XG4gIH1cbiAgYXN5bmMgc2V0TWV0YWRhdGEoeyBuYW1lLCBhYm91dCwgcGljdHVyZSB9KSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGspO1xuICAgIGV2ZW50LmtpbmQgPSA5MDAyIC8qIEdyb3VwQWRtaW5FZGl0TWV0YWRhdGEgKi87XG4gICAgZXZlbnQudGFncy5wdXNoKFtcImhcIiwgdGhpcy5ncm91cElkXSk7XG4gICAgaWYgKG5hbWUpIGV2ZW50LnRhZ3MucHVzaChbXCJuYW1lXCIsIG5hbWVdKTtcbiAgICBpZiAoYWJvdXQpIGV2ZW50LnRhZ3MucHVzaChbXCJhYm91dFwiLCBhYm91dF0pO1xuICAgIGlmIChwaWN0dXJlKSBldmVudC50YWdzLnB1c2goW1wicGljdHVyZVwiLCBwaWN0dXJlXSk7XG4gICAgYXdhaXQgZXZlbnQuc2lnbigpO1xuICAgIHJldHVybiBldmVudC5wdWJsaXNoKHRoaXMucmVsYXlTZXQpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgdXNlciB0byB0aGUgZ3JvdXAgdXNpbmcgYSBraW5kOjkwMDAgZXZlbnRcbiAgICogQHBhcmFtIHVzZXIgdXNlciB0byBhZGRcbiAgICogQHBhcmFtIG9wdHMgb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgYWRkVXNlcih1c2VyKSB7XG4gICAgY29uc3QgYWRkVXNlckV2ZW50ID0gX05ES1NpbXBsZUdyb3VwLmdlbmVyYXRlQWRkVXNlckV2ZW50KHVzZXIucHVia2V5LCB0aGlzLmdyb3VwSWQpO1xuICAgIGFkZFVzZXJFdmVudC5uZGsgPSB0aGlzLm5kaztcbiAgICByZXR1cm4gYWRkVXNlckV2ZW50O1xuICB9XG4gIGFzeW5jIGdldE1lbWJlckxpc3RFdmVudCgpIHtcbiAgICBjb25zdCBtZW1iZXJMaXN0ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudChcbiAgICAgIHtcbiAgICAgICAga2luZHM6IFszOTAwMiAvKiBHcm91cE1lbWJlcnMgKi9dLFxuICAgICAgICBcIiNkXCI6IFt0aGlzLmdyb3VwSWRdXG4gICAgICB9LFxuICAgICAgdm9pZCAwLFxuICAgICAgdGhpcy5yZWxheVNldFxuICAgICk7XG4gICAgaWYgKCFtZW1iZXJMaXN0KSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTkRLU2ltcGxlR3JvdXBNZW1iZXJMaXN0LmZyb20obWVtYmVyTGlzdCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBsaXN0IG9mIHVzZXJzIHRoYXQgYmVsb25nIHRvIHRoaXMgZ3JvdXBcbiAgICovXG4gIGFzeW5jIGdldE1lbWJlcnMoKSB7XG4gICAgY29uc3QgbWVtYmVycyA9IFtdO1xuICAgIGNvbnN0IG1lbWJlclB1YmtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IG1lbWJlckxpc3RFdmVudCA9IGF3YWl0IHRoaXMuZ2V0TWVtYmVyTGlzdEV2ZW50KCk7XG4gICAgaWYgKCFtZW1iZXJMaXN0RXZlbnQpIHJldHVybiBbXTtcbiAgICBmb3IgKGNvbnN0IHBUYWcgb2YgbWVtYmVyTGlzdEV2ZW50LmdldE1hdGNoaW5nVGFncyhcInBcIikpIHtcbiAgICAgIGNvbnN0IHB1YmtleSA9IHBUYWdbMV07XG4gICAgICBpZiAobWVtYmVyUHVia2V5cy5oYXMocHVia2V5KSkgY29udGludWU7XG4gICAgICBtZW1iZXJQdWJrZXlzLmFkZChwdWJrZXkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWVtYmVycy5wdXNoKHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXkgfSkpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZW1iZXJzO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gZXZlbnQgdGhhdCBsaXN0cyB0aGUgbWVtYmVycyBvZiBhIGdyb3VwLlxuICAgKiBAcGFyYW0gZ3JvdXBJZFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlVXNlckxpc3RFdmVudChncm91cElkKSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodm9pZCAwLCB7XG4gICAgICBraW5kOiAzOTAwMiAvKiBHcm91cE1lbWJlcnMgKi8sXG4gICAgICB0YWdzOiBbXG4gICAgICAgIFtcImhcIiwgZ3JvdXBJZF0sXG4gICAgICAgIFtcImFsdFwiLCBcIkdyb3VwIE1lbWJlciBMaXN0XCJdXG4gICAgICBdXG4gICAgfSk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gZXZlbnQgdGhhdCBhZGRzIGEgdXNlciB0byBhIGdyb3VwLlxuICAgKiBAcGFyYW0gdXNlclB1YmtleSBwdWJrZXkgb2YgdGhlIHVzZXIgdG8gYWRkXG4gICAqIEBwYXJhbSBncm91cElkIGdyb3VwIHRvIGFkZCB0aGUgdXNlciB0b1xuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlQWRkVXNlckV2ZW50KHVzZXJQdWJrZXksIGdyb3VwSWQpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh2b2lkIDAsIHtcbiAgICAgIGtpbmQ6IDllMyAvKiBHcm91cEFkbWluQWRkVXNlciAqLyxcbiAgICAgIHRhZ3M6IFtbXCJoXCIsIGdyb3VwSWRdXVxuICAgIH0pO1xuICAgIGV2ZW50LnRhZ3MucHVzaChbXCJwXCIsIHVzZXJQdWJrZXldKTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdFRvSm9pbihfcHVia2V5LCBjb250ZW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IDkwMjEgLyogR3JvdXBBZG1pblJlcXVlc3RKb2luICovLFxuICAgICAgY29udGVudDogY29udGVudCA/PyBcIlwiLFxuICAgICAgdGFnczogW1tcImhcIiwgdGhpcy5ncm91cElkXV1cbiAgICB9KTtcbiAgICByZXR1cm4gZXZlbnQucHVibGlzaCh0aGlzLnJlbGF5U2V0KTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgc3VyZSB0aGF0IGEgbWV0YWRhdGEgZXZlbnQgZXhpc3RzIGxvY2FsbHlcbiAgICovXG4gIGFzeW5jIGVuc3VyZU1ldGFkYXRhRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMubWV0YWRhdGEpIHJldHVybjtcbiAgICBpZiAodGhpcy5mZXRjaGluZ01ldGFkYXRhKSByZXR1cm4gdGhpcy5mZXRjaGluZ01ldGFkYXRhO1xuICAgIHRoaXMuZmV0Y2hpbmdNZXRhZGF0YSA9IHRoaXMubmRrLmZldGNoRXZlbnQoXG4gICAgICB7XG4gICAgICAgIGtpbmRzOiBbMzllMyAvKiBHcm91cE1ldGFkYXRhICovXSxcbiAgICAgICAgXCIjZFwiOiBbdGhpcy5ncm91cElkXVxuICAgICAgfSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHRoaXMucmVsYXlTZXRcbiAgICApLnRoZW4oKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IE5ES1NpbXBsZUdyb3VwTWV0YWRhdGEuZnJvbShldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbmV3IE5ES1NpbXBsZUdyb3VwTWV0YWRhdGEodGhpcy5uZGspO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLmRUYWcgPSB0aGlzLmdyb3VwSWQ7XG4gICAgICB9XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICB0aGlzLmZldGNoaW5nTWV0YWRhdGEgPSB2b2lkIDA7XG4gICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggbWV0YWRhdGEgZm9yIGdyb3VwICR7dGhpcy5ncm91cElkfWApO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmZldGNoaW5nTWV0YWRhdGE7XG4gIH1cbn07XG5mdW5jdGlvbiByYW5kb21JZChsZW5ndGgpIHtcbiAgY29uc3QgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCI7XG4gIGNvbnN0IGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdCArPSBjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnNMZW5ndGgpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvYXBwLXNldHRpbmdzL2luZGV4LnRzXG52YXIgTkRLQXBwU2V0dGluZ3MgPSBjbGFzcyBfTkRLQXBwU2V0dGluZ3MgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGFwcE5hbWU7XG4gIHNldHRpbmdzID0ge307XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMwMDc4IC8qIEFwcFNwZWNpZmljRGF0YSAqLztcbiAgICB0aGlzLmRUYWcgPz89IHRoaXMuYXBwTmFtZTtcbiAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcGFyc2luZyBhcHAgc2V0dGluZ3NcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0FwcFNldHRpbmdzKGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSB2YWx1ZSBmb3IgYSBnaXZlbiBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuc2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSB2YWx1ZSBmb3IgYSBnaXZlbiBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR0aW5nc1trZXldO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2hSZXBsYWNlYWJsZShyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnNldHRpbmdzKTtcbiAgICByZXR1cm4gc3VwZXIucHVibGlzaFJlcGxhY2VhYmxlKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9yZWxheS9hdXRoLXBvbGljaWVzLnRzXG5pbXBvcnQgY3JlYXRlRGVidWcyIGZyb20gXCJkZWJ1Z1wiO1xuZnVuY3Rpb24gZGlzY29ubmVjdChwb29sLCBkZWJ1ZzgpIHtcbiAgZGVidWc4ID8/PSBjcmVhdGVEZWJ1ZzIoXCJuZGs6cmVsYXk6YXV0aC1wb2xpY2llczpkaXNjb25uZWN0XCIpO1xuICByZXR1cm4gYXN5bmMgKHJlbGF5KSA9PiB7XG4gICAgZGVidWc4Py4oYFJlbGF5ICR7cmVsYXkudXJsfSByZXF1ZXN0ZWQgYXV0aGVudGljYXRpb24sIGRpc2Nvbm5lY3RpbmdgKTtcbiAgICBwb29sLnJlbW92ZVJlbGF5KHJlbGF5LnVybCk7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBzaWduQW5kQXV0aChldmVudCwgcmVsYXksIHNpZ25lciwgZGVidWc4LCByZXNvbHZlLCByZWplY3QpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBldmVudC5zaWduKHNpZ25lcik7XG4gICAgcmVzb2x2ZShldmVudCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1Zzg/LihgRmFpbGVkIHRvIHB1Ymxpc2ggYXV0aCBldmVudCB0byByZWxheSAke3JlbGF5LnVybH1gLCBlKTtcbiAgICByZWplY3QoZXZlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBzaWduSW4oeyBuZGssIHNpZ25lciwgZGVidWc6IGRlYnVnOCB9ID0ge30pIHtcbiAgZGVidWc4ID8/PSBjcmVhdGVEZWJ1ZzIoXCJuZGs6YXV0aC1wb2xpY2llczpzaWduSW5cIik7XG4gIHJldHVybiBhc3luYyAocmVsYXksIGNoYWxsZW5nZSkgPT4ge1xuICAgIGRlYnVnOD8uKGBSZWxheSAke3JlbGF5LnVybH0gcmVxdWVzdGVkIGF1dGhlbnRpY2F0aW9uLCBzaWduaW5nIGluYCk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrKTtcbiAgICBldmVudC5raW5kID0gMjIyNDIgLyogQ2xpZW50QXV0aCAqLztcbiAgICBldmVudC50YWdzID0gW1xuICAgICAgW1wicmVsYXlcIiwgcmVsYXkudXJsXSxcbiAgICAgIFtcImNoYWxsZW5nZVwiLCBjaGFsbGVuZ2VdXG4gICAgXTtcbiAgICBzaWduZXIgPz89IG5kaz8uc2lnbmVyO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoc2lnbmVyKSB7XG4gICAgICAgIGF3YWl0IHNpZ25BbmRBdXRoKGV2ZW50LCByZWxheSwgc2lnbmVyLCBkZWJ1ZzgsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZGs/Lm9uY2UoXCJzaWduZXI6cmVhZHlcIiwgYXN5bmMgKHNpZ25lcjIpID0+IHtcbiAgICAgICAgICBhd2FpdCBzaWduQW5kQXV0aChldmVudCwgcmVsYXksIHNpZ25lcjIsIGRlYnVnOCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG52YXIgTkRLUmVsYXlBdXRoUG9saWNpZXMgPSB7XG4gIGRpc2Nvbm5lY3QsXG4gIHNpZ25JblxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwMDcvaW5kZXgudHNcbmltcG9ydCBkZWJ1ZzUgZnJvbSBcImRlYnVnXCI7XG52YXIgTkRLTmlwMDdTaWduZXIgPSBjbGFzcyBfTkRLTmlwMDdTaWduZXIge1xuICBfdXNlclByb21pc2U7XG4gIGVuY3J5cHRpb25RdWV1ZSA9IFtdO1xuICBlbmNyeXB0aW9uUHJvY2Vzc2luZyA9IGZhbHNlO1xuICBkZWJ1ZztcbiAgd2FpdFRpbWVvdXQ7XG4gIF9wdWJrZXk7XG4gIG5kaztcbiAgX3VzZXI7XG4gIC8qKlxuICAgKiBAcGFyYW0gd2FpdFRpbWVvdXQgLSBUaGUgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgdGhlIE5JUC0wNyB0byBiZWNvbWUgYXZhaWxhYmxlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3YWl0VGltZW91dCA9IDFlMywgbmRrKSB7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnNShcIm5kazpuaXAwN1wiKTtcbiAgICB0aGlzLndhaXRUaW1lb3V0ID0gd2FpdFRpbWVvdXQ7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gIH1cbiAgZ2V0IHB1YmtleSgpIHtcbiAgICBpZiAoIXRoaXMuX3B1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiTm90IHJlYWR5XCIpO1xuICAgIHJldHVybiB0aGlzLl9wdWJrZXk7XG4gIH1cbiAgYXN5bmMgYmxvY2tVbnRpbFJlYWR5KCkge1xuICAgIGF3YWl0IHRoaXMud2FpdEZvckV4dGVuc2lvbigpO1xuICAgIGNvbnN0IHB1YmtleSA9IGF3YWl0IHdpbmRvdy5ub3N0cj8uZ2V0UHVibGljS2V5KCk7XG4gICAgaWYgKCFwdWJrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgcmVqZWN0ZWQgYWNjZXNzXCIpO1xuICAgIH1cbiAgICB0aGlzLl9wdWJrZXkgPSBwdWJrZXk7XG4gICAgbGV0IHVzZXI7XG4gICAgaWYgKHRoaXMubmRrKSB1c2VyID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleSB9KTtcbiAgICBlbHNlIHVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleSB9KTtcbiAgICB0aGlzLl91c2VyID0gdXNlcjtcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgdXNlciBwcm9wZXJ0eS5cbiAgICogQHJldHVybnMgVGhlIE5ES1VzZXIgaW5zdGFuY2UuXG4gICAqL1xuICBhc3luYyB1c2VyKCkge1xuICAgIGlmICghdGhpcy5fdXNlclByb21pc2UpIHtcbiAgICAgIHRoaXMuX3VzZXJQcm9taXNlID0gdGhpcy5ibG9ja1VudGlsUmVhZHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJQcm9taXNlO1xuICB9XG4gIGdldCB1c2VyU3luYygpIHtcbiAgICBpZiAoIXRoaXMuX3VzZXIpIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IHJlYWR5XCIpO1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIC8qKlxuICAgKiBTaWducyB0aGUgZ2l2ZW4gTm9zdHIgZXZlbnQuXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBOb3N0ciBldmVudCB0byBiZSBzaWduZWQuXG4gICAqIEByZXR1cm5zIFRoZSBzaWduYXR1cmUgb2YgdGhlIHNpZ25lZCBldmVudC5cbiAgICogQHRocm93cyBFcnJvciBpZiB0aGUgTklQLTA3IGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAqL1xuICBhc3luYyBzaWduKGV2ZW50KSB7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3Qgc2lnbmVkRXZlbnQgPSBhd2FpdCB3aW5kb3cubm9zdHI/LnNpZ25FdmVudChldmVudCk7XG4gICAgaWYgKCFzaWduZWRFdmVudCkgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHNpZ24gZXZlbnRcIik7XG4gICAgcmV0dXJuIHNpZ25lZEV2ZW50LnNpZztcbiAgfVxuICBhc3luYyByZWxheXMobmRrKSB7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3QgcmVsYXlzID0gYXdhaXQgd2luZG93Lm5vc3RyPy5nZXRSZWxheXM/LigpIHx8IHt9O1xuICAgIGNvbnN0IGFjdGl2ZVJlbGF5cyA9IFtdO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIE9iamVjdC5rZXlzKHJlbGF5cykpIHtcbiAgICAgIGlmIChyZWxheXNbdXJsXS5yZWFkICYmIHJlbGF5c1t1cmxdLndyaXRlKSB7XG4gICAgICAgIGFjdGl2ZVJlbGF5cy5wdXNoKHVybCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVSZWxheXMubWFwKCh1cmwpID0+IG5ldyBOREtSZWxheSh1cmwsIG5kaz8ucmVsYXlBdXRoRGVmYXVsdFBvbGljeSwgbmRrKSk7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdGlvbkVuYWJsZWQobmlwKSB7XG4gICAgY29uc3QgZW5hYmxlZCA9IFtdO1xuICAgIGlmICgoIW5pcCB8fCBuaXAgPT09IFwibmlwMDRcIikgJiYgQm9vbGVhbih3aW5kb3cubm9zdHI/Lm5pcDA0KSkgZW5hYmxlZC5wdXNoKFwibmlwMDRcIik7XG4gICAgaWYgKCghbmlwIHx8IG5pcCA9PT0gXCJuaXA0NFwiKSAmJiBCb29sZWFuKHdpbmRvdy5ub3N0cj8ubmlwNDQpKSBlbmFibGVkLnB1c2goXCJuaXA0NFwiKTtcbiAgICByZXR1cm4gZW5hYmxlZDtcbiAgfVxuICBhc3luYyBlbmNyeXB0KHJlY2lwaWVudCwgdmFsdWUsIG5pcCA9IFwibmlwMDRcIikge1xuICAgIGlmICghYXdhaXQgdGhpcy5lbmNyeXB0aW9uRW5hYmxlZChuaXApKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25pcH1lbmNyeXB0aW9uIGlzIG5vdCBhdmFpbGFibGUgZnJvbSB5b3VyIGJyb3dzZXIgZXh0ZW5zaW9uYCk7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3QgcmVjaXBpZW50SGV4UHViS2V5ID0gcmVjaXBpZW50LnB1YmtleTtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZUVuY3J5cHRpb24obmlwLCBcImVuY3J5cHRcIiwgcmVjaXBpZW50SGV4UHViS2V5LCB2YWx1ZSk7XG4gIH1cbiAgYXN5bmMgZGVjcnlwdChzZW5kZXIsIHZhbHVlLCBuaXAgPSBcIm5pcDA0XCIpIHtcbiAgICBpZiAoIWF3YWl0IHRoaXMuZW5jcnlwdGlvbkVuYWJsZWQobmlwKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuaXB9ZW5jcnlwdGlvbiBpcyBub3QgYXZhaWxhYmxlIGZyb20geW91ciBicm93c2VyIGV4dGVuc2lvbmApO1xuICAgIGF3YWl0IHRoaXMud2FpdEZvckV4dGVuc2lvbigpO1xuICAgIGNvbnN0IHNlbmRlckhleFB1YktleSA9IHNlbmRlci5wdWJrZXk7XG4gICAgcmV0dXJuIHRoaXMucXVldWVFbmNyeXB0aW9uKG5pcCwgXCJkZWNyeXB0XCIsIHNlbmRlckhleFB1YktleSwgdmFsdWUpO1xuICB9XG4gIGFzeW5jIHF1ZXVlRW5jcnlwdGlvbihzY2hlbWUsIG1ldGhvZCwgY291bnRlcnBhcnR5SGV4cHVia2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmVuY3J5cHRpb25RdWV1ZS5wdXNoKHtcbiAgICAgICAgc2NoZW1lLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIGNvdW50ZXJwYXJ0eUhleHB1YmtleSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHJlc29sdmUsXG4gICAgICAgIHJlamVjdFxuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMuZW5jcnlwdGlvblByb2Nlc3NpbmcpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzRW5jcnlwdGlvblF1ZXVlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0VuY3J5cHRpb25RdWV1ZShpdGVtLCByZXRyaWVzID0gMCkge1xuICAgIGlmICghaXRlbSAmJiB0aGlzLmVuY3J5cHRpb25RdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmNyeXB0aW9uUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgY29uc3QgY3VycmVudEl0ZW0gPSBpdGVtIHx8IHRoaXMuZW5jcnlwdGlvblF1ZXVlLnNoaWZ0KCk7XG4gICAgaWYgKCFjdXJyZW50SXRlbSkge1xuICAgICAgdGhpcy5lbmNyeXB0aW9uUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHNjaGVtZSwgbWV0aG9kLCBjb3VudGVycGFydHlIZXhwdWJrZXksIHZhbHVlLCByZXNvbHZlLCByZWplY3QgfSA9IGN1cnJlbnRJdGVtO1xuICAgIHRoaXMuZGVidWcoXCJQcm9jZXNzaW5nIGVuY3J5cHRpb24gcXVldWUgaXRlbVwiLCB7XG4gICAgICBtZXRob2QsXG4gICAgICBjb3VudGVycGFydHlIZXhwdWJrZXksXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3aW5kb3cubm9zdHI/LltzY2hlbWVdPy5bbWV0aG9kXShjb3VudGVycGFydHlIZXhwdWJrZXksIHZhbHVlKTtcbiAgICAgIGlmICghcmVzdWx0KSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZW5jcnlwdC9kZWNyeXB0XCIpO1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICBpZiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKFwiY2FsbCBhbHJlYWR5IGV4ZWN1dGluZ1wiKSAmJiByZXRyaWVzIDwgNSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiUmV0cnlpbmcgZW5jcnlwdGlvbiBxdWV1ZSBpdGVtXCIsIHtcbiAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgY291bnRlcnBhcnR5SGV4cHVia2V5LFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHJldHJpZXNcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMucHJvY2Vzc0VuY3J5cHRpb25RdWV1ZShjdXJyZW50SXRlbSwgcmV0cmllcyArIDEpO1xuICAgICAgICB9LCA1MCAqIHJldHJpZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZWplY3QoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yTWVzc2FnZSkpO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NFbmNyeXB0aW9uUXVldWUoKTtcbiAgfVxuICB3YWl0Rm9yRXh0ZW5zaW9uKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAod2luZG93Lm5vc3RyKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHRpbWVySWQ7XG4gICAgICBjb25zdCBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBpZiAod2luZG93Lm5vc3RyKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDApO1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKFwiTklQLTA3IGV4dGVuc2lvbiBub3QgYXZhaWxhYmxlXCIpKTtcbiAgICAgIH0sIHRoaXMud2FpdFRpbWVvdXQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBzaWduZXIgdHlwZSBpbnRvIGEgc3RvcmFibGUgZm9ybWF0LlxuICAgKiBOSVAtMDcgc2lnbmVycyBkb24ndCBoYXZlIHBlcnNpc3RlbnQgc3RhdGUgdG8gc2VyaWFsaXplIGJleW9uZCB0aGVpciB0eXBlLlxuICAgKiBAcmV0dXJucyBBIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHR5cGUuXG4gICAqL1xuICB0b1BheWxvYWQoKSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIHR5cGU6IFwibmlwMDdcIixcbiAgICAgIHBheWxvYWQ6IFwiXCJcbiAgICAgIC8vIE5vIHNwZWNpZmljIHBheWxvYWQgbmVlZGVkIGZvciBOSVAtMDdcbiAgICB9O1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgfVxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBzaWduZXIgZnJvbSBhIHBheWxvYWQgc3RyaW5nLlxuICAgKiBDcmVhdGVzIGEgbmV3IE5ES05pcDA3U2lnbmVyIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gcGF5bG9hZFN0cmluZyBUaGUgSlNPTiBzdHJpbmcgb2J0YWluZWQgZnJvbSB0b1BheWxvYWQoKS5cbiAgICogQHBhcmFtIG5kayBPcHRpb25hbCBOREsgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIE5ES05pcDA3U2lnbmVyLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21QYXlsb2FkKHBheWxvYWRTdHJpbmcsIG5kaykge1xuICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKHBheWxvYWRTdHJpbmcpO1xuICAgIGlmIChwYXlsb2FkLnR5cGUgIT09IFwibmlwMDdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBheWxvYWQgdHlwZTogZXhwZWN0ZWQgJ25pcDA3JywgZ290ICR7cGF5bG9hZC50eXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9OREtOaXAwN1NpZ25lcih2b2lkIDAsIG5kayk7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvaW5kZXgudHNcbmltcG9ydCB7IGhleFRvQnl0ZXMgYXMgaGV4VG9CeXRlczIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9ycGMudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI1IH0gZnJvbSBcInRzZWVwXCI7XG52YXIgTkRLTm9zdHJScGMgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjUge1xuICBuZGs7XG4gIHNpZ25lcjtcbiAgcmVsYXlTZXQ7XG4gIGRlYnVnO1xuICBlbmNyeXB0aW9uVHlwZSA9IFwibmlwMDRcIjtcbiAgcG9vbDtcbiAgY29uc3RydWN0b3IobmRrLCBzaWduZXIsIGRlYnVnOCwgcmVsYXlVcmxzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLnNpZ25lciA9IHNpZ25lcjtcbiAgICBpZiAocmVsYXlVcmxzKSB7XG4gICAgICB0aGlzLnBvb2wgPSBuZXcgTkRLUG9vbChyZWxheVVybHMsIFtdLCBuZGssIHtcbiAgICAgICAgZGVidWc6IGRlYnVnOC5leHRlbmQoXCJycGMtcG9vbFwiKSxcbiAgICAgICAgbmFtZTogXCJOb3N0ciBSUENcIlxuICAgICAgfSk7XG4gICAgICB0aGlzLnJlbGF5U2V0ID0gbmV3IE5ES1JlbGF5U2V0KC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIG5kaywgdGhpcy5wb29sKTtcbiAgICAgIGZvciAoY29uc3QgdXJsIG9mIHJlbGF5VXJscykge1xuICAgICAgICBjb25zdCByZWxheSA9IHRoaXMucG9vbC5nZXRSZWxheSh1cmwsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIHJlbGF5LmF1dGhQb2xpY3kgPSBOREtSZWxheUF1dGhQb2xpY2llcy5zaWduSW4oeyBuZGssIHNpZ25lciwgZGVidWc6IGRlYnVnOCB9KTtcbiAgICAgICAgdGhpcy5yZWxheVNldC5hZGRSZWxheShyZWxheSk7XG4gICAgICAgIHJlbGF5LmNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnOC5leHRlbmQoXCJycGNcIik7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byBhIGZpbHRlci4gVGhpcyBmdW5jdGlvbiB3aWxsIHJlc29sdmUgb25jZSB0aGUgc3Vic2NyaXB0aW9uIGlzIHJlYWR5LlxuICAgKi9cbiAgc3Vic2NyaWJlKGZpbHRlcikge1xuICAgIGNvbnN0IHN1YiA9IHRoaXMubmRrLnN1YnNjcmliZShcbiAgICAgIGZpbHRlcixcbiAgICAgIHtcbiAgICAgICAgY2xvc2VPbkVvc2U6IGZhbHNlLFxuICAgICAgICBncm91cGFibGU6IGZhbHNlLFxuICAgICAgICBjYWNoZVVzYWdlOiBcIk9OTFlfUkVMQVlcIiAvKiBPTkxZX1JFTEFZICovLFxuICAgICAgICBwb29sOiB0aGlzLnBvb2wsXG4gICAgICAgIHJlbGF5U2V0OiB0aGlzLnJlbGF5U2V0XG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHN1Yi5vbihcImV2ZW50XCIsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkRXZlbnQgPSBhd2FpdCB0aGlzLnBhcnNlRXZlbnQoZXZlbnQpO1xuICAgICAgICBpZiAocGFyc2VkRXZlbnQubWV0aG9kKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KFwicmVxdWVzdFwiLCBwYXJzZWRFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbWl0KGByZXNwb25zZS0ke3BhcnNlZEV2ZW50LmlkfWAsIHBhcnNlZEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiZXJyb3IgcGFyc2luZyBldmVudFwiLCBlLCBldmVudC5yYXdFdmVudCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHN1Yi5vbihcImVvc2VcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmRlYnVnKFwiZW9zZWRcIik7XG4gICAgICAgIHJlc29sdmUoc3ViKTtcbiAgICAgIH0pO1xuICAgICAgc3ViLnN0YXJ0KCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcGFyc2VFdmVudChldmVudCkge1xuICAgIGlmICh0aGlzLmVuY3J5cHRpb25UeXBlID09PSBcIm5pcDQ0XCIgJiYgZXZlbnQuY29udGVudC5pbmNsdWRlcyhcIj9pdj1cIikpIHtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblR5cGUgPSBcIm5pcDA0XCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVuY3J5cHRpb25UeXBlID09PSBcIm5pcDA0XCIgJiYgIWV2ZW50LmNvbnRlbnQuaW5jbHVkZXMoXCI/aXY9XCIpKSB7XG4gICAgICB0aGlzLmVuY3J5cHRpb25UeXBlID0gXCJuaXA0NFwiO1xuICAgIH1cbiAgICBjb25zdCByZW1vdGVVc2VyID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogZXZlbnQucHVia2V5IH0pO1xuICAgIHJlbW90ZVVzZXIubmRrID0gdGhpcy5uZGs7XG4gICAgbGV0IGRlY3J5cHRlZENvbnRlbnQ7XG4gICAgdHJ5IHtcbiAgICAgIGRlY3J5cHRlZENvbnRlbnQgPSBhd2FpdCB0aGlzLnNpZ25lci5kZWNyeXB0KHJlbW90ZVVzZXIsIGV2ZW50LmNvbnRlbnQsIHRoaXMuZW5jcnlwdGlvblR5cGUpO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICBjb25zdCBvdGhlckVuY3J5cHRpb25UeXBlID0gdGhpcy5lbmNyeXB0aW9uVHlwZSA9PT0gXCJuaXAwNFwiID8gXCJuaXA0NFwiIDogXCJuaXAwNFwiO1xuICAgICAgZGVjcnlwdGVkQ29udGVudCA9IGF3YWl0IHRoaXMuc2lnbmVyLmRlY3J5cHQocmVtb3RlVXNlciwgZXZlbnQuY29udGVudCwgb3RoZXJFbmNyeXB0aW9uVHlwZSk7XG4gICAgICB0aGlzLmVuY3J5cHRpb25UeXBlID0gb3RoZXJFbmNyeXB0aW9uVHlwZTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkQ29udGVudCA9IEpTT04ucGFyc2UoZGVjcnlwdGVkQ29udGVudCk7XG4gICAgY29uc3QgeyBpZCwgbWV0aG9kLCBwYXJhbXMsIHJlc3VsdCwgZXJyb3IgfSA9IHBhcnNlZENvbnRlbnQ7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgcmV0dXJuIHsgaWQsIHB1YmtleTogZXZlbnQucHVia2V5LCBtZXRob2QsIHBhcmFtcywgZXZlbnQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaWQsIHJlc3VsdCwgZXJyb3IsIGV2ZW50IH07XG4gIH1cbiAgYXN5bmMgc2VuZFJlc3BvbnNlKGlkLCByZW1vdGVQdWJrZXksIHJlc3VsdCwga2luZCA9IDI0MTMzIC8qIE5vc3RyQ29ubmVjdCAqLywgZXJyb3IpIHtcbiAgICBjb25zdCByZXMgPSB7IGlkLCByZXN1bHQgfTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJlcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbFVzZXIgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3QgcmVtb3RlVXNlciA9IHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXk6IHJlbW90ZVB1YmtleSB9KTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywge1xuICAgICAga2luZCxcbiAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHJlcyksXG4gICAgICB0YWdzOiBbW1wicFwiLCByZW1vdGVQdWJrZXldXSxcbiAgICAgIHB1YmtleTogbG9jYWxVc2VyLnB1YmtleVxuICAgIH0pO1xuICAgIGV2ZW50LmNvbnRlbnQgPSBhd2FpdCB0aGlzLnNpZ25lci5lbmNyeXB0KHJlbW90ZVVzZXIsIGV2ZW50LmNvbnRlbnQsIHRoaXMuZW5jcnlwdGlvblR5cGUpO1xuICAgIGF3YWl0IGV2ZW50LnNpZ24odGhpcy5zaWduZXIpO1xuICAgIGF3YWl0IGV2ZW50LnB1Ymxpc2godGhpcy5yZWxheVNldCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmVxdWVzdC5cbiAgICogQHBhcmFtIHJlbW90ZVB1YmtleVxuICAgKiBAcGFyYW0gbWV0aG9kXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGtpbmRcbiAgICogQHBhcmFtIGlkXG4gICAqL1xuICBhc3luYyBzZW5kUmVxdWVzdChyZW1vdGVQdWJrZXksIG1ldGhvZCwgcGFyYW1zID0gW10sIGtpbmQgPSAyNDEzMywgY2IpIHtcbiAgICBjb25zdCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KTtcbiAgICBjb25zdCBsb2NhbFVzZXIgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3QgcmVtb3RlVXNlciA9IHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXk6IHJlbW90ZVB1YmtleSB9KTtcbiAgICBjb25zdCByZXF1ZXN0ID0geyBpZCwgbWV0aG9kLCBwYXJhbXMgfTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKCkgPT4ge1xuICAgICAgY29uc3QgcmVzcG9uc2VIYW5kbGVyID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5yZXN1bHQgPT09IFwiYXV0aF91cmxcIikge1xuICAgICAgICAgIHRoaXMub25jZShgcmVzcG9uc2UtJHtpZH1gLCByZXNwb25zZUhhbmRsZXIpO1xuICAgICAgICAgIHRoaXMuZW1pdChcImF1dGhVcmxcIiwgcmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICAgICAgY2IocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmNlKGByZXNwb25zZS0ke2lkfWAsIHJlc3BvbnNlSGFuZGxlcik7XG4gICAgfSk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQsXG4gICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSxcbiAgICAgIHRhZ3M6IFtbXCJwXCIsIHJlbW90ZVB1YmtleV1dLFxuICAgICAgcHVia2V5OiBsb2NhbFVzZXIucHVia2V5XG4gICAgfSk7XG4gICAgZXZlbnQuY29udGVudCA9IGF3YWl0IHRoaXMuc2lnbmVyLmVuY3J5cHQocmVtb3RlVXNlciwgZXZlbnQuY29udGVudCwgdGhpcy5lbmNyeXB0aW9uVHlwZSk7XG4gICAgYXdhaXQgZXZlbnQuc2lnbih0aGlzLnNpZ25lcik7XG4gICAgYXdhaXQgZXZlbnQucHVibGlzaCh0aGlzLnJlbGF5U2V0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9jb25uZWN0LnRzXG52YXIgQ29ubmVjdEV2ZW50SGFuZGxpbmdTdHJhdGVneSA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtfLCB0b2tlbl0gPSBwYXJhbXM7XG4gICAgY29uc3QgZGVidWc4ID0gYmFja2VuZC5kZWJ1Zy5leHRlbmQoXCJjb25uZWN0XCIpO1xuICAgIGRlYnVnOChgY29ubmVjdGlvbiByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9YCk7XG4gICAgaWYgKHRva2VuICYmIGJhY2tlbmQuYXBwbHlUb2tlbikge1xuICAgICAgZGVidWc4KFwiYXBwbHlpbmcgdG9rZW5cIik7XG4gICAgICBhd2FpdCBiYWNrZW5kLmFwcGx5VG9rZW4ocmVtb3RlUHVia2V5LCB0b2tlbik7XG4gICAgfVxuICAgIGlmIChhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgICAgaWQsXG4gICAgICBwdWJrZXk6IHJlbW90ZVB1YmtleSxcbiAgICAgIG1ldGhvZDogXCJjb25uZWN0XCIsXG4gICAgICBwYXJhbXM6IHRva2VuXG4gICAgfSkpIHtcbiAgICAgIGRlYnVnOChgY29ubmVjdGlvbiByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IGFsbG93ZWRgKTtcbiAgICAgIHJldHVybiBcImFja1wiO1xuICAgIH1cbiAgICBkZWJ1ZzgoYGNvbm5lY3Rpb24gcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSByZWplY3RlZGApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvZ2V0LXB1YmxpYy1rZXkudHNcbnZhciBHZXRQdWJsaWNLZXlIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgX2lkLCBfcmVtb3RlUHVia2V5LCBfcGFyYW1zKSB7XG4gICAgcmV0dXJuIGJhY2tlbmQubG9jYWxVc2VyPy5wdWJrZXk7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvbmlwMDQtZGVjcnlwdC50c1xudmFyIE5pcDA0RGVjcnlwdEhhbmRsaW5nU3RyYXRlZ3kgPSBjbGFzcyB7XG4gIGFzeW5jIGhhbmRsZShiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBwYXJhbXMpIHtcbiAgICBjb25zdCBbc2VuZGVyUHVia2V5LCBwYXlsb2FkXSA9IHBhcmFtcztcbiAgICBjb25zdCBzZW5kZXJVc2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXk6IHNlbmRlclB1YmtleSB9KTtcbiAgICBjb25zdCBkZWNyeXB0ZWRQYXlsb2FkID0gYXdhaXQgZGVjcnlwdDIoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgc2VuZGVyVXNlciwgcGF5bG9hZCk7XG4gICAgcmV0dXJuIGRlY3J5cHRlZFBheWxvYWQ7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0MihiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBzZW5kZXJVc2VyLCBwYXlsb2FkKSB7XG4gIGlmICghYXdhaXQgYmFja2VuZC5wdWJrZXlBbGxvd2VkKHtcbiAgICBpZCxcbiAgICBwdWJrZXk6IHJlbW90ZVB1YmtleSxcbiAgICBtZXRob2Q6IFwibmlwMDRfZGVjcnlwdFwiLFxuICAgIHBhcmFtczogcGF5bG9hZFxuICB9KSkge1xuICAgIGJhY2tlbmQuZGVidWcoYGRlY3J5cHQgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSByZWplY3RlZGApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IGJhY2tlbmQuc2lnbmVyLmRlY3J5cHQoc2VuZGVyVXNlciwgcGF5bG9hZCwgXCJuaXAwNFwiKTtcbn1cblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9uaXAwNC1lbmNyeXB0LnRzXG52YXIgTmlwMDRFbmNyeXB0SGFuZGxpbmdTdHJhdGVneSA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtyZWNpcGllbnRQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlY2lwaWVudFVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogcmVjaXBpZW50UHVia2V5IH0pO1xuICAgIGNvbnN0IGVuY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBlbmNyeXB0MihiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCByZWNpcGllbnRVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZW5jcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHQyKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHJlY2lwaWVudFVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXAwNF9lbmNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZW5jcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZW5jcnlwdChyZWNpcGllbnRVc2VyLCBwYXlsb2FkLCBcIm5pcDA0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL25pcDQ0LWRlY3J5cHQudHNcbnZhciBOaXAwNERlY3J5cHRIYW5kbGluZ1N0cmF0ZWd5MiA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtzZW5kZXJQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHNlbmRlclVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogc2VuZGVyUHVia2V5IH0pO1xuICAgIGNvbnN0IGRlY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBkZWNyeXB0MyhiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBzZW5kZXJVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZGVjcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQzKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHNlbmRlclVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXA0NF9kZWNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZGVjcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZGVjcnlwdChzZW5kZXJVc2VyLCBwYXlsb2FkLCBcIm5pcDQ0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL25pcDQ0LWVuY3J5cHQudHNcbnZhciBOaXAwNEVuY3J5cHRIYW5kbGluZ1N0cmF0ZWd5MiA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtyZWNpcGllbnRQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlY2lwaWVudFVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogcmVjaXBpZW50UHVia2V5IH0pO1xuICAgIGNvbnN0IGVuY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBlbmNyeXB0MyhiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCByZWNpcGllbnRVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZW5jcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHQzKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHJlY2lwaWVudFVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXA0NF9lbmNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZW5jcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZW5jcnlwdChyZWNpcGllbnRVc2VyLCBwYXlsb2FkLCBcIm5pcDQ0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL3BpbmcudHNcbnZhciBQaW5nRXZlbnRIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgX3BhcmFtcykge1xuICAgIGNvbnN0IGRlYnVnOCA9IGJhY2tlbmQuZGVidWcuZXh0ZW5kKFwicGluZ1wiKTtcbiAgICBkZWJ1ZzgoYHBpbmcgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fWApO1xuICAgIGlmIChhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoeyBpZCwgcHVia2V5OiByZW1vdGVQdWJrZXksIG1ldGhvZDogXCJwaW5nXCIgfSkpIHtcbiAgICAgIGRlYnVnOChgY29ubmVjdGlvbiByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IGFsbG93ZWRgKTtcbiAgICAgIHJldHVybiBcInBvbmdcIjtcbiAgICB9XG4gICAgZGVidWc4KGBjb25uZWN0aW9uIHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gcmVqZWN0ZWRgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL3NpZ24tZXZlbnQudHNcbnZhciBTaWduRXZlbnRIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gICAgY29uc3QgZXZlbnQgPSBhd2FpdCBzaWduRXZlbnQoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKTtcbiAgICBpZiAoIWV2ZW50KSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhd2FpdCBldmVudC50b05vc3RyRXZlbnQoKSk7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBzaWduRXZlbnQoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gIGNvbnN0IFtldmVudFN0cmluZ10gPSBwYXJhbXM7XG4gIGJhY2tlbmQuZGVidWcoYHNpZ24gZXZlbnQgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fWApO1xuICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudChiYWNrZW5kLm5kaywgSlNPTi5wYXJzZShldmVudFN0cmluZykpO1xuICBiYWNrZW5kLmRlYnVnKFwiZXZlbnQgdG8gc2lnblwiLCBldmVudC5yYXdFdmVudCgpKTtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJzaWduX2V2ZW50XCIsXG4gICAgcGFyYW1zOiBldmVudFxuICB9KSkge1xuICAgIGJhY2tlbmQuZGVidWcoYHNpZ24gZXZlbnQgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSByZWplY3RlZGApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgYmFja2VuZC5kZWJ1Zyhgc2lnbiBldmVudCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IGFsbG93ZWRgKTtcbiAgYXdhaXQgZXZlbnQuc2lnbihiYWNrZW5kLnNpZ25lcik7XG4gIHJldHVybiBldmVudDtcbn1cblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9pbmRleC50c1xudmFyIE5ES05pcDQ2QmFja2VuZCA9IGNsYXNzIHtcbiAgbmRrO1xuICBzaWduZXI7XG4gIGxvY2FsVXNlcjtcbiAgZGVidWc7XG4gIHJwYztcbiAgcGVybWl0Q2FsbGJhY2s7XG4gIHJlbGF5VXJscztcbiAgLyoqXG4gICAqIEBwYXJhbSBuZGsgVGhlIE5ESyBpbnN0YW5jZSB0byB1c2VcbiAgICogQHBhcmFtIHByaXZhdGVLZXlPclNpZ25lciBUaGUgcHJpdmF0ZSBrZXkgb3Igc2lnbmVyIG9mIHRoZSBucHViIHRoYXQgd2FudHMgdG8gYmUgcHVibGlzaGVkIGFzXG4gICAqIEBwYXJhbSBwZXJtaXRDYWxsYmFjayBDYWxsYmFjayBleGVjdXRlZCB3aGVuIHBlcm1pc3Npb24gaXMgcmVxdWVzdGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuZGssIHByaXZhdGVLZXlPclNpZ25lciwgcGVybWl0Q2FsbGJhY2ssIHJlbGF5VXJscykge1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIGlmIChwcml2YXRlS2V5T3JTaWduZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICB0aGlzLnNpZ25lciA9IG5ldyBOREtQcml2YXRlS2V5U2lnbmVyKHByaXZhdGVLZXlPclNpZ25lcik7XG4gICAgfSBlbHNlIGlmIChwcml2YXRlS2V5T3JTaWduZXIgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgIHRoaXMuc2lnbmVyID0gbmV3IE5ES1ByaXZhdGVLZXlTaWduZXIoaGV4VG9CeXRlczIocHJpdmF0ZUtleU9yU2lnbmVyKSk7XG4gICAgfSBlbHNlIGlmIChwcml2YXRlS2V5T3JTaWduZXIgaW5zdGFuY2VvZiBOREtQcml2YXRlS2V5U2lnbmVyKSB7XG4gICAgICB0aGlzLnNpZ25lciA9IHByaXZhdGVLZXlPclNpZ25lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduZXJcIik7XG4gICAgfVxuICAgIHRoaXMuZGVidWcgPSBuZGsuZGVidWcuZXh0ZW5kKFwibmlwNDY6YmFja2VuZFwiKTtcbiAgICB0aGlzLnJlbGF5VXJscyA9IHJlbGF5VXJscyA/PyBBcnJheS5mcm9tKG5kay5wb29sLnJlbGF5cy5rZXlzKCkpO1xuICAgIHRoaXMucnBjID0gbmV3IE5ES05vc3RyUnBjKG5kaywgdGhpcy5zaWduZXIsIHRoaXMuZGVidWcsIHRoaXMucmVsYXlVcmxzKTtcbiAgICB0aGlzLnBlcm1pdENhbGxiYWNrID0gcGVybWl0Q2FsbGJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHN0YXJ0cyB0aGUgYmFja2VuZCwgd2hpY2ggd2lsbCBzdGFydCBsaXN0ZW5pbmcgZm9yIGluY29taW5nXG4gICAqIHJlcXVlc3RzLlxuICAgKi9cbiAgYXN5bmMgc3RhcnQoKSB7XG4gICAgdGhpcy5sb2NhbFVzZXIgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3Qgc3ViID0gdGhpcy5uZGsuc3Vic2NyaWJlKFxuICAgICAge1xuICAgICAgICBraW5kczogWzI0MTMzXSxcbiAgICAgICAgXCIjcFwiOiBbdGhpcy5sb2NhbFVzZXIucHVia2V5XVxuICAgICAgfSxcbiAgICAgIHsgY2xvc2VPbkVvc2U6IGZhbHNlIH1cbiAgICApO1xuICAgIHN1Yi5vbihcImV2ZW50XCIsIChlKSA9PiB0aGlzLmhhbmRsZUluY29taW5nRXZlbnQoZSkpO1xuICB9XG4gIGhhbmRsZXJzID0ge1xuICAgIGNvbm5lY3Q6IG5ldyBDb25uZWN0RXZlbnRIYW5kbGluZ1N0cmF0ZWd5KCksXG4gICAgc2lnbl9ldmVudDogbmV3IFNpZ25FdmVudEhhbmRsaW5nU3RyYXRlZ3koKSxcbiAgICBuaXAwNF9lbmNyeXB0OiBuZXcgTmlwMDRFbmNyeXB0SGFuZGxpbmdTdHJhdGVneSgpLFxuICAgIG5pcDA0X2RlY3J5cHQ6IG5ldyBOaXAwNERlY3J5cHRIYW5kbGluZ1N0cmF0ZWd5KCksXG4gICAgbmlwNDRfZW5jcnlwdDogbmV3IE5pcDA0RW5jcnlwdEhhbmRsaW5nU3RyYXRlZ3kyKCksXG4gICAgbmlwNDRfZGVjcnlwdDogbmV3IE5pcDA0RGVjcnlwdEhhbmRsaW5nU3RyYXRlZ3kyKCksXG4gICAgZ2V0X3B1YmxpY19rZXk6IG5ldyBHZXRQdWJsaWNLZXlIYW5kbGluZ1N0cmF0ZWd5KCksXG4gICAgcGluZzogbmV3IFBpbmdFdmVudEhhbmRsaW5nU3RyYXRlZ3koKVxuICB9O1xuICAvKipcbiAgICogRW5hYmxlcyB0aGUgdXNlciB0byBzZXQgYSBjdXN0b20gc3RyYXRlZ3kgZm9yIGhhbmRsaW5nIGluY29taW5nIGV2ZW50cy5cbiAgICogQHBhcmFtIG1ldGhvZCAtIFRoZSBtZXRob2QgdG8gc2V0IHRoZSBzdHJhdGVneSBmb3JcbiAgICogQHBhcmFtIHN0cmF0ZWd5IC0gVGhlIHN0cmF0ZWd5IHRvIHNldFxuICAgKi9cbiAgc2V0U3RyYXRlZ3kobWV0aG9kLCBzdHJhdGVneSkge1xuICAgIHRoaXMuaGFuZGxlcnNbbWV0aG9kXSA9IHN0cmF0ZWd5O1xuICB9XG4gIC8qKlxuICAgKiBPdmVybG9hZCB0aGlzIG1ldGhvZCB0byBhcHBseSB0b2tlbnMsIHdoaWNoIGNhblxuICAgKiB3cmFwIHBlcm1pc3Npb24gc2V0cyB0byBiZSBhcHBsaWVkIHRvIGEgcHVia2V5LlxuICAgKiBAcGFyYW0gcHVia2V5IHB1YmxpYyBrZXkgdG8gYXBwbHkgdG9rZW4gdG9cbiAgICogQHBhcmFtIHRva2VuIHRva2VuIHRvIGFwcGx5XG4gICAqL1xuICBhc3luYyBhcHBseVRva2VuKF9wdWJrZXksIF90b2tlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvbm5lY3Rpb24gdG9rZW4gbm90IHN1cHBvcnRlZFwiKTtcbiAgfVxuICBhc3luYyBoYW5kbGVJbmNvbWluZ0V2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgeyBpZCwgbWV0aG9kLCBwYXJhbXMgfSA9IGF3YWl0IHRoaXMucnBjLnBhcnNlRXZlbnQoZXZlbnQpO1xuICAgIGNvbnN0IHJlbW90ZVB1YmtleSA9IGV2ZW50LnB1YmtleTtcbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgdGhpcy5kZWJ1ZyhcImluY29taW5nIGV2ZW50XCIsIHsgaWQsIG1ldGhvZCwgcGFyYW1zIH0pO1xuICAgIGlmICghZXZlbnQudmVyaWZ5U2lnbmF0dXJlKGZhbHNlKSkge1xuICAgICAgdGhpcy5kZWJ1ZyhcImludmFsaWQgc2lnbmF0dXJlXCIsIGV2ZW50LnJhd0V2ZW50KCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdHJhdGVneSA9IHRoaXMuaGFuZGxlcnNbbWV0aG9kXTtcbiAgICBpZiAoc3RyYXRlZ3kpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgc3RyYXRlZ3kuaGFuZGxlKHRoaXMsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJlcnJvciBoYW5kbGluZyBldmVudFwiLCBlLCB7IGlkLCBtZXRob2QsIHBhcmFtcyB9KTtcbiAgICAgICAgdGhpcy5ycGMuc2VuZFJlc3BvbnNlKGlkLCByZW1vdGVQdWJrZXksIFwiZXJyb3JcIiwgdm9pZCAwLCBlLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlYnVnKFwidW5zdXBwb3J0ZWQgbWV0aG9kXCIsIHsgbWV0aG9kLCBwYXJhbXMgfSk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgdGhpcy5kZWJ1Zyhgc2VuZGluZyByZXNwb25zZSB0byAke3JlbW90ZVB1YmtleX1gLCByZXNwb25zZSk7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVzcG9uc2UoaWQsIHJlbW90ZVB1YmtleSwgcmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVzcG9uc2UoaWQsIHJlbW90ZVB1YmtleSwgXCJlcnJvclwiLCB2b2lkIDAsIFwiTm90IGF1dGhvcml6ZWRcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGVuIGJ5IHRoZSB1c2VyIHRvIGFsbG93IG9yIHJlamVjdCBpbmNvbWluZ1xuICAgKiBjb25uZWN0aW9ucy5cbiAgICovXG4gIGFzeW5jIHB1YmtleUFsbG93ZWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMucGVybWl0Q2FsbGJhY2socGFyYW1zKTtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvaW5kZXgudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI2IH0gZnJvbSBcInRzZWVwXCI7XG5cbi8vIHNyYy9zaWduZXJzL2Rlc2VyaWFsaXphdGlvbi50c1xudmFyIHNpZ25lclJlZ2lzdHJ5ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbnNpZ25lclJlZ2lzdHJ5LnNldChcInByaXZhdGUta2V5XCIsIE5ES1ByaXZhdGVLZXlTaWduZXIpO1xuc2lnbmVyUmVnaXN0cnkuc2V0KFwibmlwMDdcIiwgTkRLTmlwMDdTaWduZXIpO1xuc2lnbmVyUmVnaXN0cnkuc2V0KFwibmlwNDZcIiwgTkRLTmlwNDZTaWduZXIpO1xuYXN5bmMgZnVuY3Rpb24gbmRrU2lnbmVyRnJvbVBheWxvYWQocGF5bG9hZFN0cmluZywgbmRrKSB7XG4gIGxldCBwYXJzZWQ7XG4gIHRyeSB7XG4gICAgcGFyc2VkID0gSlNPTi5wYXJzZShwYXlsb2FkU3RyaW5nKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHNpZ25lciBwYXlsb2FkOiAke2UgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKX1gKTtcbiAgfVxuICBjb25zdCBTaWduZXJDbGFzcyA9IHNpZ25lclJlZ2lzdHJ5LmdldChwYXJzZWQudHlwZSk7XG4gIGlmICghU2lnbmVyQ2xhc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc2lnbmVyIHR5cGU6ICR7cGFyc2VkLnR5cGV9YCk7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgU2lnbmVyQ2xhc3MuZnJvbVBheWxvYWQocGF5bG9hZFN0cmluZywgbmRrKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnN0IGVycm9yTXNnID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpO1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlc2VyaWFsaXplIHNpZ25lciB0eXBlICR7cGFyc2VkLnR5cGV9OiAke2Vycm9yTXNnfWApO1xuICB9XG59XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2luZGV4LnRzXG52YXIgTkRLTmlwNDZTaWduZXIgPSBjbGFzcyBfTkRLTmlwNDZTaWduZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXI2IHtcbiAgbmRrO1xuICBfdXNlcjtcbiAgLyoqXG4gICAqIFRoZSBwdWJrZXkgb2YgdGhlIGJ1bmtlciB0aGF0IHdpbGwgYmUgcHJvdmlkaW5nIHNpZ25hdHVyZXNcbiAgICovXG4gIGJ1bmtlclB1YmtleTtcbiAgLyoqXG4gICAqIFRoZSBwdWJrZXkgb2YgdGhlIHVzZXIgdGhhdCBldmVudHMgd2lsbCBiZSBwdWJsaXNoZWQgYXNcbiAgICovXG4gIHVzZXJQdWJrZXk7XG4gIGdldCBwdWJrZXkoKSB7XG4gICAgaWYgKCF0aGlzLnVzZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIk5vdCByZWFkeVwiKTtcbiAgICByZXR1cm4gdGhpcy51c2VyUHVia2V5O1xuICB9XG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBzZWNyZXQgdmFsdWUgcHJvdmlkZWQgdG8gY29ubmVjdCB0byB0aGUgYnVua2VyXG4gICAqL1xuICBzZWNyZXQ7XG4gIGxvY2FsU2lnbmVyO1xuICBuaXAwNTtcbiAgcnBjO1xuICBkZWJ1ZztcbiAgcmVsYXlVcmxzO1xuICBzdWJzY3JpcHRpb247XG4gIC8qKlxuICAgKiBAcGFyYW0gbmRrIC0gVGhlIE5ESyBpbnN0YW5jZSB0byB1c2VcbiAgICogQHBhcmFtIHVzZXJPckNvbm5lY3Rpb25Ub2tlbiAtIFRoZSBwdWJsaWMga2V5LCBvciBhIGNvbm5lY3Rpb24gdG9rZW4sIG9mIHRoZSBucHViIHRoYXQgd2FudHMgdG8gYmUgcHVibGlzaGVkIGFzXG4gICAqIEBwYXJhbSBsb2NhbFNpZ25lciAtIFRoZSBzaWduZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmVxdWVzdCBldmVudHMgdG8gYmUgc2lnbmVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuZGssIHVzZXJPckNvbm5lY3Rpb25Ub2tlbiwgbG9jYWxTaWduZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMuZGVidWcgPSBuZGsuZGVidWcuZXh0ZW5kKFwibmlwNDY6c2lnbmVyXCIpO1xuICAgIGlmICh1c2VyT3JDb25uZWN0aW9uVG9rZW4uc3RhcnRzV2l0aChcImJ1bmtlcjovL1wiKSkge1xuICAgICAgdGhpcy5jb25uZWN0aW9uVG9rZW5Jbml0KHVzZXJPckNvbm5lY3Rpb25Ub2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmlwMDVJbml0KHVzZXJPckNvbm5lY3Rpb25Ub2tlbik7XG4gICAgfVxuICAgIGlmICghbG9jYWxTaWduZXIpIHtcbiAgICAgIHRoaXMubG9jYWxTaWduZXIgPSBOREtQcml2YXRlS2V5U2lnbmVyLmdlbmVyYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9jYWxTaWduZXIgPSBsb2NhbFNpZ25lcjtcbiAgICB9XG4gICAgdGhpcy5ycGMgPSBuZXcgTkRLTm9zdHJScGModGhpcy5uZGssIHRoaXMubG9jYWxTaWduZXIsIHRoaXMuZGVidWcsIHRoaXMucmVsYXlVcmxzKTtcbiAgfVxuICBjb25uZWN0aW9uVG9rZW5Jbml0KGNvbm5lY3Rpb25Ub2tlbikge1xuICAgIGNvbnN0IGJ1bmtlclVybCA9IG5ldyBVUkwoY29ubmVjdGlvblRva2VuKTtcbiAgICBjb25zdCBidW5rZXJQdWJrZXkgPSBidW5rZXJVcmwuaG9zdG5hbWUgfHwgYnVua2VyVXJsLnBhdGhuYW1lLnJlcGxhY2UoL15cXC9cXC8vLCBcIlwiKTtcbiAgICBjb25zdCB1c2VyUHVia2V5ID0gYnVua2VyVXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJwdWJrZXlcIik7XG4gICAgY29uc3QgcmVsYXlVcmxzID0gYnVua2VyVXJsLnNlYXJjaFBhcmFtcy5nZXRBbGwoXCJyZWxheVwiKTtcbiAgICBjb25zdCBzZWNyZXQgPSBidW5rZXJVcmwuc2VhcmNoUGFyYW1zLmdldChcInNlY3JldFwiKTtcbiAgICB0aGlzLmJ1bmtlclB1YmtleSA9IGJ1bmtlclB1YmtleTtcbiAgICB0aGlzLnVzZXJQdWJrZXkgPSB1c2VyUHVia2V5O1xuICAgIHRoaXMucmVsYXlVcmxzID0gcmVsYXlVcmxzO1xuICAgIHRoaXMuc2VjcmV0ID0gc2VjcmV0O1xuICB9XG4gIG5pcDA1SW5pdChuaXAwNSkge1xuICAgIHRoaXMubmlwMDUgPSBuaXAwNTtcbiAgfVxuICAvKipcbiAgICogV2Ugc3RhcnQgbGlzdGVuaW5nIGZvciBldmVudHMgZnJvbSB0aGUgYnVua2VyXG4gICAqL1xuICBhc3luYyBzdGFydExpc3RlbmluZygpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHJldHVybjtcbiAgICBjb25zdCBsb2NhbFVzZXIgPSBhd2FpdCB0aGlzLmxvY2FsU2lnbmVyLnVzZXIoKTtcbiAgICBpZiAoIWxvY2FsVXNlcikgdGhyb3cgbmV3IEVycm9yKFwiTG9jYWwgc2lnbmVyIG5vdCByZWFkeVwiKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IGF3YWl0IHRoaXMucnBjLnN1YnNjcmliZSh7XG4gICAgICBraW5kczogWzI0MTMzIC8qIE5vc3RyQ29ubmVjdCAqL10sXG4gICAgICBcIiNwXCI6IFtsb2NhbFVzZXIucHVia2V5XVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIgdGhhdCBpcyBiZWluZyBwdWJsaXNoZWQgYXNcbiAgICovXG4gIGFzeW5jIHVzZXIoKSB7XG4gICAgaWYgKHRoaXMuX3VzZXIpIHJldHVybiB0aGlzLl91c2VyO1xuICAgIHJldHVybiB0aGlzLmJsb2NrVW50aWxSZWFkeSgpO1xuICB9XG4gIGdldCB1c2VyU3luYygpIHtcbiAgICBpZiAoIXRoaXMuX3VzZXIpIHRocm93IG5ldyBFcnJvcihcIlJlbW90ZSB1c2VyIG5vdCByZWFkeSBzeW5jaHJvbm91c2x5XCIpO1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIGFzeW5jIGJsb2NrVW50aWxSZWFkeSgpIHtcbiAgICBpZiAodGhpcy5uaXAwNSAmJiAhdGhpcy51c2VyUHVia2V5KSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgTkRLVXNlci5mcm9tTmlwMDUodGhpcy5uaXAwNSwgdGhpcy5uZGspO1xuICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgdGhpcy5fdXNlciA9IHVzZXI7XG4gICAgICAgIHRoaXMudXNlclB1YmtleSA9IHVzZXIucHVia2V5O1xuICAgICAgICB0aGlzLnJlbGF5VXJscyA9IHVzZXIubmlwNDZVcmxzO1xuICAgICAgICB0aGlzLnJwYyA9IG5ldyBOREtOb3N0clJwYyh0aGlzLm5kaywgdGhpcy5sb2NhbFNpZ25lciwgdGhpcy5kZWJ1ZywgdGhpcy5yZWxheVVybHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuYnVua2VyUHVia2V5ICYmIHRoaXMudXNlclB1YmtleSkge1xuICAgICAgdGhpcy5idW5rZXJQdWJrZXkgPSB0aGlzLnVzZXJQdWJrZXk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5zdGFydExpc3RlbmluZygpO1xuICAgIHRoaXMucnBjLm9uKFwiYXV0aFVybFwiLCAoLi4ucHJvcHMpID0+IHtcbiAgICAgIHRoaXMuZW1pdChcImF1dGhVcmxcIiwgLi4ucHJvcHMpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjb25uZWN0UGFyYW1zID0gW3RoaXMudXNlclB1YmtleSA/PyBcIlwiXTtcbiAgICAgIGlmICh0aGlzLnNlY3JldCkgY29ubmVjdFBhcmFtcy5wdXNoKHRoaXMuc2VjcmV0KTtcbiAgICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KHRoaXMuYnVua2VyUHVia2V5LCBcImNvbm5lY3RcIiwgY29ubmVjdFBhcmFtcywgMjQxMzMsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2UucmVzdWx0ID09PSBcImFja1wiKSB7XG4gICAgICAgICAgdGhpcy5nZXRQdWJsaWNLZXkoKS50aGVuKChwdWJrZXkpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXNlclB1YmtleSA9IHB1YmtleTtcbiAgICAgICAgICAgIHRoaXMuX3VzZXIgPSB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5IH0pO1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLl91c2VyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXRQdWJsaWNLZXkoKSB7XG4gICAgaWYgKHRoaXMudXNlclB1YmtleSkgcmV0dXJuIHRoaXMudXNlclB1YmtleTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIF9yZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KHRoaXMuYnVua2VyUHVia2V5LCBcImdldF9wdWJsaWNfa2V5XCIsIFtdLCAyNDEzMywgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIHJlc29sdmUocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGVuY3J5cHRpb25FbmFibGVkKHNjaGVtZSkge1xuICAgIGlmIChzY2hlbWUpIHJldHVybiBbc2NoZW1lXTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtcIm5pcDA0XCIsIFwibmlwNDRcIl0pO1xuICB9XG4gIGFzeW5jIGVuY3J5cHQocmVjaXBpZW50LCB2YWx1ZSwgc2NoZW1lID0gXCJuaXAwNFwiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvbihyZWNpcGllbnQsIHZhbHVlLCBzY2hlbWUsIFwiZW5jcnlwdFwiKTtcbiAgfVxuICBhc3luYyBkZWNyeXB0KHNlbmRlciwgdmFsdWUsIHNjaGVtZSA9IFwibmlwMDRcIikge1xuICAgIHJldHVybiB0aGlzLmVuY3J5cHRpb24oc2VuZGVyLCB2YWx1ZSwgc2NoZW1lLCBcImRlY3J5cHRcIik7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdGlvbihwZWVyLCB2YWx1ZSwgc2NoZW1lLCBtZXRob2QpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmJ1bmtlclB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiQnVua2VyIHB1YmtleSBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QoXG4gICAgICAgIHRoaXMuYnVua2VyUHVia2V5LFxuICAgICAgICBgJHtzY2hlbWV9XyR7bWV0aG9kfWAsXG4gICAgICAgIFtwZWVyLnB1YmtleSwgdmFsdWVdLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBhc3luYyBzaWduKGV2ZW50KSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KFxuICAgICAgICB0aGlzLmJ1bmtlclB1YmtleSxcbiAgICAgICAgXCJzaWduX2V2ZW50XCIsXG4gICAgICAgIFtKU09OLnN0cmluZ2lmeShldmVudCldLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgICAgIHJlc29sdmUoanNvbi5zaWcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIGNyZWF0aW5nIGEgbmV3IGFjY291bnQgb24gdGhlIHJlbW90ZSBzZXJ2ZXIuXG4gICAqIEBwYXJhbSB1c2VybmFtZSBEZXNpcmVkIHVzZXJuYW1lIGZvciB0aGUgTklQLTA1XG4gICAqIEBwYXJhbSBkb21haW4gRGVzaXJlZCBkb21haW4gZm9yIHRoZSBOSVAtMDVcbiAgICogQHBhcmFtIGVtYWlsIEVtYWlsIGFkZHJlc3MgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBhY2NvdW50IC0tIFJlbW90ZSBzZXJ2ZXJzIG1heSB1c2UgdGhpcyBmb3IgcmVjb3ZlcnlcbiAgICogQHJldHVybnMgVGhlIHB1YmxpYyBrZXkgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgYWNjb3VudFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQWNjb3VudCh1c2VybmFtZSwgZG9tYWluLCBlbWFpbCkge1xuICAgIGF3YWl0IHRoaXMuc3RhcnRMaXN0ZW5pbmcoKTtcbiAgICBjb25zdCByZXEgPSBbXTtcbiAgICBpZiAodXNlcm5hbWUpIHJlcS5wdXNoKHVzZXJuYW1lKTtcbiAgICBpZiAoZG9tYWluKSByZXEucHVzaChkb21haW4pO1xuICAgIGlmIChlbWFpbCkgcmVxLnB1c2goZW1haWwpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMuYnVua2VyUHVia2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJCdW5rZXIgcHVia2V5IG5vdCBzZXRcIik7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVxdWVzdChcbiAgICAgICAgdGhpcy5idW5rZXJQdWJrZXksXG4gICAgICAgIFwiY3JlYXRlX2FjY291bnRcIixcbiAgICAgICAgcmVxLFxuICAgICAgICAyNDEzMyAvKiBOb3N0ckNvbm5lY3QgKi8sXG4gICAgICAgIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGlmICghcmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YmtleSA9IHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgIHJlc29sdmUocHVia2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIHNpZ25lcidzIGNvbm5lY3Rpb24gZGV0YWlscyBhbmQgbG9jYWwgc2lnbmVyIHN0YXRlLlxuICAgKiBAcmV0dXJucyBBIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHR5cGUsIGNvbm5lY3Rpb24gaW5mbywgYW5kIGxvY2FsIHNpZ25lciBwYXlsb2FkLlxuICAgKi9cbiAgdG9QYXlsb2FkKCkge1xuICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkgfHwgIXRoaXMudXNlclB1YmtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTklQLTQ2IHNpZ25lciBpcyBub3QgZnVsbHkgaW5pdGlhbGl6ZWQgZm9yIHNlcmlhbGl6YXRpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICB0eXBlOiBcIm5pcDQ2XCIsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGJ1bmtlclB1YmtleTogdGhpcy5idW5rZXJQdWJrZXksXG4gICAgICAgIHVzZXJQdWJrZXk6IHRoaXMudXNlclB1YmtleSxcbiAgICAgICAgcmVsYXlVcmxzOiB0aGlzLnJlbGF5VXJscyxcbiAgICAgICAgc2VjcmV0OiB0aGlzLnNlY3JldCxcbiAgICAgICAgbG9jYWxTaWduZXJQYXlsb2FkOiB0aGlzLmxvY2FsU2lnbmVyLnRvUGF5bG9hZCgpLFxuICAgICAgICAvLyBTdG9yZSBuaXAwNSBpZiBpdCB3YXMgdXNlZCBmb3IgaW5pdGlhbGl6YXRpb24sIG90aGVyd2lzZSBudWxsXG4gICAgICAgIG5pcDA1OiB0aGlzLm5pcDA1IHx8IG51bGxcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgfVxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBzaWduZXIgZnJvbSBhIHBheWxvYWQgc3RyaW5nLlxuICAgKiBAcGFyYW0gcGF5bG9hZFN0cmluZyBUaGUgSlNPTiBzdHJpbmcgb2J0YWluZWQgZnJvbSB0b1BheWxvYWQoKS5cbiAgICogQHBhcmFtIG5kayBUaGUgTkRLIGluc3RhbmNlLCByZXF1aXJlZCBmb3IgTklQLTQ2LlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBOREtOaXA0NlNpZ25lci5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBmcm9tUGF5bG9hZChwYXlsb2FkU3RyaW5nLCBuZGspIHtcbiAgICBpZiAoIW5kaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIGlzIHJlcXVpcmVkIHRvIGRlc2VyaWFsaXplIE5JUC00NiBzaWduZXJcIik7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UocGF5bG9hZFN0cmluZyk7XG4gICAgaWYgKHBhcnNlZC50eXBlICE9PSBcIm5pcDQ2XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXlsb2FkIHR5cGU6IGV4cGVjdGVkICduaXA0NicsIGdvdCAke3BhcnNlZC50eXBlfWApO1xuICAgIH1cbiAgICBjb25zdCBwYXlsb2FkID0gcGFyc2VkLnBheWxvYWQ7XG4gICAgaWYgKCFwYXlsb2FkIHx8IHR5cGVvZiBwYXlsb2FkICE9PSBcIm9iamVjdFwiIHx8ICFwYXlsb2FkLmxvY2FsU2lnbmVyUGF5bG9hZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXlsb2FkIGNvbnRlbnQgZm9yIG5pcDQ2IHNpZ25lclwiKTtcbiAgICB9XG4gICAgY29uc3QgbG9jYWxTaWduZXIgPSBhd2FpdCBuZGtTaWduZXJGcm9tUGF5bG9hZChwYXlsb2FkLmxvY2FsU2lnbmVyUGF5bG9hZCwgbmRrKTtcbiAgICBpZiAoIWxvY2FsU2lnbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVzZXJpYWxpemUgbG9jYWwgc2lnbmVyIGZvciBOSVAtNDZcIik7XG4gICAgfVxuICAgIGxldCBzaWduZXI7XG4gICAgaWYgKHBheWxvYWQubmlwMDUpIHtcbiAgICAgIHNpZ25lciA9IG5ldyBfTkRLTmlwNDZTaWduZXIobmRrLCBwYXlsb2FkLm5pcDA1LCBsb2NhbFNpZ25lcik7XG4gICAgICBzaWduZXIudXNlclB1YmtleSA9IHBheWxvYWQudXNlclB1YmtleTtcbiAgICAgIHNpZ25lci5idW5rZXJQdWJrZXkgPSBwYXlsb2FkLmJ1bmtlclB1YmtleTtcbiAgICAgIHNpZ25lci5yZWxheVVybHMgPSBwYXlsb2FkLnJlbGF5VXJscztcbiAgICAgIHNpZ25lci5zZWNyZXQgPSBwYXlsb2FkLnNlY3JldDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2lnbmVyID0gbmV3IF9OREtOaXA0NlNpZ25lcihuZGssIHBheWxvYWQudXNlclB1YmtleSwgbG9jYWxTaWduZXIpO1xuICAgICAgc2lnbmVyLmJ1bmtlclB1YmtleSA9IHBheWxvYWQuYnVua2VyUHVia2V5O1xuICAgICAgc2lnbmVyLnJlbGF5VXJscyA9IHBheWxvYWQucmVsYXlVcmxzO1xuICAgICAgc2lnbmVyLnNlY3JldCA9IHBheWxvYWQuc2VjcmV0O1xuICAgIH1cbiAgICByZXR1cm4gc2lnbmVyO1xuICB9XG59O1xuXG4vLyBzcmMvZHZtL3NjaGVkdWxlLnRzXG5mdW5jdGlvbiBhZGRSZWxheXMoZXZlbnQsIHJlbGF5cykge1xuICBjb25zdCB0YWdzID0gW107XG4gIGlmICghcmVsYXlzIHx8IHJlbGF5cy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zdCBwb29sUmVsYXlzID0gZXZlbnQubmRrPy5wb29sLnJlbGF5cztcbiAgICByZWxheXMgPSBwb29sUmVsYXlzID8gT2JqZWN0LmtleXMocG9vbFJlbGF5cykgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKHJlbGF5cyAmJiByZWxheXMubGVuZ3RoID4gMCkgdGFncy5wdXNoKFtcInJlbGF5c1wiLCAuLi5yZWxheXNdKTtcbiAgcmV0dXJuIHRhZ3M7XG59XG5hc3luYyBmdW5jdGlvbiBkdm1TY2hlZHVsZShldmVudHMsIGR2bSwgcmVsYXlzLCBlbmNyeXB0ZWQgPSB0cnVlLCB3YWl0Rm9yQ29uZmlybWF0aW9uRm9yTXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV2ZW50cykpIHtcbiAgICBldmVudHMgPSBbZXZlbnRzXTtcbiAgfVxuICBjb25zdCBuZGsgPSBldmVudHNbMF0ubmRrO1xuICBpZiAoIW5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIG5vdCBzZXRcIik7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgaWYgKCFldmVudC5zaWcpIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IG5vdCBzaWduZWRcIik7XG4gICAgaWYgKCFldmVudC5jcmVhdGVkX2F0KSB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBoYXMgbm8gZGF0ZVwiKTtcbiAgICBpZiAoIWR2bSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gRFZNIHNwZWNpZmllZFwiKTtcbiAgICBpZiAoZXZlbnQuY3JlYXRlZF9hdCA8PSBEYXRlLm5vdygpIC8gMWUzKSB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBuZWVkcyB0byBiZSBpbiB0aGUgZnV0dXJlXCIpO1xuICB9XG4gIGNvbnN0IHNjaGVkdWxlRXZlbnQgPSBuZXcgTkRLRFZNUmVxdWVzdChuZGssIHtcbiAgICBraW5kOiA1OTA1IC8qIERWTUV2ZW50U2NoZWR1bGUgKi9cbiAgfSk7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgc2NoZWR1bGVFdmVudC5hZGRJbnB1dChKU09OLnN0cmluZ2lmeShldmVudC5yYXdFdmVudCgpKSwgXCJ0ZXh0XCIpO1xuICB9XG4gIHNjaGVkdWxlRXZlbnQudGFncy5wdXNoKC4uLmFkZFJlbGF5cyhldmVudHNbMF0sIHJlbGF5cykpO1xuICBpZiAoZW5jcnlwdGVkKSB7XG4gICAgYXdhaXQgc2NoZWR1bGVFdmVudC5lbmNyeXB0aW9uKGR2bSk7XG4gIH0gZWxzZSB7XG4gICAgc2NoZWR1bGVFdmVudC5kdm0gPSBkdm07XG4gIH1cbiAgYXdhaXQgc2NoZWR1bGVFdmVudC5zaWduKCk7XG4gIGxldCByZXM7XG4gIGlmICh3YWl0Rm9yQ29uZmlybWF0aW9uRm9yTXMpIHtcbiAgICByZXMgPSBuZGsuc3Vic2NyaWJlKFxuICAgICAge1xuICAgICAgICBraW5kczogWzU5MDUgLyogRFZNRXZlbnRTY2hlZHVsZSAqLyArIDFlMywgN2UzIC8qIERWTUpvYkZlZWRiYWNrICovXSxcbiAgICAgICAgLi4uc2NoZWR1bGVFdmVudC5maWx0ZXIoKVxuICAgICAgfSxcbiAgICAgIHsgZ3JvdXBhYmxlOiBmYWxzZSwgY2xvc2VPbkVvc2U6IGZhbHNlIH1cbiAgICApO1xuICB9XG4gIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlamVjdCkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVzPy5zdG9wKCk7XG4gICAgICByZWplY3QoXCJUaW1lb3V0IHdhaXRpbmcgZm9yIGFuIGFuc3dlciBmcm9tIHRoZSBEVk1cIik7XG4gICAgfSwgd2FpdEZvckNvbmZpcm1hdGlvbkZvck1zKTtcbiAgfSk7XG4gIGNvbnN0IHNjaGVkdWxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAod2FpdEZvckNvbmZpcm1hdGlvbkZvck1zKSB7XG4gICAgICByZXM/Lm9uKFwiZXZlbnRcIiwgYXN5bmMgKGUpID0+IHtcbiAgICAgICAgcmVzPy5zdG9wKCk7XG4gICAgICAgIGlmIChlLmtpbmQgPT09IDdlMyAvKiBEVk1Kb2JGZWVkYmFjayAqLykge1xuICAgICAgICAgIGNvbnN0IGZlZWRiYWNrID0gYXdhaXQgTkRLRFZNSm9iRmVlZGJhY2suZnJvbShlKTtcbiAgICAgICAgICBpZiAoZmVlZGJhY2suc3RhdHVzID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c1RhZyA9IGZlZWRiYWNrLmdldE1hdGNoaW5nVGFncyhcInN0YXR1c1wiKTtcbiAgICAgICAgICAgIHJlamVjdChzdGF0dXNUYWc/LlsyXSA/PyBmZWVkYmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoZmVlZGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKGUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNjaGVkdWxlRXZlbnQucHVibGlzaCgpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKCF3YWl0Rm9yQ29uZmlybWF0aW9uRm9yTXMpIHJlc29sdmUodm9pZCAwKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKHdhaXRGb3JDb25maXJtYXRpb25Gb3JNcykge1xuICAgICAgUHJvbWlzZS5yYWNlKFt0aW1lb3V0UHJvbWlzZSwgc2NoZWR1bGVQcm9taXNlXSkudGhlbigoZSkgPT4ge1xuICAgICAgICByZXNvbHZlKGUpO1xuICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVQcm9taXNlLnRoZW4ocmVzb2x2ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL25kay9pbmRleC50c1xuaW1wb3J0IGRlYnVnNyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI4IH0gZnJvbSBcInRzZWVwXCI7XG5cbi8vIHNyYy9ldmVudHMvZGVkdXAudHNcbmZ1bmN0aW9uIGRlZHVwKGV2ZW50MSwgZXZlbnQyKSB7XG4gIGlmIChldmVudDEuY3JlYXRlZF9hdCA+IGV2ZW50Mi5jcmVhdGVkX2F0KSB7XG4gICAgcmV0dXJuIGV2ZW50MTtcbiAgfVxuICByZXR1cm4gZXZlbnQyO1xufVxuXG4vLyBzcmMvb3V0Ym94L3RyYWNrZXIudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI3IH0gZnJvbSBcInRzZWVwXCI7XG5pbXBvcnQgeyBMUlVDYWNoZSBhcyBMUlVDYWNoZTIgfSBmcm9tIFwidHlwZXNjcmlwdC1scnUtY2FjaGVcIjtcblxuLy8gc3JjL3V0aWxzL2dldC11c2Vycy1yZWxheS1saXN0LnRzXG5hc3luYyBmdW5jdGlvbiBnZXRSZWxheUxpc3RGb3JVc2VyKHB1YmtleSwgbmRrKSB7XG4gIGNvbnN0IGxpc3QgPSBhd2FpdCBnZXRSZWxheUxpc3RGb3JVc2VycyhbcHVia2V5XSwgbmRrKTtcbiAgcmV0dXJuIGxpc3QuZ2V0KHB1YmtleSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRSZWxheUxpc3RGb3JVc2VycyhwdWJrZXlzLCBuZGssIHNraXBDYWNoZSA9IGZhbHNlLCB0aW1lb3V0ID0gMWUzKSB7XG4gIGNvbnN0IHBvb2wgPSBuZGsub3V0Ym94UG9vbCB8fCBuZGsucG9vbDtcbiAgY29uc3Qgc2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCByZWxheSBvZiBwb29sLnJlbGF5cy52YWx1ZXMoKSkgc2V0LmFkZChyZWxheSk7XG4gIGNvbnN0IHJlbGF5TGlzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBmcm9tQ29udGFjdExpc3QgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCByZWxheVNldCA9IG5ldyBOREtSZWxheVNldChzZXQsIG5kayk7XG4gIGlmIChuZGsuY2FjaGVBZGFwdGVyPy5sb2NraW5nICYmICFza2lwQ2FjaGUpIHtcbiAgICBjb25zdCBjYWNoZWRMaXN0ID0gYXdhaXQgbmRrLmZldGNoRXZlbnRzKFxuICAgICAgeyBraW5kczogWzMsIDEwMDAyXSwgYXV0aG9yczogQXJyYXkuZnJvbShuZXcgU2V0KHB1YmtleXMpKSB9LFxuICAgICAgeyBjYWNoZVVzYWdlOiBcIk9OTFlfQ0FDSEVcIiAvKiBPTkxZX0NBQ0hFICovLCBzdWJJZDogXCJuZGstcmVsYXktbGlzdC1mZXRjaFwiIH1cbiAgICApO1xuICAgIGZvciAoY29uc3QgcmVsYXlMaXN0IG9mIGNhY2hlZExpc3QpIHtcbiAgICAgIGlmIChyZWxheUxpc3Qua2luZCA9PT0gMTAwMDIpIHJlbGF5TGlzdHMuc2V0KHJlbGF5TGlzdC5wdWJrZXksIE5ES1JlbGF5TGlzdC5mcm9tKHJlbGF5TGlzdCkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHJlbGF5TGlzdCBvZiBjYWNoZWRMaXN0KSB7XG4gICAgICBpZiAocmVsYXlMaXN0LmtpbmQgPT09IDMpIHtcbiAgICAgICAgaWYgKHJlbGF5TGlzdHMuaGFzKHJlbGF5TGlzdC5wdWJrZXkpKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbGlzdCA9IHJlbGF5TGlzdEZyb21LaW5kMyhuZGssIHJlbGF5TGlzdCk7XG4gICAgICAgIGlmIChsaXN0KSBmcm9tQ29udGFjdExpc3Quc2V0KHJlbGF5TGlzdC5wdWJrZXksIGxpc3QpO1xuICAgICAgfVxuICAgIH1cbiAgICBwdWJrZXlzID0gcHVia2V5cy5maWx0ZXIoKHB1YmtleSkgPT4gIXJlbGF5TGlzdHMuaGFzKHB1YmtleSkgJiYgIWZyb21Db250YWN0TGlzdC5oYXMocHVia2V5KSk7XG4gIH1cbiAgaWYgKHB1YmtleXMubGVuZ3RoID09PSAwKSByZXR1cm4gcmVsYXlMaXN0cztcbiAgY29uc3QgcmVsYXlMaXN0RXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgY29udGFjdExpc3RFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBoYW5kbGVTdWJzY3JpcHRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdWJzY3JpYmVPcHRzID0ge1xuICAgICAgICBjbG9zZU9uRW9zZTogdHJ1ZSxcbiAgICAgICAgcG9vbCxcbiAgICAgICAgZ3JvdXBhYmxlOiB0cnVlLFxuICAgICAgICBzdWJJZDogXCJuZGstcmVsYXktbGlzdC1mZXRjaFwiLFxuICAgICAgICBhZGRTaW5jZUZyb21DYWNoZTogdHJ1ZSxcbiAgICAgICAgcmVsYXlTZXRcbiAgICAgIH07XG4gICAgICBpZiAocmVsYXlTZXQpIHN1YnNjcmliZU9wdHMucmVsYXlTZXQgPSByZWxheVNldDtcbiAgICAgIG5kay5zdWJzY3JpYmUoeyBraW5kczogWzMsIDEwMDAyXSwgYXV0aG9yczogcHVia2V5cyB9LCBzdWJzY3JpYmVPcHRzLCB7XG4gICAgICAgIG9uRXZlbnQ6IChldmVudCkgPT4ge1xuICAgICAgICAgIGlmIChldmVudC5raW5kID09PSAxMDAwMiAvKiBSZWxheUxpc3QgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRXZlbnQgPSByZWxheUxpc3RFdmVudHMuZ2V0KGV2ZW50LnB1YmtleSk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdFdmVudCAmJiBleGlzdGluZ0V2ZW50LmNyZWF0ZWRfYXQgPiBldmVudC5jcmVhdGVkX2F0KSByZXR1cm47XG4gICAgICAgICAgICByZWxheUxpc3RFdmVudHMuc2V0KGV2ZW50LnB1YmtleSwgZXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2luZCA9PT0gMyAvKiBDb250YWN0cyAqLykge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdFdmVudCA9IGNvbnRhY3RMaXN0RXZlbnRzLmdldChldmVudC5wdWJrZXkpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRXZlbnQgJiYgZXhpc3RpbmdFdmVudC5jcmVhdGVkX2F0ID4gZXZlbnQuY3JlYXRlZF9hdCkgcmV0dXJuO1xuICAgICAgICAgICAgY29udGFjdExpc3RFdmVudHMuc2V0KGV2ZW50LnB1YmtleSwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Fb3NlOiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiByZWxheUxpc3RFdmVudHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHJlbGF5TGlzdHMuc2V0KGV2ZW50LnB1YmtleSwgTkRLUmVsYXlMaXN0LmZyb20oZXZlbnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBwdWJrZXkgb2YgcHVia2V5cykge1xuICAgICAgICAgICAgaWYgKHJlbGF5TGlzdHMuaGFzKHB1YmtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgY29udGFjdExpc3QgPSBjb250YWN0TGlzdEV2ZW50cy5nZXQocHVia2V5KTtcbiAgICAgICAgICAgIGlmICghY29udGFjdExpc3QpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgbGlzdCA9IHJlbGF5TGlzdEZyb21LaW5kMyhuZGssIGNvbnRhY3RMaXN0KTtcbiAgICAgICAgICAgIGlmIChsaXN0KSByZWxheUxpc3RzLnNldChwdWJrZXksIGxpc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlbGF5TGlzdHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZXNvbHZlKHJlbGF5TGlzdHMpO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgfTtcbiAgICBoYW5kbGVTdWJzY3JpcHRpb24oKTtcbiAgfSk7XG59XG5cbi8vIHNyYy9vdXRib3gvdHJhY2tlci50c1xudmFyIE91dGJveEl0ZW0gPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBUeXBlIG9mIGl0ZW1cbiAgICovXG4gIHR5cGU7XG4gIC8qKlxuICAgKiBUaGUgcmVsYXkgVVJMcyB0aGF0IGFyZSBvZiBpbnRlcmVzdCB0byB0aGlzIGl0ZW1cbiAgICovXG4gIHJlbGF5VXJsU2NvcmVzO1xuICByZWFkUmVsYXlzO1xuICB3cml0ZVJlbGF5cztcbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5yZWxheVVybFNjb3JlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5yZWFkUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLndyaXRlUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgfVxufTtcbnZhciBPdXRib3hUcmFja2VyID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXI3IHtcbiAgZGF0YTtcbiAgbmRrO1xuICBkZWJ1ZztcbiAgY29uc3RydWN0b3IobmRrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLmRlYnVnID0gbmRrLmRlYnVnLmV4dGVuZChcIm91dGJveC10cmFja2VyXCIpO1xuICAgIHRoaXMuZGF0YSA9IG5ldyBMUlVDYWNoZTIoe1xuICAgICAgbWF4U2l6ZTogMWU1LFxuICAgICAgZW50cnlFeHBpcmF0aW9uVGltZUluTVM6IDIgKiA2MCAqIDFlM1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbGlzdCBvZiB1c2VycyB0byB0aGUgdHJhY2tlci5cbiAgICogQHBhcmFtIGl0ZW1zXG4gICAqIEBwYXJhbSBza2lwQ2FjaGVcbiAgICovXG4gIGFzeW5jIHRyYWNrVXNlcnMoaXRlbXMsIHNraXBDYWNoZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSA0MDApIHtcbiAgICAgIGNvbnN0IHNsaWNlID0gaXRlbXMuc2xpY2UoaSwgaSArIDQwMCk7XG4gICAgICBjb25zdCBwdWJrZXlzID0gc2xpY2UubWFwKChpdGVtKSA9PiBnZXRLZXlGcm9tSXRlbShpdGVtKSkuZmlsdGVyKChwdWJrZXkpID0+ICF0aGlzLmRhdGEuaGFzKHB1YmtleSkpO1xuICAgICAgaWYgKHB1YmtleXMubGVuZ3RoID09PSAwKSBjb250aW51ZTtcbiAgICAgIGZvciAoY29uc3QgcHVia2V5IG9mIHB1YmtleXMpIHtcbiAgICAgICAgdGhpcy5kYXRhLnNldChwdWJrZXksIG5ldyBPdXRib3hJdGVtKFwidXNlclwiKSk7XG4gICAgICB9XG4gICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIGdldFJlbGF5TGlzdEZvclVzZXJzKHB1YmtleXMsIHRoaXMubmRrLCBza2lwQ2FjaGUpLnRoZW4oKHJlbGF5TGlzdHMpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3B1YmtleSwgcmVsYXlMaXN0XSBvZiByZWxheUxpc3RzKSB7XG4gICAgICAgICAgICAgIGxldCBvdXRib3hJdGVtID0gdGhpcy5kYXRhLmdldChwdWJrZXkpO1xuICAgICAgICAgICAgICBvdXRib3hJdGVtID8/PSBuZXcgT3V0Ym94SXRlbShcInVzZXJcIik7XG4gICAgICAgICAgICAgIGlmIChyZWxheUxpc3QpIHtcbiAgICAgICAgICAgICAgICBvdXRib3hJdGVtLnJlYWRSZWxheXMgPSBuZXcgU2V0KG5vcm1hbGl6ZShyZWxheUxpc3QucmVhZFJlbGF5VXJscykpO1xuICAgICAgICAgICAgICAgIG91dGJveEl0ZW0ud3JpdGVSZWxheXMgPSBuZXcgU2V0KG5vcm1hbGl6ZShyZWxheUxpc3Qud3JpdGVSZWxheVVybHMpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIG91dGJveEl0ZW0ucmVhZFJlbGF5cykge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmRrLnBvb2wuYmxhY2tsaXN0UmVsYXlVcmxzLmhhcyhyZWxheVVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0Ym94SXRlbS5yZWFkUmVsYXlzLmRlbGV0ZShyZWxheVVybCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2Ygb3V0Ym94SXRlbS53cml0ZVJlbGF5cykge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmRrLnBvb2wuYmxhY2tsaXN0UmVsYXlVcmxzLmhhcyhyZWxheVVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0Ym94SXRlbS53cml0ZVJlbGF5cy5kZWxldGUocmVsYXlVcmwpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuc2V0KHB1YmtleSwgb3V0Ym94SXRlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5maW5hbGx5KHJlc29sdmUpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gc2NvcmVcbiAgICovXG4gIHRyYWNrKGl0ZW0sIHR5cGUsIF9za2lwQ2FjaGUgPSB0cnVlKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5RnJvbUl0ZW0oaXRlbSk7XG4gICAgdHlwZSA/Pz0gZ2V0VHlwZUZyb21JdGVtKGl0ZW0pO1xuICAgIGxldCBvdXRib3hJdGVtID0gdGhpcy5kYXRhLmdldChrZXkpO1xuICAgIGlmICghb3V0Ym94SXRlbSkge1xuICAgICAgb3V0Ym94SXRlbSA9IG5ldyBPdXRib3hJdGVtKHR5cGUpO1xuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtVc2VyKSB7XG4gICAgICAgIHRoaXMudHJhY2tVc2VycyhbaXRlbV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0Ym94SXRlbTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldEtleUZyb21JdGVtKGl0ZW0pIHtcbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtVc2VyKSB7XG4gICAgcmV0dXJuIGl0ZW0ucHVia2V5O1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuZnVuY3Rpb24gZ2V0VHlwZUZyb21JdGVtKGl0ZW0pIHtcbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtVc2VyKSB7XG4gICAgcmV0dXJuIFwidXNlclwiO1xuICB9XG4gIHJldHVybiBcImtpbmRcIjtcbn1cblxuLy8gc3JjL3JlbGF5L3NldHMvdXRpbHMudHNcbmZ1bmN0aW9uIGNvcnJlY3RSZWxheVNldChyZWxheVNldCwgcG9vbCkge1xuICBjb25zdCBjb25uZWN0ZWRSZWxheXMgPSBwb29sLmNvbm5lY3RlZFJlbGF5cygpO1xuICBjb25zdCBpbmNsdWRlc0Nvbm5lY3RlZFJlbGF5ID0gQXJyYXkuZnJvbShyZWxheVNldC5yZWxheXMpLnNvbWUoKHJlbGF5KSA9PiB7XG4gICAgcmV0dXJuIGNvbm5lY3RlZFJlbGF5cy5tYXAoKHIpID0+IHIudXJsKS5pbmNsdWRlcyhyZWxheS51cmwpO1xuICB9KTtcbiAgaWYgKCFpbmNsdWRlc0Nvbm5lY3RlZFJlbGF5KSB7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiBjb25uZWN0ZWRSZWxheXMpIHtcbiAgICAgIHJlbGF5U2V0LmFkZFJlbGF5KHJlbGF5KTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbm5lY3RlZFJlbGF5cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHBvb2wucmVsYXlzLnZhbHVlcygpKSB7XG4gICAgICByZWxheVNldC5hZGRSZWxheShyZWxheSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWxheVNldDtcbn1cblxuLy8gc3JjL3N1YnNjcmlwdGlvbi9tYW5hZ2VyLnRzXG5pbXBvcnQgeyBtYXRjaEZpbHRlcnMgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbnZhciBOREtTdWJzY3JpcHRpb25NYW5hZ2VyID0gY2xhc3Mge1xuICBzdWJzY3JpcHRpb25zO1xuICBzZWVuRXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBhZGQoc3ViKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChzdWIuaW50ZXJuYWxJZCwgc3ViKTtcbiAgICBpZiAoc3ViLm9uU3RvcHBlZCkge1xuICAgIH1cbiAgICBzdWIub25TdG9wcGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmRlbGV0ZShzdWIuaW50ZXJuYWxJZCk7XG4gICAgfTtcbiAgICBzdWIub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1Yi5pbnRlcm5hbElkKTtcbiAgICB9KTtcbiAgfVxuICBzZWVuRXZlbnQoZXZlbnRJZCwgcmVsYXkpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5zZWVuRXZlbnRzLmdldChldmVudElkKSB8fCBbXTtcbiAgICBjdXJyZW50LnB1c2gocmVsYXkpO1xuICAgIHRoaXMuc2VlbkV2ZW50cy5zZXQoZXZlbnRJZCwgY3VycmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZW5ldmVyIGFuIGV2ZW50IGNvbWVzIGluLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICogVGhpcyBmdW5jdGlvbiBtYXRjaGVzIHRoZSByZWNlaXZlZCBldmVudCBhZ2FpbnN0IGFsbCB0aGVcbiAgICoga25vd24gKGkuZS4gYWN0aXZlKSBOREtTdWJzY3JpcHRpb25zLCBhbmQgaWYgaXQgbWF0Y2hlcyxcbiAgICogaXQgc2VuZHMgdGhlIGV2ZW50IHRvIHRoZSBzdWJzY3JpcHRpb24uXG4gICAqXG4gICAqIFRoaXMgaXMgdGhlIHNpbmdsZSBwbGFjZSBpbiB0aGUgY29kZWJhc2UgdGhhdCBtYXRjaGVzXG4gICAqIGluY29taW5nIGV2ZW50cyB3aXRoIHBhcnRpZXMgaW50ZXJlc3RlZCBpbiB0aGUgZXZlbnQuXG4gICAqXG4gICAqIFRoaXMgaXMgYWxzbyB3aGF0IGFsbG93cyBmb3IgcmVhY3Rpdml0eSBpbiBOREsgYXBwcywgc3VjaCB0aGF0XG4gICAqIHdoZW5ldmVyIGFuIGFjdGl2ZSBzdWJzY3JpcHRpb24gcmVjZWl2ZXMgYW4gZXZlbnQgdGhhdCBzb21lXG4gICAqIG90aGVyIGFjdGl2ZSBzdWJzY3JpcHRpb24gd291bGQgd2FudCB0byByZWNlaXZlLCBib3RoIHJlY2VpdmUgaXQuXG4gICAqXG4gICAqIFRPRE8gVGhpcyBhbHNvIGFsbG93cyBmb3Igc3Vic2NyaXB0aW9ucyB0aGF0IG92ZXJsYXAgaW4gbWVhbmluZ1xuICAgKiB0byBiZSBjb2xsYXBzZWQgaW50byBvbmUuXG4gICAqXG4gICAqIEkuZS4gaWYgYSBzdWJzY3JpcHRpb24gd2l0aCBmaWx0ZXI6IGtpbmRzOiBbMV0sIGF1dGhvcnM6IFthbGljZV1cbiAgICogaXMgY3JlYXRlZCBhbmQgRU9TRXMsIGFuZCB0aGVuIGEgc3Vic2VxdWVudCBzdWJzY3JpcHRpb24gd2l0aFxuICAgKiBraW5kczogWzFdLCBhdXRob3JzOiBbYWxpY2VdIGlzIGNyZWF0ZWQsIG9uY2UgdGhlIHNlY29uZCBzdWJzY3JpcHRpb25cbiAgICogRU9TRXMgd2UgY2FuIHNhZmVseSBjbG9zZSBpdCwgaW5jcmVtZW50IGl0cyByZWZDb3VudCBhbmQgY2xvc2UgaXQsXG4gICAqIGFuZCB3aGVuIHRoZSBmaXJzdCBzdWJzY3JpcHRpb24gcmVjZWl2ZXMgYSBuZXcgZXZlbnQgZnJvbSBBbGljZSB0aGlzXG4gICAqIGNvZGUgd2lsbCBtYWtlIHRoZSBzZWNvbmQgc3Vic2NyaXB0aW9uIHJlY2VpdmUgdGhlIGV2ZW50IGV2ZW4gdGhvdWdoXG4gICAqIGl0IGhhcyBubyBhY3RpdmUgc3Vic2NyaXB0aW9uIG9uIGEgcmVsYXkuXG4gICAqIEBwYXJhbSBldmVudCBSYXcgZXZlbnQgcmVjZWl2ZWQgZnJvbSBhIHJlbGF5XG4gICAqIEBwYXJhbSByZWxheSBSZWxheSB0aGF0IHNlbnQgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBvcHRpbWlzdGljUHVibGlzaCBXaGV0aGVyIHRoZSBldmVudCBpcyBjb21pbmcgZnJvbSBhbiBvcHRpbWlzdGljIHB1Ymxpc2hcbiAgICovXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnQsIHJlbGF5LCBvcHRpbWlzdGljUHVibGlzaCA9IGZhbHNlKSB7XG4gICAgaWYgKHJlbGF5KSB0aGlzLnNlZW5FdmVudChldmVudC5pZCwgcmVsYXkpO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMudmFsdWVzKCk7XG4gICAgY29uc3QgbWF0Y2hpbmdTdWJzID0gW107XG4gICAgZm9yIChjb25zdCBzdWIgb2Ygc3Vic2NyaXB0aW9ucykge1xuICAgICAgaWYgKG1hdGNoRmlsdGVycyhzdWIuZmlsdGVycywgZXZlbnQpKSB7XG4gICAgICAgIG1hdGNoaW5nU3Vicy5wdXNoKHN1Yik7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3ViIG9mIG1hdGNoaW5nU3Vicykge1xuICAgICAgc3ViLmV2ZW50UmVjZWl2ZWQoZXZlbnQsIHJlbGF5LCBmYWxzZSwgb3B0aW1pc3RpY1B1Ymxpc2gpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL25kay9hY3RpdmUtdXNlci50c1xuaW1wb3J0IGNyZWF0ZURlYnVnMyBmcm9tIFwiZGVidWdcIjtcbnZhciBkZWJ1ZzYgPSBjcmVhdGVEZWJ1ZzMoXCJuZGs6YWN0aXZlLXVzZXJcIik7XG5hc3luYyBmdW5jdGlvbiBnZXRVc2VyUmVsYXlMaXN0KHVzZXIpIHtcbiAgaWYgKCF0aGlzLmF1dG9Db25uZWN0VXNlclJlbGF5cykgcmV0dXJuO1xuICBjb25zdCB1c2VyUmVsYXlzID0gYXdhaXQgZ2V0UmVsYXlMaXN0Rm9yVXNlcih1c2VyLnB1YmtleSwgdGhpcyk7XG4gIGlmICghdXNlclJlbGF5cykgcmV0dXJuO1xuICBmb3IgKGNvbnN0IHVybCBvZiB1c2VyUmVsYXlzLnJlbGF5cykge1xuICAgIGxldCByZWxheSA9IHRoaXMucG9vbC5yZWxheXMuZ2V0KHVybCk7XG4gICAgaWYgKCFyZWxheSkge1xuICAgICAgcmVsYXkgPSBuZXcgTkRLUmVsYXkodXJsLCB0aGlzLnJlbGF5QXV0aERlZmF1bHRQb2xpY3ksIHRoaXMpO1xuICAgICAgdGhpcy5wb29sLmFkZFJlbGF5KHJlbGF5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVzZXJSZWxheXM7XG59XG5hc3luYyBmdW5jdGlvbiBzZXRBY3RpdmVVc2VyKHVzZXIpIHtcbiAgY29uc3QgcG9vbCA9IHRoaXMub3V0Ym94UG9vbCB8fCB0aGlzLnBvb2w7XG4gIGlmIChwb29sLmNvbm5lY3RlZFJlbGF5cy5sZW5ndGggPiAwKSB7XG4gICAgc2V0QWN0aXZlVXNlckNvbm5lY3RlZC5jYWxsKHRoaXMsIHVzZXIpO1xuICB9IGVsc2Uge1xuICAgIHBvb2wub25jZShcImNvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgc2V0QWN0aXZlVXNlckNvbm5lY3RlZC5jYWxsKHRoaXMsIHVzZXIpO1xuICAgIH0pO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBzZXRBY3RpdmVVc2VyQ29ubmVjdGVkKHVzZXIpIHtcbiAgY29uc3QgdXNlclJlbGF5cyA9IGF3YWl0IGdldFVzZXJSZWxheUxpc3QuY2FsbCh0aGlzLCB1c2VyKTtcbiAgY29uc3QgZmlsdGVycyA9IFtcbiAgICB7XG4gICAgICBraW5kczogWzEwMDA2IC8qIEJsb2NrUmVsYXlMaXN0ICovXSxcbiAgICAgIGF1dGhvcnM6IFt1c2VyLnB1YmtleV1cbiAgICB9XG4gIF07XG4gIGlmICh0aGlzLmF1dG9GZXRjaFVzZXJNdXRlbGlzdCkge1xuICAgIGZpbHRlcnNbMF0ua2luZHM/LnB1c2goMWU0IC8qIE11dGVMaXN0ICovKTtcbiAgfVxuICBjb25zdCBldmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCByZWxheVNldCA9IHVzZXJSZWxheXMgPyB1c2VyUmVsYXlzLnJlbGF5U2V0IDogdm9pZCAwO1xuICB0aGlzLnN1YnNjcmliZShcbiAgICBmaWx0ZXJzLFxuICAgIHsgc3ViSWQ6IFwiYWN0aXZlLXVzZXItc2V0dGluZ3NcIiwgY2xvc2VPbkVvc2U6IHRydWUsIHJlbGF5U2V0IH0sXG4gICAge1xuICAgICAgb25FdmVudDogKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZFdmVudCA9IGV2ZW50cy5nZXQoZXZlbnQua2luZCk7XG4gICAgICAgIGlmIChwcmV2RXZlbnQgJiYgcHJldkV2ZW50LmNyZWF0ZWRfYXQgPj0gZXZlbnQuY3JlYXRlZF9hdCkgcmV0dXJuO1xuICAgICAgICBldmVudHMuc2V0KGV2ZW50LmtpbmQsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBvbkVvc2U6ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMudmFsdWVzKCkpIHtcbiAgICAgICAgICBwcm9jZXNzRXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzRXZlbnQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmtpbmQgPT09IDEwMDA2IC8qIEJsb2NrUmVsYXlMaXN0ICovKSB7XG4gICAgcHJvY2Vzc0Jsb2NrUmVsYXlMaXN0LmNhbGwodGhpcywgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGV2ZW50LmtpbmQgPT09IDFlNCAvKiBNdXRlTGlzdCAqLykge1xuICAgIHByb2Nlc3NNdXRlTGlzdC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrUmVsYXlMaXN0KGV2ZW50KSB7XG4gIGNvbnN0IGxpc3QgPSBsaXN0c19kZWZhdWx0LmZyb20oZXZlbnQpO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgbGlzdC5pdGVtcykge1xuICAgIHRoaXMucG9vbC5ibGFja2xpc3RSZWxheVVybHMuYWRkKGl0ZW1bMF0pO1xuICB9XG4gIGRlYnVnNihcIkFkZGVkICVkIHJlbGF5cyB0byByZWxheSBibGFja2xpc3RcIiwgbGlzdC5pdGVtcy5sZW5ndGgpO1xufVxuZnVuY3Rpb24gcHJvY2Vzc011dGVMaXN0KG11dGVMaXN0KSB7XG4gIGNvbnN0IGxpc3QgPSBsaXN0c19kZWZhdWx0LmZyb20obXV0ZUxpc3QpO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgbGlzdC5pdGVtcykge1xuICAgIHRoaXMubXV0ZWRJZHMuc2V0KGl0ZW1bMV0sIGl0ZW1bMF0pO1xuICB9XG4gIGRlYnVnNihcIkFkZGVkICVkIHVzZXJzIHRvIG11dGUgbGlzdFwiLCBsaXN0Lml0ZW1zLmxlbmd0aCk7XG59XG5cbi8vIHNyYy9uZGsvZW50aXR5LnRzXG5pbXBvcnQgeyBuaXAxOSBhcyBuaXAxOTcgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbmZ1bmN0aW9uIGdldEVudGl0eShlbnRpdHkpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkZWNvZGVkID0gbmlwMTk3LmRlY29kZShlbnRpdHkpO1xuICAgIGlmIChkZWNvZGVkLnR5cGUgPT09IFwibnB1YlwiKSByZXR1cm4gbnB1Yih0aGlzLCBkZWNvZGVkLmRhdGEpO1xuICAgIGlmIChkZWNvZGVkLnR5cGUgPT09IFwibnByb2ZpbGVcIikgcmV0dXJuIG5wcm9maWxlKHRoaXMsIGRlY29kZWQuZGF0YSk7XG4gICAgcmV0dXJuIGRlY29kZWQ7XG4gIH0gY2F0Y2ggKF9lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIG5wdWIobmRrLCBwdWJrZXkpIHtcbiAgcmV0dXJuIG5kay5nZXRVc2VyKHsgcHVia2V5IH0pO1xufVxuZnVuY3Rpb24gbnByb2ZpbGUobmRrLCBwcm9maWxlKSB7XG4gIGNvbnN0IHVzZXIgPSBuZGsuZ2V0VXNlcih7IHB1YmtleTogcHJvZmlsZS5wdWJrZXkgfSk7XG4gIGlmIChwcm9maWxlLnJlbGF5cykgdXNlci5yZWxheVVybHMgPSBwcm9maWxlLnJlbGF5cztcbiAgcmV0dXJuIHVzZXI7XG59XG5cbi8vIHNyYy9uZGsvZmV0Y2gtZXZlbnQtZnJvbS10YWcudHNcbmZ1bmN0aW9uIGlzVmFsaWRIaW50KGhpbnQpIHtcbiAgaWYgKCFoaW50IHx8IGhpbnQgPT09IFwiXCIpIHJldHVybiBmYWxzZTtcbiAgdHJ5IHtcbiAgICBuZXcgVVJMKGhpbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChfZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hFdmVudEZyb21UYWcodGFnLCBvcmlnaW5hbEV2ZW50LCBzdWJPcHRzLCBmYWxsYmFjayA9IHtcbiAgdHlwZTogXCJ0aW1lb3V0XCJcbn0pIHtcbiAgY29uc3QgZDQgPSB0aGlzLmRlYnVnLmV4dGVuZChcImZldGNoLWV2ZW50LWZyb20tdGFnXCIpO1xuICBjb25zdCBbXywgaWQsIGhpbnRdID0gdGFnO1xuICBzdWJPcHRzID0ge307XG4gIGQ0KFwiZmV0Y2hpbmcgZXZlbnQgZnJvbSB0YWdcIiwgdGFnLCBzdWJPcHRzLCBmYWxsYmFjayk7XG4gIGNvbnN0IGF1dGhvclJlbGF5cyA9IGdldFJlbGF5c0ZvclN5bmModGhpcywgb3JpZ2luYWxFdmVudC5wdWJrZXkpO1xuICBpZiAoYXV0aG9yUmVsYXlzICYmIGF1dGhvclJlbGF5cy5zaXplID4gMCkge1xuICAgIGQ0KFwiZmV0Y2hpbmcgZXZlbnQgZnJvbSBhdXRob3IgcmVsYXlzICVvXCIsIEFycmF5LmZyb20oYXV0aG9yUmVsYXlzKSk7XG4gICAgY29uc3QgcmVsYXlTZXQyID0gTkRLUmVsYXlTZXQuZnJvbVJlbGF5VXJscyhBcnJheS5mcm9tKGF1dGhvclJlbGF5cyksIHRoaXMpO1xuICAgIGNvbnN0IGV2ZW50MiA9IGF3YWl0IHRoaXMuZmV0Y2hFdmVudChpZCwgc3ViT3B0cywgcmVsYXlTZXQyKTtcbiAgICBpZiAoZXZlbnQyKSByZXR1cm4gZXZlbnQyO1xuICB9IGVsc2Uge1xuICAgIGQ0KFwibm8gYXV0aG9yIHJlbGF5cyBmb3VuZCBmb3IgJXNcIiwgb3JpZ2luYWxFdmVudC5wdWJrZXksIG9yaWdpbmFsRXZlbnQpO1xuICB9XG4gIGNvbnN0IHJlbGF5U2V0ID0gY2FsY3VsYXRlUmVsYXlTZXRzRnJvbUZpbHRlcnModGhpcywgW3sgaWRzOiBbaWRdIH1dLCB0aGlzLnBvb2wpO1xuICBkNChcImZldGNoaW5nIGV2ZW50IHdpdGhvdXQgcmVsYXkgaGludFwiLCByZWxheVNldCk7XG4gIGNvbnN0IGV2ZW50ID0gYXdhaXQgdGhpcy5mZXRjaEV2ZW50KGlkLCBzdWJPcHRzKTtcbiAgaWYgKGV2ZW50KSByZXR1cm4gZXZlbnQ7XG4gIGlmIChoaW50ICYmIGhpbnQgIT09IFwiXCIpIHtcbiAgICBjb25zdCBldmVudDIgPSBhd2FpdCB0aGlzLmZldGNoRXZlbnQoaWQsIHN1Yk9wdHMsIHRoaXMucG9vbC5nZXRSZWxheShoaW50LCB0cnVlLCB0cnVlLCBbeyBpZHM6IFtpZF0gfV0pKTtcbiAgICBpZiAoZXZlbnQyKSByZXR1cm4gZXZlbnQyO1xuICB9XG4gIGxldCByZXN1bHQgPSB2b2lkIDA7XG4gIGNvbnN0IHJlbGF5ID0gaXNWYWxpZEhpbnQoaGludCkgPyB0aGlzLnBvb2wuZ2V0UmVsYXkoaGludCwgZmFsc2UsIHRydWUsIFt7IGlkczogW2lkXSB9XSkgOiB2b2lkIDA7XG4gIGNvbnN0IGZldGNoTWF5YmVXaXRoUmVsYXlIaW50ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICB0aGlzLmZldGNoRXZlbnQoaWQsIHN1Yk9wdHMsIHJlbGF5KS50aGVuKHJlc29sdmUpO1xuICB9KTtcbiAgaWYgKCFpc1ZhbGlkSGludChoaW50KSB8fCBmYWxsYmFjay50eXBlID09PSBcIm5vbmVcIikge1xuICAgIHJldHVybiBmZXRjaE1heWJlV2l0aFJlbGF5SGludDtcbiAgfVxuICBjb25zdCBmYWxsYmFja0ZldGNoUHJvbWlzZSA9IG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgZmFsbGJhY2tSZWxheVNldCA9IGZhbGxiYWNrLnJlbGF5U2V0O1xuICAgIGNvbnN0IHRpbWVvdXQgPSBmYWxsYmFjay50aW1lb3V0ID8/IDE1MDA7XG4gICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZTIpID0+IHNldFRpbWVvdXQocmVzb2x2ZTIsIHRpbWVvdXQpKTtcbiAgICBpZiAoZmFsbGJhY2sudHlwZSA9PT0gXCJ0aW1lb3V0XCIpIGF3YWl0IHRpbWVvdXRQcm9taXNlO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZDQoXCJmYWxsYmFjayBmZXRjaCB0cmlnZ2VyZWRcIik7XG4gICAgICBjb25zdCBmYWxsYmFja0V2ZW50ID0gYXdhaXQgdGhpcy5mZXRjaEV2ZW50KGlkLCBzdWJPcHRzLCBmYWxsYmFja1JlbGF5U2V0KTtcbiAgICAgIHJlc29sdmUoZmFsbGJhY2tFdmVudCk7XG4gICAgfVxuICB9KTtcbiAgc3dpdGNoIChmYWxsYmFjay50eXBlKSB7XG4gICAgY2FzZSBcInRpbWVvdXRcIjpcbiAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2ZldGNoTWF5YmVXaXRoUmVsYXlIaW50LCBmYWxsYmFja0ZldGNoUHJvbWlzZV0pO1xuICAgIGNhc2UgXCJlb3NlXCI6XG4gICAgICByZXN1bHQgPSBhd2FpdCBmZXRjaE1heWJlV2l0aFJlbGF5SGludDtcbiAgICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICByZXR1cm4gZmFsbGJhY2tGZXRjaFByb21pc2U7XG4gIH1cbn1cblxuLy8gc3JjL25kay9xdWV1ZS9pbmRleC50c1xudmFyIFF1ZXVlID0gY2xhc3Mge1xuICBxdWV1ZSA9IFtdO1xuICBtYXhDb25jdXJyZW5jeTtcbiAgcHJvY2Vzc2luZyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHByb21pc2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IoX25hbWUsIG1heENvbmN1cnJlbmN5KSB7XG4gICAgdGhpcy5tYXhDb25jdXJyZW5jeSA9IG1heENvbmN1cnJlbmN5O1xuICB9XG4gIGFkZChpdGVtKSB7XG4gICAgaWYgKHRoaXMucHJvbWlzZXMuaGFzKGl0ZW0uaWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9taXNlcy5nZXQoaXRlbS5pZCk7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goe1xuICAgICAgICAuLi5pdGVtLFxuICAgICAgICBmdW5jOiAoKSA9PiBpdGVtLmZ1bmMoKS50aGVuKFxuICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9jZXNzKCk7XG4gICAgfSk7XG4gICAgdGhpcy5wcm9taXNlcy5zZXQoaXRlbS5pZCwgcHJvbWlzZSk7XG4gICAgcHJvbWlzZS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMucHJvbWlzZXMuZGVsZXRlKGl0ZW0uaWQpO1xuICAgICAgdGhpcy5wcm9jZXNzaW5nLmRlbGV0ZShpdGVtLmlkKTtcbiAgICAgIHRoaXMucHJvY2VzcygpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIHByb2Nlc3MoKSB7XG4gICAgaWYgKHRoaXMucHJvY2Vzc2luZy5zaXplID49IHRoaXMubWF4Q29uY3VycmVuY3kgfHwgdGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICBpZiAoIWl0ZW0gfHwgdGhpcy5wcm9jZXNzaW5nLmhhcyhpdGVtLmlkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NpbmcuYWRkKGl0ZW0uaWQpO1xuICAgIGl0ZW0uZnVuYygpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgfVxuICBjbGVhclByb2Nlc3NpbmcoKSB7XG4gICAgdGhpcy5wcm9jZXNzaW5nLmNsZWFyKCk7XG4gIH1cbiAgY2xlYXJBbGwoKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMuY2xlYXJQcm9jZXNzaW5nKCk7XG4gIH1cbiAgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlLmxlbmd0aDtcbiAgfVxufTtcblxuLy8gc3JjL25kay9pbmRleC50c1xudmFyIERFRkFVTFRfT1VUQk9YX1JFTEFZUyA9IFtcIndzczovL3B1cnBsZXBhZy5lcy9cIiwgXCJ3c3M6Ly9ub3MubG9sL1wiXTtcbnZhciBERUZBVUxUX0JMQUNLTElTVEVEX1JFTEFZUyA9IFtcbiAgXCJ3c3M6Ly9icmIuaW8vXCIsXG4gIC8vIEJSQlxuICBcIndzczovL25vc3RyLm11dGlueXdhbGxldC5jb20vXCJcbiAgLy8gRG9uJ3QgdHJ5IHRvIHJlYWQgZnJvbSB0aGlzIHJlbGF5IHNpbmNlIGl0J3MgYSB3cml0ZS1vbmx5IHJlbGF5XG4gIC8vIFwid3NzOi8vcHVycGxlcGFnLmVzL1wiLCAvLyBUaGlzIGlzIGEgaGFjaywgc2luY2UgdGhpcyBpcyBhIG1vc3RseSByZWFkLW9ubHkgcmVsYXksIGJ1dCBub3QgZnVsbHkuIE9uY2Ugd2UgaGF2ZSByZWxheSByb3V0aW5nIHRoaXMgY2FuIGJlIHJlbW92ZWQgc28gaXQgb25seSByZWNlaXZlcyB0aGUgc3VwcG9ydGVkIGtpbmRzXG5dO1xudmFyIE5ESyA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyOCB7XG4gIF9leHBsaWNpdFJlbGF5VXJscztcbiAgYmxhY2tsaXN0UmVsYXlVcmxzO1xuICBwb29sO1xuICBvdXRib3hQb29sO1xuICBfc2lnbmVyO1xuICBfYWN0aXZlVXNlcjtcbiAgY2FjaGVBZGFwdGVyO1xuICBkZWJ1ZztcbiAgZGV2V3JpdGVSZWxheVNldDtcbiAgb3V0Ym94VHJhY2tlcjtcbiAgbXV0ZWRJZHM7XG4gIGNsaWVudE5hbWU7XG4gIGNsaWVudE5pcDg5O1xuICBxdWV1ZXNaYXBDb25maWc7XG4gIHF1ZXVlc05pcDA1O1xuICBhc3luY1NpZ1ZlcmlmaWNhdGlvbiA9IGZhbHNlO1xuICBpbml0aWFsVmFsaWRhdGlvblJhdGlvID0gMTtcbiAgbG93ZXN0VmFsaWRhdGlvblJhdGlvID0gMTtcbiAgdmFsaWRhdGlvblJhdGlvRm47XG4gIHN1Yk1hbmFnZXI7XG4gIHB1Ymxpc2hpbmdGYWlsdXJlSGFuZGxlZCA9IGZhbHNlO1xuICBwb29scyA9IFtdO1xuICAvKipcbiAgICogRGVmYXVsdCByZWxheS1hdXRoIHBvbGljeSB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIGEgcmVsYXkgcmVxdWVzdHMgYXV0aGVudGljYXRpb24sXG4gICAqIGlmIG5vIG90aGVyIHBvbGljeSBpcyBzcGVjaWZpZWQgZm9yIHRoYXQgcmVsYXkuXG4gICAqXG4gICAqIEBleGFtcGxlIERpc2Nvbm5lY3QgZnJvbSByZWxheXMgdGhhdCByZXF1ZXN0IGF1dGhlbnRpY2F0aW9uOlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIG5kay5yZWxheUF1dGhEZWZhdWx0UG9saWN5ID0gTkRLQXV0aFBvbGljaWVzLmRpc2Nvbm5lY3QobmRrLnBvb2wpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGUgU2lnbiBpbiB0byByZWxheXMgdGhhdCByZXF1ZXN0IGF1dGhlbnRpY2F0aW9uOlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIG5kay5yZWxheUF1dGhEZWZhdWx0UG9saWN5ID0gTkRLQXV0aFBvbGljaWVzLnNpZ25Jbih7bmRrfSlcbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlIFNpZ24gaW4gdG8gcmVsYXlzIHRoYXQgcmVxdWVzdCBhdXRoZW50aWNhdGlvbiwgYXNraW5nIHRoZSB1c2VyIGZvciBjb25maXJtYXRpb246XG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogbmRrLnJlbGF5QXV0aERlZmF1bHRQb2xpY3kgPSAocmVsYXk6IE5ES1JlbGF5KSA9PiB7XG4gICAqICAgICBjb25zdCBzaWduSW4gPSBOREtBdXRoUG9saWNpZXMuc2lnbkluKHtuZGt9KTtcbiAgICogICAgIGlmIChjb25maXJtKGBSZWxheSAke3JlbGF5LnVybH0gaXMgcmVxdWVzdGluZyBhdXRoZW50aWNhdGlvbiwgZG8geW91IHdhbnQgdG8gc2lnbiBpbj9gKSkge1xuICAgKiAgICAgICAgc2lnbkluKHJlbGF5KTtcbiAgICogICAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIHJlbGF5QXV0aERlZmF1bHRQb2xpY3k7XG4gIC8qKlxuICAgKiBGZXRjaCBmdW5jdGlvbiB0byB1c2UgZm9yIEhUVFAgcmVxdWVzdHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogaW1wb3J0IGZldGNoIGZyb20gXCJub2RlLWZldGNoXCI7XG4gICAqXG4gICAqIG5kay5odHRwRmV0Y2ggPSBmZXRjaDtcbiAgICogYGBgXG4gICAqL1xuICBodHRwRmV0Y2g7XG4gIC8qKlxuICAgKiBQcm92aWRlIGEgY2FsbGVyIGZ1bmN0aW9uIHRvIHJlY2VpdmUgYWxsIG5ldHdvcmtpbmcgdHJhZmZpYyBmcm9tIHJlbGF5c1xuICAgKi9cbiAgbmV0RGVidWc7XG4gIGF1dG9Db25uZWN0VXNlclJlbGF5cyA9IHRydWU7XG4gIGF1dG9GZXRjaFVzZXJNdXRlbGlzdCA9IHRydWU7XG4gIHdhbGxldENvbmZpZztcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRlYnVnID0gb3B0cy5kZWJ1ZyB8fCBkZWJ1ZzcoXCJuZGtcIik7XG4gICAgdGhpcy5uZXREZWJ1ZyA9IG9wdHMubmV0RGVidWc7XG4gICAgdGhpcy5fZXhwbGljaXRSZWxheVVybHMgPSBvcHRzLmV4cGxpY2l0UmVsYXlVcmxzIHx8IFtdO1xuICAgIHRoaXMuYmxhY2tsaXN0UmVsYXlVcmxzID0gb3B0cy5ibGFja2xpc3RSZWxheVVybHMgfHwgREVGQVVMVF9CTEFDS0xJU1RFRF9SRUxBWVM7XG4gICAgdGhpcy5zdWJNYW5hZ2VyID0gbmV3IE5ES1N1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgICB0aGlzLnBvb2wgPSBuZXcgTkRLUG9vbChvcHRzLmV4cGxpY2l0UmVsYXlVcmxzIHx8IFtdLCBbXSwgdGhpcyk7XG4gICAgdGhpcy5wb29sLm5hbWUgPSBcIk1haW5cIjtcbiAgICB0aGlzLnBvb2wub24oXCJyZWxheTphdXRoXCIsIGFzeW5jIChyZWxheSwgY2hhbGxlbmdlKSA9PiB7XG4gICAgICBpZiAodGhpcy5yZWxheUF1dGhEZWZhdWx0UG9saWN5KSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVsYXlBdXRoRGVmYXVsdFBvbGljeShyZWxheSwgY2hhbGxlbmdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmF1dG9Db25uZWN0VXNlclJlbGF5cyA9IG9wdHMuYXV0b0Nvbm5lY3RVc2VyUmVsYXlzID8/IHRydWU7XG4gICAgdGhpcy5hdXRvRmV0Y2hVc2VyTXV0ZWxpc3QgPSBvcHRzLmF1dG9GZXRjaFVzZXJNdXRlbGlzdCA/PyB0cnVlO1xuICAgIHRoaXMuY2xpZW50TmFtZSA9IG9wdHMuY2xpZW50TmFtZTtcbiAgICB0aGlzLmNsaWVudE5pcDg5ID0gb3B0cy5jbGllbnROaXA4OTtcbiAgICB0aGlzLnJlbGF5QXV0aERlZmF1bHRQb2xpY3kgPSBvcHRzLnJlbGF5QXV0aERlZmF1bHRQb2xpY3k7XG4gICAgaWYgKG9wdHMuZW5hYmxlT3V0Ym94TW9kZWwpIHtcbiAgICAgIHRoaXMub3V0Ym94UG9vbCA9IG5ldyBOREtQb29sKG9wdHMub3V0Ym94UmVsYXlVcmxzIHx8IERFRkFVTFRfT1VUQk9YX1JFTEFZUywgW10sIHRoaXMsIHtcbiAgICAgICAgZGVidWc6IHRoaXMuZGVidWcuZXh0ZW5kKFwib3V0Ym94LXBvb2xcIiksXG4gICAgICAgIG5hbWU6IFwiT3V0Ym94IFBvb2xcIlxuICAgICAgfSk7XG4gICAgICB0aGlzLm91dGJveFRyYWNrZXIgPSBuZXcgT3V0Ym94VHJhY2tlcih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5zaWduZXIgPSBvcHRzLnNpZ25lcjtcbiAgICB0aGlzLmNhY2hlQWRhcHRlciA9IG9wdHMuY2FjaGVBZGFwdGVyO1xuICAgIHRoaXMubXV0ZWRJZHMgPSBvcHRzLm11dGVkSWRzIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKG9wdHMuZGV2V3JpdGVSZWxheVVybHMpIHtcbiAgICAgIHRoaXMuZGV2V3JpdGVSZWxheVNldCA9IE5ES1JlbGF5U2V0LmZyb21SZWxheVVybHMob3B0cy5kZXZXcml0ZVJlbGF5VXJscywgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMucXVldWVzWmFwQ29uZmlnID0gbmV3IFF1ZXVlKFwiemFwc1wiLCAzKTtcbiAgICB0aGlzLnF1ZXVlc05pcDA1ID0gbmV3IFF1ZXVlKFwibmlwMDVcIiwgMTApO1xuICAgIHRoaXMuc2lnbmF0dXJlVmVyaWZpY2F0aW9uV29ya2VyID0gb3B0cy5zaWduYXR1cmVWZXJpZmljYXRpb25Xb3JrZXI7XG4gICAgdGhpcy5pbml0aWFsVmFsaWRhdGlvblJhdGlvID0gb3B0cy5pbml0aWFsVmFsaWRhdGlvblJhdGlvIHx8IDE7XG4gICAgdGhpcy5sb3dlc3RWYWxpZGF0aW9uUmF0aW8gPSBvcHRzLmxvd2VzdFZhbGlkYXRpb25SYXRpbyB8fCAxO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmh0dHBGZXRjaCA9IGZldGNoO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICBzZXQgZXhwbGljaXRSZWxheVVybHModXJscykge1xuICAgIHRoaXMuX2V4cGxpY2l0UmVsYXlVcmxzID0gdXJscy5tYXAobm9ybWFsaXplUmVsYXlVcmwpO1xuICAgIHRoaXMucG9vbC5yZWxheVVybHMgPSB1cmxzO1xuICB9XG4gIGdldCBleHBsaWNpdFJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy5fZXhwbGljaXRSZWxheVVybHMgfHwgW107XG4gIH1cbiAgc2V0IHNpZ25hdHVyZVZlcmlmaWNhdGlvbldvcmtlcih3b3JrZXIyKSB7XG4gICAgdGhpcy5hc3luY1NpZ1ZlcmlmaWNhdGlvbiA9ICEhd29ya2VyMjtcbiAgICBpZiAod29ya2VyMikge1xuICAgICAgc2lnbmF0dXJlVmVyaWZpY2F0aW9uSW5pdCh3b3JrZXIyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gZXhwbGljaXQgcmVsYXkgdG8gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSB1cmxcbiAgICogQHBhcmFtIHJlbGF5QXV0aFBvbGljeSBBdXRoZW50aWNhdGlvbiBwb2xpY3kgdG8gdXNlIGlmIGRpZmZlcmVudCBmcm9tIHRoZSBkZWZhdWx0XG4gICAqIEBwYXJhbSBjb25uZWN0IFdoZXRoZXIgdG8gY29ubmVjdCB0byB0aGUgcmVsYXkgYXV0b21hdGljYWxseVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYWRkRXhwbGljaXRSZWxheSh1cmxPclJlbGF5LCByZWxheUF1dGhQb2xpY3ksIGNvbm5lY3QgPSB0cnVlKSB7XG4gICAgbGV0IHJlbGF5O1xuICAgIGlmICh0eXBlb2YgdXJsT3JSZWxheSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVsYXkgPSBuZXcgTkRLUmVsYXkodXJsT3JSZWxheSwgcmVsYXlBdXRoUG9saWN5LCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVsYXkgPSB1cmxPclJlbGF5O1xuICAgIH1cbiAgICB0aGlzLnBvb2wuYWRkUmVsYXkocmVsYXksIGNvbm5lY3QpO1xuICAgIHRoaXMuZXhwbGljaXRSZWxheVVybHM/LnB1c2gocmVsYXkudXJsKTtcbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7IHJlbGF5Q291bnQ6IHRoaXMucG9vbC5yZWxheXMuc2l6ZSB9LnRvU3RyaW5nKCk7XG4gIH1cbiAgZ2V0IGFjdGl2ZVVzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVVzZXI7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFjdGl2ZSB1c2VyIGZvciB0aGlzIE5ESyBpbnN0YW5jZSwgdHlwaWNhbGx5IHRoaXMgd2lsbCBiZVxuICAgKiBjYWxsZWQgd2hlbiBhc3NpZ25pbmcgYSBzaWduZXIgdG8gdGhlIE5ESyBpbnN0YW5jZS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgY29ubmVjdCB0byB0aGUgdXNlcidzIHJlbGF5cyBpZlxuICAgKiBgYXV0b0Nvbm5lY3RVc2VyUmVsYXlzYCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICpcbiAgICogSXQgd2lsbCBhbHNvIGZldGNoIHRoZSB1c2VyJ3MgbXV0ZWxpc3QgaWYgYGF1dG9GZXRjaFVzZXJNdXRlbGlzdGAgaXMgc2V0IHRvIHRydWUuXG4gICAqL1xuICBzZXQgYWN0aXZlVXNlcih1c2VyKSB7XG4gICAgY29uc3QgZGlmZmVyZW50VXNlciA9IHRoaXMuX2FjdGl2ZVVzZXI/LnB1YmtleSAhPT0gdXNlcj8ucHVia2V5O1xuICAgIHRoaXMuX2FjdGl2ZVVzZXIgPSB1c2VyO1xuICAgIGlmICh1c2VyICYmIGRpZmZlcmVudFVzZXIpIHtcbiAgICAgIHNldEFjdGl2ZVVzZXIuY2FsbCh0aGlzLCB1c2VyKTtcbiAgICB9IGVsc2UgaWYgKCF1c2VyKSB7XG4gICAgICB0aGlzLm11dGVkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNpZ25lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lnbmVyO1xuICB9XG4gIHNldCBzaWduZXIobmV3U2lnbmVyKSB7XG4gICAgdGhpcy5fc2lnbmVyID0gbmV3U2lnbmVyO1xuICAgIGlmIChuZXdTaWduZXIpIHRoaXMuZW1pdChcInNpZ25lcjpyZWFkeVwiLCBuZXdTaWduZXIpO1xuICAgIG5ld1NpZ25lcj8udXNlcigpLnRoZW4oKHVzZXIpID0+IHtcbiAgICAgIHVzZXIubmRrID0gdGhpcztcbiAgICAgIHRoaXMuYWN0aXZlVXNlciA9IHVzZXI7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3QgdG8gcmVsYXlzIHdpdGggb3B0aW9uYWwgdGltZW91dC5cbiAgICogSWYgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZCwgdGhlIGNvbm5lY3Rpb24gd2lsbCBiZSBjb250aW51ZWQgdG8gYmUgZXN0YWJsaXNoZWQgaW4gdGhlIGJhY2tncm91bmQuXG4gICAqL1xuICBhc3luYyBjb25uZWN0KHRpbWVvdXRNcykge1xuICAgIGlmICh0aGlzLl9zaWduZXIgJiYgdGhpcy5hdXRvQ29ubmVjdFVzZXJSZWxheXMpIHtcbiAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgIFwiQXR0ZW1wdGluZyB0byBjb25uZWN0IHRvIHVzZXIgcmVsYXlzIHNwZWNpZmllZCBieSBzaWduZXIgJW9cIixcbiAgICAgICAgYXdhaXQgdGhpcy5fc2lnbmVyLnJlbGF5cz8uKHRoaXMpXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuX3NpZ25lci5yZWxheXMpIHtcbiAgICAgICAgY29uc3QgcmVsYXlzID0gYXdhaXQgdGhpcy5fc2lnbmVyLnJlbGF5cyh0aGlzKTtcbiAgICAgICAgcmVsYXlzLmZvckVhY2goKHJlbGF5KSA9PiB0aGlzLnBvb2wuYWRkUmVsYXkocmVsYXkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvbnMgPSBbdGhpcy5wb29sLmNvbm5lY3QodGltZW91dE1zKV07XG4gICAgaWYgKHRoaXMub3V0Ym94UG9vbCkge1xuICAgICAgY29ubmVjdGlvbnMucHVzaCh0aGlzLm91dGJveFBvb2wuY29ubmVjdCh0aW1lb3V0TXMpKTtcbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyhcIkNvbm5lY3RpbmcgdG8gcmVsYXlzICVvXCIsIHsgdGltZW91dE1zIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbFNldHRsZWQoY29ubmVjdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBOREtVc2VyIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gb3B0c1xuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0VXNlcihvcHRzKSB7XG4gICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKG9wdHMpO1xuICAgIHVzZXIubmRrID0gdGhpcztcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgTkRLVXNlciBmcm9tIGEgTklQMDVcbiAgICogQHBhcmFtIG5pcDA1IE5JUC0wNSBJRFxuICAgKiBAcGFyYW0gc2tpcENhY2hlIFNraXAgY2FjaGVcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGdldFVzZXJGcm9tTmlwMDUobmlwMDUsIHNraXBDYWNoZSA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIE5ES1VzZXIuZnJvbU5pcDA1KG5pcDA1LCB0aGlzLCBza2lwQ2FjaGUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBzdGFydHMgYSBuZXcgc3Vic2NyaXB0aW9uLlxuICAgKlxuICAgKiBTdWJzY3JpcHRpb25zIGF1dG9tYXRpY2FsbHkgc3RhcnQgdW5sZXNzIGBhdXRvU3RhcnRgIGlzIHNldCB0byBgZmFsc2VgLlxuICAgKiBZb3UgY2FuIGNvbnRyb2wgYXV0b21hdGljIGNsb3Npbmcgb24gRU9TRSB2aWEgYG9wdHMuY2xvc2VPbkVvc2VgLlxuICAgKlxuICAgKiBAcGFyYW0gZmlsdGVycyAtIEEgc2luZ2xlIE5ES0ZpbHRlciBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgZmlsdGVycy5cbiAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25hbCBOREtTdWJzY3JpcHRpb25PcHRpb25zIHRvIGN1c3RvbWl6ZSBiZWhhdmlvciAoZS5nLiwgY2FjaGluZywgZ3JvdXBpbmcpLlxuICAgKiBAcGFyYW0gaGFuZGxlcnMgLSBPcHRpb25hbCBoYW5kbGVycyBmb3Igc3Vic2NyaXB0aW9uIGV2ZW50cy4gUGFzc2luZyBoYW5kbGVycyBpcyB0aGUgcHJlZmVycmVkIG1ldGhvZCBvZiB1c2luZyBuZGsuc3Vic2NyaWJlLlxuICAgKiAgIC0gYG9uRXZlbnRgOiBDYWxsZWQgZm9yIGVhY2ggZXZlbnQgcmVjZWl2ZWQuXG4gICAqICAtIGBvbkV2ZW50c2A6IENhbGxlZCBvbmNlIHdpdGggYW4gYXJyYXkgb2YgZXZlbnRzIHdoZW4gdGhlIHN1YnNjcmlwdGlvbiBzdGFydHMgKGZyb20gdGhlIGNhY2hlKS5cbiAgICogIC0gYG9uRW9zZWA6IENhbGxlZCB3aGVuIHRoZSBzdWJzY3JpcHRpb24gcmVjZWl2ZXMgRU9TRS5cbiAgICogIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgdGhpcyB0aGlyZCBwYXJhbWV0ZXIgYWxzbyBhY2NlcHRzIGEgcmVsYXlTZXQsIHRoZSByZWxheVNldCBzaG91bGQgYmUgcGFzc2VkIHZpYSBgb3B0cy5yZWxheVNldGAuXG4gICAqXG4gICAqIEBwYXJhbSBfYXV0b1N0YXJ0IC0gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB0aGlzIGNhbiBiZSBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIHN0YXJ0IHRoZSBzdWJzY3JpcHRpb24gaW1tZWRpYXRlbHkuXG4gICAqICBUaGlzIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cbiAgICogICAtIGBmYWxzZWA6IENyZWF0ZXMgdGhlIHN1YnNjcmlwdGlvbiBidXQgZG9lcyBub3Qgc3RhcnQgaXQgKGNhbGwgYHN1YnNjcmlwdGlvbi5zdGFydCgpYCBtYW51YWxseSkuXG4gICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIE5ES1N1YnNjcmlwdGlvbiBpbnN0YW5jZS5cbiAgICpcbiAgICogQGV4YW1wbGUgQmFzaWMgc3Vic2NyaXB0aW9uXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3Qgc3ViID0gbmRrLnN1YnNjcmliZSh7IGtpbmRzOiBbMV0sIGF1dGhvcnM6IFtwdWJrZXldIH0pO1xuICAgKiBzdWIub24oXCJldmVudFwiLCAoZXZlbnQpID0+IGNvbnNvbGUubG9nKFwiS2luZCAxIGV2ZW50OlwiLCBldmVudC5jb250ZW50KSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZSBTdWJzY3JpcHRpb24gd2l0aCBvcHRpb25zIGFuZCBkaXJlY3QgaGFuZGxlcnNcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBzdWIgPSBuZGsuc3Vic2NyaWJlKFxuICAgKiAgIHsga2luZHM6IFswXSwgYXV0aG9yczogW3B1YmtleV0gfSxcbiAgICogICB7IGNsb3NlT25Fb3NlOiB0cnVlLCBjYWNoZVVzYWdlOiBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlLlBBUkFMTEVMIH0sXG4gICAqICAgdW5kZWZpbmVkLCAvLyBVc2UgZGVmYXVsdCByZWxheSBzZXQgY2FsY3VsYXRpb25cbiAgICogICB7XG4gICAqICAgICBvbkV2ZW50czogKGV2ZW50cykgPT4geyAvLyBSZW5hbWVkIHBhcmFtZXRlclxuICAgKiAgICAgICBpZiAoZXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICogICAgICAgICBjb25zb2xlLmxvZyhgR290ICR7ZXZlbnRzLmxlbmd0aH0gcHJvZmlsZSBldmVudHMgZnJvbSBjYWNoZTpgLCBldmVudHNbMF0uY29udGVudCk7XG4gICAqICAgICAgIH1cbiAgICogICAgIH0sXG4gICAqICAgICBvbkV2ZW50OiAoZXZlbnQpID0+IHsgLy8gUmVuYW1lZCBwYXJhbWV0ZXJcbiAgICogICAgICAgY29uc29sZS5sb2coXCJHb3QgcHJvZmlsZSB1cGRhdGUgZnJvbSByZWxheTpcIiwgZXZlbnQuY29udGVudCk7IC8vIENsYXJpZmllZCBzb3VyY2VcbiAgICogICAgIH0sXG4gICAqICAgICBvbkVvc2U6ICgpID0+IGNvbnNvbGUubG9nKFwiUHJvZmlsZSBzdWJzY3JpcHRpb24gZmluaXNoZWQuXCIpXG4gICAqICAgfVxuICAgKiApO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHNpbmNlIDIuMTMuMCBgcmVsYXlTZXRgIHBhcmFtZXRlciByZW1vdmVkOyBwYXNzIGByZWxheVNldGAgb3IgYHJlbGF5VXJsc2AgdmlhIGBvcHRzYC5cbiAgICovXG4gIHN1YnNjcmliZShmaWx0ZXJzLCBvcHRzLCBhdXRvU3RhcnRPclJlbGF5U2V0ID0gdHJ1ZSwgX2F1dG9TdGFydCA9IHRydWUpIHtcbiAgICBsZXQgX3JlbGF5U2V0ID0gb3B0cz8ucmVsYXlTZXQ7XG4gICAgbGV0IGF1dG9TdGFydCA9IF9hdXRvU3RhcnQ7XG4gICAgaWYgKGF1dG9TdGFydE9yUmVsYXlTZXQgaW5zdGFuY2VvZiBOREtSZWxheVNldCkge1xuICAgICAgY29uc29sZS53YXJuKFwicmVsYXlTZXQgaXMgZGVwcmVjYXRlZCwgdXNlIG9wdHMucmVsYXlTZXQgaW5zdGVhZC4gVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiB2Mi4xNC4wXCIpO1xuICAgICAgX3JlbGF5U2V0ID0gYXV0b1N0YXJ0T3JSZWxheVNldDtcbiAgICAgIGF1dG9TdGFydCA9IF9hdXRvU3RhcnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXV0b1N0YXJ0T3JSZWxheVNldCA9PT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIGF1dG9TdGFydE9yUmVsYXlTZXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGF1dG9TdGFydCA9IGF1dG9TdGFydE9yUmVsYXlTZXQ7XG4gICAgfVxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG5ldyBOREtTdWJzY3JpcHRpb24odGhpcywgZmlsdGVycywgeyByZWxheVNldDogX3JlbGF5U2V0LCAuLi5vcHRzIH0pO1xuICAgIHRoaXMuc3ViTWFuYWdlci5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICBjb25zdCBwb29sID0gc3Vic2NyaXB0aW9uLnBvb2w7XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5yZWxheVNldCkge1xuICAgICAgZm9yIChjb25zdCByZWxheSBvZiBzdWJzY3JpcHRpb24ucmVsYXlTZXQucmVsYXlzKSB7XG4gICAgICAgIHBvb2wudXNlVGVtcG9yYXJ5UmVsYXkocmVsYXksIHZvaWQgMCwgc3Vic2NyaXB0aW9uLmZpbHRlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5vdXRib3hQb29sICYmIHN1YnNjcmlwdGlvbi5oYXNBdXRob3JzRmlsdGVyKCkpIHtcbiAgICAgIGNvbnN0IGF1dGhvcnMgPSBzdWJzY3JpcHRpb24uZmlsdGVycy5maWx0ZXIoKGZpbHRlcikgPT4gZmlsdGVyLmF1dGhvcnMgJiYgZmlsdGVyLmF1dGhvcnM/Lmxlbmd0aCA+IDApLmZsYXRNYXAoKGZpbHRlcikgPT4gZmlsdGVyLmF1dGhvcnMpO1xuICAgICAgdGhpcy5vdXRib3hUcmFja2VyPy50cmFja1VzZXJzKGF1dGhvcnMpO1xuICAgIH1cbiAgICBpZiAoYXV0b1N0YXJ0KSB7XG4gICAgICBsZXQgZXZlbnRzSGFuZGxlcjtcbiAgICAgIGlmICh0eXBlb2YgYXV0b1N0YXJ0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChhdXRvU3RhcnQub25FdmVudCkgc3Vic2NyaXB0aW9uLm9uKFwiZXZlbnRcIiwgYXV0b1N0YXJ0Lm9uRXZlbnQpO1xuICAgICAgICBpZiAoYXV0b1N0YXJ0Lm9uRW9zZSkgc3Vic2NyaXB0aW9uLm9uKFwiZW9zZVwiLCBhdXRvU3RhcnQub25Fb3NlKTtcbiAgICAgICAgaWYgKGF1dG9TdGFydC5vbkV2ZW50cykgZXZlbnRzSGFuZGxlciA9IGF1dG9TdGFydC5vbkV2ZW50cztcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBjYWNoZWRFdmVudHMgPSBzdWJzY3JpcHRpb24uc3RhcnQoIWV2ZW50c0hhbmRsZXIpO1xuICAgICAgICBpZiAoY2FjaGVkRXZlbnRzICYmIGNhY2hlZEV2ZW50cy5sZW5ndGggPiAwICYmICEhZXZlbnRzSGFuZGxlcikgZXZlbnRzSGFuZGxlcihjYWNoZWRFdmVudHMpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYW4gZXZlbnQgdG8gYSByZWxheVxuICAgKiBAcGFyYW0gZXZlbnQgZXZlbnQgdG8gcHVibGlzaFxuICAgKiBAcGFyYW0gcmVsYXlTZXQgZXhwbGljaXQgcmVsYXkgc2V0IHRvIHVzZVxuICAgKiBAcGFyYW0gdGltZW91dE1zIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIHRoZSBldmVudCB0byBiZSBwdWJsaXNoZWRcbiAgICogQHJldHVybnMgVGhlIHJlbGF5cyB0aGUgZXZlbnQgd2FzIHB1Ymxpc2hlZCB0b1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYGV2ZW50LnB1Ymxpc2goKWAgaW5zdGVhZFxuICAgKi9cbiAgYXN5bmMgcHVibGlzaChldmVudCwgcmVsYXlTZXQsIHRpbWVvdXRNcykge1xuICAgIHRoaXMuZGVidWcoXCJEZXByZWNhdGVkOiBVc2UgYGV2ZW50LnB1Ymxpc2goKWAgaW5zdGVhZFwiKTtcbiAgICByZXR1cm4gZXZlbnQucHVibGlzaChyZWxheVNldCwgdGltZW91dE1zKTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZmV0Y2ggYW4gZXZlbnQgZnJvbSBhIHRhZywgZm9sbG93aW5nIHJlbGF5IGhpbnRzIGFuZFxuICAgKiBvdGhlciBiZXN0IHByYWN0aWNlcy5cbiAgICogQHBhcmFtIHRhZyBUYWcgdG8gZmV0Y2ggdGhlIGV2ZW50IGZyb21cbiAgICogQHBhcmFtIG9yaWdpbmFsRXZlbnQgRXZlbnQgd2hlcmUgdGhlIHRhZyBjYW1lIGZyb21cbiAgICogQHBhcmFtIHN1Yk9wdHMgU3Vic2NyaXB0aW9uIG9wdGlvbnMgdG8gdXNlIHdoZW4gZmV0Y2hpbmcgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBmYWxsYmFjayBGYWxsYmFjayBvcHRpb25zIHRvIHVzZSB3aGVuIHRoZSBoaW50IHJlbGF5IGRvZXNuJ3QgcmVzcG9uZFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZmV0Y2hFdmVudEZyb21UYWcgPSBmZXRjaEV2ZW50RnJvbVRhZy5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogRmV0Y2ggYW4gZXZlbnQgZnJvbSB0aGUgY2FjaGUgc3luY2hyb25vdXNseS5cbiAgICogQHBhcmFtIGlkT3JGaWx0ZXIgZXZlbnQgaWQgaW4gYmVjaDMyIGZvcm1hdCBvciBmaWx0ZXJcbiAgICogQHJldHVybnMgZXZlbnRzIGZyb20gdGhlIGNhY2hlIG9yIG51bGwgaWYgdGhlIGNhY2hlIGlzIGVtcHR5XG4gICAqL1xuICBmZXRjaEV2ZW50U3luYyhpZE9yRmlsdGVyKSB7XG4gICAgaWYgKCF0aGlzLmNhY2hlQWRhcHRlcikgdGhyb3cgbmV3IEVycm9yKFwiQ2FjaGUgYWRhcHRlciBub3Qgc2V0XCIpO1xuICAgIGxldCBmaWx0ZXJzO1xuICAgIGlmICh0eXBlb2YgaWRPckZpbHRlciA9PT0gXCJzdHJpbmdcIikgZmlsdGVycyA9IFtmaWx0ZXJGcm9tSWQoaWRPckZpbHRlcildO1xuICAgIGVsc2UgZmlsdGVycyA9IGlkT3JGaWx0ZXI7XG4gICAgY29uc3Qgc3ViID0gbmV3IE5ES1N1YnNjcmlwdGlvbih0aGlzLCBmaWx0ZXJzKTtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLmNhY2hlQWRhcHRlci5xdWVyeShzdWIpO1xuICAgIGlmIChldmVudHMgaW5zdGFuY2VvZiBQcm9taXNlKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWNoZSBhZGFwdGVyIGlzIGFzeW5jXCIpO1xuICAgIHJldHVybiBldmVudHMubWFwKChlKSA9PiB7XG4gICAgICBlLm5kayA9IHRoaXM7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBzaW5nbGUgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBpZE9yRmlsdGVyIGV2ZW50IGlkIGluIGJlY2gzMiBmb3JtYXQgb3IgZmlsdGVyXG4gICAqIEBwYXJhbSBvcHRzIHN1YnNjcmlwdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSByZWxheVNldE9yUmVsYXkgZXhwbGljaXQgcmVsYXkgc2V0IHRvIHVzZVxuICAgKi9cbiAgYXN5bmMgZmV0Y2hFdmVudChpZE9yRmlsdGVyLCBvcHRzLCByZWxheVNldE9yUmVsYXkpIHtcbiAgICBsZXQgZmlsdGVycztcbiAgICBsZXQgcmVsYXlTZXQ7XG4gICAgaWYgKHJlbGF5U2V0T3JSZWxheSBpbnN0YW5jZW9mIE5ES1JlbGF5KSB7XG4gICAgICByZWxheVNldCA9IG5ldyBOREtSZWxheVNldCgvKiBAX19QVVJFX18gKi8gbmV3IFNldChbcmVsYXlTZXRPclJlbGF5XSksIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAocmVsYXlTZXRPclJlbGF5IGluc3RhbmNlb2YgTkRLUmVsYXlTZXQpIHtcbiAgICAgIHJlbGF5U2V0ID0gcmVsYXlTZXRPclJlbGF5O1xuICAgIH1cbiAgICBpZiAoIXJlbGF5U2V0T3JSZWxheSAmJiB0eXBlb2YgaWRPckZpbHRlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKCFpc05pcDMzQVZhbHVlKGlkT3JGaWx0ZXIpKSB7XG4gICAgICAgIGNvbnN0IHJlbGF5cyA9IHJlbGF5c0Zyb21CZWNoMzIoaWRPckZpbHRlciwgdGhpcyk7XG4gICAgICAgIGlmIChyZWxheXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlbGF5U2V0ID0gbmV3IE5ES1JlbGF5U2V0KG5ldyBTZXQocmVsYXlzKSwgdGhpcyk7XG4gICAgICAgICAgcmVsYXlTZXQgPSBjb3JyZWN0UmVsYXlTZXQocmVsYXlTZXQsIHRoaXMucG9vbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpZE9yRmlsdGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBmaWx0ZXJzID0gW2ZpbHRlckZyb21JZChpZE9yRmlsdGVyKV07XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlkT3JGaWx0ZXIpKSB7XG4gICAgICBmaWx0ZXJzID0gaWRPckZpbHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsdGVycyA9IFtpZE9yRmlsdGVyXTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmlsdGVyOiAke0pTT04uc3RyaW5naWZ5KGlkT3JGaWx0ZXIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxldCBmZXRjaGVkRXZlbnQgPSBudWxsO1xuICAgICAgY29uc3Qgc3Vic2NyaWJlT3B0cyA9IHtcbiAgICAgICAgLi4ub3B0cyB8fCB7fSxcbiAgICAgICAgY2xvc2VPbkVvc2U6IHRydWVcbiAgICAgIH07XG4gICAgICBpZiAocmVsYXlTZXQpIHN1YnNjcmliZU9wdHMucmVsYXlTZXQgPSByZWxheVNldDtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLnN1YnNjcmliZShcbiAgICAgICAgZmlsdGVycyxcbiAgICAgICAgc3Vic2NyaWJlT3B0cyxcbiAgICAgICAgLy8gcmVsYXlTZXQsIC8vIFJlbW92ZWQ6IFBhc3NlZCB2aWEgb3B0c1xuICAgICAgICBmYWxzZVxuICAgICAgICAvLyBhdXRvU3RhcnQgPSBmYWxzZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHQyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHMuc3RvcCgpO1xuICAgICAgICByZXNvbHZlKGZldGNoZWRFdmVudCk7XG4gICAgICB9LCAxZTQpO1xuICAgICAgcy5vbihcImV2ZW50XCIsIChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5uZGsgPSB0aGlzO1xuICAgICAgICBpZiAoIWV2ZW50LmlzUmVwbGFjZWFibGUoKSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0Mik7XG4gICAgICAgICAgcmVzb2x2ZShldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWZldGNoZWRFdmVudCB8fCBmZXRjaGVkRXZlbnQuY3JlYXRlZF9hdCA8IGV2ZW50LmNyZWF0ZWRfYXQpIHtcbiAgICAgICAgICBmZXRjaGVkRXZlbnQgPSBldmVudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0Mik7XG4gICAgICAgIHJlc29sdmUoZmV0Y2hlZEV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgcy5zdGFydCgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBldmVudHNcbiAgICovXG4gIGFzeW5jIGZldGNoRXZlbnRzKGZpbHRlcnMsIG9wdHMsIHJlbGF5U2V0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBldmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3Qgc3Vic2NyaWJlT3B0cyA9IHtcbiAgICAgICAgLi4ub3B0cyB8fCB7fSxcbiAgICAgICAgY2xvc2VPbkVvc2U6IHRydWVcbiAgICAgIH07XG4gICAgICBpZiAocmVsYXlTZXQpIHN1YnNjcmliZU9wdHMucmVsYXlTZXQgPSByZWxheVNldDtcbiAgICAgIGNvbnN0IHJlbGF5U2V0U3Vic2NyaXB0aW9uID0gdGhpcy5zdWJzY3JpYmUoXG4gICAgICAgIGZpbHRlcnMsXG4gICAgICAgIHN1YnNjcmliZU9wdHMsXG4gICAgICAgIC8vIHJlbGF5U2V0LCAvLyBSZW1vdmVkOiBQYXNzZWQgdmlhIG9wdHNcbiAgICAgICAgZmFsc2VcbiAgICAgICAgLy8gYXV0b1N0YXJ0ID0gZmFsc2VcbiAgICAgICk7XG4gICAgICBjb25zdCBvbkV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGxldCBfZXZlbnQ7XG4gICAgICAgIGlmICghKGV2ZW50IGluc3RhbmNlb2YgTkRLRXZlbnQpKSBfZXZlbnQgPSBuZXcgTkRLRXZlbnQodm9pZCAwLCBldmVudCk7XG4gICAgICAgIGVsc2UgX2V2ZW50ID0gZXZlbnQ7XG4gICAgICAgIGNvbnN0IGRlZHVwS2V5ID0gX2V2ZW50LmRlZHVwbGljYXRpb25LZXkoKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdFdmVudCA9IGV2ZW50cy5nZXQoZGVkdXBLZXkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdFdmVudCkge1xuICAgICAgICAgIF9ldmVudCA9IGRlZHVwKGV4aXN0aW5nRXZlbnQsIF9ldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgX2V2ZW50Lm5kayA9IHRoaXM7XG4gICAgICAgIGV2ZW50cy5zZXQoZGVkdXBLZXksIF9ldmVudCk7XG4gICAgICB9O1xuICAgICAgcmVsYXlTZXRTdWJzY3JpcHRpb24ub24oXCJldmVudFwiLCBvbkV2ZW50KTtcbiAgICAgIHJlbGF5U2V0U3Vic2NyaXB0aW9uLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUobmV3IFNldChldmVudHMudmFsdWVzKCkpKTtcbiAgICAgIH0pO1xuICAgICAgcmVsYXlTZXRTdWJzY3JpcHRpb24uc3RhcnQoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IGEgc2lnbmVyIGlzIGF2YWlsYWJsZSB0byBzaWduIGFuIGV2ZW50LlxuICAgKi9cbiAgYXNzZXJ0U2lnbmVyKCkge1xuICAgIGlmICghdGhpcy5zaWduZXIpIHtcbiAgICAgIHRoaXMuZW1pdChcInNpZ25lcjpyZXF1aXJlZFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ25lciByZXF1aXJlZFwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0RW50aXR5ID0gZ2V0RW50aXR5LmJpbmQodGhpcyk7XG4gIHNldCB3YWxsZXQod2FsbGV0KSB7XG4gICAgaWYgKCF3YWxsZXQpIHtcbiAgICAgIHRoaXMud2FsbGV0Q29uZmlnID0gdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLndhbGxldENvbmZpZyA/Pz0ge307XG4gICAgdGhpcy53YWxsZXRDb25maWcubG5QYXkgPSB3YWxsZXQ/LmxuUGF5Py5iaW5kKHdhbGxldCk7XG4gICAgdGhpcy53YWxsZXRDb25maWcuY2FzaHVQYXkgPSB3YWxsZXQ/LmNhc2h1UGF5Py5iaW5kKHdhbGxldCk7XG4gIH1cbn07XG5cbi8vIHNyYy96YXAvaW52b2ljZS50c1xuaW1wb3J0IHsgZGVjb2RlIH0gZnJvbSBcImxpZ2h0LWJvbHQxMS1kZWNvZGVyXCI7XG5mdW5jdGlvbiB6YXBJbnZvaWNlRnJvbUV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwiZGVzY3JpcHRpb25cIilbMF07XG4gIGNvbnN0IGJvbHQxMSA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImJvbHQxMVwiKVswXTtcbiAgbGV0IGRlY29kZWRJbnZvaWNlO1xuICBsZXQgemFwUmVxdWVzdDtcbiAgaWYgKCFkZXNjcmlwdGlvbiB8fCAhYm9sdDExIHx8ICFib2x0MTFbMV0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIGxldCB6YXBSZXF1ZXN0UGF5bG9hZCA9IGRlc2NyaXB0aW9uWzFdO1xuICAgIGlmICh6YXBSZXF1ZXN0UGF5bG9hZC5zdGFydHNXaXRoKFwiJVwiKSkge1xuICAgICAgemFwUmVxdWVzdFBheWxvYWQgPSBkZWNvZGVVUklDb21wb25lbnQoemFwUmVxdWVzdFBheWxvYWQpO1xuICAgIH1cbiAgICBpZiAoemFwUmVxdWVzdFBheWxvYWQgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB6YXBSZXF1ZXN0ID0gSlNPTi5wYXJzZSh6YXBSZXF1ZXN0UGF5bG9hZCk7XG4gICAgZGVjb2RlZEludm9pY2UgPSBkZWNvZGUoYm9sdDExWzFdKTtcbiAgfSBjYXRjaCAoX2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBhbW91bnRTZWN0aW9uID0gZGVjb2RlZEludm9pY2Uuc2VjdGlvbnMuZmluZCgocykgPT4gcy5uYW1lID09PSBcImFtb3VudFwiKTtcbiAgaWYgKCFhbW91bnRTZWN0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYW1vdW50ID0gTnVtYmVyLnBhcnNlSW50KGFtb3VudFNlY3Rpb24udmFsdWUpO1xuICBpZiAoIWFtb3VudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGNvbnRlbnQgPSB6YXBSZXF1ZXN0LmNvbnRlbnQ7XG4gIGNvbnN0IHNlbmRlciA9IHphcFJlcXVlc3QucHVia2V5O1xuICBjb25zdCByZWNpcGllbnRUYWcgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpWzBdO1xuICBjb25zdCByZWNpcGllbnQgPSByZWNpcGllbnRUYWdbMV07XG4gIGxldCB6YXBwZWRFdmVudCA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImVcIilbMF07XG4gIGlmICghemFwcGVkRXZlbnQpIHtcbiAgICB6YXBwZWRFdmVudCA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImFcIilbMF07XG4gIH1cbiAgY29uc3QgemFwcGVkRXZlbnRJZCA9IHphcHBlZEV2ZW50ID8gemFwcGVkRXZlbnRbMV0gOiB2b2lkIDA7XG4gIGNvbnN0IHphcEludm9pY2UgPSB7XG4gICAgaWQ6IGV2ZW50LmlkLFxuICAgIHphcHBlcjogZXZlbnQucHVia2V5LFxuICAgIHphcHBlZTogc2VuZGVyLFxuICAgIHphcHBlZDogcmVjaXBpZW50LFxuICAgIHphcHBlZEV2ZW50OiB6YXBwZWRFdmVudElkLFxuICAgIGFtb3VudCxcbiAgICBjb21tZW50OiBjb250ZW50XG4gIH07XG4gIHJldHVybiB6YXBJbnZvaWNlO1xufVxuXG4vLyBzcmMvemFwcGVyL2luZGV4LnRzXG5pbXBvcnQgY3JlYXRlRGVidWc1IGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjkgfSBmcm9tIFwidHNlZXBcIjtcblxuLy8gc3JjL3phcHBlci9sbi50c1xuaW1wb3J0IHsgYmVjaDMyIH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG5pbXBvcnQgY3JlYXRlRGVidWc0IGZyb20gXCJkZWJ1Z1wiO1xudmFyIGQyID0gY3JlYXRlRGVidWc0KFwibmRrOnphcHBlcjpsblwiKTtcbmFzeW5jIGZ1bmN0aW9uIGdldE5pcDU3WmFwU3BlY0Zyb21MdWQoeyBsdWQwNiwgbHVkMTYgfSwgbmRrKSB7XG4gIGxldCB6YXBFbmRwb2ludDtcbiAgaWYgKGx1ZDE2ICYmICFsdWQxNi5zdGFydHNXaXRoKFwiTE5VUkxcIikpIHtcbiAgICBjb25zdCBbbmFtZSwgZG9tYWluXSA9IGx1ZDE2LnNwbGl0KFwiQFwiKTtcbiAgICB6YXBFbmRwb2ludCA9IGBodHRwczovLyR7ZG9tYWlufS8ud2VsbC1rbm93bi9sbnVybHAvJHtuYW1lfWA7XG4gIH0gZWxzZSBpZiAobHVkMDYpIHtcbiAgICBjb25zdCB7IHdvcmRzIH0gPSBiZWNoMzIuZGVjb2RlKGx1ZDA2LCAxZTMpO1xuICAgIGNvbnN0IGRhdGEgPSBiZWNoMzIuZnJvbVdvcmRzKHdvcmRzKTtcbiAgICBjb25zdCB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuICAgIHphcEVuZHBvaW50ID0gdXRmOERlY29kZXIuZGVjb2RlKGRhdGEpO1xuICB9XG4gIGlmICghemFwRW5kcG9pbnQpIHtcbiAgICBkMihcIk5vIHphcCBlbmRwb2ludCBmb3VuZCAlb1wiLCB7IGx1ZDA2LCBsdWQxNiB9KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB6YXAgZW5kcG9pbnQgZm91bmRcIik7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBfZmV0Y2ggPSBuZGsuaHR0cEZldGNoIHx8IGZldGNoO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2ZldGNoKHphcEVuZHBvaW50KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmZXRjaCB6YXAgZW5kcG9pbnQgJHt6YXBFbmRwb2ludH06ICR7dGV4dH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZldGNoIHphcCBlbmRwb2ludCAke3phcEVuZHBvaW50fTogJHtlfWApO1xuICB9XG59XG5cbi8vIHNyYy96YXBwZXIvbmlwNTcudHNcbmltcG9ydCB7IG5pcDU3IH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVphcFJlcXVlc3QodGFyZ2V0LCBuZGssIGRhdGEsIHB1YmtleSwgYW1vdW50LCByZWxheXMsIGNvbW1lbnQsIHRhZ3MsIHNpZ25lcikge1xuICBjb25zdCB6YXBFbmRwb2ludCA9IGRhdGEuY2FsbGJhY2s7XG4gIGNvbnN0IHphcFJlcXVlc3QgPSBuaXA1Ny5tYWtlWmFwUmVxdWVzdCh7XG4gICAgcHJvZmlsZTogcHVia2V5LFxuICAgIC8vIHNldCB0aGUgZXZlbnQgdG8gbnVsbCBzaW5jZSBub3N0ci10b29scyBkb2Vzbid0IHN1cHBvcnQgbmlwLTMzIHphcHNcbiAgICBldmVudDogbnVsbCxcbiAgICBhbW91bnQsXG4gICAgY29tbWVudDogY29tbWVudCB8fCBcIlwiLFxuICAgIHJlbGF5czogcmVsYXlzLnNsaWNlKDAsIDQpXG4gIH0pO1xuICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICBjb25zdCB0YWdzMiA9IHRhcmdldC5yZWZlcmVuY2VUYWdzKCk7XG4gICAgY29uc3Qgbm9uUFRhZ3MgPSB0YWdzMi5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcInBcIik7XG4gICAgemFwUmVxdWVzdC50YWdzLnB1c2goLi4ubm9uUFRhZ3MpO1xuICB9XG4gIHphcFJlcXVlc3QudGFncy5wdXNoKFtcImxudXJsXCIsIHphcEVuZHBvaW50XSk7XG4gIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgemFwUmVxdWVzdCk7XG4gIGlmICh0YWdzKSB7XG4gICAgZXZlbnQudGFncyA9IGV2ZW50LnRhZ3MuY29uY2F0KHRhZ3MpO1xuICB9XG4gIGNvbnN0IGVUYWdnZWRFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBhVGFnZ2VkRXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCB0YWcgb2YgZXZlbnQudGFncykge1xuICAgIGlmICh0YWdbMF0gPT09IFwiZVwiKSB7XG4gICAgICBlVGFnZ2VkRXZlbnRzLmFkZCh0YWdbMV0pO1xuICAgIH0gZWxzZSBpZiAodGFnWzBdID09PSBcImFcIikge1xuICAgICAgYVRhZ2dlZEV2ZW50cy5hZGQodGFnWzFdKTtcbiAgICB9XG4gIH1cbiAgaWYgKGVUYWdnZWRFdmVudHMuc2l6ZSA+IDEpIHRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGUtdGFnIGlzIGFsbG93ZWRcIik7XG4gIGlmIChhVGFnZ2VkRXZlbnRzLnNpemUgPiAxKSB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBhLXRhZyBpcyBhbGxvd2VkXCIpO1xuICBldmVudC50YWdzID0gZXZlbnQudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcInBcIik7XG4gIGV2ZW50LnRhZ3MucHVzaChbXCJwXCIsIHB1YmtleV0pO1xuICBhd2FpdCBldmVudC5zaWduKHNpZ25lcik7XG4gIHJldHVybiBldmVudDtcbn1cblxuLy8gc3JjL3phcHBlci9pbmRleC50c1xudmFyIGQzID0gY3JlYXRlRGVidWc1KFwibmRrOnphcHBlclwiKTtcbnZhciBOREtaYXBwZXIgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjkge1xuICB0YXJnZXQ7XG4gIG5kaztcbiAgY29tbWVudDtcbiAgYW1vdW50O1xuICB1bml0O1xuICB0YWdzO1xuICBzaWduZXI7XG4gIHphcE1ldGhvZDtcbiAgbnV0emFwQXNGYWxsYmFjaztcbiAgbG5QYXk7XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIGNhc2h1IHBheW1lbnQgaXMgdG8gYmUgbWFkZS5cbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgc3dhcC9taW50IHByb29mcyBmb3IgdGhlIHJlcXVpcmVkIGFtb3VudCwgaW4gdGhlIHJlcXVpcmVkIHVuaXQsXG4gICAqIGluIGFueSBvZiB0aGUgcHJvdmlkZWQgbWludHMgYW5kIHJldHVybiB0aGUgcHJvb2ZzIGFuZCBtaW50IHVzZWQuXG4gICAqL1xuICBjYXNodVBheTtcbiAgb25Db21wbGV0ZTtcbiAgbWF4UmVsYXlzID0gMztcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvZiB0aGUgemFwXG4gICAqIEBwYXJhbSBhbW91bnQgVGhlIGFtb3VudCB0byBzZW5kIGluZGljYXRlZCBpbiB0aGUgdW5pdFxuICAgKiBAcGFyYW0gdW5pdCBUaGUgdW5pdCBvZiB0aGUgYW1vdW50XG4gICAqIEBwYXJhbSBvcHRzIE9wdGlvbnMgZm9yIHRoZSB6YXBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhcmdldCwgYW1vdW50LCB1bml0ID0gXCJtc2F0XCIsIG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5uZGsgPSBvcHRzLm5kayB8fCB0YXJnZXQubmRrO1xuICAgIGlmICghdGhpcy5uZGspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBwcm92aWRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5hbW91bnQgPSBhbW91bnQ7XG4gICAgdGhpcy5jb21tZW50ID0gb3B0cy5jb21tZW50O1xuICAgIHRoaXMudW5pdCA9IHVuaXQ7XG4gICAgdGhpcy50YWdzID0gb3B0cy50YWdzO1xuICAgIHRoaXMuc2lnbmVyID0gb3B0cy5zaWduZXI7XG4gICAgdGhpcy5udXR6YXBBc0ZhbGxiYWNrID0gb3B0cy5udXR6YXBBc0ZhbGxiYWNrID8/IGZhbHNlO1xuICAgIHRoaXMubG5QYXkgPSBvcHRzLmxuUGF5IHx8IHRoaXMubmRrLndhbGxldENvbmZpZz8ubG5QYXk7XG4gICAgdGhpcy5jYXNodVBheSA9IG9wdHMuY2FzaHVQYXkgfHwgdGhpcy5uZGsud2FsbGV0Q29uZmlnPy5jYXNodVBheTtcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBvcHRzLm9uQ29tcGxldGUgfHwgdGhpcy5uZGsud2FsbGV0Q29uZmlnPy5vblBheW1lbnRDb21wbGV0ZTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGUgemFwcGluZyBwcm9jZXNzXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBjYWxjdWxhdGUgdGhlIHNwbGl0cyBmb3IgdGhpcyB6YXAgYW5kIGluaXRpYXRlIGVhY2ggemFwIHNwbGl0LlxuICAgKi9cbiAgYXN5bmMgemFwKG1ldGhvZHMpIHtcbiAgICBjb25zdCBzcGxpdHMgPSB0aGlzLmdldFphcFNwbGl0cygpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgc3BsaXRzLm1hcChhc3luYyAoc3BsaXQpID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnphcFNwbGl0KHNwbGl0LCBtZXRob2RzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyBFcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcInNwbGl0OmNvbXBsZXRlXCIsIHNwbGl0LCByZXN1bHQpO1xuICAgICAgICByZXN1bHRzLnNldChzcGxpdCwgcmVzdWx0KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLmVtaXQoXCJjb21wbGV0ZVwiLCByZXN1bHRzKTtcbiAgICBpZiAodGhpcy5vbkNvbXBsZXRlKSB0aGlzLm9uQ29tcGxldGUocmVzdWx0cyk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgYXN5bmMgemFwTmlwNTcoc3BsaXQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMubG5QYXkpIHRocm93IG5ldyBFcnJvcihcIk5vIGxuUGF5IGZ1bmN0aW9uIGF2YWlsYWJsZVwiKTtcbiAgICBjb25zdCB6YXBTcGVjID0gYXdhaXQgZ2V0TmlwNTdaYXBTcGVjRnJvbUx1ZChkYXRhLCB0aGlzLm5kayk7XG4gICAgaWYgKCF6YXBTcGVjKSB0aHJvdyBuZXcgRXJyb3IoXCJObyB6YXAgc3BlYyBhdmFpbGFibGUgZm9yIHJlY2lwaWVudFwiKTtcbiAgICBjb25zdCByZWxheXMgPSBhd2FpdCB0aGlzLnJlbGF5cyhzcGxpdC5wdWJrZXkpO1xuICAgIGNvbnN0IHphcFJlcXVlc3QgPSBhd2FpdCBnZW5lcmF0ZVphcFJlcXVlc3QoXG4gICAgICB0aGlzLnRhcmdldCxcbiAgICAgIHRoaXMubmRrLFxuICAgICAgemFwU3BlYyxcbiAgICAgIHNwbGl0LnB1YmtleSxcbiAgICAgIHNwbGl0LmFtb3VudCxcbiAgICAgIHJlbGF5cyxcbiAgICAgIHRoaXMuY29tbWVudCxcbiAgICAgIHRoaXMudGFncyxcbiAgICAgIHRoaXMuc2lnbmVyXG4gICAgKTtcbiAgICBpZiAoIXphcFJlcXVlc3QpIHtcbiAgICAgIGQzKFwiVW5hYmxlIHRvIGdlbmVyYXRlIHphcCByZXF1ZXN0XCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGdlbmVyYXRlIHphcCByZXF1ZXN0XCIpO1xuICAgIH1cbiAgICBjb25zdCBwciA9IGF3YWl0IHRoaXMuZ2V0TG5JbnZvaWNlKHphcFJlcXVlc3QsIHNwbGl0LmFtb3VudCwgemFwU3BlYyk7XG4gICAgaWYgKCFwcikge1xuICAgICAgZDMoXCJVbmFibGUgdG8gZ2V0IHBheW1lbnQgcmVxdWVzdFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBnZXQgcGF5bWVudCByZXF1ZXN0XCIpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJsbl9pbnZvaWNlXCIsIHtcbiAgICAgIGFtb3VudDogc3BsaXQuYW1vdW50LFxuICAgICAgcmVjaXBpZW50UHVia2V5OiBzcGxpdC5wdWJrZXksXG4gICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICBuaXA1N1phcFJlcXVlc3Q6IHphcFJlcXVlc3QsXG4gICAgICBwcixcbiAgICAgIHR5cGU6IFwibmlwNTdcIlxuICAgIH0pO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMubG5QYXkoe1xuICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCxcbiAgICAgIHJlY2lwaWVudFB1YmtleTogc3BsaXQucHVia2V5LFxuICAgICAgcGF5bWVudERlc2NyaXB0aW9uOiBcIk5JUC01NyBaYXBcIixcbiAgICAgIHByLFxuICAgICAgYW1vdW50OiBzcGxpdC5hbW91bnQsXG4gICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICBuaXA1N1phcFJlcXVlc3Q6IHphcFJlcXVlc3RcbiAgICB9KTtcbiAgICBpZiAocmVzPy5wcmVpbWFnZSkge1xuICAgICAgdGhpcy5lbWl0KFwibG5fcGF5bWVudFwiLCB7XG4gICAgICAgIHByZWltYWdlOiByZXMucHJlaW1hZ2UsXG4gICAgICAgIGFtb3VudDogc3BsaXQuYW1vdW50LFxuICAgICAgICByZWNpcGllbnRQdWJrZXk6IHNwbGl0LnB1YmtleSxcbiAgICAgICAgcHIsXG4gICAgICAgIHVuaXQ6IHRoaXMudW5pdCxcbiAgICAgICAgbmlwNTdaYXBSZXF1ZXN0OiB6YXBSZXF1ZXN0LFxuICAgICAgICB0eXBlOiBcIm5pcDU3XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaGVzIGluZm9ybWF0aW9uIGFib3V0IGEgTklQLTYxIHphcCBhbmQgYXNrcyB0aGUgY2FsbGVyIHRvIGNyZWF0ZSBjYXNodSBwcm9vZnMgZm9yIHRoZSB6YXAuXG4gICAqXG4gICAqIChub3RlIHRoYXQgdGhlIGNhc2h1UGF5IGZ1bmN0aW9uIGNhbiB1c2UgYW55IG1ldGhvZCB0byBjcmVhdGUgdGhlIHByb29mcywgaW5jbHVkaW5nIHVzaW5nIGxpZ2h0bmluZ1xuICAgKiB0byBtaW50IHByb29mcyBpbiB0aGUgc3BlY2lmaWVkIG1pbnQsIHRoZSByZXNwb25zaWJpbGl0eSBvZiBtaW50aW5nIHRoZSBwcm9vZnMgaXMgZGVsZWdhdGVkIHRvIHRoZSBjYWxsZXIgKGUuZy4gbmRrLXdhbGxldCkpXG4gICAqL1xuICBhc3luYyB6YXBOaXA2MShzcGxpdCwgZGF0YSkge1xuICAgIGlmICghdGhpcy5jYXNodVBheSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2FzaHVQYXkgZnVuY3Rpb24gYXZhaWxhYmxlXCIpO1xuICAgIGxldCByZXQ7XG4gICAgcmV0ID0gYXdhaXQgdGhpcy5jYXNodVBheShcbiAgICAgIHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCxcbiAgICAgICAgcmVjaXBpZW50UHVia2V5OiBzcGxpdC5wdWJrZXksXG4gICAgICAgIHBheW1lbnREZXNjcmlwdGlvbjogXCJOSVAtNjEgWmFwXCIsXG4gICAgICAgIGFtb3VudDogc3BsaXQuYW1vdW50LFxuICAgICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICAgIC4uLmRhdGEgPz8ge31cbiAgICAgIH0sXG4gICAgICAocHIpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFwibG5faW52b2ljZVwiLCB7XG4gICAgICAgICAgcHIsXG4gICAgICAgICAgYW1vdW50OiBzcGxpdC5hbW91bnQsXG4gICAgICAgICAgcmVjaXBpZW50UHVia2V5OiBzcGxpdC5wdWJrZXksXG4gICAgICAgICAgdW5pdDogdGhpcy51bml0LFxuICAgICAgICAgIHR5cGU6IFwibmlwNjFcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICAgIGQzKFwiTklQLTYxIFphcCByZXN1bHQ6ICVvXCIsIHJldCk7XG4gICAgaWYgKHJldCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBpZiAocmV0KSB7XG4gICAgICBjb25zdCB7IHByb29mcywgbWludCB9ID0gcmV0O1xuICAgICAgaWYgKCFwcm9vZnMgfHwgIW1pbnQpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB6YXAgY29uZmlybWF0aW9uOiBtaXNzaW5nIHByb29mcyBvciBtaW50OiAke3JldH1gKTtcbiAgICAgIGNvbnN0IHJlbGF5cyA9IGF3YWl0IHRoaXMucmVsYXlzKHNwbGl0LnB1YmtleSk7XG4gICAgICBjb25zdCByZWxheVNldCA9IE5ES1JlbGF5U2V0LmZyb21SZWxheVVybHMocmVsYXlzLCB0aGlzLm5kayk7XG4gICAgICBjb25zdCBudXR6YXAgPSBuZXcgTkRLTnV0emFwKHRoaXMubmRrKTtcbiAgICAgIG51dHphcC50YWdzID0gWy4uLm51dHphcC50YWdzLCAuLi50aGlzLnRhZ3MgfHwgW11dO1xuICAgICAgbnV0emFwLnByb29mcyA9IHByb29mcztcbiAgICAgIG51dHphcC5taW50ID0gbWludDtcbiAgICAgIG51dHphcC50YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgIG51dHphcC5jb21tZW50ID0gdGhpcy5jb21tZW50O1xuICAgICAgbnV0emFwLnVuaXQgPSBcInNhdFwiO1xuICAgICAgbnV0emFwLnJlY2lwaWVudFB1YmtleSA9IHNwbGl0LnB1YmtleTtcbiAgICAgIGF3YWl0IG51dHphcC5zaWduKHRoaXMuc2lnbmVyKTtcbiAgICAgIG51dHphcC5wdWJsaXNoKHJlbGF5U2V0KTtcbiAgICAgIHJldHVybiBudXR6YXA7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHphcCBtZXRob2RzIGF2YWlsYWJsZSBmb3IgdGhlIHJlY2lwaWVudCBhbmQgaW5pdGlhdGVzIHRoZSB6YXBcbiAgICogaW4gdGhlIGRlc2lyZWQgbWV0aG9kLlxuICAgKiBAcGFyYW0gc3BsaXRcbiAgICogQHBhcmFtIG1ldGhvZHMgLSBUaGUgbWV0aG9kcyB0byB0cnksIGlmIG5vdCBwcm92aWRlZCwgYWxsIG1ldGhvZHMgd2lsbCBiZSB0cmllZC5cbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIHphcFNwbGl0KHNwbGl0LCBtZXRob2RzKSB7XG4gICAgY29uc3QgcmVjaXBpZW50ID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogc3BsaXQucHVia2V5IH0pO1xuICAgIGNvbnN0IHphcE1ldGhvZHMgPSBhd2FpdCByZWNpcGllbnQuZ2V0WmFwSW5mbygyNTAwKTtcbiAgICBsZXQgcmV0VmFsO1xuICAgIGNvbnN0IGNhbkZhbGxiYWNrVG9OaXA2MSA9IHRoaXMubnV0emFwQXNGYWxsYmFjayAmJiB0aGlzLmNhc2h1UGF5O1xuICAgIGlmICh6YXBNZXRob2RzLnNpemUgPT09IDAgJiYgIWNhbkZhbGxiYWNrVG9OaXA2MSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHphcCBtZXRob2QgYXZhaWxhYmxlIGZvciByZWNpcGllbnQgYW5kIE5JUC02MSBmYWxsYmFjayBpcyBkaXNhYmxlZFwiKTtcbiAgICBjb25zdCBuaXA2MUZhbGxiYWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLm51dHphcEFzRmFsbGJhY2spIHJldHVybjtcbiAgICAgIGNvbnN0IHJlbGF5TGlzdHMgPSBhd2FpdCBnZXRSZWxheUxpc3RGb3JVc2Vycyhbc3BsaXQucHVia2V5XSwgdGhpcy5uZGspO1xuICAgICAgbGV0IHJlbGF5VXJscyA9IHJlbGF5TGlzdHMuZ2V0KHNwbGl0LnB1YmtleSk/LnJlYWRSZWxheVVybHM7XG4gICAgICByZWxheVVybHMgPSB0aGlzLm5kay5wb29sLmNvbm5lY3RlZFJlbGF5cygpLm1hcCgocikgPT4gci51cmwpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuemFwTmlwNjEoc3BsaXQsIHtcbiAgICAgICAgLy8gdXNlIHRoZSB1c2VyJ3MgcmVsYXkgbGlzdFxuICAgICAgICByZWxheXM6IHJlbGF5VXJscyxcbiAgICAgICAgLy8gbG9jayB0byB0aGUgdXNlcidzIGFjdHVhbCBwdWJrZXlcbiAgICAgICAgcDJwazogc3BsaXQucHVia2V5LFxuICAgICAgICAvLyBhbGxvdyBpbnRyYW1pbnQgZmFsbGJhY2tcbiAgICAgICAgYWxsb3dJbnRyYW1pbnRGYWxsYmFjazogISFjYW5GYWxsYmFja1RvTmlwNjFcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgY2FuVXNlTmlwNjEgPSAhbWV0aG9kcyB8fCBtZXRob2RzLmluY2x1ZGVzKFwibmlwNjFcIik7XG4gICAgY29uc3QgY2FuVXNlTmlwNTcgPSAhbWV0aG9kcyB8fCBtZXRob2RzLmluY2x1ZGVzKFwibmlwNTdcIik7XG4gICAgY29uc3QgbmlwNjFNZXRob2QgPSB6YXBNZXRob2RzLmdldChcIm5pcDYxXCIpO1xuICAgIGlmIChuaXA2MU1ldGhvZCAmJiBjYW5Vc2VOaXA2MSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0VmFsID0gYXdhaXQgdGhpcy56YXBOaXA2MShzcGxpdCwgbmlwNjFNZXRob2QpO1xuICAgICAgICBpZiAocmV0VmFsIGluc3RhbmNlb2YgTkRLTnV0emFwKSByZXR1cm4gcmV0VmFsO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJub3RpY2VcIiwgYE5JUC02MSBhdHRlbXB0IGZhaWxlZDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5pcDU3TWV0aG9kID0gemFwTWV0aG9kcy5nZXQoXCJuaXA1N1wiKTtcbiAgICBpZiAobmlwNTdNZXRob2QgJiYgY2FuVXNlTmlwNTcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldFZhbCA9IGF3YWl0IHRoaXMuemFwTmlwNTcoc3BsaXQsIG5pcDU3TWV0aG9kKTtcbiAgICAgICAgaWYgKCEocmV0VmFsIGluc3RhbmNlb2YgRXJyb3IpKSByZXR1cm4gcmV0VmFsO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJub3RpY2VcIiwgYE5JUC01NyBhdHRlbXB0IGZhaWxlZDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjYW5GYWxsYmFja1RvTmlwNjEpIHtcbiAgICAgIHJldFZhbCA9IGF3YWl0IG5pcDYxRmFsbGJhY2soKTtcbiAgICAgIGlmIChyZXRWYWwgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgcmV0VmFsO1xuICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwibm90aWNlXCIsIFwiWmFwIG1ldGhvZHMgZXhoYXVzdGVkIGFuZCB0aGVyZSB3YXMgbm8gZmFsbGJhY2sgdG8gTklQLTYxXCIpO1xuICAgIGlmIChyZXRWYWwgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgcmV0VmFsO1xuICAgIHJldHVybiByZXRWYWw7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBib2x0MTEgZm9yIGEgbmlwNTcgemFwXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcGFyYW0gYW1vdW50XG4gICAqIEBwYXJhbSB6YXBFbmRwb2ludFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgZ2V0TG5JbnZvaWNlKHphcFJlcXVlc3QsIGFtb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHphcEVuZHBvaW50ID0gZGF0YS5jYWxsYmFjaztcbiAgICBjb25zdCBldmVudFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeSh6YXBSZXF1ZXN0LnJhd0V2ZW50KCkpO1xuICAgIGQzKFxuICAgICAgYEZldGNoaW5nIGludm9pY2UgZnJvbSAke3phcEVuZHBvaW50fT8ke25ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhbW91bnQ6IGFtb3VudC50b1N0cmluZygpLFxuICAgICAgICBub3N0cjogZXZlbnRQYXlsb2FkXG4gICAgICB9KX1gXG4gICAgKTtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHphcEVuZHBvaW50KTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImFtb3VudFwiLCBhbW91bnQudG9TdHJpbmcoKSk7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJub3N0clwiLCBldmVudFBheWxvYWQpO1xuICAgIGQzKGBGZXRjaGluZyBpbnZvaWNlIGZyb20gJHt1cmwudG9TdHJpbmcoKX1gKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpKTtcbiAgICBkMyhgR290IHJlc3BvbnNlIGZyb20gemFwIGVuZHBvaW50OiAke3phcEVuZHBvaW50fWAsIHsgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICBkMyhgUmVjZWl2ZWQgbm9uLTIwMCBzdGF0dXMgZnJvbSB6YXAgZW5kcG9pbnQ6ICR7emFwRW5kcG9pbnR9YCwge1xuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgYW1vdW50LFxuICAgICAgICBub3N0cjogZXZlbnRQYXlsb2FkXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmZXRjaCB6YXAgZW5kcG9pbnQgJHt6YXBFbmRwb2ludH06ICR7dGV4dH1gKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gYm9keS5wcjtcbiAgfVxuICBnZXRaYXBTcGxpdHMoKSB7XG4gICAgaWYgKHRoaXMudGFyZ2V0IGluc3RhbmNlb2YgTkRLVXNlcikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHB1YmtleTogdGhpcy50YXJnZXQucHVia2V5LFxuICAgICAgICAgIGFtb3VudDogdGhpcy5hbW91bnRcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgY29uc3QgemFwVGFncyA9IHRoaXMudGFyZ2V0LmdldE1hdGNoaW5nVGFncyhcInphcFwiKTtcbiAgICBpZiAoemFwVGFncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICBwdWJrZXk6IHRoaXMudGFyZ2V0LnB1YmtleSxcbiAgICAgICAgICBhbW91bnQ6IHRoaXMuYW1vdW50XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0IHNwbGl0cyA9IFtdO1xuICAgIGNvbnN0IHRvdGFsID0gemFwVGFncy5yZWR1Y2UoKGFjYywgdGFnKSA9PiBhY2MgKyBOdW1iZXIucGFyc2VJbnQodGFnWzJdKSwgMCk7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgemFwVGFncykge1xuICAgICAgY29uc3QgcHVia2V5ID0gdGFnWzFdO1xuICAgICAgY29uc3QgYW1vdW50ID0gTWF0aC5mbG9vcihOdW1iZXIucGFyc2VJbnQodGFnWzJdKSAvIHRvdGFsICogdGhpcy5hbW91bnQpO1xuICAgICAgc3BsaXRzLnB1c2goeyBwdWJrZXksIGFtb3VudCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNwbGl0cztcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgemFwIG1ldGhvZCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHphcCBhIHB1YmJrZXlcbiAgICogQHBhcmFtIG5ka1xuICAgKiBAcGFyYW0gcHVia2V5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBnZXRaYXBNZXRob2RzKG5kaywgcmVjaXBpZW50LCB0aW1lb3V0ID0gMjUwMCkge1xuICAgIGNvbnN0IHVzZXIgPSBuZGsuZ2V0VXNlcih7IHB1YmtleTogcmVjaXBpZW50IH0pO1xuICAgIHJldHVybiBhd2FpdCB1c2VyLmdldFphcEluZm8odGltZW91dCk7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIHRoZSByZWxheXMgdG8gdXNlIGZvciB0aGUgemFwIHJlcXVlc3RcbiAgICovXG4gIGFzeW5jIHJlbGF5cyhwdWJrZXkpIHtcbiAgICBsZXQgciA9IFtdO1xuICAgIGlmICh0aGlzLm5kaz8uYWN0aXZlVXNlcikge1xuICAgICAgY29uc3QgcmVsYXlMaXN0cyA9IGF3YWl0IGdldFJlbGF5TGlzdEZvclVzZXJzKFt0aGlzLm5kay5hY3RpdmVVc2VyLnB1YmtleSwgcHVia2V5XSwgdGhpcy5uZGspO1xuICAgICAgY29uc3QgcmVsYXlTY29yZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCByZWxheUxpc3Qgb2YgcmVsYXlMaXN0cy52YWx1ZXMoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHVybCBvZiByZWxheUxpc3QucmVhZFJlbGF5VXJscykge1xuICAgICAgICAgIGNvbnN0IHNjb3JlID0gcmVsYXlTY29yZXMuZ2V0KHVybCkgfHwgMDtcbiAgICAgICAgICByZWxheVNjb3Jlcy5zZXQodXJsLCBzY29yZSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByID0gQXJyYXkuZnJvbShyZWxheVNjb3Jlcy5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKS5tYXAoKFt1cmxdKSA9PiB1cmwpLnNsaWNlKDAsIHRoaXMubWF4UmVsYXlzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmRrPy5wb29sPy5wZXJtYW5lbnRBbmRDb25uZWN0ZWRSZWxheXMoKS5sZW5ndGgpIHtcbiAgICAgIHIgPSB0aGlzLm5kay5wb29sLnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLm1hcCgocmVsYXkpID0+IHJlbGF5LnVybCk7XG4gICAgfVxuICAgIGlmICghci5sZW5ndGgpIHtcbiAgICAgIHIgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9maWx0ZXIudHNcbmZ1bmN0aW9uIG1hdGNoRmlsdGVyKGZpbHRlciwgZXZlbnQpIHtcbiAgaWYgKGZpbHRlci5pZHMgJiYgZmlsdGVyLmlkcy5pbmRleE9mKGV2ZW50LmlkKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbHRlci5raW5kcyAmJiBmaWx0ZXIua2luZHMuaW5kZXhPZihldmVudC5raW5kKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbHRlci5hdXRob3JzICYmIGZpbHRlci5hdXRob3JzLmluZGV4T2YoZXZlbnQucHVia2V5KSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBmIGluIGZpbHRlcikge1xuICAgIGlmIChmWzBdID09PSBcIiNcIikge1xuICAgICAgY29uc3QgdGFnTmFtZSA9IGYuc2xpY2UoMSk7XG4gICAgICBpZiAodGFnTmFtZSA9PT0gXCJ0XCIpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZmlsdGVyW2AjJHt0YWdOYW1lfWBdPy5tYXAoKHYpID0+IHYudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmICh2YWx1ZXMgJiYgIWV2ZW50LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSB0YWdOYW1lICYmIHZhbHVlcz8uaW5kZXhPZih2LnRvTG93ZXJDYXNlKCkpICE9PSAtMSkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZmlsdGVyW2AjJHt0YWdOYW1lfWBdO1xuICAgICAgICBpZiAodmFsdWVzICYmICFldmVudC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gdGFnTmFtZSAmJiB2YWx1ZXM/LmluZGV4T2YodikgIT09IC0xKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZmlsdGVyLnNpbmNlICYmIGV2ZW50LmNyZWF0ZWRfYXQgPCBmaWx0ZXIuc2luY2UpIHJldHVybiBmYWxzZTtcbiAgaWYgKGZpbHRlci51bnRpbCAmJiBldmVudC5jcmVhdGVkX2F0ID4gZmlsdGVyLnVudGlsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IHtcbiAgQkVDSDMyX1JFR0VYLFxuICBOREtBcHBIYW5kbGVyRXZlbnQsXG4gIE5ES0FwcFNldHRpbmdzLFxuICBOREtBcnRpY2xlLFxuICBOREtDYXNodU1pbnRMaXN0LFxuICBOREtDYXNodVRva2VuLFxuICBOREtDYXNodVdhbGxldFR4LFxuICBOREtDbGFzc2lmaWVkLFxuICBOREtEVk1Kb2JGZWVkYmFjayxcbiAgTkRLRFZNSm9iUmVzdWx0LFxuICBOREtEVk1SZXF1ZXN0LFxuICBOREtEcmFmdCxcbiAgTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMsXG4gIE5ES0V2ZW50LFxuICBOREtIaWdobGlnaHQsXG4gIE5ES0ltYWdlLFxuICBOREtLaW5kLFxuICBOREtMaXN0LFxuICBOREtMaXN0S2luZHMsXG4gIE5ES05pcDA3U2lnbmVyLFxuICBOREtOaXA0NkJhY2tlbmQsXG4gIE5ES05pcDQ2U2lnbmVyLFxuICBOREtOb3N0clJwYyxcbiAgTkRLTnV0emFwLFxuICBOREtQb29sLFxuICBOREtQcml2YXRlS2V5U2lnbmVyLFxuICBOREtQdWJsaXNoRXJyb3IsXG4gIE5ES1JlbGF5LFxuICBOREtSZWxheUF1dGhQb2xpY2llcyxcbiAgTkRLUmVsYXlMaXN0LFxuICBOREtSZWxheVNldCxcbiAgTkRLUmVsYXlTdGF0dXMsXG4gIE5ES1JlcG9zdCxcbiAgTkRLU2ltcGxlR3JvdXAsXG4gIE5ES1NpbXBsZUdyb3VwTWVtYmVyTGlzdCxcbiAgTkRLU2ltcGxlR3JvdXBNZXRhZGF0YSxcbiAgTkRLU3RvcnksXG4gIE5ES1N0b3J5U3RpY2tlcixcbiAgTkRLU3RvcnlTdGlja2VyVHlwZSxcbiAgTkRLU3Vic2NyaXB0aW9uLFxuICBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlLFxuICBOREtTdWJzY3JpcHRpb25SZWNlaXB0LFxuICBOREtTdWJzY3JpcHRpb25TdGFydCxcbiAgTkRLU3Vic2NyaXB0aW9uVGllcixcbiAgTkRLVHJhbnNjcmlwdGlvbkRWTSxcbiAgTkRLVXNlcixcbiAgTkRLVmlkZW8sXG4gIE5ES1dpa2ksXG4gIE5ES1dpa2lNZXJnZVJlcXVlc3QsXG4gIE5ES1phcHBlcixcbiAgTklQMzNfQV9SRUdFWCxcbiAgTmRrTnV0emFwU3RhdHVzLFxuICBjYWxjdWxhdGVSZWxheVNldEZyb21FdmVudCxcbiAgY2FsY3VsYXRlVGVybUR1cmF0aW9uSW5TZWNvbmRzLFxuICBjYXNodVB1YmtleVRvTm9zdHJQdWJrZXksXG4gIGNvbXBhcmVGaWx0ZXIsXG4gIE5ESyBhcyBkZWZhdWx0LFxuICBkZWZhdWx0T3B0cyxcbiAgZGVzZXJpYWxpemUsXG4gIGR2bVNjaGVkdWxlLFxuICBldmVudEhhc0VUYWdNYXJrZXJzLFxuICBldmVudElzUGFydE9mVGhyZWFkLFxuICBldmVudElzUmVwbHksXG4gIGV2ZW50UmVwbGllcyxcbiAgZXZlbnRUaHJlYWRJZHMsXG4gIGV2ZW50VGhyZWFkcyxcbiAgZXZlbnRzQnlTYW1lQXV0aG9yLFxuICBmaWx0ZXJBbmRSZWxheVNldEZyb21CZWNoMzIsXG4gIGZpbHRlckZpbmdlcnByaW50LFxuICBmaWx0ZXJGb3JFdmVudHNUYWdnaW5nSWQsXG4gIGZpbHRlckZyb21JZCxcbiAgZ2VuZXJhdGVDb250ZW50VGFncyxcbiAgZ2VuZXJhdGVIYXNodGFncyxcbiAgZ2VuZXJhdGVTdWJJZCxcbiAgZ2VuZXJhdGVaYXBSZXF1ZXN0LFxuICBnZXRFdmVudFJlcGx5SWQsXG4gIGdldE5pcDU3WmFwU3BlY0Zyb21MdWQsXG4gIGdldFJlbGF5TGlzdEZvclVzZXIsXG4gIGdldFJlbGF5TGlzdEZvclVzZXJzLFxuICBnZXRSZXBseVRhZyxcbiAgZ2V0Um9vdEV2ZW50SWQsXG4gIGdldFJvb3RUYWcsXG4gIGdpZnRVbndyYXAsXG4gIGdpZnRXcmFwLFxuICBpbWV0YVRhZ1RvVGFnLFxuICBpc0V2ZW50T3JpZ2luYWxQb3N0LFxuICBpc05pcDMzQVZhbHVlLFxuICBtYXBJbWV0YVRhZyxcbiAgbWF0Y2hGaWx0ZXIsXG4gIG1lcmdlRmlsdGVycyxcbiAgbWVyZ2VUYWdzLFxuICBuZGtTaWduZXJGcm9tUGF5bG9hZCxcbiAgbmV3QW1vdW50LFxuICBub3JtYWxpemUsXG4gIG5vcm1hbGl6ZVJlbGF5VXJsLFxuICBub3JtYWxpemVVcmwsXG4gIHBhcnNlVGFnVG9TdWJzY3JpcHRpb25BbW91bnQsXG4gIHBpbkV2ZW50LFxuICBwb3NzaWJsZUludGVydmFsRnJlcXVlbmNpZXMsXG4gIHByb2ZpbGVGcm9tRXZlbnQsXG4gIHByb29mUDJwayxcbiAgcHJvb2ZQMnBrTm9zdHIsXG4gIHByb29mc1RvdGFsQmFsYW5jZSxcbiAgcXVlcnlGdWxseUZpbGxlZCxcbiAgcmVsYXlMaXN0RnJvbUtpbmQzLFxuICByZWxheXNGcm9tQmVjaDMyLFxuICBzZXJpYWxpemUsXG4gIHNlcmlhbGl6ZVByb2ZpbGUsXG4gIHNpZ25lclJlZ2lzdHJ5LFxuICBzdHJUb0RpbWVuc2lvbixcbiAgc3RyVG9Qb3NpdGlvbixcbiAgdHJ5Tm9ybWFsaXplUmVsYXlVcmwsXG4gIHVuaXF1ZVRhZyxcbiAgd3JhcEV2ZW50LFxuICB6YXBJbnZvaWNlRnJvbUV2ZW50XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-hooks/node_modules/@nostr-dev-kit/ndk/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-wallet/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-wallet/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NDKCashuDeposit: () => (/* binding */ NDKCashuDeposit),\n/* harmony export */   NDKCashuWallet: () => (/* binding */ NDKCashuWallet),\n/* harmony export */   NDKCashuWalletBackup: () => (/* binding */ NDKCashuWalletBackup),\n/* harmony export */   NDKNWCWallet: () => (/* binding */ NDKNWCWallet),\n/* harmony export */   NDKNutzapMonitor: () => (/* binding */ NDKNutzapMonitor),\n/* harmony export */   NDKWallet: () => (/* binding */ NDKWallet),\n/* harmony export */   NDKWalletStatus: () => (/* binding */ NDKWalletStatus),\n/* harmony export */   NDKWebLNWallet: () => (/* binding */ NDKWebLNWallet),\n/* harmony export */   WalletState: () => (/* binding */ WalletState),\n/* harmony export */   calculateNewState: () => (/* binding */ calculateNewState),\n/* harmony export */   consolidateMintTokens: () => (/* binding */ consolidateMintTokens),\n/* harmony export */   consolidateTokens: () => (/* binding */ consolidateTokens),\n/* harmony export */   getBolt11Amount: () => (/* binding */ getBolt11Amount),\n/* harmony export */   getBolt11Description: () => (/* binding */ getBolt11Description),\n/* harmony export */   getBolt11ExpiresAt: () => (/* binding */ getBolt11ExpiresAt),\n/* harmony export */   getCashuMintRecommendations: () => (/* binding */ getCashuMintRecommendations),\n/* harmony export */   migrateCashuWallet: () => (/* binding */ migrateCashuWallet),\n/* harmony export */   update: () => (/* binding */ update)\n/* harmony export */ });\n/* harmony import */ var _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @nostr-dev-kit/ndk */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk-wallet/node_modules/@nostr-dev-kit/ndk/dist/index.mjs\");\n/* harmony import */ var tseep__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tseep */ \"(ssr)/./node_modules/tseep/lib/index.js\");\n/* harmony import */ var _cashu_cashu_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @cashu/cashu-ts */ \"(ssr)/./node_modules/@cashu/cashu-ts/lib/cashu-ts.es.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n/* harmony import */ var light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! light-bolt11-decoder */ \"(ssr)/./node_modules/light-bolt11-decoder/bolt11.js\");\n/* harmony import */ var webln__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! webln */ \"(ssr)/./node_modules/webln/lib/index.js\");\n// src/nutzap-monitor/index.ts\n\n\n\n\n// src/wallets/cashu/wallet/index.ts\n\n\n\n// src/wallets/index.ts\n\n\n// src/wallets/cashu/mint.ts\n\nvar mintWallets = /* @__PURE__ */ new Map();\nvar mintWalletPromises = /* @__PURE__ */ new Map();\nfunction mintKey(mint, unit, pk) {\n  if (unit === \"sats\") {\n    unit = \"sat\";\n  }\n  if (pk) {\n    const pkStr = new TextDecoder().decode(pk);\n    return `${mint}-${unit}-${pkStr}`;\n  }\n  return `${mint}-${unit}`;\n}\nasync function walletForMint(mint, {\n  pk,\n  timeout = 5e3,\n  mintInfo,\n  mintKeys,\n  onMintInfoNeeded,\n  onMintInfoLoaded,\n  onMintKeysNeeded,\n  onMintKeysLoaded\n} = {}) {\n  mintInfo ??= await onMintInfoNeeded?.(mint);\n  mintKeys ??= await onMintKeysNeeded?.(mint);\n  if (!mintInfo && onMintInfoLoaded) {\n    mintInfo = await _cashu_cashu_ts__WEBPACK_IMPORTED_MODULE_2__.CashuMint.getInfo(mint);\n    onMintInfoLoaded?.(mint, mintInfo);\n  }\n  const unit = \"sat\";\n  const key = mintKey(mint, unit, pk);\n  if (mintWallets.has(key)) {\n    return mintWallets.get(key);\n  }\n  if (mintWalletPromises.has(key)) {\n    return mintWalletPromises.get(key);\n  }\n  if (!mintInfo) {\n    if (onMintInfoNeeded) {\n      mintInfo = await onMintInfoNeeded(mint);\n    }\n    if (!mintInfo && onMintInfoLoaded) {\n      mintInfo = await _cashu_cashu_ts__WEBPACK_IMPORTED_MODULE_2__.CashuMint.getInfo(mint);\n      onMintInfoLoaded(mint, mintInfo);\n    }\n  }\n  if (!mintKeys && onMintKeysNeeded) {\n    mintKeys = await onMintKeysNeeded(mint);\n  }\n  const wallet = new _cashu_cashu_ts__WEBPACK_IMPORTED_MODULE_2__.CashuWallet(new _cashu_cashu_ts__WEBPACK_IMPORTED_MODULE_2__.CashuMint(mint), {\n    unit,\n    bip39seed: pk,\n    mintInfo,\n    keys: mintKeys\n  });\n  const loadPromise = new Promise(async (resolve) => {\n    try {\n      const timeoutPromise = new Promise((_, rejectTimeout) => {\n        setTimeout(() => {\n          rejectTimeout(new Error(\"timeout loading mint\"));\n        }, timeout);\n      });\n      await Promise.race([wallet.loadMint(), timeoutPromise]);\n      mintWallets.set(key, wallet);\n      mintWalletPromises.delete(key);\n      if (wallet.keys) {\n        onMintKeysLoaded?.(mint, wallet.keys);\n      }\n      resolve(wallet);\n    } catch (e) {\n      console.error(\"[WALLET] error loading mint\", mint, e.message);\n      mintWalletPromises.delete(key);\n      resolve(null);\n    }\n  });\n  mintWalletPromises.set(key, loadPromise);\n  return loadPromise;\n}\n\n// src/wallets/mint.ts\nasync function getCashuWallet(mint) {\n  if (this.cashuWallets.has(mint)) return this.cashuWallets.get(mint);\n  const w = await walletForMint(mint, {\n    onMintInfoNeeded: this.onMintInfoNeeded,\n    onMintInfoLoaded: this.onMintInfoLoaded,\n    onMintKeysNeeded: this.onMintKeysNeeded,\n    onMintKeysLoaded: this.onMintKeysLoaded\n  });\n  if (!w) throw new Error(`unable to load wallet for mint ${mint}`);\n  this.cashuWallets.set(mint, w);\n  return w;\n}\n\n// src/wallets/index.ts\nvar NDKWalletStatus = /* @__PURE__ */ ((NDKWalletStatus2) => {\n  NDKWalletStatus2[\"INITIAL\"] = \"initial\";\n  NDKWalletStatus2[\"LOADING\"] = \"loading\";\n  NDKWalletStatus2[\"READY\"] = \"ready\";\n  NDKWalletStatus2[\"FAILED\"] = \"failed\";\n  return NDKWalletStatus2;\n})(NDKWalletStatus || {});\nvar NDKWallet = class extends tseep__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {\n  cashuWallets = /* @__PURE__ */ new Map();\n  onMintInfoNeeded;\n  onMintInfoLoaded;\n  onMintKeysNeeded;\n  onMintKeysLoaded;\n  getCashuWallet = getCashuWallet.bind(this);\n  ndk;\n  constructor(ndk) {\n    super();\n    this.ndk = ndk;\n  }\n  status = \"initial\" /* INITIAL */;\n  get type() {\n    throw new Error(\"Not implemented\");\n  }\n  /**\n   * An ID of this wallet\n   */\n  walletId = \"unknown\";\n  /**\n   * Get the balance of this wallet\n   */\n  get balance() {\n    throw new Error(\"Not implemented\");\n  }\n  /**\n   * Redeem a set of nutzaps into an NWC wallet.\n   *\n   * This function gets an invoice from the NWC wallet until the total amount of the nutzaps is enough to pay for the invoice\n   * when accounting for fees.\n   *\n   * @param cashuWallet - The cashu wallet to redeem the nutzaps into\n   * @param nutzapIds - The IDs of the nutzaps to redeem\n   * @param proofs - The proofs to redeem\n   * @param privkey - The private key needed to redeem p2pk proofs.\n   */\n  redeemNutzaps(_nutzaps, _privkey, _opts) {\n    throw new Error(\"Not implemented\");\n  }\n};\n\n// src/wallets/cashu/deposit-monitor.ts\n\nvar NDKCashuDepositMonitor = class extends tseep__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {\n  deposits = /* @__PURE__ */ new Map();\n  addDeposit(deposit) {\n    const { quoteId } = deposit;\n    if (!quoteId) throw new Error(\"deposit has no quote ID\");\n    if (this.deposits.has(quoteId)) return false;\n    deposit.once(\"success\", (_token) => {\n      this.removeDeposit(quoteId);\n    });\n    this.deposits.set(quoteId, deposit);\n    this.emit(\"change\");\n    return true;\n  }\n  removeDeposit(quoteId) {\n    this.deposits.delete(quoteId);\n    this.emit(\"change\");\n  }\n};\n\n// src/wallets/cashu/deposit.ts\n\n\n\n// src/wallets/cashu/quote.ts\n\n\n\n// src/utils/ln.ts\n\nfunction getBolt11ExpiresAt(bolt11) {\n  const decoded = (0,light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_4__.decode)(bolt11);\n  const expiry = decoded.expiry;\n  const timestamp = decoded.sections.find((section) => section.name === \"timestamp\").value;\n  if (typeof expiry === \"number\" && typeof timestamp === \"number\") {\n    return expiry + timestamp;\n  }\n  return void 0;\n}\nfunction getBolt11Amount(bolt11) {\n  const decoded = (0,light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_4__.decode)(bolt11);\n  const section = decoded.sections.find((section2) => section2.name === \"amount\");\n  const val = section?.value;\n  return Number(val);\n}\nfunction getBolt11Description(bolt11) {\n  const decoded = (0,light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_4__.decode)(bolt11);\n  const section = decoded.sections.find((section2) => section2.name === \"description\");\n  const val = section?.value;\n  return val;\n}\n\n// src/wallets/cashu/quote.ts\nvar NDKCashuQuote = class _NDKCashuQuote extends _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKEvent {\n  quoteId;\n  mint;\n  amount;\n  unit;\n  _wallet;\n  static kind = _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.CashuQuote;\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.CashuQuote;\n  }\n  static async from(event) {\n    const quote = new _NDKCashuQuote(event.ndk, event);\n    const original = event;\n    try {\n      await quote.decrypt();\n    } catch {\n      quote.content = original.content;\n    }\n    try {\n      const content = JSON.parse(quote.content);\n      quote.quoteId = content.quoteId;\n      quote.mint = content.mint;\n      quote.amount = content.amount;\n      quote.unit = content.unit;\n    } catch (_e) {\n      return;\n    }\n    return quote;\n  }\n  set wallet(wallet) {\n    this._wallet = wallet;\n  }\n  set invoice(invoice) {\n    const bolt11Expiry = getBolt11ExpiresAt(invoice);\n    if (bolt11Expiry) this.tags.push([\"expiration\", bolt11Expiry.toString()]);\n  }\n  async save() {\n    if (!this.ndk) throw new Error(\"NDK is required\");\n    this.content = JSON.stringify({\n      quoteId: this.quoteId,\n      mint: this.mint,\n      amount: this.amount,\n      unit: this.unit\n    });\n    await this.encrypt(this.ndk.activeUser, void 0, \"nip44\");\n    await this.sign();\n    await this.publish(this._wallet?.relaySet);\n  }\n};\n\n// src/wallets/cashu/wallet/txs.ts\n\nasync function createOutTxEvent(ndk, paymentRequest, paymentResult, relaySet, { nutzaps } = {}) {\n  let description = paymentRequest.paymentDescription;\n  let amount;\n  if (paymentRequest.pr) {\n    amount = getBolt11Amount(paymentRequest.pr);\n    description ??= getBolt11Description(paymentRequest.pr);\n    if (amount) amount /= 1e3;\n  } else {\n    amount = paymentRequest.amount;\n  }\n  if (!amount) {\n    console.error(\"BUG: Unable to find amount for paymentRequest\", paymentRequest);\n  }\n  const txEvent = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKCashuWalletTx(ndk);\n  txEvent.direction = \"out\";\n  txEvent.amount = amount ?? 0;\n  txEvent.mint = paymentResult.mint;\n  txEvent.description = description;\n  if (paymentResult.fee) txEvent.fee = paymentResult.fee;\n  if (paymentRequest.target) {\n    txEvent.tags.push(paymentRequest.target.tagReference());\n    if (!(paymentRequest.target instanceof _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKUser)) {\n      txEvent.tags.push([\"p\", paymentRequest.target.pubkey]);\n    }\n  }\n  if (nutzaps) {\n    txEvent.description ??= \"nutzap redeem\";\n    for (const nutzap of nutzaps) txEvent.addRedeemedNutzap(nutzap);\n  }\n  if (paymentResult.stateUpdate?.created) txEvent.createdTokens = [paymentResult.stateUpdate.created];\n  if (paymentResult.stateUpdate?.deleted) txEvent.destroyedTokenIds = paymentResult.stateUpdate.deleted;\n  if (paymentResult.stateUpdate?.reserved) txEvent.reservedTokens = [paymentResult.stateUpdate.reserved];\n  await txEvent.sign();\n  txEvent.publish(relaySet);\n  return txEvent;\n}\nasync function createInTxEvent(ndk, proofs, mint, updateStateResult, { nutzaps, fee, description }, relaySet) {\n  const txEvent = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKCashuWalletTx(ndk);\n  const amount = (0,_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.proofsTotalBalance)(proofs);\n  txEvent.direction = \"in\";\n  txEvent.amount = amount;\n  txEvent.mint = mint;\n  txEvent.description = description;\n  if (updateStateResult.created) txEvent.createdTokens = [updateStateResult.created];\n  if (updateStateResult.deleted) txEvent.destroyedTokenIds = updateStateResult.deleted;\n  if (updateStateResult.reserved) txEvent.reservedTokens = [updateStateResult.reserved];\n  if (nutzaps) for (const nutzap of nutzaps) txEvent.addRedeemedNutzap(nutzap);\n  if (fee) txEvent.fee = fee;\n  await txEvent.sign();\n  txEvent.publish(relaySet);\n  return txEvent;\n}\n\n// src/wallets/cashu/deposit.ts\nvar d = debug__WEBPACK_IMPORTED_MODULE_3__(\"ndk-wallet:cashu:deposit\");\nfunction randomMint(wallet) {\n  const mints = wallet.mints;\n  const mint = mints[Math.floor(Math.random() * mints.length)];\n  return mint;\n}\nvar NDKCashuDeposit = class _NDKCashuDeposit extends tseep__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {\n  mint;\n  amount;\n  quoteId;\n  wallet;\n  checkTimeout;\n  checkIntervalLength = 2500;\n  finalized = false;\n  quoteEvent;\n  constructor(wallet, amount, mint) {\n    super();\n    this.wallet = wallet;\n    this.mint = mint || randomMint(wallet);\n    this.amount = amount;\n  }\n  static fromQuoteEvent(wallet, quote) {\n    if (!quote.amount) throw new Error(\"quote has no amount\");\n    if (!quote.mint) throw new Error(\"quote has no mint\");\n    const deposit = new _NDKCashuDeposit(wallet, quote.amount, quote.mint);\n    deposit.quoteId = quote.quoteId;\n    return deposit;\n  }\n  /**\n   * Creates a quote ID and start monitoring for payment.\n   *\n   * Once a payment is received, the deposit will emit a \"success\" event.\n   *\n   * @param pollTime - time in milliseconds between checks\n   * @returns\n   */\n  async start(pollTime = 2500) {\n    const cashuWallet = await this.wallet.getCashuWallet(this.mint);\n    const quote = await cashuWallet.createMintQuote(this.amount);\n    d(\"created quote %s for %d %s\", quote.quote, this.amount, this.mint);\n    this.quoteId = quote.quote;\n    this.wallet.depositMonitor.addDeposit(this);\n    setTimeout(this.check.bind(this, pollTime), pollTime);\n    this.createQuoteEvent(quote.quote, quote.request).then((event) => this.quoteEvent = event);\n    return quote.request;\n  }\n  /**\n   * This generates a 7374 event containing the quote ID\n   * with an optional expiration set to the bolt11 expiry (if there is one)\n   */\n  async createQuoteEvent(quoteId, bolt11) {\n    const { ndk } = this.wallet;\n    const quoteEvent = new NDKCashuQuote(ndk);\n    quoteEvent.quoteId = quoteId;\n    quoteEvent.mint = this.mint;\n    quoteEvent.amount = this.amount;\n    quoteEvent.wallet = this.wallet;\n    quoteEvent.invoice = bolt11;\n    try {\n      await quoteEvent.save();\n      d(\"saved quote on event %s\", quoteEvent.rawEvent());\n    } catch (e) {\n      d(\"error saving quote on event %s\", e.relayErrors);\n    }\n    return quoteEvent;\n  }\n  async runCheck() {\n    if (!this.finalized) await this.finalize();\n    if (!this.finalized) this.delayCheck();\n  }\n  delayCheck() {\n    setTimeout(() => {\n      this.runCheck();\n      this.checkIntervalLength += 500;\n    }, this.checkIntervalLength);\n  }\n  /**\n   * Check if the deposit has been finalized.\n   * @param timeout A timeout in milliseconds to wait before giving up.\n   */\n  async check(timeout) {\n    this.runCheck();\n    if (timeout) {\n      setTimeout(() => {\n        clearTimeout(this.checkTimeout);\n      }, timeout);\n    }\n  }\n  async finalize() {\n    if (!this.quoteId) throw new Error(\"No quoteId set.\");\n    let proofs;\n    try {\n      d(\"Checking for minting status of %s\", this.quoteId);\n      const cashuWallet = await this.wallet.getCashuWallet(this.mint);\n      const proofsWeHave = await this.wallet.state.getProofs({ mint: this.mint });\n      proofs = await cashuWallet.mintProofs(this.amount, this.quoteId, {\n        proofsWeHave\n      });\n      if (proofs.length === 0) return;\n    } catch (e) {\n      if (e.message.match(/not paid/i)) return;\n      if (e.message.match(/already issued/i)) {\n        d(\"Mint is saying the quote has already been issued, destroying quote event: %s\", e.message);\n        this.destroyQuoteEvent();\n        this.finalized = true;\n        return;\n      }\n      if (e.message.match(/rate limit/i)) {\n        d(\"Mint seems to be rate limiting, lowering check interval\");\n        this.checkIntervalLength += 5e3;\n        return;\n      }\n      d(e.message);\n      return;\n    }\n    try {\n      this.finalized = true;\n      const updateRes = await this.wallet.state.update(\n        {\n          store: proofs,\n          mint: this.mint\n        },\n        \"Deposit\"\n      );\n      const tokenEvent = updateRes.created;\n      if (!tokenEvent) throw new Error(\"no token event created\");\n      createInTxEvent(\n        this.wallet.ndk,\n        proofs,\n        this.mint,\n        updateRes,\n        { description: \"Deposit\" },\n        this.wallet.relaySet\n      );\n      this.emit(\"success\", tokenEvent);\n      this.destroyQuoteEvent();\n    } catch (e) {\n      this.emit(\"error\", e.message);\n      console.error(e);\n    }\n  }\n  async destroyQuoteEvent() {\n    if (!this.quoteEvent) return;\n    const deleteEvent = await this.quoteEvent.delete(void 0, false);\n    deleteEvent.publish(this.wallet.relaySet);\n  }\n};\n\n// src/wallets/cashu/event-handlers/index.ts\n\n\n// src/wallets/cashu/event-handlers/deletion.ts\nasync function handleEventDeletion(event) {\n  const deletedIds = event.getMatchingTags(\"e\").map((tag) => tag[1]);\n  for (const deletedId of deletedIds) {\n    this.state.removeTokenId(deletedId);\n  }\n}\n\n// src/wallets/cashu/event-handlers/quote.ts\nasync function handleQuote(event) {\n  const quote = await NDKCashuQuote.from(event);\n  if (!quote) return;\n  const deposit = NDKCashuDeposit.fromQuoteEvent(this, quote);\n  if (this.depositMonitor.addDeposit(deposit)) {\n    deposit.finalize();\n  }\n}\n\n// src/wallets/cashu/event-handlers/token.ts\n\nvar _cumulativeTime = 0;\nvar _cumulativeCalls = 0;\nasync function handleToken(event) {\n  if (this.state.tokens.has(event.id)) return;\n  const startTime = Date.now();\n  const token = await _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKCashuToken.from(event);\n  if (!token) {\n    _cumulativeTime += Date.now() - startTime;\n    _cumulativeCalls++;\n    return;\n  }\n  _cumulativeTime += Date.now() - startTime;\n  _cumulativeCalls++;\n  for (const deletedTokenId of token.deletedTokens) {\n    this.state.removeTokenId(deletedTokenId);\n  }\n  this.state.addToken(token);\n}\nsetInterval(() => {\n}, 5e3);\n\n// src/wallets/cashu/event-handlers/index.ts\nvar handlers = {\n  [_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.CashuToken]: handleToken,\n  [_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.CashuQuote]: handleQuote,\n  [_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.EventDeletion]: handleEventDeletion\n};\nvar balanceUpdateTimer = null;\nasync function eventHandler(event) {\n  const handler = handlers[event.kind];\n  if (handler) {\n    if (balanceUpdateTimer) clearTimeout(balanceUpdateTimer);\n    await handler.call(this, event);\n    balanceUpdateTimer = setTimeout(() => {\n      this.emit(\"balance_updated\");\n    }, 100);\n  }\n}\nasync function eventDupHandler(_event, _relay, _timeSinceFirstSeen, _sub, _fromCache) {\n}\n\n// src/wallets/cashu/validate.ts\n\n\nvar d2 = debug__WEBPACK_IMPORTED_MODULE_3__(\"ndk-wallet:cashu:validate\");\nasync function consolidateTokens() {\n  d2(\"checking %d tokens for spent proofs\", this.state.tokens.size);\n  const mints = new Set(\n    this.state.getMintsProofs({ validStates: /* @__PURE__ */ new Set([\"available\", \"reserved\", \"deleted\"]) }).keys()\n  );\n  d2(\"found %d mints\", mints.size);\n  mints.forEach((mint) => {\n    consolidateMintTokens(mint, this);\n  });\n}\nasync function consolidateMintTokens(mint, wallet, allProofs, onResult, onFailure) {\n  allProofs ??= wallet.state.getProofs({ mint, includeDeleted: true, onlyAvailable: false });\n  const _wallet = await walletForMint(mint);\n  if (!_wallet) {\n    return;\n  }\n  let proofStates = [];\n  try {\n    proofStates = await _wallet.checkProofsStates(allProofs);\n  } catch (e) {\n    onFailure?.(e.message);\n    return;\n  }\n  const spentProofs = [];\n  const unspentProofs = [];\n  const pendingProofs = [];\n  allProofs.forEach((proof, index) => {\n    const { state } = proofStates[index];\n    if (state === _cashu_cashu_ts__WEBPACK_IMPORTED_MODULE_2__.CheckStateEnum.SPENT) {\n      spentProofs.push(proof);\n    } else if (state === _cashu_cashu_ts__WEBPACK_IMPORTED_MODULE_2__.CheckStateEnum.UNSPENT) {\n      unspentProofs.push(proof);\n    } else {\n      pendingProofs.push(proof);\n    }\n  });\n  const walletChange = {\n    mint,\n    store: unspentProofs,\n    destroy: spentProofs\n  };\n  onResult?.(walletChange);\n  const _totalSpentProofs = spentProofs.reduce((acc, proof) => acc + proof.amount, 0);\n  if (walletChange.destroy?.length === 0) return;\n  walletChange.store?.push(...pendingProofs);\n  const totalPendingProofs = pendingProofs.reduce((acc, proof) => acc + proof.amount, 0);\n  wallet.state.reserveProofs(pendingProofs, totalPendingProofs);\n  return wallet.state.update(walletChange, \"Consolidate\");\n}\n\n// src/wallets/cashu/pay/ln.ts\n\n\n// src/wallets/cashu/wallet/fee.ts\nfunction calculateFee(intendedAmount, providedProofs, returnedProofs) {\n  const totalProvided = providedProofs.reduce((acc, p) => acc + p.amount, 0);\n  const totalReturned = returnedProofs.reduce((acc, p) => acc + p.amount, 0);\n  const totalFee = totalProvided - intendedAmount - totalReturned;\n  if (totalFee < 0) {\n    throw new Error(\"Invalid fee calculation: received more proofs than sent to mint\");\n  }\n  return totalFee;\n}\n\n// src/wallets/cashu/wallet/effect.ts\nasync function withProofReserve(wallet, cashuWallet, mint, amountWithFees, amountWithoutFees, cb) {\n  cashuWallet ??= await wallet.getCashuWallet(mint);\n  const availableMintProofs = wallet.state.getProofs({ mint, onlyAvailable: true });\n  const proofs = cashuWallet.selectProofsToSend(availableMintProofs, amountWithFees);\n  const fetchedAmount = proofs.send.reduce((a, b) => a + b.amount, 0);\n  if (fetchedAmount < amountWithFees) return null;\n  wallet.state.reserveProofs(proofs.send, amountWithFees);\n  let cbResult = null;\n  let proofsChange = null;\n  let updateRes = null;\n  try {\n    cbResult = await cb(proofs.send, availableMintProofs);\n    if (!cbResult) return null;\n    proofsChange = {\n      mint,\n      store: cbResult.change,\n      destroy: proofs.send\n    };\n    updateRes = await wallet.state.update(proofsChange);\n  } catch (e) {\n    wallet.state.unreserveProofs(proofs.send, amountWithFees, \"available\");\n    throw e;\n  }\n  if (!cbResult) return null;\n  return {\n    result: cbResult.result,\n    proofsChange,\n    stateUpdate: updateRes,\n    mint,\n    fee: calculateFee(amountWithoutFees, proofs.send, cbResult.change)\n  };\n}\n\n// src/wallets/cashu/pay/ln.ts\nasync function payLn(wallet, pr, { amount, unit } = {}) {\n  let invoiceAmount = getBolt11Amount(pr);\n  if (!invoiceAmount) throw new Error(\"invoice amount is required\");\n  invoiceAmount = invoiceAmount / 1e3;\n  if (amount && unit) {\n    if (unit === \"msat\") {\n      amount = amount / 1e3;\n    }\n  }\n  const eligibleMints = wallet.getMintsWithBalance(invoiceAmount + 3);\n  if (!eligibleMints.length) {\n    return null;\n  }\n  for (const mint of eligibleMints) {\n    try {\n      const result = await executePayment(mint, pr, amount ?? invoiceAmount, wallet);\n      if (result) {\n        if (amount) {\n          result.fee = calculateFee(\n            amount,\n            result.proofsChange?.destroy ?? [],\n            result.proofsChange?.store ?? []\n          );\n        }\n        return result;\n      }\n    } catch (error) {\n      wallet.warn(`Failed to execute payment with min ${mint}: ${error}`);\n    }\n  }\n  return null;\n}\nasync function executePayment(mint, pr, amountWithoutFees, wallet) {\n  const cashuWallet = await wallet.getCashuWallet(mint);\n  try {\n    const meltQuote = await cashuWallet.createMeltQuote(pr);\n    const amountToSend = meltQuote.amount + meltQuote.fee_reserve;\n    const result = await withProofReserve(\n      wallet,\n      cashuWallet,\n      mint,\n      amountToSend,\n      amountWithoutFees,\n      async (proofsToUse, _allOurProofs) => {\n        const meltResult = await cashuWallet.meltProofs(meltQuote, proofsToUse);\n        if (meltResult.quote.state === _cashu_cashu_ts__WEBPACK_IMPORTED_MODULE_2__.MeltQuoteState.PAID) {\n          return {\n            result: {\n              preimage: meltResult.quote.payment_preimage ?? \"\"\n            },\n            change: meltResult.change\n          };\n        }\n        return null;\n      }\n    );\n    return result;\n  } catch (e) {\n    if (e instanceof Error) {\n      if (e.message.match(/already spent/i)) {\n        setTimeout(() => {\n          consolidateMintTokens(mint, wallet);\n        }, 2500);\n      } else {\n        throw e;\n      }\n    }\n    return null;\n  }\n}\n\n// src/wallets/cashu/pay/nut.ts\n\n\n// src/utils/cashu.ts\nfunction ensureIsCashuPubkey(pubkey) {\n  if (!pubkey) return;\n  let _pubkey = pubkey;\n  if (_pubkey.length === 64) _pubkey = `02${_pubkey}`;\n  if (_pubkey.length !== 66) throw new Error(\"Invalid pubkey\");\n  return _pubkey;\n}\nasync function mintProofs(wallet, quote, amount, mint, p2pk) {\n  const mintTokenAttempt = (resolve, reject, attempt) => {\n    const pubkey = ensureIsCashuPubkey(p2pk);\n    wallet.mintProofs(amount, quote.quote, { pubkey }).then((mintProofs2) => {\n      console.debug(\"minted tokens\", mintProofs2);\n      resolve({\n        proofs: mintProofs2,\n        mint\n      });\n    }).catch((e) => {\n      attempt++;\n      if (attempt <= 3) {\n        console.error(\"error minting tokens\", e);\n        setTimeout(() => mintTokenAttempt(resolve, reject, attempt), attempt * 1500);\n      } else {\n        reject(e);\n      }\n    });\n  };\n  return new Promise((resolve, reject) => {\n    mintTokenAttempt(resolve, reject, 0);\n  });\n}\n\n// src/wallets/cashu/pay/nut.ts\nasync function createToken(wallet, amount, recipientMints, p2pk) {\n  p2pk = ensureIsCashuPubkey(p2pk);\n  const myMintsWithEnoughBalance = wallet.getMintsWithBalance(amount);\n  const hasRecipientMints = recipientMints && recipientMints.length > 0;\n  const mintsInCommon = hasRecipientMints ? findMintsInCommon([recipientMints, myMintsWithEnoughBalance]) : myMintsWithEnoughBalance;\n  for (const mint of mintsInCommon) {\n    try {\n      const res = await createTokenInMint(wallet, mint, amount, p2pk);\n      if (res) {\n        return res;\n      }\n    } catch (_e) {\n    }\n  }\n  if (hasRecipientMints) {\n    return await createTokenWithMintTransfer(wallet, amount, recipientMints, p2pk);\n  }\n  return null;\n}\nasync function createTokenInMint(wallet, mint, amount, p2pk) {\n  const cashuWallet = await wallet.getCashuWallet(mint);\n  try {\n    const result = await withProofReserve(\n      wallet,\n      cashuWallet,\n      mint,\n      amount,\n      amount,\n      async (proofsToUse, allOurProofs) => {\n        const sendResult = await cashuWallet.send(amount, proofsToUse, {\n          pubkey: p2pk,\n          proofsWeHave: allOurProofs\n        });\n        return {\n          result: {\n            proofs: sendResult.send,\n            mint\n          },\n          change: sendResult.keep,\n          mint\n        };\n      }\n    );\n    return result;\n  } catch (_e) {\n  }\n  return null;\n}\nasync function createTokenWithMintTransfer(wallet, amount, recipientMints, p2pk) {\n  const generateQuote = async () => {\n    const generateQuoteFromSomeMint = async (mint3) => {\n      const targetMintWallet3 = await walletForMint(mint3);\n      if (!targetMintWallet3) throw new Error(`unable to load wallet for mint ${mint3}`);\n      const quote3 = await targetMintWallet3.createMintQuote(amount);\n      return { quote: quote3, mint: mint3, targetMintWallet: targetMintWallet3 };\n    };\n    const quotesPromises = recipientMints.map(generateQuoteFromSomeMint);\n    const { quote: quote2, mint: mint2, targetMintWallet: targetMintWallet2 } = await Promise.any(quotesPromises);\n    if (!quote2) {\n      throw new Error(\"failed to get quote from any mint\");\n    }\n    return { quote: quote2, mint: mint2, targetMintWallet: targetMintWallet2 };\n  };\n  const { quote, mint: targetMint, targetMintWallet } = await generateQuote();\n  if (!quote) {\n    return null;\n  }\n  const invoiceAmount = getBolt11Amount(quote.request);\n  if (!invoiceAmount) throw new Error(\"invoice amount is required\");\n  const invoiceAmountInSat = invoiceAmount / 1e3;\n  if (invoiceAmountInSat > amount)\n    throw new Error(`invoice amount is more than the amount passed in (${invoiceAmountInSat} vs ${amount})`);\n  const payLNResult = await payLn(wallet, quote.request, { amount });\n  if (!payLNResult) {\n    return null;\n  }\n  const { proofs, mint } = await mintProofs(targetMintWallet, quote, amount, targetMint, p2pk);\n  return {\n    ...payLNResult,\n    result: { proofs, mint },\n    fee: payLNResult.fee\n  };\n}\nfunction findMintsInCommon(mintCollections) {\n  const mintCounts = /* @__PURE__ */ new Map();\n  for (const mints of mintCollections) {\n    for (const mint of mints) {\n      const normalizedMint = (0,_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.normalizeUrl)(mint);\n      if (!mintCounts.has(normalizedMint)) {\n        mintCounts.set(normalizedMint, 1);\n      } else {\n        mintCounts.set(normalizedMint, mintCounts.get(normalizedMint) + 1);\n      }\n    }\n  }\n  const commonMints = [];\n  for (const [mint, count] of mintCounts.entries()) {\n    if (count === mintCollections.length) {\n      commonMints.push(mint);\n    }\n  }\n  return commonMints;\n}\n\n// src/wallets/cashu/wallet/payment.ts\nvar PaymentHandler = class {\n  wallet;\n  constructor(wallet) {\n    this.wallet = wallet;\n  }\n  /**\n   * Pay a LN invoice with this wallet. This will used cashu proofs to pay a bolt11.\n   */\n  async lnPay(payment, createTxEvent = true) {\n    if (!payment.pr) throw new Error(\"pr is required\");\n    const invoiceAmount = getBolt11Amount(payment.pr);\n    if (!invoiceAmount) throw new Error(\"invoice amount is required\");\n    if (payment.amount && invoiceAmount > payment.amount) {\n      throw new Error(\"invoice amount is more than the amount passed in\");\n    }\n    const res = await payLn(this.wallet, payment.pr, {\n      amount: payment.amount,\n      unit: payment.unit\n    });\n    if (!res?.result?.preimage) return;\n    if (createTxEvent) {\n      createOutTxEvent(this.wallet.ndk, payment, res, this.wallet.relaySet);\n    }\n    return res.result;\n  }\n  /**\n   * Swaps tokens to a specific amount, optionally locking to a p2pk.\n   */\n  async cashuPay(payment) {\n    const satPayment = { ...payment };\n    if (satPayment.unit?.startsWith(\"msat\")) {\n      satPayment.amount = satPayment.amount / 1e3;\n      satPayment.unit = \"sat\";\n    }\n    let createResult = await createToken(this.wallet, satPayment.amount, payment.mints, payment.p2pk);\n    if (!createResult) {\n      if (payment.allowIntramintFallback) {\n        createResult = await createToken(this.wallet, satPayment.amount, void 0, payment.p2pk);\n      }\n      if (!createResult) {\n        return;\n      }\n    }\n    createOutTxEvent(this.wallet.ndk, satPayment, createResult, this.wallet.relaySet);\n    return createResult.result;\n  }\n};\n\n// src/wallets/cashu/wallet/state/balance.ts\nfunction getBalance(opts) {\n  const proofs = this.getProofEntries(opts);\n  return proofs.reduce((sum, proof) => sum + proof.proof.amount, 0);\n}\nfunction getMintsBalances({ onlyAvailable } = { onlyAvailable: true }) {\n  const balances = {};\n  const proofs = this.getProofEntries({ onlyAvailable });\n  for (const proof of proofs) {\n    if (!proof.mint) continue;\n    balances[proof.mint] ??= 0;\n    balances[proof.mint] += proof.proof.amount;\n  }\n  return balances;\n}\n\n// src/wallets/cashu/wallet/state/proofs.ts\nfunction addProof(proofEntry) {\n  this.proofs.set(proofEntry.proof.C, proofEntry);\n  this.journal.push({\n    memo: \"Added proof\",\n    timestamp: Date.now(),\n    metadata: {\n      type: \"proof\",\n      id: proofEntry.proof.C,\n      amount: proofEntry.proof.amount,\n      mint: proofEntry.mint\n    }\n  });\n}\nfunction reserveProofs(proofs, amount) {\n  for (const proof of proofs) {\n    this.updateProof(proof, { state: \"reserved\" });\n  }\n  this.reserveAmounts.push(amount);\n}\nfunction unreserveProofs(proofs, amount, newState) {\n  for (const proof of proofs) {\n    this.updateProof(proof, { state: newState });\n  }\n  const index = this.reserveAmounts.indexOf(amount);\n  if (index !== -1) {\n    this.reserveAmounts.splice(index, 1);\n  } else {\n    throw new Error(`BUG: Amount ${amount} not found in reserveAmounts`);\n  }\n}\nfunction getProofEntries(opts = {}) {\n  const proofs = /* @__PURE__ */ new Map();\n  const validStates = /* @__PURE__ */ new Set([\"available\"]);\n  let { mint, onlyAvailable, includeDeleted } = opts;\n  onlyAvailable ??= true;\n  if (!onlyAvailable) validStates.add(\"reserved\");\n  if (includeDeleted) validStates.add(\"deleted\");\n  for (const proofEntry of this.proofs.values()) {\n    if (mint && proofEntry.mint !== mint) continue;\n    if (!validStates.has(proofEntry.state)) continue;\n    if (!proofEntry.proof) continue;\n    proofs.set(proofEntry.proof.C, proofEntry);\n  }\n  return Array.from(proofs.values());\n}\nfunction updateProof(proof, state) {\n  const proofC = proof.C;\n  const currentState = this.proofs.get(proofC);\n  if (!currentState) throw new Error(\"Proof not found\");\n  const newState = { ...currentState, ...state };\n  this.proofs.set(proofC, newState);\n  this.journal.push({\n    memo: `Updated proof state: ${JSON.stringify(state)}`,\n    timestamp: Date.now(),\n    metadata: {\n      type: \"proof\",\n      id: proofC,\n      amount: proof.amount,\n      mint: currentState.mint\n    }\n  });\n}\n\n// src/wallets/cashu/wallet/state/token.ts\nfunction addToken(token) {\n  if (!token.mint) throw new Error(\"BUG: Token has no mint\");\n  const currentEntry = this.tokens.get(token.id);\n  const state = currentEntry?.state ?? \"available\";\n  this.tokens.set(token.id, { token, state });\n  let _added = 0;\n  let _invalid = 0;\n  for (const proof of token.proofs) {\n    const val = maybeAssociateProofWithToken(this, proof, token, state);\n    if (val === false) {\n      _invalid++;\n    } else {\n      _added++;\n    }\n  }\n}\nfunction maybeAssociateProofWithToken(walletState, proof, token, state) {\n  const proofC = proof.C;\n  const proofEntry = walletState.proofs.get(proofC);\n  if (!proofEntry) {\n    walletState.addProof({\n      mint: token.mint,\n      state,\n      tokenId: token.id,\n      timestamp: token.created_at,\n      proof\n    });\n    return true;\n  }\n  if (proofEntry.tokenId) {\n    if (proofEntry.tokenId === token.id) {\n      return null;\n    }\n    const existingTokenEntry = walletState.tokens.get(proofEntry.tokenId);\n    if (!existingTokenEntry) {\n      throw new Error(\n        `BUG: Token id ${proofEntry.tokenId} not found, was expected to be associated with proof ${proofC}`\n      );\n    }\n    const existingToken = existingTokenEntry.token;\n    if (existingToken) {\n      if (existingToken.created_at && (!token.created_at || token.created_at < existingToken.created_at)) {\n        return false;\n      }\n    }\n    walletState.updateProof(proof, { tokenId: token.id, state });\n    return true;\n  }\n  walletState.updateProof(proof, { tokenId: token.id, state });\n  return true;\n}\nfunction removeTokenId(tokenId) {\n  const currentEntry = this.tokens.get(tokenId) || {};\n  this.tokens.set(tokenId, { ...currentEntry, state: \"deleted\" });\n  for (const proofEntry of this.proofs.values()) {\n    const { proof } = proofEntry;\n    if (proofEntry.tokenId === tokenId) {\n      if (!proof) {\n        throw new Error(\"BUG: Proof entry has no proof\");\n      }\n      this.updateProof(proof, { state: \"deleted\" });\n    }\n  }\n}\n\n// src/wallets/cashu/wallet/state/update.ts\n\nasync function update(stateChange, _memo) {\n  updateInternalState(this, stateChange);\n  this.wallet.emit(\"balance_updated\");\n  return updateExternalState(this, stateChange);\n}\nfunction updateInternalState(walletState, stateChange) {\n  if (stateChange.store && stateChange.store.length > 0) {\n    for (const proof of stateChange.store) {\n      walletState.addProof({\n        mint: stateChange.mint,\n        state: \"available\",\n        proof,\n        timestamp: Date.now()\n      });\n    }\n  }\n  if (stateChange.destroy && stateChange.destroy.length > 0) {\n    for (const proof of stateChange.destroy) {\n      walletState.updateProof(proof, { state: \"deleted\" });\n    }\n  }\n  if (stateChange.reserve && stateChange.reserve.length > 0) {\n    throw new Error(\"BUG: Proofs should not be reserved via update\");\n  }\n}\nasync function updateExternalState(walletState, stateChange) {\n  const newState = calculateNewState(walletState, stateChange);\n  if (newState.deletedTokenIds.size > 0) {\n    const deleteEvent = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKEvent(walletState.wallet.ndk, {\n      kind: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.EventDeletion,\n      tags: [\n        [\"k\", _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.CashuToken.toString()],\n        ...Array.from(newState.deletedTokenIds).map((id) => [\"e\", id])\n      ]\n    });\n    await deleteEvent.sign();\n    publishWithRetry(walletState, deleteEvent, walletState.wallet.relaySet);\n    for (const tokenId of newState.deletedTokenIds) {\n      walletState.removeTokenId(tokenId);\n    }\n  }\n  const res = {};\n  if (newState.saveProofs.length > 0) {\n    const newToken = await createTokenEvent(walletState, stateChange.mint, newState);\n    res.created = newToken;\n  }\n  return res;\n}\nasync function publishWithRetry(walletState, event, relaySet, retryTimeout = 10 * 1e3) {\n  let publishResult;\n  publishResult = await event.publish(relaySet);\n  let type;\n  if (event.kind === _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.EventDeletion) type = \"deletion\";\n  if (event.kind === _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.CashuToken) type = \"token\";\n  if (event.kind === _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.CashuWallet) type = \"wallet\";\n  const journalEntryMetadata = {\n    type,\n    id: event.id,\n    relayUrl: relaySet?.relayUrls.join(\",\")\n  };\n  if (publishResult) {\n    walletState.journal.push({\n      memo: `Publish kind:${event.kind} succeesfully`,\n      timestamp: Date.now(),\n      metadata: journalEntryMetadata\n    });\n    return publishResult;\n  }\n  walletState.journal.push({\n    memo: \"Publish failed\",\n    timestamp: Date.now(),\n    metadata: journalEntryMetadata\n  });\n  setTimeout(() => {\n    publishWithRetry(walletState, event, relaySet, retryTimeout);\n  }, retryTimeout);\n}\nasync function createTokenEvent(walletState, mint, newState) {\n  const newToken = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKCashuToken(walletState.wallet.ndk);\n  newToken.mint = mint;\n  newToken.proofs = newState.saveProofs;\n  await newToken.toNostrEvent();\n  walletState.addToken(newToken);\n  newToken.deletedTokens = Array.from(newState.deletedTokenIds);\n  await newToken.sign();\n  walletState.addToken(newToken);\n  publishWithRetry(walletState, newToken, walletState.wallet.relaySet);\n  return newToken;\n}\nfunction calculateNewState(walletState, stateChange) {\n  const destroyProofs = /* @__PURE__ */ new Set();\n  for (const proof of stateChange.destroy || []) destroyProofs.add(proof.C);\n  const proofsToStore = /* @__PURE__ */ new Map();\n  let tokensToDelete;\n  for (const proof of stateChange.store || []) proofsToStore.set(proof.C, proof);\n  tokensToDelete = getAffectedTokens(walletState, stateChange);\n  for (const token of tokensToDelete.values()) {\n    for (const proof of token.proofs) {\n      if (destroyProofs.has(proof.C)) continue;\n      proofsToStore.set(proof.C, proof);\n    }\n  }\n  return {\n    deletedTokenIds: new Set(tokensToDelete.keys()),\n    deletedProofs: destroyProofs,\n    reserveProofs: [],\n    saveProofs: Array.from(proofsToStore.values())\n  };\n}\nfunction getAffectedTokens(walletState, stateChange) {\n  const tokens = /* @__PURE__ */ new Map();\n  for (const proof of stateChange.destroy || []) {\n    const proofEntry = walletState.proofs.get(proof.C);\n    if (!proofEntry) {\n      continue;\n    }\n    const tokenId = proofEntry.tokenId;\n    if (!tokenId) {\n      continue;\n    }\n    const tokenEntry = walletState.tokens.get(tokenId);\n    if (!tokenEntry?.token) {\n      continue;\n    }\n    tokens.set(tokenId, tokenEntry.token);\n  }\n  return tokens;\n}\n\n// src/wallets/cashu/wallet/state/index.ts\nvar WalletState = class {\n  constructor(wallet, reservedProofCs = /* @__PURE__ */ new Set()) {\n    this.wallet = wallet;\n    this.reservedProofCs = reservedProofCs;\n  }\n  /**\n   * the amounts that are intended to be reserved\n   * this is the net amount we are trying to pay out,\n   * excluding fees and coin sizes\n   * e.g. we might want to pay 5 sats, have 2 sats in fees\n   * and we're using 2 inputs that add up to 8, the reserve amount is 5\n   * while the reserve proofs add up to 8\n   */\n  reserveAmounts = [];\n  /**\n   * Source of truth of the proofs this wallet has/had.\n   */\n  proofs = /* @__PURE__ */ new Map();\n  /**\n   * The tokens that are known to this wallet.\n   */\n  tokens = /* @__PURE__ */ new Map();\n  journal = [];\n  /** This is a debugging function that dumps the state of the wallet */\n  dump() {\n    const res = {\n      proofs: Array.from(this.proofs.values()),\n      balances: this.getMintsBalance(),\n      totalBalance: this.getBalance(),\n      tokens: Array.from(this.tokens.values())\n    };\n    return res;\n  }\n  /***************************\n   * Tokens\n   ***************************/\n  addToken = addToken.bind(this);\n  removeTokenId = removeTokenId.bind(this);\n  /***************************\n   * Proof management\n   ***************************/\n  addProof = addProof.bind(this);\n  /**\n   * Reserves a number of selected proofs and a specific amount.\n   *\n   * The amount and total of the proofs don't need to match. We\n   * might want to use 5 sats and have 2 proofs of 4 sats each.\n   * In that case, the reserve amount is 5, while the reserve proofs\n   * add up to 8.\n   */\n  reserveProofs = reserveProofs.bind(this);\n  /**\n   * Unreserves a number of selected proofs and a specific amount.\n   */\n  unreserveProofs = unreserveProofs.bind(this);\n  /**\n   * Returns all proof entries, optionally filtered by mint and state\n   */\n  getProofEntries = getProofEntries.bind(this);\n  /**\n   * Updates information about a proof\n   */\n  updateProof = updateProof.bind(this);\n  /**\n   * Returns all proofs, optionally filtered by mint and state\n   * @param opts.mint - optional mint to filter by\n   * @param opts.onlyAvailable - only include available proofs @default true\n   * @param opts.includeDeleted - include deleted proofs @default false\n   */\n  getProofs(opts) {\n    return this.getProofEntries(opts).map((entry) => entry.proof);\n  }\n  getTokens(opts = { onlyAvailable: true }) {\n    const proofEntries = this.getProofEntries(opts);\n    const tokens = /* @__PURE__ */ new Map();\n    for (const proofEntry of proofEntries) {\n      const tokenId = proofEntry.tokenId ?? null;\n      const current = tokens.get(tokenId) ?? {\n        tokenId,\n        mint: proofEntry.mint,\n        proofEntries: []\n      };\n      current.token ??= tokenId ? this.tokens.get(tokenId)?.token : void 0;\n      current.proofEntries.push(proofEntry);\n      tokens.set(tokenId, current);\n    }\n    return tokens;\n  }\n  /**\n   * Gets a list of proofs for each mint\n   * @returns\n   */\n  getMintsProofs({\n    validStates = /* @__PURE__ */ new Set([\"available\"])\n  } = {}) {\n    const mints = /* @__PURE__ */ new Map();\n    for (const entry of this.proofs.values()) {\n      if (!entry.mint || !entry.proof) continue;\n      if (!validStates.has(entry.state)) continue;\n      const current = mints.get(entry.mint) || [];\n      current.push(entry.proof);\n      mints.set(entry.mint, current);\n    }\n    return mints;\n  }\n  /***************************\n   * Balance\n   ***************************/\n  /**\n   * Returns the balance of the wallet, optionally filtered by mint and state\n   *\n   * @params opts.mint - optional mint to filter by\n   * @params opts.onlyAvailable - only include available proofs @default true\n   */\n  getBalance = getBalance.bind(this);\n  /**\n   * Returns the balances of the different mints\n   *\n   * @params opts.onlyAvailable - only include available proofs @default true\n   */\n  getMintsBalance = getMintsBalances.bind(this);\n  /***************************\n   * State update\n   ***************************/\n  update = update.bind(this);\n};\n\n// src/wallets/cashu/wallet/index.ts\nvar _startTime = Date.now();\nfunction log(_msg) {\n}\nvar NDKCashuWallet = class _NDKCashuWallet extends NDKWallet {\n  get type() {\n    return \"nip-60\";\n  }\n  _p2pk;\n  sub;\n  status = \"initial\" /* INITIAL */;\n  static kind = _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.CashuWallet;\n  static kinds = [_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.CashuWallet];\n  mints = [];\n  privkeys = /* @__PURE__ */ new Map();\n  signer;\n  walletId = \"nip-60\";\n  depositMonitor = new NDKCashuDepositMonitor();\n  /**\n   * Warnings that have been raised\n   */\n  warnings = [];\n  paymentHandler;\n  state;\n  relaySet;\n  constructor(ndk) {\n    super(ndk);\n    this.ndk = ndk;\n    this.paymentHandler = new PaymentHandler(this);\n    this.state = new WalletState(this);\n    log(\"NDK Cashu Wallet constructor\");\n  }\n  /**\n   * Generates a backup event for this wallet\n   */\n  async backup(publish = true) {\n    log(\"NDK Cashu Wallet generating backup\");\n    if (this.privkeys.size === 0) throw new Error(\"no privkey to backup\");\n    const backup = new NDKCashuWalletBackup(this.ndk);\n    const privkeys = [];\n    for (const [_pubkey, signer] of this.privkeys.entries()) {\n      privkeys.push(signer.privateKey);\n    }\n    backup.privkeys = privkeys;\n    backup.mints = this.mints;\n    if (publish) backup.save(this.relaySet);\n    return backup;\n  }\n  consolidateTokens = consolidateTokens.bind(this);\n  /**\n   * Generates nuts that can be used to send to someone.\n   *\n   * Note that this function does not send anything, it just generates a specific amount of proofs.\n   * @param amounts\n   * @returns\n   */\n  async mintNuts(amounts) {\n    let result;\n    const totalAmount = amounts.reduce((acc, amount) => acc + amount, 0);\n    for (const mint of this.mints) {\n      const wallet = await this.getCashuWallet(mint);\n      const mintProofs2 = await this.state.getProofs({ mint });\n      result = await wallet.send(totalAmount, mintProofs2, {\n        proofsWeHave: mintProofs2,\n        includeFees: true,\n        outputAmounts: {\n          sendAmounts: amounts\n        }\n      });\n      if (result.send.length > 0) {\n        const change = { store: result?.keep ?? [], destroy: result.send, mint };\n        const updateRes = await this.state.update(change);\n        createOutTxEvent(\n          this.ndk,\n          {\n            paymentDescription: \"minted nuts\",\n            amount: amounts.reduce((acc, amount) => acc + amount, 0)\n          },\n          {\n            result: { proofs: result.send, mint },\n            proofsChange: change,\n            stateUpdate: updateRes,\n            mint,\n            fee: 0\n          },\n          this.relaySet\n        );\n        this.emit(\"balance_updated\");\n        return result;\n      }\n    }\n  }\n  /**\n   * Loads a wallet information from an event\n   * @param event\n   */\n  async loadFromEvent(event) {\n    const _event = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKEvent(event.ndk, event.rawEvent());\n    await _event.decrypt();\n    const content = JSON.parse(_event.content);\n    for (const tag of content) {\n      if (tag[0] === \"mint\") {\n        this.mints.push(tag[1]);\n      } else if (tag[0] === \"privkey\") {\n        await this.addPrivkey(tag[1]);\n      }\n    }\n    await this.getP2pk();\n  }\n  static async from(event) {\n    if (!event.ndk) throw new Error(\"no ndk instance on event\");\n    const wallet = new _NDKCashuWallet(event.ndk);\n    await wallet.loadFromEvent(event);\n    return wallet;\n  }\n  /**\n   * Starts monitoring the wallet.\n   *\n   * Use `since` to start syncing state from a specific timestamp. This should be\n   * used by storing at the app level a time in which we know we were able to communicate\n   * with the relays, for example, by saving the time the wallet has emitted a \"ready\" event.\n   */\n  start(opts) {\n    log(\"NDK Cashu Wallet starting\");\n    const activeUser = this.ndk?.activeUser;\n    if (this.status === \"ready\" /* READY */) return;\n    this.status = \"loading\" /* LOADING */;\n    const pubkey = opts?.pubkey ?? activeUser?.pubkey;\n    if (!pubkey) throw new Error(\"no pubkey\");\n    const filters = [\n      { kinds: [_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.CashuToken], authors: [pubkey] },\n      { kinds: [_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.CashuQuote], authors: [pubkey] },\n      {\n        kinds: [_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.EventDeletion],\n        authors: [pubkey],\n        \"#k\": [_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.CashuToken.toString()]\n      }\n    ];\n    if (opts?.since) {\n      filters[0].since = opts.since;\n      filters[1].since = opts.since;\n      filters[2].since = opts.since;\n    }\n    const subOpts = opts ?? {};\n    subOpts.subId ??= \"cashu-wallet-state\";\n    log(`Subscribing to ${JSON.stringify(filters)} and opts ${JSON.stringify(opts)}`);\n    this.sub = this.ndk.subscribe(filters, { ...subOpts, relaySet: this.relaySet }, false);\n    this.sub.on(\"event:dup\", eventDupHandler.bind(this));\n    this.sub.on(\"event\", (event) => {\n      log(`Event ${event.kind} received`);\n      eventHandler.call(this, event);\n    });\n    this.sub.on(\"eose\", () => {\n      log(\"Eose received\");\n      this.emit(\"ready\");\n      this.status = \"ready\" /* READY */;\n    });\n    this.sub.start(true);\n  }\n  stop() {\n    this.sub?.stop();\n    this.status = \"initial\" /* INITIAL */;\n  }\n  /**\n   * Returns the p2pk of this wallet or generates a new one if we don't have one\n   */\n  async getP2pk() {\n    if (this._p2pk) return this._p2pk;\n    if (this.privkeys.size === 0) {\n      const signer = _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKPrivateKeySigner.generate();\n      await this.addPrivkey(signer.privateKey);\n    }\n    return this.p2pk;\n  }\n  /**\n   * If this wallet has access to more than one privkey, this will return all of them.\n   */\n  get p2pks() {\n    return Array.from(this.privkeys.keys());\n  }\n  async addPrivkey(privkey) {\n    const signer = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKPrivateKeySigner(privkey);\n    const user = await signer.user();\n    this.privkeys.set(user.pubkey, signer);\n    this._p2pk ??= user.pubkey;\n    return this._p2pk;\n  }\n  get p2pk() {\n    if (!this._p2pk) throw new Error(\"p2pk not set\");\n    return this._p2pk;\n  }\n  set p2pk(pubkey) {\n    if (this.privkeys.has(pubkey)) {\n      this.signer = this.privkeys.get(pubkey);\n      this.p2pk = pubkey;\n    } else {\n      throw new Error(`privkey for ${pubkey} not found`);\n    }\n  }\n  /**\n   * Generates the payload for a wallet event\n   */\n  walletPayload() {\n    const privkeys = Array.from(this.privkeys.values()).map((signer) => signer.privateKey);\n    return payloadForEvent(privkeys, this.mints);\n  }\n  async publish() {\n    const event = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKEvent(this.ndk, {\n      content: JSON.stringify(this.walletPayload()),\n      kind: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.CashuWallet\n    });\n    const user = await this.ndk?.signer?.user();\n    await event.encrypt(user, void 0, \"nip44\");\n    return event.publish(this.relaySet);\n  }\n  /**\n   * Prepares a deposit\n   * @param amount\n   * @param mint\n   *\n   * @example\n   * const wallet = new NDKCashuWallet(...);\n   * const deposit = wallet.deposit(1000, \"https://mint.example.com\", \"sats\");\n   * deposit.on(\"success\", (token) => {\n   * });\n   * deposit.on(\"error\", (error) => {\n   * });\n   *\n   * // start monitoring the deposit\n   * deposit.start();\n   */\n  deposit(amount, mint) {\n    const deposit = new NDKCashuDeposit(this, amount, mint);\n    deposit.on(\"success\", (token) => {\n      this.state.addToken(token);\n    });\n    return deposit;\n  }\n  /**\n   * Receives a token and adds it to the wallet\n   * @param token\n   * @returns the token event that was created\n   */\n  async receiveToken(token, description) {\n    const { mint } = (0,_cashu_cashu_ts__WEBPACK_IMPORTED_MODULE_2__.getDecodedToken)(token);\n    const wallet = await this.getCashuWallet(mint);\n    const proofs = await wallet.receive(token);\n    const updateRes = await this.state.update({\n      store: proofs,\n      mint\n    });\n    const tokenEvent = updateRes.created;\n    createInTxEvent(this.ndk, proofs, mint, updateRes, { description }, this.relaySet);\n    return tokenEvent;\n  }\n  /**\n   * Pay a LN invoice with this wallet\n   */\n  async lnPay(payment, createTxEvent = true) {\n    return this.paymentHandler.lnPay(payment, createTxEvent);\n  }\n  /**\n   * Swaps tokens to a specific amount, optionally locking to a p2pk.\n   *\n   * This function has side effects:\n   * - It swaps tokens at the mint\n   * - It updates the wallet state (deletes affected tokens, might create new ones)\n   * - It creates a wallet transaction event\n   *\n   * This function returns the proofs that need to be sent to the recipient.\n   * @param amount\n   */\n  async cashuPay(payment) {\n    return this.paymentHandler.cashuPay(payment);\n  }\n  wallets = /* @__PURE__ */ new Map();\n  async redeemNutzaps(nutzaps, privkey, { mint, proofs, cashuWallet }) {\n    if (cashuWallet) {\n      mint ??= cashuWallet.mint.mintUrl;\n    } else {\n      if (!mint) throw new Error(\"mint not set\");\n      cashuWallet = await this.getCashuWallet(mint);\n    }\n    if (!mint) throw new Error(\"mint not set\");\n    if (!proofs) throw new Error(\"proofs not set\");\n    try {\n      const proofsWeHave = this.state.getProofs({ mint });\n      const res = await cashuWallet.receive({ proofs, mint }, { proofsWeHave, privkey });\n      const receivedAmount = proofs.reduce((acc, proof) => acc + proof.amount, 0);\n      const redeemedAmount = res.reduce((acc, proof) => acc + proof.amount, 0);\n      const fee = receivedAmount - redeemedAmount;\n      const updateRes = await this.state.update({\n        store: res,\n        mint\n      });\n      createInTxEvent(this.ndk, res, mint, updateRes, { nutzaps, fee }, this.relaySet);\n      return receivedAmount;\n    } catch (e) {\n      console.error(\n        \"error redeeming nutzaps\",\n        nutzaps.map((n) => n.encode()),\n        e\n      );\n      throw e;\n    }\n  }\n  warn(msg, event, relays) {\n    relays ??= event?.onRelays;\n    this.warnings.push({ msg, event, relays });\n    this.emit(\"warning\", { msg, event, relays });\n  }\n  get balance() {\n    return {\n      amount: this.state.getBalance({ onlyAvailable: true })\n    };\n  }\n  /**\n   * Gets the total balance for a specific mint, including reserved proofs\n   */\n  mintBalance(mint) {\n    return this.mintBalances[mint] || 0;\n  }\n  /**\n   * Gets all tokens, grouped by mint with their total balances\n   */\n  get mintBalances() {\n    return this.state.getMintsBalance({ onlyAvailable: true });\n  }\n  /**\n   * Returns a list of mints that have enough available balance (excluding reserved proofs)\n   * to cover the specified amount\n   */\n  getMintsWithBalance(amount) {\n    const availableBalances = this.state.getMintsBalance({ onlyAvailable: true });\n    return Object.entries(availableBalances).filter(([_, balance]) => balance >= amount).map(([mint]) => mint);\n  }\n};\nvar NDKCashuWalletBackup = class _NDKCashuWalletBackup extends _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKEvent {\n  privkeys = [];\n  mints = [];\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.CashuWalletBackup;\n  }\n  static async from(event) {\n    if (!event.ndk) throw new Error(\"no ndk instance on event\");\n    const backup = new _NDKCashuWalletBackup(event.ndk, event);\n    try {\n      await backup.decrypt();\n      const content = JSON.parse(backup.content);\n      for (const tag of content) {\n        if (tag[0] === \"mint\") {\n          backup.mints.push(tag[1]);\n        } else if (tag[0] === \"privkey\") {\n          backup.privkeys.push(tag[1]);\n        }\n      }\n    } catch (e) {\n      console.error(\"error decrypting backup event\", backup.encode(), e);\n      return;\n    }\n    return backup;\n  }\n  async save(relaySet) {\n    if (!this.ndk) throw new Error(\"no ndk instance\");\n    if (!this.privkeys.length) throw new Error(\"no privkeys\");\n    this.content = JSON.stringify(payloadForEvent(this.privkeys, this.mints));\n    await this.encrypt(this.ndk.activeUser, void 0, \"nip44\");\n    return this.publish(relaySet);\n  }\n};\nfunction payloadForEvent(privkeys, mints) {\n  if (privkeys.length === 0) throw new Error(\"privkey not set\");\n  const payload = [\n    ...mints.map((mint) => [\"mint\", mint]),\n    ...privkeys.map((privkey) => [\"privkey\", privkey])\n  ];\n  return payload;\n}\n\n// src/nutzap-monitor/fetch-page.ts\n\nasync function fetchPage(ndk, filter, _knownNutzaps, relaySet) {\n  const events = await ndk.fetchEvents(\n    filter,\n    {\n      cacheUsage: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKSubscriptionCacheUsage.ONLY_RELAY,\n      groupable: false,\n      subId: \"recent-nutzap\"\n    },\n    relaySet\n  );\n  return Array.from(events).map((e) => _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKNutzap.from(e)).filter((n) => !!n);\n}\n\n// src/nutzap-monitor/group-nutzaps.ts\n\nfunction groupNutzaps(nutzaps, monitor) {\n  const result = /* @__PURE__ */ new Map();\n  const getKey = (mint, p2pk = \"no-key\") => `${mint}:${p2pk}`;\n  for (const nutzap of nutzaps) {\n    if (!monitor.shouldTryRedeem(nutzap)) continue;\n    const mint = nutzap.mint;\n    for (const proof of nutzap.proofs) {\n      const cashuPubkey = (0,_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.proofP2pk)(proof) ?? \"no-key\";\n      const key = getKey(mint, cashuPubkey);\n      const group = result.get(key) ?? {\n        mint,\n        cashuPubkey,\n        nostrPubkey: (0,_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.cashuPubkeyToNostrPubkey)(cashuPubkey),\n        nutzaps: []\n      };\n      group.nutzaps.push(nutzap);\n      result.set(key, group);\n    }\n  }\n  return Array.from(result.values());\n}\n\n// src/nutzap-monitor/spend-status.ts\n\nasync function getProofSpendState(wallet, nutzaps) {\n  const result = {\n    unspentProofs: [],\n    spentProofs: [],\n    nutzapsWithUnspentProofs: [],\n    nutzapsWithSpentProofs: []\n  };\n  const proofCs = /* @__PURE__ */ new Set();\n  const proofs = [];\n  const nutzapMap = /* @__PURE__ */ new Map();\n  for (const nutzap of nutzaps) {\n    for (const proof of nutzap.proofs) {\n      if (proofCs.has(proof.C)) continue;\n      proofCs.add(proof.C);\n      proofs.push(proof);\n      nutzapMap.set(proof.C, nutzap);\n    }\n  }\n  const states = await wallet.checkProofsStates(proofs);\n  for (let i = 0; i < states.length; i++) {\n    const state = states[i];\n    const proof = proofs[i];\n    const nutzap = nutzapMap.get(proof.C);\n    if (!nutzap) continue;\n    if (state.state === _cashu_cashu_ts__WEBPACK_IMPORTED_MODULE_2__.CheckStateEnum.SPENT) {\n      result.spentProofs.push(proof);\n      if (!result.nutzapsWithSpentProofs.some((n) => n.id === nutzap.id)) {\n        result.nutzapsWithSpentProofs.push(nutzap);\n      }\n    } else if (state.state === _cashu_cashu_ts__WEBPACK_IMPORTED_MODULE_2__.CheckStateEnum.UNSPENT) {\n      result.unspentProofs.push(proof);\n      if (!result.nutzapsWithUnspentProofs.some((n) => n.id === nutzap.id)) {\n        result.nutzapsWithUnspentProofs.push(nutzap);\n      }\n    }\n  }\n  return result;\n}\n\n// src/nutzap-monitor/index.ts\nvar _startTime2 = Date.now();\nfunction log2(_msg) {\n}\nvar NDKNutzapMonitor = class extends tseep__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {\n  store;\n  ndk;\n  user;\n  relaySet;\n  sub;\n  nutzapStates = /* @__PURE__ */ new Map();\n  _wallet;\n  mintList;\n  privkeys = /* @__PURE__ */ new Map();\n  cashuWallets = /* @__PURE__ */ new Map();\n  getCashuWallet = getCashuWallet.bind(this);\n  onMintInfoNeeded;\n  onMintInfoLoaded;\n  onMintKeysNeeded;\n  onMintKeysLoaded;\n  /**\n   * Create a new nutzap monitor.\n   * @param ndk - The NDK instance.\n   * @param user - The user to monitor.\n   * @param mintList - An optional mint list to monitor zaps on, if one is not provided, the monitor will use the relay set from the mint list, which is the correct default behavior of NIP-61 zaps.\n   * @param store - An optional store to save and load nutzap states to.\n   */\n  constructor(ndk, user, { mintList, store }) {\n    super();\n    this.ndk = ndk;\n    this.user = user;\n    this.mintList = mintList;\n    this.relaySet = mintList?.relaySet;\n    this.store = store;\n  }\n  set wallet(wallet) {\n    this._wallet = wallet;\n    if (wallet) {\n      this.onMintInfoNeeded ??= wallet.onMintInfoNeeded;\n      this.onMintInfoLoaded ??= wallet.onMintInfoLoaded;\n      this.onMintKeysNeeded ??= wallet.onMintKeysNeeded;\n      this.onMintKeysLoaded ??= wallet.onMintKeysLoaded;\n      if (wallet instanceof NDKCashuWallet && wallet?.privkeys) {\n        for (const [pubkey, signer] of wallet.privkeys.entries()) {\n          try {\n            this.addPrivkey(signer);\n          } catch (e) {\n            console.error(\"failed to add privkey from wallet with pubkey\", pubkey, e);\n          }\n        }\n      }\n    }\n  }\n  get wallet() {\n    return this._wallet;\n  }\n  /**\n   * Provide private keys that can be used to redeem nutzaps.\n   *\n   * This is particularly useful when a NWC wallet is used to receive the nutzaps,\n   * since it doesn't have a private key, this allows keeping the private key in a separate\n   * place (ideally a NIP-60 wallet event).\n   *\n   * Multiple keys can be added, and the monitor will use the correct key for the nutzap.\n   */\n  async addPrivkey(signer) {\n    const pubkey = (await signer.user()).pubkey;\n    if (this.privkeys.has(pubkey)) return;\n    this.privkeys.set(pubkey, signer);\n    if (!this.sub) return;\n    const inMssingPrivKeyState = (state) => state.status === _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.MISSING_PRIVKEY;\n    const ensureIsCashuPubkey2 = (state) => state.nutzap?.p2pk === pubkey;\n    const candidateNutzaps = Array.from(this.nutzapStates.values()).filter(inMssingPrivKeyState).filter(ensureIsCashuPubkey2);\n    if (candidateNutzaps.length > 0) {\n      const nutzaps = candidateNutzaps.map((c) => c.nutzap).filter((n) => !!n);\n      const groupedNutzaps = groupNutzaps(nutzaps, this);\n      for (const group of groupedNutzaps) {\n        await this.checkAndRedeemGroup(group);\n      }\n    }\n  }\n  async addUserPrivKey() {\n    const { signer } = this.ndk;\n    if (signer instanceof _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKPrivateKeySigner) {\n      const user = await signer.user();\n      const pubkey = user.pubkey;\n      this.privkeys.set(pubkey, signer);\n    }\n  }\n  /**\n   * Loads kind:375 backup events from this user to find all backup keys this user might have used.\n   */\n  async getBackupKeys() {\n    const backupEvents = await this.ndk.fetchEvents(\n      [{ kinds: [_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.CashuWalletBackup], authors: [this.user.pubkey] }],\n      void 0,\n      this.relaySet\n    );\n    const keys = Array.from(this.privkeys.values());\n    const keysNotFound = new Set(keys.map((signer) => signer.privateKey));\n    for (const event of backupEvents) {\n      const backup = await NDKCashuWalletBackup.from(event);\n      if (!backup) continue;\n      for (const privkey of backup.privkeys) {\n        if (keysNotFound.has(privkey)) keysNotFound.delete(privkey);\n        try {\n          const signer = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKPrivateKeySigner(privkey);\n          this.addPrivkey(signer);\n        } catch (e) {\n          console.error(\"failed to add privkey\", privkey, e);\n        }\n      }\n    }\n    if (keysNotFound.size > 0) {\n      const backup = new NDKCashuWalletBackup(this.ndk);\n      backup.privkeys = Array.from(keysNotFound);\n      await backup.save(this.relaySet);\n    }\n  }\n  /**\n   * Start the nutzap monitor. The monitor will initially look back\n   * for nutzaps it doesn't know about and will try to redeem them.\n   *\n   * @param knownNutzaps - An optional set of nutzaps the app knows about. This is an optimization so that we don't try to redeem nutzaps we know have already been redeemed.\n   * @param pageSize - The number of nutzaps to fetch per page.\n   *\n   */\n  async start({ filter, opts }) {\n    log2(\"Starting nutzap monitor\");\n    if (this.sub) this.sub.stop();\n    try {\n      await this.getBackupKeys();\n      log2(`Got backup keys ${this.privkeys.size}`);\n    } catch (e) {\n      console.error(\"\\u274C Failed to get backup keys\", e);\n    }\n    await this.addUserPrivKey();\n    log2(`Added user privkey ${this.privkeys.size}`);\n    const since = Math.floor(Date.now() / 1e3);\n    const monitorFilter = { kinds: [_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.Nutzap], \"#p\": [this.user.pubkey], since };\n    if (this.store) {\n      log2(\"Will load nutzaps from store\");\n      try {\n        const nutzaps = await this.store.getAllNutzaps();\n        log2(`Loaded ${nutzaps.size} nutzaps`);\n        for (const [id, state] of nutzaps.entries()) {\n          this.nutzapStates.set(id, state);\n        }\n        log2(`Changed the state of ${nutzaps.size} nutzaps`);\n      } catch (e) {\n        console.error(\"\\u274C Failed to load nutzaps from store\", e);\n      }\n    }\n    try {\n      log2(\"Will start processing redeemable nutzaps from store\");\n      await this.processRedeemableNutzapsFromStore();\n      log2(\"Finished processing redeemable nutzaps from store\");\n    } catch (e) {\n      console.error(\"\\u274C Failed to process redeemable nutzaps from store\", e);\n    }\n    try {\n      log2(\"Will start processing accumulated nutzaps\");\n      await this.processAccumulatedNutzaps(filter, opts);\n      log2(`Finished processing accumulated nutzaps ${this.nutzapStates.size}`);\n    } catch (e) {\n      console.error(\"\\u274C Failed to process nutzaps\", e);\n    }\n    log2(`Running filter ${JSON.stringify(monitorFilter)}`);\n    const subscribeOpts = {\n      subId: \"ndk-wallet:nutzap-monitor\",\n      cacheUsage: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKSubscriptionCacheUsage.ONLY_RELAY,\n      wrap: false,\n      // We skip validation so the user knows about nutzaps that were sent but are not valid\n      // this way tooling can be more comprehensive and include nutzaps that were not valid\n      skipValidation: true,\n      ...opts,\n      relaySet: this.relaySet\n      // Pass relaySet via options\n    };\n    this.sub = this.ndk.subscribe(\n      monitorFilter,\n      subscribeOpts,\n      // this.relaySet, // Removed: Passed via opts\n      {\n        // autoStart handlers (now 3rd argument)\n        onEvent: (event) => this.eventHandler(event)\n        // Added NDKEvent type\n      }\n    );\n    log2(\"\\u2705 Nutzap monitor started successfully\");\n    return true;\n  }\n  /**\n   * Checks if the group of nutzaps can be redeemed and redeems the ones that can be.\n   */\n  async checkAndRedeemGroup(group, oldestUnspentNutzapTime) {\n    const cashuWallet = await this.getCashuWallet(group.mint);\n    const spendStates = await getProofSpendState(cashuWallet, group.nutzaps);\n    for (const nutzap of spendStates.nutzapsWithSpentProofs) {\n      this.updateNutzapState(nutzap.id, { status: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.SPENT, nutzap });\n    }\n    for (const nutzap of spendStates.nutzapsWithUnspentProofs) {\n      this.emit(\"seen\", nutzap);\n      this.updateNutzapState(nutzap.id, { status: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.INITIAL, nutzap });\n    }\n    if (spendStates.unspentProofs.length > 0) {\n      for (const nutzap of spendStates.nutzapsWithUnspentProofs) {\n        if (!oldestUnspentNutzapTime || oldestUnspentNutzapTime > nutzap.created_at) {\n          oldestUnspentNutzapTime = nutzap.created_at;\n        }\n      }\n      await this.redeemNutzaps(group.mint, spendStates.nutzapsWithUnspentProofs, spendStates.unspentProofs);\n    }\n  }\n  /**\n   * Processes nutzaps that have been accumulated while the monitor was offline.\n   * @param startOpts\n   * @param opts\n   */\n  async processAccumulatedNutzaps(filter = {}, opts) {\n    log2(\"Processing accumulated nutzaps\");\n    let oldestUnspentNutzapTime;\n    const _filter = { ...filter };\n    _filter.kinds = [_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.Nutzap];\n    _filter[\"#p\"] = [this.user.pubkey];\n    const knownNutzapIds = new Set(this.nutzapStates.keys());\n    const nutzaps = await fetchPage(this.ndk, _filter, knownNutzapIds, this.relaySet);\n    log2(`We loaded ${nutzaps.length} nutzaps from relays`);\n    oldestUnspentNutzapTime = await this.processNutzaps(nutzaps, oldestUnspentNutzapTime);\n    log2(\"We finished processing thesenutzaps\");\n    if (oldestUnspentNutzapTime) {\n      _filter.since = oldestUnspentNutzapTime - 1;\n      await this.processAccumulatedNutzaps(_filter, opts);\n    }\n  }\n  stop() {\n    this.sub?.stop();\n  }\n  updateNutzapState(id, state) {\n    const currentState = this.nutzapStates.get(id) ?? {};\n    if (!currentState.status) state.status ??= _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.INITIAL;\n    const stateIsUnchanged = Object.entries(state).every(([key, value]) => {\n      if (key === \"nutzap\" && currentState.nutzap && value) {\n        return currentState.nutzap.id === value.id;\n      }\n      return currentState[key] === value;\n    });\n    if (stateIsUnchanged) return;\n    this.nutzapStates.set(id, { ...currentState, ...state });\n    this.emit(\"state_changed\", id, currentState.status);\n    const serializedState = (state2) => {\n      const res = { ...state2 };\n      if (res.nutzap) res.nutzap = res.nutzap.id;\n      return JSON.stringify(res);\n    };\n    const currentStatusStr = serializedState(currentState);\n    const newStatusStr = serializedState(state);\n    log2(`[${id.substring(0, 6)}] ${currentStatusStr} changed to \\u{1F449} ${newStatusStr}`);\n    this.store?.setNutzapState(id, state);\n  }\n  async eventHandler(event) {\n    if (this.nutzapStates.has(event.id)) return;\n    const nutzap = await _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKNutzap.from(event);\n    if (!nutzap) {\n      this.updateNutzapState(event.id, {\n        status: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.PERMANENT_ERROR,\n        errorMessage: \"Failed to parse nutzap\"\n      });\n      return;\n    }\n    if (this.mintList && !this.mintList.mints.includes(nutzap.mint)) {\n      this.emit(\"seen_in_unknown_mint\", nutzap);\n    }\n    this.redeemNutzap(nutzap);\n  }\n  /**\n   * Gathers the necessary information to redeem a nutzap and then redeems it.\n   * @param nutzap\n   */\n  async redeemNutzap(nutzap) {\n    if (!this.nutzapStates.has(nutzap.id))\n      this.updateNutzapState(nutzap.id, { status: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.INITIAL, nutzap });\n    const rawP2pk = nutzap.rawP2pk;\n    if (rawP2pk) {\n      const cashuPubkey = (0,_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.proofP2pk)(nutzap.proofs[0]);\n      if (cashuPubkey) {\n        const nostrPubkey = (0,_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.cashuPubkeyToNostrPubkey)(cashuPubkey);\n        if (nostrPubkey && !this.privkeys.has(nostrPubkey)) {\n          this.updateNutzapState(nutzap.id, {\n            status: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.MISSING_PRIVKEY,\n            errorMessage: \"No privkey found for p2pk\"\n          });\n          return this.nutzapStates.get(nutzap.id);\n        }\n      }\n    }\n    await this.redeemNutzaps(nutzap.mint, [nutzap], nutzap.proofs);\n    return this.nutzapStates.get(nutzap.id);\n  }\n  /**\n   * This function redeems a list of proofs.\n   *\n   * Proofs will be attempted to be redeemed in a single call, so they will all work or none will.\n   * Either call this function with proofs that have been verified to be redeemable or don't group them,\n   * and provide a single nutzap per call.\n   *\n   * All nutzaps MUST be p2pked to the same pubkey.\n   *\n   * @param mint\n   * @param nutzaps\n   * @param proofs\n   * @param privkey Private key that is needed to redeem the nutzaps.\n   * @returns\n   */\n  async redeemNutzaps(mint, nutzaps, proofs) {\n    if (!this.wallet) throw new Error(\"wallet not set\");\n    if (!this.wallet.redeemNutzaps) throw new Error(\"wallet does not support redeeming nutzaps\");\n    const cashuWallet = await this.getCashuWallet(mint);\n    const validNutzaps = [];\n    if (proofs.length > 0) {\n      const cashuPubkey2 = (0,_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.proofP2pk)(proofs[0]);\n      if (!cashuPubkey2) {\n        for (const nutzap of nutzaps) {\n          this.updateNutzapState(nutzap.id, {\n            status: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.INVALID_NUTZAP,\n            errorMessage: \"Invalid nutzap: proof is not p2pk\"\n          });\n        }\n        return;\n      }\n      const nostrPubkey2 = (0,_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.cashuPubkeyToNostrPubkey)(cashuPubkey2);\n      if (!nostrPubkey2) {\n        for (const nutzap of nutzaps) {\n          this.updateNutzapState(nutzap.id, {\n            status: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.INVALID_NUTZAP,\n            errorMessage: \"Invalid nutzap: locked to an invalid public key (not a nostr key)\"\n          });\n        }\n        return;\n      }\n      const privkey2 = this.privkeys.get(nostrPubkey2);\n      if (!privkey2) {\n        for (const nutzap of nutzaps) {\n          this.updateNutzapState(nutzap.id, {\n            status: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.MISSING_PRIVKEY,\n            errorMessage: \"No privkey found for p2pk\"\n          });\n        }\n        return;\n      }\n    }\n    for (const nutzap of nutzaps) {\n      if (!nutzap.isValid) {\n        this.updateNutzapState(nutzap.id, {\n          status: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.INVALID_NUTZAP,\n          errorMessage: \"Invalid nutzap\"\n        });\n        continue;\n      }\n      const rawP2pk = nutzap.rawP2pk;\n      if (!rawP2pk) {\n        this.updateNutzapState(nutzap.id, {\n          status: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.INVALID_NUTZAP,\n          errorMessage: \"Invalid nutzap: locked to an invalid public key (no p2pk)\"\n        });\n        continue;\n      }\n      if (rawP2pk.length !== 66) {\n        this.updateNutzapState(nutzap.id, {\n          status: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.INVALID_NUTZAP,\n          errorMessage: `Invalid nutzap: locked to an invalid public key (length ${rawP2pk.length})`\n        });\n        continue;\n      }\n      validNutzaps.push(nutzap);\n    }\n    if (validNutzaps.length === 0) return;\n    const cashuPubkey = (0,_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.proofP2pk)(proofs[0]);\n    if (!cashuPubkey) return;\n    const nostrPubkey = (0,_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.cashuPubkeyToNostrPubkey)(cashuPubkey);\n    if (!nostrPubkey) return;\n    const privkey = this.privkeys.get(nostrPubkey);\n    if (!privkey) {\n      for (const nutzap of validNutzaps) {\n        this.updateNutzapState(nutzap.id, {\n          status: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.MISSING_PRIVKEY,\n          errorMessage: \"No privkey found for p2pk\"\n        });\n      }\n      return;\n    }\n    for (const nutzap of validNutzaps) {\n      this.updateNutzapState(nutzap.id, { status: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.PROCESSING });\n    }\n    try {\n      const totalAmount = await this.wallet.redeemNutzaps(nutzaps, privkey.privateKey, {\n        cashuWallet,\n        proofs,\n        mint\n      });\n      this.emit(\"redeemed\", nutzaps, totalAmount);\n      for (const nutzap of nutzaps) {\n        const nutzapTotalAmount = proofsTotal(proofsIntersection(proofs, nutzap.proofs));\n        this.updateNutzapState(nutzap.id, {\n          status: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.REDEEMED,\n          redeemedAmount: nutzapTotalAmount\n        });\n      }\n    } catch (e) {\n      console.error(\"\\u274C Failed to redeem nutzaps\", e.message);\n      if (e.message?.includes(\"unknown public key size\")) {\n        for (const nutzap of nutzaps) {\n          this.updateNutzapState(nutzap.id, {\n            status: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.PERMANENT_ERROR,\n            errorMessage: \"Invalid p2pk: unknown public key size\"\n          });\n          this.emit(\"failed\", nutzap, \"Invalid p2pk: unknown public key size\");\n        }\n      } else {\n        for (const nutzap of nutzaps) {\n          this.emit(\"failed\", nutzap, e.message);\n        }\n      }\n    }\n  }\n  shouldTryRedeem(nutzap) {\n    const state = this.nutzapStates.get(nutzap.id);\n    if (!state) return true;\n    if ([_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.INITIAL].includes(state.status)) return true;\n    if (state.status === _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.MISSING_PRIVKEY) {\n      const p2pk = state.nutzap?.p2pk;\n      if (p2pk && this.privkeys.has(p2pk)) return true;\n      return false;\n    }\n    if ([_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.SPENT, _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.REDEEMED].includes(state.status)) return false;\n    if ([_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.PERMANENT_ERROR, _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NdkNutzapStatus.INVALID_NUTZAP].includes(state.status)) return false;\n    return false;\n  }\n  /**\n   * Process nutzaps from the store that are in a redeemable state.\n   * This includes nutzaps in INITIAL state and those in MISSING_PRIVKEY state\n   * for which we now have the private key.\n   */\n  async processRedeemableNutzapsFromStore() {\n    const redeemableNutzaps = [];\n    for (const [_id, state] of this.nutzapStates.entries()) {\n      if (!state.nutzap) continue;\n      if (this.shouldTryRedeem(state.nutzap)) {\n        redeemableNutzaps.push(state.nutzap);\n      }\n    }\n    if (redeemableNutzaps.length === 0) return;\n    log2(`We found ${redeemableNutzaps.length} redeemable nutzaps in the store`);\n    await this.processNutzaps(redeemableNutzaps);\n  }\n  /**\n   * Common method to process a collection of nutzaps:\n   * - Group them by mint\n   * - Check and redeem each group\n   *\n   * @param nutzaps The nutzaps to process\n   * @param oldestUnspentNutzapTime Optional timestamp to track the oldest unspent nutzap\n   * @returns The updated oldestUnspentNutzapTime if any nutzaps were processed\n   */\n  async processNutzaps(nutzaps, oldestUnspentNutzapTime) {\n    const groupedNutzaps = groupNutzaps(nutzaps, this);\n    for (const group of groupedNutzaps) {\n      log2(`Processing group ${group.mint} with ${group.nutzaps.length} nutzaps`);\n      try {\n        await this.checkAndRedeemGroup(group, oldestUnspentNutzapTime);\n        log2(`Finished processing group ${group.mint}`);\n      } catch (e) {\n        log2(`Failed to process group ${group.mint}`);\n        console.error(`\\u274C Failed to process group ${group.mint}`, e);\n      }\n    }\n    return oldestUnspentNutzapTime;\n  }\n};\nfunction proofsIntersection(proofs1, proofs2) {\n  const proofs2Cs = new Set(proofs2.map((p) => p.C));\n  return proofs1.filter((p) => proofs2Cs.has(p.C));\n}\nfunction proofsTotal(proofs) {\n  return proofs.reduce((acc, proof) => acc + proof.amount, 0);\n}\n\n// src/wallets/cashu/mint/utils.ts\n\nasync function getCashuMintRecommendations(ndk, filter) {\n  const f = [\n    { kinds: [_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.EcashMintRecommendation], \"#k\": [\"38002\"], ...filter || {} },\n    { kinds: [_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.CashuMintList], ...filter || {} }\n  ];\n  const res = {};\n  const recommendations = await ndk.fetchEvents(f);\n  for (const event of recommendations) {\n    switch (event.kind) {\n      case _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.EcashMintRecommendation:\n        for (const uTag of event.getMatchingTags(\"u\")) {\n          if (uTag[2] && uTag[2] !== \"cashu\") continue;\n          const url = uTag[1];\n          if (!url) continue;\n          const entry = res[url] || { events: [], pubkeys: /* @__PURE__ */ new Set() };\n          entry.events.push(event);\n          entry.pubkeys.add(event.pubkey);\n          res[url] = entry;\n        }\n        break;\n      case _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.CashuMintList:\n        for (const mintTag of event.getMatchingTags(\"mint\")) {\n          const url = mintTag[1];\n          if (!url) continue;\n          const entry = res[url] || { events: [], pubkeys: /* @__PURE__ */ new Set() };\n          entry.events.push(event);\n          entry.pubkeys.add(event.pubkey);\n          res[url] = entry;\n        }\n        break;\n    }\n  }\n  return res;\n}\n\n// src/wallets/cashu/wallet/migrate.ts\n\nasync function migrateCashuWallet(ndk) {\n  let mintList = await getMintList(ndk);\n  const oldWallets = await getOldWallets(ndk);\n  if (oldWallets.length === 0) return;\n  const privKeys = /* @__PURE__ */ new Map();\n  const mints = /* @__PURE__ */ new Set();\n  const newWallet = new NDKCashuWallet(ndk);\n  for (const wallet of oldWallets) {\n    const { privkey, mints: walletMints } = await extractInfoFromLegacyWallet(wallet);\n    if (privkey) {\n      newWallet.addPrivkey(privkey);\n    }\n    for (const mint of walletMints) mints.add(mint);\n  }\n  cleanupMints(mints);\n  if (mintList) {\n    cleanupMintList(mintList);\n    for (const mint of mintList.mints) mints.add(mint);\n    mintList.mints = Array.from(mints);\n    if (!mintList.p2pk && privKeys.size > 0) mintList.p2pk = Array.from(privKeys.keys())[0];\n    await mintList.toNostrEvent();\n  } else {\n    mintList = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKCashuMintList(ndk);\n    mintList.mints = Array.from(mints);\n    await mintList.toNostrEvent();\n  }\n  newWallet.mints = Array.from(mints);\n  await newWallet.publish();\n  mintList.p2pk = await newWallet.getP2pk();\n  await mintList.publishReplaceable();\n  for (const wallet of oldWallets) {\n    wallet.tags = [[\"d\", wallet.dTag ?? \"\"], [\"deleted\"]];\n    await wallet.publishReplaceable();\n  }\n}\nasync function getMintList(ndk) {\n  const activeUser = ndk.activeUser;\n  if (!activeUser) throw new Error(\"No active user\");\n  const mintList = await ndk.fetchEvent({\n    kinds: [_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.CashuMintList],\n    authors: [activeUser.pubkey]\n  });\n  if (!mintList) return;\n  return _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKCashuMintList.from(mintList);\n}\nasync function getOldWallets(ndk) {\n  const user = ndk.activeUser;\n  if (!user) throw new Error(\"No active user\");\n  const walletEvents = await ndk.fetchEvents([{ kinds: [_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.LegacyCashuWallet], authors: [user.pubkey] }]);\n  return Array.from(walletEvents).filter((event) => !event.hasTag(\"deleted\"));\n}\nasync function extractInfoFromLegacyWallet(wallet) {\n  const mints = [];\n  let privkey;\n  try {\n    const origContent = wallet.content;\n    await wallet.decrypt();\n    const privTags = JSON.parse(wallet.content);\n    for (const tag of privTags) {\n      if (tag[0] === \"privkey\") privkey = tag[1];\n      if (tag[0] === \"mint\") mints.push(tag[1]);\n    }\n    wallet.content = origContent;\n    return { privkey, mints };\n  } catch (error) {\n    console.error(\"Error decrypting legacy wallet\", error);\n  }\n  return { privkey, mints };\n}\nfunction cleanupMints(mints) {\n  for (const mint of mints) if (mint.match(/testnut/)) mints.delete(mint);\n  return mints;\n}\nfunction cleanupMintList(mintList) {\n  mintList.mints = mintList.mints.filter((mint) => !mint.match(/testnut/));\n}\n\n// src/wallets/webln/index.ts\n\n\n// src/wallets/webln/pay.ts\n\nvar NDKLnPay = class {\n  wallet;\n  info;\n  type = \"ln\";\n  constructor(wallet, info) {\n    this.wallet = wallet;\n    this.info = info;\n  }\n  async pay() {\n    if (this.type === \"ln\") {\n      return this.payLn();\n    }\n    return this.payNut();\n  }\n  /**\n   * Uses LN balance to pay to a mint\n   */\n  async payNut() {\n    const { mints, p2pk } = this.info;\n    let { amount, unit } = this.info;\n    if (!mints) throw new Error(\"No mints provided\");\n    if (unit === \"msat\") {\n      amount /= 1e3;\n      unit = \"sat\";\n    }\n    const quotesPromises = mints.map(async (mint2) => {\n      const wallet2 = new _cashu_cashu_ts__WEBPACK_IMPORTED_MODULE_2__.CashuWallet(new _cashu_cashu_ts__WEBPACK_IMPORTED_MODULE_2__.CashuMint(mint2), { unit });\n      const quote2 = await wallet2.createMintQuote(amount);\n      return { quote: quote2, mint: mint2 };\n    });\n    const { quote, mint } = await Promise.any(quotesPromises);\n    if (!quote) {\n      console.warn(\"failed to get quote from any mint\");\n      throw new Error(\"failed to get quote from any mint\");\n    }\n    const res = await this.wallet.pay({ pr: quote.request });\n    if (!res) {\n      console.warn(\"payment failed\");\n      throw new Error(\"payment failed\");\n    }\n    const wallet = new _cashu_cashu_ts__WEBPACK_IMPORTED_MODULE_2__.CashuWallet(new _cashu_cashu_ts__WEBPACK_IMPORTED_MODULE_2__.CashuMint(mint), { unit });\n    const proofs = await wallet.mintProofs(amount, quote.quote, {\n      pubkey: p2pk\n    });\n    console.warn(\"minted tokens with proofs %o\", proofs);\n    return { proofs, mint };\n  }\n  /**\n   * Straightforward; uses LN balance to pay a LN invoice\n   */\n  async payLn() {\n    const data = this.info;\n    if (!data.pr) throw new Error(\"missing pr\");\n    const _paid = false;\n    const ret = await this.wallet.pay(data);\n    return ret ? ret.preimage : void 0;\n  }\n};\n\n// src/wallets/webln/index.ts\nvar NDKWebLNWallet = class extends NDKWallet {\n  get type() {\n    return \"webln\";\n  }\n  walletId = \"webln\";\n  status = \"initial\" /* INITIAL */;\n  provider;\n  _balance;\n  constructor(ndk) {\n    super(ndk);\n    (0,webln__WEBPACK_IMPORTED_MODULE_5__.requestProvider)().then((p) => {\n      if (p) {\n        this.provider = p;\n        this.status = \"ready\" /* READY */;\n        this.emit(\"ready\");\n      } else {\n        this.status = \"failed\" /* FAILED */;\n      }\n    }).catch(() => this.status = \"failed\" /* FAILED */);\n  }\n  async pay(payment) {\n    if (!this.provider) throw new Error(\"Provider not ready\");\n    return this.provider.sendPayment(payment.pr);\n  }\n  async lnPay(payment) {\n    const pay = new NDKLnPay(this, payment);\n    const preimage = await pay.payLn();\n    if (!preimage) return;\n    return { preimage };\n  }\n  async cashuPay(payment) {\n    const pay = new NDKLnPay(this, payment);\n    return pay.payNut();\n  }\n  async updateBalance() {\n    if (!this.provider) {\n      return new Promise((resolve) => {\n        this.once(\"ready\", () => {\n          resolve();\n        });\n      });\n    }\n    const b = await this.provider.getBalance?.();\n    if (b) this._balance = { amount: b.balance };\n    return;\n  }\n  get balance() {\n    if (!this.provider) {\n      return void 0;\n    }\n    return this._balance;\n  }\n};\n\n// src/wallets/nwc/index.ts\n\n\n\n\n// src/wallets/nwc/nutzap.ts\n\nasync function redeemNutzaps(nutzaps, privkey, { cashuWallet, proofs, mint }) {\n  proofs ??= nutzaps.flatMap((n) => n.proofs);\n  if (!cashuWallet) {\n    if (!mint) throw new Error(\"No mint provided\");\n    cashuWallet = await this.getCashuWallet(mint);\n  } else {\n    mint = cashuWallet.mint.mintUrl;\n  }\n  const info = await this.getInfo();\n  if (!info.methods.includes(\"make_invoice\")) throw new Error(\"This NWC wallet does not support making invoices\");\n  const totalAvailable = proofs.reduce((acc, proof) => acc + proof.amount, 0);\n  let sweepAmount = totalAvailable;\n  while (sweepAmount > 0) {\n    const invoice = await this.makeInvoice(sweepAmount * 1e3, \"Nutzap redemption\");\n    const meltQuote = await cashuWallet.createMeltQuote(invoice.invoice);\n    const totalRequired = meltQuote.amount + meltQuote.fee_reserve;\n    if (totalRequired > totalAvailable) {\n      sweepAmount -= meltQuote.fee_reserve;\n      continue;\n    }\n    const result = await cashuWallet.meltProofs(meltQuote, proofs, { privkey });\n    let change;\n    if (result.change.length > 0) change = await saveChange(this.ndk, mint, result.change);\n    const description = `Nutzap redemption to external wallet (${this.walletId})`;\n    createOutTxEvent(\n      this.ndk,\n      {\n        pr: invoice.invoice,\n        paymentDescription: description\n      },\n      {\n        result: { preimage: invoice.preimage },\n        mint,\n        fee: meltQuote.fee_reserve,\n        proofsChange: { store: change?.proofs, mint },\n        stateUpdate: {\n          created: change\n        }\n      },\n      this.relaySet,\n      { nutzaps }\n    );\n    return sweepAmount;\n  }\n  throw new Error(\"Failed to redeem nutzaps\");\n}\nasync function saveChange(ndk, mint, change) {\n  const totalChange = change.reduce((acc, proof) => acc + proof.amount, 0);\n  if (totalChange === 0) return;\n  const token = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKCashuToken(ndk);\n  token.mint = mint;\n  token.proofs = change;\n  token.publish();\n  return token;\n}\n\n// src/wallets/nwc/req.ts\n\n\n// src/wallets/nwc/res.ts\n\nasync function waitForResponse(request) {\n  if (!this.pool) throw new Error(\"Wallet not initialized\");\n  const sendRequest = () => {\n    if (waitForEoseTimeout) clearTimeout(waitForEoseTimeout);\n    request.publish(this.relaySet);\n  };\n  const waitForEoseTimeout = setTimeout(sendRequest, 2500);\n  return new Promise((resolve, reject) => {\n    const sub = this.ndk.subscribe(\n      {\n        kinds: [_nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.NostrWalletConnectRes],\n        \"#e\": [request.id],\n        limit: 1\n      },\n      { groupable: false, pool: this.pool },\n      this.relaySet\n    );\n    sub.on(\"event\", async (event) => {\n      try {\n        await event.decrypt(event.author, this.signer);\n        const content = JSON.parse(event.content);\n        if (content.error) {\n          reject(content);\n        } else {\n          resolve(content);\n        }\n      } catch (e) {\n        console.error(\"error decrypting event\", e);\n        reject({\n          result_type: \"error\",\n          error: {\n            code: \"failed_to_parse_response\",\n            message: e.message\n          }\n        });\n      } finally {\n        sub.stop();\n      }\n    });\n    sub.on(\"eose\", () => {\n      sendRequest();\n    });\n  });\n}\n\n// src/wallets/nwc/req.ts\nasync function sendReq(method, params) {\n  if (!this.walletService || !this.signer) {\n    throw new Error(\"Wallet not initialized\");\n  }\n  const event = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKEvent(this.ndk, {\n    kind: _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKKind.NostrWalletConnectReq,\n    tags: [[\"p\", this.walletService.pubkey]],\n    content: JSON.stringify({ method, params })\n  });\n  await event.encrypt(this.walletService, this.signer, \"nip04\");\n  await event.sign(this.signer);\n  const responsePromise = new Promise((resolve, reject) => {\n    waitForResponse.call(this, event).then(resolve).catch(reject);\n  });\n  if (this.timeout) {\n    const timeoutPromise = new Promise(\n      (_, reject) => setTimeout(() => {\n        this.emit(\"timeout\", method);\n        reject(new Error(`Request timed out after ${this.timeout}ms`));\n      }, this.timeout)\n    );\n    return Promise.race([responsePromise, timeoutPromise]);\n  }\n  return responsePromise;\n}\n\n// src/wallets/nwc/index.ts\nvar d3 = debug__WEBPACK_IMPORTED_MODULE_3__(\"ndk-wallet:nwc\");\nvar NDKNWCWallet = class extends NDKWallet {\n  get type() {\n    return \"nwc\";\n  }\n  status = \"initial\" /* INITIAL */;\n  walletId = \"nwc\";\n  pairingCode;\n  walletService;\n  relaySet;\n  signer;\n  _balance;\n  cachedInfo;\n  pool;\n  timeout;\n  /**\n   *\n   * @param ndk\n   * @param timeout A timeeout to use for all operations.\n   */\n  constructor(ndk, {\n    timeout,\n    pairingCode,\n    pubkey,\n    relayUrls,\n    secret\n  }) {\n    super(ndk);\n    if (pairingCode) {\n      const u = new URL(pairingCode);\n      pubkey = u.host ?? u.pathname;\n      relayUrls = u.searchParams.getAll(\"relay\");\n      secret = u.searchParams.get(\"secret\");\n      this.pairingCode = pairingCode;\n    }\n    if (!pubkey || !relayUrls || !secret) throw new Error(\"Incomplete initialization parameters\");\n    this.timeout = timeout;\n    this.walletService = this.ndk.getUser({ pubkey });\n    this.pool = this.getPool(relayUrls);\n    this.relaySet = _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKRelaySet.fromRelayUrls(relayUrls, this.ndk, true, this.pool);\n    this.signer = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKPrivateKeySigner(secret);\n    this.pool.on(\"connect\", () => {\n      this.status = \"ready\" /* READY */;\n      this.emit(\"ready\");\n    });\n    this.pool.on(\"relay:disconnect\", () => this.status = \"loading\" /* LOADING */);\n    this.pool.connect();\n    if (this.pool.connectedRelays().length > 0) {\n      this.status = \"ready\" /* READY */;\n      this.emit(\"ready\");\n    }\n  }\n  getPool(relayUrls) {\n    for (const pool of this.ndk.pools) if (pool.name === \"NWC\") return pool;\n    return new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_0__.NDKPool(relayUrls, [], this.ndk, { name: \"NWC\" });\n  }\n  async lnPay(payment) {\n    if (!this.signer) throw new Error(\"Wallet not initialized\");\n    d3(\"lnPay\", payment.pr);\n    const res = await this.req(\"pay_invoice\", { invoice: payment.pr });\n    d3(\"lnPay res\", res);\n    if (res.result) {\n      return {\n        preimage: res.result.preimage\n      };\n    }\n    this.updateBalance();\n    throw new Error(res.error?.message || \"Payment failed\");\n  }\n  /**\n   * Pay by minting tokens.\n   *\n   * This creates a quote on a mint, pays it using NWC and then mints the tokens.\n   *\n   * @param payment - The payment to pay\n   * @param onLnPayment - A callback that is called when an LN payment will be processed\n   * @returns The payment confirmation\n   */\n  async cashuPay(payment, onLnInvoice, onLnPayment) {\n    if (!payment.mints) throw new Error(\"No mints provided\");\n    for (const mint of payment.mints) {\n      let amount = payment.amount;\n      amount = amount / 1e3;\n      const wallet = new _cashu_cashu_ts__WEBPACK_IMPORTED_MODULE_2__.CashuWallet(new _cashu_cashu_ts__WEBPACK_IMPORTED_MODULE_2__.CashuMint(mint), { unit: \"sat\" });\n      let quote;\n      try {\n        quote = await wallet.createMintQuote(amount);\n        d3(\"cashuPay quote\", quote);\n        onLnInvoice?.(quote.request);\n      } catch (e) {\n        console.error(\"error creating mint quote\", e);\n        throw e;\n      }\n      if (!quote) throw new Error(\"Didnt receive a mint quote\");\n      try {\n        const res = await this.req(\"pay_invoice\", { invoice: quote.request });\n        if (res.result?.preimage) {\n          onLnPayment?.(mint, res.result.preimage);\n        }\n        d3(\"cashuPay res\", res);\n      } catch (e) {\n        const message = e?.error?.message || e?.message || \"unknown error\";\n        console.error(\"error paying invoice\", e, { message });\n        throw new Error(message);\n      }\n      this.updateBalance();\n      return mintProofs(wallet, quote, amount, mint, payment.p2pk);\n    }\n  }\n  /**\n   * Redeem a set of nutzaps into an NWC wallet.\n   *\n   * This function gets an invoice from the NWC wallet until the total amount of the nutzaps is enough to pay for the invoice\n   * when accounting for fees.\n   *\n   * @param cashuWallet - The cashu wallet to redeem the nutzaps into\n   * @param nutzaps - The nutzaps to redeem\n   * @param proofs - The proofs to redeem\n   * @param mint - The mint to redeem the nutzaps into\n   * @param privkey - The private key needed to redeem p2pk proofs.\n   */\n  redeemNutzaps = redeemNutzaps.bind(this);\n  /**\n   * Fetch the balance of this wallet\n   */\n  async updateBalance() {\n    const res = await this.req(\"get_balance\", {});\n    if (!res.result) throw new Error(\"Failed to get balance\");\n    if (res.error) throw new Error(res.error.message);\n    this._balance = {\n      amount: res.result?.balance ?? 0\n    };\n    this._balance.amount /= 1e3;\n    this.emit(\"balance_updated\");\n  }\n  /**\n   * Get the balance of this wallet\n   */\n  get balance() {\n    return this._balance;\n  }\n  req = sendReq.bind(this);\n  async getInfo(refetch = false) {\n    if (refetch) {\n      this.cachedInfo = void 0;\n    }\n    if (this.cachedInfo) return this.cachedInfo;\n    const res = await this.req(\"get_info\", {});\n    d3(\"info\", res);\n    if (!res.result) throw new Error(\"Failed to get info\");\n    if (res.error) throw new Error(res.error.message);\n    this.cachedInfo = res.result;\n    if (res.result.alias) this.walletId = res.result.alias;\n    return res.result;\n  }\n  async listTransactions() {\n    const res = await this.req(\"list_transactions\", {});\n    if (!res.result) throw new Error(\"Failed to list transactions\");\n    return res.result;\n  }\n  async makeInvoice(amount, description) {\n    const res = await this.req(\"make_invoice\", { amount, description });\n    if (!res.result) throw new Error(\"Failed to make invoice\");\n    return res.result;\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLXdhbGxldC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBUTRCO0FBQ3lCO0FBQ0M7O0FBRXREO0FBQ2tEO0FBQ21EOztBQUVyRztBQUNxQzs7QUFFckM7QUFDeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSyxHQUFHLEtBQUssR0FBRyxNQUFNO0FBQ3BDO0FBQ0EsWUFBWSxLQUFLLEdBQUcsS0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzREFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFXLEtBQUssc0RBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsNERBQTRELEtBQUs7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUI7QUFDeEIsOEJBQThCLCtDQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQVE7QUFDeEIsa0JBQWtCLHVEQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFPLDRCQUE0QixhQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHFCQUFxQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdEQUFZLEtBQUssc0RBQVUsVUFBVSxhQUFhO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3QkFBd0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxxQkFBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFvQkUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYWJsb2Zlcm5hbmRlei90ZXN0MTIzL1RFTkVYLXBma21jOS9tYWluL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGstd2FsbGV0L2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL251dHphcC1tb25pdG9yL2luZGV4LnRzXG5pbXBvcnQge1xuICBOREtLaW5kIGFzIE5ES0tpbmQ1LFxuICBOREtOdXR6YXAgYXMgTkRLTnV0emFwMixcbiAgTkRLUHJpdmF0ZUtleVNpZ25lciBhcyBOREtQcml2YXRlS2V5U2lnbmVyMixcbiAgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZSBhcyBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlMixcbiAgY2FzaHVQdWJrZXlUb05vc3RyUHVia2V5IGFzIGNhc2h1UHVia2V5VG9Ob3N0clB1YmtleTIsXG4gIHByb29mUDJwayBhcyBwcm9vZlAycGsyXG59IGZyb20gXCJAbm9zdHItZGV2LWtpdC9uZGtcIjtcbmltcG9ydCB7IE5ka051dHphcFN0YXR1cyB9IGZyb20gXCJAbm9zdHItZGV2LWtpdC9uZGtcIjtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI0IH0gZnJvbSBcInRzZWVwXCI7XG5cbi8vIHNyYy93YWxsZXRzL2Nhc2h1L3dhbGxldC9pbmRleC50c1xuaW1wb3J0IHsgZ2V0RGVjb2RlZFRva2VuIH0gZnJvbSBcIkBjYXNodS9jYXNodS10c1wiO1xuaW1wb3J0IHsgTkRLRXZlbnQgYXMgTkRLRXZlbnQzLCBOREtLaW5kIGFzIE5ES0tpbmQ0LCBOREtQcml2YXRlS2V5U2lnbmVyIH0gZnJvbSBcIkBub3N0ci1kZXYta2l0L25ka1wiO1xuXG4vLyBzcmMvd2FsbGV0cy9pbmRleC50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSBcInRzZWVwXCI7XG5cbi8vIHNyYy93YWxsZXRzL2Nhc2h1L21pbnQudHNcbmltcG9ydCB7IENhc2h1TWludCwgQ2FzaHVXYWxsZXQgfSBmcm9tIFwiQGNhc2h1L2Nhc2h1LXRzXCI7XG52YXIgbWludFdhbGxldHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xudmFyIG1pbnRXYWxsZXRQcm9taXNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBtaW50S2V5KG1pbnQsIHVuaXQsIHBrKSB7XG4gIGlmICh1bml0ID09PSBcInNhdHNcIikge1xuICAgIHVuaXQgPSBcInNhdFwiO1xuICB9XG4gIGlmIChwaykge1xuICAgIGNvbnN0IHBrU3RyID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHBrKTtcbiAgICByZXR1cm4gYCR7bWludH0tJHt1bml0fS0ke3BrU3RyfWA7XG4gIH1cbiAgcmV0dXJuIGAke21pbnR9LSR7dW5pdH1gO1xufVxuYXN5bmMgZnVuY3Rpb24gd2FsbGV0Rm9yTWludChtaW50LCB7XG4gIHBrLFxuICB0aW1lb3V0ID0gNWUzLFxuICBtaW50SW5mbyxcbiAgbWludEtleXMsXG4gIG9uTWludEluZm9OZWVkZWQsXG4gIG9uTWludEluZm9Mb2FkZWQsXG4gIG9uTWludEtleXNOZWVkZWQsXG4gIG9uTWludEtleXNMb2FkZWRcbn0gPSB7fSkge1xuICBtaW50SW5mbyA/Pz0gYXdhaXQgb25NaW50SW5mb05lZWRlZD8uKG1pbnQpO1xuICBtaW50S2V5cyA/Pz0gYXdhaXQgb25NaW50S2V5c05lZWRlZD8uKG1pbnQpO1xuICBpZiAoIW1pbnRJbmZvICYmIG9uTWludEluZm9Mb2FkZWQpIHtcbiAgICBtaW50SW5mbyA9IGF3YWl0IENhc2h1TWludC5nZXRJbmZvKG1pbnQpO1xuICAgIG9uTWludEluZm9Mb2FkZWQ/LihtaW50LCBtaW50SW5mbyk7XG4gIH1cbiAgY29uc3QgdW5pdCA9IFwic2F0XCI7XG4gIGNvbnN0IGtleSA9IG1pbnRLZXkobWludCwgdW5pdCwgcGspO1xuICBpZiAobWludFdhbGxldHMuaGFzKGtleSkpIHtcbiAgICByZXR1cm4gbWludFdhbGxldHMuZ2V0KGtleSk7XG4gIH1cbiAgaWYgKG1pbnRXYWxsZXRQcm9taXNlcy5oYXMoa2V5KSkge1xuICAgIHJldHVybiBtaW50V2FsbGV0UHJvbWlzZXMuZ2V0KGtleSk7XG4gIH1cbiAgaWYgKCFtaW50SW5mbykge1xuICAgIGlmIChvbk1pbnRJbmZvTmVlZGVkKSB7XG4gICAgICBtaW50SW5mbyA9IGF3YWl0IG9uTWludEluZm9OZWVkZWQobWludCk7XG4gICAgfVxuICAgIGlmICghbWludEluZm8gJiYgb25NaW50SW5mb0xvYWRlZCkge1xuICAgICAgbWludEluZm8gPSBhd2FpdCBDYXNodU1pbnQuZ2V0SW5mbyhtaW50KTtcbiAgICAgIG9uTWludEluZm9Mb2FkZWQobWludCwgbWludEluZm8pO1xuICAgIH1cbiAgfVxuICBpZiAoIW1pbnRLZXlzICYmIG9uTWludEtleXNOZWVkZWQpIHtcbiAgICBtaW50S2V5cyA9IGF3YWl0IG9uTWludEtleXNOZWVkZWQobWludCk7XG4gIH1cbiAgY29uc3Qgd2FsbGV0ID0gbmV3IENhc2h1V2FsbGV0KG5ldyBDYXNodU1pbnQobWludCksIHtcbiAgICB1bml0LFxuICAgIGJpcDM5c2VlZDogcGssXG4gICAgbWludEluZm8sXG4gICAga2V5czogbWludEtleXNcbiAgfSk7XG4gIGNvbnN0IGxvYWRQcm9taXNlID0gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0VGltZW91dCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZWplY3RUaW1lb3V0KG5ldyBFcnJvcihcInRpbWVvdXQgbG9hZGluZyBtaW50XCIpKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICB9KTtcbiAgICAgIGF3YWl0IFByb21pc2UucmFjZShbd2FsbGV0LmxvYWRNaW50KCksIHRpbWVvdXRQcm9taXNlXSk7XG4gICAgICBtaW50V2FsbGV0cy5zZXQoa2V5LCB3YWxsZXQpO1xuICAgICAgbWludFdhbGxldFByb21pc2VzLmRlbGV0ZShrZXkpO1xuICAgICAgaWYgKHdhbGxldC5rZXlzKSB7XG4gICAgICAgIG9uTWludEtleXNMb2FkZWQ/LihtaW50LCB3YWxsZXQua2V5cyk7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHdhbGxldCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIltXQUxMRVRdIGVycm9yIGxvYWRpbmcgbWludFwiLCBtaW50LCBlLm1lc3NhZ2UpO1xuICAgICAgbWludFdhbGxldFByb21pc2VzLmRlbGV0ZShrZXkpO1xuICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICB9XG4gIH0pO1xuICBtaW50V2FsbGV0UHJvbWlzZXMuc2V0KGtleSwgbG9hZFByb21pc2UpO1xuICByZXR1cm4gbG9hZFByb21pc2U7XG59XG5cbi8vIHNyYy93YWxsZXRzL21pbnQudHNcbmFzeW5jIGZ1bmN0aW9uIGdldENhc2h1V2FsbGV0KG1pbnQpIHtcbiAgaWYgKHRoaXMuY2FzaHVXYWxsZXRzLmhhcyhtaW50KSkgcmV0dXJuIHRoaXMuY2FzaHVXYWxsZXRzLmdldChtaW50KTtcbiAgY29uc3QgdyA9IGF3YWl0IHdhbGxldEZvck1pbnQobWludCwge1xuICAgIG9uTWludEluZm9OZWVkZWQ6IHRoaXMub25NaW50SW5mb05lZWRlZCxcbiAgICBvbk1pbnRJbmZvTG9hZGVkOiB0aGlzLm9uTWludEluZm9Mb2FkZWQsXG4gICAgb25NaW50S2V5c05lZWRlZDogdGhpcy5vbk1pbnRLZXlzTmVlZGVkLFxuICAgIG9uTWludEtleXNMb2FkZWQ6IHRoaXMub25NaW50S2V5c0xvYWRlZFxuICB9KTtcbiAgaWYgKCF3KSB0aHJvdyBuZXcgRXJyb3IoYHVuYWJsZSB0byBsb2FkIHdhbGxldCBmb3IgbWludCAke21pbnR9YCk7XG4gIHRoaXMuY2FzaHVXYWxsZXRzLnNldChtaW50LCB3KTtcbiAgcmV0dXJuIHc7XG59XG5cbi8vIHNyYy93YWxsZXRzL2luZGV4LnRzXG52YXIgTkRLV2FsbGV0U3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoTkRLV2FsbGV0U3RhdHVzMikgPT4ge1xuICBOREtXYWxsZXRTdGF0dXMyW1wiSU5JVElBTFwiXSA9IFwiaW5pdGlhbFwiO1xuICBOREtXYWxsZXRTdGF0dXMyW1wiTE9BRElOR1wiXSA9IFwibG9hZGluZ1wiO1xuICBOREtXYWxsZXRTdGF0dXMyW1wiUkVBRFlcIl0gPSBcInJlYWR5XCI7XG4gIE5ES1dhbGxldFN0YXR1czJbXCJGQUlMRURcIl0gPSBcImZhaWxlZFwiO1xuICByZXR1cm4gTkRLV2FsbGV0U3RhdHVzMjtcbn0pKE5ES1dhbGxldFN0YXR1cyB8fCB7fSk7XG52YXIgTkRLV2FsbGV0ID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjYXNodVdhbGxldHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBvbk1pbnRJbmZvTmVlZGVkO1xuICBvbk1pbnRJbmZvTG9hZGVkO1xuICBvbk1pbnRLZXlzTmVlZGVkO1xuICBvbk1pbnRLZXlzTG9hZGVkO1xuICBnZXRDYXNodVdhbGxldCA9IGdldENhc2h1V2FsbGV0LmJpbmQodGhpcyk7XG4gIG5kaztcbiAgY29uc3RydWN0b3IobmRrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgfVxuICBzdGF0dXMgPSBcImluaXRpYWxcIiAvKiBJTklUSUFMICovO1xuICBnZXQgdHlwZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIEFuIElEIG9mIHRoaXMgd2FsbGV0XG4gICAqL1xuICB3YWxsZXRJZCA9IFwidW5rbm93blwiO1xuICAvKipcbiAgICogR2V0IHRoZSBiYWxhbmNlIG9mIHRoaXMgd2FsbGV0XG4gICAqL1xuICBnZXQgYmFsYW5jZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJlZGVlbSBhIHNldCBvZiBudXR6YXBzIGludG8gYW4gTldDIHdhbGxldC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBnZXRzIGFuIGludm9pY2UgZnJvbSB0aGUgTldDIHdhbGxldCB1bnRpbCB0aGUgdG90YWwgYW1vdW50IG9mIHRoZSBudXR6YXBzIGlzIGVub3VnaCB0byBwYXkgZm9yIHRoZSBpbnZvaWNlXG4gICAqIHdoZW4gYWNjb3VudGluZyBmb3IgZmVlcy5cbiAgICpcbiAgICogQHBhcmFtIGNhc2h1V2FsbGV0IC0gVGhlIGNhc2h1IHdhbGxldCB0byByZWRlZW0gdGhlIG51dHphcHMgaW50b1xuICAgKiBAcGFyYW0gbnV0emFwSWRzIC0gVGhlIElEcyBvZiB0aGUgbnV0emFwcyB0byByZWRlZW1cbiAgICogQHBhcmFtIHByb29mcyAtIFRoZSBwcm9vZnMgdG8gcmVkZWVtXG4gICAqIEBwYXJhbSBwcml2a2V5IC0gVGhlIHByaXZhdGUga2V5IG5lZWRlZCB0byByZWRlZW0gcDJwayBwcm9vZnMuXG4gICAqL1xuICByZWRlZW1OdXR6YXBzKF9udXR6YXBzLCBfcHJpdmtleSwgX29wdHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbn07XG5cbi8vIHNyYy93YWxsZXRzL2Nhc2h1L2RlcG9zaXQtbW9uaXRvci50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjIgfSBmcm9tIFwidHNlZXBcIjtcbnZhciBOREtDYXNodURlcG9zaXRNb25pdG9yID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXIyIHtcbiAgZGVwb3NpdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBhZGREZXBvc2l0KGRlcG9zaXQpIHtcbiAgICBjb25zdCB7IHF1b3RlSWQgfSA9IGRlcG9zaXQ7XG4gICAgaWYgKCFxdW90ZUlkKSB0aHJvdyBuZXcgRXJyb3IoXCJkZXBvc2l0IGhhcyBubyBxdW90ZSBJRFwiKTtcbiAgICBpZiAodGhpcy5kZXBvc2l0cy5oYXMocXVvdGVJZCkpIHJldHVybiBmYWxzZTtcbiAgICBkZXBvc2l0Lm9uY2UoXCJzdWNjZXNzXCIsIChfdG9rZW4pID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlRGVwb3NpdChxdW90ZUlkKTtcbiAgICB9KTtcbiAgICB0aGlzLmRlcG9zaXRzLnNldChxdW90ZUlkLCBkZXBvc2l0KTtcbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmVtb3ZlRGVwb3NpdChxdW90ZUlkKSB7XG4gICAgdGhpcy5kZXBvc2l0cy5kZWxldGUocXVvdGVJZCk7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICB9XG59O1xuXG4vLyBzcmMvd2FsbGV0cy9jYXNodS9kZXBvc2l0LnRzXG5pbXBvcnQgY3JlYXRlRGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgYXMgRXZlbnRFbWl0dGVyMyB9IGZyb20gXCJ0c2VlcFwiO1xuXG4vLyBzcmMvd2FsbGV0cy9jYXNodS9xdW90ZS50c1xuaW1wb3J0IHsgTkRLS2luZCB9IGZyb20gXCJAbm9zdHItZGV2LWtpdC9uZGtcIjtcbmltcG9ydCB7IE5ES0V2ZW50IH0gZnJvbSBcIkBub3N0ci1kZXYta2l0L25ka1wiO1xuXG4vLyBzcmMvdXRpbHMvbG4udHNcbmltcG9ydCB7IGRlY29kZSBhcyBkZWNvZGVCb2x0MTEgfSBmcm9tIFwibGlnaHQtYm9sdDExLWRlY29kZXJcIjtcbmZ1bmN0aW9uIGdldEJvbHQxMUV4cGlyZXNBdChib2x0MTEpIHtcbiAgY29uc3QgZGVjb2RlZCA9IGRlY29kZUJvbHQxMShib2x0MTEpO1xuICBjb25zdCBleHBpcnkgPSBkZWNvZGVkLmV4cGlyeTtcbiAgY29uc3QgdGltZXN0YW1wID0gZGVjb2RlZC5zZWN0aW9ucy5maW5kKChzZWN0aW9uKSA9PiBzZWN0aW9uLm5hbWUgPT09IFwidGltZXN0YW1wXCIpLnZhbHVlO1xuICBpZiAodHlwZW9mIGV4cGlyeSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgdGltZXN0YW1wID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIGV4cGlyeSArIHRpbWVzdGFtcDtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0Qm9sdDExQW1vdW50KGJvbHQxMSkge1xuICBjb25zdCBkZWNvZGVkID0gZGVjb2RlQm9sdDExKGJvbHQxMSk7XG4gIGNvbnN0IHNlY3Rpb24gPSBkZWNvZGVkLnNlY3Rpb25zLmZpbmQoKHNlY3Rpb24yKSA9PiBzZWN0aW9uMi5uYW1lID09PSBcImFtb3VudFwiKTtcbiAgY29uc3QgdmFsID0gc2VjdGlvbj8udmFsdWU7XG4gIHJldHVybiBOdW1iZXIodmFsKTtcbn1cbmZ1bmN0aW9uIGdldEJvbHQxMURlc2NyaXB0aW9uKGJvbHQxMSkge1xuICBjb25zdCBkZWNvZGVkID0gZGVjb2RlQm9sdDExKGJvbHQxMSk7XG4gIGNvbnN0IHNlY3Rpb24gPSBkZWNvZGVkLnNlY3Rpb25zLmZpbmQoKHNlY3Rpb24yKSA9PiBzZWN0aW9uMi5uYW1lID09PSBcImRlc2NyaXB0aW9uXCIpO1xuICBjb25zdCB2YWwgPSBzZWN0aW9uPy52YWx1ZTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuLy8gc3JjL3dhbGxldHMvY2FzaHUvcXVvdGUudHNcbnZhciBOREtDYXNodVF1b3RlID0gY2xhc3MgX05ES0Nhc2h1UXVvdGUgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHF1b3RlSWQ7XG4gIG1pbnQ7XG4gIGFtb3VudDtcbiAgdW5pdDtcbiAgX3dhbGxldDtcbiAgc3RhdGljIGtpbmQgPSBOREtLaW5kLkNhc2h1UXVvdGU7XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcihuZGssIGV2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IE5ES0tpbmQuQ2FzaHVRdW90ZTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbShldmVudCkge1xuICAgIGNvbnN0IHF1b3RlID0gbmV3IF9OREtDYXNodVF1b3RlKGV2ZW50Lm5kaywgZXZlbnQpO1xuICAgIGNvbnN0IG9yaWdpbmFsID0gZXZlbnQ7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHF1b3RlLmRlY3J5cHQoKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHF1b3RlLmNvbnRlbnQgPSBvcmlnaW5hbC5jb250ZW50O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgY29udGVudCA9IEpTT04ucGFyc2UocXVvdGUuY29udGVudCk7XG4gICAgICBxdW90ZS5xdW90ZUlkID0gY29udGVudC5xdW90ZUlkO1xuICAgICAgcXVvdGUubWludCA9IGNvbnRlbnQubWludDtcbiAgICAgIHF1b3RlLmFtb3VudCA9IGNvbnRlbnQuYW1vdW50O1xuICAgICAgcXVvdGUudW5pdCA9IGNvbnRlbnQudW5pdDtcbiAgICB9IGNhdGNoIChfZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gcXVvdGU7XG4gIH1cbiAgc2V0IHdhbGxldCh3YWxsZXQpIHtcbiAgICB0aGlzLl93YWxsZXQgPSB3YWxsZXQ7XG4gIH1cbiAgc2V0IGludm9pY2UoaW52b2ljZSkge1xuICAgIGNvbnN0IGJvbHQxMUV4cGlyeSA9IGdldEJvbHQxMUV4cGlyZXNBdChpbnZvaWNlKTtcbiAgICBpZiAoYm9sdDExRXhwaXJ5KSB0aGlzLnRhZ3MucHVzaChbXCJleHBpcmF0aW9uXCIsIGJvbHQxMUV4cGlyeS50b1N0cmluZygpXSk7XG4gIH1cbiAgYXN5bmMgc2F2ZSgpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaXMgcmVxdWlyZWRcIik7XG4gICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgcXVvdGVJZDogdGhpcy5xdW90ZUlkLFxuICAgICAgbWludDogdGhpcy5taW50LFxuICAgICAgYW1vdW50OiB0aGlzLmFtb3VudCxcbiAgICAgIHVuaXQ6IHRoaXMudW5pdFxuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMuZW5jcnlwdCh0aGlzLm5kay5hY3RpdmVVc2VyLCB2b2lkIDAsIFwibmlwNDRcIik7XG4gICAgYXdhaXQgdGhpcy5zaWduKCk7XG4gICAgYXdhaXQgdGhpcy5wdWJsaXNoKHRoaXMuX3dhbGxldD8ucmVsYXlTZXQpO1xuICB9XG59O1xuXG4vLyBzcmMvd2FsbGV0cy9jYXNodS93YWxsZXQvdHhzLnRzXG5pbXBvcnQge1xuICBOREtDYXNodVdhbGxldFR4LFxuICBOREtVc2VyLFxuICBwcm9vZnNUb3RhbEJhbGFuY2Vcbn0gZnJvbSBcIkBub3N0ci1kZXYta2l0L25ka1wiO1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlT3V0VHhFdmVudChuZGssIHBheW1lbnRSZXF1ZXN0LCBwYXltZW50UmVzdWx0LCByZWxheVNldCwgeyBudXR6YXBzIH0gPSB7fSkge1xuICBsZXQgZGVzY3JpcHRpb24gPSBwYXltZW50UmVxdWVzdC5wYXltZW50RGVzY3JpcHRpb247XG4gIGxldCBhbW91bnQ7XG4gIGlmIChwYXltZW50UmVxdWVzdC5wcikge1xuICAgIGFtb3VudCA9IGdldEJvbHQxMUFtb3VudChwYXltZW50UmVxdWVzdC5wcik7XG4gICAgZGVzY3JpcHRpb24gPz89IGdldEJvbHQxMURlc2NyaXB0aW9uKHBheW1lbnRSZXF1ZXN0LnByKTtcbiAgICBpZiAoYW1vdW50KSBhbW91bnQgLz0gMWUzO1xuICB9IGVsc2Uge1xuICAgIGFtb3VudCA9IHBheW1lbnRSZXF1ZXN0LmFtb3VudDtcbiAgfVxuICBpZiAoIWFtb3VudCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJCVUc6IFVuYWJsZSB0byBmaW5kIGFtb3VudCBmb3IgcGF5bWVudFJlcXVlc3RcIiwgcGF5bWVudFJlcXVlc3QpO1xuICB9XG4gIGNvbnN0IHR4RXZlbnQgPSBuZXcgTkRLQ2FzaHVXYWxsZXRUeChuZGspO1xuICB0eEV2ZW50LmRpcmVjdGlvbiA9IFwib3V0XCI7XG4gIHR4RXZlbnQuYW1vdW50ID0gYW1vdW50ID8/IDA7XG4gIHR4RXZlbnQubWludCA9IHBheW1lbnRSZXN1bHQubWludDtcbiAgdHhFdmVudC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICBpZiAocGF5bWVudFJlc3VsdC5mZWUpIHR4RXZlbnQuZmVlID0gcGF5bWVudFJlc3VsdC5mZWU7XG4gIGlmIChwYXltZW50UmVxdWVzdC50YXJnZXQpIHtcbiAgICB0eEV2ZW50LnRhZ3MucHVzaChwYXltZW50UmVxdWVzdC50YXJnZXQudGFnUmVmZXJlbmNlKCkpO1xuICAgIGlmICghKHBheW1lbnRSZXF1ZXN0LnRhcmdldCBpbnN0YW5jZW9mIE5ES1VzZXIpKSB7XG4gICAgICB0eEV2ZW50LnRhZ3MucHVzaChbXCJwXCIsIHBheW1lbnRSZXF1ZXN0LnRhcmdldC5wdWJrZXldKTtcbiAgICB9XG4gIH1cbiAgaWYgKG51dHphcHMpIHtcbiAgICB0eEV2ZW50LmRlc2NyaXB0aW9uID8/PSBcIm51dHphcCByZWRlZW1cIjtcbiAgICBmb3IgKGNvbnN0IG51dHphcCBvZiBudXR6YXBzKSB0eEV2ZW50LmFkZFJlZGVlbWVkTnV0emFwKG51dHphcCk7XG4gIH1cbiAgaWYgKHBheW1lbnRSZXN1bHQuc3RhdGVVcGRhdGU/LmNyZWF0ZWQpIHR4RXZlbnQuY3JlYXRlZFRva2VucyA9IFtwYXltZW50UmVzdWx0LnN0YXRlVXBkYXRlLmNyZWF0ZWRdO1xuICBpZiAocGF5bWVudFJlc3VsdC5zdGF0ZVVwZGF0ZT8uZGVsZXRlZCkgdHhFdmVudC5kZXN0cm95ZWRUb2tlbklkcyA9IHBheW1lbnRSZXN1bHQuc3RhdGVVcGRhdGUuZGVsZXRlZDtcbiAgaWYgKHBheW1lbnRSZXN1bHQuc3RhdGVVcGRhdGU/LnJlc2VydmVkKSB0eEV2ZW50LnJlc2VydmVkVG9rZW5zID0gW3BheW1lbnRSZXN1bHQuc3RhdGVVcGRhdGUucmVzZXJ2ZWRdO1xuICBhd2FpdCB0eEV2ZW50LnNpZ24oKTtcbiAgdHhFdmVudC5wdWJsaXNoKHJlbGF5U2V0KTtcbiAgcmV0dXJuIHR4RXZlbnQ7XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVJblR4RXZlbnQobmRrLCBwcm9vZnMsIG1pbnQsIHVwZGF0ZVN0YXRlUmVzdWx0LCB7IG51dHphcHMsIGZlZSwgZGVzY3JpcHRpb24gfSwgcmVsYXlTZXQpIHtcbiAgY29uc3QgdHhFdmVudCA9IG5ldyBOREtDYXNodVdhbGxldFR4KG5kayk7XG4gIGNvbnN0IGFtb3VudCA9IHByb29mc1RvdGFsQmFsYW5jZShwcm9vZnMpO1xuICB0eEV2ZW50LmRpcmVjdGlvbiA9IFwiaW5cIjtcbiAgdHhFdmVudC5hbW91bnQgPSBhbW91bnQ7XG4gIHR4RXZlbnQubWludCA9IG1pbnQ7XG4gIHR4RXZlbnQuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgaWYgKHVwZGF0ZVN0YXRlUmVzdWx0LmNyZWF0ZWQpIHR4RXZlbnQuY3JlYXRlZFRva2VucyA9IFt1cGRhdGVTdGF0ZVJlc3VsdC5jcmVhdGVkXTtcbiAgaWYgKHVwZGF0ZVN0YXRlUmVzdWx0LmRlbGV0ZWQpIHR4RXZlbnQuZGVzdHJveWVkVG9rZW5JZHMgPSB1cGRhdGVTdGF0ZVJlc3VsdC5kZWxldGVkO1xuICBpZiAodXBkYXRlU3RhdGVSZXN1bHQucmVzZXJ2ZWQpIHR4RXZlbnQucmVzZXJ2ZWRUb2tlbnMgPSBbdXBkYXRlU3RhdGVSZXN1bHQucmVzZXJ2ZWRdO1xuICBpZiAobnV0emFwcykgZm9yIChjb25zdCBudXR6YXAgb2YgbnV0emFwcykgdHhFdmVudC5hZGRSZWRlZW1lZE51dHphcChudXR6YXApO1xuICBpZiAoZmVlKSB0eEV2ZW50LmZlZSA9IGZlZTtcbiAgYXdhaXQgdHhFdmVudC5zaWduKCk7XG4gIHR4RXZlbnQucHVibGlzaChyZWxheVNldCk7XG4gIHJldHVybiB0eEV2ZW50O1xufVxuXG4vLyBzcmMvd2FsbGV0cy9jYXNodS9kZXBvc2l0LnRzXG52YXIgZCA9IGNyZWF0ZURlYnVnKFwibmRrLXdhbGxldDpjYXNodTpkZXBvc2l0XCIpO1xuZnVuY3Rpb24gcmFuZG9tTWludCh3YWxsZXQpIHtcbiAgY29uc3QgbWludHMgPSB3YWxsZXQubWludHM7XG4gIGNvbnN0IG1pbnQgPSBtaW50c1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtaW50cy5sZW5ndGgpXTtcbiAgcmV0dXJuIG1pbnQ7XG59XG52YXIgTkRLQ2FzaHVEZXBvc2l0ID0gY2xhc3MgX05ES0Nhc2h1RGVwb3NpdCBleHRlbmRzIEV2ZW50RW1pdHRlcjMge1xuICBtaW50O1xuICBhbW91bnQ7XG4gIHF1b3RlSWQ7XG4gIHdhbGxldDtcbiAgY2hlY2tUaW1lb3V0O1xuICBjaGVja0ludGVydmFsTGVuZ3RoID0gMjUwMDtcbiAgZmluYWxpemVkID0gZmFsc2U7XG4gIHF1b3RlRXZlbnQ7XG4gIGNvbnN0cnVjdG9yKHdhbGxldCwgYW1vdW50LCBtaW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLndhbGxldCA9IHdhbGxldDtcbiAgICB0aGlzLm1pbnQgPSBtaW50IHx8IHJhbmRvbU1pbnQod2FsbGV0KTtcbiAgICB0aGlzLmFtb3VudCA9IGFtb3VudDtcbiAgfVxuICBzdGF0aWMgZnJvbVF1b3RlRXZlbnQod2FsbGV0LCBxdW90ZSkge1xuICAgIGlmICghcXVvdGUuYW1vdW50KSB0aHJvdyBuZXcgRXJyb3IoXCJxdW90ZSBoYXMgbm8gYW1vdW50XCIpO1xuICAgIGlmICghcXVvdGUubWludCkgdGhyb3cgbmV3IEVycm9yKFwicXVvdGUgaGFzIG5vIG1pbnRcIik7XG4gICAgY29uc3QgZGVwb3NpdCA9IG5ldyBfTkRLQ2FzaHVEZXBvc2l0KHdhbGxldCwgcXVvdGUuYW1vdW50LCBxdW90ZS5taW50KTtcbiAgICBkZXBvc2l0LnF1b3RlSWQgPSBxdW90ZS5xdW90ZUlkO1xuICAgIHJldHVybiBkZXBvc2l0O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcXVvdGUgSUQgYW5kIHN0YXJ0IG1vbml0b3JpbmcgZm9yIHBheW1lbnQuXG4gICAqXG4gICAqIE9uY2UgYSBwYXltZW50IGlzIHJlY2VpdmVkLCB0aGUgZGVwb3NpdCB3aWxsIGVtaXQgYSBcInN1Y2Nlc3NcIiBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHBvbGxUaW1lIC0gdGltZSBpbiBtaWxsaXNlY29uZHMgYmV0d2VlbiBjaGVja3NcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIHN0YXJ0KHBvbGxUaW1lID0gMjUwMCkge1xuICAgIGNvbnN0IGNhc2h1V2FsbGV0ID0gYXdhaXQgdGhpcy53YWxsZXQuZ2V0Q2FzaHVXYWxsZXQodGhpcy5taW50KTtcbiAgICBjb25zdCBxdW90ZSA9IGF3YWl0IGNhc2h1V2FsbGV0LmNyZWF0ZU1pbnRRdW90ZSh0aGlzLmFtb3VudCk7XG4gICAgZChcImNyZWF0ZWQgcXVvdGUgJXMgZm9yICVkICVzXCIsIHF1b3RlLnF1b3RlLCB0aGlzLmFtb3VudCwgdGhpcy5taW50KTtcbiAgICB0aGlzLnF1b3RlSWQgPSBxdW90ZS5xdW90ZTtcbiAgICB0aGlzLndhbGxldC5kZXBvc2l0TW9uaXRvci5hZGREZXBvc2l0KHRoaXMpO1xuICAgIHNldFRpbWVvdXQodGhpcy5jaGVjay5iaW5kKHRoaXMsIHBvbGxUaW1lKSwgcG9sbFRpbWUpO1xuICAgIHRoaXMuY3JlYXRlUXVvdGVFdmVudChxdW90ZS5xdW90ZSwgcXVvdGUucmVxdWVzdCkudGhlbigoZXZlbnQpID0+IHRoaXMucXVvdGVFdmVudCA9IGV2ZW50KTtcbiAgICByZXR1cm4gcXVvdGUucmVxdWVzdDtcbiAgfVxuICAvKipcbiAgICogVGhpcyBnZW5lcmF0ZXMgYSA3Mzc0IGV2ZW50IGNvbnRhaW5pbmcgdGhlIHF1b3RlIElEXG4gICAqIHdpdGggYW4gb3B0aW9uYWwgZXhwaXJhdGlvbiBzZXQgdG8gdGhlIGJvbHQxMSBleHBpcnkgKGlmIHRoZXJlIGlzIG9uZSlcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVF1b3RlRXZlbnQocXVvdGVJZCwgYm9sdDExKSB7XG4gICAgY29uc3QgeyBuZGsgfSA9IHRoaXMud2FsbGV0O1xuICAgIGNvbnN0IHF1b3RlRXZlbnQgPSBuZXcgTkRLQ2FzaHVRdW90ZShuZGspO1xuICAgIHF1b3RlRXZlbnQucXVvdGVJZCA9IHF1b3RlSWQ7XG4gICAgcXVvdGVFdmVudC5taW50ID0gdGhpcy5taW50O1xuICAgIHF1b3RlRXZlbnQuYW1vdW50ID0gdGhpcy5hbW91bnQ7XG4gICAgcXVvdGVFdmVudC53YWxsZXQgPSB0aGlzLndhbGxldDtcbiAgICBxdW90ZUV2ZW50Lmludm9pY2UgPSBib2x0MTE7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHF1b3RlRXZlbnQuc2F2ZSgpO1xuICAgICAgZChcInNhdmVkIHF1b3RlIG9uIGV2ZW50ICVzXCIsIHF1b3RlRXZlbnQucmF3RXZlbnQoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZChcImVycm9yIHNhdmluZyBxdW90ZSBvbiBldmVudCAlc1wiLCBlLnJlbGF5RXJyb3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIHF1b3RlRXZlbnQ7XG4gIH1cbiAgYXN5bmMgcnVuQ2hlY2soKSB7XG4gICAgaWYgKCF0aGlzLmZpbmFsaXplZCkgYXdhaXQgdGhpcy5maW5hbGl6ZSgpO1xuICAgIGlmICghdGhpcy5maW5hbGl6ZWQpIHRoaXMuZGVsYXlDaGVjaygpO1xuICB9XG4gIGRlbGF5Q2hlY2soKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnJ1bkNoZWNrKCk7XG4gICAgICB0aGlzLmNoZWNrSW50ZXJ2YWxMZW5ndGggKz0gNTAwO1xuICAgIH0sIHRoaXMuY2hlY2tJbnRlcnZhbExlbmd0aCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBkZXBvc2l0IGhhcyBiZWVuIGZpbmFsaXplZC5cbiAgICogQHBhcmFtIHRpbWVvdXQgQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBnaXZpbmcgdXAuXG4gICAqL1xuICBhc3luYyBjaGVjayh0aW1lb3V0KSB7XG4gICAgdGhpcy5ydW5DaGVjaygpO1xuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2hlY2tUaW1lb3V0KTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmaW5hbGl6ZSgpIHtcbiAgICBpZiAoIXRoaXMucXVvdGVJZCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gcXVvdGVJZCBzZXQuXCIpO1xuICAgIGxldCBwcm9vZnM7XG4gICAgdHJ5IHtcbiAgICAgIGQoXCJDaGVja2luZyBmb3IgbWludGluZyBzdGF0dXMgb2YgJXNcIiwgdGhpcy5xdW90ZUlkKTtcbiAgICAgIGNvbnN0IGNhc2h1V2FsbGV0ID0gYXdhaXQgdGhpcy53YWxsZXQuZ2V0Q2FzaHVXYWxsZXQodGhpcy5taW50KTtcbiAgICAgIGNvbnN0IHByb29mc1dlSGF2ZSA9IGF3YWl0IHRoaXMud2FsbGV0LnN0YXRlLmdldFByb29mcyh7IG1pbnQ6IHRoaXMubWludCB9KTtcbiAgICAgIHByb29mcyA9IGF3YWl0IGNhc2h1V2FsbGV0Lm1pbnRQcm9vZnModGhpcy5hbW91bnQsIHRoaXMucXVvdGVJZCwge1xuICAgICAgICBwcm9vZnNXZUhhdmVcbiAgICAgIH0pO1xuICAgICAgaWYgKHByb29mcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5tZXNzYWdlLm1hdGNoKC9ub3QgcGFpZC9pKSkgcmV0dXJuO1xuICAgICAgaWYgKGUubWVzc2FnZS5tYXRjaCgvYWxyZWFkeSBpc3N1ZWQvaSkpIHtcbiAgICAgICAgZChcIk1pbnQgaXMgc2F5aW5nIHRoZSBxdW90ZSBoYXMgYWxyZWFkeSBiZWVuIGlzc3VlZCwgZGVzdHJveWluZyBxdW90ZSBldmVudDogJXNcIiwgZS5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5kZXN0cm95UXVvdGVFdmVudCgpO1xuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlLm1lc3NhZ2UubWF0Y2goL3JhdGUgbGltaXQvaSkpIHtcbiAgICAgICAgZChcIk1pbnQgc2VlbXMgdG8gYmUgcmF0ZSBsaW1pdGluZywgbG93ZXJpbmcgY2hlY2sgaW50ZXJ2YWxcIik7XG4gICAgICAgIHRoaXMuY2hlY2tJbnRlcnZhbExlbmd0aCArPSA1ZTM7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGQoZS5tZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHVwZGF0ZVJlcyA9IGF3YWl0IHRoaXMud2FsbGV0LnN0YXRlLnVwZGF0ZShcbiAgICAgICAge1xuICAgICAgICAgIHN0b3JlOiBwcm9vZnMsXG4gICAgICAgICAgbWludDogdGhpcy5taW50XG4gICAgICAgIH0sXG4gICAgICAgIFwiRGVwb3NpdFwiXG4gICAgICApO1xuICAgICAgY29uc3QgdG9rZW5FdmVudCA9IHVwZGF0ZVJlcy5jcmVhdGVkO1xuICAgICAgaWYgKCF0b2tlbkV2ZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJubyB0b2tlbiBldmVudCBjcmVhdGVkXCIpO1xuICAgICAgY3JlYXRlSW5UeEV2ZW50KFxuICAgICAgICB0aGlzLndhbGxldC5uZGssXG4gICAgICAgIHByb29mcyxcbiAgICAgICAgdGhpcy5taW50LFxuICAgICAgICB1cGRhdGVSZXMsXG4gICAgICAgIHsgZGVzY3JpcHRpb246IFwiRGVwb3NpdFwiIH0sXG4gICAgICAgIHRoaXMud2FsbGV0LnJlbGF5U2V0XG4gICAgICApO1xuICAgICAgdGhpcy5lbWl0KFwic3VjY2Vzc1wiLCB0b2tlbkV2ZW50KTtcbiAgICAgIHRoaXMuZGVzdHJveVF1b3RlRXZlbnQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlLm1lc3NhZ2UpO1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZGVzdHJveVF1b3RlRXZlbnQoKSB7XG4gICAgaWYgKCF0aGlzLnF1b3RlRXZlbnQpIHJldHVybjtcbiAgICBjb25zdCBkZWxldGVFdmVudCA9IGF3YWl0IHRoaXMucXVvdGVFdmVudC5kZWxldGUodm9pZCAwLCBmYWxzZSk7XG4gICAgZGVsZXRlRXZlbnQucHVibGlzaCh0aGlzLndhbGxldC5yZWxheVNldCk7XG4gIH1cbn07XG5cbi8vIHNyYy93YWxsZXRzL2Nhc2h1L2V2ZW50LWhhbmRsZXJzL2luZGV4LnRzXG5pbXBvcnQgeyBOREtLaW5kIGFzIE5ES0tpbmQyIH0gZnJvbSBcIkBub3N0ci1kZXYta2l0L25ka1wiO1xuXG4vLyBzcmMvd2FsbGV0cy9jYXNodS9ldmVudC1oYW5kbGVycy9kZWxldGlvbi50c1xuYXN5bmMgZnVuY3Rpb24gaGFuZGxlRXZlbnREZWxldGlvbihldmVudCkge1xuICBjb25zdCBkZWxldGVkSWRzID0gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKS5tYXAoKHRhZykgPT4gdGFnWzFdKTtcbiAgZm9yIChjb25zdCBkZWxldGVkSWQgb2YgZGVsZXRlZElkcykge1xuICAgIHRoaXMuc3RhdGUucmVtb3ZlVG9rZW5JZChkZWxldGVkSWQpO1xuICB9XG59XG5cbi8vIHNyYy93YWxsZXRzL2Nhc2h1L2V2ZW50LWhhbmRsZXJzL3F1b3RlLnRzXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVRdW90ZShldmVudCkge1xuICBjb25zdCBxdW90ZSA9IGF3YWl0IE5ES0Nhc2h1UXVvdGUuZnJvbShldmVudCk7XG4gIGlmICghcXVvdGUpIHJldHVybjtcbiAgY29uc3QgZGVwb3NpdCA9IE5ES0Nhc2h1RGVwb3NpdC5mcm9tUXVvdGVFdmVudCh0aGlzLCBxdW90ZSk7XG4gIGlmICh0aGlzLmRlcG9zaXRNb25pdG9yLmFkZERlcG9zaXQoZGVwb3NpdCkpIHtcbiAgICBkZXBvc2l0LmZpbmFsaXplKCk7XG4gIH1cbn1cblxuLy8gc3JjL3dhbGxldHMvY2FzaHUvZXZlbnQtaGFuZGxlcnMvdG9rZW4udHNcbmltcG9ydCB7IE5ES0Nhc2h1VG9rZW4gfSBmcm9tIFwiQG5vc3RyLWRldi1raXQvbmRrXCI7XG52YXIgX2N1bXVsYXRpdmVUaW1lID0gMDtcbnZhciBfY3VtdWxhdGl2ZUNhbGxzID0gMDtcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVRva2VuKGV2ZW50KSB7XG4gIGlmICh0aGlzLnN0YXRlLnRva2Vucy5oYXMoZXZlbnQuaWQpKSByZXR1cm47XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gIGNvbnN0IHRva2VuID0gYXdhaXQgTkRLQ2FzaHVUb2tlbi5mcm9tKGV2ZW50KTtcbiAgaWYgKCF0b2tlbikge1xuICAgIF9jdW11bGF0aXZlVGltZSArPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIF9jdW11bGF0aXZlQ2FsbHMrKztcbiAgICByZXR1cm47XG4gIH1cbiAgX2N1bXVsYXRpdmVUaW1lICs9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gIF9jdW11bGF0aXZlQ2FsbHMrKztcbiAgZm9yIChjb25zdCBkZWxldGVkVG9rZW5JZCBvZiB0b2tlbi5kZWxldGVkVG9rZW5zKSB7XG4gICAgdGhpcy5zdGF0ZS5yZW1vdmVUb2tlbklkKGRlbGV0ZWRUb2tlbklkKTtcbiAgfVxuICB0aGlzLnN0YXRlLmFkZFRva2VuKHRva2VuKTtcbn1cbnNldEludGVydmFsKCgpID0+IHtcbn0sIDVlMyk7XG5cbi8vIHNyYy93YWxsZXRzL2Nhc2h1L2V2ZW50LWhhbmRsZXJzL2luZGV4LnRzXG52YXIgaGFuZGxlcnMgPSB7XG4gIFtOREtLaW5kMi5DYXNodVRva2VuXTogaGFuZGxlVG9rZW4sXG4gIFtOREtLaW5kMi5DYXNodVF1b3RlXTogaGFuZGxlUXVvdGUsXG4gIFtOREtLaW5kMi5FdmVudERlbGV0aW9uXTogaGFuZGxlRXZlbnREZWxldGlvblxufTtcbnZhciBiYWxhbmNlVXBkYXRlVGltZXIgPSBudWxsO1xuYXN5bmMgZnVuY3Rpb24gZXZlbnRIYW5kbGVyKGV2ZW50KSB7XG4gIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1tldmVudC5raW5kXTtcbiAgaWYgKGhhbmRsZXIpIHtcbiAgICBpZiAoYmFsYW5jZVVwZGF0ZVRpbWVyKSBjbGVhclRpbWVvdXQoYmFsYW5jZVVwZGF0ZVRpbWVyKTtcbiAgICBhd2FpdCBoYW5kbGVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIGJhbGFuY2VVcGRhdGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFwiYmFsYW5jZV91cGRhdGVkXCIpO1xuICAgIH0sIDEwMCk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGV2ZW50RHVwSGFuZGxlcihfZXZlbnQsIF9yZWxheSwgX3RpbWVTaW5jZUZpcnN0U2VlbiwgX3N1YiwgX2Zyb21DYWNoZSkge1xufVxuXG4vLyBzcmMvd2FsbGV0cy9jYXNodS92YWxpZGF0ZS50c1xuaW1wb3J0IHsgQ2hlY2tTdGF0ZUVudW0gfSBmcm9tIFwiQGNhc2h1L2Nhc2h1LXRzXCI7XG5pbXBvcnQgY3JlYXRlRGVidWcyIGZyb20gXCJkZWJ1Z1wiO1xudmFyIGQyID0gY3JlYXRlRGVidWcyKFwibmRrLXdhbGxldDpjYXNodTp2YWxpZGF0ZVwiKTtcbmFzeW5jIGZ1bmN0aW9uIGNvbnNvbGlkYXRlVG9rZW5zKCkge1xuICBkMihcImNoZWNraW5nICVkIHRva2VucyBmb3Igc3BlbnQgcHJvb2ZzXCIsIHRoaXMuc3RhdGUudG9rZW5zLnNpemUpO1xuICBjb25zdCBtaW50cyA9IG5ldyBTZXQoXG4gICAgdGhpcy5zdGF0ZS5nZXRNaW50c1Byb29mcyh7IHZhbGlkU3RhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJhdmFpbGFibGVcIiwgXCJyZXNlcnZlZFwiLCBcImRlbGV0ZWRcIl0pIH0pLmtleXMoKVxuICApO1xuICBkMihcImZvdW5kICVkIG1pbnRzXCIsIG1pbnRzLnNpemUpO1xuICBtaW50cy5mb3JFYWNoKChtaW50KSA9PiB7XG4gICAgY29uc29saWRhdGVNaW50VG9rZW5zKG1pbnQsIHRoaXMpO1xuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNvbnNvbGlkYXRlTWludFRva2VucyhtaW50LCB3YWxsZXQsIGFsbFByb29mcywgb25SZXN1bHQsIG9uRmFpbHVyZSkge1xuICBhbGxQcm9vZnMgPz89IHdhbGxldC5zdGF0ZS5nZXRQcm9vZnMoeyBtaW50LCBpbmNsdWRlRGVsZXRlZDogdHJ1ZSwgb25seUF2YWlsYWJsZTogZmFsc2UgfSk7XG4gIGNvbnN0IF93YWxsZXQgPSBhd2FpdCB3YWxsZXRGb3JNaW50KG1pbnQpO1xuICBpZiAoIV93YWxsZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHByb29mU3RhdGVzID0gW107XG4gIHRyeSB7XG4gICAgcHJvb2ZTdGF0ZXMgPSBhd2FpdCBfd2FsbGV0LmNoZWNrUHJvb2ZzU3RhdGVzKGFsbFByb29mcyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBvbkZhaWx1cmU/LihlLm1lc3NhZ2UpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzcGVudFByb29mcyA9IFtdO1xuICBjb25zdCB1bnNwZW50UHJvb2ZzID0gW107XG4gIGNvbnN0IHBlbmRpbmdQcm9vZnMgPSBbXTtcbiAgYWxsUHJvb2ZzLmZvckVhY2goKHByb29mLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHsgc3RhdGUgfSA9IHByb29mU3RhdGVzW2luZGV4XTtcbiAgICBpZiAoc3RhdGUgPT09IENoZWNrU3RhdGVFbnVtLlNQRU5UKSB7XG4gICAgICBzcGVudFByb29mcy5wdXNoKHByb29mKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBDaGVja1N0YXRlRW51bS5VTlNQRU5UKSB7XG4gICAgICB1bnNwZW50UHJvb2ZzLnB1c2gocHJvb2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nUHJvb2ZzLnB1c2gocHJvb2YpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHdhbGxldENoYW5nZSA9IHtcbiAgICBtaW50LFxuICAgIHN0b3JlOiB1bnNwZW50UHJvb2ZzLFxuICAgIGRlc3Ryb3k6IHNwZW50UHJvb2ZzXG4gIH07XG4gIG9uUmVzdWx0Py4od2FsbGV0Q2hhbmdlKTtcbiAgY29uc3QgX3RvdGFsU3BlbnRQcm9vZnMgPSBzcGVudFByb29mcy5yZWR1Y2UoKGFjYywgcHJvb2YpID0+IGFjYyArIHByb29mLmFtb3VudCwgMCk7XG4gIGlmICh3YWxsZXRDaGFuZ2UuZGVzdHJveT8ubGVuZ3RoID09PSAwKSByZXR1cm47XG4gIHdhbGxldENoYW5nZS5zdG9yZT8ucHVzaCguLi5wZW5kaW5nUHJvb2ZzKTtcbiAgY29uc3QgdG90YWxQZW5kaW5nUHJvb2ZzID0gcGVuZGluZ1Byb29mcy5yZWR1Y2UoKGFjYywgcHJvb2YpID0+IGFjYyArIHByb29mLmFtb3VudCwgMCk7XG4gIHdhbGxldC5zdGF0ZS5yZXNlcnZlUHJvb2ZzKHBlbmRpbmdQcm9vZnMsIHRvdGFsUGVuZGluZ1Byb29mcyk7XG4gIHJldHVybiB3YWxsZXQuc3RhdGUudXBkYXRlKHdhbGxldENoYW5nZSwgXCJDb25zb2xpZGF0ZVwiKTtcbn1cblxuLy8gc3JjL3dhbGxldHMvY2FzaHUvcGF5L2xuLnRzXG5pbXBvcnQgeyBNZWx0UXVvdGVTdGF0ZSB9IGZyb20gXCJAY2FzaHUvY2FzaHUtdHNcIjtcblxuLy8gc3JjL3dhbGxldHMvY2FzaHUvd2FsbGV0L2ZlZS50c1xuZnVuY3Rpb24gY2FsY3VsYXRlRmVlKGludGVuZGVkQW1vdW50LCBwcm92aWRlZFByb29mcywgcmV0dXJuZWRQcm9vZnMpIHtcbiAgY29uc3QgdG90YWxQcm92aWRlZCA9IHByb3ZpZGVkUHJvb2ZzLnJlZHVjZSgoYWNjLCBwKSA9PiBhY2MgKyBwLmFtb3VudCwgMCk7XG4gIGNvbnN0IHRvdGFsUmV0dXJuZWQgPSByZXR1cm5lZFByb29mcy5yZWR1Y2UoKGFjYywgcCkgPT4gYWNjICsgcC5hbW91bnQsIDApO1xuICBjb25zdCB0b3RhbEZlZSA9IHRvdGFsUHJvdmlkZWQgLSBpbnRlbmRlZEFtb3VudCAtIHRvdGFsUmV0dXJuZWQ7XG4gIGlmICh0b3RhbEZlZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGZlZSBjYWxjdWxhdGlvbjogcmVjZWl2ZWQgbW9yZSBwcm9vZnMgdGhhbiBzZW50IHRvIG1pbnRcIik7XG4gIH1cbiAgcmV0dXJuIHRvdGFsRmVlO1xufVxuXG4vLyBzcmMvd2FsbGV0cy9jYXNodS93YWxsZXQvZWZmZWN0LnRzXG5hc3luYyBmdW5jdGlvbiB3aXRoUHJvb2ZSZXNlcnZlKHdhbGxldCwgY2FzaHVXYWxsZXQsIG1pbnQsIGFtb3VudFdpdGhGZWVzLCBhbW91bnRXaXRob3V0RmVlcywgY2IpIHtcbiAgY2FzaHVXYWxsZXQgPz89IGF3YWl0IHdhbGxldC5nZXRDYXNodVdhbGxldChtaW50KTtcbiAgY29uc3QgYXZhaWxhYmxlTWludFByb29mcyA9IHdhbGxldC5zdGF0ZS5nZXRQcm9vZnMoeyBtaW50LCBvbmx5QXZhaWxhYmxlOiB0cnVlIH0pO1xuICBjb25zdCBwcm9vZnMgPSBjYXNodVdhbGxldC5zZWxlY3RQcm9vZnNUb1NlbmQoYXZhaWxhYmxlTWludFByb29mcywgYW1vdW50V2l0aEZlZXMpO1xuICBjb25zdCBmZXRjaGVkQW1vdW50ID0gcHJvb2ZzLnNlbmQucmVkdWNlKChhLCBiKSA9PiBhICsgYi5hbW91bnQsIDApO1xuICBpZiAoZmV0Y2hlZEFtb3VudCA8IGFtb3VudFdpdGhGZWVzKSByZXR1cm4gbnVsbDtcbiAgd2FsbGV0LnN0YXRlLnJlc2VydmVQcm9vZnMocHJvb2ZzLnNlbmQsIGFtb3VudFdpdGhGZWVzKTtcbiAgbGV0IGNiUmVzdWx0ID0gbnVsbDtcbiAgbGV0IHByb29mc0NoYW5nZSA9IG51bGw7XG4gIGxldCB1cGRhdGVSZXMgPSBudWxsO1xuICB0cnkge1xuICAgIGNiUmVzdWx0ID0gYXdhaXQgY2IocHJvb2ZzLnNlbmQsIGF2YWlsYWJsZU1pbnRQcm9vZnMpO1xuICAgIGlmICghY2JSZXN1bHQpIHJldHVybiBudWxsO1xuICAgIHByb29mc0NoYW5nZSA9IHtcbiAgICAgIG1pbnQsXG4gICAgICBzdG9yZTogY2JSZXN1bHQuY2hhbmdlLFxuICAgICAgZGVzdHJveTogcHJvb2ZzLnNlbmRcbiAgICB9O1xuICAgIHVwZGF0ZVJlcyA9IGF3YWl0IHdhbGxldC5zdGF0ZS51cGRhdGUocHJvb2ZzQ2hhbmdlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHdhbGxldC5zdGF0ZS51bnJlc2VydmVQcm9vZnMocHJvb2ZzLnNlbmQsIGFtb3VudFdpdGhGZWVzLCBcImF2YWlsYWJsZVwiKTtcbiAgICB0aHJvdyBlO1xuICB9XG4gIGlmICghY2JSZXN1bHQpIHJldHVybiBudWxsO1xuICByZXR1cm4ge1xuICAgIHJlc3VsdDogY2JSZXN1bHQucmVzdWx0LFxuICAgIHByb29mc0NoYW5nZSxcbiAgICBzdGF0ZVVwZGF0ZTogdXBkYXRlUmVzLFxuICAgIG1pbnQsXG4gICAgZmVlOiBjYWxjdWxhdGVGZWUoYW1vdW50V2l0aG91dEZlZXMsIHByb29mcy5zZW5kLCBjYlJlc3VsdC5jaGFuZ2UpXG4gIH07XG59XG5cbi8vIHNyYy93YWxsZXRzL2Nhc2h1L3BheS9sbi50c1xuYXN5bmMgZnVuY3Rpb24gcGF5TG4od2FsbGV0LCBwciwgeyBhbW91bnQsIHVuaXQgfSA9IHt9KSB7XG4gIGxldCBpbnZvaWNlQW1vdW50ID0gZ2V0Qm9sdDExQW1vdW50KHByKTtcbiAgaWYgKCFpbnZvaWNlQW1vdW50KSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZvaWNlIGFtb3VudCBpcyByZXF1aXJlZFwiKTtcbiAgaW52b2ljZUFtb3VudCA9IGludm9pY2VBbW91bnQgLyAxZTM7XG4gIGlmIChhbW91bnQgJiYgdW5pdCkge1xuICAgIGlmICh1bml0ID09PSBcIm1zYXRcIikge1xuICAgICAgYW1vdW50ID0gYW1vdW50IC8gMWUzO1xuICAgIH1cbiAgfVxuICBjb25zdCBlbGlnaWJsZU1pbnRzID0gd2FsbGV0LmdldE1pbnRzV2l0aEJhbGFuY2UoaW52b2ljZUFtb3VudCArIDMpO1xuICBpZiAoIWVsaWdpYmxlTWludHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZm9yIChjb25zdCBtaW50IG9mIGVsaWdpYmxlTWludHMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0ZVBheW1lbnQobWludCwgcHIsIGFtb3VudCA/PyBpbnZvaWNlQW1vdW50LCB3YWxsZXQpO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBpZiAoYW1vdW50KSB7XG4gICAgICAgICAgcmVzdWx0LmZlZSA9IGNhbGN1bGF0ZUZlZShcbiAgICAgICAgICAgIGFtb3VudCxcbiAgICAgICAgICAgIHJlc3VsdC5wcm9vZnNDaGFuZ2U/LmRlc3Ryb3kgPz8gW10sXG4gICAgICAgICAgICByZXN1bHQucHJvb2ZzQ2hhbmdlPy5zdG9yZSA/PyBbXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgd2FsbGV0Lndhcm4oYEZhaWxlZCB0byBleGVjdXRlIHBheW1lbnQgd2l0aCBtaW4gJHttaW50fTogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBleGVjdXRlUGF5bWVudChtaW50LCBwciwgYW1vdW50V2l0aG91dEZlZXMsIHdhbGxldCkge1xuICBjb25zdCBjYXNodVdhbGxldCA9IGF3YWl0IHdhbGxldC5nZXRDYXNodVdhbGxldChtaW50KTtcbiAgdHJ5IHtcbiAgICBjb25zdCBtZWx0UXVvdGUgPSBhd2FpdCBjYXNodVdhbGxldC5jcmVhdGVNZWx0UXVvdGUocHIpO1xuICAgIGNvbnN0IGFtb3VudFRvU2VuZCA9IG1lbHRRdW90ZS5hbW91bnQgKyBtZWx0UXVvdGUuZmVlX3Jlc2VydmU7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd2l0aFByb29mUmVzZXJ2ZShcbiAgICAgIHdhbGxldCxcbiAgICAgIGNhc2h1V2FsbGV0LFxuICAgICAgbWludCxcbiAgICAgIGFtb3VudFRvU2VuZCxcbiAgICAgIGFtb3VudFdpdGhvdXRGZWVzLFxuICAgICAgYXN5bmMgKHByb29mc1RvVXNlLCBfYWxsT3VyUHJvb2ZzKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lbHRSZXN1bHQgPSBhd2FpdCBjYXNodVdhbGxldC5tZWx0UHJvb2ZzKG1lbHRRdW90ZSwgcHJvb2ZzVG9Vc2UpO1xuICAgICAgICBpZiAobWVsdFJlc3VsdC5xdW90ZS5zdGF0ZSA9PT0gTWVsdFF1b3RlU3RhdGUuUEFJRCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgICAgcHJlaW1hZ2U6IG1lbHRSZXN1bHQucXVvdGUucGF5bWVudF9wcmVpbWFnZSA/PyBcIlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hhbmdlOiBtZWx0UmVzdWx0LmNoYW5nZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgaWYgKGUubWVzc2FnZS5tYXRjaCgvYWxyZWFkeSBzcGVudC9pKSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjb25zb2xpZGF0ZU1pbnRUb2tlbnMobWludCwgd2FsbGV0KTtcbiAgICAgICAgfSwgMjUwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyBzcmMvd2FsbGV0cy9jYXNodS9wYXkvbnV0LnRzXG5pbXBvcnQgeyBub3JtYWxpemVVcmwgfSBmcm9tIFwiQG5vc3RyLWRldi1raXQvbmRrXCI7XG5cbi8vIHNyYy91dGlscy9jYXNodS50c1xuZnVuY3Rpb24gZW5zdXJlSXNDYXNodVB1YmtleShwdWJrZXkpIHtcbiAgaWYgKCFwdWJrZXkpIHJldHVybjtcbiAgbGV0IF9wdWJrZXkgPSBwdWJrZXk7XG4gIGlmIChfcHVia2V5Lmxlbmd0aCA9PT0gNjQpIF9wdWJrZXkgPSBgMDIke19wdWJrZXl9YDtcbiAgaWYgKF9wdWJrZXkubGVuZ3RoICE9PSA2NikgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwdWJrZXlcIik7XG4gIHJldHVybiBfcHVia2V5O1xufVxuYXN5bmMgZnVuY3Rpb24gbWludFByb29mcyh3YWxsZXQsIHF1b3RlLCBhbW91bnQsIG1pbnQsIHAycGspIHtcbiAgY29uc3QgbWludFRva2VuQXR0ZW1wdCA9IChyZXNvbHZlLCByZWplY3QsIGF0dGVtcHQpID0+IHtcbiAgICBjb25zdCBwdWJrZXkgPSBlbnN1cmVJc0Nhc2h1UHVia2V5KHAycGspO1xuICAgIHdhbGxldC5taW50UHJvb2ZzKGFtb3VudCwgcXVvdGUucXVvdGUsIHsgcHVia2V5IH0pLnRoZW4oKG1pbnRQcm9vZnMyKSA9PiB7XG4gICAgICBjb25zb2xlLmRlYnVnKFwibWludGVkIHRva2Vuc1wiLCBtaW50UHJvb2ZzMik7XG4gICAgICByZXNvbHZlKHtcbiAgICAgICAgcHJvb2ZzOiBtaW50UHJvb2ZzMixcbiAgICAgICAgbWludFxuICAgICAgfSk7XG4gICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgIGF0dGVtcHQrKztcbiAgICAgIGlmIChhdHRlbXB0IDw9IDMpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcImVycm9yIG1pbnRpbmcgdG9rZW5zXCIsIGUpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IG1pbnRUb2tlbkF0dGVtcHQocmVzb2x2ZSwgcmVqZWN0LCBhdHRlbXB0KSwgYXR0ZW1wdCAqIDE1MDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG1pbnRUb2tlbkF0dGVtcHQocmVzb2x2ZSwgcmVqZWN0LCAwKTtcbiAgfSk7XG59XG5cbi8vIHNyYy93YWxsZXRzL2Nhc2h1L3BheS9udXQudHNcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRva2VuKHdhbGxldCwgYW1vdW50LCByZWNpcGllbnRNaW50cywgcDJwaykge1xuICBwMnBrID0gZW5zdXJlSXNDYXNodVB1YmtleShwMnBrKTtcbiAgY29uc3QgbXlNaW50c1dpdGhFbm91Z2hCYWxhbmNlID0gd2FsbGV0LmdldE1pbnRzV2l0aEJhbGFuY2UoYW1vdW50KTtcbiAgY29uc3QgaGFzUmVjaXBpZW50TWludHMgPSByZWNpcGllbnRNaW50cyAmJiByZWNpcGllbnRNaW50cy5sZW5ndGggPiAwO1xuICBjb25zdCBtaW50c0luQ29tbW9uID0gaGFzUmVjaXBpZW50TWludHMgPyBmaW5kTWludHNJbkNvbW1vbihbcmVjaXBpZW50TWludHMsIG15TWludHNXaXRoRW5vdWdoQmFsYW5jZV0pIDogbXlNaW50c1dpdGhFbm91Z2hCYWxhbmNlO1xuICBmb3IgKGNvbnN0IG1pbnQgb2YgbWludHNJbkNvbW1vbikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBjcmVhdGVUb2tlbkluTWludCh3YWxsZXQsIG1pbnQsIGFtb3VudCwgcDJwayk7XG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1JlY2lwaWVudE1pbnRzKSB7XG4gICAgcmV0dXJuIGF3YWl0IGNyZWF0ZVRva2VuV2l0aE1pbnRUcmFuc2Zlcih3YWxsZXQsIGFtb3VudCwgcmVjaXBpZW50TWludHMsIHAycGspO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlVG9rZW5Jbk1pbnQod2FsbGV0LCBtaW50LCBhbW91bnQsIHAycGspIHtcbiAgY29uc3QgY2FzaHVXYWxsZXQgPSBhd2FpdCB3YWxsZXQuZ2V0Q2FzaHVXYWxsZXQobWludCk7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgd2l0aFByb29mUmVzZXJ2ZShcbiAgICAgIHdhbGxldCxcbiAgICAgIGNhc2h1V2FsbGV0LFxuICAgICAgbWludCxcbiAgICAgIGFtb3VudCxcbiAgICAgIGFtb3VudCxcbiAgICAgIGFzeW5jIChwcm9vZnNUb1VzZSwgYWxsT3VyUHJvb2ZzKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbmRSZXN1bHQgPSBhd2FpdCBjYXNodVdhbGxldC5zZW5kKGFtb3VudCwgcHJvb2ZzVG9Vc2UsIHtcbiAgICAgICAgICBwdWJrZXk6IHAycGssXG4gICAgICAgICAgcHJvb2ZzV2VIYXZlOiBhbGxPdXJQcm9vZnNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICBwcm9vZnM6IHNlbmRSZXN1bHQuc2VuZCxcbiAgICAgICAgICAgIG1pbnRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoYW5nZTogc2VuZFJlc3VsdC5rZWVwLFxuICAgICAgICAgIG1pbnRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKF9lKSB7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVUb2tlbldpdGhNaW50VHJhbnNmZXIod2FsbGV0LCBhbW91bnQsIHJlY2lwaWVudE1pbnRzLCBwMnBrKSB7XG4gIGNvbnN0IGdlbmVyYXRlUXVvdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgZ2VuZXJhdGVRdW90ZUZyb21Tb21lTWludCA9IGFzeW5jIChtaW50MykgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0TWludFdhbGxldDMgPSBhd2FpdCB3YWxsZXRGb3JNaW50KG1pbnQzKTtcbiAgICAgIGlmICghdGFyZ2V0TWludFdhbGxldDMpIHRocm93IG5ldyBFcnJvcihgdW5hYmxlIHRvIGxvYWQgd2FsbGV0IGZvciBtaW50ICR7bWludDN9YCk7XG4gICAgICBjb25zdCBxdW90ZTMgPSBhd2FpdCB0YXJnZXRNaW50V2FsbGV0My5jcmVhdGVNaW50UXVvdGUoYW1vdW50KTtcbiAgICAgIHJldHVybiB7IHF1b3RlOiBxdW90ZTMsIG1pbnQ6IG1pbnQzLCB0YXJnZXRNaW50V2FsbGV0OiB0YXJnZXRNaW50V2FsbGV0MyB9O1xuICAgIH07XG4gICAgY29uc3QgcXVvdGVzUHJvbWlzZXMgPSByZWNpcGllbnRNaW50cy5tYXAoZ2VuZXJhdGVRdW90ZUZyb21Tb21lTWludCk7XG4gICAgY29uc3QgeyBxdW90ZTogcXVvdGUyLCBtaW50OiBtaW50MiwgdGFyZ2V0TWludFdhbGxldDogdGFyZ2V0TWludFdhbGxldDIgfSA9IGF3YWl0IFByb21pc2UuYW55KHF1b3Rlc1Byb21pc2VzKTtcbiAgICBpZiAoIXF1b3RlMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmFpbGVkIHRvIGdldCBxdW90ZSBmcm9tIGFueSBtaW50XCIpO1xuICAgIH1cbiAgICByZXR1cm4geyBxdW90ZTogcXVvdGUyLCBtaW50OiBtaW50MiwgdGFyZ2V0TWludFdhbGxldDogdGFyZ2V0TWludFdhbGxldDIgfTtcbiAgfTtcbiAgY29uc3QgeyBxdW90ZSwgbWludDogdGFyZ2V0TWludCwgdGFyZ2V0TWludFdhbGxldCB9ID0gYXdhaXQgZ2VuZXJhdGVRdW90ZSgpO1xuICBpZiAoIXF1b3RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaW52b2ljZUFtb3VudCA9IGdldEJvbHQxMUFtb3VudChxdW90ZS5yZXF1ZXN0KTtcbiAgaWYgKCFpbnZvaWNlQW1vdW50KSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZvaWNlIGFtb3VudCBpcyByZXF1aXJlZFwiKTtcbiAgY29uc3QgaW52b2ljZUFtb3VudEluU2F0ID0gaW52b2ljZUFtb3VudCAvIDFlMztcbiAgaWYgKGludm9pY2VBbW91bnRJblNhdCA+IGFtb3VudClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludm9pY2UgYW1vdW50IGlzIG1vcmUgdGhhbiB0aGUgYW1vdW50IHBhc3NlZCBpbiAoJHtpbnZvaWNlQW1vdW50SW5TYXR9IHZzICR7YW1vdW50fSlgKTtcbiAgY29uc3QgcGF5TE5SZXN1bHQgPSBhd2FpdCBwYXlMbih3YWxsZXQsIHF1b3RlLnJlcXVlc3QsIHsgYW1vdW50IH0pO1xuICBpZiAoIXBheUxOUmVzdWx0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgeyBwcm9vZnMsIG1pbnQgfSA9IGF3YWl0IG1pbnRQcm9vZnModGFyZ2V0TWludFdhbGxldCwgcXVvdGUsIGFtb3VudCwgdGFyZ2V0TWludCwgcDJwayk7XG4gIHJldHVybiB7XG4gICAgLi4ucGF5TE5SZXN1bHQsXG4gICAgcmVzdWx0OiB7IHByb29mcywgbWludCB9LFxuICAgIGZlZTogcGF5TE5SZXN1bHQuZmVlXG4gIH07XG59XG5mdW5jdGlvbiBmaW5kTWludHNJbkNvbW1vbihtaW50Q29sbGVjdGlvbnMpIHtcbiAgY29uc3QgbWludENvdW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgbWludHMgb2YgbWludENvbGxlY3Rpb25zKSB7XG4gICAgZm9yIChjb25zdCBtaW50IG9mIG1pbnRzKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkTWludCA9IG5vcm1hbGl6ZVVybChtaW50KTtcbiAgICAgIGlmICghbWludENvdW50cy5oYXMobm9ybWFsaXplZE1pbnQpKSB7XG4gICAgICAgIG1pbnRDb3VudHMuc2V0KG5vcm1hbGl6ZWRNaW50LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pbnRDb3VudHMuc2V0KG5vcm1hbGl6ZWRNaW50LCBtaW50Q291bnRzLmdldChub3JtYWxpemVkTWludCkgKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgY29tbW9uTWludHMgPSBbXTtcbiAgZm9yIChjb25zdCBbbWludCwgY291bnRdIG9mIG1pbnRDb3VudHMuZW50cmllcygpKSB7XG4gICAgaWYgKGNvdW50ID09PSBtaW50Q29sbGVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb21tb25NaW50cy5wdXNoKG1pbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29tbW9uTWludHM7XG59XG5cbi8vIHNyYy93YWxsZXRzL2Nhc2h1L3dhbGxldC9wYXltZW50LnRzXG52YXIgUGF5bWVudEhhbmRsZXIgPSBjbGFzcyB7XG4gIHdhbGxldDtcbiAgY29uc3RydWN0b3Iod2FsbGV0KSB7XG4gICAgdGhpcy53YWxsZXQgPSB3YWxsZXQ7XG4gIH1cbiAgLyoqXG4gICAqIFBheSBhIExOIGludm9pY2Ugd2l0aCB0aGlzIHdhbGxldC4gVGhpcyB3aWxsIHVzZWQgY2FzaHUgcHJvb2ZzIHRvIHBheSBhIGJvbHQxMS5cbiAgICovXG4gIGFzeW5jIGxuUGF5KHBheW1lbnQsIGNyZWF0ZVR4RXZlbnQgPSB0cnVlKSB7XG4gICAgaWYgKCFwYXltZW50LnByKSB0aHJvdyBuZXcgRXJyb3IoXCJwciBpcyByZXF1aXJlZFwiKTtcbiAgICBjb25zdCBpbnZvaWNlQW1vdW50ID0gZ2V0Qm9sdDExQW1vdW50KHBheW1lbnQucHIpO1xuICAgIGlmICghaW52b2ljZUFtb3VudCkgdGhyb3cgbmV3IEVycm9yKFwiaW52b2ljZSBhbW91bnQgaXMgcmVxdWlyZWRcIik7XG4gICAgaWYgKHBheW1lbnQuYW1vdW50ICYmIGludm9pY2VBbW91bnQgPiBwYXltZW50LmFtb3VudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52b2ljZSBhbW91bnQgaXMgbW9yZSB0aGFuIHRoZSBhbW91bnQgcGFzc2VkIGluXCIpO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCBwYXlMbih0aGlzLndhbGxldCwgcGF5bWVudC5wciwge1xuICAgICAgYW1vdW50OiBwYXltZW50LmFtb3VudCxcbiAgICAgIHVuaXQ6IHBheW1lbnQudW5pdFxuICAgIH0pO1xuICAgIGlmICghcmVzPy5yZXN1bHQ/LnByZWltYWdlKSByZXR1cm47XG4gICAgaWYgKGNyZWF0ZVR4RXZlbnQpIHtcbiAgICAgIGNyZWF0ZU91dFR4RXZlbnQodGhpcy53YWxsZXQubmRrLCBwYXltZW50LCByZXMsIHRoaXMud2FsbGV0LnJlbGF5U2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIFN3YXBzIHRva2VucyB0byBhIHNwZWNpZmljIGFtb3VudCwgb3B0aW9uYWxseSBsb2NraW5nIHRvIGEgcDJway5cbiAgICovXG4gIGFzeW5jIGNhc2h1UGF5KHBheW1lbnQpIHtcbiAgICBjb25zdCBzYXRQYXltZW50ID0geyAuLi5wYXltZW50IH07XG4gICAgaWYgKHNhdFBheW1lbnQudW5pdD8uc3RhcnRzV2l0aChcIm1zYXRcIikpIHtcbiAgICAgIHNhdFBheW1lbnQuYW1vdW50ID0gc2F0UGF5bWVudC5hbW91bnQgLyAxZTM7XG4gICAgICBzYXRQYXltZW50LnVuaXQgPSBcInNhdFwiO1xuICAgIH1cbiAgICBsZXQgY3JlYXRlUmVzdWx0ID0gYXdhaXQgY3JlYXRlVG9rZW4odGhpcy53YWxsZXQsIHNhdFBheW1lbnQuYW1vdW50LCBwYXltZW50Lm1pbnRzLCBwYXltZW50LnAycGspO1xuICAgIGlmICghY3JlYXRlUmVzdWx0KSB7XG4gICAgICBpZiAocGF5bWVudC5hbGxvd0ludHJhbWludEZhbGxiYWNrKSB7XG4gICAgICAgIGNyZWF0ZVJlc3VsdCA9IGF3YWl0IGNyZWF0ZVRva2VuKHRoaXMud2FsbGV0LCBzYXRQYXltZW50LmFtb3VudCwgdm9pZCAwLCBwYXltZW50LnAycGspO1xuICAgICAgfVxuICAgICAgaWYgKCFjcmVhdGVSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVPdXRUeEV2ZW50KHRoaXMud2FsbGV0Lm5kaywgc2F0UGF5bWVudCwgY3JlYXRlUmVzdWx0LCB0aGlzLndhbGxldC5yZWxheVNldCk7XG4gICAgcmV0dXJuIGNyZWF0ZVJlc3VsdC5yZXN1bHQ7XG4gIH1cbn07XG5cbi8vIHNyYy93YWxsZXRzL2Nhc2h1L3dhbGxldC9zdGF0ZS9iYWxhbmNlLnRzXG5mdW5jdGlvbiBnZXRCYWxhbmNlKG9wdHMpIHtcbiAgY29uc3QgcHJvb2ZzID0gdGhpcy5nZXRQcm9vZkVudHJpZXMob3B0cyk7XG4gIHJldHVybiBwcm9vZnMucmVkdWNlKChzdW0sIHByb29mKSA9PiBzdW0gKyBwcm9vZi5wcm9vZi5hbW91bnQsIDApO1xufVxuZnVuY3Rpb24gZ2V0TWludHNCYWxhbmNlcyh7IG9ubHlBdmFpbGFibGUgfSA9IHsgb25seUF2YWlsYWJsZTogdHJ1ZSB9KSB7XG4gIGNvbnN0IGJhbGFuY2VzID0ge307XG4gIGNvbnN0IHByb29mcyA9IHRoaXMuZ2V0UHJvb2ZFbnRyaWVzKHsgb25seUF2YWlsYWJsZSB9KTtcbiAgZm9yIChjb25zdCBwcm9vZiBvZiBwcm9vZnMpIHtcbiAgICBpZiAoIXByb29mLm1pbnQpIGNvbnRpbnVlO1xuICAgIGJhbGFuY2VzW3Byb29mLm1pbnRdID8/PSAwO1xuICAgIGJhbGFuY2VzW3Byb29mLm1pbnRdICs9IHByb29mLnByb29mLmFtb3VudDtcbiAgfVxuICByZXR1cm4gYmFsYW5jZXM7XG59XG5cbi8vIHNyYy93YWxsZXRzL2Nhc2h1L3dhbGxldC9zdGF0ZS9wcm9vZnMudHNcbmZ1bmN0aW9uIGFkZFByb29mKHByb29mRW50cnkpIHtcbiAgdGhpcy5wcm9vZnMuc2V0KHByb29mRW50cnkucHJvb2YuQywgcHJvb2ZFbnRyeSk7XG4gIHRoaXMuam91cm5hbC5wdXNoKHtcbiAgICBtZW1vOiBcIkFkZGVkIHByb29mXCIsXG4gICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgIG1ldGFkYXRhOiB7XG4gICAgICB0eXBlOiBcInByb29mXCIsXG4gICAgICBpZDogcHJvb2ZFbnRyeS5wcm9vZi5DLFxuICAgICAgYW1vdW50OiBwcm9vZkVudHJ5LnByb29mLmFtb3VudCxcbiAgICAgIG1pbnQ6IHByb29mRW50cnkubWludFxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXNlcnZlUHJvb2ZzKHByb29mcywgYW1vdW50KSB7XG4gIGZvciAoY29uc3QgcHJvb2Ygb2YgcHJvb2ZzKSB7XG4gICAgdGhpcy51cGRhdGVQcm9vZihwcm9vZiwgeyBzdGF0ZTogXCJyZXNlcnZlZFwiIH0pO1xuICB9XG4gIHRoaXMucmVzZXJ2ZUFtb3VudHMucHVzaChhbW91bnQpO1xufVxuZnVuY3Rpb24gdW5yZXNlcnZlUHJvb2ZzKHByb29mcywgYW1vdW50LCBuZXdTdGF0ZSkge1xuICBmb3IgKGNvbnN0IHByb29mIG9mIHByb29mcykge1xuICAgIHRoaXMudXBkYXRlUHJvb2YocHJvb2YsIHsgc3RhdGU6IG5ld1N0YXRlIH0pO1xuICB9XG4gIGNvbnN0IGluZGV4ID0gdGhpcy5yZXNlcnZlQW1vdW50cy5pbmRleE9mKGFtb3VudCk7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICB0aGlzLnJlc2VydmVBbW91bnRzLnNwbGljZShpbmRleCwgMSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBCVUc6IEFtb3VudCAke2Ftb3VudH0gbm90IGZvdW5kIGluIHJlc2VydmVBbW91bnRzYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFByb29mRW50cmllcyhvcHRzID0ge30pIHtcbiAgY29uc3QgcHJvb2ZzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgdmFsaWRTdGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJhdmFpbGFibGVcIl0pO1xuICBsZXQgeyBtaW50LCBvbmx5QXZhaWxhYmxlLCBpbmNsdWRlRGVsZXRlZCB9ID0gb3B0cztcbiAgb25seUF2YWlsYWJsZSA/Pz0gdHJ1ZTtcbiAgaWYgKCFvbmx5QXZhaWxhYmxlKSB2YWxpZFN0YXRlcy5hZGQoXCJyZXNlcnZlZFwiKTtcbiAgaWYgKGluY2x1ZGVEZWxldGVkKSB2YWxpZFN0YXRlcy5hZGQoXCJkZWxldGVkXCIpO1xuICBmb3IgKGNvbnN0IHByb29mRW50cnkgb2YgdGhpcy5wcm9vZnMudmFsdWVzKCkpIHtcbiAgICBpZiAobWludCAmJiBwcm9vZkVudHJ5Lm1pbnQgIT09IG1pbnQpIGNvbnRpbnVlO1xuICAgIGlmICghdmFsaWRTdGF0ZXMuaGFzKHByb29mRW50cnkuc3RhdGUpKSBjb250aW51ZTtcbiAgICBpZiAoIXByb29mRW50cnkucHJvb2YpIGNvbnRpbnVlO1xuICAgIHByb29mcy5zZXQocHJvb2ZFbnRyeS5wcm9vZi5DLCBwcm9vZkVudHJ5KTtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShwcm9vZnMudmFsdWVzKCkpO1xufVxuZnVuY3Rpb24gdXBkYXRlUHJvb2YocHJvb2YsIHN0YXRlKSB7XG4gIGNvbnN0IHByb29mQyA9IHByb29mLkM7XG4gIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMucHJvb2ZzLmdldChwcm9vZkMpO1xuICBpZiAoIWN1cnJlbnRTdGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiUHJvb2Ygbm90IGZvdW5kXCIpO1xuICBjb25zdCBuZXdTdGF0ZSA9IHsgLi4uY3VycmVudFN0YXRlLCAuLi5zdGF0ZSB9O1xuICB0aGlzLnByb29mcy5zZXQocHJvb2ZDLCBuZXdTdGF0ZSk7XG4gIHRoaXMuam91cm5hbC5wdXNoKHtcbiAgICBtZW1vOiBgVXBkYXRlZCBwcm9vZiBzdGF0ZTogJHtKU09OLnN0cmluZ2lmeShzdGF0ZSl9YCxcbiAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIHR5cGU6IFwicHJvb2ZcIixcbiAgICAgIGlkOiBwcm9vZkMsXG4gICAgICBhbW91bnQ6IHByb29mLmFtb3VudCxcbiAgICAgIG1pbnQ6IGN1cnJlbnRTdGF0ZS5taW50XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL3dhbGxldHMvY2FzaHUvd2FsbGV0L3N0YXRlL3Rva2VuLnRzXG5mdW5jdGlvbiBhZGRUb2tlbih0b2tlbikge1xuICBpZiAoIXRva2VuLm1pbnQpIHRocm93IG5ldyBFcnJvcihcIkJVRzogVG9rZW4gaGFzIG5vIG1pbnRcIik7XG4gIGNvbnN0IGN1cnJlbnRFbnRyeSA9IHRoaXMudG9rZW5zLmdldCh0b2tlbi5pZCk7XG4gIGNvbnN0IHN0YXRlID0gY3VycmVudEVudHJ5Py5zdGF0ZSA/PyBcImF2YWlsYWJsZVwiO1xuICB0aGlzLnRva2Vucy5zZXQodG9rZW4uaWQsIHsgdG9rZW4sIHN0YXRlIH0pO1xuICBsZXQgX2FkZGVkID0gMDtcbiAgbGV0IF9pbnZhbGlkID0gMDtcbiAgZm9yIChjb25zdCBwcm9vZiBvZiB0b2tlbi5wcm9vZnMpIHtcbiAgICBjb25zdCB2YWwgPSBtYXliZUFzc29jaWF0ZVByb29mV2l0aFRva2VuKHRoaXMsIHByb29mLCB0b2tlbiwgc3RhdGUpO1xuICAgIGlmICh2YWwgPT09IGZhbHNlKSB7XG4gICAgICBfaW52YWxpZCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYWRkZWQrKztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1heWJlQXNzb2NpYXRlUHJvb2ZXaXRoVG9rZW4od2FsbGV0U3RhdGUsIHByb29mLCB0b2tlbiwgc3RhdGUpIHtcbiAgY29uc3QgcHJvb2ZDID0gcHJvb2YuQztcbiAgY29uc3QgcHJvb2ZFbnRyeSA9IHdhbGxldFN0YXRlLnByb29mcy5nZXQocHJvb2ZDKTtcbiAgaWYgKCFwcm9vZkVudHJ5KSB7XG4gICAgd2FsbGV0U3RhdGUuYWRkUHJvb2Yoe1xuICAgICAgbWludDogdG9rZW4ubWludCxcbiAgICAgIHN0YXRlLFxuICAgICAgdG9rZW5JZDogdG9rZW4uaWQsXG4gICAgICB0aW1lc3RhbXA6IHRva2VuLmNyZWF0ZWRfYXQsXG4gICAgICBwcm9vZlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChwcm9vZkVudHJ5LnRva2VuSWQpIHtcbiAgICBpZiAocHJvb2ZFbnRyeS50b2tlbklkID09PSB0b2tlbi5pZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nVG9rZW5FbnRyeSA9IHdhbGxldFN0YXRlLnRva2Vucy5nZXQocHJvb2ZFbnRyeS50b2tlbklkKTtcbiAgICBpZiAoIWV4aXN0aW5nVG9rZW5FbnRyeSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQlVHOiBUb2tlbiBpZCAke3Byb29mRW50cnkudG9rZW5JZH0gbm90IGZvdW5kLCB3YXMgZXhwZWN0ZWQgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHByb29mICR7cHJvb2ZDfWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nVG9rZW4gPSBleGlzdGluZ1Rva2VuRW50cnkudG9rZW47XG4gICAgaWYgKGV4aXN0aW5nVG9rZW4pIHtcbiAgICAgIGlmIChleGlzdGluZ1Rva2VuLmNyZWF0ZWRfYXQgJiYgKCF0b2tlbi5jcmVhdGVkX2F0IHx8IHRva2VuLmNyZWF0ZWRfYXQgPCBleGlzdGluZ1Rva2VuLmNyZWF0ZWRfYXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2FsbGV0U3RhdGUudXBkYXRlUHJvb2YocHJvb2YsIHsgdG9rZW5JZDogdG9rZW4uaWQsIHN0YXRlIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHdhbGxldFN0YXRlLnVwZGF0ZVByb29mKHByb29mLCB7IHRva2VuSWQ6IHRva2VuLmlkLCBzdGF0ZSB9KTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZW1vdmVUb2tlbklkKHRva2VuSWQpIHtcbiAgY29uc3QgY3VycmVudEVudHJ5ID0gdGhpcy50b2tlbnMuZ2V0KHRva2VuSWQpIHx8IHt9O1xuICB0aGlzLnRva2Vucy5zZXQodG9rZW5JZCwgeyAuLi5jdXJyZW50RW50cnksIHN0YXRlOiBcImRlbGV0ZWRcIiB9KTtcbiAgZm9yIChjb25zdCBwcm9vZkVudHJ5IG9mIHRoaXMucHJvb2ZzLnZhbHVlcygpKSB7XG4gICAgY29uc3QgeyBwcm9vZiB9ID0gcHJvb2ZFbnRyeTtcbiAgICBpZiAocHJvb2ZFbnRyeS50b2tlbklkID09PSB0b2tlbklkKSB7XG4gICAgICBpZiAoIXByb29mKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJVRzogUHJvb2YgZW50cnkgaGFzIG5vIHByb29mXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVQcm9vZihwcm9vZiwgeyBzdGF0ZTogXCJkZWxldGVkXCIgfSk7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy93YWxsZXRzL2Nhc2h1L3dhbGxldC9zdGF0ZS91cGRhdGUudHNcbmltcG9ydCB7XG4gIE5ES0Nhc2h1VG9rZW4gYXMgTkRLQ2FzaHVUb2tlbjIsXG4gIE5ES0V2ZW50IGFzIE5ES0V2ZW50MixcbiAgTkRLS2luZCBhcyBOREtLaW5kM1xufSBmcm9tIFwiQG5vc3RyLWRldi1raXQvbmRrXCI7XG5hc3luYyBmdW5jdGlvbiB1cGRhdGUoc3RhdGVDaGFuZ2UsIF9tZW1vKSB7XG4gIHVwZGF0ZUludGVybmFsU3RhdGUodGhpcywgc3RhdGVDaGFuZ2UpO1xuICB0aGlzLndhbGxldC5lbWl0KFwiYmFsYW5jZV91cGRhdGVkXCIpO1xuICByZXR1cm4gdXBkYXRlRXh0ZXJuYWxTdGF0ZSh0aGlzLCBzdGF0ZUNoYW5nZSk7XG59XG5mdW5jdGlvbiB1cGRhdGVJbnRlcm5hbFN0YXRlKHdhbGxldFN0YXRlLCBzdGF0ZUNoYW5nZSkge1xuICBpZiAoc3RhdGVDaGFuZ2Uuc3RvcmUgJiYgc3RhdGVDaGFuZ2Uuc3RvcmUubGVuZ3RoID4gMCkge1xuICAgIGZvciAoY29uc3QgcHJvb2Ygb2Ygc3RhdGVDaGFuZ2Uuc3RvcmUpIHtcbiAgICAgIHdhbGxldFN0YXRlLmFkZFByb29mKHtcbiAgICAgICAgbWludDogc3RhdGVDaGFuZ2UubWludCxcbiAgICAgICAgc3RhdGU6IFwiYXZhaWxhYmxlXCIsXG4gICAgICAgIHByb29mLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGVDaGFuZ2UuZGVzdHJveSAmJiBzdGF0ZUNoYW5nZS5kZXN0cm95Lmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKGNvbnN0IHByb29mIG9mIHN0YXRlQ2hhbmdlLmRlc3Ryb3kpIHtcbiAgICAgIHdhbGxldFN0YXRlLnVwZGF0ZVByb29mKHByb29mLCB7IHN0YXRlOiBcImRlbGV0ZWRcIiB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRlQ2hhbmdlLnJlc2VydmUgJiYgc3RhdGVDaGFuZ2UucmVzZXJ2ZS5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiBQcm9vZnMgc2hvdWxkIG5vdCBiZSByZXNlcnZlZCB2aWEgdXBkYXRlXCIpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiB1cGRhdGVFeHRlcm5hbFN0YXRlKHdhbGxldFN0YXRlLCBzdGF0ZUNoYW5nZSkge1xuICBjb25zdCBuZXdTdGF0ZSA9IGNhbGN1bGF0ZU5ld1N0YXRlKHdhbGxldFN0YXRlLCBzdGF0ZUNoYW5nZSk7XG4gIGlmIChuZXdTdGF0ZS5kZWxldGVkVG9rZW5JZHMuc2l6ZSA+IDApIHtcbiAgICBjb25zdCBkZWxldGVFdmVudCA9IG5ldyBOREtFdmVudDIod2FsbGV0U3RhdGUud2FsbGV0Lm5kaywge1xuICAgICAga2luZDogTkRLS2luZDMuRXZlbnREZWxldGlvbixcbiAgICAgIHRhZ3M6IFtcbiAgICAgICAgW1wia1wiLCBOREtLaW5kMy5DYXNodVRva2VuLnRvU3RyaW5nKCldLFxuICAgICAgICAuLi5BcnJheS5mcm9tKG5ld1N0YXRlLmRlbGV0ZWRUb2tlbklkcykubWFwKChpZCkgPT4gW1wiZVwiLCBpZF0pXG4gICAgICBdXG4gICAgfSk7XG4gICAgYXdhaXQgZGVsZXRlRXZlbnQuc2lnbigpO1xuICAgIHB1Ymxpc2hXaXRoUmV0cnkod2FsbGV0U3RhdGUsIGRlbGV0ZUV2ZW50LCB3YWxsZXRTdGF0ZS53YWxsZXQucmVsYXlTZXQpO1xuICAgIGZvciAoY29uc3QgdG9rZW5JZCBvZiBuZXdTdGF0ZS5kZWxldGVkVG9rZW5JZHMpIHtcbiAgICAgIHdhbGxldFN0YXRlLnJlbW92ZVRva2VuSWQodG9rZW5JZCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBpZiAobmV3U3RhdGUuc2F2ZVByb29mcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbmV3VG9rZW4gPSBhd2FpdCBjcmVhdGVUb2tlbkV2ZW50KHdhbGxldFN0YXRlLCBzdGF0ZUNoYW5nZS5taW50LCBuZXdTdGF0ZSk7XG4gICAgcmVzLmNyZWF0ZWQgPSBuZXdUb2tlbjtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuYXN5bmMgZnVuY3Rpb24gcHVibGlzaFdpdGhSZXRyeSh3YWxsZXRTdGF0ZSwgZXZlbnQsIHJlbGF5U2V0LCByZXRyeVRpbWVvdXQgPSAxMCAqIDFlMykge1xuICBsZXQgcHVibGlzaFJlc3VsdDtcbiAgcHVibGlzaFJlc3VsdCA9IGF3YWl0IGV2ZW50LnB1Ymxpc2gocmVsYXlTZXQpO1xuICBsZXQgdHlwZTtcbiAgaWYgKGV2ZW50LmtpbmQgPT09IE5ES0tpbmQzLkV2ZW50RGVsZXRpb24pIHR5cGUgPSBcImRlbGV0aW9uXCI7XG4gIGlmIChldmVudC5raW5kID09PSBOREtLaW5kMy5DYXNodVRva2VuKSB0eXBlID0gXCJ0b2tlblwiO1xuICBpZiAoZXZlbnQua2luZCA9PT0gTkRLS2luZDMuQ2FzaHVXYWxsZXQpIHR5cGUgPSBcIndhbGxldFwiO1xuICBjb25zdCBqb3VybmFsRW50cnlNZXRhZGF0YSA9IHtcbiAgICB0eXBlLFxuICAgIGlkOiBldmVudC5pZCxcbiAgICByZWxheVVybDogcmVsYXlTZXQ/LnJlbGF5VXJscy5qb2luKFwiLFwiKVxuICB9O1xuICBpZiAocHVibGlzaFJlc3VsdCkge1xuICAgIHdhbGxldFN0YXRlLmpvdXJuYWwucHVzaCh7XG4gICAgICBtZW1vOiBgUHVibGlzaCBraW5kOiR7ZXZlbnQua2luZH0gc3VjY2Vlc2Z1bGx5YCxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIG1ldGFkYXRhOiBqb3VybmFsRW50cnlNZXRhZGF0YVxuICAgIH0pO1xuICAgIHJldHVybiBwdWJsaXNoUmVzdWx0O1xuICB9XG4gIHdhbGxldFN0YXRlLmpvdXJuYWwucHVzaCh7XG4gICAgbWVtbzogXCJQdWJsaXNoIGZhaWxlZFwiLFxuICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICBtZXRhZGF0YTogam91cm5hbEVudHJ5TWV0YWRhdGFcbiAgfSk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHB1Ymxpc2hXaXRoUmV0cnkod2FsbGV0U3RhdGUsIGV2ZW50LCByZWxheVNldCwgcmV0cnlUaW1lb3V0KTtcbiAgfSwgcmV0cnlUaW1lb3V0KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRva2VuRXZlbnQod2FsbGV0U3RhdGUsIG1pbnQsIG5ld1N0YXRlKSB7XG4gIGNvbnN0IG5ld1Rva2VuID0gbmV3IE5ES0Nhc2h1VG9rZW4yKHdhbGxldFN0YXRlLndhbGxldC5uZGspO1xuICBuZXdUb2tlbi5taW50ID0gbWludDtcbiAgbmV3VG9rZW4ucHJvb2ZzID0gbmV3U3RhdGUuc2F2ZVByb29mcztcbiAgYXdhaXQgbmV3VG9rZW4udG9Ob3N0ckV2ZW50KCk7XG4gIHdhbGxldFN0YXRlLmFkZFRva2VuKG5ld1Rva2VuKTtcbiAgbmV3VG9rZW4uZGVsZXRlZFRva2VucyA9IEFycmF5LmZyb20obmV3U3RhdGUuZGVsZXRlZFRva2VuSWRzKTtcbiAgYXdhaXQgbmV3VG9rZW4uc2lnbigpO1xuICB3YWxsZXRTdGF0ZS5hZGRUb2tlbihuZXdUb2tlbik7XG4gIHB1Ymxpc2hXaXRoUmV0cnkod2FsbGV0U3RhdGUsIG5ld1Rva2VuLCB3YWxsZXRTdGF0ZS53YWxsZXQucmVsYXlTZXQpO1xuICByZXR1cm4gbmV3VG9rZW47XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVOZXdTdGF0ZSh3YWxsZXRTdGF0ZSwgc3RhdGVDaGFuZ2UpIHtcbiAgY29uc3QgZGVzdHJveVByb29mcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgcHJvb2Ygb2Ygc3RhdGVDaGFuZ2UuZGVzdHJveSB8fCBbXSkgZGVzdHJveVByb29mcy5hZGQocHJvb2YuQyk7XG4gIGNvbnN0IHByb29mc1RvU3RvcmUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgdG9rZW5zVG9EZWxldGU7XG4gIGZvciAoY29uc3QgcHJvb2Ygb2Ygc3RhdGVDaGFuZ2Uuc3RvcmUgfHwgW10pIHByb29mc1RvU3RvcmUuc2V0KHByb29mLkMsIHByb29mKTtcbiAgdG9rZW5zVG9EZWxldGUgPSBnZXRBZmZlY3RlZFRva2Vucyh3YWxsZXRTdGF0ZSwgc3RhdGVDaGFuZ2UpO1xuICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vuc1RvRGVsZXRlLnZhbHVlcygpKSB7XG4gICAgZm9yIChjb25zdCBwcm9vZiBvZiB0b2tlbi5wcm9vZnMpIHtcbiAgICAgIGlmIChkZXN0cm95UHJvb2ZzLmhhcyhwcm9vZi5DKSkgY29udGludWU7XG4gICAgICBwcm9vZnNUb1N0b3JlLnNldChwcm9vZi5DLCBwcm9vZik7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZGVsZXRlZFRva2VuSWRzOiBuZXcgU2V0KHRva2Vuc1RvRGVsZXRlLmtleXMoKSksXG4gICAgZGVsZXRlZFByb29mczogZGVzdHJveVByb29mcyxcbiAgICByZXNlcnZlUHJvb2ZzOiBbXSxcbiAgICBzYXZlUHJvb2ZzOiBBcnJheS5mcm9tKHByb29mc1RvU3RvcmUudmFsdWVzKCkpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRBZmZlY3RlZFRva2Vucyh3YWxsZXRTdGF0ZSwgc3RhdGVDaGFuZ2UpIHtcbiAgY29uc3QgdG9rZW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBwcm9vZiBvZiBzdGF0ZUNoYW5nZS5kZXN0cm95IHx8IFtdKSB7XG4gICAgY29uc3QgcHJvb2ZFbnRyeSA9IHdhbGxldFN0YXRlLnByb29mcy5nZXQocHJvb2YuQyk7XG4gICAgaWYgKCFwcm9vZkVudHJ5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW5JZCA9IHByb29mRW50cnkudG9rZW5JZDtcbiAgICBpZiAoIXRva2VuSWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0b2tlbkVudHJ5ID0gd2FsbGV0U3RhdGUudG9rZW5zLmdldCh0b2tlbklkKTtcbiAgICBpZiAoIXRva2VuRW50cnk/LnRva2VuKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdG9rZW5zLnNldCh0b2tlbklkLCB0b2tlbkVudHJ5LnRva2VuKTtcbiAgfVxuICByZXR1cm4gdG9rZW5zO1xufVxuXG4vLyBzcmMvd2FsbGV0cy9jYXNodS93YWxsZXQvc3RhdGUvaW5kZXgudHNcbnZhciBXYWxsZXRTdGF0ZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iod2FsbGV0LCByZXNlcnZlZFByb29mQ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSB7XG4gICAgdGhpcy53YWxsZXQgPSB3YWxsZXQ7XG4gICAgdGhpcy5yZXNlcnZlZFByb29mQ3MgPSByZXNlcnZlZFByb29mQ3M7XG4gIH1cbiAgLyoqXG4gICAqIHRoZSBhbW91bnRzIHRoYXQgYXJlIGludGVuZGVkIHRvIGJlIHJlc2VydmVkXG4gICAqIHRoaXMgaXMgdGhlIG5ldCBhbW91bnQgd2UgYXJlIHRyeWluZyB0byBwYXkgb3V0LFxuICAgKiBleGNsdWRpbmcgZmVlcyBhbmQgY29pbiBzaXplc1xuICAgKiBlLmcuIHdlIG1pZ2h0IHdhbnQgdG8gcGF5IDUgc2F0cywgaGF2ZSAyIHNhdHMgaW4gZmVlc1xuICAgKiBhbmQgd2UncmUgdXNpbmcgMiBpbnB1dHMgdGhhdCBhZGQgdXAgdG8gOCwgdGhlIHJlc2VydmUgYW1vdW50IGlzIDVcbiAgICogd2hpbGUgdGhlIHJlc2VydmUgcHJvb2ZzIGFkZCB1cCB0byA4XG4gICAqL1xuICByZXNlcnZlQW1vdW50cyA9IFtdO1xuICAvKipcbiAgICogU291cmNlIG9mIHRydXRoIG9mIHRoZSBwcm9vZnMgdGhpcyB3YWxsZXQgaGFzL2hhZC5cbiAgICovXG4gIHByb29mcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8qKlxuICAgKiBUaGUgdG9rZW5zIHRoYXQgYXJlIGtub3duIHRvIHRoaXMgd2FsbGV0LlxuICAgKi9cbiAgdG9rZW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgam91cm5hbCA9IFtdO1xuICAvKiogVGhpcyBpcyBhIGRlYnVnZ2luZyBmdW5jdGlvbiB0aGF0IGR1bXBzIHRoZSBzdGF0ZSBvZiB0aGUgd2FsbGV0ICovXG4gIGR1bXAoKSB7XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgcHJvb2ZzOiBBcnJheS5mcm9tKHRoaXMucHJvb2ZzLnZhbHVlcygpKSxcbiAgICAgIGJhbGFuY2VzOiB0aGlzLmdldE1pbnRzQmFsYW5jZSgpLFxuICAgICAgdG90YWxCYWxhbmNlOiB0aGlzLmdldEJhbGFuY2UoKSxcbiAgICAgIHRva2VuczogQXJyYXkuZnJvbSh0aGlzLnRva2Vucy52YWx1ZXMoKSlcbiAgICB9O1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBUb2tlbnNcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgYWRkVG9rZW4gPSBhZGRUb2tlbi5iaW5kKHRoaXMpO1xuICByZW1vdmVUb2tlbklkID0gcmVtb3ZlVG9rZW5JZC5iaW5kKHRoaXMpO1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIFByb29mIG1hbmFnZW1lbnRcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgYWRkUHJvb2YgPSBhZGRQcm9vZi5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogUmVzZXJ2ZXMgYSBudW1iZXIgb2Ygc2VsZWN0ZWQgcHJvb2ZzIGFuZCBhIHNwZWNpZmljIGFtb3VudC5cbiAgICpcbiAgICogVGhlIGFtb3VudCBhbmQgdG90YWwgb2YgdGhlIHByb29mcyBkb24ndCBuZWVkIHRvIG1hdGNoLiBXZVxuICAgKiBtaWdodCB3YW50IHRvIHVzZSA1IHNhdHMgYW5kIGhhdmUgMiBwcm9vZnMgb2YgNCBzYXRzIGVhY2guXG4gICAqIEluIHRoYXQgY2FzZSwgdGhlIHJlc2VydmUgYW1vdW50IGlzIDUsIHdoaWxlIHRoZSByZXNlcnZlIHByb29mc1xuICAgKiBhZGQgdXAgdG8gOC5cbiAgICovXG4gIHJlc2VydmVQcm9vZnMgPSByZXNlcnZlUHJvb2ZzLmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBVbnJlc2VydmVzIGEgbnVtYmVyIG9mIHNlbGVjdGVkIHByb29mcyBhbmQgYSBzcGVjaWZpYyBhbW91bnQuXG4gICAqL1xuICB1bnJlc2VydmVQcm9vZnMgPSB1bnJlc2VydmVQcm9vZnMuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIHByb29mIGVudHJpZXMsIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgbWludCBhbmQgc3RhdGVcbiAgICovXG4gIGdldFByb29mRW50cmllcyA9IGdldFByb29mRW50cmllcy5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogVXBkYXRlcyBpbmZvcm1hdGlvbiBhYm91dCBhIHByb29mXG4gICAqL1xuICB1cGRhdGVQcm9vZiA9IHVwZGF0ZVByb29mLmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBwcm9vZnMsIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgbWludCBhbmQgc3RhdGVcbiAgICogQHBhcmFtIG9wdHMubWludCAtIG9wdGlvbmFsIG1pbnQgdG8gZmlsdGVyIGJ5XG4gICAqIEBwYXJhbSBvcHRzLm9ubHlBdmFpbGFibGUgLSBvbmx5IGluY2x1ZGUgYXZhaWxhYmxlIHByb29mcyBAZGVmYXVsdCB0cnVlXG4gICAqIEBwYXJhbSBvcHRzLmluY2x1ZGVEZWxldGVkIC0gaW5jbHVkZSBkZWxldGVkIHByb29mcyBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZ2V0UHJvb2ZzKG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQcm9vZkVudHJpZXMob3B0cykubWFwKChlbnRyeSkgPT4gZW50cnkucHJvb2YpO1xuICB9XG4gIGdldFRva2VucyhvcHRzID0geyBvbmx5QXZhaWxhYmxlOiB0cnVlIH0pIHtcbiAgICBjb25zdCBwcm9vZkVudHJpZXMgPSB0aGlzLmdldFByb29mRW50cmllcyhvcHRzKTtcbiAgICBjb25zdCB0b2tlbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgcHJvb2ZFbnRyeSBvZiBwcm9vZkVudHJpZXMpIHtcbiAgICAgIGNvbnN0IHRva2VuSWQgPSBwcm9vZkVudHJ5LnRva2VuSWQgPz8gbnVsbDtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSB0b2tlbnMuZ2V0KHRva2VuSWQpID8/IHtcbiAgICAgICAgdG9rZW5JZCxcbiAgICAgICAgbWludDogcHJvb2ZFbnRyeS5taW50LFxuICAgICAgICBwcm9vZkVudHJpZXM6IFtdXG4gICAgICB9O1xuICAgICAgY3VycmVudC50b2tlbiA/Pz0gdG9rZW5JZCA/IHRoaXMudG9rZW5zLmdldCh0b2tlbklkKT8udG9rZW4gOiB2b2lkIDA7XG4gICAgICBjdXJyZW50LnByb29mRW50cmllcy5wdXNoKHByb29mRW50cnkpO1xuICAgICAgdG9rZW5zLnNldCh0b2tlbklkLCBjdXJyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VucztcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIGxpc3Qgb2YgcHJvb2ZzIGZvciBlYWNoIG1pbnRcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldE1pbnRzUHJvb2ZzKHtcbiAgICB2YWxpZFN0YXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImF2YWlsYWJsZVwiXSlcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgbWludHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5wcm9vZnMudmFsdWVzKCkpIHtcbiAgICAgIGlmICghZW50cnkubWludCB8fCAhZW50cnkucHJvb2YpIGNvbnRpbnVlO1xuICAgICAgaWYgKCF2YWxpZFN0YXRlcy5oYXMoZW50cnkuc3RhdGUpKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBtaW50cy5nZXQoZW50cnkubWludCkgfHwgW107XG4gICAgICBjdXJyZW50LnB1c2goZW50cnkucHJvb2YpO1xuICAgICAgbWludHMuc2V0KGVudHJ5Lm1pbnQsIGN1cnJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gbWludHM7XG4gIH1cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgKiBCYWxhbmNlXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiYWxhbmNlIG9mIHRoZSB3YWxsZXQsIG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgbWludCBhbmQgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtcyBvcHRzLm1pbnQgLSBvcHRpb25hbCBtaW50IHRvIGZpbHRlciBieVxuICAgKiBAcGFyYW1zIG9wdHMub25seUF2YWlsYWJsZSAtIG9ubHkgaW5jbHVkZSBhdmFpbGFibGUgcHJvb2ZzIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGdldEJhbGFuY2UgPSBnZXRCYWxhbmNlLmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBiYWxhbmNlcyBvZiB0aGUgZGlmZmVyZW50IG1pbnRzXG4gICAqXG4gICAqIEBwYXJhbXMgb3B0cy5vbmx5QXZhaWxhYmxlIC0gb25seSBpbmNsdWRlIGF2YWlsYWJsZSBwcm9vZnMgQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZ2V0TWludHNCYWxhbmNlID0gZ2V0TWludHNCYWxhbmNlcy5iaW5kKHRoaXMpO1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIFN0YXRlIHVwZGF0ZVxuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICB1cGRhdGUgPSB1cGRhdGUuYmluZCh0aGlzKTtcbn07XG5cbi8vIHNyYy93YWxsZXRzL2Nhc2h1L3dhbGxldC9pbmRleC50c1xudmFyIF9zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuZnVuY3Rpb24gbG9nKF9tc2cpIHtcbn1cbnZhciBOREtDYXNodVdhbGxldCA9IGNsYXNzIF9OREtDYXNodVdhbGxldCBleHRlbmRzIE5ES1dhbGxldCB7XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcIm5pcC02MFwiO1xuICB9XG4gIF9wMnBrO1xuICBzdWI7XG4gIHN0YXR1cyA9IFwiaW5pdGlhbFwiIC8qIElOSVRJQUwgKi87XG4gIHN0YXRpYyBraW5kID0gTkRLS2luZDQuQ2FzaHVXYWxsZXQ7XG4gIHN0YXRpYyBraW5kcyA9IFtOREtLaW5kNC5DYXNodVdhbGxldF07XG4gIG1pbnRzID0gW107XG4gIHByaXZrZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgc2lnbmVyO1xuICB3YWxsZXRJZCA9IFwibmlwLTYwXCI7XG4gIGRlcG9zaXRNb25pdG9yID0gbmV3IE5ES0Nhc2h1RGVwb3NpdE1vbml0b3IoKTtcbiAgLyoqXG4gICAqIFdhcm5pbmdzIHRoYXQgaGF2ZSBiZWVuIHJhaXNlZFxuICAgKi9cbiAgd2FybmluZ3MgPSBbXTtcbiAgcGF5bWVudEhhbmRsZXI7XG4gIHN0YXRlO1xuICByZWxheVNldDtcbiAgY29uc3RydWN0b3IobmRrKSB7XG4gICAgc3VwZXIobmRrKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLnBheW1lbnRIYW5kbGVyID0gbmV3IFBheW1lbnRIYW5kbGVyKHRoaXMpO1xuICAgIHRoaXMuc3RhdGUgPSBuZXcgV2FsbGV0U3RhdGUodGhpcyk7XG4gICAgbG9nKFwiTkRLIENhc2h1IFdhbGxldCBjb25zdHJ1Y3RvclwiKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgYmFja3VwIGV2ZW50IGZvciB0aGlzIHdhbGxldFxuICAgKi9cbiAgYXN5bmMgYmFja3VwKHB1Ymxpc2ggPSB0cnVlKSB7XG4gICAgbG9nKFwiTkRLIENhc2h1IFdhbGxldCBnZW5lcmF0aW5nIGJhY2t1cFwiKTtcbiAgICBpZiAodGhpcy5wcml2a2V5cy5zaXplID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBwcml2a2V5IHRvIGJhY2t1cFwiKTtcbiAgICBjb25zdCBiYWNrdXAgPSBuZXcgTkRLQ2FzaHVXYWxsZXRCYWNrdXAodGhpcy5uZGspO1xuICAgIGNvbnN0IHByaXZrZXlzID0gW107XG4gICAgZm9yIChjb25zdCBbX3B1YmtleSwgc2lnbmVyXSBvZiB0aGlzLnByaXZrZXlzLmVudHJpZXMoKSkge1xuICAgICAgcHJpdmtleXMucHVzaChzaWduZXIucHJpdmF0ZUtleSk7XG4gICAgfVxuICAgIGJhY2t1cC5wcml2a2V5cyA9IHByaXZrZXlzO1xuICAgIGJhY2t1cC5taW50cyA9IHRoaXMubWludHM7XG4gICAgaWYgKHB1Ymxpc2gpIGJhY2t1cC5zYXZlKHRoaXMucmVsYXlTZXQpO1xuICAgIHJldHVybiBiYWNrdXA7XG4gIH1cbiAgY29uc29saWRhdGVUb2tlbnMgPSBjb25zb2xpZGF0ZVRva2Vucy5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogR2VuZXJhdGVzIG51dHMgdGhhdCBjYW4gYmUgdXNlZCB0byBzZW5kIHRvIHNvbWVvbmUuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHNlbmQgYW55dGhpbmcsIGl0IGp1c3QgZ2VuZXJhdGVzIGEgc3BlY2lmaWMgYW1vdW50IG9mIHByb29mcy5cbiAgICogQHBhcmFtIGFtb3VudHNcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIG1pbnROdXRzKGFtb3VudHMpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGNvbnN0IHRvdGFsQW1vdW50ID0gYW1vdW50cy5yZWR1Y2UoKGFjYywgYW1vdW50KSA9PiBhY2MgKyBhbW91bnQsIDApO1xuICAgIGZvciAoY29uc3QgbWludCBvZiB0aGlzLm1pbnRzKSB7XG4gICAgICBjb25zdCB3YWxsZXQgPSBhd2FpdCB0aGlzLmdldENhc2h1V2FsbGV0KG1pbnQpO1xuICAgICAgY29uc3QgbWludFByb29mczIgPSBhd2FpdCB0aGlzLnN0YXRlLmdldFByb29mcyh7IG1pbnQgfSk7XG4gICAgICByZXN1bHQgPSBhd2FpdCB3YWxsZXQuc2VuZCh0b3RhbEFtb3VudCwgbWludFByb29mczIsIHtcbiAgICAgICAgcHJvb2ZzV2VIYXZlOiBtaW50UHJvb2ZzMixcbiAgICAgICAgaW5jbHVkZUZlZXM6IHRydWUsXG4gICAgICAgIG91dHB1dEFtb3VudHM6IHtcbiAgICAgICAgICBzZW5kQW1vdW50czogYW1vdW50c1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChyZXN1bHQuc2VuZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZSA9IHsgc3RvcmU6IHJlc3VsdD8ua2VlcCA/PyBbXSwgZGVzdHJveTogcmVzdWx0LnNlbmQsIG1pbnQgfTtcbiAgICAgICAgY29uc3QgdXBkYXRlUmVzID0gYXdhaXQgdGhpcy5zdGF0ZS51cGRhdGUoY2hhbmdlKTtcbiAgICAgICAgY3JlYXRlT3V0VHhFdmVudChcbiAgICAgICAgICB0aGlzLm5kayxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwYXltZW50RGVzY3JpcHRpb246IFwibWludGVkIG51dHNcIixcbiAgICAgICAgICAgIGFtb3VudDogYW1vdW50cy5yZWR1Y2UoKGFjYywgYW1vdW50KSA9PiBhY2MgKyBhbW91bnQsIDApXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXN1bHQ6IHsgcHJvb2ZzOiByZXN1bHQuc2VuZCwgbWludCB9LFxuICAgICAgICAgICAgcHJvb2ZzQ2hhbmdlOiBjaGFuZ2UsXG4gICAgICAgICAgICBzdGF0ZVVwZGF0ZTogdXBkYXRlUmVzLFxuICAgICAgICAgICAgbWludCxcbiAgICAgICAgICAgIGZlZTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhpcy5yZWxheVNldFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmVtaXQoXCJiYWxhbmNlX3VwZGF0ZWRcIik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBMb2FkcyBhIHdhbGxldCBpbmZvcm1hdGlvbiBmcm9tIGFuIGV2ZW50XG4gICAqIEBwYXJhbSBldmVudFxuICAgKi9cbiAgYXN5bmMgbG9hZEZyb21FdmVudChldmVudCkge1xuICAgIGNvbnN0IF9ldmVudCA9IG5ldyBOREtFdmVudDMoZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgICBhd2FpdCBfZXZlbnQuZGVjcnlwdCgpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBKU09OLnBhcnNlKF9ldmVudC5jb250ZW50KTtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiBjb250ZW50KSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcIm1pbnRcIikge1xuICAgICAgICB0aGlzLm1pbnRzLnB1c2godGFnWzFdKTtcbiAgICAgIH0gZWxzZSBpZiAodGFnWzBdID09PSBcInByaXZrZXlcIikge1xuICAgICAgICBhd2FpdCB0aGlzLmFkZFByaXZrZXkodGFnWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgdGhpcy5nZXRQMnBrKCk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb20oZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50Lm5kaykgdGhyb3cgbmV3IEVycm9yKFwibm8gbmRrIGluc3RhbmNlIG9uIGV2ZW50XCIpO1xuICAgIGNvbnN0IHdhbGxldCA9IG5ldyBfTkRLQ2FzaHVXYWxsZXQoZXZlbnQubmRrKTtcbiAgICBhd2FpdCB3YWxsZXQubG9hZEZyb21FdmVudChldmVudCk7XG4gICAgcmV0dXJuIHdhbGxldDtcbiAgfVxuICAvKipcbiAgICogU3RhcnRzIG1vbml0b3JpbmcgdGhlIHdhbGxldC5cbiAgICpcbiAgICogVXNlIGBzaW5jZWAgdG8gc3RhcnQgc3luY2luZyBzdGF0ZSBmcm9tIGEgc3BlY2lmaWMgdGltZXN0YW1wLiBUaGlzIHNob3VsZCBiZVxuICAgKiB1c2VkIGJ5IHN0b3JpbmcgYXQgdGhlIGFwcCBsZXZlbCBhIHRpbWUgaW4gd2hpY2ggd2Uga25vdyB3ZSB3ZXJlIGFibGUgdG8gY29tbXVuaWNhdGVcbiAgICogd2l0aCB0aGUgcmVsYXlzLCBmb3IgZXhhbXBsZSwgYnkgc2F2aW5nIHRoZSB0aW1lIHRoZSB3YWxsZXQgaGFzIGVtaXR0ZWQgYSBcInJlYWR5XCIgZXZlbnQuXG4gICAqL1xuICBzdGFydChvcHRzKSB7XG4gICAgbG9nKFwiTkRLIENhc2h1IFdhbGxldCBzdGFydGluZ1wiKTtcbiAgICBjb25zdCBhY3RpdmVVc2VyID0gdGhpcy5uZGs/LmFjdGl2ZVVzZXI7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBcInJlYWR5XCIgLyogUkVBRFkgKi8pIHJldHVybjtcbiAgICB0aGlzLnN0YXR1cyA9IFwibG9hZGluZ1wiIC8qIExPQURJTkcgKi87XG4gICAgY29uc3QgcHVia2V5ID0gb3B0cz8ucHVia2V5ID8/IGFjdGl2ZVVzZXI/LnB1YmtleTtcbiAgICBpZiAoIXB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwibm8gcHVia2V5XCIpO1xuICAgIGNvbnN0IGZpbHRlcnMgPSBbXG4gICAgICB7IGtpbmRzOiBbTkRLS2luZDQuQ2FzaHVUb2tlbl0sIGF1dGhvcnM6IFtwdWJrZXldIH0sXG4gICAgICB7IGtpbmRzOiBbTkRLS2luZDQuQ2FzaHVRdW90ZV0sIGF1dGhvcnM6IFtwdWJrZXldIH0sXG4gICAgICB7XG4gICAgICAgIGtpbmRzOiBbTkRLS2luZDQuRXZlbnREZWxldGlvbl0sXG4gICAgICAgIGF1dGhvcnM6IFtwdWJrZXldLFxuICAgICAgICBcIiNrXCI6IFtOREtLaW5kNC5DYXNodVRva2VuLnRvU3RyaW5nKCldXG4gICAgICB9XG4gICAgXTtcbiAgICBpZiAob3B0cz8uc2luY2UpIHtcbiAgICAgIGZpbHRlcnNbMF0uc2luY2UgPSBvcHRzLnNpbmNlO1xuICAgICAgZmlsdGVyc1sxXS5zaW5jZSA9IG9wdHMuc2luY2U7XG4gICAgICBmaWx0ZXJzWzJdLnNpbmNlID0gb3B0cy5zaW5jZTtcbiAgICB9XG4gICAgY29uc3Qgc3ViT3B0cyA9IG9wdHMgPz8ge307XG4gICAgc3ViT3B0cy5zdWJJZCA/Pz0gXCJjYXNodS13YWxsZXQtc3RhdGVcIjtcbiAgICBsb2coYFN1YnNjcmliaW5nIHRvICR7SlNPTi5zdHJpbmdpZnkoZmlsdGVycyl9IGFuZCBvcHRzICR7SlNPTi5zdHJpbmdpZnkob3B0cyl9YCk7XG4gICAgdGhpcy5zdWIgPSB0aGlzLm5kay5zdWJzY3JpYmUoZmlsdGVycywgeyAuLi5zdWJPcHRzLCByZWxheVNldDogdGhpcy5yZWxheVNldCB9LCBmYWxzZSk7XG4gICAgdGhpcy5zdWIub24oXCJldmVudDpkdXBcIiwgZXZlbnREdXBIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc3ViLm9uKFwiZXZlbnRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBsb2coYEV2ZW50ICR7ZXZlbnQua2luZH0gcmVjZWl2ZWRgKTtcbiAgICAgIGV2ZW50SGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9KTtcbiAgICB0aGlzLnN1Yi5vbihcImVvc2VcIiwgKCkgPT4ge1xuICAgICAgbG9nKFwiRW9zZSByZWNlaXZlZFwiKTtcbiAgICAgIHRoaXMuZW1pdChcInJlYWR5XCIpO1xuICAgICAgdGhpcy5zdGF0dXMgPSBcInJlYWR5XCIgLyogUkVBRFkgKi87XG4gICAgfSk7XG4gICAgdGhpcy5zdWIuc3RhcnQodHJ1ZSk7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnN1Yj8uc3RvcCgpO1xuICAgIHRoaXMuc3RhdHVzID0gXCJpbml0aWFsXCIgLyogSU5JVElBTCAqLztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcDJwayBvZiB0aGlzIHdhbGxldCBvciBnZW5lcmF0ZXMgYSBuZXcgb25lIGlmIHdlIGRvbid0IGhhdmUgb25lXG4gICAqL1xuICBhc3luYyBnZXRQMnBrKCkge1xuICAgIGlmICh0aGlzLl9wMnBrKSByZXR1cm4gdGhpcy5fcDJwaztcbiAgICBpZiAodGhpcy5wcml2a2V5cy5zaXplID09PSAwKSB7XG4gICAgICBjb25zdCBzaWduZXIgPSBOREtQcml2YXRlS2V5U2lnbmVyLmdlbmVyYXRlKCk7XG4gICAgICBhd2FpdCB0aGlzLmFkZFByaXZrZXkoc2lnbmVyLnByaXZhdGVLZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wMnBrO1xuICB9XG4gIC8qKlxuICAgKiBJZiB0aGlzIHdhbGxldCBoYXMgYWNjZXNzIHRvIG1vcmUgdGhhbiBvbmUgcHJpdmtleSwgdGhpcyB3aWxsIHJldHVybiBhbGwgb2YgdGhlbS5cbiAgICovXG4gIGdldCBwMnBrcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnByaXZrZXlzLmtleXMoKSk7XG4gIH1cbiAgYXN5bmMgYWRkUHJpdmtleShwcml2a2V5KSB7XG4gICAgY29uc3Qgc2lnbmVyID0gbmV3IE5ES1ByaXZhdGVLZXlTaWduZXIocHJpdmtleSk7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHNpZ25lci51c2VyKCk7XG4gICAgdGhpcy5wcml2a2V5cy5zZXQodXNlci5wdWJrZXksIHNpZ25lcik7XG4gICAgdGhpcy5fcDJwayA/Pz0gdXNlci5wdWJrZXk7XG4gICAgcmV0dXJuIHRoaXMuX3AycGs7XG4gIH1cbiAgZ2V0IHAycGsoKSB7XG4gICAgaWYgKCF0aGlzLl9wMnBrKSB0aHJvdyBuZXcgRXJyb3IoXCJwMnBrIG5vdCBzZXRcIik7XG4gICAgcmV0dXJuIHRoaXMuX3AycGs7XG4gIH1cbiAgc2V0IHAycGsocHVia2V5KSB7XG4gICAgaWYgKHRoaXMucHJpdmtleXMuaGFzKHB1YmtleSkpIHtcbiAgICAgIHRoaXMuc2lnbmVyID0gdGhpcy5wcml2a2V5cy5nZXQocHVia2V5KTtcbiAgICAgIHRoaXMucDJwayA9IHB1YmtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcml2a2V5IGZvciAke3B1YmtleX0gbm90IGZvdW5kYCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIHBheWxvYWQgZm9yIGEgd2FsbGV0IGV2ZW50XG4gICAqL1xuICB3YWxsZXRQYXlsb2FkKCkge1xuICAgIGNvbnN0IHByaXZrZXlzID0gQXJyYXkuZnJvbSh0aGlzLnByaXZrZXlzLnZhbHVlcygpKS5tYXAoKHNpZ25lcikgPT4gc2lnbmVyLnByaXZhdGVLZXkpO1xuICAgIHJldHVybiBwYXlsb2FkRm9yRXZlbnQocHJpdmtleXMsIHRoaXMubWludHMpO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2goKSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQzKHRoaXMubmRrLCB7XG4gICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeSh0aGlzLndhbGxldFBheWxvYWQoKSksXG4gICAgICBraW5kOiBOREtLaW5kNC5DYXNodVdhbGxldFxuICAgIH0pO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5kaz8uc2lnbmVyPy51c2VyKCk7XG4gICAgYXdhaXQgZXZlbnQuZW5jcnlwdCh1c2VyLCB2b2lkIDAsIFwibmlwNDRcIik7XG4gICAgcmV0dXJuIGV2ZW50LnB1Ymxpc2godGhpcy5yZWxheVNldCk7XG4gIH1cbiAgLyoqXG4gICAqIFByZXBhcmVzIGEgZGVwb3NpdFxuICAgKiBAcGFyYW0gYW1vdW50XG4gICAqIEBwYXJhbSBtaW50XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHdhbGxldCA9IG5ldyBOREtDYXNodVdhbGxldCguLi4pO1xuICAgKiBjb25zdCBkZXBvc2l0ID0gd2FsbGV0LmRlcG9zaXQoMTAwMCwgXCJodHRwczovL21pbnQuZXhhbXBsZS5jb21cIiwgXCJzYXRzXCIpO1xuICAgKiBkZXBvc2l0Lm9uKFwic3VjY2Vzc1wiLCAodG9rZW4pID0+IHtcbiAgICogfSk7XG4gICAqIGRlcG9zaXQub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcbiAgICogfSk7XG4gICAqXG4gICAqIC8vIHN0YXJ0IG1vbml0b3JpbmcgdGhlIGRlcG9zaXRcbiAgICogZGVwb3NpdC5zdGFydCgpO1xuICAgKi9cbiAgZGVwb3NpdChhbW91bnQsIG1pbnQpIHtcbiAgICBjb25zdCBkZXBvc2l0ID0gbmV3IE5ES0Nhc2h1RGVwb3NpdCh0aGlzLCBhbW91bnQsIG1pbnQpO1xuICAgIGRlcG9zaXQub24oXCJzdWNjZXNzXCIsICh0b2tlbikgPT4ge1xuICAgICAgdGhpcy5zdGF0ZS5hZGRUb2tlbih0b2tlbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlcG9zaXQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlY2VpdmVzIGEgdG9rZW4gYW5kIGFkZHMgaXQgdG8gdGhlIHdhbGxldFxuICAgKiBAcGFyYW0gdG9rZW5cbiAgICogQHJldHVybnMgdGhlIHRva2VuIGV2ZW50IHRoYXQgd2FzIGNyZWF0ZWRcbiAgICovXG4gIGFzeW5jIHJlY2VpdmVUb2tlbih0b2tlbiwgZGVzY3JpcHRpb24pIHtcbiAgICBjb25zdCB7IG1pbnQgfSA9IGdldERlY29kZWRUb2tlbih0b2tlbik7XG4gICAgY29uc3Qgd2FsbGV0ID0gYXdhaXQgdGhpcy5nZXRDYXNodVdhbGxldChtaW50KTtcbiAgICBjb25zdCBwcm9vZnMgPSBhd2FpdCB3YWxsZXQucmVjZWl2ZSh0b2tlbik7XG4gICAgY29uc3QgdXBkYXRlUmVzID0gYXdhaXQgdGhpcy5zdGF0ZS51cGRhdGUoe1xuICAgICAgc3RvcmU6IHByb29mcyxcbiAgICAgIG1pbnRcbiAgICB9KTtcbiAgICBjb25zdCB0b2tlbkV2ZW50ID0gdXBkYXRlUmVzLmNyZWF0ZWQ7XG4gICAgY3JlYXRlSW5UeEV2ZW50KHRoaXMubmRrLCBwcm9vZnMsIG1pbnQsIHVwZGF0ZVJlcywgeyBkZXNjcmlwdGlvbiB9LCB0aGlzLnJlbGF5U2V0KTtcbiAgICByZXR1cm4gdG9rZW5FdmVudDtcbiAgfVxuICAvKipcbiAgICogUGF5IGEgTE4gaW52b2ljZSB3aXRoIHRoaXMgd2FsbGV0XG4gICAqL1xuICBhc3luYyBsblBheShwYXltZW50LCBjcmVhdGVUeEV2ZW50ID0gdHJ1ZSkge1xuICAgIHJldHVybiB0aGlzLnBheW1lbnRIYW5kbGVyLmxuUGF5KHBheW1lbnQsIGNyZWF0ZVR4RXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBTd2FwcyB0b2tlbnMgdG8gYSBzcGVjaWZpYyBhbW91bnQsIG9wdGlvbmFsbHkgbG9ja2luZyB0byBhIHAycGsuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gaGFzIHNpZGUgZWZmZWN0czpcbiAgICogLSBJdCBzd2FwcyB0b2tlbnMgYXQgdGhlIG1pbnRcbiAgICogLSBJdCB1cGRhdGVzIHRoZSB3YWxsZXQgc3RhdGUgKGRlbGV0ZXMgYWZmZWN0ZWQgdG9rZW5zLCBtaWdodCBjcmVhdGUgbmV3IG9uZXMpXG4gICAqIC0gSXQgY3JlYXRlcyBhIHdhbGxldCB0cmFuc2FjdGlvbiBldmVudFxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHByb29mcyB0aGF0IG5lZWQgdG8gYmUgc2VudCB0byB0aGUgcmVjaXBpZW50LlxuICAgKiBAcGFyYW0gYW1vdW50XG4gICAqL1xuICBhc3luYyBjYXNodVBheShwYXltZW50KSB7XG4gICAgcmV0dXJuIHRoaXMucGF5bWVudEhhbmRsZXIuY2FzaHVQYXkocGF5bWVudCk7XG4gIH1cbiAgd2FsbGV0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGFzeW5jIHJlZGVlbU51dHphcHMobnV0emFwcywgcHJpdmtleSwgeyBtaW50LCBwcm9vZnMsIGNhc2h1V2FsbGV0IH0pIHtcbiAgICBpZiAoY2FzaHVXYWxsZXQpIHtcbiAgICAgIG1pbnQgPz89IGNhc2h1V2FsbGV0Lm1pbnQubWludFVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFtaW50KSB0aHJvdyBuZXcgRXJyb3IoXCJtaW50IG5vdCBzZXRcIik7XG4gICAgICBjYXNodVdhbGxldCA9IGF3YWl0IHRoaXMuZ2V0Q2FzaHVXYWxsZXQobWludCk7XG4gICAgfVxuICAgIGlmICghbWludCkgdGhyb3cgbmV3IEVycm9yKFwibWludCBub3Qgc2V0XCIpO1xuICAgIGlmICghcHJvb2ZzKSB0aHJvdyBuZXcgRXJyb3IoXCJwcm9vZnMgbm90IHNldFwiKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvb2ZzV2VIYXZlID0gdGhpcy5zdGF0ZS5nZXRQcm9vZnMoeyBtaW50IH0pO1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgY2FzaHVXYWxsZXQucmVjZWl2ZSh7IHByb29mcywgbWludCB9LCB7IHByb29mc1dlSGF2ZSwgcHJpdmtleSB9KTtcbiAgICAgIGNvbnN0IHJlY2VpdmVkQW1vdW50ID0gcHJvb2ZzLnJlZHVjZSgoYWNjLCBwcm9vZikgPT4gYWNjICsgcHJvb2YuYW1vdW50LCAwKTtcbiAgICAgIGNvbnN0IHJlZGVlbWVkQW1vdW50ID0gcmVzLnJlZHVjZSgoYWNjLCBwcm9vZikgPT4gYWNjICsgcHJvb2YuYW1vdW50LCAwKTtcbiAgICAgIGNvbnN0IGZlZSA9IHJlY2VpdmVkQW1vdW50IC0gcmVkZWVtZWRBbW91bnQ7XG4gICAgICBjb25zdCB1cGRhdGVSZXMgPSBhd2FpdCB0aGlzLnN0YXRlLnVwZGF0ZSh7XG4gICAgICAgIHN0b3JlOiByZXMsXG4gICAgICAgIG1pbnRcbiAgICAgIH0pO1xuICAgICAgY3JlYXRlSW5UeEV2ZW50KHRoaXMubmRrLCByZXMsIG1pbnQsIHVwZGF0ZVJlcywgeyBudXR6YXBzLCBmZWUgfSwgdGhpcy5yZWxheVNldCk7XG4gICAgICByZXR1cm4gcmVjZWl2ZWRBbW91bnQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJlcnJvciByZWRlZW1pbmcgbnV0emFwc1wiLFxuICAgICAgICBudXR6YXBzLm1hcCgobikgPT4gbi5lbmNvZGUoKSksXG4gICAgICAgIGVcbiAgICAgICk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICB3YXJuKG1zZywgZXZlbnQsIHJlbGF5cykge1xuICAgIHJlbGF5cyA/Pz0gZXZlbnQ/Lm9uUmVsYXlzO1xuICAgIHRoaXMud2FybmluZ3MucHVzaCh7IG1zZywgZXZlbnQsIHJlbGF5cyB9KTtcbiAgICB0aGlzLmVtaXQoXCJ3YXJuaW5nXCIsIHsgbXNnLCBldmVudCwgcmVsYXlzIH0pO1xuICB9XG4gIGdldCBiYWxhbmNlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhbW91bnQ6IHRoaXMuc3RhdGUuZ2V0QmFsYW5jZSh7IG9ubHlBdmFpbGFibGU6IHRydWUgfSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0b3RhbCBiYWxhbmNlIGZvciBhIHNwZWNpZmljIG1pbnQsIGluY2x1ZGluZyByZXNlcnZlZCBwcm9vZnNcbiAgICovXG4gIG1pbnRCYWxhbmNlKG1pbnQpIHtcbiAgICByZXR1cm4gdGhpcy5taW50QmFsYW5jZXNbbWludF0gfHwgMDtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhbGwgdG9rZW5zLCBncm91cGVkIGJ5IG1pbnQgd2l0aCB0aGVpciB0b3RhbCBiYWxhbmNlc1xuICAgKi9cbiAgZ2V0IG1pbnRCYWxhbmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5nZXRNaW50c0JhbGFuY2UoeyBvbmx5QXZhaWxhYmxlOiB0cnVlIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBtaW50cyB0aGF0IGhhdmUgZW5vdWdoIGF2YWlsYWJsZSBiYWxhbmNlIChleGNsdWRpbmcgcmVzZXJ2ZWQgcHJvb2ZzKVxuICAgKiB0byBjb3ZlciB0aGUgc3BlY2lmaWVkIGFtb3VudFxuICAgKi9cbiAgZ2V0TWludHNXaXRoQmFsYW5jZShhbW91bnQpIHtcbiAgICBjb25zdCBhdmFpbGFibGVCYWxhbmNlcyA9IHRoaXMuc3RhdGUuZ2V0TWludHNCYWxhbmNlKHsgb25seUF2YWlsYWJsZTogdHJ1ZSB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoYXZhaWxhYmxlQmFsYW5jZXMpLmZpbHRlcigoW18sIGJhbGFuY2VdKSA9PiBiYWxhbmNlID49IGFtb3VudCkubWFwKChbbWludF0pID0+IG1pbnQpO1xuICB9XG59O1xudmFyIE5ES0Nhc2h1V2FsbGV0QmFja3VwID0gY2xhc3MgX05ES0Nhc2h1V2FsbGV0QmFja3VwIGV4dGVuZHMgTkRLRXZlbnQzIHtcbiAgcHJpdmtleXMgPSBbXTtcbiAgbWludHMgPSBbXTtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gTkRLS2luZDQuQ2FzaHVXYWxsZXRCYWNrdXA7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb20oZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50Lm5kaykgdGhyb3cgbmV3IEVycm9yKFwibm8gbmRrIGluc3RhbmNlIG9uIGV2ZW50XCIpO1xuICAgIGNvbnN0IGJhY2t1cCA9IG5ldyBfTkRLQ2FzaHVXYWxsZXRCYWNrdXAoZXZlbnQubmRrLCBldmVudCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGJhY2t1cC5kZWNyeXB0KCk7XG4gICAgICBjb25zdCBjb250ZW50ID0gSlNPTi5wYXJzZShiYWNrdXAuY29udGVudCk7XG4gICAgICBmb3IgKGNvbnN0IHRhZyBvZiBjb250ZW50KSB7XG4gICAgICAgIGlmICh0YWdbMF0gPT09IFwibWludFwiKSB7XG4gICAgICAgICAgYmFja3VwLm1pbnRzLnB1c2godGFnWzFdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YWdbMF0gPT09IFwicHJpdmtleVwiKSB7XG4gICAgICAgICAgYmFja3VwLnByaXZrZXlzLnB1c2godGFnWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJlcnJvciBkZWNyeXB0aW5nIGJhY2t1cCBldmVudFwiLCBiYWNrdXAuZW5jb2RlKCksIGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gYmFja3VwO1xuICB9XG4gIGFzeW5jIHNhdmUocmVsYXlTZXQpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBuZGsgaW5zdGFuY2VcIik7XG4gICAgaWYgKCF0aGlzLnByaXZrZXlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKFwibm8gcHJpdmtleXNcIik7XG4gICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZEZvckV2ZW50KHRoaXMucHJpdmtleXMsIHRoaXMubWludHMpKTtcbiAgICBhd2FpdCB0aGlzLmVuY3J5cHQodGhpcy5uZGsuYWN0aXZlVXNlciwgdm9pZCAwLCBcIm5pcDQ0XCIpO1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2gocmVsYXlTZXQpO1xuICB9XG59O1xuZnVuY3Rpb24gcGF5bG9hZEZvckV2ZW50KHByaXZrZXlzLCBtaW50cykge1xuICBpZiAocHJpdmtleXMubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJwcml2a2V5IG5vdCBzZXRcIik7XG4gIGNvbnN0IHBheWxvYWQgPSBbXG4gICAgLi4ubWludHMubWFwKChtaW50KSA9PiBbXCJtaW50XCIsIG1pbnRdKSxcbiAgICAuLi5wcml2a2V5cy5tYXAoKHByaXZrZXkpID0+IFtcInByaXZrZXlcIiwgcHJpdmtleV0pXG4gIF07XG4gIHJldHVybiBwYXlsb2FkO1xufVxuXG4vLyBzcmMvbnV0emFwLW1vbml0b3IvZmV0Y2gtcGFnZS50c1xuaW1wb3J0IHtcbiAgTkRLTnV0emFwLFxuICBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlXG59IGZyb20gXCJAbm9zdHItZGV2LWtpdC9uZGtcIjtcbmFzeW5jIGZ1bmN0aW9uIGZldGNoUGFnZShuZGssIGZpbHRlciwgX2tub3duTnV0emFwcywgcmVsYXlTZXQpIHtcbiAgY29uc3QgZXZlbnRzID0gYXdhaXQgbmRrLmZldGNoRXZlbnRzKFxuICAgIGZpbHRlcixcbiAgICB7XG4gICAgICBjYWNoZVVzYWdlOiBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlLk9OTFlfUkVMQVksXG4gICAgICBncm91cGFibGU6IGZhbHNlLFxuICAgICAgc3ViSWQ6IFwicmVjZW50LW51dHphcFwiXG4gICAgfSxcbiAgICByZWxheVNldFxuICApO1xuICByZXR1cm4gQXJyYXkuZnJvbShldmVudHMpLm1hcCgoZSkgPT4gTkRLTnV0emFwLmZyb20oZSkpLmZpbHRlcigobikgPT4gISFuKTtcbn1cblxuLy8gc3JjL251dHphcC1tb25pdG9yL2dyb3VwLW51dHphcHMudHNcbmltcG9ydCB7IGNhc2h1UHVia2V5VG9Ob3N0clB1YmtleSwgcHJvb2ZQMnBrIH0gZnJvbSBcIkBub3N0ci1kZXYta2l0L25ka1wiO1xuZnVuY3Rpb24gZ3JvdXBOdXR6YXBzKG51dHphcHMsIG1vbml0b3IpIHtcbiAgY29uc3QgcmVzdWx0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgZ2V0S2V5ID0gKG1pbnQsIHAycGsgPSBcIm5vLWtleVwiKSA9PiBgJHttaW50fToke3AycGt9YDtcbiAgZm9yIChjb25zdCBudXR6YXAgb2YgbnV0emFwcykge1xuICAgIGlmICghbW9uaXRvci5zaG91bGRUcnlSZWRlZW0obnV0emFwKSkgY29udGludWU7XG4gICAgY29uc3QgbWludCA9IG51dHphcC5taW50O1xuICAgIGZvciAoY29uc3QgcHJvb2Ygb2YgbnV0emFwLnByb29mcykge1xuICAgICAgY29uc3QgY2FzaHVQdWJrZXkgPSBwcm9vZlAycGsocHJvb2YpID8/IFwibm8ta2V5XCI7XG4gICAgICBjb25zdCBrZXkgPSBnZXRLZXkobWludCwgY2FzaHVQdWJrZXkpO1xuICAgICAgY29uc3QgZ3JvdXAgPSByZXN1bHQuZ2V0KGtleSkgPz8ge1xuICAgICAgICBtaW50LFxuICAgICAgICBjYXNodVB1YmtleSxcbiAgICAgICAgbm9zdHJQdWJrZXk6IGNhc2h1UHVia2V5VG9Ob3N0clB1YmtleShjYXNodVB1YmtleSksXG4gICAgICAgIG51dHphcHM6IFtdXG4gICAgICB9O1xuICAgICAgZ3JvdXAubnV0emFwcy5wdXNoKG51dHphcCk7XG4gICAgICByZXN1bHQuc2V0KGtleSwgZ3JvdXApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShyZXN1bHQudmFsdWVzKCkpO1xufVxuXG4vLyBzcmMvbnV0emFwLW1vbml0b3Ivc3BlbmQtc3RhdHVzLnRzXG5pbXBvcnQgeyBDaGVja1N0YXRlRW51bSBhcyBDaGVja1N0YXRlRW51bTIgfSBmcm9tIFwiQGNhc2h1L2Nhc2h1LXRzXCI7XG5hc3luYyBmdW5jdGlvbiBnZXRQcm9vZlNwZW5kU3RhdGUod2FsbGV0LCBudXR6YXBzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB1bnNwZW50UHJvb2ZzOiBbXSxcbiAgICBzcGVudFByb29mczogW10sXG4gICAgbnV0emFwc1dpdGhVbnNwZW50UHJvb2ZzOiBbXSxcbiAgICBudXR6YXBzV2l0aFNwZW50UHJvb2ZzOiBbXVxuICB9O1xuICBjb25zdCBwcm9vZkNzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgcHJvb2ZzID0gW107XG4gIGNvbnN0IG51dHphcE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgbnV0emFwIG9mIG51dHphcHMpIHtcbiAgICBmb3IgKGNvbnN0IHByb29mIG9mIG51dHphcC5wcm9vZnMpIHtcbiAgICAgIGlmIChwcm9vZkNzLmhhcyhwcm9vZi5DKSkgY29udGludWU7XG4gICAgICBwcm9vZkNzLmFkZChwcm9vZi5DKTtcbiAgICAgIHByb29mcy5wdXNoKHByb29mKTtcbiAgICAgIG51dHphcE1hcC5zZXQocHJvb2YuQywgbnV0emFwKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3RhdGVzID0gYXdhaXQgd2FsbGV0LmNoZWNrUHJvb2ZzU3RhdGVzKHByb29mcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBzdGF0ZXNbaV07XG4gICAgY29uc3QgcHJvb2YgPSBwcm9vZnNbaV07XG4gICAgY29uc3QgbnV0emFwID0gbnV0emFwTWFwLmdldChwcm9vZi5DKTtcbiAgICBpZiAoIW51dHphcCkgY29udGludWU7XG4gICAgaWYgKHN0YXRlLnN0YXRlID09PSBDaGVja1N0YXRlRW51bTIuU1BFTlQpIHtcbiAgICAgIHJlc3VsdC5zcGVudFByb29mcy5wdXNoKHByb29mKTtcbiAgICAgIGlmICghcmVzdWx0Lm51dHphcHNXaXRoU3BlbnRQcm9vZnMuc29tZSgobikgPT4gbi5pZCA9PT0gbnV0emFwLmlkKSkge1xuICAgICAgICByZXN1bHQubnV0emFwc1dpdGhTcGVudFByb29mcy5wdXNoKG51dHphcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5zdGF0ZSA9PT0gQ2hlY2tTdGF0ZUVudW0yLlVOU1BFTlQpIHtcbiAgICAgIHJlc3VsdC51bnNwZW50UHJvb2ZzLnB1c2gocHJvb2YpO1xuICAgICAgaWYgKCFyZXN1bHQubnV0emFwc1dpdGhVbnNwZW50UHJvb2ZzLnNvbWUoKG4pID0+IG4uaWQgPT09IG51dHphcC5pZCkpIHtcbiAgICAgICAgcmVzdWx0Lm51dHphcHNXaXRoVW5zcGVudFByb29mcy5wdXNoKG51dHphcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy9udXR6YXAtbW9uaXRvci9pbmRleC50c1xudmFyIF9zdGFydFRpbWUyID0gRGF0ZS5ub3coKTtcbmZ1bmN0aW9uIGxvZzIoX21zZykge1xufVxudmFyIE5ES051dHphcE1vbml0b3IgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjQge1xuICBzdG9yZTtcbiAgbmRrO1xuICB1c2VyO1xuICByZWxheVNldDtcbiAgc3ViO1xuICBudXR6YXBTdGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfd2FsbGV0O1xuICBtaW50TGlzdDtcbiAgcHJpdmtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjYXNodVdhbGxldHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBnZXRDYXNodVdhbGxldCA9IGdldENhc2h1V2FsbGV0LmJpbmQodGhpcyk7XG4gIG9uTWludEluZm9OZWVkZWQ7XG4gIG9uTWludEluZm9Mb2FkZWQ7XG4gIG9uTWludEtleXNOZWVkZWQ7XG4gIG9uTWludEtleXNMb2FkZWQ7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgbnV0emFwIG1vbml0b3IuXG4gICAqIEBwYXJhbSBuZGsgLSBUaGUgTkRLIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyIHRvIG1vbml0b3IuXG4gICAqIEBwYXJhbSBtaW50TGlzdCAtIEFuIG9wdGlvbmFsIG1pbnQgbGlzdCB0byBtb25pdG9yIHphcHMgb24sIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQsIHRoZSBtb25pdG9yIHdpbGwgdXNlIHRoZSByZWxheSBzZXQgZnJvbSB0aGUgbWludCBsaXN0LCB3aGljaCBpcyB0aGUgY29ycmVjdCBkZWZhdWx0IGJlaGF2aW9yIG9mIE5JUC02MSB6YXBzLlxuICAgKiBAcGFyYW0gc3RvcmUgLSBBbiBvcHRpb25hbCBzdG9yZSB0byBzYXZlIGFuZCBsb2FkIG51dHphcCBzdGF0ZXMgdG8uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuZGssIHVzZXIsIHsgbWludExpc3QsIHN0b3JlIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgdGhpcy5taW50TGlzdCA9IG1pbnRMaXN0O1xuICAgIHRoaXMucmVsYXlTZXQgPSBtaW50TGlzdD8ucmVsYXlTZXQ7XG4gICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICB9XG4gIHNldCB3YWxsZXQod2FsbGV0KSB7XG4gICAgdGhpcy5fd2FsbGV0ID0gd2FsbGV0O1xuICAgIGlmICh3YWxsZXQpIHtcbiAgICAgIHRoaXMub25NaW50SW5mb05lZWRlZCA/Pz0gd2FsbGV0Lm9uTWludEluZm9OZWVkZWQ7XG4gICAgICB0aGlzLm9uTWludEluZm9Mb2FkZWQgPz89IHdhbGxldC5vbk1pbnRJbmZvTG9hZGVkO1xuICAgICAgdGhpcy5vbk1pbnRLZXlzTmVlZGVkID8/PSB3YWxsZXQub25NaW50S2V5c05lZWRlZDtcbiAgICAgIHRoaXMub25NaW50S2V5c0xvYWRlZCA/Pz0gd2FsbGV0Lm9uTWludEtleXNMb2FkZWQ7XG4gICAgICBpZiAod2FsbGV0IGluc3RhbmNlb2YgTkRLQ2FzaHVXYWxsZXQgJiYgd2FsbGV0Py5wcml2a2V5cykge1xuICAgICAgICBmb3IgKGNvbnN0IFtwdWJrZXksIHNpZ25lcl0gb2Ygd2FsbGV0LnByaXZrZXlzLmVudHJpZXMoKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmFkZFByaXZrZXkoc2lnbmVyKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZmFpbGVkIHRvIGFkZCBwcml2a2V5IGZyb20gd2FsbGV0IHdpdGggcHVia2V5XCIsIHB1YmtleSwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCB3YWxsZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldDtcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZSBwcml2YXRlIGtleXMgdGhhdCBjYW4gYmUgdXNlZCB0byByZWRlZW0gbnV0emFwcy5cbiAgICpcbiAgICogVGhpcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIHdoZW4gYSBOV0Mgd2FsbGV0IGlzIHVzZWQgdG8gcmVjZWl2ZSB0aGUgbnV0emFwcyxcbiAgICogc2luY2UgaXQgZG9lc24ndCBoYXZlIGEgcHJpdmF0ZSBrZXksIHRoaXMgYWxsb3dzIGtlZXBpbmcgdGhlIHByaXZhdGUga2V5IGluIGEgc2VwYXJhdGVcbiAgICogcGxhY2UgKGlkZWFsbHkgYSBOSVAtNjAgd2FsbGV0IGV2ZW50KS5cbiAgICpcbiAgICogTXVsdGlwbGUga2V5cyBjYW4gYmUgYWRkZWQsIGFuZCB0aGUgbW9uaXRvciB3aWxsIHVzZSB0aGUgY29ycmVjdCBrZXkgZm9yIHRoZSBudXR6YXAuXG4gICAqL1xuICBhc3luYyBhZGRQcml2a2V5KHNpZ25lcikge1xuICAgIGNvbnN0IHB1YmtleSA9IChhd2FpdCBzaWduZXIudXNlcigpKS5wdWJrZXk7XG4gICAgaWYgKHRoaXMucHJpdmtleXMuaGFzKHB1YmtleSkpIHJldHVybjtcbiAgICB0aGlzLnByaXZrZXlzLnNldChwdWJrZXksIHNpZ25lcik7XG4gICAgaWYgKCF0aGlzLnN1YikgcmV0dXJuO1xuICAgIGNvbnN0IGluTXNzaW5nUHJpdktleVN0YXRlID0gKHN0YXRlKSA9PiBzdGF0ZS5zdGF0dXMgPT09IE5ka051dHphcFN0YXR1cy5NSVNTSU5HX1BSSVZLRVk7XG4gICAgY29uc3QgZW5zdXJlSXNDYXNodVB1YmtleTIgPSAoc3RhdGUpID0+IHN0YXRlLm51dHphcD8ucDJwayA9PT0gcHVia2V5O1xuICAgIGNvbnN0IGNhbmRpZGF0ZU51dHphcHMgPSBBcnJheS5mcm9tKHRoaXMubnV0emFwU3RhdGVzLnZhbHVlcygpKS5maWx0ZXIoaW5Nc3NpbmdQcml2S2V5U3RhdGUpLmZpbHRlcihlbnN1cmVJc0Nhc2h1UHVia2V5Mik7XG4gICAgaWYgKGNhbmRpZGF0ZU51dHphcHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbnV0emFwcyA9IGNhbmRpZGF0ZU51dHphcHMubWFwKChjKSA9PiBjLm51dHphcCkuZmlsdGVyKChuKSA9PiAhIW4pO1xuICAgICAgY29uc3QgZ3JvdXBlZE51dHphcHMgPSBncm91cE51dHphcHMobnV0emFwcywgdGhpcyk7XG4gICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIGdyb3VwZWROdXR6YXBzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY2hlY2tBbmRSZWRlZW1Hcm91cChncm91cCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGFkZFVzZXJQcml2S2V5KCkge1xuICAgIGNvbnN0IHsgc2lnbmVyIH0gPSB0aGlzLm5kaztcbiAgICBpZiAoc2lnbmVyIGluc3RhbmNlb2YgTkRLUHJpdmF0ZUtleVNpZ25lcjIpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBzaWduZXIudXNlcigpO1xuICAgICAgY29uc3QgcHVia2V5ID0gdXNlci5wdWJrZXk7XG4gICAgICB0aGlzLnByaXZrZXlzLnNldChwdWJrZXksIHNpZ25lcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBMb2FkcyBraW5kOjM3NSBiYWNrdXAgZXZlbnRzIGZyb20gdGhpcyB1c2VyIHRvIGZpbmQgYWxsIGJhY2t1cCBrZXlzIHRoaXMgdXNlciBtaWdodCBoYXZlIHVzZWQuXG4gICAqL1xuICBhc3luYyBnZXRCYWNrdXBLZXlzKCkge1xuICAgIGNvbnN0IGJhY2t1cEV2ZW50cyA9IGF3YWl0IHRoaXMubmRrLmZldGNoRXZlbnRzKFxuICAgICAgW3sga2luZHM6IFtOREtLaW5kNS5DYXNodVdhbGxldEJhY2t1cF0sIGF1dGhvcnM6IFt0aGlzLnVzZXIucHVia2V5XSB9XSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHRoaXMucmVsYXlTZXRcbiAgICApO1xuICAgIGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKHRoaXMucHJpdmtleXMudmFsdWVzKCkpO1xuICAgIGNvbnN0IGtleXNOb3RGb3VuZCA9IG5ldyBTZXQoa2V5cy5tYXAoKHNpZ25lcikgPT4gc2lnbmVyLnByaXZhdGVLZXkpKTtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGJhY2t1cEV2ZW50cykge1xuICAgICAgY29uc3QgYmFja3VwID0gYXdhaXQgTkRLQ2FzaHVXYWxsZXRCYWNrdXAuZnJvbShldmVudCk7XG4gICAgICBpZiAoIWJhY2t1cCkgY29udGludWU7XG4gICAgICBmb3IgKGNvbnN0IHByaXZrZXkgb2YgYmFja3VwLnByaXZrZXlzKSB7XG4gICAgICAgIGlmIChrZXlzTm90Rm91bmQuaGFzKHByaXZrZXkpKSBrZXlzTm90Rm91bmQuZGVsZXRlKHByaXZrZXkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHNpZ25lciA9IG5ldyBOREtQcml2YXRlS2V5U2lnbmVyMihwcml2a2V5KTtcbiAgICAgICAgICB0aGlzLmFkZFByaXZrZXkoc2lnbmVyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJmYWlsZWQgdG8gYWRkIHByaXZrZXlcIiwgcHJpdmtleSwgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXNOb3RGb3VuZC5zaXplID4gMCkge1xuICAgICAgY29uc3QgYmFja3VwID0gbmV3IE5ES0Nhc2h1V2FsbGV0QmFja3VwKHRoaXMubmRrKTtcbiAgICAgIGJhY2t1cC5wcml2a2V5cyA9IEFycmF5LmZyb20oa2V5c05vdEZvdW5kKTtcbiAgICAgIGF3YWl0IGJhY2t1cC5zYXZlKHRoaXMucmVsYXlTZXQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3RhcnQgdGhlIG51dHphcCBtb25pdG9yLiBUaGUgbW9uaXRvciB3aWxsIGluaXRpYWxseSBsb29rIGJhY2tcbiAgICogZm9yIG51dHphcHMgaXQgZG9lc24ndCBrbm93IGFib3V0IGFuZCB3aWxsIHRyeSB0byByZWRlZW0gdGhlbS5cbiAgICpcbiAgICogQHBhcmFtIGtub3duTnV0emFwcyAtIEFuIG9wdGlvbmFsIHNldCBvZiBudXR6YXBzIHRoZSBhcHAga25vd3MgYWJvdXQuIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHNvIHRoYXQgd2UgZG9uJ3QgdHJ5IHRvIHJlZGVlbSBudXR6YXBzIHdlIGtub3cgaGF2ZSBhbHJlYWR5IGJlZW4gcmVkZWVtZWQuXG4gICAqIEBwYXJhbSBwYWdlU2l6ZSAtIFRoZSBudW1iZXIgb2YgbnV0emFwcyB0byBmZXRjaCBwZXIgcGFnZS5cbiAgICpcbiAgICovXG4gIGFzeW5jIHN0YXJ0KHsgZmlsdGVyLCBvcHRzIH0pIHtcbiAgICBsb2cyKFwiU3RhcnRpbmcgbnV0emFwIG1vbml0b3JcIik7XG4gICAgaWYgKHRoaXMuc3ViKSB0aGlzLnN1Yi5zdG9wKCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuZ2V0QmFja3VwS2V5cygpO1xuICAgICAgbG9nMihgR290IGJhY2t1cCBrZXlzICR7dGhpcy5wcml2a2V5cy5zaXplfWApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJcXHUyNzRDIEZhaWxlZCB0byBnZXQgYmFja3VwIGtleXNcIiwgZSk7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuYWRkVXNlclByaXZLZXkoKTtcbiAgICBsb2cyKGBBZGRlZCB1c2VyIHByaXZrZXkgJHt0aGlzLnByaXZrZXlzLnNpemV9YCk7XG4gICAgY29uc3Qgc2luY2UgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpO1xuICAgIGNvbnN0IG1vbml0b3JGaWx0ZXIgPSB7IGtpbmRzOiBbTkRLS2luZDUuTnV0emFwXSwgXCIjcFwiOiBbdGhpcy51c2VyLnB1YmtleV0sIHNpbmNlIH07XG4gICAgaWYgKHRoaXMuc3RvcmUpIHtcbiAgICAgIGxvZzIoXCJXaWxsIGxvYWQgbnV0emFwcyBmcm9tIHN0b3JlXCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbnV0emFwcyA9IGF3YWl0IHRoaXMuc3RvcmUuZ2V0QWxsTnV0emFwcygpO1xuICAgICAgICBsb2cyKGBMb2FkZWQgJHtudXR6YXBzLnNpemV9IG51dHphcHNgKTtcbiAgICAgICAgZm9yIChjb25zdCBbaWQsIHN0YXRlXSBvZiBudXR6YXBzLmVudHJpZXMoKSkge1xuICAgICAgICAgIHRoaXMubnV0emFwU3RhdGVzLnNldChpZCwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGxvZzIoYENoYW5nZWQgdGhlIHN0YXRlIG9mICR7bnV0emFwcy5zaXplfSBudXR6YXBzYCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJcXHUyNzRDIEZhaWxlZCB0byBsb2FkIG51dHphcHMgZnJvbSBzdG9yZVwiLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxvZzIoXCJXaWxsIHN0YXJ0IHByb2Nlc3NpbmcgcmVkZWVtYWJsZSBudXR6YXBzIGZyb20gc3RvcmVcIik7XG4gICAgICBhd2FpdCB0aGlzLnByb2Nlc3NSZWRlZW1hYmxlTnV0emFwc0Zyb21TdG9yZSgpO1xuICAgICAgbG9nMihcIkZpbmlzaGVkIHByb2Nlc3NpbmcgcmVkZWVtYWJsZSBudXR6YXBzIGZyb20gc3RvcmVcIik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIlxcdTI3NEMgRmFpbGVkIHRvIHByb2Nlc3MgcmVkZWVtYWJsZSBudXR6YXBzIGZyb20gc3RvcmVcIiwgZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsb2cyKFwiV2lsbCBzdGFydCBwcm9jZXNzaW5nIGFjY3VtdWxhdGVkIG51dHphcHNcIik7XG4gICAgICBhd2FpdCB0aGlzLnByb2Nlc3NBY2N1bXVsYXRlZE51dHphcHMoZmlsdGVyLCBvcHRzKTtcbiAgICAgIGxvZzIoYEZpbmlzaGVkIHByb2Nlc3NpbmcgYWNjdW11bGF0ZWQgbnV0emFwcyAke3RoaXMubnV0emFwU3RhdGVzLnNpemV9YCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIlxcdTI3NEMgRmFpbGVkIHRvIHByb2Nlc3MgbnV0emFwc1wiLCBlKTtcbiAgICB9XG4gICAgbG9nMihgUnVubmluZyBmaWx0ZXIgJHtKU09OLnN0cmluZ2lmeShtb25pdG9yRmlsdGVyKX1gKTtcbiAgICBjb25zdCBzdWJzY3JpYmVPcHRzID0ge1xuICAgICAgc3ViSWQ6IFwibmRrLXdhbGxldDpudXR6YXAtbW9uaXRvclwiLFxuICAgICAgY2FjaGVVc2FnZTogTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTIuT05MWV9SRUxBWSxcbiAgICAgIHdyYXA6IGZhbHNlLFxuICAgICAgLy8gV2Ugc2tpcCB2YWxpZGF0aW9uIHNvIHRoZSB1c2VyIGtub3dzIGFib3V0IG51dHphcHMgdGhhdCB3ZXJlIHNlbnQgYnV0IGFyZSBub3QgdmFsaWRcbiAgICAgIC8vIHRoaXMgd2F5IHRvb2xpbmcgY2FuIGJlIG1vcmUgY29tcHJlaGVuc2l2ZSBhbmQgaW5jbHVkZSBudXR6YXBzIHRoYXQgd2VyZSBub3QgdmFsaWRcbiAgICAgIHNraXBWYWxpZGF0aW9uOiB0cnVlLFxuICAgICAgLi4ub3B0cyxcbiAgICAgIHJlbGF5U2V0OiB0aGlzLnJlbGF5U2V0XG4gICAgICAvLyBQYXNzIHJlbGF5U2V0IHZpYSBvcHRpb25zXG4gICAgfTtcbiAgICB0aGlzLnN1YiA9IHRoaXMubmRrLnN1YnNjcmliZShcbiAgICAgIG1vbml0b3JGaWx0ZXIsXG4gICAgICBzdWJzY3JpYmVPcHRzLFxuICAgICAgLy8gdGhpcy5yZWxheVNldCwgLy8gUmVtb3ZlZDogUGFzc2VkIHZpYSBvcHRzXG4gICAgICB7XG4gICAgICAgIC8vIGF1dG9TdGFydCBoYW5kbGVycyAobm93IDNyZCBhcmd1bWVudClcbiAgICAgICAgb25FdmVudDogKGV2ZW50KSA9PiB0aGlzLmV2ZW50SGFuZGxlcihldmVudClcbiAgICAgICAgLy8gQWRkZWQgTkRLRXZlbnQgdHlwZVxuICAgICAgfVxuICAgICk7XG4gICAgbG9nMihcIlxcdTI3MDUgTnV0emFwIG1vbml0b3Igc3RhcnRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ3JvdXAgb2YgbnV0emFwcyBjYW4gYmUgcmVkZWVtZWQgYW5kIHJlZGVlbXMgdGhlIG9uZXMgdGhhdCBjYW4gYmUuXG4gICAqL1xuICBhc3luYyBjaGVja0FuZFJlZGVlbUdyb3VwKGdyb3VwLCBvbGRlc3RVbnNwZW50TnV0emFwVGltZSkge1xuICAgIGNvbnN0IGNhc2h1V2FsbGV0ID0gYXdhaXQgdGhpcy5nZXRDYXNodVdhbGxldChncm91cC5taW50KTtcbiAgICBjb25zdCBzcGVuZFN0YXRlcyA9IGF3YWl0IGdldFByb29mU3BlbmRTdGF0ZShjYXNodVdhbGxldCwgZ3JvdXAubnV0emFwcyk7XG4gICAgZm9yIChjb25zdCBudXR6YXAgb2Ygc3BlbmRTdGF0ZXMubnV0emFwc1dpdGhTcGVudFByb29mcykge1xuICAgICAgdGhpcy51cGRhdGVOdXR6YXBTdGF0ZShudXR6YXAuaWQsIHsgc3RhdHVzOiBOZGtOdXR6YXBTdGF0dXMuU1BFTlQsIG51dHphcCB9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBudXR6YXAgb2Ygc3BlbmRTdGF0ZXMubnV0emFwc1dpdGhVbnNwZW50UHJvb2ZzKSB7XG4gICAgICB0aGlzLmVtaXQoXCJzZWVuXCIsIG51dHphcCk7XG4gICAgICB0aGlzLnVwZGF0ZU51dHphcFN0YXRlKG51dHphcC5pZCwgeyBzdGF0dXM6IE5ka051dHphcFN0YXR1cy5JTklUSUFMLCBudXR6YXAgfSk7XG4gICAgfVxuICAgIGlmIChzcGVuZFN0YXRlcy51bnNwZW50UHJvb2ZzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3QgbnV0emFwIG9mIHNwZW5kU3RhdGVzLm51dHphcHNXaXRoVW5zcGVudFByb29mcykge1xuICAgICAgICBpZiAoIW9sZGVzdFVuc3BlbnROdXR6YXBUaW1lIHx8IG9sZGVzdFVuc3BlbnROdXR6YXBUaW1lID4gbnV0emFwLmNyZWF0ZWRfYXQpIHtcbiAgICAgICAgICBvbGRlc3RVbnNwZW50TnV0emFwVGltZSA9IG51dHphcC5jcmVhdGVkX2F0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLnJlZGVlbU51dHphcHMoZ3JvdXAubWludCwgc3BlbmRTdGF0ZXMubnV0emFwc1dpdGhVbnNwZW50UHJvb2ZzLCBzcGVuZFN0YXRlcy51bnNwZW50UHJvb2ZzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBudXR6YXBzIHRoYXQgaGF2ZSBiZWVuIGFjY3VtdWxhdGVkIHdoaWxlIHRoZSBtb25pdG9yIHdhcyBvZmZsaW5lLlxuICAgKiBAcGFyYW0gc3RhcnRPcHRzXG4gICAqIEBwYXJhbSBvcHRzXG4gICAqL1xuICBhc3luYyBwcm9jZXNzQWNjdW11bGF0ZWROdXR6YXBzKGZpbHRlciA9IHt9LCBvcHRzKSB7XG4gICAgbG9nMihcIlByb2Nlc3NpbmcgYWNjdW11bGF0ZWQgbnV0emFwc1wiKTtcbiAgICBsZXQgb2xkZXN0VW5zcGVudE51dHphcFRpbWU7XG4gICAgY29uc3QgX2ZpbHRlciA9IHsgLi4uZmlsdGVyIH07XG4gICAgX2ZpbHRlci5raW5kcyA9IFtOREtLaW5kNS5OdXR6YXBdO1xuICAgIF9maWx0ZXJbXCIjcFwiXSA9IFt0aGlzLnVzZXIucHVia2V5XTtcbiAgICBjb25zdCBrbm93bk51dHphcElkcyA9IG5ldyBTZXQodGhpcy5udXR6YXBTdGF0ZXMua2V5cygpKTtcbiAgICBjb25zdCBudXR6YXBzID0gYXdhaXQgZmV0Y2hQYWdlKHRoaXMubmRrLCBfZmlsdGVyLCBrbm93bk51dHphcElkcywgdGhpcy5yZWxheVNldCk7XG4gICAgbG9nMihgV2UgbG9hZGVkICR7bnV0emFwcy5sZW5ndGh9IG51dHphcHMgZnJvbSByZWxheXNgKTtcbiAgICBvbGRlc3RVbnNwZW50TnV0emFwVGltZSA9IGF3YWl0IHRoaXMucHJvY2Vzc051dHphcHMobnV0emFwcywgb2xkZXN0VW5zcGVudE51dHphcFRpbWUpO1xuICAgIGxvZzIoXCJXZSBmaW5pc2hlZCBwcm9jZXNzaW5nIHRoZXNlbnV0emFwc1wiKTtcbiAgICBpZiAob2xkZXN0VW5zcGVudE51dHphcFRpbWUpIHtcbiAgICAgIF9maWx0ZXIuc2luY2UgPSBvbGRlc3RVbnNwZW50TnV0emFwVGltZSAtIDE7XG4gICAgICBhd2FpdCB0aGlzLnByb2Nlc3NBY2N1bXVsYXRlZE51dHphcHMoX2ZpbHRlciwgb3B0cyk7XG4gICAgfVxuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5zdWI/LnN0b3AoKTtcbiAgfVxuICB1cGRhdGVOdXR6YXBTdGF0ZShpZCwgc3RhdGUpIHtcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB0aGlzLm51dHphcFN0YXRlcy5nZXQoaWQpID8/IHt9O1xuICAgIGlmICghY3VycmVudFN0YXRlLnN0YXR1cykgc3RhdGUuc3RhdHVzID8/PSBOZGtOdXR6YXBTdGF0dXMuSU5JVElBTDtcbiAgICBjb25zdCBzdGF0ZUlzVW5jaGFuZ2VkID0gT2JqZWN0LmVudHJpZXMoc3RhdGUpLmV2ZXJ5KChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmIChrZXkgPT09IFwibnV0emFwXCIgJiYgY3VycmVudFN0YXRlLm51dHphcCAmJiB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY3VycmVudFN0YXRlLm51dHphcC5pZCA9PT0gdmFsdWUuaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudFN0YXRlW2tleV0gPT09IHZhbHVlO1xuICAgIH0pO1xuICAgIGlmIChzdGF0ZUlzVW5jaGFuZ2VkKSByZXR1cm47XG4gICAgdGhpcy5udXR6YXBTdGF0ZXMuc2V0KGlkLCB7IC4uLmN1cnJlbnRTdGF0ZSwgLi4uc3RhdGUgfSk7XG4gICAgdGhpcy5lbWl0KFwic3RhdGVfY2hhbmdlZFwiLCBpZCwgY3VycmVudFN0YXRlLnN0YXR1cyk7XG4gICAgY29uc3Qgc2VyaWFsaXplZFN0YXRlID0gKHN0YXRlMikgPT4ge1xuICAgICAgY29uc3QgcmVzID0geyAuLi5zdGF0ZTIgfTtcbiAgICAgIGlmIChyZXMubnV0emFwKSByZXMubnV0emFwID0gcmVzLm51dHphcC5pZDtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXMpO1xuICAgIH07XG4gICAgY29uc3QgY3VycmVudFN0YXR1c1N0ciA9IHNlcmlhbGl6ZWRTdGF0ZShjdXJyZW50U3RhdGUpO1xuICAgIGNvbnN0IG5ld1N0YXR1c1N0ciA9IHNlcmlhbGl6ZWRTdGF0ZShzdGF0ZSk7XG4gICAgbG9nMihgWyR7aWQuc3Vic3RyaW5nKDAsIDYpfV0gJHtjdXJyZW50U3RhdHVzU3RyfSBjaGFuZ2VkIHRvIFxcdXsxRjQ0OX0gJHtuZXdTdGF0dXNTdHJ9YCk7XG4gICAgdGhpcy5zdG9yZT8uc2V0TnV0emFwU3RhdGUoaWQsIHN0YXRlKTtcbiAgfVxuICBhc3luYyBldmVudEhhbmRsZXIoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5udXR6YXBTdGF0ZXMuaGFzKGV2ZW50LmlkKSkgcmV0dXJuO1xuICAgIGNvbnN0IG51dHphcCA9IGF3YWl0IE5ES051dHphcDIuZnJvbShldmVudCk7XG4gICAgaWYgKCFudXR6YXApIHtcbiAgICAgIHRoaXMudXBkYXRlTnV0emFwU3RhdGUoZXZlbnQuaWQsIHtcbiAgICAgICAgc3RhdHVzOiBOZGtOdXR6YXBTdGF0dXMuUEVSTUFORU5UX0VSUk9SLFxuICAgICAgICBlcnJvck1lc3NhZ2U6IFwiRmFpbGVkIHRvIHBhcnNlIG51dHphcFwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubWludExpc3QgJiYgIXRoaXMubWludExpc3QubWludHMuaW5jbHVkZXMobnV0emFwLm1pbnQpKSB7XG4gICAgICB0aGlzLmVtaXQoXCJzZWVuX2luX3Vua25vd25fbWludFwiLCBudXR6YXApO1xuICAgIH1cbiAgICB0aGlzLnJlZGVlbU51dHphcChudXR6YXApO1xuICB9XG4gIC8qKlxuICAgKiBHYXRoZXJzIHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb24gdG8gcmVkZWVtIGEgbnV0emFwIGFuZCB0aGVuIHJlZGVlbXMgaXQuXG4gICAqIEBwYXJhbSBudXR6YXBcbiAgICovXG4gIGFzeW5jIHJlZGVlbU51dHphcChudXR6YXApIHtcbiAgICBpZiAoIXRoaXMubnV0emFwU3RhdGVzLmhhcyhudXR6YXAuaWQpKVxuICAgICAgdGhpcy51cGRhdGVOdXR6YXBTdGF0ZShudXR6YXAuaWQsIHsgc3RhdHVzOiBOZGtOdXR6YXBTdGF0dXMuSU5JVElBTCwgbnV0emFwIH0pO1xuICAgIGNvbnN0IHJhd1AycGsgPSBudXR6YXAucmF3UDJwaztcbiAgICBpZiAocmF3UDJwaykge1xuICAgICAgY29uc3QgY2FzaHVQdWJrZXkgPSBwcm9vZlAycGsyKG51dHphcC5wcm9vZnNbMF0pO1xuICAgICAgaWYgKGNhc2h1UHVia2V5KSB7XG4gICAgICAgIGNvbnN0IG5vc3RyUHVia2V5ID0gY2FzaHVQdWJrZXlUb05vc3RyUHVia2V5MihjYXNodVB1YmtleSk7XG4gICAgICAgIGlmIChub3N0clB1YmtleSAmJiAhdGhpcy5wcml2a2V5cy5oYXMobm9zdHJQdWJrZXkpKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVOdXR6YXBTdGF0ZShudXR6YXAuaWQsIHtcbiAgICAgICAgICAgIHN0YXR1czogTmRrTnV0emFwU3RhdHVzLk1JU1NJTkdfUFJJVktFWSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZTogXCJObyBwcml2a2V5IGZvdW5kIGZvciBwMnBrXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5udXR6YXBTdGF0ZXMuZ2V0KG51dHphcC5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgdGhpcy5yZWRlZW1OdXR6YXBzKG51dHphcC5taW50LCBbbnV0emFwXSwgbnV0emFwLnByb29mcyk7XG4gICAgcmV0dXJuIHRoaXMubnV0emFwU3RhdGVzLmdldChudXR6YXAuaWQpO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHJlZGVlbXMgYSBsaXN0IG9mIHByb29mcy5cbiAgICpcbiAgICogUHJvb2ZzIHdpbGwgYmUgYXR0ZW1wdGVkIHRvIGJlIHJlZGVlbWVkIGluIGEgc2luZ2xlIGNhbGwsIHNvIHRoZXkgd2lsbCBhbGwgd29yayBvciBub25lIHdpbGwuXG4gICAqIEVpdGhlciBjYWxsIHRoaXMgZnVuY3Rpb24gd2l0aCBwcm9vZnMgdGhhdCBoYXZlIGJlZW4gdmVyaWZpZWQgdG8gYmUgcmVkZWVtYWJsZSBvciBkb24ndCBncm91cCB0aGVtLFxuICAgKiBhbmQgcHJvdmlkZSBhIHNpbmdsZSBudXR6YXAgcGVyIGNhbGwuXG4gICAqXG4gICAqIEFsbCBudXR6YXBzIE1VU1QgYmUgcDJwa2VkIHRvIHRoZSBzYW1lIHB1YmtleS5cbiAgICpcbiAgICogQHBhcmFtIG1pbnRcbiAgICogQHBhcmFtIG51dHphcHNcbiAgICogQHBhcmFtIHByb29mc1xuICAgKiBAcGFyYW0gcHJpdmtleSBQcml2YXRlIGtleSB0aGF0IGlzIG5lZWRlZCB0byByZWRlZW0gdGhlIG51dHphcHMuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyByZWRlZW1OdXR6YXBzKG1pbnQsIG51dHphcHMsIHByb29mcykge1xuICAgIGlmICghdGhpcy53YWxsZXQpIHRocm93IG5ldyBFcnJvcihcIndhbGxldCBub3Qgc2V0XCIpO1xuICAgIGlmICghdGhpcy53YWxsZXQucmVkZWVtTnV0emFwcykgdGhyb3cgbmV3IEVycm9yKFwid2FsbGV0IGRvZXMgbm90IHN1cHBvcnQgcmVkZWVtaW5nIG51dHphcHNcIik7XG4gICAgY29uc3QgY2FzaHVXYWxsZXQgPSBhd2FpdCB0aGlzLmdldENhc2h1V2FsbGV0KG1pbnQpO1xuICAgIGNvbnN0IHZhbGlkTnV0emFwcyA9IFtdO1xuICAgIGlmIChwcm9vZnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2FzaHVQdWJrZXkyID0gcHJvb2ZQMnBrMihwcm9vZnNbMF0pO1xuICAgICAgaWYgKCFjYXNodVB1YmtleTIpIHtcbiAgICAgICAgZm9yIChjb25zdCBudXR6YXAgb2YgbnV0emFwcykge1xuICAgICAgICAgIHRoaXMudXBkYXRlTnV0emFwU3RhdGUobnV0emFwLmlkLCB7XG4gICAgICAgICAgICBzdGF0dXM6IE5ka051dHphcFN0YXR1cy5JTlZBTElEX05VVFpBUCxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZTogXCJJbnZhbGlkIG51dHphcDogcHJvb2YgaXMgbm90IHAycGtcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vc3RyUHVia2V5MiA9IGNhc2h1UHVia2V5VG9Ob3N0clB1YmtleTIoY2FzaHVQdWJrZXkyKTtcbiAgICAgIGlmICghbm9zdHJQdWJrZXkyKSB7XG4gICAgICAgIGZvciAoY29uc3QgbnV0emFwIG9mIG51dHphcHMpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZU51dHphcFN0YXRlKG51dHphcC5pZCwge1xuICAgICAgICAgICAgc3RhdHVzOiBOZGtOdXR6YXBTdGF0dXMuSU5WQUxJRF9OVVRaQVAsXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2U6IFwiSW52YWxpZCBudXR6YXA6IGxvY2tlZCB0byBhbiBpbnZhbGlkIHB1YmxpYyBrZXkgKG5vdCBhIG5vc3RyIGtleSlcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByaXZrZXkyID0gdGhpcy5wcml2a2V5cy5nZXQobm9zdHJQdWJrZXkyKTtcbiAgICAgIGlmICghcHJpdmtleTIpIHtcbiAgICAgICAgZm9yIChjb25zdCBudXR6YXAgb2YgbnV0emFwcykge1xuICAgICAgICAgIHRoaXMudXBkYXRlTnV0emFwU3RhdGUobnV0emFwLmlkLCB7XG4gICAgICAgICAgICBzdGF0dXM6IE5ka051dHphcFN0YXR1cy5NSVNTSU5HX1BSSVZLRVksXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2U6IFwiTm8gcHJpdmtleSBmb3VuZCBmb3IgcDJwa1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IG51dHphcCBvZiBudXR6YXBzKSB7XG4gICAgICBpZiAoIW51dHphcC5pc1ZhbGlkKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTnV0emFwU3RhdGUobnV0emFwLmlkLCB7XG4gICAgICAgICAgc3RhdHVzOiBOZGtOdXR6YXBTdGF0dXMuSU5WQUxJRF9OVVRaQVAsXG4gICAgICAgICAgZXJyb3JNZXNzYWdlOiBcIkludmFsaWQgbnV0emFwXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmF3UDJwayA9IG51dHphcC5yYXdQMnBrO1xuICAgICAgaWYgKCFyYXdQMnBrKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTnV0emFwU3RhdGUobnV0emFwLmlkLCB7XG4gICAgICAgICAgc3RhdHVzOiBOZGtOdXR6YXBTdGF0dXMuSU5WQUxJRF9OVVRaQVAsXG4gICAgICAgICAgZXJyb3JNZXNzYWdlOiBcIkludmFsaWQgbnV0emFwOiBsb2NrZWQgdG8gYW4gaW52YWxpZCBwdWJsaWMga2V5IChubyBwMnBrKVwiXG4gICAgICAgIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyYXdQMnBrLmxlbmd0aCAhPT0gNjYpIHtcbiAgICAgICAgdGhpcy51cGRhdGVOdXR6YXBTdGF0ZShudXR6YXAuaWQsIHtcbiAgICAgICAgICBzdGF0dXM6IE5ka051dHphcFN0YXR1cy5JTlZBTElEX05VVFpBUCxcbiAgICAgICAgICBlcnJvck1lc3NhZ2U6IGBJbnZhbGlkIG51dHphcDogbG9ja2VkIHRvIGFuIGludmFsaWQgcHVibGljIGtleSAobGVuZ3RoICR7cmF3UDJway5sZW5ndGh9KWBcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFsaWROdXR6YXBzLnB1c2gobnV0emFwKTtcbiAgICB9XG4gICAgaWYgKHZhbGlkTnV0emFwcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICBjb25zdCBjYXNodVB1YmtleSA9IHByb29mUDJwazIocHJvb2ZzWzBdKTtcbiAgICBpZiAoIWNhc2h1UHVia2V5KSByZXR1cm47XG4gICAgY29uc3Qgbm9zdHJQdWJrZXkgPSBjYXNodVB1YmtleVRvTm9zdHJQdWJrZXkyKGNhc2h1UHVia2V5KTtcbiAgICBpZiAoIW5vc3RyUHVia2V5KSByZXR1cm47XG4gICAgY29uc3QgcHJpdmtleSA9IHRoaXMucHJpdmtleXMuZ2V0KG5vc3RyUHVia2V5KTtcbiAgICBpZiAoIXByaXZrZXkpIHtcbiAgICAgIGZvciAoY29uc3QgbnV0emFwIG9mIHZhbGlkTnV0emFwcykge1xuICAgICAgICB0aGlzLnVwZGF0ZU51dHphcFN0YXRlKG51dHphcC5pZCwge1xuICAgICAgICAgIHN0YXR1czogTmRrTnV0emFwU3RhdHVzLk1JU1NJTkdfUFJJVktFWSxcbiAgICAgICAgICBlcnJvck1lc3NhZ2U6IFwiTm8gcHJpdmtleSBmb3VuZCBmb3IgcDJwa1wiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG51dHphcCBvZiB2YWxpZE51dHphcHMpIHtcbiAgICAgIHRoaXMudXBkYXRlTnV0emFwU3RhdGUobnV0emFwLmlkLCB7IHN0YXR1czogTmRrTnV0emFwU3RhdHVzLlBST0NFU1NJTkcgfSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0b3RhbEFtb3VudCA9IGF3YWl0IHRoaXMud2FsbGV0LnJlZGVlbU51dHphcHMobnV0emFwcywgcHJpdmtleS5wcml2YXRlS2V5LCB7XG4gICAgICAgIGNhc2h1V2FsbGV0LFxuICAgICAgICBwcm9vZnMsXG4gICAgICAgIG1pbnRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0KFwicmVkZWVtZWRcIiwgbnV0emFwcywgdG90YWxBbW91bnQpO1xuICAgICAgZm9yIChjb25zdCBudXR6YXAgb2YgbnV0emFwcykge1xuICAgICAgICBjb25zdCBudXR6YXBUb3RhbEFtb3VudCA9IHByb29mc1RvdGFsKHByb29mc0ludGVyc2VjdGlvbihwcm9vZnMsIG51dHphcC5wcm9vZnMpKTtcbiAgICAgICAgdGhpcy51cGRhdGVOdXR6YXBTdGF0ZShudXR6YXAuaWQsIHtcbiAgICAgICAgICBzdGF0dXM6IE5ka051dHphcFN0YXR1cy5SRURFRU1FRCxcbiAgICAgICAgICByZWRlZW1lZEFtb3VudDogbnV0emFwVG90YWxBbW91bnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIlxcdTI3NEMgRmFpbGVkIHRvIHJlZGVlbSBudXR6YXBzXCIsIGUubWVzc2FnZSk7XG4gICAgICBpZiAoZS5tZXNzYWdlPy5pbmNsdWRlcyhcInVua25vd24gcHVibGljIGtleSBzaXplXCIpKSB7XG4gICAgICAgIGZvciAoY29uc3QgbnV0emFwIG9mIG51dHphcHMpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZU51dHphcFN0YXRlKG51dHphcC5pZCwge1xuICAgICAgICAgICAgc3RhdHVzOiBOZGtOdXR6YXBTdGF0dXMuUEVSTUFORU5UX0VSUk9SLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiBcIkludmFsaWQgcDJwazogdW5rbm93biBwdWJsaWMga2V5IHNpemVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZW1pdChcImZhaWxlZFwiLCBudXR6YXAsIFwiSW52YWxpZCBwMnBrOiB1bmtub3duIHB1YmxpYyBrZXkgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBudXR6YXAgb2YgbnV0emFwcykge1xuICAgICAgICAgIHRoaXMuZW1pdChcImZhaWxlZFwiLCBudXR6YXAsIGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2hvdWxkVHJ5UmVkZWVtKG51dHphcCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5udXR6YXBTdGF0ZXMuZ2V0KG51dHphcC5pZCk7XG4gICAgaWYgKCFzdGF0ZSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKFtOZGtOdXR6YXBTdGF0dXMuSU5JVElBTF0uaW5jbHVkZXMoc3RhdGUuc3RhdHVzKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gTmRrTnV0emFwU3RhdHVzLk1JU1NJTkdfUFJJVktFWSkge1xuICAgICAgY29uc3QgcDJwayA9IHN0YXRlLm51dHphcD8ucDJwaztcbiAgICAgIGlmIChwMnBrICYmIHRoaXMucHJpdmtleXMuaGFzKHAycGspKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKFtOZGtOdXR6YXBTdGF0dXMuU1BFTlQsIE5ka051dHphcFN0YXR1cy5SRURFRU1FRF0uaW5jbHVkZXMoc3RhdGUuc3RhdHVzKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChbTmRrTnV0emFwU3RhdHVzLlBFUk1BTkVOVF9FUlJPUiwgTmRrTnV0emFwU3RhdHVzLklOVkFMSURfTlVUWkFQXS5pbmNsdWRlcyhzdGF0ZS5zdGF0dXMpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBQcm9jZXNzIG51dHphcHMgZnJvbSB0aGUgc3RvcmUgdGhhdCBhcmUgaW4gYSByZWRlZW1hYmxlIHN0YXRlLlxuICAgKiBUaGlzIGluY2x1ZGVzIG51dHphcHMgaW4gSU5JVElBTCBzdGF0ZSBhbmQgdGhvc2UgaW4gTUlTU0lOR19QUklWS0VZIHN0YXRlXG4gICAqIGZvciB3aGljaCB3ZSBub3cgaGF2ZSB0aGUgcHJpdmF0ZSBrZXkuXG4gICAqL1xuICBhc3luYyBwcm9jZXNzUmVkZWVtYWJsZU51dHphcHNGcm9tU3RvcmUoKSB7XG4gICAgY29uc3QgcmVkZWVtYWJsZU51dHphcHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtfaWQsIHN0YXRlXSBvZiB0aGlzLm51dHphcFN0YXRlcy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmICghc3RhdGUubnV0emFwKSBjb250aW51ZTtcbiAgICAgIGlmICh0aGlzLnNob3VsZFRyeVJlZGVlbShzdGF0ZS5udXR6YXApKSB7XG4gICAgICAgIHJlZGVlbWFibGVOdXR6YXBzLnB1c2goc3RhdGUubnV0emFwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlZGVlbWFibGVOdXR6YXBzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGxvZzIoYFdlIGZvdW5kICR7cmVkZWVtYWJsZU51dHphcHMubGVuZ3RofSByZWRlZW1hYmxlIG51dHphcHMgaW4gdGhlIHN0b3JlYCk7XG4gICAgYXdhaXQgdGhpcy5wcm9jZXNzTnV0emFwcyhyZWRlZW1hYmxlTnV0emFwcyk7XG4gIH1cbiAgLyoqXG4gICAqIENvbW1vbiBtZXRob2QgdG8gcHJvY2VzcyBhIGNvbGxlY3Rpb24gb2YgbnV0emFwczpcbiAgICogLSBHcm91cCB0aGVtIGJ5IG1pbnRcbiAgICogLSBDaGVjayBhbmQgcmVkZWVtIGVhY2ggZ3JvdXBcbiAgICpcbiAgICogQHBhcmFtIG51dHphcHMgVGhlIG51dHphcHMgdG8gcHJvY2Vzc1xuICAgKiBAcGFyYW0gb2xkZXN0VW5zcGVudE51dHphcFRpbWUgT3B0aW9uYWwgdGltZXN0YW1wIHRvIHRyYWNrIHRoZSBvbGRlc3QgdW5zcGVudCBudXR6YXBcbiAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgb2xkZXN0VW5zcGVudE51dHphcFRpbWUgaWYgYW55IG51dHphcHMgd2VyZSBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIHByb2Nlc3NOdXR6YXBzKG51dHphcHMsIG9sZGVzdFVuc3BlbnROdXR6YXBUaW1lKSB7XG4gICAgY29uc3QgZ3JvdXBlZE51dHphcHMgPSBncm91cE51dHphcHMobnV0emFwcywgdGhpcyk7XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBncm91cGVkTnV0emFwcykge1xuICAgICAgbG9nMihgUHJvY2Vzc2luZyBncm91cCAke2dyb3VwLm1pbnR9IHdpdGggJHtncm91cC5udXR6YXBzLmxlbmd0aH0gbnV0emFwc2ApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5jaGVja0FuZFJlZGVlbUdyb3VwKGdyb3VwLCBvbGRlc3RVbnNwZW50TnV0emFwVGltZSk7XG4gICAgICAgIGxvZzIoYEZpbmlzaGVkIHByb2Nlc3NpbmcgZ3JvdXAgJHtncm91cC5taW50fWApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2cyKGBGYWlsZWQgdG8gcHJvY2VzcyBncm91cCAke2dyb3VwLm1pbnR9YCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFxcdTI3NEMgRmFpbGVkIHRvIHByb2Nlc3MgZ3JvdXAgJHtncm91cC5taW50fWAsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2xkZXN0VW5zcGVudE51dHphcFRpbWU7XG4gIH1cbn07XG5mdW5jdGlvbiBwcm9vZnNJbnRlcnNlY3Rpb24ocHJvb2ZzMSwgcHJvb2ZzMikge1xuICBjb25zdCBwcm9vZnMyQ3MgPSBuZXcgU2V0KHByb29mczIubWFwKChwKSA9PiBwLkMpKTtcbiAgcmV0dXJuIHByb29mczEuZmlsdGVyKChwKSA9PiBwcm9vZnMyQ3MuaGFzKHAuQykpO1xufVxuZnVuY3Rpb24gcHJvb2ZzVG90YWwocHJvb2ZzKSB7XG4gIHJldHVybiBwcm9vZnMucmVkdWNlKChhY2MsIHByb29mKSA9PiBhY2MgKyBwcm9vZi5hbW91bnQsIDApO1xufVxuXG4vLyBzcmMvd2FsbGV0cy9jYXNodS9taW50L3V0aWxzLnRzXG5pbXBvcnQgeyBOREtLaW5kIGFzIE5ES0tpbmQ2IH0gZnJvbSBcIkBub3N0ci1kZXYta2l0L25ka1wiO1xuYXN5bmMgZnVuY3Rpb24gZ2V0Q2FzaHVNaW50UmVjb21tZW5kYXRpb25zKG5kaywgZmlsdGVyKSB7XG4gIGNvbnN0IGYgPSBbXG4gICAgeyBraW5kczogW05ES0tpbmQ2LkVjYXNoTWludFJlY29tbWVuZGF0aW9uXSwgXCIja1wiOiBbXCIzODAwMlwiXSwgLi4uZmlsdGVyIHx8IHt9IH0sXG4gICAgeyBraW5kczogW05ES0tpbmQ2LkNhc2h1TWludExpc3RdLCAuLi5maWx0ZXIgfHwge30gfVxuICBdO1xuICBjb25zdCByZXMgPSB7fTtcbiAgY29uc3QgcmVjb21tZW5kYXRpb25zID0gYXdhaXQgbmRrLmZldGNoRXZlbnRzKGYpO1xuICBmb3IgKGNvbnN0IGV2ZW50IG9mIHJlY29tbWVuZGF0aW9ucykge1xuICAgIHN3aXRjaCAoZXZlbnQua2luZCkge1xuICAgICAgY2FzZSBOREtLaW5kNi5FY2FzaE1pbnRSZWNvbW1lbmRhdGlvbjpcbiAgICAgICAgZm9yIChjb25zdCB1VGFnIG9mIGV2ZW50LmdldE1hdGNoaW5nVGFncyhcInVcIikpIHtcbiAgICAgICAgICBpZiAodVRhZ1syXSAmJiB1VGFnWzJdICE9PSBcImNhc2h1XCIpIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IHVybCA9IHVUYWdbMV07XG4gICAgICAgICAgaWYgKCF1cmwpIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IGVudHJ5ID0gcmVzW3VybF0gfHwgeyBldmVudHM6IFtdLCBwdWJrZXlzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpIH07XG4gICAgICAgICAgZW50cnkuZXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgICAgIGVudHJ5LnB1YmtleXMuYWRkKGV2ZW50LnB1YmtleSk7XG4gICAgICAgICAgcmVzW3VybF0gPSBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTkRLS2luZDYuQ2FzaHVNaW50TGlzdDpcbiAgICAgICAgZm9yIChjb25zdCBtaW50VGFnIG9mIGV2ZW50LmdldE1hdGNoaW5nVGFncyhcIm1pbnRcIikpIHtcbiAgICAgICAgICBjb25zdCB1cmwgPSBtaW50VGFnWzFdO1xuICAgICAgICAgIGlmICghdXJsKSBjb250aW51ZTtcbiAgICAgICAgICBjb25zdCBlbnRyeSA9IHJlc1t1cmxdIHx8IHsgZXZlbnRzOiBbXSwgcHVia2V5czogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSB9O1xuICAgICAgICAgIGVudHJ5LmV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgICBlbnRyeS5wdWJrZXlzLmFkZChldmVudC5wdWJrZXkpO1xuICAgICAgICAgIHJlc1t1cmxdID0gZW50cnk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy93YWxsZXRzL2Nhc2h1L3dhbGxldC9taWdyYXRlLnRzXG5pbXBvcnQgeyBOREtDYXNodU1pbnRMaXN0LCBOREtLaW5kIGFzIE5ES0tpbmQ3IH0gZnJvbSBcIkBub3N0ci1kZXYta2l0L25ka1wiO1xuYXN5bmMgZnVuY3Rpb24gbWlncmF0ZUNhc2h1V2FsbGV0KG5kaykge1xuICBsZXQgbWludExpc3QgPSBhd2FpdCBnZXRNaW50TGlzdChuZGspO1xuICBjb25zdCBvbGRXYWxsZXRzID0gYXdhaXQgZ2V0T2xkV2FsbGV0cyhuZGspO1xuICBpZiAob2xkV2FsbGV0cy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgY29uc3QgcHJpdktleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBtaW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IG5ld1dhbGxldCA9IG5ldyBOREtDYXNodVdhbGxldChuZGspO1xuICBmb3IgKGNvbnN0IHdhbGxldCBvZiBvbGRXYWxsZXRzKSB7XG4gICAgY29uc3QgeyBwcml2a2V5LCBtaW50czogd2FsbGV0TWludHMgfSA9IGF3YWl0IGV4dHJhY3RJbmZvRnJvbUxlZ2FjeVdhbGxldCh3YWxsZXQpO1xuICAgIGlmIChwcml2a2V5KSB7XG4gICAgICBuZXdXYWxsZXQuYWRkUHJpdmtleShwcml2a2V5KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtaW50IG9mIHdhbGxldE1pbnRzKSBtaW50cy5hZGQobWludCk7XG4gIH1cbiAgY2xlYW51cE1pbnRzKG1pbnRzKTtcbiAgaWYgKG1pbnRMaXN0KSB7XG4gICAgY2xlYW51cE1pbnRMaXN0KG1pbnRMaXN0KTtcbiAgICBmb3IgKGNvbnN0IG1pbnQgb2YgbWludExpc3QubWludHMpIG1pbnRzLmFkZChtaW50KTtcbiAgICBtaW50TGlzdC5taW50cyA9IEFycmF5LmZyb20obWludHMpO1xuICAgIGlmICghbWludExpc3QucDJwayAmJiBwcml2S2V5cy5zaXplID4gMCkgbWludExpc3QucDJwayA9IEFycmF5LmZyb20ocHJpdktleXMua2V5cygpKVswXTtcbiAgICBhd2FpdCBtaW50TGlzdC50b05vc3RyRXZlbnQoKTtcbiAgfSBlbHNlIHtcbiAgICBtaW50TGlzdCA9IG5ldyBOREtDYXNodU1pbnRMaXN0KG5kayk7XG4gICAgbWludExpc3QubWludHMgPSBBcnJheS5mcm9tKG1pbnRzKTtcbiAgICBhd2FpdCBtaW50TGlzdC50b05vc3RyRXZlbnQoKTtcbiAgfVxuICBuZXdXYWxsZXQubWludHMgPSBBcnJheS5mcm9tKG1pbnRzKTtcbiAgYXdhaXQgbmV3V2FsbGV0LnB1Ymxpc2goKTtcbiAgbWludExpc3QucDJwayA9IGF3YWl0IG5ld1dhbGxldC5nZXRQMnBrKCk7XG4gIGF3YWl0IG1pbnRMaXN0LnB1Ymxpc2hSZXBsYWNlYWJsZSgpO1xuICBmb3IgKGNvbnN0IHdhbGxldCBvZiBvbGRXYWxsZXRzKSB7XG4gICAgd2FsbGV0LnRhZ3MgPSBbW1wiZFwiLCB3YWxsZXQuZFRhZyA/PyBcIlwiXSwgW1wiZGVsZXRlZFwiXV07XG4gICAgYXdhaXQgd2FsbGV0LnB1Ymxpc2hSZXBsYWNlYWJsZSgpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRNaW50TGlzdChuZGspIHtcbiAgY29uc3QgYWN0aXZlVXNlciA9IG5kay5hY3RpdmVVc2VyO1xuICBpZiAoIWFjdGl2ZVVzZXIpIHRocm93IG5ldyBFcnJvcihcIk5vIGFjdGl2ZSB1c2VyXCIpO1xuICBjb25zdCBtaW50TGlzdCA9IGF3YWl0IG5kay5mZXRjaEV2ZW50KHtcbiAgICBraW5kczogW05ES0tpbmQ3LkNhc2h1TWludExpc3RdLFxuICAgIGF1dGhvcnM6IFthY3RpdmVVc2VyLnB1YmtleV1cbiAgfSk7XG4gIGlmICghbWludExpc3QpIHJldHVybjtcbiAgcmV0dXJuIE5ES0Nhc2h1TWludExpc3QuZnJvbShtaW50TGlzdCk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRPbGRXYWxsZXRzKG5kaykge1xuICBjb25zdCB1c2VyID0gbmRrLmFjdGl2ZVVzZXI7XG4gIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKFwiTm8gYWN0aXZlIHVzZXJcIik7XG4gIGNvbnN0IHdhbGxldEV2ZW50cyA9IGF3YWl0IG5kay5mZXRjaEV2ZW50cyhbeyBraW5kczogW05ES0tpbmQ3LkxlZ2FjeUNhc2h1V2FsbGV0XSwgYXV0aG9yczogW3VzZXIucHVia2V5XSB9XSk7XG4gIHJldHVybiBBcnJheS5mcm9tKHdhbGxldEV2ZW50cykuZmlsdGVyKChldmVudCkgPT4gIWV2ZW50Lmhhc1RhZyhcImRlbGV0ZWRcIikpO1xufVxuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEluZm9Gcm9tTGVnYWN5V2FsbGV0KHdhbGxldCkge1xuICBjb25zdCBtaW50cyA9IFtdO1xuICBsZXQgcHJpdmtleTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcmlnQ29udGVudCA9IHdhbGxldC5jb250ZW50O1xuICAgIGF3YWl0IHdhbGxldC5kZWNyeXB0KCk7XG4gICAgY29uc3QgcHJpdlRhZ3MgPSBKU09OLnBhcnNlKHdhbGxldC5jb250ZW50KTtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiBwcml2VGFncykge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJwcml2a2V5XCIpIHByaXZrZXkgPSB0YWdbMV07XG4gICAgICBpZiAodGFnWzBdID09PSBcIm1pbnRcIikgbWludHMucHVzaCh0YWdbMV0pO1xuICAgIH1cbiAgICB3YWxsZXQuY29udGVudCA9IG9yaWdDb250ZW50O1xuICAgIHJldHVybiB7IHByaXZrZXksIG1pbnRzIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRlY3J5cHRpbmcgbGVnYWN5IHdhbGxldFwiLCBlcnJvcik7XG4gIH1cbiAgcmV0dXJuIHsgcHJpdmtleSwgbWludHMgfTtcbn1cbmZ1bmN0aW9uIGNsZWFudXBNaW50cyhtaW50cykge1xuICBmb3IgKGNvbnN0IG1pbnQgb2YgbWludHMpIGlmIChtaW50Lm1hdGNoKC90ZXN0bnV0LykpIG1pbnRzLmRlbGV0ZShtaW50KTtcbiAgcmV0dXJuIG1pbnRzO1xufVxuZnVuY3Rpb24gY2xlYW51cE1pbnRMaXN0KG1pbnRMaXN0KSB7XG4gIG1pbnRMaXN0Lm1pbnRzID0gbWludExpc3QubWludHMuZmlsdGVyKChtaW50KSA9PiAhbWludC5tYXRjaCgvdGVzdG51dC8pKTtcbn1cblxuLy8gc3JjL3dhbGxldHMvd2VibG4vaW5kZXgudHNcbmltcG9ydCB7IHJlcXVlc3RQcm92aWRlciB9IGZyb20gXCJ3ZWJsblwiO1xuXG4vLyBzcmMvd2FsbGV0cy93ZWJsbi9wYXkudHNcbmltcG9ydCB7IENhc2h1TWludCBhcyBDYXNodU1pbnQyLCBDYXNodVdhbGxldCBhcyBDYXNodVdhbGxldDIgfSBmcm9tIFwiQGNhc2h1L2Nhc2h1LXRzXCI7XG52YXIgTkRLTG5QYXkgPSBjbGFzcyB7XG4gIHdhbGxldDtcbiAgaW5mbztcbiAgdHlwZSA9IFwibG5cIjtcbiAgY29uc3RydWN0b3Iod2FsbGV0LCBpbmZvKSB7XG4gICAgdGhpcy53YWxsZXQgPSB3YWxsZXQ7XG4gICAgdGhpcy5pbmZvID0gaW5mbztcbiAgfVxuICBhc3luYyBwYXkoKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gXCJsblwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXlMbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXlOdXQoKTtcbiAgfVxuICAvKipcbiAgICogVXNlcyBMTiBiYWxhbmNlIHRvIHBheSB0byBhIG1pbnRcbiAgICovXG4gIGFzeW5jIHBheU51dCgpIHtcbiAgICBjb25zdCB7IG1pbnRzLCBwMnBrIH0gPSB0aGlzLmluZm87XG4gICAgbGV0IHsgYW1vdW50LCB1bml0IH0gPSB0aGlzLmluZm87XG4gICAgaWYgKCFtaW50cykgdGhyb3cgbmV3IEVycm9yKFwiTm8gbWludHMgcHJvdmlkZWRcIik7XG4gICAgaWYgKHVuaXQgPT09IFwibXNhdFwiKSB7XG4gICAgICBhbW91bnQgLz0gMWUzO1xuICAgICAgdW5pdCA9IFwic2F0XCI7XG4gICAgfVxuICAgIGNvbnN0IHF1b3Rlc1Byb21pc2VzID0gbWludHMubWFwKGFzeW5jIChtaW50MikgPT4ge1xuICAgICAgY29uc3Qgd2FsbGV0MiA9IG5ldyBDYXNodVdhbGxldDIobmV3IENhc2h1TWludDIobWludDIpLCB7IHVuaXQgfSk7XG4gICAgICBjb25zdCBxdW90ZTIgPSBhd2FpdCB3YWxsZXQyLmNyZWF0ZU1pbnRRdW90ZShhbW91bnQpO1xuICAgICAgcmV0dXJuIHsgcXVvdGU6IHF1b3RlMiwgbWludDogbWludDIgfTtcbiAgICB9KTtcbiAgICBjb25zdCB7IHF1b3RlLCBtaW50IH0gPSBhd2FpdCBQcm9taXNlLmFueShxdW90ZXNQcm9taXNlcyk7XG4gICAgaWYgKCFxdW90ZSkge1xuICAgICAgY29uc29sZS53YXJuKFwiZmFpbGVkIHRvIGdldCBxdW90ZSBmcm9tIGFueSBtaW50XCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmFpbGVkIHRvIGdldCBxdW90ZSBmcm9tIGFueSBtaW50XCIpO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLndhbGxldC5wYXkoeyBwcjogcXVvdGUucmVxdWVzdCB9KTtcbiAgICBpZiAoIXJlcykge1xuICAgICAgY29uc29sZS53YXJuKFwicGF5bWVudCBmYWlsZWRcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXltZW50IGZhaWxlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgd2FsbGV0ID0gbmV3IENhc2h1V2FsbGV0MihuZXcgQ2FzaHVNaW50MihtaW50KSwgeyB1bml0IH0pO1xuICAgIGNvbnN0IHByb29mcyA9IGF3YWl0IHdhbGxldC5taW50UHJvb2ZzKGFtb3VudCwgcXVvdGUucXVvdGUsIHtcbiAgICAgIHB1YmtleTogcDJwa1xuICAgIH0pO1xuICAgIGNvbnNvbGUud2FybihcIm1pbnRlZCB0b2tlbnMgd2l0aCBwcm9vZnMgJW9cIiwgcHJvb2ZzKTtcbiAgICByZXR1cm4geyBwcm9vZnMsIG1pbnQgfTtcbiAgfVxuICAvKipcbiAgICogU3RyYWlnaHRmb3J3YXJkOyB1c2VzIExOIGJhbGFuY2UgdG8gcGF5IGEgTE4gaW52b2ljZVxuICAgKi9cbiAgYXN5bmMgcGF5TG4oKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuaW5mbztcbiAgICBpZiAoIWRhdGEucHIpIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgcHJcIik7XG4gICAgY29uc3QgX3BhaWQgPSBmYWxzZTtcbiAgICBjb25zdCByZXQgPSBhd2FpdCB0aGlzLndhbGxldC5wYXkoZGF0YSk7XG4gICAgcmV0dXJuIHJldCA/IHJldC5wcmVpbWFnZSA6IHZvaWQgMDtcbiAgfVxufTtcblxuLy8gc3JjL3dhbGxldHMvd2VibG4vaW5kZXgudHNcbnZhciBOREtXZWJMTldhbGxldCA9IGNsYXNzIGV4dGVuZHMgTkRLV2FsbGV0IHtcbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwid2VibG5cIjtcbiAgfVxuICB3YWxsZXRJZCA9IFwid2VibG5cIjtcbiAgc3RhdHVzID0gXCJpbml0aWFsXCIgLyogSU5JVElBTCAqLztcbiAgcHJvdmlkZXI7XG4gIF9iYWxhbmNlO1xuICBjb25zdHJ1Y3RvcihuZGspIHtcbiAgICBzdXBlcihuZGspO1xuICAgIHJlcXVlc3RQcm92aWRlcigpLnRoZW4oKHApID0+IHtcbiAgICAgIGlmIChwKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IFwicmVhZHlcIiAvKiBSRUFEWSAqLztcbiAgICAgICAgdGhpcy5lbWl0KFwicmVhZHlcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IFwiZmFpbGVkXCIgLyogRkFJTEVEICovO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKCgpID0+IHRoaXMuc3RhdHVzID0gXCJmYWlsZWRcIiAvKiBGQUlMRUQgKi8pO1xuICB9XG4gIGFzeW5jIHBheShwYXltZW50KSB7XG4gICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBub3QgcmVhZHlcIik7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZFBheW1lbnQocGF5bWVudC5wcik7XG4gIH1cbiAgYXN5bmMgbG5QYXkocGF5bWVudCkge1xuICAgIGNvbnN0IHBheSA9IG5ldyBOREtMblBheSh0aGlzLCBwYXltZW50KTtcbiAgICBjb25zdCBwcmVpbWFnZSA9IGF3YWl0IHBheS5wYXlMbigpO1xuICAgIGlmICghcHJlaW1hZ2UpIHJldHVybjtcbiAgICByZXR1cm4geyBwcmVpbWFnZSB9O1xuICB9XG4gIGFzeW5jIGNhc2h1UGF5KHBheW1lbnQpIHtcbiAgICBjb25zdCBwYXkgPSBuZXcgTkRLTG5QYXkodGhpcywgcGF5bWVudCk7XG4gICAgcmV0dXJuIHBheS5wYXlOdXQoKTtcbiAgfVxuICBhc3luYyB1cGRhdGVCYWxhbmNlKCkge1xuICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHRoaXMub25jZShcInJlYWR5XCIsICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGIgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJhbGFuY2U/LigpO1xuICAgIGlmIChiKSB0aGlzLl9iYWxhbmNlID0geyBhbW91bnQ6IGIuYmFsYW5jZSB9O1xuICAgIHJldHVybjtcbiAgfVxuICBnZXQgYmFsYW5jZSgpIHtcbiAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9iYWxhbmNlO1xuICB9XG59O1xuXG4vLyBzcmMvd2FsbGV0cy9ud2MvaW5kZXgudHNcbmltcG9ydCB7IENhc2h1TWludCBhcyBDYXNodU1pbnQzLCBDYXNodVdhbGxldCBhcyBDYXNodVdhbGxldDMgfSBmcm9tIFwiQGNhc2h1L2Nhc2h1LXRzXCI7XG5pbXBvcnQge1xuICBOREtQb29sLFxuICBOREtQcml2YXRlS2V5U2lnbmVyIGFzIE5ES1ByaXZhdGVLZXlTaWduZXIzLFxuICBOREtSZWxheVNldFxufSBmcm9tIFwiQG5vc3RyLWRldi1raXQvbmRrXCI7XG5pbXBvcnQgY3JlYXRlRGVidWczIGZyb20gXCJkZWJ1Z1wiO1xuXG4vLyBzcmMvd2FsbGV0cy9ud2MvbnV0emFwLnRzXG5pbXBvcnQgeyBOREtDYXNodVRva2VuIGFzIE5ES0Nhc2h1VG9rZW4zIH0gZnJvbSBcIkBub3N0ci1kZXYta2l0L25ka1wiO1xuYXN5bmMgZnVuY3Rpb24gcmVkZWVtTnV0emFwcyhudXR6YXBzLCBwcml2a2V5LCB7IGNhc2h1V2FsbGV0LCBwcm9vZnMsIG1pbnQgfSkge1xuICBwcm9vZnMgPz89IG51dHphcHMuZmxhdE1hcCgobikgPT4gbi5wcm9vZnMpO1xuICBpZiAoIWNhc2h1V2FsbGV0KSB7XG4gICAgaWYgKCFtaW50KSB0aHJvdyBuZXcgRXJyb3IoXCJObyBtaW50IHByb3ZpZGVkXCIpO1xuICAgIGNhc2h1V2FsbGV0ID0gYXdhaXQgdGhpcy5nZXRDYXNodVdhbGxldChtaW50KTtcbiAgfSBlbHNlIHtcbiAgICBtaW50ID0gY2FzaHVXYWxsZXQubWludC5taW50VXJsO1xuICB9XG4gIGNvbnN0IGluZm8gPSBhd2FpdCB0aGlzLmdldEluZm8oKTtcbiAgaWYgKCFpbmZvLm1ldGhvZHMuaW5jbHVkZXMoXCJtYWtlX2ludm9pY2VcIikpIHRocm93IG5ldyBFcnJvcihcIlRoaXMgTldDIHdhbGxldCBkb2VzIG5vdCBzdXBwb3J0IG1ha2luZyBpbnZvaWNlc1wiKTtcbiAgY29uc3QgdG90YWxBdmFpbGFibGUgPSBwcm9vZnMucmVkdWNlKChhY2MsIHByb29mKSA9PiBhY2MgKyBwcm9vZi5hbW91bnQsIDApO1xuICBsZXQgc3dlZXBBbW91bnQgPSB0b3RhbEF2YWlsYWJsZTtcbiAgd2hpbGUgKHN3ZWVwQW1vdW50ID4gMCkge1xuICAgIGNvbnN0IGludm9pY2UgPSBhd2FpdCB0aGlzLm1ha2VJbnZvaWNlKHN3ZWVwQW1vdW50ICogMWUzLCBcIk51dHphcCByZWRlbXB0aW9uXCIpO1xuICAgIGNvbnN0IG1lbHRRdW90ZSA9IGF3YWl0IGNhc2h1V2FsbGV0LmNyZWF0ZU1lbHRRdW90ZShpbnZvaWNlLmludm9pY2UpO1xuICAgIGNvbnN0IHRvdGFsUmVxdWlyZWQgPSBtZWx0UXVvdGUuYW1vdW50ICsgbWVsdFF1b3RlLmZlZV9yZXNlcnZlO1xuICAgIGlmICh0b3RhbFJlcXVpcmVkID4gdG90YWxBdmFpbGFibGUpIHtcbiAgICAgIHN3ZWVwQW1vdW50IC09IG1lbHRRdW90ZS5mZWVfcmVzZXJ2ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYXNodVdhbGxldC5tZWx0UHJvb2ZzKG1lbHRRdW90ZSwgcHJvb2ZzLCB7IHByaXZrZXkgfSk7XG4gICAgbGV0IGNoYW5nZTtcbiAgICBpZiAocmVzdWx0LmNoYW5nZS5sZW5ndGggPiAwKSBjaGFuZ2UgPSBhd2FpdCBzYXZlQ2hhbmdlKHRoaXMubmRrLCBtaW50LCByZXN1bHQuY2hhbmdlKTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGBOdXR6YXAgcmVkZW1wdGlvbiB0byBleHRlcm5hbCB3YWxsZXQgKCR7dGhpcy53YWxsZXRJZH0pYDtcbiAgICBjcmVhdGVPdXRUeEV2ZW50KFxuICAgICAgdGhpcy5uZGssXG4gICAgICB7XG4gICAgICAgIHByOiBpbnZvaWNlLmludm9pY2UsXG4gICAgICAgIHBheW1lbnREZXNjcmlwdGlvbjogZGVzY3JpcHRpb25cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHJlc3VsdDogeyBwcmVpbWFnZTogaW52b2ljZS5wcmVpbWFnZSB9LFxuICAgICAgICBtaW50LFxuICAgICAgICBmZWU6IG1lbHRRdW90ZS5mZWVfcmVzZXJ2ZSxcbiAgICAgICAgcHJvb2ZzQ2hhbmdlOiB7IHN0b3JlOiBjaGFuZ2U/LnByb29mcywgbWludCB9LFxuICAgICAgICBzdGF0ZVVwZGF0ZToge1xuICAgICAgICAgIGNyZWF0ZWQ6IGNoYW5nZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdGhpcy5yZWxheVNldCxcbiAgICAgIHsgbnV0emFwcyB9XG4gICAgKTtcbiAgICByZXR1cm4gc3dlZXBBbW91bnQ7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHJlZGVlbSBudXR6YXBzXCIpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2F2ZUNoYW5nZShuZGssIG1pbnQsIGNoYW5nZSkge1xuICBjb25zdCB0b3RhbENoYW5nZSA9IGNoYW5nZS5yZWR1Y2UoKGFjYywgcHJvb2YpID0+IGFjYyArIHByb29mLmFtb3VudCwgMCk7XG4gIGlmICh0b3RhbENoYW5nZSA9PT0gMCkgcmV0dXJuO1xuICBjb25zdCB0b2tlbiA9IG5ldyBOREtDYXNodVRva2VuMyhuZGspO1xuICB0b2tlbi5taW50ID0gbWludDtcbiAgdG9rZW4ucHJvb2ZzID0gY2hhbmdlO1xuICB0b2tlbi5wdWJsaXNoKCk7XG4gIHJldHVybiB0b2tlbjtcbn1cblxuLy8gc3JjL3dhbGxldHMvbndjL3JlcS50c1xuaW1wb3J0IHsgTkRLRXZlbnQgYXMgTkRLRXZlbnQ0LCBOREtLaW5kIGFzIE5ES0tpbmQ5IH0gZnJvbSBcIkBub3N0ci1kZXYta2l0L25ka1wiO1xuXG4vLyBzcmMvd2FsbGV0cy9ud2MvcmVzLnRzXG5pbXBvcnQgeyBOREtLaW5kIGFzIE5ES0tpbmQ4IH0gZnJvbSBcIkBub3N0ci1kZXYta2l0L25ka1wiO1xuYXN5bmMgZnVuY3Rpb24gd2FpdEZvclJlc3BvbnNlKHJlcXVlc3QpIHtcbiAgaWYgKCF0aGlzLnBvb2wpIHRocm93IG5ldyBFcnJvcihcIldhbGxldCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gIGNvbnN0IHNlbmRSZXF1ZXN0ID0gKCkgPT4ge1xuICAgIGlmICh3YWl0Rm9yRW9zZVRpbWVvdXQpIGNsZWFyVGltZW91dCh3YWl0Rm9yRW9zZVRpbWVvdXQpO1xuICAgIHJlcXVlc3QucHVibGlzaCh0aGlzLnJlbGF5U2V0KTtcbiAgfTtcbiAgY29uc3Qgd2FpdEZvckVvc2VUaW1lb3V0ID0gc2V0VGltZW91dChzZW5kUmVxdWVzdCwgMjUwMCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgc3ViID0gdGhpcy5uZGsuc3Vic2NyaWJlKFxuICAgICAge1xuICAgICAgICBraW5kczogW05ES0tpbmQ4Lk5vc3RyV2FsbGV0Q29ubmVjdFJlc10sXG4gICAgICAgIFwiI2VcIjogW3JlcXVlc3QuaWRdLFxuICAgICAgICBsaW1pdDogMVxuICAgICAgfSxcbiAgICAgIHsgZ3JvdXBhYmxlOiBmYWxzZSwgcG9vbDogdGhpcy5wb29sIH0sXG4gICAgICB0aGlzLnJlbGF5U2V0XG4gICAgKTtcbiAgICBzdWIub24oXCJldmVudFwiLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGV2ZW50LmRlY3J5cHQoZXZlbnQuYXV0aG9yLCB0aGlzLnNpZ25lcik7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBKU09OLnBhcnNlKGV2ZW50LmNvbnRlbnQpO1xuICAgICAgICBpZiAoY29udGVudC5lcnJvcikge1xuICAgICAgICAgIHJlamVjdChjb250ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJlcnJvciBkZWNyeXB0aW5nIGV2ZW50XCIsIGUpO1xuICAgICAgICByZWplY3Qoe1xuICAgICAgICAgIHJlc3VsdF90eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgIGNvZGU6IFwiZmFpbGVkX3RvX3BhcnNlX3Jlc3BvbnNlXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlLm1lc3NhZ2VcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc3ViLnN0b3AoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBzdWIub24oXCJlb3NlXCIsICgpID0+IHtcbiAgICAgIHNlbmRSZXF1ZXN0KCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyBzcmMvd2FsbGV0cy9ud2MvcmVxLnRzXG5hc3luYyBmdW5jdGlvbiBzZW5kUmVxKG1ldGhvZCwgcGFyYW1zKSB7XG4gIGlmICghdGhpcy53YWxsZXRTZXJ2aWNlIHx8ICF0aGlzLnNpZ25lcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIldhbGxldCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gIH1cbiAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQ0KHRoaXMubmRrLCB7XG4gICAga2luZDogTkRLS2luZDkuTm9zdHJXYWxsZXRDb25uZWN0UmVxLFxuICAgIHRhZ3M6IFtbXCJwXCIsIHRoaXMud2FsbGV0U2VydmljZS5wdWJrZXldXSxcbiAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeSh7IG1ldGhvZCwgcGFyYW1zIH0pXG4gIH0pO1xuICBhd2FpdCBldmVudC5lbmNyeXB0KHRoaXMud2FsbGV0U2VydmljZSwgdGhpcy5zaWduZXIsIFwibmlwMDRcIik7XG4gIGF3YWl0IGV2ZW50LnNpZ24odGhpcy5zaWduZXIpO1xuICBjb25zdCByZXNwb25zZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgd2FpdEZvclJlc3BvbnNlLmNhbGwodGhpcywgZXZlbnQpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgfSk7XG4gIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKFxuICAgICAgKF8sIHJlamVjdCkgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChcInRpbWVvdXRcIiwgbWV0aG9kKTtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgUmVxdWVzdCB0aW1lZCBvdXQgYWZ0ZXIgJHt0aGlzLnRpbWVvdXR9bXNgKSk7XG4gICAgICB9LCB0aGlzLnRpbWVvdXQpXG4gICAgKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtyZXNwb25zZVByb21pc2UsIHRpbWVvdXRQcm9taXNlXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlUHJvbWlzZTtcbn1cblxuLy8gc3JjL3dhbGxldHMvbndjL2luZGV4LnRzXG52YXIgZDMgPSBjcmVhdGVEZWJ1ZzMoXCJuZGstd2FsbGV0Om53Y1wiKTtcbnZhciBOREtOV0NXYWxsZXQgPSBjbGFzcyBleHRlbmRzIE5ES1dhbGxldCB7XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcIm53Y1wiO1xuICB9XG4gIHN0YXR1cyA9IFwiaW5pdGlhbFwiIC8qIElOSVRJQUwgKi87XG4gIHdhbGxldElkID0gXCJud2NcIjtcbiAgcGFpcmluZ0NvZGU7XG4gIHdhbGxldFNlcnZpY2U7XG4gIHJlbGF5U2V0O1xuICBzaWduZXI7XG4gIF9iYWxhbmNlO1xuICBjYWNoZWRJbmZvO1xuICBwb29sO1xuICB0aW1lb3V0O1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG5ka1xuICAgKiBAcGFyYW0gdGltZW91dCBBIHRpbWVlb3V0IHRvIHVzZSBmb3IgYWxsIG9wZXJhdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuZGssIHtcbiAgICB0aW1lb3V0LFxuICAgIHBhaXJpbmdDb2RlLFxuICAgIHB1YmtleSxcbiAgICByZWxheVVybHMsXG4gICAgc2VjcmV0XG4gIH0pIHtcbiAgICBzdXBlcihuZGspO1xuICAgIGlmIChwYWlyaW5nQ29kZSkge1xuICAgICAgY29uc3QgdSA9IG5ldyBVUkwocGFpcmluZ0NvZGUpO1xuICAgICAgcHVia2V5ID0gdS5ob3N0ID8/IHUucGF0aG5hbWU7XG4gICAgICByZWxheVVybHMgPSB1LnNlYXJjaFBhcmFtcy5nZXRBbGwoXCJyZWxheVwiKTtcbiAgICAgIHNlY3JldCA9IHUuc2VhcmNoUGFyYW1zLmdldChcInNlY3JldFwiKTtcbiAgICAgIHRoaXMucGFpcmluZ0NvZGUgPSBwYWlyaW5nQ29kZTtcbiAgICB9XG4gICAgaWYgKCFwdWJrZXkgfHwgIXJlbGF5VXJscyB8fCAhc2VjcmV0KSB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvbXBsZXRlIGluaXRpYWxpemF0aW9uIHBhcmFtZXRlcnNcIik7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICB0aGlzLndhbGxldFNlcnZpY2UgPSB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5IH0pO1xuICAgIHRoaXMucG9vbCA9IHRoaXMuZ2V0UG9vbChyZWxheVVybHMpO1xuICAgIHRoaXMucmVsYXlTZXQgPSBOREtSZWxheVNldC5mcm9tUmVsYXlVcmxzKHJlbGF5VXJscywgdGhpcy5uZGssIHRydWUsIHRoaXMucG9vbCk7XG4gICAgdGhpcy5zaWduZXIgPSBuZXcgTkRLUHJpdmF0ZUtleVNpZ25lcjMoc2VjcmV0KTtcbiAgICB0aGlzLnBvb2wub24oXCJjb25uZWN0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuc3RhdHVzID0gXCJyZWFkeVwiIC8qIFJFQURZICovO1xuICAgICAgdGhpcy5lbWl0KFwicmVhZHlcIik7XG4gICAgfSk7XG4gICAgdGhpcy5wb29sLm9uKFwicmVsYXk6ZGlzY29ubmVjdFwiLCAoKSA9PiB0aGlzLnN0YXR1cyA9IFwibG9hZGluZ1wiIC8qIExPQURJTkcgKi8pO1xuICAgIHRoaXMucG9vbC5jb25uZWN0KCk7XG4gICAgaWYgKHRoaXMucG9vbC5jb25uZWN0ZWRSZWxheXMoKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IFwicmVhZHlcIiAvKiBSRUFEWSAqLztcbiAgICAgIHRoaXMuZW1pdChcInJlYWR5XCIpO1xuICAgIH1cbiAgfVxuICBnZXRQb29sKHJlbGF5VXJscykge1xuICAgIGZvciAoY29uc3QgcG9vbCBvZiB0aGlzLm5kay5wb29scykgaWYgKHBvb2wubmFtZSA9PT0gXCJOV0NcIikgcmV0dXJuIHBvb2w7XG4gICAgcmV0dXJuIG5ldyBOREtQb29sKHJlbGF5VXJscywgW10sIHRoaXMubmRrLCB7IG5hbWU6IFwiTldDXCIgfSk7XG4gIH1cbiAgYXN5bmMgbG5QYXkocGF5bWVudCkge1xuICAgIGlmICghdGhpcy5zaWduZXIpIHRocm93IG5ldyBFcnJvcihcIldhbGxldCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgZDMoXCJsblBheVwiLCBwYXltZW50LnByKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnJlcShcInBheV9pbnZvaWNlXCIsIHsgaW52b2ljZTogcGF5bWVudC5wciB9KTtcbiAgICBkMyhcImxuUGF5IHJlc1wiLCByZXMpO1xuICAgIGlmIChyZXMucmVzdWx0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmVpbWFnZTogcmVzLnJlc3VsdC5wcmVpbWFnZVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVCYWxhbmNlKCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKHJlcy5lcnJvcj8ubWVzc2FnZSB8fCBcIlBheW1lbnQgZmFpbGVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBQYXkgYnkgbWludGluZyB0b2tlbnMuXG4gICAqXG4gICAqIFRoaXMgY3JlYXRlcyBhIHF1b3RlIG9uIGEgbWludCwgcGF5cyBpdCB1c2luZyBOV0MgYW5kIHRoZW4gbWludHMgdGhlIHRva2Vucy5cbiAgICpcbiAgICogQHBhcmFtIHBheW1lbnQgLSBUaGUgcGF5bWVudCB0byBwYXlcbiAgICogQHBhcmFtIG9uTG5QYXltZW50IC0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIGFuIExOIHBheW1lbnQgd2lsbCBiZSBwcm9jZXNzZWRcbiAgICogQHJldHVybnMgVGhlIHBheW1lbnQgY29uZmlybWF0aW9uXG4gICAqL1xuICBhc3luYyBjYXNodVBheShwYXltZW50LCBvbkxuSW52b2ljZSwgb25MblBheW1lbnQpIHtcbiAgICBpZiAoIXBheW1lbnQubWludHMpIHRocm93IG5ldyBFcnJvcihcIk5vIG1pbnRzIHByb3ZpZGVkXCIpO1xuICAgIGZvciAoY29uc3QgbWludCBvZiBwYXltZW50Lm1pbnRzKSB7XG4gICAgICBsZXQgYW1vdW50ID0gcGF5bWVudC5hbW91bnQ7XG4gICAgICBhbW91bnQgPSBhbW91bnQgLyAxZTM7XG4gICAgICBjb25zdCB3YWxsZXQgPSBuZXcgQ2FzaHVXYWxsZXQzKG5ldyBDYXNodU1pbnQzKG1pbnQpLCB7IHVuaXQ6IFwic2F0XCIgfSk7XG4gICAgICBsZXQgcXVvdGU7XG4gICAgICB0cnkge1xuICAgICAgICBxdW90ZSA9IGF3YWl0IHdhbGxldC5jcmVhdGVNaW50UXVvdGUoYW1vdW50KTtcbiAgICAgICAgZDMoXCJjYXNodVBheSBxdW90ZVwiLCBxdW90ZSk7XG4gICAgICAgIG9uTG5JbnZvaWNlPy4ocXVvdGUucmVxdWVzdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJlcnJvciBjcmVhdGluZyBtaW50IHF1b3RlXCIsIGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgaWYgKCFxdW90ZSkgdGhyb3cgbmV3IEVycm9yKFwiRGlkbnQgcmVjZWl2ZSBhIG1pbnQgcXVvdGVcIik7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnJlcShcInBheV9pbnZvaWNlXCIsIHsgaW52b2ljZTogcXVvdGUucmVxdWVzdCB9KTtcbiAgICAgICAgaWYgKHJlcy5yZXN1bHQ/LnByZWltYWdlKSB7XG4gICAgICAgICAgb25MblBheW1lbnQ/LihtaW50LCByZXMucmVzdWx0LnByZWltYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBkMyhcImNhc2h1UGF5IHJlc1wiLCByZXMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZT8uZXJyb3I/Lm1lc3NhZ2UgfHwgZT8ubWVzc2FnZSB8fCBcInVua25vd24gZXJyb3JcIjtcbiAgICAgICAgY29uc29sZS5lcnJvcihcImVycm9yIHBheWluZyBpbnZvaWNlXCIsIGUsIHsgbWVzc2FnZSB9KTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVCYWxhbmNlKCk7XG4gICAgICByZXR1cm4gbWludFByb29mcyh3YWxsZXQsIHF1b3RlLCBhbW91bnQsIG1pbnQsIHBheW1lbnQucDJwayk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZWRlZW0gYSBzZXQgb2YgbnV0emFwcyBpbnRvIGFuIE5XQyB3YWxsZXQuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gZ2V0cyBhbiBpbnZvaWNlIGZyb20gdGhlIE5XQyB3YWxsZXQgdW50aWwgdGhlIHRvdGFsIGFtb3VudCBvZiB0aGUgbnV0emFwcyBpcyBlbm91Z2ggdG8gcGF5IGZvciB0aGUgaW52b2ljZVxuICAgKiB3aGVuIGFjY291bnRpbmcgZm9yIGZlZXMuXG4gICAqXG4gICAqIEBwYXJhbSBjYXNodVdhbGxldCAtIFRoZSBjYXNodSB3YWxsZXQgdG8gcmVkZWVtIHRoZSBudXR6YXBzIGludG9cbiAgICogQHBhcmFtIG51dHphcHMgLSBUaGUgbnV0emFwcyB0byByZWRlZW1cbiAgICogQHBhcmFtIHByb29mcyAtIFRoZSBwcm9vZnMgdG8gcmVkZWVtXG4gICAqIEBwYXJhbSBtaW50IC0gVGhlIG1pbnQgdG8gcmVkZWVtIHRoZSBudXR6YXBzIGludG9cbiAgICogQHBhcmFtIHByaXZrZXkgLSBUaGUgcHJpdmF0ZSBrZXkgbmVlZGVkIHRvIHJlZGVlbSBwMnBrIHByb29mcy5cbiAgICovXG4gIHJlZGVlbU51dHphcHMgPSByZWRlZW1OdXR6YXBzLmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgYmFsYW5jZSBvZiB0aGlzIHdhbGxldFxuICAgKi9cbiAgYXN5bmMgdXBkYXRlQmFsYW5jZSgpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnJlcShcImdldF9iYWxhbmNlXCIsIHt9KTtcbiAgICBpZiAoIXJlcy5yZXN1bHQpIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgYmFsYW5jZVwiKTtcbiAgICBpZiAocmVzLmVycm9yKSB0aHJvdyBuZXcgRXJyb3IocmVzLmVycm9yLm1lc3NhZ2UpO1xuICAgIHRoaXMuX2JhbGFuY2UgPSB7XG4gICAgICBhbW91bnQ6IHJlcy5yZXN1bHQ/LmJhbGFuY2UgPz8gMFxuICAgIH07XG4gICAgdGhpcy5fYmFsYW5jZS5hbW91bnQgLz0gMWUzO1xuICAgIHRoaXMuZW1pdChcImJhbGFuY2VfdXBkYXRlZFwiKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBiYWxhbmNlIG9mIHRoaXMgd2FsbGV0XG4gICAqL1xuICBnZXQgYmFsYW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFsYW5jZTtcbiAgfVxuICByZXEgPSBzZW5kUmVxLmJpbmQodGhpcyk7XG4gIGFzeW5jIGdldEluZm8ocmVmZXRjaCA9IGZhbHNlKSB7XG4gICAgaWYgKHJlZmV0Y2gpIHtcbiAgICAgIHRoaXMuY2FjaGVkSW5mbyA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2FjaGVkSW5mbykgcmV0dXJuIHRoaXMuY2FjaGVkSW5mbztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnJlcShcImdldF9pbmZvXCIsIHt9KTtcbiAgICBkMyhcImluZm9cIiwgcmVzKTtcbiAgICBpZiAoIXJlcy5yZXN1bHQpIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgaW5mb1wiKTtcbiAgICBpZiAocmVzLmVycm9yKSB0aHJvdyBuZXcgRXJyb3IocmVzLmVycm9yLm1lc3NhZ2UpO1xuICAgIHRoaXMuY2FjaGVkSW5mbyA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKHJlcy5yZXN1bHQuYWxpYXMpIHRoaXMud2FsbGV0SWQgPSByZXMucmVzdWx0LmFsaWFzO1xuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG4gIGFzeW5jIGxpc3RUcmFuc2FjdGlvbnMoKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5yZXEoXCJsaXN0X3RyYW5zYWN0aW9uc1wiLCB7fSk7XG4gICAgaWYgKCFyZXMucmVzdWx0KSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbGlzdCB0cmFuc2FjdGlvbnNcIik7XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cbiAgYXN5bmMgbWFrZUludm9pY2UoYW1vdW50LCBkZXNjcmlwdGlvbikge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucmVxKFwibWFrZV9pbnZvaWNlXCIsIHsgYW1vdW50LCBkZXNjcmlwdGlvbiB9KTtcbiAgICBpZiAoIXJlcy5yZXN1bHQpIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBtYWtlIGludm9pY2VcIik7XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cbn07XG5leHBvcnQge1xuICBOREtDYXNodURlcG9zaXQsXG4gIE5ES0Nhc2h1V2FsbGV0LFxuICBOREtDYXNodVdhbGxldEJhY2t1cCxcbiAgTkRLTldDV2FsbGV0LFxuICBOREtOdXR6YXBNb25pdG9yLFxuICBOREtXYWxsZXQsXG4gIE5ES1dhbGxldFN0YXR1cyxcbiAgTkRLV2ViTE5XYWxsZXQsXG4gIFdhbGxldFN0YXRlLFxuICBjYWxjdWxhdGVOZXdTdGF0ZSxcbiAgY29uc29saWRhdGVNaW50VG9rZW5zLFxuICBjb25zb2xpZGF0ZVRva2VucyxcbiAgZ2V0Qm9sdDExQW1vdW50LFxuICBnZXRCb2x0MTFEZXNjcmlwdGlvbixcbiAgZ2V0Qm9sdDExRXhwaXJlc0F0LFxuICBnZXRDYXNodU1pbnRSZWNvbW1lbmRhdGlvbnMsXG4gIG1pZ3JhdGVDYXNodVdhbGxldCxcbiAgdXBkYXRlXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-wallet/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-wallet/node_modules/@nostr-dev-kit/ndk/dist/index.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-wallet/node_modules/@nostr-dev-kit/ndk/dist/index.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BECH32_REGEX: () => (/* binding */ BECH32_REGEX),\n/* harmony export */   NDKAppHandlerEvent: () => (/* binding */ NDKAppHandlerEvent),\n/* harmony export */   NDKAppSettings: () => (/* binding */ NDKAppSettings),\n/* harmony export */   NDKArticle: () => (/* binding */ NDKArticle),\n/* harmony export */   NDKCashuMintList: () => (/* binding */ NDKCashuMintList),\n/* harmony export */   NDKCashuToken: () => (/* binding */ NDKCashuToken),\n/* harmony export */   NDKCashuWalletTx: () => (/* binding */ NDKCashuWalletTx),\n/* harmony export */   NDKClassified: () => (/* binding */ NDKClassified),\n/* harmony export */   NDKDVMJobFeedback: () => (/* binding */ NDKDVMJobFeedback),\n/* harmony export */   NDKDVMJobResult: () => (/* binding */ NDKDVMJobResult),\n/* harmony export */   NDKDVMRequest: () => (/* binding */ NDKDVMRequest),\n/* harmony export */   NDKDraft: () => (/* binding */ NDKDraft),\n/* harmony export */   NDKDvmJobFeedbackStatus: () => (/* binding */ NDKDvmJobFeedbackStatus),\n/* harmony export */   NDKEvent: () => (/* binding */ NDKEvent),\n/* harmony export */   NDKHighlight: () => (/* binding */ NDKHighlight),\n/* harmony export */   NDKImage: () => (/* binding */ NDKImage),\n/* harmony export */   NDKKind: () => (/* binding */ NDKKind),\n/* harmony export */   NDKList: () => (/* binding */ NDKList),\n/* harmony export */   NDKListKinds: () => (/* binding */ NDKListKinds),\n/* harmony export */   NDKNip07Signer: () => (/* binding */ NDKNip07Signer),\n/* harmony export */   NDKNip46Backend: () => (/* binding */ NDKNip46Backend),\n/* harmony export */   NDKNip46Signer: () => (/* binding */ NDKNip46Signer),\n/* harmony export */   NDKNostrRpc: () => (/* binding */ NDKNostrRpc),\n/* harmony export */   NDKNutzap: () => (/* binding */ NDKNutzap),\n/* harmony export */   NDKPool: () => (/* binding */ NDKPool),\n/* harmony export */   NDKPrivateKeySigner: () => (/* binding */ NDKPrivateKeySigner),\n/* harmony export */   NDKPublishError: () => (/* binding */ NDKPublishError),\n/* harmony export */   NDKRelay: () => (/* binding */ NDKRelay),\n/* harmony export */   NDKRelayAuthPolicies: () => (/* binding */ NDKRelayAuthPolicies),\n/* harmony export */   NDKRelayList: () => (/* binding */ NDKRelayList),\n/* harmony export */   NDKRelaySet: () => (/* binding */ NDKRelaySet),\n/* harmony export */   NDKRelayStatus: () => (/* binding */ NDKRelayStatus),\n/* harmony export */   NDKRepost: () => (/* binding */ NDKRepost),\n/* harmony export */   NDKSimpleGroup: () => (/* binding */ NDKSimpleGroup),\n/* harmony export */   NDKSimpleGroupMemberList: () => (/* binding */ NDKSimpleGroupMemberList),\n/* harmony export */   NDKSimpleGroupMetadata: () => (/* binding */ NDKSimpleGroupMetadata),\n/* harmony export */   NDKStory: () => (/* binding */ NDKStory),\n/* harmony export */   NDKStorySticker: () => (/* binding */ NDKStorySticker),\n/* harmony export */   NDKStoryStickerType: () => (/* binding */ NDKStoryStickerType),\n/* harmony export */   NDKSubscription: () => (/* binding */ NDKSubscription),\n/* harmony export */   NDKSubscriptionCacheUsage: () => (/* binding */ NDKSubscriptionCacheUsage),\n/* harmony export */   NDKSubscriptionReceipt: () => (/* binding */ NDKSubscriptionReceipt),\n/* harmony export */   NDKSubscriptionStart: () => (/* binding */ NDKSubscriptionStart),\n/* harmony export */   NDKSubscriptionTier: () => (/* binding */ NDKSubscriptionTier),\n/* harmony export */   NDKTranscriptionDVM: () => (/* binding */ NDKTranscriptionDVM),\n/* harmony export */   NDKUser: () => (/* binding */ NDKUser),\n/* harmony export */   NDKVideo: () => (/* binding */ NDKVideo),\n/* harmony export */   NDKWiki: () => (/* binding */ NDKWiki),\n/* harmony export */   NDKWikiMergeRequest: () => (/* binding */ NDKWikiMergeRequest),\n/* harmony export */   NDKZapper: () => (/* binding */ NDKZapper),\n/* harmony export */   NIP33_A_REGEX: () => (/* binding */ NIP33_A_REGEX),\n/* harmony export */   NdkNutzapStatus: () => (/* binding */ NdkNutzapStatus),\n/* harmony export */   calculateRelaySetFromEvent: () => (/* binding */ calculateRelaySetFromEvent),\n/* harmony export */   calculateTermDurationInSeconds: () => (/* binding */ calculateTermDurationInSeconds),\n/* harmony export */   cashuPubkeyToNostrPubkey: () => (/* binding */ cashuPubkeyToNostrPubkey),\n/* harmony export */   compareFilter: () => (/* binding */ compareFilter),\n/* harmony export */   \"default\": () => (/* binding */ NDK),\n/* harmony export */   defaultOpts: () => (/* binding */ defaultOpts),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   dvmSchedule: () => (/* binding */ dvmSchedule),\n/* harmony export */   eventHasETagMarkers: () => (/* binding */ eventHasETagMarkers),\n/* harmony export */   eventIsPartOfThread: () => (/* binding */ eventIsPartOfThread),\n/* harmony export */   eventIsReply: () => (/* binding */ eventIsReply),\n/* harmony export */   eventReplies: () => (/* binding */ eventReplies),\n/* harmony export */   eventThreadIds: () => (/* binding */ eventThreadIds),\n/* harmony export */   eventThreads: () => (/* binding */ eventThreads),\n/* harmony export */   eventsBySameAuthor: () => (/* binding */ eventsBySameAuthor),\n/* harmony export */   filterAndRelaySetFromBech32: () => (/* binding */ filterAndRelaySetFromBech32),\n/* harmony export */   filterFingerprint: () => (/* binding */ filterFingerprint),\n/* harmony export */   filterForEventsTaggingId: () => (/* binding */ filterForEventsTaggingId),\n/* harmony export */   filterFromId: () => (/* binding */ filterFromId),\n/* harmony export */   generateContentTags: () => (/* binding */ generateContentTags),\n/* harmony export */   generateHashtags: () => (/* binding */ generateHashtags),\n/* harmony export */   generateSubId: () => (/* binding */ generateSubId),\n/* harmony export */   generateZapRequest: () => (/* binding */ generateZapRequest),\n/* harmony export */   getEventReplyId: () => (/* binding */ getEventReplyId),\n/* harmony export */   getNip57ZapSpecFromLud: () => (/* binding */ getNip57ZapSpecFromLud),\n/* harmony export */   getRelayListForUser: () => (/* binding */ getRelayListForUser),\n/* harmony export */   getRelayListForUsers: () => (/* binding */ getRelayListForUsers),\n/* harmony export */   getReplyTag: () => (/* binding */ getReplyTag),\n/* harmony export */   getRootEventId: () => (/* binding */ getRootEventId),\n/* harmony export */   getRootTag: () => (/* binding */ getRootTag),\n/* harmony export */   giftUnwrap: () => (/* binding */ giftUnwrap),\n/* harmony export */   giftWrap: () => (/* binding */ giftWrap),\n/* harmony export */   imetaTagToTag: () => (/* binding */ imetaTagToTag),\n/* harmony export */   isEventOriginalPost: () => (/* binding */ isEventOriginalPost),\n/* harmony export */   isNip33AValue: () => (/* binding */ isNip33AValue),\n/* harmony export */   mapImetaTag: () => (/* binding */ mapImetaTag),\n/* harmony export */   matchFilter: () => (/* binding */ matchFilter),\n/* harmony export */   mergeFilters: () => (/* binding */ mergeFilters),\n/* harmony export */   mergeTags: () => (/* binding */ mergeTags),\n/* harmony export */   ndkSignerFromPayload: () => (/* binding */ ndkSignerFromPayload),\n/* harmony export */   newAmount: () => (/* binding */ newAmount),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   normalizeRelayUrl: () => (/* binding */ normalizeRelayUrl),\n/* harmony export */   normalizeUrl: () => (/* binding */ normalizeUrl),\n/* harmony export */   parseTagToSubscriptionAmount: () => (/* binding */ parseTagToSubscriptionAmount),\n/* harmony export */   pinEvent: () => (/* binding */ pinEvent),\n/* harmony export */   possibleIntervalFrequencies: () => (/* binding */ possibleIntervalFrequencies),\n/* harmony export */   profileFromEvent: () => (/* binding */ profileFromEvent),\n/* harmony export */   proofP2pk: () => (/* binding */ proofP2pk),\n/* harmony export */   proofP2pkNostr: () => (/* binding */ proofP2pkNostr),\n/* harmony export */   proofsTotalBalance: () => (/* binding */ proofsTotalBalance),\n/* harmony export */   queryFullyFilled: () => (/* binding */ queryFullyFilled),\n/* harmony export */   relayListFromKind3: () => (/* binding */ relayListFromKind3),\n/* harmony export */   relaysFromBech32: () => (/* binding */ relaysFromBech32),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializeProfile: () => (/* binding */ serializeProfile),\n/* harmony export */   signerRegistry: () => (/* binding */ signerRegistry),\n/* harmony export */   strToDimension: () => (/* binding */ strToDimension),\n/* harmony export */   strToPosition: () => (/* binding */ strToPosition),\n/* harmony export */   tryNormalizeRelayUrl: () => (/* binding */ tryNormalizeRelayUrl),\n/* harmony export */   uniqueTag: () => (/* binding */ uniqueTag),\n/* harmony export */   wrapEvent: () => (/* binding */ wrapEvent),\n/* harmony export */   zapInvoiceFromEvent: () => (/* binding */ zapInvoiceFromEvent)\n/* harmony export */ });\n/* harmony import */ var tseep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tseep */ \"(ssr)/./node_modules/tseep/lib/index.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nostr-tools */ \"(ssr)/./node_modules/.pnpm/nostr-tools@2.14.2_typescript@5.8.3/node_modules/nostr-tools/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! typescript-lru-cache */ \"(ssr)/./node_modules/typescript-lru-cache/dist/index.js\");\n/* harmony import */ var light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! light-bolt11-decoder */ \"(ssr)/./node_modules/light-bolt11-decoder/bolt11.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n// src/types.ts\nvar NdkNutzapStatus = /* @__PURE__ */ ((NdkNutzapStatus2) => {\n  NdkNutzapStatus2[\"INITIAL\"] = \"initial\";\n  NdkNutzapStatus2[\"PROCESSING\"] = \"processing\";\n  NdkNutzapStatus2[\"REDEEMED\"] = \"redeemed\";\n  NdkNutzapStatus2[\"SPENT\"] = \"spent\";\n  NdkNutzapStatus2[\"MISSING_PRIVKEY\"] = \"missing_privkey\";\n  NdkNutzapStatus2[\"TEMPORARY_ERROR\"] = \"temporary_error\";\n  NdkNutzapStatus2[\"PERMANENT_ERROR\"] = \"permanent_error\";\n  NdkNutzapStatus2[\"INVALID_NUTZAP\"] = \"invalid_nutzap\";\n  return NdkNutzapStatus2;\n})(NdkNutzapStatus || {});\n\n// src/events/kinds/index.ts\nvar NDKKind = /* @__PURE__ */ ((NDKKind2) => {\n  NDKKind2[NDKKind2[\"Metadata\"] = 0] = \"Metadata\";\n  NDKKind2[NDKKind2[\"Text\"] = 1] = \"Text\";\n  NDKKind2[NDKKind2[\"RecommendRelay\"] = 2] = \"RecommendRelay\";\n  NDKKind2[NDKKind2[\"Contacts\"] = 3] = \"Contacts\";\n  NDKKind2[NDKKind2[\"EncryptedDirectMessage\"] = 4] = \"EncryptedDirectMessage\";\n  NDKKind2[NDKKind2[\"EventDeletion\"] = 5] = \"EventDeletion\";\n  NDKKind2[NDKKind2[\"Repost\"] = 6] = \"Repost\";\n  NDKKind2[NDKKind2[\"Reaction\"] = 7] = \"Reaction\";\n  NDKKind2[NDKKind2[\"BadgeAward\"] = 8] = \"BadgeAward\";\n  NDKKind2[NDKKind2[\"GroupChat\"] = 9] = \"GroupChat\";\n  NDKKind2[NDKKind2[\"GroupNote\"] = 11] = \"GroupNote\";\n  NDKKind2[NDKKind2[\"GroupReply\"] = 12] = \"GroupReply\";\n  NDKKind2[NDKKind2[\"GiftWrapSeal\"] = 13] = \"GiftWrapSeal\";\n  NDKKind2[NDKKind2[\"PrivateDirectMessage\"] = 14] = \"PrivateDirectMessage\";\n  NDKKind2[NDKKind2[\"Image\"] = 20] = \"Image\";\n  NDKKind2[NDKKind2[\"Video\"] = 21] = \"Video\";\n  NDKKind2[NDKKind2[\"ShortVideo\"] = 22] = \"ShortVideo\";\n  NDKKind2[NDKKind2[\"Story\"] = 23] = \"Story\";\n  NDKKind2[NDKKind2[\"Vanish\"] = 62] = \"Vanish\";\n  NDKKind2[NDKKind2[\"CashuWalletBackup\"] = 375] = \"CashuWalletBackup\";\n  NDKKind2[NDKKind2[\"GiftWrap\"] = 1059] = \"GiftWrap\";\n  NDKKind2[NDKKind2[\"GenericRepost\"] = 16] = \"GenericRepost\";\n  NDKKind2[NDKKind2[\"ChannelCreation\"] = 40] = \"ChannelCreation\";\n  NDKKind2[NDKKind2[\"ChannelMetadata\"] = 41] = \"ChannelMetadata\";\n  NDKKind2[NDKKind2[\"ChannelMessage\"] = 42] = \"ChannelMessage\";\n  NDKKind2[NDKKind2[\"ChannelHideMessage\"] = 43] = \"ChannelHideMessage\";\n  NDKKind2[NDKKind2[\"ChannelMuteUser\"] = 44] = \"ChannelMuteUser\";\n  NDKKind2[NDKKind2[\"WikiMergeRequest\"] = 818] = \"WikiMergeRequest\";\n  NDKKind2[NDKKind2[\"GenericReply\"] = 1111] = \"GenericReply\";\n  NDKKind2[NDKKind2[\"Media\"] = 1063] = \"Media\";\n  NDKKind2[NDKKind2[\"Report\"] = 1984] = \"Report\";\n  NDKKind2[NDKKind2[\"Label\"] = 1985] = \"Label\";\n  NDKKind2[NDKKind2[\"DVMReqTextExtraction\"] = 5e3] = \"DVMReqTextExtraction\";\n  NDKKind2[NDKKind2[\"DVMReqTextSummarization\"] = 5001] = \"DVMReqTextSummarization\";\n  NDKKind2[NDKKind2[\"DVMReqTextTranslation\"] = 5002] = \"DVMReqTextTranslation\";\n  NDKKind2[NDKKind2[\"DVMReqTextGeneration\"] = 5050] = \"DVMReqTextGeneration\";\n  NDKKind2[NDKKind2[\"DVMReqImageGeneration\"] = 5100] = \"DVMReqImageGeneration\";\n  NDKKind2[NDKKind2[\"DVMReqTextToSpeech\"] = 5250] = \"DVMReqTextToSpeech\";\n  NDKKind2[NDKKind2[\"DVMReqDiscoveryNostrContent\"] = 5300] = \"DVMReqDiscoveryNostrContent\";\n  NDKKind2[NDKKind2[\"DVMReqDiscoveryNostrPeople\"] = 5301] = \"DVMReqDiscoveryNostrPeople\";\n  NDKKind2[NDKKind2[\"DVMReqTimestamping\"] = 5900] = \"DVMReqTimestamping\";\n  NDKKind2[NDKKind2[\"DVMEventSchedule\"] = 5905] = \"DVMEventSchedule\";\n  NDKKind2[NDKKind2[\"DVMJobFeedback\"] = 7e3] = \"DVMJobFeedback\";\n  NDKKind2[NDKKind2[\"Subscribe\"] = 7001] = \"Subscribe\";\n  NDKKind2[NDKKind2[\"Unsubscribe\"] = 7002] = \"Unsubscribe\";\n  NDKKind2[NDKKind2[\"SubscriptionReceipt\"] = 7003] = \"SubscriptionReceipt\";\n  NDKKind2[NDKKind2[\"CashuReserve\"] = 7373] = \"CashuReserve\";\n  NDKKind2[NDKKind2[\"CashuQuote\"] = 7374] = \"CashuQuote\";\n  NDKKind2[NDKKind2[\"CashuToken\"] = 7375] = \"CashuToken\";\n  NDKKind2[NDKKind2[\"CashuWalletTx\"] = 7376] = \"CashuWalletTx\";\n  NDKKind2[NDKKind2[\"GroupAdminAddUser\"] = 9e3] = \"GroupAdminAddUser\";\n  NDKKind2[NDKKind2[\"GroupAdminRemoveUser\"] = 9001] = \"GroupAdminRemoveUser\";\n  NDKKind2[NDKKind2[\"GroupAdminEditMetadata\"] = 9002] = \"GroupAdminEditMetadata\";\n  NDKKind2[NDKKind2[\"GroupAdminEditStatus\"] = 9006] = \"GroupAdminEditStatus\";\n  NDKKind2[NDKKind2[\"GroupAdminCreateGroup\"] = 9007] = \"GroupAdminCreateGroup\";\n  NDKKind2[NDKKind2[\"GroupAdminRequestJoin\"] = 9021] = \"GroupAdminRequestJoin\";\n  NDKKind2[NDKKind2[\"MuteList\"] = 1e4] = \"MuteList\";\n  NDKKind2[NDKKind2[\"PinList\"] = 10001] = \"PinList\";\n  NDKKind2[NDKKind2[\"RelayList\"] = 10002] = \"RelayList\";\n  NDKKind2[NDKKind2[\"BookmarkList\"] = 10003] = \"BookmarkList\";\n  NDKKind2[NDKKind2[\"CommunityList\"] = 10004] = \"CommunityList\";\n  NDKKind2[NDKKind2[\"PublicChatList\"] = 10005] = \"PublicChatList\";\n  NDKKind2[NDKKind2[\"BlockRelayList\"] = 10006] = \"BlockRelayList\";\n  NDKKind2[NDKKind2[\"SearchRelayList\"] = 10007] = \"SearchRelayList\";\n  NDKKind2[NDKKind2[\"SimpleGroupList\"] = 10009] = \"SimpleGroupList\";\n  NDKKind2[NDKKind2[\"InterestList\"] = 10015] = \"InterestList\";\n  NDKKind2[NDKKind2[\"CashuMintList\"] = 10019] = \"CashuMintList\";\n  NDKKind2[NDKKind2[\"EmojiList\"] = 10030] = \"EmojiList\";\n  NDKKind2[NDKKind2[\"DirectMessageReceiveRelayList\"] = 10050] = \"DirectMessageReceiveRelayList\";\n  NDKKind2[NDKKind2[\"BlossomList\"] = 10063] = \"BlossomList\";\n  NDKKind2[NDKKind2[\"NostrWaletConnectInfo\"] = 13194] = \"NostrWaletConnectInfo\";\n  NDKKind2[NDKKind2[\"TierList\"] = 17e3] = \"TierList\";\n  NDKKind2[NDKKind2[\"CashuWallet\"] = 17375] = \"CashuWallet\";\n  NDKKind2[NDKKind2[\"FollowSet\"] = 3e4] = \"FollowSet\";\n  NDKKind2[NDKKind2[\"CategorizedPeopleList\"] = 3e4 /* FollowSet */] = \"CategorizedPeopleList\";\n  NDKKind2[NDKKind2[\"CategorizedBookmarkList\"] = 30001] = \"CategorizedBookmarkList\";\n  NDKKind2[NDKKind2[\"RelaySet\"] = 30002] = \"RelaySet\";\n  NDKKind2[NDKKind2[\"CategorizedRelayList\"] = 30002 /* RelaySet */] = \"CategorizedRelayList\";\n  NDKKind2[NDKKind2[\"BookmarkSet\"] = 30003] = \"BookmarkSet\";\n  NDKKind2[NDKKind2[\"CurationSet\"] = 30004] = \"CurationSet\";\n  NDKKind2[NDKKind2[\"ArticleCurationSet\"] = 30004] = \"ArticleCurationSet\";\n  NDKKind2[NDKKind2[\"VideoCurationSet\"] = 30005] = \"VideoCurationSet\";\n  NDKKind2[NDKKind2[\"ImageCurationSet\"] = 30006] = \"ImageCurationSet\";\n  NDKKind2[NDKKind2[\"InterestSet\"] = 30015] = \"InterestSet\";\n  NDKKind2[NDKKind2[\"InterestsList\"] = 30015 /* InterestSet */] = \"InterestsList\";\n  NDKKind2[NDKKind2[\"EmojiSet\"] = 30030] = \"EmojiSet\";\n  NDKKind2[NDKKind2[\"ModularArticle\"] = 30040] = \"ModularArticle\";\n  NDKKind2[NDKKind2[\"ModularArticleItem\"] = 30041] = \"ModularArticleItem\";\n  NDKKind2[NDKKind2[\"Wiki\"] = 30818] = \"Wiki\";\n  NDKKind2[NDKKind2[\"Draft\"] = 31234] = \"Draft\";\n  NDKKind2[NDKKind2[\"SubscriptionTier\"] = 37001] = \"SubscriptionTier\";\n  NDKKind2[NDKKind2[\"EcashMintRecommendation\"] = 38e3] = \"EcashMintRecommendation\";\n  NDKKind2[NDKKind2[\"HighlightSet\"] = 39802] = \"HighlightSet\";\n  NDKKind2[NDKKind2[\"CategorizedHighlightList\"] = 39802 /* HighlightSet */] = \"CategorizedHighlightList\";\n  NDKKind2[NDKKind2[\"Nutzap\"] = 9321] = \"Nutzap\";\n  NDKKind2[NDKKind2[\"ZapRequest\"] = 9734] = \"ZapRequest\";\n  NDKKind2[NDKKind2[\"Zap\"] = 9735] = \"Zap\";\n  NDKKind2[NDKKind2[\"Highlight\"] = 9802] = \"Highlight\";\n  NDKKind2[NDKKind2[\"ClientAuth\"] = 22242] = \"ClientAuth\";\n  NDKKind2[NDKKind2[\"NostrWalletConnectReq\"] = 23194] = \"NostrWalletConnectReq\";\n  NDKKind2[NDKKind2[\"NostrWalletConnectRes\"] = 23195] = \"NostrWalletConnectRes\";\n  NDKKind2[NDKKind2[\"NostrConnect\"] = 24133] = \"NostrConnect\";\n  NDKKind2[NDKKind2[\"BlossomUpload\"] = 24242] = \"BlossomUpload\";\n  NDKKind2[NDKKind2[\"HttpAuth\"] = 27235] = \"HttpAuth\";\n  NDKKind2[NDKKind2[\"ProfileBadge\"] = 30008] = \"ProfileBadge\";\n  NDKKind2[NDKKind2[\"BadgeDefinition\"] = 30009] = \"BadgeDefinition\";\n  NDKKind2[NDKKind2[\"MarketStall\"] = 30017] = \"MarketStall\";\n  NDKKind2[NDKKind2[\"MarketProduct\"] = 30018] = \"MarketProduct\";\n  NDKKind2[NDKKind2[\"Article\"] = 30023] = \"Article\";\n  NDKKind2[NDKKind2[\"AppSpecificData\"] = 30078] = \"AppSpecificData\";\n  NDKKind2[NDKKind2[\"Classified\"] = 30402] = \"Classified\";\n  NDKKind2[NDKKind2[\"HorizontalVideo\"] = 34235] = \"HorizontalVideo\";\n  NDKKind2[NDKKind2[\"VerticalVideo\"] = 34236] = \"VerticalVideo\";\n  NDKKind2[NDKKind2[\"LegacyCashuWallet\"] = 37375] = \"LegacyCashuWallet\";\n  NDKKind2[NDKKind2[\"GroupMetadata\"] = 39e3] = \"GroupMetadata\";\n  NDKKind2[NDKKind2[\"GroupAdmins\"] = 39001] = \"GroupAdmins\";\n  NDKKind2[NDKKind2[\"GroupMembers\"] = 39002] = \"GroupMembers\";\n  NDKKind2[NDKKind2[\"AppRecommendation\"] = 31989] = \"AppRecommendation\";\n  NDKKind2[NDKKind2[\"AppHandler\"] = 31990] = \"AppHandler\";\n  return NDKKind2;\n})(NDKKind || {});\nvar NDKListKinds = [\n  1e4 /* MuteList */,\n  10001 /* PinList */,\n  10002 /* RelayList */,\n  10003 /* BookmarkList */,\n  10004 /* CommunityList */,\n  10005 /* PublicChatList */,\n  10006 /* BlockRelayList */,\n  10007 /* SearchRelayList */,\n  10015 /* InterestList */,\n  10030 /* EmojiList */,\n  10050 /* DirectMessageReceiveRelayList */,\n  3e4 /* FollowSet */,\n  30003 /* BookmarkSet */,\n  30001 /* CategorizedBookmarkList */,\n  // Backwards compatibility\n  30002 /* RelaySet */,\n  30004 /* ArticleCurationSet */,\n  30005 /* VideoCurationSet */,\n  30015 /* InterestSet */,\n  30030 /* EmojiSet */,\n  39802 /* HighlightSet */\n];\n\n// src/events/index.ts\n\n\n// src/relay/sets/calculate.ts\n\n\n// src/outbox/write.ts\nfunction getRelaysForSync(ndk, author, type = \"write\") {\n  if (!ndk.outboxTracker) return void 0;\n  const item = ndk.outboxTracker.data.get(author);\n  if (!item) return void 0;\n  if (type === \"write\") {\n    return item.writeRelays;\n  }\n  return item.readRelays;\n}\nasync function getWriteRelaysFor(ndk, author, type = \"write\") {\n  if (!ndk.outboxTracker) return void 0;\n  if (!ndk.outboxTracker.data.has(author)) {\n    await ndk.outboxTracker.trackUsers([author]);\n  }\n  return getRelaysForSync(ndk, author, type);\n}\n\n// src/outbox/relay-ranking.ts\nfunction getTopRelaysForAuthors(ndk, authors) {\n  const relaysWithCount = /* @__PURE__ */ new Map();\n  authors.forEach((author) => {\n    const writeRelays = getRelaysForSync(ndk, author);\n    if (writeRelays) {\n      writeRelays.forEach((relay) => {\n        const count = relaysWithCount.get(relay) || 0;\n        relaysWithCount.set(relay, count + 1);\n      });\n    }\n  });\n  const sortedRelays = Array.from(relaysWithCount.entries()).sort((a, b) => b[1] - a[1]);\n  return sortedRelays.map((entry) => entry[0]);\n}\n\n// src/outbox/index.ts\nfunction getAllRelaysForAllPubkeys(ndk, pubkeys, type = \"read\") {\n  const pubkeysToRelays = /* @__PURE__ */ new Map();\n  const authorsMissingRelays = /* @__PURE__ */ new Set();\n  pubkeys.forEach((pubkey) => {\n    const relays = getRelaysForSync(ndk, pubkey, type);\n    if (relays && relays.size > 0) {\n      relays.forEach((relay) => {\n        const pubkeysInRelay = pubkeysToRelays.get(relay) || /* @__PURE__ */ new Set();\n        pubkeysInRelay.add(pubkey);\n      });\n      pubkeysToRelays.set(pubkey, relays);\n    } else {\n      authorsMissingRelays.add(pubkey);\n    }\n  });\n  return { pubkeysToRelays, authorsMissingRelays };\n}\nfunction chooseRelayCombinationForPubkeys(ndk, pubkeys, type, { count, preferredRelays } = {}) {\n  count ??= 2;\n  preferredRelays ??= /* @__PURE__ */ new Set();\n  const pool = ndk.pool;\n  const connectedRelays = pool.connectedRelays();\n  connectedRelays.forEach((relay) => {\n    preferredRelays?.add(relay.url);\n  });\n  const relayToAuthorsMap = /* @__PURE__ */ new Map();\n  const { pubkeysToRelays, authorsMissingRelays } = getAllRelaysForAllPubkeys(ndk, pubkeys, type);\n  const sortedRelays = getTopRelaysForAuthors(ndk, pubkeys);\n  const addAuthorToRelay = (author, relay) => {\n    const authorsInRelay = relayToAuthorsMap.get(relay) || [];\n    authorsInRelay.push(author);\n    relayToAuthorsMap.set(relay, authorsInRelay);\n  };\n  for (const [author, authorRelays] of pubkeysToRelays.entries()) {\n    let missingRelayCount = count;\n    for (const relay of connectedRelays) {\n      if (authorRelays.has(relay.url)) {\n        addAuthorToRelay(author, relay.url);\n        missingRelayCount--;\n      }\n    }\n    for (const authorRelay of authorRelays) {\n      if (relayToAuthorsMap.has(authorRelay)) {\n        addAuthorToRelay(author, authorRelay);\n        missingRelayCount--;\n      }\n    }\n    if (missingRelayCount <= 0) continue;\n    for (const relay of sortedRelays) {\n      if (missingRelayCount <= 0) break;\n      if (authorRelays.has(relay)) {\n        addAuthorToRelay(author, relay);\n        missingRelayCount--;\n      }\n    }\n  }\n  for (const author of authorsMissingRelays) {\n    pool.permanentAndConnectedRelays().forEach((relay) => {\n      const authorsInRelay = relayToAuthorsMap.get(relay.url) || [];\n      authorsInRelay.push(author);\n      relayToAuthorsMap.set(relay.url, authorsInRelay);\n    });\n  }\n  return relayToAuthorsMap;\n}\n\n// src/outbox/read/with-authors.ts\nfunction getRelaysForFilterWithAuthors(ndk, authors, relayGoalPerAuthor = 2) {\n  return chooseRelayCombinationForPubkeys(ndk, authors, \"write\", { count: relayGoalPerAuthor });\n}\n\n// src/utils/normalize-url.ts\nfunction tryNormalizeRelayUrl(url) {\n  try {\n    return normalizeRelayUrl(url);\n  } catch {\n    return void 0;\n  }\n}\nfunction normalizeRelayUrl(url) {\n  let r = normalizeUrl(url, {\n    stripAuthentication: false,\n    stripWWW: false,\n    stripHash: true\n  });\n  if (!r.endsWith(\"/\")) {\n    r += \"/\";\n  }\n  return r;\n}\nfunction normalize(urls) {\n  const normalized = /* @__PURE__ */ new Set();\n  for (const url of urls) {\n    try {\n      normalized.add(normalizeRelayUrl(url));\n    } catch {\n    }\n  }\n  return Array.from(normalized);\n}\nvar DATA_URL_DEFAULT_MIME_TYPE = \"text/plain\";\nvar DATA_URL_DEFAULT_CHARSET = \"us-ascii\";\nvar testParameter = (name, filters) => filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);\nvar supportedProtocols = /* @__PURE__ */ new Set([\"https:\", \"http:\", \"file:\"]);\nvar hasCustomProtocol = (urlString) => {\n  try {\n    const { protocol } = new URL(urlString);\n    return protocol.endsWith(\":\") && !protocol.includes(\".\") && !supportedProtocols.has(protocol);\n  } catch {\n    return false;\n  }\n};\nvar normalizeDataURL = (urlString, { stripHash }) => {\n  const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);\n  if (!match) {\n    throw new Error(`Invalid URL: ${urlString}`);\n  }\n  const type = match.groups?.type ?? \"\";\n  const data = match.groups?.data ?? \"\";\n  let hash = match.groups?.hash ?? \"\";\n  const mediaType = type.split(\";\");\n  hash = stripHash ? \"\" : hash;\n  let isBase64 = false;\n  if (mediaType[mediaType.length - 1] === \"base64\") {\n    mediaType.pop();\n    isBase64 = true;\n  }\n  const mimeType = mediaType.shift()?.toLowerCase() ?? \"\";\n  const attributes = mediaType.map((attribute) => {\n    let [key, value = \"\"] = attribute.split(\"=\").map((string) => string.trim());\n    if (key === \"charset\") {\n      value = value.toLowerCase();\n      if (value === DATA_URL_DEFAULT_CHARSET) {\n        return \"\";\n      }\n    }\n    return `${key}${value ? `=${value}` : \"\"}`;\n  }).filter(Boolean);\n  const normalizedMediaType = [...attributes];\n  if (isBase64) {\n    normalizedMediaType.push(\"base64\");\n  }\n  if (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {\n    normalizedMediaType.unshift(mimeType);\n  }\n  return `data:${normalizedMediaType.join(\";\")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : \"\"}`;\n};\nfunction normalizeUrl(urlString, options = {}) {\n  options = {\n    defaultProtocol: \"http\",\n    normalizeProtocol: true,\n    forceHttp: false,\n    forceHttps: false,\n    stripAuthentication: true,\n    stripHash: false,\n    stripTextFragment: true,\n    stripWWW: true,\n    removeQueryParameters: [/^utm_\\w+/i],\n    removeTrailingSlash: true,\n    removeSingleSlash: true,\n    removeDirectoryIndex: false,\n    removeExplicitPort: false,\n    sortQueryParameters: true,\n    ...options\n  };\n  if (typeof options.defaultProtocol === \"string\" && !options.defaultProtocol.endsWith(\":\")) {\n    options.defaultProtocol = `${options.defaultProtocol}:`;\n  }\n  urlString = urlString.trim();\n  if (/^data:/i.test(urlString)) {\n    return normalizeDataURL(urlString, options);\n  }\n  if (hasCustomProtocol(urlString)) {\n    return urlString;\n  }\n  const hasRelativeProtocol = urlString.startsWith(\"//\");\n  const isRelativeUrl = !hasRelativeProtocol && /^\\.*\\//.test(urlString);\n  if (!isRelativeUrl) {\n    urlString = urlString.replace(/^(?!(?:\\w+:)?\\/\\/)|^\\/\\//, options.defaultProtocol);\n  }\n  const urlObject = new URL(urlString);\n  urlObject.hostname = urlObject.hostname.toLowerCase();\n  if (options.forceHttp && options.forceHttps) {\n    throw new Error(\"The `forceHttp` and `forceHttps` options cannot be used together\");\n  }\n  if (options.forceHttp && urlObject.protocol === \"https:\") {\n    urlObject.protocol = \"http:\";\n  }\n  if (options.forceHttps && urlObject.protocol === \"http:\") {\n    urlObject.protocol = \"https:\";\n  }\n  if (options.stripAuthentication) {\n    urlObject.username = \"\";\n    urlObject.password = \"\";\n  }\n  if (options.stripHash) {\n    urlObject.hash = \"\";\n  } else if (options.stripTextFragment) {\n    urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, \"\");\n  }\n  if (urlObject.pathname) {\n    const protocolRegex = /\\b[a-z][a-z\\d+\\-.]{1,50}:\\/\\//g;\n    let lastIndex = 0;\n    let result = \"\";\n    for (; ; ) {\n      const match = protocolRegex.exec(urlObject.pathname);\n      if (!match) {\n        break;\n      }\n      const protocol = match[0];\n      const protocolAtIndex = match.index;\n      const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);\n      result += intermediate.replace(/\\/{2,}/g, \"/\");\n      result += protocol;\n      lastIndex = protocolAtIndex + protocol.length;\n    }\n    const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);\n    result += remnant.replace(/\\/{2,}/g, \"/\");\n    urlObject.pathname = result;\n  }\n  if (urlObject.pathname) {\n    try {\n      urlObject.pathname = decodeURI(urlObject.pathname);\n    } catch {\n    }\n  }\n  if (options.removeDirectoryIndex === true) {\n    options.removeDirectoryIndex = [/^index\\.[a-z]+$/];\n  }\n  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {\n    let pathComponents = urlObject.pathname.split(\"/\");\n    const lastComponent = pathComponents[pathComponents.length - 1];\n    if (testParameter(lastComponent, options.removeDirectoryIndex)) {\n      pathComponents = pathComponents.slice(0, -1);\n      urlObject.pathname = `${pathComponents.slice(1).join(\"/\")}/`;\n    }\n  }\n  if (urlObject.hostname) {\n    urlObject.hostname = urlObject.hostname.replace(/\\.$/, \"\");\n    if (options.stripWWW && /^www\\.(?!www\\.)[a-z\\-\\d]{1,63}\\.[a-z.\\-\\d]{2,63}$/.test(urlObject.hostname)) {\n      urlObject.hostname = urlObject.hostname.replace(/^www\\./, \"\");\n    }\n  }\n  if (Array.isArray(options.removeQueryParameters)) {\n    for (const key of [...urlObject.searchParams.keys()]) {\n      if (testParameter(key, options.removeQueryParameters)) {\n        urlObject.searchParams.delete(key);\n      }\n    }\n  }\n  if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {\n    urlObject.search = \"\";\n  }\n  if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {\n    for (const key of [...urlObject.searchParams.keys()]) {\n      if (!testParameter(key, options.keepQueryParameters)) {\n        urlObject.searchParams.delete(key);\n      }\n    }\n  }\n  if (options.sortQueryParameters) {\n    urlObject.searchParams.sort();\n    try {\n      urlObject.search = decodeURIComponent(urlObject.search);\n    } catch {\n    }\n  }\n  if (options.removeTrailingSlash) {\n    urlObject.pathname = urlObject.pathname.replace(/\\/$/, \"\");\n  }\n  if (options.removeExplicitPort && urlObject.port) {\n    urlObject.port = \"\";\n  }\n  const oldUrlString = urlString;\n  urlString = urlObject.toString();\n  if (!options.removeSingleSlash && urlObject.pathname === \"/\" && !oldUrlString.endsWith(\"/\") && urlObject.hash === \"\") {\n    urlString = urlString.replace(/\\/$/, \"\");\n  }\n  if ((options.removeTrailingSlash || urlObject.pathname === \"/\") && urlObject.hash === \"\" && options.removeSingleSlash) {\n    urlString = urlString.replace(/\\/$/, \"\");\n  }\n  if (hasRelativeProtocol && !options.normalizeProtocol) {\n    urlString = urlString.replace(/^http:\\/\\//, \"//\");\n  }\n  if (options.stripProtocol) {\n    urlString = urlString.replace(/^(?:https?:)?\\/\\//, \"\");\n  }\n  return urlString;\n}\n\n// src/relay/index.ts\n\n\n\n// src/relay/connectivity.ts\nvar MAX_RECONNECT_ATTEMPTS = 5;\nvar FLAPPING_THRESHOLD_MS = 1e3;\nvar NDKRelayConnectivity = class {\n  ndkRelay;\n  ws;\n  _status;\n  timeoutMs;\n  connectedAt;\n  _connectionStats = {\n    attempts: 0,\n    success: 0,\n    durations: []\n  };\n  debug;\n  netDebug;\n  connectTimeout;\n  reconnectTimeout;\n  ndk;\n  openSubs = /* @__PURE__ */ new Map();\n  openCountRequests = /* @__PURE__ */ new Map();\n  openEventPublishes = /* @__PURE__ */ new Map();\n  serial = 0;\n  baseEoseTimeout = 4400;\n  constructor(ndkRelay, ndk) {\n    this.ndkRelay = ndkRelay;\n    this._status = 1 /* DISCONNECTED */;\n    const rand = Math.floor(Math.random() * 1e3);\n    this.debug = this.ndkRelay.debug.extend(`connectivity${rand}`);\n    this.ndk = ndk;\n  }\n  /**\n   * Connects to the NDK relay and handles the connection lifecycle.\n   *\n   * This method attempts to establish a WebSocket connection to the NDK relay specified in the `ndkRelay` object.\n   * If the connection is successful, it updates the connection statistics, sets the connection status to `CONNECTED`,\n   * and emits `connect` and `ready` events on the `ndkRelay` object.\n   *\n   * If the connection attempt fails, it handles the error by either initiating a reconnection attempt or emitting a\n   * `delayed-connect` event on the `ndkRelay` object, depending on the `reconnect` parameter.\n   *\n   * @param timeoutMs - The timeout in milliseconds for the connection attempt. If not provided, the default timeout from the `ndkRelay` object is used.\n   * @param reconnect - Indicates whether a reconnection should be attempted if the connection fails. Defaults to `true`.\n   * @returns A Promise that resolves when the connection is established, or rejects if the connection fails.\n   */\n  async connect(timeoutMs, reconnect = true) {\n    if (this._status !== 2 /* RECONNECTING */ && this._status !== 1 /* DISCONNECTED */ || this.reconnectTimeout) {\n      this.debug(\n        \"Relay requested to be connected but was in state %s or it had a reconnect timeout\",\n        this._status\n      );\n      return;\n    }\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = void 0;\n    }\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = void 0;\n    }\n    timeoutMs ??= this.timeoutMs;\n    if (!this.timeoutMs && timeoutMs) this.timeoutMs = timeoutMs;\n    if (this.timeoutMs) this.connectTimeout = setTimeout(() => this.onConnectionError(reconnect), this.timeoutMs);\n    try {\n      this.updateConnectionStats.attempt();\n      if (this._status === 1 /* DISCONNECTED */) this._status = 4 /* CONNECTING */;\n      else this._status = 2 /* RECONNECTING */;\n      this.ws = new WebSocket(this.ndkRelay.url);\n      this.ws.onopen = this.onConnect.bind(this);\n      this.ws.onclose = this.onDisconnect.bind(this);\n      this.ws.onmessage = this.onMessage.bind(this);\n      this.ws.onerror = this.onError.bind(this);\n    } catch (e) {\n      this.debug(`Failed to connect to ${this.ndkRelay.url}`, e);\n      this._status = 1 /* DISCONNECTED */;\n      if (reconnect) this.handleReconnection();\n      else this.ndkRelay.emit(\"delayed-connect\", 2 * 24 * 60 * 60 * 1e3);\n      throw e;\n    }\n  }\n  /**\n   * Disconnects the WebSocket connection to the NDK relay.\n   * This method sets the connection status to `NDKRelayStatus.DISCONNECTING`,\n   * attempts to close the WebSocket connection, and sets the status to\n   * `NDKRelayStatus.DISCONNECTED` if the disconnect operation fails.\n   */\n  disconnect() {\n    this._status = 0 /* DISCONNECTING */;\n    try {\n      this.ws?.close();\n    } catch (e) {\n      this.debug(\"Failed to disconnect\", e);\n      this._status = 1 /* DISCONNECTED */;\n    }\n  }\n  /**\n   * Handles the error that occurred when attempting to connect to the NDK relay.\n   * If `reconnect` is `true`, this method will initiate a reconnection attempt.\n   * Otherwise, it will emit a `delayed-connect` event on the `ndkRelay` object,\n   * indicating that a reconnection should be attempted after a delay.\n   *\n   * @param reconnect - Indicates whether a reconnection should be attempted.\n   */\n  onConnectionError(reconnect) {\n    this.debug(`Error connecting to ${this.ndkRelay.url}`, this.timeoutMs);\n    if (reconnect && !this.reconnectTimeout) {\n      this.handleReconnection();\n    }\n  }\n  /**\n   * Handles the connection event when the WebSocket connection is established.\n   * This method is called when the WebSocket connection is successfully opened.\n   * It clears any existing connection and reconnection timeouts, updates the connection statistics,\n   * sets the connection status to `CONNECTED`, and emits `connect` and `ready` events on the `ndkRelay` object.\n   */\n  onConnect() {\n    this.netDebug?.(\"connected\", this.ndkRelay);\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = void 0;\n    }\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = void 0;\n    }\n    this.updateConnectionStats.connected();\n    this._status = 5 /* CONNECTED */;\n    this.ndkRelay.emit(\"connect\");\n    this.ndkRelay.emit(\"ready\");\n  }\n  /**\n   * Handles the disconnection event when the WebSocket connection is closed.\n   * This method is called when the WebSocket connection is successfully closed.\n   * It updates the connection statistics, sets the connection status to `DISCONNECTED`,\n   * initiates a reconnection attempt if we didn't disconnect ourselves,\n   * and emits a `disconnect` event on the `ndkRelay` object.\n   */\n  onDisconnect() {\n    this.netDebug?.(\"disconnected\", this.ndkRelay);\n    this.updateConnectionStats.disconnected();\n    if (this._status === 5 /* CONNECTED */) {\n      this.handleReconnection();\n    }\n    this._status = 1 /* DISCONNECTED */;\n    this.ndkRelay.emit(\"disconnect\");\n  }\n  /**\n   * Handles incoming messages from the NDK relay WebSocket connection.\n   * This method is called whenever a message is received from the relay.\n   * It parses the message data and dispatches the appropriate handling logic based on the message type.\n   *\n   * @param event - The MessageEvent containing the received message data.\n   */\n  onMessage(event) {\n    this.netDebug?.(event.data, this.ndkRelay, \"recv\");\n    try {\n      const data = JSON.parse(event.data);\n      const [cmd, id, ..._rest] = data;\n      switch (cmd) {\n        case \"EVENT\": {\n          const so = this.openSubs.get(id);\n          const event2 = data[2];\n          if (!so) {\n            this.debug(`Received event for unknown subscription ${id}`);\n            return;\n          }\n          so.onevent(event2);\n          return;\n        }\n        case \"COUNT\": {\n          const payload = data[2];\n          const cr = this.openCountRequests.get(id);\n          if (cr) {\n            cr.resolve(payload.count);\n            this.openCountRequests.delete(id);\n          }\n          return;\n        }\n        case \"EOSE\": {\n          const so = this.openSubs.get(id);\n          if (!so) return;\n          so.oneose(id);\n          return;\n        }\n        case \"OK\": {\n          const ok = data[2];\n          const reason = data[3];\n          const ep = this.openEventPublishes.get(id);\n          const firstEp = ep?.pop();\n          if (!ep || !firstEp) {\n            this.debug(\"Received OK for unknown event publish\", id);\n            return;\n          }\n          if (ok) firstEp.resolve(reason);\n          else firstEp.reject(new Error(reason));\n          if (ep.length === 0) {\n            this.openEventPublishes.delete(id);\n          } else {\n            this.openEventPublishes.set(id, ep);\n          }\n          return;\n        }\n        case \"CLOSED\": {\n          const so = this.openSubs.get(id);\n          if (!so) return;\n          so.onclosed(data[2]);\n          return;\n        }\n        case \"NOTICE\":\n          this.onNotice(data[1]);\n          return;\n        case \"AUTH\": {\n          this.onAuthRequested(data[1]);\n          return;\n        }\n      }\n    } catch (error) {\n      this.debug(`Error parsing message from ${this.ndkRelay.url}: ${error.message}`, error?.stack);\n      return;\n    }\n  }\n  /**\n   * Handles an authentication request from the NDK relay.\n   *\n   * If an authentication policy is configured, it will be used to authenticate the connection.\n   * Otherwise, the `auth` event will be emitted to allow the application to handle the authentication.\n   *\n   * @param challenge - The authentication challenge provided by the NDK relay.\n   */\n  async onAuthRequested(challenge) {\n    const authPolicy = this.ndkRelay.authPolicy ?? this.ndk?.relayAuthDefaultPolicy;\n    this.debug(\"Relay requested authentication\", {\n      havePolicy: !!authPolicy\n    });\n    if (this._status === 7 /* AUTHENTICATING */) {\n      this.debug(\"Already authenticating, ignoring\");\n      return;\n    }\n    this._status = 6 /* AUTH_REQUESTED */;\n    if (authPolicy) {\n      if (this._status >= 5 /* CONNECTED */) {\n        this._status = 7 /* AUTHENTICATING */;\n        let res;\n        try {\n          res = await authPolicy(this.ndkRelay, challenge);\n        } catch (e) {\n          this.debug(\"Authentication policy threw an error\", e);\n          res = false;\n        }\n        this.debug(\"Authentication policy returned\", !!res);\n        if (res instanceof NDKEvent || res === true) {\n          if (res instanceof NDKEvent) {\n            await this.auth(res);\n          }\n          const authenticate = async () => {\n            if (this._status >= 5 /* CONNECTED */ && this._status < 8 /* AUTHENTICATED */) {\n              const event = new NDKEvent(this.ndk);\n              event.kind = 22242 /* ClientAuth */;\n              event.tags = [\n                [\"relay\", this.ndkRelay.url],\n                [\"challenge\", challenge]\n              ];\n              await event.sign();\n              this.auth(event).then(() => {\n                this._status = 8 /* AUTHENTICATED */;\n                this.ndkRelay.emit(\"authed\");\n                this.debug(\"Authentication successful\");\n              }).catch((e) => {\n                this._status = 6 /* AUTH_REQUESTED */;\n                this.ndkRelay.emit(\"auth:failed\", e);\n                this.debug(\"Authentication failed\", e);\n              });\n            } else {\n              this.debug(\"Authentication failed, it changed status, status is %d\", this._status);\n            }\n          };\n          if (res === true) {\n            if (!this.ndk?.signer) {\n              this.debug(\"No signer available for authentication localhost\");\n              this.ndk?.once(\"signer:ready\", authenticate);\n            } else {\n              authenticate().catch((e) => {\n                console.error(\"Error authenticating\", e);\n              });\n            }\n          }\n          this._status = 5 /* CONNECTED */;\n          this.ndkRelay.emit(\"authed\");\n        }\n      }\n    } else {\n      this.ndkRelay.emit(\"auth\", challenge);\n    }\n  }\n  /**\n   * Handles errors that occur on the WebSocket connection to the relay.\n   * @param error - The error or event that occurred.\n   */\n  onError(error) {\n    this.debug(`WebSocket error on ${this.ndkRelay.url}:`, error);\n  }\n  /**\n   * Gets the current status of the NDK relay connection.\n   * @returns {NDKRelayStatus} The current status of the NDK relay connection.\n   */\n  get status() {\n    return this._status;\n  }\n  /**\n   * Checks if the NDK relay connection is currently available.\n   * @returns {boolean} `true` if the relay connection is in the `CONNECTED` status, `false` otherwise.\n   */\n  isAvailable() {\n    return this._status === 5 /* CONNECTED */;\n  }\n  /**\n   * Checks if the NDK relay connection is flapping, which means the connection is rapidly\n   * disconnecting and reconnecting. This is determined by analyzing the durations of the\n   * last three connection attempts. If the standard deviation of the durations is less\n   * than 1000 milliseconds, the connection is considered to be flapping.\n   *\n   * @returns {boolean} `true` if the connection is flapping, `false` otherwise.\n   */\n  isFlapping() {\n    const durations = this._connectionStats.durations;\n    if (durations.length % 3 !== 0) return false;\n    const sum = durations.reduce((a, b) => a + b, 0);\n    const avg = sum / durations.length;\n    const variance = durations.map((x) => (x - avg) ** 2).reduce((a, b) => a + b, 0) / durations.length;\n    const stdDev = Math.sqrt(variance);\n    const isFlapping = stdDev < FLAPPING_THRESHOLD_MS;\n    return isFlapping;\n  }\n  /**\n   * Handles a notice received from the NDK relay.\n   * If the notice indicates the relay is complaining (e.g. \"too many\" or \"maximum\"),\n   * the method disconnects from the relay and attempts to reconnect after a 2-second delay.\n   * A debug message is logged with the relay URL and the notice text.\n   * The \"notice\" event is emitted on the ndkRelay instance with the notice text.\n   *\n   * @param notice - The notice text received from the NDK relay.\n   */\n  async onNotice(notice) {\n    this.ndkRelay.emit(\"notice\", notice);\n  }\n  /**\n   * Attempts to reconnect to the NDK relay after a connection is lost.\n   * This function is called recursively to handle multiple reconnection attempts.\n   * It checks if the relay is flapping and emits a \"flapping\" event if so.\n   * It then calculates a delay before the next reconnection attempt based on the number of previous attempts.\n   * The function sets a timeout to execute the next reconnection attempt after the calculated delay.\n   * If the maximum number of reconnection attempts is reached, a debug message is logged.\n   *\n   * @param attempt - The current attempt number (default is 0).\n   */\n  handleReconnection(attempt = 0) {\n    if (this.reconnectTimeout) return;\n    if (this.isFlapping()) {\n      this.ndkRelay.emit(\"flapping\", this._connectionStats);\n      this._status = 3 /* FLAPPING */;\n      return;\n    }\n    const reconnectDelay = this.connectedAt ? Math.max(0, 6e4 - (Date.now() - this.connectedAt)) : 5e3 * (this._connectionStats.attempts + 1);\n    this.reconnectTimeout = setTimeout(() => {\n      this.reconnectTimeout = void 0;\n      this._status = 2 /* RECONNECTING */;\n      this.connect().catch((_err) => {\n        if (attempt < MAX_RECONNECT_ATTEMPTS) {\n          setTimeout(\n            () => {\n              this.handleReconnection(attempt + 1);\n            },\n            1e3 * (attempt + 1) ^ 4\n          );\n        } else {\n          this.debug(\"Reconnect failed\");\n        }\n      });\n    }, reconnectDelay);\n    this.ndkRelay.emit(\"delayed-connect\", reconnectDelay);\n    this.debug(\"Reconnecting in\", reconnectDelay);\n    this._connectionStats.nextReconnectAt = Date.now() + reconnectDelay;\n  }\n  /**\n   * Sends a message to the NDK relay if the connection is in the CONNECTED state and the WebSocket is open.\n   * If the connection is not in the CONNECTED state or the WebSocket is not open, logs a debug message and throws an error.\n   *\n   * @param message - The message to send to the NDK relay.\n   * @throws {Error} If attempting to send on a closed relay connection.\n   */\n  async send(message) {\n    if (this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN) {\n      this.ws?.send(message);\n      this.netDebug?.(message, this.ndkRelay, \"send\");\n    } else {\n      this.debug(`Not connected to ${this.ndkRelay.url} (%d), not sending message ${message}`, this._status);\n    }\n  }\n  /**\n   * Authenticates the NDK event by sending it to the NDK relay and returning a promise that resolves with the result.\n   *\n   * @param event - The NDK event to authenticate.\n   * @returns A promise that resolves with the authentication result.\n   */\n  async auth(event) {\n    const ret = new Promise((resolve, reject) => {\n      const val = this.openEventPublishes.get(event.id) ?? [];\n      val.push({ resolve, reject });\n      this.openEventPublishes.set(event.id, val);\n    });\n    this.send(`[\"AUTH\",${JSON.stringify(event.rawEvent())}]`);\n    return ret;\n  }\n  /**\n   * Publishes an NDK event to the relay and returns a promise that resolves with the result.\n   *\n   * @param event - The NDK event to publish.\n   * @returns A promise that resolves with the result of the event publication.\n   * @throws {Error} If attempting to publish on a closed relay connection.\n   */\n  async publish(event) {\n    const ret = new Promise((resolve, reject) => {\n      const val = this.openEventPublishes.get(event.id) ?? [];\n      if (val.length > 0) {\n        console.warn(`Duplicate event publishing detected, you are publishing event ${event.id} twice`);\n      }\n      val.push({ resolve, reject });\n      this.openEventPublishes.set(event.id, val);\n    });\n    this.send(`[\"EVENT\",${JSON.stringify(event)}]`);\n    return ret;\n  }\n  /**\n   * Counts the number of events that match the provided filters.\n   *\n   * @param filters - The filters to apply to the count request.\n   * @param params - An optional object containing a custom id for the count request.\n   * @returns A promise that resolves with the number of matching events.\n   * @throws {Error} If attempting to send the count request on a closed relay connection.\n   */\n  async count(filters, params) {\n    this.serial++;\n    const id = params?.id || `count:${this.serial}`;\n    const ret = new Promise((resolve, reject) => {\n      this.openCountRequests.set(id, { resolve, reject });\n    });\n    this.send(`[\"COUNT\",\"${id}\",${JSON.stringify(filters).substring(1)}`);\n    return ret;\n  }\n  close(subId, reason) {\n    this.send(`[\"CLOSE\",\"${subId}\"]`);\n    const sub = this.openSubs.get(subId);\n    this.openSubs.delete(subId);\n    if (sub) sub.onclose(reason);\n  }\n  /**\n   * Subscribes to the NDK relay with the provided filters and parameters.\n   *\n   * @param filters - The filters to apply to the subscription.\n   * @param params - The subscription parameters, including an optional custom id.\n   * @returns A new NDKRelaySubscription instance.\n   */\n  req(relaySub) {\n    `${this.send(`[\"REQ\",\"${relaySub.subId}\",${JSON.stringify(relaySub.executeFilters).substring(1)}`)}]`;\n    this.openSubs.set(relaySub.subId, relaySub);\n  }\n  /**\n   * Utility functions to update the connection stats.\n   */\n  updateConnectionStats = {\n    connected: () => {\n      this._connectionStats.success++;\n      this._connectionStats.connectedAt = Date.now();\n    },\n    disconnected: () => {\n      if (this._connectionStats.connectedAt) {\n        this._connectionStats.durations.push(Date.now() - this._connectionStats.connectedAt);\n        if (this._connectionStats.durations.length > 100) {\n          this._connectionStats.durations.shift();\n        }\n      }\n      this._connectionStats.connectedAt = void 0;\n    },\n    attempt: () => {\n      this._connectionStats.attempts++;\n      this._connectionStats.connectedAt = Date.now();\n    }\n  };\n  /** Returns the connection stats. */\n  get connectionStats() {\n    return this._connectionStats;\n  }\n  /** Returns the relay URL */\n  get url() {\n    return this.ndkRelay.url;\n  }\n  get connected() {\n    return this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN;\n  }\n};\n\n// src/relay/publisher.ts\nvar NDKRelayPublisher = class {\n  ndkRelay;\n  debug;\n  constructor(ndkRelay) {\n    this.ndkRelay = ndkRelay;\n    this.debug = ndkRelay.debug.extend(\"publisher\");\n  }\n  /**\n   * Published an event to the relay; if the relay is not connected, it will\n   * wait for the relay to connect before publishing the event.\n   *\n   * If the relay does not connect within the timeout, the publish operation\n   * will fail.\n   * @param event  The event to publish\n   * @param timeoutMs  The timeout for the publish operation in milliseconds\n   * @returns A promise that resolves when the event has been published or rejects if the operation times out\n   */\n  async publish(event, timeoutMs = 2500) {\n    let timeout;\n    const publishConnected = () => {\n      return new Promise((resolve, reject) => {\n        try {\n          this.publishEvent(event).then((_result) => {\n            this.ndkRelay.emit(\"published\", event);\n            event.emit(\"relay:published\", this.ndkRelay);\n            resolve(true);\n          }).catch(reject);\n        } catch (err) {\n          reject(err);\n        }\n      });\n    };\n    const timeoutPromise = new Promise((_, reject) => {\n      timeout = setTimeout(() => {\n        timeout = void 0;\n        reject(new Error(`Timeout: ${timeoutMs}ms`));\n      }, timeoutMs);\n    });\n    const onConnectHandler = () => {\n      publishConnected().then((result) => connectResolve(result)).catch((err) => connectReject(err));\n    };\n    let connectResolve;\n    let connectReject;\n    const onError = (err) => {\n      this.ndkRelay.debug(\"Publish failed\", err, event.id);\n      this.ndkRelay.emit(\"publish:failed\", event, err);\n      event.emit(\"relay:publish:failed\", this.ndkRelay, err);\n      throw err;\n    };\n    const onFinally = () => {\n      if (timeout) clearTimeout(timeout);\n      this.ndkRelay.removeListener(\"connect\", onConnectHandler);\n    };\n    if (this.ndkRelay.status >= 5 /* CONNECTED */) {\n      return Promise.race([publishConnected(), timeoutPromise]).catch(onError).finally(onFinally);\n    }\n    if (this.ndkRelay.status <= 1 /* DISCONNECTED */) {\n      console.warn(\"Relay is disconnected, trying to connect to publish an event\", this.ndkRelay.url);\n      this.ndkRelay.connect();\n    } else {\n      console.warn(\"Relay not connected, waiting for connection to publish an event\", this.ndkRelay.url);\n    }\n    return Promise.race([\n      new Promise((resolve, reject) => {\n        connectResolve = resolve;\n        connectReject = reject;\n        this.ndkRelay.once(\"connect\", onConnectHandler);\n      }),\n      timeoutPromise\n    ]).catch(onError).finally(onFinally);\n  }\n  async publishEvent(event) {\n    return this.ndkRelay.connectivity.publish(event.rawEvent());\n  }\n};\n\n// src/subscription/grouping.ts\nfunction filterFingerprint(filters, closeOnEose) {\n  const elements = [];\n  for (const filter of filters) {\n    const keys = Object.entries(filter || {}).map(([key, values]) => {\n      if ([\"since\", \"until\"].includes(key)) {\n        return `${key}:${values}`;\n      }\n      return key;\n    }).sort().join(\"-\");\n    elements.push(keys);\n  }\n  let id = closeOnEose ? \"+\" : \"\";\n  id += elements.join(\"|\");\n  return id;\n}\nfunction mergeFilters(filters) {\n  const result = [];\n  const lastResult = {};\n  filters.filter((f) => !!f.limit).forEach((filterWithLimit) => result.push(filterWithLimit));\n  filters = filters.filter((f) => !f.limit);\n  if (filters.length === 0) return result;\n  filters.forEach((filter) => {\n    Object.entries(filter).forEach(([key, value]) => {\n      if (Array.isArray(value)) {\n        if (lastResult[key] === void 0) {\n          lastResult[key] = [...value];\n        } else {\n          lastResult[key] = Array.from(/* @__PURE__ */ new Set([...lastResult[key], ...value]));\n        }\n      } else {\n        lastResult[key] = value;\n      }\n    });\n  });\n  return [...result, lastResult];\n}\n\n// src/relay/subscription.ts\nvar NDKRelaySubscription = class {\n  fingerprint;\n  items = /* @__PURE__ */ new Map();\n  topSubManager;\n  debug;\n  /**\n   * Tracks the status of this REQ.\n   */\n  status = 0 /* INITIAL */;\n  onClose;\n  relay;\n  /**\n   * Whether this subscription has reached EOSE.\n   */\n  eosed = false;\n  /**\n   * Timeout at which this subscription will\n   * start executing.\n   */\n  executionTimer;\n  /**\n   * Track the time at which this subscription will fire.\n   */\n  fireTime;\n  /**\n   * The delay type that the current fireTime was calculated with.\n   */\n  delayType;\n  /**\n   * The filters that have been executed.\n   */\n  executeFilters;\n  id = Math.random().toString(36).substring(7);\n  /**\n   *\n   * @param fingerprint The fingerprint of this subscription.\n   */\n  constructor(relay, fingerprint, topSubManager) {\n    this.relay = relay;\n    this.topSubManager = topSubManager;\n    this.debug = relay.debug.extend(`sub[${this.id}]`);\n    this.fingerprint = fingerprint || Math.random().toString(36).substring(7);\n  }\n  _subId;\n  get subId() {\n    if (this._subId) return this._subId;\n    this._subId = this.fingerprint.slice(0, 15);\n    return this._subId;\n  }\n  subIdParts = /* @__PURE__ */ new Set();\n  addSubIdPart(part) {\n    this.subIdParts.add(part);\n  }\n  addItem(subscription, filters) {\n    this.debug(\"Adding item\", {\n      filters,\n      internalId: subscription.internalId,\n      status: this.status,\n      fingerprint: this.fingerprint,\n      id: this.subId,\n      items: this.items,\n      itemsSize: this.items.size\n    });\n    if (this.items.has(subscription.internalId)) return;\n    subscription.on(\"close\", this.removeItem.bind(this, subscription));\n    this.items.set(subscription.internalId, { subscription, filters });\n    if (this.status !== 3 /* RUNNING */) {\n      if (subscription.subId && (!this._subId || this._subId.length < 48)) {\n        if (this.status === 0 /* INITIAL */ || this.status === 1 /* PENDING */) {\n          this.addSubIdPart(subscription.subId);\n        }\n      }\n    }\n    switch (this.status) {\n      case 0 /* INITIAL */:\n        this.evaluateExecutionPlan(subscription);\n        break;\n      case 3 /* RUNNING */:\n        break;\n      case 1 /* PENDING */:\n        this.evaluateExecutionPlan(subscription);\n        break;\n      case 4 /* CLOSED */:\n        this.debug(\"Subscription is closed, cannot add new items %o (%o)\", subscription, filters);\n        throw new Error(\"Cannot add new items to a closed subscription\");\n    }\n  }\n  /**\n   * A subscription has been closed, remove it from the list of items.\n   * @param subscription\n   */\n  removeItem(subscription) {\n    this.items.delete(subscription.internalId);\n    if (this.items.size === 0) {\n      if (!this.eosed) return;\n      this.close();\n      this.cleanup();\n    }\n  }\n  close() {\n    if (this.status === 4 /* CLOSED */) return;\n    const prevStatus = this.status;\n    this.status = 4 /* CLOSED */;\n    if (prevStatus === 3 /* RUNNING */) {\n      try {\n        this.relay.close(this.subId);\n      } catch (e) {\n        this.debug(\"Error closing subscription\", e, this);\n      }\n    } else {\n      this.debug(\"Subscription wanted to close but it wasn't running, this is probably ok\", {\n        subId: this.subId,\n        prevStatus,\n        sub: this\n      });\n    }\n    this.cleanup();\n  }\n  cleanup() {\n    if (this.executionTimer) clearTimeout(this.executionTimer);\n    this.relay.off(\"ready\", this.executeOnRelayReady);\n    this.relay.off(\"authed\", this.reExecuteAfterAuth);\n    if (this.onClose) this.onClose(this);\n  }\n  evaluateExecutionPlan(subscription) {\n    if (!subscription.isGroupable()) {\n      this.status = 1 /* PENDING */;\n      this.execute();\n      return;\n    }\n    if (subscription.filters.find((filter) => !!filter.limit)) {\n      this.executeFilters = this.compileFilters();\n      if (this.executeFilters.length >= 10) {\n        this.status = 1 /* PENDING */;\n        this.execute();\n        return;\n      }\n    }\n    const delay = subscription.groupableDelay;\n    const delayType = subscription.groupableDelayType;\n    if (!delay) throw new Error(\"Cannot group a subscription without a delay\");\n    if (this.status === 0 /* INITIAL */) {\n      this.schedule(delay, delayType);\n    } else {\n      const existingDelayType = this.delayType;\n      const timeUntilFire = this.fireTime - Date.now();\n      if (existingDelayType === \"at-least\" && delayType === \"at-least\") {\n        if (timeUntilFire < delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-least\" && delayType === \"at-most\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-most\" && delayType === \"at-most\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-most\" && delayType === \"at-least\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else {\n        throw new Error(`Unknown delay type combination ${existingDelayType} ${delayType}`);\n      }\n    }\n  }\n  schedule(delay, delayType) {\n    this.status = 1 /* PENDING */;\n    const currentTime = Date.now();\n    this.fireTime = currentTime + delay;\n    this.delayType = delayType;\n    const timer = setTimeout(this.execute.bind(this), delay);\n    if (delayType === \"at-least\") {\n      this.executionTimer = timer;\n    }\n  }\n  executeOnRelayReady = () => {\n    if (this.status !== 2 /* WAITING */) return;\n    if (this.items.size === 0) {\n      this.debug(\"No items to execute; this relay was probably too slow to respond and the caller gave up\", {\n        status: this.status,\n        fingerprint: this.fingerprint,\n        items: this.items,\n        itemsSize: this.items.size,\n        id: this.id,\n        subId: this.subId\n      });\n      this.cleanup();\n      return;\n    }\n    this.debug(\"Executing on relay ready\", {\n      status: this.status,\n      fingerprint: this.fingerprint,\n      items: this.items,\n      itemsSize: this.items.size\n    });\n    this.status = 1 /* PENDING */;\n    this.execute();\n  };\n  finalizeSubId() {\n    if (this.subIdParts.size > 0) {\n      this._subId = Array.from(this.subIdParts).join(\"-\");\n    } else {\n      this._subId = this.fingerprint.slice(0, 15);\n    }\n    this._subId += `-${Math.random().toString(36).substring(2, 7)}`;\n  }\n  // we do it this way so that we can remove the listener\n  reExecuteAfterAuth = (() => {\n    const oldSubId = this.subId;\n    this.debug(\"Re-executing after auth\", this.items.size);\n    if (this.eosed) {\n      this.relay.close(this.subId);\n    } else {\n      this.debug(\"We are abandoning an opened subscription, once it EOSE's, the handler will close it\", {\n        oldSubId\n      });\n    }\n    this._subId = void 0;\n    this.status = 1 /* PENDING */;\n    this.execute();\n    this.debug(\"Re-executed after auth %s \\u{1F449} %s\", oldSubId, this.subId);\n  }).bind(this);\n  execute() {\n    if (this.status !== 1 /* PENDING */) {\n      return;\n    }\n    if (!this.relay.connected) {\n      this.status = 2 /* WAITING */;\n      this.debug(\"Waiting for relay to be ready\", {\n        status: this.status,\n        id: this.subId,\n        fingerprint: this.fingerprint,\n        items: this.items,\n        itemsSize: this.items.size\n      });\n      this.relay.once(\"ready\", this.executeOnRelayReady);\n      return;\n    }\n    if (this.relay.status < 8 /* AUTHENTICATED */) {\n      this.relay.once(\"authed\", this.reExecuteAfterAuth);\n    }\n    this.status = 3 /* RUNNING */;\n    this.finalizeSubId();\n    this.executeFilters = this.compileFilters();\n    this.relay.req(this);\n  }\n  onstart() {\n  }\n  onevent(event) {\n    this.topSubManager.dispatchEvent(event, this.relay);\n  }\n  oneose(subId) {\n    this.eosed = true;\n    if (subId !== this.subId) {\n      this.debug(\"Received EOSE for an abandoned subscription\", subId, this.subId);\n      this.relay.close(subId);\n      return;\n    }\n    if (this.items.size === 0) {\n      this.close();\n    }\n    for (const { subscription } of this.items.values()) {\n      subscription.eoseReceived(this.relay);\n      if (subscription.closeOnEose) {\n        this.debug(\"Removing item because of EOSE\", {\n          filters: subscription.filters,\n          internalId: subscription.internalId,\n          status: this.status,\n          fingerprint: this.fingerprint,\n          items: this.items,\n          itemsSize: this.items.size\n        });\n        this.removeItem(subscription);\n      }\n    }\n  }\n  onclose(_reason) {\n    this.status = 4 /* CLOSED */;\n  }\n  onclosed(reason) {\n    if (!reason) return;\n    for (const { subscription } of this.items.values()) {\n      subscription.closedReceived(this.relay, reason);\n    }\n  }\n  /**\n   * Grabs the filters from all the subscriptions\n   * and merges them into a single filter.\n   */\n  compileFilters() {\n    const mergedFilters = [];\n    const filters = Array.from(this.items.values()).map((item) => item.filters);\n    if (!filters[0]) {\n      this.debug(\"\\u{1F440} No filters to merge\", this.items);\n      console.error(\"BUG: No filters to merge!\", this.items);\n      return [];\n    }\n    const filterCount = filters[0].length;\n    for (let i = 0; i < filterCount; i++) {\n      const allFiltersAtIndex = filters.map((filter) => filter[i]);\n      mergedFilters.push(...mergeFilters(allFiltersAtIndex));\n    }\n    return mergedFilters;\n  }\n};\n\n// src/relay/sub-manager.ts\nvar NDKRelaySubscriptionManager = class {\n  relay;\n  subscriptions;\n  generalSubManager;\n  /**\n   * @param relay - The relay instance.\n   * @param generalSubManager - The subscription manager instance.\n   */\n  constructor(relay, generalSubManager) {\n    this.relay = relay;\n    this.subscriptions = /* @__PURE__ */ new Map();\n    this.generalSubManager = generalSubManager;\n  }\n  /**\n   * Adds a subscription to the manager.\n   */\n  addSubscription(sub, filters) {\n    let relaySub;\n    if (!sub.isGroupable()) {\n      relaySub = this.createSubscription(sub, filters);\n    } else {\n      const filterFp = filterFingerprint(filters, sub.closeOnEose);\n      if (filterFp) {\n        const existingSubs = this.subscriptions.get(filterFp);\n        relaySub = (existingSubs || []).find((sub2) => sub2.status < 3 /* RUNNING */);\n      }\n      relaySub ??= this.createSubscription(sub, filters, filterFp);\n    }\n    relaySub.addItem(sub, filters);\n  }\n  createSubscription(_sub, _filters, fingerprint) {\n    const relaySub = new NDKRelaySubscription(this.relay, fingerprint || null, this.generalSubManager);\n    relaySub.onClose = this.onRelaySubscriptionClose.bind(this);\n    const currentVal = this.subscriptions.get(relaySub.fingerprint) ?? [];\n    this.subscriptions.set(relaySub.fingerprint, [...currentVal, relaySub]);\n    return relaySub;\n  }\n  onRelaySubscriptionClose(sub) {\n    let currentVal = this.subscriptions.get(sub.fingerprint) ?? [];\n    if (!currentVal) {\n      console.warn(\"Unexpectedly did not find a subscription with fingerprint\", sub.fingerprint);\n    } else if (currentVal.length === 1) {\n      this.subscriptions.delete(sub.fingerprint);\n    } else {\n      currentVal = currentVal.filter((s) => s.id !== sub.id);\n      this.subscriptions.set(sub.fingerprint, currentVal);\n    }\n  }\n};\n\n// src/relay/index.ts\nvar NDKRelayStatus = /* @__PURE__ */ ((NDKRelayStatus2) => {\n  NDKRelayStatus2[NDKRelayStatus2[\"DISCONNECTING\"] = 0] = \"DISCONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"DISCONNECTED\"] = 1] = \"DISCONNECTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"FLAPPING\"] = 3] = \"FLAPPING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"CONNECTING\"] = 4] = \"CONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"CONNECTED\"] = 5] = \"CONNECTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTH_REQUESTED\"] = 6] = \"AUTH_REQUESTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTHENTICATING\"] = 7] = \"AUTHENTICATING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTHENTICATED\"] = 8] = \"AUTHENTICATED\";\n  return NDKRelayStatus2;\n})(NDKRelayStatus || {});\nvar NDKRelay = class _NDKRelay extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  url;\n  scores;\n  connectivity;\n  subs;\n  publisher;\n  authPolicy;\n  /**\n   * The lowest validation ratio this relay can reach.\n   */\n  lowestValidationRatio;\n  /**\n   * Current validation ratio this relay is targeting.\n   */\n  targetValidationRatio;\n  validationRatioFn;\n  /**\n   * This tracks events that have been seen by this relay\n   * with a valid signature.\n   */\n  validatedEventCount = 0;\n  /**\n   * This tracks events that have been seen by this relay\n   * but have not been validated.\n   */\n  nonValidatedEventCount = 0;\n  /**\n   * Whether this relay is trusted.\n   *\n   * Trusted relay's events do not get their signature verified.\n   */\n  trusted = false;\n  complaining = false;\n  debug;\n  static defaultValidationRatioUpdateFn = (relay, validatedCount, _nonValidatedCount) => {\n    if (relay.lowestValidationRatio === void 0 || relay.targetValidationRatio === void 0) return 1;\n    let newRatio = relay.validationRatio;\n    if (relay.validationRatio > relay.targetValidationRatio) {\n      const factor = validatedCount / 100;\n      newRatio = Math.max(relay.lowestValidationRatio, relay.validationRatio - factor);\n    }\n    if (newRatio < relay.validationRatio) {\n      return newRatio;\n    }\n    return relay.validationRatio;\n  };\n  constructor(url, authPolicy, ndk) {\n    super();\n    this.url = normalizeRelayUrl(url);\n    this.scores = /* @__PURE__ */ new Map();\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_1__(`ndk:relay:${url}`);\n    this.connectivity = new NDKRelayConnectivity(this, ndk);\n    this.connectivity.netDebug = ndk?.netDebug;\n    this.req = this.connectivity.req.bind(this.connectivity);\n    this.close = this.connectivity.close.bind(this.connectivity);\n    this.subs = new NDKRelaySubscriptionManager(this, ndk.subManager);\n    this.publisher = new NDKRelayPublisher(this);\n    this.authPolicy = authPolicy;\n    this.targetValidationRatio = ndk?.initialValidationRatio;\n    this.lowestValidationRatio = ndk?.lowestValidationRatio;\n    this.validationRatioFn = (ndk?.validationRatioFn ?? _NDKRelay.defaultValidationRatioUpdateFn).bind(this);\n    this.updateValidationRatio();\n    if (!ndk) {\n      console.trace(\"relay created without ndk\");\n    }\n  }\n  updateValidationRatio() {\n    setTimeout(() => {\n      this.updateValidationRatio();\n    }, 3e4);\n  }\n  get status() {\n    return this.connectivity.status;\n  }\n  get connectionStats() {\n    return this.connectivity.connectionStats;\n  }\n  /**\n   * Connects to the relay.\n   */\n  async connect(timeoutMs, reconnect = true) {\n    return this.connectivity.connect(timeoutMs, reconnect);\n  }\n  /**\n   * Disconnects from the relay.\n   */\n  disconnect() {\n    if (this.status === 1 /* DISCONNECTED */) {\n      return;\n    }\n    this.connectivity.disconnect();\n  }\n  /**\n   * Queues or executes the subscription of a specific set of filters\n   * within this relay.\n   *\n   * @param subscription NDKSubscription this filters belong to.\n   * @param filters Filters to execute\n   */\n  subscribe(subscription, filters) {\n    this.subs.addSubscription(subscription, filters);\n  }\n  /**\n   * Publishes an event to the relay with an optional timeout.\n   *\n   * If the relay is not connected, the event will be published when the relay connects,\n   * unless the timeout is reached before the relay connects.\n   *\n   * @param event The event to publish\n   * @param timeoutMs The timeout for the publish operation in milliseconds\n   * @returns A promise that resolves when the event has been published or rejects if the operation times out\n   */\n  async publish(event, timeoutMs = 2500) {\n    return this.publisher.publish(event, timeoutMs);\n  }\n  referenceTags() {\n    return [[\"r\", this.url]];\n  }\n  addValidatedEvent() {\n    this.validatedEventCount++;\n  }\n  addNonValidatedEvent() {\n    this.nonValidatedEventCount++;\n  }\n  /**\n   * The current validation ratio this relay has achieved.\n   */\n  get validationRatio() {\n    if (this.nonValidatedEventCount === 0) {\n      return 1;\n    }\n    return this.validatedEventCount / (this.validatedEventCount + this.nonValidatedEventCount);\n  }\n  shouldValidateEvent() {\n    if (this.trusted) {\n      return false;\n    }\n    if (this.targetValidationRatio === void 0) {\n      return true;\n    }\n    return this.validationRatio < this.targetValidationRatio;\n  }\n  get connected() {\n    return this.connectivity.connected;\n  }\n  req;\n  close;\n};\n\n// src/relay/sets/index.ts\nvar NDKPublishError = class extends Error {\n  errors;\n  publishedToRelays;\n  /**\n   * Intended relay set where the publishing was intended to happen.\n   */\n  intendedRelaySet;\n  constructor(message, errors, publishedToRelays, intendedRelaySet) {\n    super(message);\n    this.errors = errors;\n    this.publishedToRelays = publishedToRelays;\n    this.intendedRelaySet = intendedRelaySet;\n  }\n  get relayErrors() {\n    const errors = [];\n    for (const [relay, err] of this.errors) {\n      errors.push(`${relay.url}: ${err}`);\n    }\n    return errors.join(\"\\n\");\n  }\n};\nvar NDKRelaySet = class _NDKRelaySet {\n  relays;\n  debug;\n  ndk;\n  pool;\n  constructor(relays, ndk, pool) {\n    this.relays = relays;\n    this.ndk = ndk;\n    this.pool = pool ?? ndk.pool;\n    this.debug = ndk.debug.extend(\"relayset\");\n  }\n  /**\n   * Adds a relay to this set.\n   */\n  addRelay(relay) {\n    this.relays.add(relay);\n  }\n  get relayUrls() {\n    return Array.from(this.relays).map((r) => r.url);\n  }\n  /**\n   * Creates a relay set from a list of relay URLs.\n   *\n   * If no connection to the relay is found in the pool it will temporarily\n   * connect to it.\n   *\n   * @param relayUrls - list of relay URLs to include in this set\n   * @param ndk\n   * @param connect - whether to connect to the relay immediately if it was already in the pool but not connected\n   * @returns NDKRelaySet\n   */\n  static fromRelayUrls(relayUrls, ndk, connect = true, pool) {\n    pool = pool ?? ndk.pool;\n    if (!pool) throw new Error(\"No pool provided\");\n    const relays = /* @__PURE__ */ new Set();\n    for (const url of relayUrls) {\n      const relay = pool.relays.get(normalizeRelayUrl(url));\n      if (relay) {\n        if (relay.status < 5 /* CONNECTED */ && connect) {\n          relay.connect();\n        }\n        relays.add(relay);\n      } else {\n        const temporaryRelay = new NDKRelay(normalizeRelayUrl(url), ndk?.relayAuthDefaultPolicy, ndk);\n        pool.useTemporaryRelay(temporaryRelay, void 0, `requested from fromRelayUrls ${relayUrls}`);\n        relays.add(temporaryRelay);\n      }\n    }\n    return new _NDKRelaySet(new Set(relays), ndk, pool);\n  }\n  /**\n   * Publish an event to all relays in this relay set.\n   *\n   * This method implements a robust mechanism for publishing events to multiple relays with\n   * built-in handling for race conditions, timeouts, and partial failures. The implementation\n   * uses a dual-tracking mechanism to ensure accurate reporting of which relays successfully\n   * received an event.\n   *\n   * Key aspects of this implementation:\n   *\n   * 1. DUAL-TRACKING MECHANISM:\n   *    - Promise-based tracking: Records successes/failures from the promises returned by relay.publish()\n   *    - Event-based tracking: Listens for 'relay:published' events that indicate successful publishing\n   *    This approach ensures we don't miss successful publishes even if there are subsequent errors in\n   *    the promise chain.\n   *\n   * 2. RACE CONDITION HANDLING:\n   *    - If a relay emits a success event but later fails in the promise chain, we still count it as a success\n   *    - If a relay times out after successfully publishing, we still count it as a success\n   *    - All relay operations happen in parallel, with proper tracking regardless of completion order\n   *\n   * 3. TIMEOUT MANAGEMENT:\n   *    - Individual timeouts for each relay operation\n   *    - Proper cleanup of timeouts to prevent memory leaks\n   *    - Clear timeout error reporting\n   *\n   * 4. ERROR HANDLING:\n   *    - Detailed tracking of specific errors for each failed relay\n   *    - Special handling for ephemeral events (which don't expect acknowledgement)\n   *    - RequiredRelayCount parameter to control the minimum success threshold\n   *\n   * @param event Event to publish\n   * @param timeoutMs Timeout in milliseconds for each relay publish operation\n   * @param requiredRelayCount The minimum number of relays we expect the event to be published to\n   * @returns A set of relays the event was published to\n   * @throws {NDKPublishError} If the event could not be published to at least `requiredRelayCount` relays\n   * @example\n   * ```typescript\n   * const relaySet = new NDKRelaySet(new Set([relay1, relay2]), ndk);\n   * const publishedToRelays = await relaySet.publish(event);\n   * // publishedToRelays can contain relay1, relay2, both, or none\n   * // depending on which relays the event was successfully published to\n   * if (publishedToRelays.size > 0) {\n   *   console.log(\"Event published to at least one relay\");\n   * }\n   * ```\n   */\n  async publish(event, timeoutMs, requiredRelayCount = 1) {\n    const publishedToRelays = /* @__PURE__ */ new Set();\n    const errors = /* @__PURE__ */ new Map();\n    const isEphemeral2 = event.isEphemeral();\n    event.publishStatus = \"pending\";\n    const relayPublishedHandler = (relay) => {\n      publishedToRelays.add(relay);\n    };\n    event.on(\"relay:published\", relayPublishedHandler);\n    try {\n      const promises = Array.from(this.relays).map((relay) => {\n        return new Promise((resolve) => {\n          const timeoutId = timeoutMs ? setTimeout(() => {\n            if (!publishedToRelays.has(relay)) {\n              errors.set(relay, new Error(`Publish timeout after ${timeoutMs}ms`));\n              resolve(false);\n            }\n          }, timeoutMs) : null;\n          relay.publish(event, timeoutMs).then((success) => {\n            if (timeoutId) clearTimeout(timeoutId);\n            if (success) {\n              publishedToRelays.add(relay);\n              resolve(true);\n            } else {\n              resolve(false);\n            }\n          }).catch((err) => {\n            if (timeoutId) clearTimeout(timeoutId);\n            if (!isEphemeral2) {\n              errors.set(relay, err);\n            }\n            resolve(false);\n          });\n        });\n      });\n      await Promise.all(promises);\n      if (publishedToRelays.size < requiredRelayCount) {\n        if (!isEphemeral2) {\n          const error = new NDKPublishError(\n            \"Not enough relays received the event\",\n            errors,\n            publishedToRelays,\n            this\n          );\n          event.publishStatus = \"error\";\n          event.publishError = error;\n          this.ndk?.emit(\"event:publish-failed\", event, error, this.relayUrls);\n          throw error;\n        }\n      } else {\n        event.publishStatus = \"success\";\n        event.emit(\"published\", { relaySet: this, publishedToRelays });\n      }\n      return publishedToRelays;\n    } finally {\n      event.off(\"relay:published\", relayPublishedHandler);\n    }\n  }\n  get size() {\n    return this.relays.size;\n  }\n};\n\n// src/relay/sets/calculate.ts\nvar d = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:outbox:calculate\");\nasync function calculateRelaySetFromEvent(ndk, event) {\n  const relays = /* @__PURE__ */ new Set();\n  const authorWriteRelays = await getWriteRelaysFor(ndk, event.pubkey);\n  if (authorWriteRelays) {\n    authorWriteRelays.forEach((relayUrl) => {\n      const relay = ndk.pool?.getRelay(relayUrl);\n      if (relay) relays.add(relay);\n    });\n  }\n  let relayHints = event.tags.filter((tag) => [\"a\", \"e\"].includes(tag[0])).map((tag) => tag[2]).filter((url) => url?.startsWith(\"wss://\")).filter((url) => {\n    try {\n      new URL(url);\n      return true;\n    } catch {\n      return false;\n    }\n  }).map((url) => normalizeRelayUrl(url));\n  relayHints = Array.from(new Set(relayHints)).slice(0, 5);\n  relayHints.forEach((relayUrl) => {\n    const relay = ndk.pool?.getRelay(relayUrl, true, true);\n    if (relay) {\n      d(\"Adding relay hint %s\", relayUrl);\n      relays.add(relay);\n    }\n  });\n  const pTags = event.getMatchingTags(\"p\").map((tag) => tag[1]);\n  if (pTags.length < 5) {\n    const pTaggedRelays = Array.from(\n      chooseRelayCombinationForPubkeys(ndk, pTags, \"read\", {\n        preferredRelays: new Set(authorWriteRelays)\n      }).keys()\n    );\n    pTaggedRelays.forEach((relayUrl) => {\n      const relay = ndk.pool?.getRelay(relayUrl, false, true);\n      if (relay) {\n        d(\"Adding p-tagged relay %s\", relayUrl);\n        relays.add(relay);\n      }\n    });\n  } else {\n    d(\"Too many p-tags to consider %d\", pTags.length);\n  }\n  ndk.pool?.permanentAndConnectedRelays().forEach((relay) => relays.add(relay));\n  return new NDKRelaySet(relays, ndk);\n}\nfunction calculateRelaySetsFromFilter(ndk, filters, pool) {\n  const result = /* @__PURE__ */ new Map();\n  const authors = /* @__PURE__ */ new Set();\n  filters.forEach((filter) => {\n    if (filter.authors) {\n      filter.authors.forEach((author) => authors.add(author));\n    }\n  });\n  if (authors.size > 0) {\n    const authorToRelaysMap = getRelaysForFilterWithAuthors(ndk, Array.from(authors));\n    for (const relayUrl of authorToRelaysMap.keys()) {\n      result.set(relayUrl, []);\n    }\n    for (const filter of filters) {\n      if (filter.authors) {\n        for (const [relayUrl, authors2] of authorToRelaysMap.entries()) {\n          const authorFilterAndRelayPubkeyIntersection = filter.authors.filter(\n            (author) => authors2.includes(author)\n          );\n          result.set(relayUrl, [\n            ...result.get(relayUrl),\n            {\n              ...filter,\n              // Overwrite authors sent to this relay with the authors that were\n              // present in the filter and are also present in the relay\n              authors: authorFilterAndRelayPubkeyIntersection\n            }\n          ]);\n        }\n      } else {\n        for (const relayUrl of authorToRelaysMap.keys()) {\n          result.set(relayUrl, [...result.get(relayUrl), filter]);\n        }\n      }\n    }\n  } else {\n    if (ndk.explicitRelayUrls) {\n      ndk.explicitRelayUrls.forEach((relayUrl) => {\n        result.set(relayUrl, filters);\n      });\n    }\n  }\n  if (result.size === 0) {\n    pool.permanentAndConnectedRelays().slice(0, 5).forEach((relay) => {\n      result.set(relay.url, filters);\n    });\n  }\n  return result;\n}\nfunction calculateRelaySetsFromFilters(ndk, filters, pool) {\n  const a = calculateRelaySetsFromFilter(ndk, filters, pool);\n  return a;\n}\n\n// src/events/content-tagger.ts\n\nfunction mergeTags(tags1, tags2) {\n  const tagMap = /* @__PURE__ */ new Map();\n  const generateKey = (tag) => tag.join(\",\");\n  const isContained = (smaller, larger) => {\n    return smaller.every((value, index) => value === larger[index]);\n  };\n  const processTag = (tag) => {\n    for (const [key, existingTag] of tagMap) {\n      if (isContained(existingTag, tag) || isContained(tag, existingTag)) {\n        if (tag.length >= existingTag.length) {\n          tagMap.set(key, tag);\n        }\n        return;\n      }\n    }\n    tagMap.set(generateKey(tag), tag);\n  };\n  tags1.concat(tags2).forEach(processTag);\n  return Array.from(tagMap.values());\n}\nfunction uniqueTag(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  const sameLength = aLength === bLength;\n  if (sameLength) {\n    if (a.every((v, i) => v === b[i])) {\n      return [a];\n    }\n    return [a, b];\n  }\n  if (aLength > bLength && a.every((v, i) => v === b[i])) {\n    return [a];\n  }\n  if (bLength > aLength && b.every((v, i) => v === a[i])) {\n    return [b];\n  }\n  return [a, b];\n}\nvar hashtagRegex = /(?<=\\s|^)(#[^\\s!@#$%^&*()=+./,[{\\]};:'\"?><]+)/g;\nfunction generateHashtags(content) {\n  const hashtags = content.match(hashtagRegex);\n  const tagIds = /* @__PURE__ */ new Set();\n  const tag = /* @__PURE__ */ new Set();\n  if (hashtags) {\n    for (const hashtag of hashtags) {\n      if (tagIds.has(hashtag.slice(1))) continue;\n      tag.add(hashtag.slice(1));\n      tagIds.add(hashtag.slice(1));\n    }\n  }\n  return Array.from(tag);\n}\nasync function generateContentTags(content, tags = []) {\n  const tagRegex = /(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g;\n  const promises = [];\n  const addTagIfNew = (t) => {\n    if (!tags.find((t2) => [\"q\", t[0]].includes(t2[0]) && t2[1] === t[1])) {\n      tags.push(t);\n    }\n  };\n  content = content.replace(tagRegex, (tag) => {\n    try {\n      const entity = tag.split(/(@|nostr:)/)[2];\n      const { type, data } = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(entity);\n      let t;\n      switch (type) {\n        case \"npub\":\n          t = [\"p\", data];\n          break;\n        case \"nprofile\":\n          t = [\"p\", data.pubkey];\n          break;\n        case \"note\":\n          promises.push(\n            new Promise(async (resolve) => {\n              addTagIfNew([\"q\", data, await maybeGetEventRelayUrl(entity)]);\n              resolve();\n            })\n          );\n          break;\n        case \"nevent\":\n          promises.push(\n            new Promise(async (resolve) => {\n              const { id, author } = data;\n              let { relays } = data;\n              if (!relays || relays.length === 0) {\n                relays = [await maybeGetEventRelayUrl(entity)];\n              }\n              addTagIfNew([\"q\", id, relays[0]]);\n              if (author) addTagIfNew([\"p\", author]);\n              resolve();\n            })\n          );\n          break;\n        case \"naddr\":\n          promises.push(\n            new Promise(async (resolve) => {\n              const id = [data.kind, data.pubkey, data.identifier].join(\":\");\n              let relays = data.relays ?? [];\n              if (relays.length === 0) {\n                relays = [await maybeGetEventRelayUrl(entity)];\n              }\n              addTagIfNew([\"q\", id, relays[0]]);\n              addTagIfNew([\"p\", data.pubkey]);\n              resolve();\n            })\n          );\n          break;\n        default:\n          return tag;\n      }\n      if (t) addTagIfNew(t);\n      return `nostr:${entity}`;\n    } catch (_error) {\n      return tag;\n    }\n  });\n  await Promise.all(promises);\n  const newTags = generateHashtags(content).map((hashtag) => [\"t\", hashtag]);\n  tags = mergeTags(tags, newTags);\n  return { content, tags };\n}\nasync function maybeGetEventRelayUrl(_nip19Id) {\n  return \"\";\n}\n\n// src/events/encryption.ts\nasync function encrypt(recipient, signer, scheme = \"nip44\") {\n  let encrypted;\n  if (!this.ndk) throw new Error(\"No NDK instance found!\");\n  let currentSigner = signer;\n  if (!currentSigner) {\n    this.ndk.assertSigner();\n    currentSigner = this.ndk.signer;\n  }\n  if (!currentSigner) throw new Error(\"no NDK signer\");\n  const currentRecipient = recipient || (() => {\n    const pTags = this.getMatchingTags(\"p\");\n    if (pTags.length !== 1) {\n      throw new Error(\"No recipient could be determined and no explicit recipient was provided\");\n    }\n    return this.ndk.getUser({ pubkey: pTags[0][1] });\n  })();\n  if (scheme === \"nip44\" && await isEncryptionEnabled(currentSigner, \"nip44\")) {\n    encrypted = await currentSigner.encrypt(currentRecipient, this.content, \"nip44\");\n  }\n  if ((!encrypted || scheme === \"nip04\") && await isEncryptionEnabled(currentSigner, \"nip04\")) {\n    encrypted = await currentSigner.encrypt(currentRecipient, this.content, \"nip04\");\n  }\n  if (!encrypted) throw new Error(\"Failed to encrypt event.\");\n  this.content = encrypted;\n}\nasync function decrypt(sender, signer, scheme) {\n  if (this.ndk?.cacheAdapter?.getDecryptedEvent) {\n    let cachedEvent = null;\n    if (typeof this.ndk.cacheAdapter.getDecryptedEvent === \"function\") {\n      cachedEvent = this.ndk.cacheAdapter.getDecryptedEvent(this.id);\n    }\n    if (cachedEvent) {\n      this.content = cachedEvent.content;\n      return;\n    }\n  }\n  let decrypted;\n  if (!this.ndk) throw new Error(\"No NDK instance found!\");\n  let currentSigner = signer;\n  if (!currentSigner) {\n    this.ndk.assertSigner();\n    currentSigner = this.ndk.signer;\n  }\n  if (!currentSigner) throw new Error(\"no NDK signer\");\n  const currentSender = sender || this.author;\n  if (!currentSender) throw new Error(\"No sender provided and no author available\");\n  const currentScheme = scheme || (this.content.match(/\\\\?iv=/) ? \"nip04\" : \"nip44\");\n  if ((currentScheme === \"nip04\" || this.kind === 4) && await isEncryptionEnabled(currentSigner, \"nip04\") && this.content.search(\"\\\\?iv=\")) {\n    decrypted = await currentSigner.decrypt(currentSender, this.content, \"nip04\");\n  }\n  if (!decrypted && currentScheme === \"nip44\" && await isEncryptionEnabled(currentSigner, \"nip44\")) {\n    decrypted = await currentSigner.decrypt(currentSender, this.content, \"nip44\");\n  }\n  if (!decrypted) throw new Error(\"Failed to decrypt event.\");\n  this.content = decrypted;\n  if (this.ndk?.cacheAdapter?.addDecryptedEvent) {\n    this.ndk.cacheAdapter.addDecryptedEvent(this);\n  }\n}\nasync function isEncryptionEnabled(signer, scheme) {\n  if (!signer.encryptionEnabled) return false;\n  if (!scheme) return true;\n  return Boolean(await signer.encryptionEnabled(scheme));\n}\n\n// src/thread/index.ts\nfunction eventsBySameAuthor(op, events) {\n  const eventsByAuthor = /* @__PURE__ */ new Map();\n  eventsByAuthor.set(op.id, op);\n  events.forEach((event) => {\n    if (event.pubkey === op.pubkey) {\n      eventsByAuthor.set(event.id, event);\n    }\n  });\n  return eventsByAuthor;\n}\nvar hasMarkers = (event, tagType) => {\n  return event.getMatchingTags(tagType).some((tag) => tag[3] && tag[3] !== \"\");\n};\nfunction eventIsReply(op, event, threadIds = /* @__PURE__ */ new Set(), tagType) {\n  tagType ??= op.tagType();\n  const tags = event.getMatchingTags(tagType);\n  threadIds.add(op.tagId());\n  if (threadIds.has(event.tagId())) return false;\n  const heedExplicitReplyMarker = () => {\n    let eventIsTagged = false;\n    for (const tag of tags) {\n      if (tag[3] === \"reply\") return threadIds.has(tag[1]);\n      const markerIsEmpty = tag[3] === \"\" || tag[3] === void 0;\n      const markerIsRoot = tag[3] === \"root\";\n      if (tag[1] === op.tagId() && (markerIsEmpty || markerIsRoot)) {\n        eventIsTagged = markerIsRoot ? \"root\" : true;\n      }\n    }\n    if (!eventIsTagged) return false;\n    if (eventIsTagged === \"root\") return true;\n  };\n  const explicitReplyMarker = heedExplicitReplyMarker();\n  if (explicitReplyMarker !== void 0) return explicitReplyMarker;\n  if (hasMarkers(event, tagType)) return false;\n  const expectedTags = op.getMatchingTags(\"e\").map((tag) => tag[1]);\n  expectedTags.push(op.id);\n  return event.getMatchingTags(\"e\").every((tag) => expectedTags.includes(tag[1]));\n}\nfunction eventThreads(op, events) {\n  const eventsByAuthor = eventsBySameAuthor(op, events);\n  const threadEvents = events.filter((event) => eventIsPartOfThread(op, event, eventsByAuthor));\n  return threadEvents.sort((a, b) => a.created_at - b.created_at);\n}\nfunction getEventReplyId(event) {\n  const replyTag = getReplyTag(event);\n  if (replyTag) return replyTag[1];\n  const rootTag = getRootTag(event);\n  if (rootTag) return rootTag[1];\n}\nfunction isEventOriginalPost(event) {\n  return getEventReplyId(event) === void 0;\n}\nfunction eventThreadIds(op, events) {\n  const threadIds = /* @__PURE__ */ new Map();\n  const threadEvents = eventThreads(op, events);\n  threadEvents.forEach((event) => threadIds.set(event.id, event));\n  return threadIds;\n}\nfunction eventReplies(op, events, threadEventIds) {\n  threadEventIds ??= new Set(eventThreadIds(op, events).keys());\n  return events.filter((event) => eventIsReply(op, event, threadEventIds));\n}\nfunction eventIsPartOfThread(op, event, eventsByAuthor) {\n  if (op.pubkey !== event.pubkey) return false;\n  const taggedEventIds = event.getMatchingTags(\"e\").map((tag) => tag[1]);\n  const allTaggedEventsAreByOriginalAuthor = taggedEventIds.every((id) => eventsByAuthor.has(id));\n  return allTaggedEventsAreByOriginalAuthor;\n}\nfunction eventHasETagMarkers(event) {\n  for (const tag of event.tags) {\n    if (tag[0] === \"e\" && (tag[3] ?? \"\").length > 0) return true;\n  }\n  return false;\n}\nfunction getRootEventId(event, searchTag) {\n  searchTag ??= event.tagType();\n  const rootEventTag = getRootTag(event, searchTag);\n  if (rootEventTag) return rootEventTag[1];\n  const replyTag = getReplyTag(event, searchTag);\n  return replyTag?.[1];\n}\nfunction getRootTag(event, searchTag) {\n  searchTag ??= event.tagType();\n  const rootEventTag = event.tags.find(isTagRootTag);\n  if (!rootEventTag) {\n    if (eventHasETagMarkers(event)) return;\n    const matchingTags = event.getMatchingTags(searchTag);\n    if (matchingTags.length < 3) return matchingTags[0];\n  }\n  return rootEventTag;\n}\nvar nip22RootTags = /* @__PURE__ */ new Set([\"A\", \"E\", \"I\"]);\nvar nip22ReplyTags = /* @__PURE__ */ new Set([\"a\", \"e\", \"i\"]);\nfunction getReplyTag(event, searchTag) {\n  if (event.kind === 1111 /* GenericReply */) {\n    let replyTag2;\n    for (const tag of event.tags) {\n      if (nip22RootTags.has(tag[0])) replyTag2 = tag;\n      else if (nip22ReplyTags.has(tag[0])) {\n        replyTag2 = tag;\n        break;\n      }\n    }\n    return replyTag2;\n  }\n  searchTag ??= event.tagType();\n  let hasMarkers2 = false;\n  let replyTag;\n  for (const tag of event.tags) {\n    if (tag[0] !== searchTag) continue;\n    if ((tag[3] ?? \"\").length > 0) hasMarkers2 = true;\n    if (hasMarkers2 && tag[3] === \"reply\") return tag;\n    if (hasMarkers2 && tag[3] === \"root\") replyTag = tag;\n    if (!hasMarkers2) replyTag = tag;\n  }\n  return replyTag;\n}\nfunction isTagRootTag(tag) {\n  return tag[0] === \"E\" || tag[3] === \"root\";\n}\n\n// src/events/fetch-tagged-event.ts\nasync function fetchTaggedEvent(tag, marker) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const t = this.getMatchingTags(tag, marker);\n  if (t.length === 0) return void 0;\n  const [_, id, hint] = t[0];\n  let relay = hint !== \"\" ? this.ndk.pool.getRelay(hint) : void 0;\n  const event = await this.ndk.fetchEvent(id, {}, relay);\n  return event;\n}\nasync function fetchRootEvent(subOpts) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const rootTag = getRootTag(this);\n  if (!rootTag) return void 0;\n  return this.ndk.fetchEventFromTag(rootTag, this, subOpts);\n}\nasync function fetchReplyEvent(subOpts) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const replyTag = getReplyTag(this);\n  if (!replyTag) return void 0;\n  return this.ndk.fetchEventFromTag(replyTag, this, subOpts);\n}\n\n// src/events/kind.ts\nfunction isReplaceable() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return [0, 3].includes(this.kind) || this.kind >= 1e4 && this.kind < 2e4 || this.kind >= 3e4 && this.kind < 4e4;\n}\nfunction isEphemeral() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return this.kind >= 2e4 && this.kind < 3e4;\n}\nfunction isParamReplaceable() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return this.kind >= 3e4 && this.kind < 4e4;\n}\n\n// src/events/nip19.ts\n\nvar DEFAULT_RELAY_COUNT = 2;\nfunction encode(maxRelayCount = DEFAULT_RELAY_COUNT) {\n  let relays = [];\n  if (this.onRelays.length > 0) {\n    relays = this.onRelays.map((relay) => relay.url);\n  } else if (this.relay) {\n    relays = [this.relay.url];\n  }\n  if (relays.length > maxRelayCount) {\n    relays = relays.slice(0, maxRelayCount);\n  }\n  if (this.isParamReplaceable()) {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.naddrEncode({\n      kind: this.kind,\n      pubkey: this.pubkey,\n      identifier: this.replaceableDTag(),\n      relays\n    });\n  }\n  if (relays.length > 0) {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.neventEncode({\n      id: this.tagId(),\n      relays,\n      author: this.pubkey\n    });\n  }\n  return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.noteEncode(this.tagId());\n}\n\n// src/events/repost.ts\nasync function repost(publish = true, signer) {\n  if (!signer && publish) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    signer = this.ndk.signer;\n  }\n  const e = new NDKEvent(this.ndk, {\n    kind: getKind(this)\n  });\n  if (!this.isProtected) e.content = JSON.stringify(this.rawEvent());\n  e.tag(this);\n  if (this.kind !== 1 /* Text */) {\n    e.tags.push([\"k\", `${this.kind}`]);\n  }\n  if (signer) await e.sign(signer);\n  if (publish) await e.publish();\n  return e;\n}\nfunction getKind(event) {\n  if (event.kind === 1) {\n    return 6 /* Repost */;\n  }\n  return 16 /* GenericRepost */;\n}\n\n// src/events/serializer.ts\nfunction serialize(includeSig = false, includeId = false) {\n  const payload = [0, this.pubkey, this.created_at, this.kind, this.tags, this.content];\n  if (includeSig) payload.push(this.sig);\n  if (includeId) payload.push(this.id);\n  return JSON.stringify(payload);\n}\nfunction deserialize(serializedEvent) {\n  const eventArray = JSON.parse(serializedEvent);\n  const ret = {\n    pubkey: eventArray[1],\n    created_at: eventArray[2],\n    kind: eventArray[3],\n    tags: eventArray[4],\n    content: eventArray[5]\n  };\n  if (eventArray.length >= 7) {\n    const first = eventArray[6];\n    const second = eventArray[7];\n    if (first && first.length === 128) {\n      ret.sig = first;\n      if (second && second.length === 64) {\n        ret.id = second;\n      }\n    } else if (first && first.length === 64) {\n      ret.id = first;\n      if (second && second.length === 128) {\n        ret.sig = second;\n      }\n    }\n  }\n  return ret;\n}\n\n// src/events/validation.ts\n\n\n\n\n\n// src/events/signature.ts\nvar worker;\nvar processingQueue = {};\nfunction signatureVerificationInit(w) {\n  worker = w;\n  worker.onmessage = (msg) => {\n    const [eventId, result] = msg.data;\n    const record = processingQueue[eventId];\n    if (!record) {\n      console.error(\"No record found for event\", eventId);\n      return;\n    }\n    delete processingQueue[eventId];\n    for (const resolve of record.resolves) {\n      resolve(result);\n    }\n  };\n}\nasync function verifySignatureAsync(event, _persist) {\n  const promise = new Promise((resolve) => {\n    const serialized = event.serialize();\n    let enqueue = false;\n    if (!processingQueue[event.id]) {\n      processingQueue[event.id] = { event, resolves: [] };\n      enqueue = true;\n    }\n    processingQueue[event.id].resolves.push(resolve);\n    if (!enqueue) return;\n    worker?.postMessage({\n      serialized,\n      id: event.id,\n      sig: event.sig,\n      pubkey: event.pubkey\n    });\n  });\n  return promise;\n}\n\n// src/events/validation.ts\nvar PUBKEY_REGEX = /^[a-f0-9]{64}$/;\nfunction validate() {\n  if (typeof this.kind !== \"number\") return false;\n  if (typeof this.content !== \"string\") return false;\n  if (typeof this.created_at !== \"number\") return false;\n  if (typeof this.pubkey !== \"string\") return false;\n  if (!this.pubkey.match(PUBKEY_REGEX)) return false;\n  if (!Array.isArray(this.tags)) return false;\n  for (let i = 0; i < this.tags.length; i++) {\n    const tag = this.tags[i];\n    if (!Array.isArray(tag)) return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\") return false;\n    }\n  }\n  return true;\n}\nvar verifiedSignatures = new typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({\n  maxSize: 1e3,\n  entryExpirationTimeInMS: 6e4\n});\nfunction verifySignature(persist) {\n  if (typeof this.signatureVerified === \"boolean\") return this.signatureVerified;\n  const prevVerification = verifiedSignatures.get(this.id);\n  if (prevVerification !== null) {\n    this.signatureVerified = !!prevVerification;\n    return this.signatureVerified;\n  }\n  try {\n    if (this.ndk?.asyncSigVerification) {\n      verifySignatureAsync(this, persist).then((result) => {\n        if (persist) {\n          this.signatureVerified = result;\n          if (result) verifiedSignatures.set(this.id, this.sig);\n        }\n        if (!result) {\n          this.ndk?.emit(\"event:invalid-sig\", this);\n          verifiedSignatures.set(this.id, false);\n        }\n      });\n    } else {\n      const hash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(new TextEncoder().encode(this.serialize()));\n      const res = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__.schnorr.verify(this.sig, hash, this.pubkey);\n      if (res) verifiedSignatures.set(this.id, this.sig);\n      else verifiedSignatures.set(this.id, false);\n      this.signatureVerified = res;\n      return res;\n    }\n  } catch (_err) {\n    this.signatureVerified = false;\n    return false;\n  }\n}\nfunction getEventHash() {\n  return getEventHashFromSerializedEvent(this.serialize());\n}\nfunction getEventHashFromSerializedEvent(serializedEvent) {\n  const eventHash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(new TextEncoder().encode(serializedEvent));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(eventHash);\n}\n\n// src/events/index.ts\nvar skipClientTagOnKinds = /* @__PURE__ */ new Set([\n  0 /* Metadata */,\n  4 /* EncryptedDirectMessage */,\n  1059 /* GiftWrap */,\n  13 /* GiftWrapSeal */,\n  3 /* Contacts */,\n  9734 /* ZapRequest */,\n  5 /* EventDeletion */\n]);\nvar NDKEvent = class _NDKEvent extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  created_at;\n  content = \"\";\n  tags = [];\n  kind;\n  id = \"\";\n  sig;\n  pubkey = \"\";\n  signatureVerified;\n  _author = void 0;\n  /**\n   * The relay that this event was first received from.\n   */\n  relay;\n  /**\n   * The relays that this event was received from and/or successfully published to.\n   */\n  get onRelays() {\n    let res = [];\n    if (!this.ndk) {\n      if (this.relay) res.push(this.relay);\n    } else {\n      res = this.ndk.subManager.seenEvents.get(this.id) || [];\n    }\n    return res;\n  }\n  /**\n   * The status of the publish operation.\n   */\n  publishStatus = \"success\";\n  publishError;\n  constructor(ndk, event) {\n    super();\n    this.ndk = ndk;\n    this.created_at = event?.created_at;\n    this.content = event?.content || \"\";\n    this.tags = event?.tags || [];\n    this.id = event?.id || \"\";\n    this.sig = event?.sig;\n    this.pubkey = event?.pubkey || \"\";\n    this.kind = event?.kind;\n    if (event instanceof _NDKEvent) {\n      if (this.relay) {\n        this.relay = event.relay;\n        this.ndk?.subManager.seenEvent(event.id, this.relay);\n      }\n      this.publishStatus = event.publishStatus;\n      this.publishError = event.publishError;\n    }\n  }\n  /**\n   * Deserialize an NDKEvent from a serialized payload.\n   * @param ndk\n   * @param event\n   * @returns\n   */\n  static deserialize(ndk, event) {\n    return new _NDKEvent(ndk, deserialize(event));\n  }\n  /**\n   * Returns the event as is.\n   */\n  rawEvent() {\n    return {\n      created_at: this.created_at,\n      content: this.content,\n      tags: this.tags,\n      kind: this.kind,\n      pubkey: this.pubkey,\n      id: this.id,\n      sig: this.sig\n    };\n  }\n  set author(user) {\n    this.pubkey = user.pubkey;\n    this._author = user;\n    this._author.ndk ??= this.ndk;\n  }\n  /**\n   * Returns an NDKUser for the author of the event.\n   */\n  get author() {\n    if (this._author) return this._author;\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const user = this.ndk.getUser({ pubkey: this.pubkey });\n    this._author = user;\n    return user;\n  }\n  /**\n   * NIP-73 tagging of external entities\n   * @param entity to be tagged\n   * @param type of the entity\n   * @param markerUrl to be used as the marker URL\n   *\n   * @example\n   * ```typescript\n   * event.tagExternal(\"https://example.com/article/123#nostr\", \"url\");\n   * event.tags => [[\"i\", \"https://example.com/123\"], [\"k\", \"https://example.com\"]]\n   * ```\n   *\n   * @example tag a podcast:item:guid\n   * ```typescript\n   * event.tagExternal(\"e32b4890-b9ea-4aef-a0bf-54b787833dc5\", \"podcast:item:guid\");\n   * event.tags => [[\"i\", \"podcast:item:guid:e32b4890-b9ea-4aef-a0bf-54b787833dc5\"], [\"k\", \"podcast:item:guid\"]]\n   * ```\n   *\n   * @see https://github.com/nostr-protocol/nips/blob/master/73.md\n   */\n  tagExternal(entity, type, markerUrl) {\n    const iTag = [\"i\"];\n    const kTag = [\"k\"];\n    switch (type) {\n      case \"url\": {\n        const url = new URL(entity);\n        url.hash = \"\";\n        iTag.push(url.toString());\n        kTag.push(`${url.protocol}//${url.host}`);\n        break;\n      }\n      case \"hashtag\":\n        iTag.push(`#${entity.toLowerCase()}`);\n        kTag.push(\"#\");\n        break;\n      case \"geohash\":\n        iTag.push(`geo:${entity.toLowerCase()}`);\n        kTag.push(\"geo\");\n        break;\n      case \"isbn\":\n        iTag.push(`isbn:${entity.replace(/-/g, \"\")}`);\n        kTag.push(\"isbn\");\n        break;\n      case \"podcast:guid\":\n        iTag.push(`podcast:guid:${entity}`);\n        kTag.push(\"podcast:guid\");\n        break;\n      case \"podcast:item:guid\":\n        iTag.push(`podcast:item:guid:${entity}`);\n        kTag.push(\"podcast:item:guid\");\n        break;\n      case \"podcast:publisher:guid\":\n        iTag.push(`podcast:publisher:guid:${entity}`);\n        kTag.push(\"podcast:publisher:guid\");\n        break;\n      case \"isan\":\n        iTag.push(`isan:${entity.split(\"-\").slice(0, 4).join(\"-\")}`);\n        kTag.push(\"isan\");\n        break;\n      case \"doi\":\n        iTag.push(`doi:${entity.toLowerCase()}`);\n        kTag.push(\"doi\");\n        break;\n      default:\n        throw new Error(`Unsupported NIP-73 entity type: ${type}`);\n    }\n    if (markerUrl) {\n      iTag.push(markerUrl);\n    }\n    this.tags.push(iTag);\n    this.tags.push(kTag);\n  }\n  /**\n   * Tag a user with an optional marker.\n   * @param target What is to be tagged. Can be an NDKUser, NDKEvent, or an NDKTag.\n   * @param marker The marker to use in the tag.\n   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event.\n   * @param forceTag Force a specific tag to be used instead of the default \"e\" or \"a\" tag.\n   * @example\n   * ```typescript\n   * reply.tag(opEvent, \"reply\");\n   * // reply.tags => [[\"e\", <id>, <relay>, \"reply\"]]\n   * ```\n   */\n  tag(target, marker, skipAuthorTag, forceTag) {\n    let tags = [];\n    const isNDKUser = target.fetchProfile !== void 0;\n    if (isNDKUser) {\n      forceTag ??= \"p\";\n      const tag = [forceTag, target.pubkey];\n      if (marker) tag.push(...[\"\", marker]);\n      tags.push(tag);\n    } else if (target instanceof _NDKEvent) {\n      const event = target;\n      skipAuthorTag ??= event?.pubkey === this.pubkey;\n      tags = event.referenceTags(marker, skipAuthorTag, forceTag);\n      for (const pTag of event.getMatchingTags(\"p\")) {\n        if (pTag[1] === this.pubkey) continue;\n        if (this.tags.find((t) => t[0] === \"p\" && t[1] === pTag[1])) continue;\n        this.tags.push([\"p\", pTag[1]]);\n      }\n    } else if (Array.isArray(target)) {\n      tags = [target];\n    } else {\n      throw new Error(\"Invalid argument\", target);\n    }\n    this.tags = mergeTags(this.tags, tags);\n  }\n  /**\n   * Return a NostrEvent object, trying to fill in missing fields\n   * when possible, adding tags when necessary.\n   * @param pubkey {string} The pubkey of the user who the event belongs to.\n   * @returns {Promise<NostrEvent>} A promise that resolves to a NostrEvent.\n   */\n  async toNostrEvent(pubkey) {\n    if (!pubkey && this.pubkey === \"\") {\n      const user = await this.ndk?.signer?.user();\n      this.pubkey = user?.pubkey || \"\";\n    }\n    if (!this.created_at) {\n      this.created_at = Math.floor(Date.now() / 1e3);\n    }\n    const { content, tags } = await this.generateTags();\n    this.content = content || \"\";\n    this.tags = tags;\n    try {\n      this.id = this.getEventHash();\n    } catch (_e) {\n    }\n    return this.rawEvent();\n  }\n  serialize = serialize.bind(this);\n  getEventHash = getEventHash.bind(this);\n  validate = validate.bind(this);\n  verifySignature = verifySignature.bind(this);\n  /**\n   * Is this event replaceable (whether parameterized or not)?\n   *\n   * This will return true for kind 0, 3, 10k-20k and 30k-40k\n   */\n  isReplaceable = isReplaceable.bind(this);\n  isEphemeral = isEphemeral.bind(this);\n  isDvm = () => this.kind && this.kind >= 5e3 && this.kind <= 7e3;\n  /**\n   * Is this event parameterized replaceable?\n   *\n   * This will return true for kind 30k-40k\n   */\n  isParamReplaceable = isParamReplaceable.bind(this);\n  /**\n   * Encodes a bech32 id.\n   *\n   * @param relays {string[]} The relays to encode in the id\n   * @returns {string} - Encoded naddr, note or nevent.\n   */\n  encode = encode.bind(this);\n  encrypt = encrypt.bind(this);\n  decrypt = decrypt.bind(this);\n  /**\n   * Get all tags with the given name\n   * @param tagName {string} The name of the tag to search for\n   * @returns {NDKTag[]} An array of the matching tags\n   */\n  getMatchingTags(tagName, marker) {\n    const t = this.tags.filter((tag) => tag[0] === tagName);\n    if (marker === void 0) return t;\n    return t.filter((tag) => tag[3] === marker);\n  }\n  /**\n   * Check if the event has a tag with the given name\n   * @param tagName\n   * @param marker\n   * @returns\n   */\n  hasTag(tagName, marker) {\n    return this.tags.some((tag) => tag[0] === tagName && (!marker || tag[3] === marker));\n  }\n  /**\n   * Get the first tag with the given name\n   * @param tagName Tag name to search for\n   * @returns The value of the first tag with the given name, or undefined if no such tag exists\n   */\n  tagValue(tagName, marker) {\n    const tags = this.getMatchingTags(tagName, marker);\n    if (tags.length === 0) return void 0;\n    return tags[0][1];\n  }\n  /**\n   * Gets the NIP-31 \"alt\" tag of the event.\n   */\n  get alt() {\n    return this.tagValue(\"alt\");\n  }\n  /**\n   * Sets the NIP-31 \"alt\" tag of the event. Use this to set an alt tag so\n   * clients that don't handle a particular event kind can display something\n   * useful for users.\n   */\n  set alt(alt) {\n    this.removeTag(\"alt\");\n    if (alt) this.tags.push([\"alt\", alt]);\n  }\n  /**\n   * Gets the NIP-33 \"d\" tag of the event.\n   */\n  get dTag() {\n    return this.tagValue(\"d\");\n  }\n  /**\n   * Sets the NIP-33 \"d\" tag of the event.\n   */\n  set dTag(value) {\n    this.removeTag(\"d\");\n    if (value) this.tags.push([\"d\", value]);\n  }\n  /**\n   * Remove all tags with the given name (e.g. \"d\", \"a\", \"p\")\n   * @param tagName Tag name(s) to search for and remove\n   * @param marker Optional marker to check for too\n   *\n   * @example\n   * Remove a tags with a \"defer\" marker\n   * ```typescript\n   * event.tags = [\n   *   [\"a\", \"....\", \"defer\"],\n   *   [\"a\", \"....\", \"no-defer\"],\n   * ]\n   *\n   * event.removeTag(\"a\", \"defer\");\n   *\n   * // event.tags => [[\"a\", \"....\", \"no-defer\"]]\n   *\n   * @returns {void}\n   */\n  removeTag(tagName, marker) {\n    const tagNames = Array.isArray(tagName) ? tagName : [tagName];\n    this.tags = this.tags.filter((tag) => {\n      const include = tagNames.includes(tag[0]);\n      const hasMarker = marker ? tag[3] === marker : true;\n      return !(include && hasMarker);\n    });\n  }\n  /**\n   * Replace a tag with a new value. If not found, it will be added.\n   * @param tag The tag to replace.\n   * @param value The new value for the tag.\n   */\n  replaceTag(tag) {\n    this.removeTag(tag[0]);\n    this.tags.push(tag);\n  }\n  /**\n   * Sign the event if a signer is present.\n   *\n   * It will generate tags.\n   * Repleacable events will have their created_at field set to the current time.\n   * @param signer {NDKSigner} The NDKSigner to use to sign the event\n   * @returns {Promise<string>} A Promise that resolves to the signature of the signed event.\n   */\n  async sign(signer) {\n    if (!signer) {\n      this.ndk?.assertSigner();\n      signer = this.ndk?.signer;\n    } else {\n      this.author = await signer.user();\n    }\n    const nostrEvent = await this.toNostrEvent();\n    this.sig = await signer.sign(nostrEvent);\n    return this.sig;\n  }\n  /**\n   *\n   * @param relaySet\n   * @param timeoutMs\n   * @param requiredRelayCount\n   * @returns\n   */\n  async publishReplaceable(relaySet, timeoutMs, requiredRelayCount) {\n    this.id = \"\";\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.sig = \"\";\n    return this.publish(relaySet, timeoutMs, requiredRelayCount);\n  }\n  /**\n   * Attempt to sign and then publish an NDKEvent to a given relaySet.\n   * If no relaySet is provided, the relaySet will be calculated by NDK.\n   * @param relaySet {NDKRelaySet} The relaySet to publish the even to.\n   * @param timeoutM {number} The timeout for the publish operation in milliseconds.\n   * @param requiredRelayCount The number of relays that must receive the event for the publish to be considered successful.\n   * @returns A promise that resolves to the relays the event was published to.\n   */\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    if (!this.sig) await this.sign();\n    if (!this.ndk) throw new Error(\"NDKEvent must be associated with an NDK instance to publish\");\n    if (!relaySet || relaySet.size === 0) {\n      relaySet = this.ndk.devWriteRelaySet || await calculateRelaySetFromEvent(this.ndk, this);\n    }\n    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {\n      const eTags = this.getMatchingTags(\"e\").map((tag) => tag[1]);\n      this.ndk.cacheAdapter.deleteEventIds(eTags);\n    }\n    const rawEvent = this.rawEvent();\n    if (this.ndk.cacheAdapter?.addUnpublishedEvent && shouldTrackUnpublishedEvent(this)) {\n      try {\n        this.ndk.cacheAdapter.addUnpublishedEvent(this, relaySet.relayUrls);\n      } catch (e) {\n        console.error(\"Error adding unpublished event to cache\", e);\n      }\n    }\n    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {\n      this.ndk.cacheAdapter.deleteEventIds(this.getMatchingTags(\"e\").map((tag) => tag[1]));\n    }\n    this.ndk.subManager.dispatchEvent(rawEvent, void 0, true);\n    const relays = await relaySet.publish(this, timeoutMs, requiredRelayCount);\n    relays.forEach((relay) => this.ndk?.subManager.seenEvent(this.id, relay));\n    return relays;\n  }\n  /**\n   * Generates tags for users, notes, and other events tagged in content.\n   * Will also generate random \"d\" tag for parameterized replaceable events where needed.\n   * @returns {ContentTag} The tags and content of the event.\n   */\n  async generateTags() {\n    let tags = [];\n    const g = await generateContentTags(this.content, this.tags);\n    const content = g.content;\n    tags = g.tags;\n    if (this.kind && this.isParamReplaceable()) {\n      const dTag = this.getMatchingTags(\"d\")[0];\n      if (!dTag) {\n        const title = this.tagValue(\"title\");\n        const randLength = title ? 6 : 16;\n        let str = [...Array(randLength)].map(() => Math.random().toString(36)[2]).join(\"\");\n        if (title && title.length > 0) {\n          str = `${title.replace(/[^a-z0-9]+/gi, \"-\").replace(/^-|-$/g, \"\")}-${str}`;\n        }\n        tags.push([\"d\", str]);\n      }\n    }\n    if (this.shouldAddClientTag) {\n      const clientTag = [\"client\", this.ndk?.clientName ?? \"\"];\n      if (this.ndk?.clientNip89) clientTag.push(this.ndk?.clientNip89);\n      tags.push(clientTag);\n    } else if (this.shouldStripClientTag) {\n      tags = tags.filter((tag) => tag[0] !== \"client\");\n    }\n    return { content: content || \"\", tags };\n  }\n  get shouldAddClientTag() {\n    if (!this.ndk?.clientName && !this.ndk?.clientNip89) return false;\n    if (skipClientTagOnKinds.has(this.kind)) return false;\n    if (this.isEphemeral()) return false;\n    if (this.isReplaceable() && !this.isParamReplaceable()) return false;\n    if (this.isDvm()) return false;\n    if (this.hasTag(\"client\")) return false;\n    return true;\n  }\n  get shouldStripClientTag() {\n    return skipClientTagOnKinds.has(this.kind);\n  }\n  muted() {\n    const authorMutedEntry = this.ndk?.mutedIds.get(this.pubkey);\n    if (authorMutedEntry && authorMutedEntry === \"p\") return \"author\";\n    const eventTagReference = this.tagReference();\n    const eventMutedEntry = this.ndk?.mutedIds.get(eventTagReference[1]);\n    if (eventMutedEntry && eventMutedEntry === eventTagReference[0]) return \"event\";\n    return null;\n  }\n  /**\n   * Returns the \"d\" tag of a parameterized replaceable event or throws an error if the event isn't\n   * a parameterized replaceable event.\n   * @returns {string} the \"d\" tag of the event.\n   *\n   * @deprecated Use `dTag` instead.\n   */\n  replaceableDTag() {\n    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {\n      const dTag = this.getMatchingTags(\"d\")[0];\n      const dTagId = dTag ? dTag[1] : \"\";\n      return dTagId;\n    }\n    throw new Error(\"Event is not a parameterized replaceable event\");\n  }\n  /**\n   * Provides a deduplication key for the event.\n   *\n   * For kinds 0, 3, 10k-20k this will be the event <kind>:<pubkey>\n   * For kinds 30k-40k this will be the event <kind>:<pubkey>:<d-tag>\n   * For all other kinds this will be the event id\n   */\n  deduplicationKey() {\n    if (this.kind === 0 || this.kind === 3 || this.kind && this.kind >= 1e4 && this.kind < 2e4) {\n      return `${this.kind}:${this.pubkey}`;\n    }\n    return this.tagId();\n  }\n  /**\n   * Returns the id of the event or, if it's a parameterized event, the generated id of the event using \"d\" tag, pubkey, and kind.\n   * @returns {string} The id\n   */\n  tagId() {\n    if (this.isParamReplaceable()) {\n      return this.tagAddress();\n    }\n    return this.id;\n  }\n  /**\n   * Returns a stable reference value for a replaceable event.\n   *\n   * Param replaceable events are returned in the expected format of `<kind>:<pubkey>:<d-tag>`.\n   * Kind-replaceable events are returned in the format of `<kind>:<pubkey>:`.\n   *\n   * @returns {string} A stable reference value for replaceable events\n   */\n  tagAddress() {\n    if (this.isParamReplaceable()) {\n      const dTagId = this.dTag ?? \"\";\n      return `${this.kind}:${this.pubkey}:${dTagId}`;\n    }\n    if (this.isReplaceable()) {\n      return `${this.kind}:${this.pubkey}:`;\n    }\n    throw new Error(\"Event is not a replaceable event\");\n  }\n  /**\n   * Determines the type of tag that can be used to reference this event from another event.\n   * @returns {string} The tag type\n   * @example\n   * event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   * event.tagType(); // \"a\"\n   */\n  tagType() {\n    return this.isParamReplaceable() ? \"a\" : \"e\";\n  }\n  /**\n   * Get the tag that can be used to reference this event from another event.\n   *\n   * Consider using referenceTags() instead (unless you have a good reason to use this)\n   *\n   * @example\n   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *     event.tagReference(); // [\"a\", \"30000:pubkey:d-code\"]\n   *\n   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *     event.tagReference(); // [\"e\", \"eventid\"]\n   * @returns {NDKTag} The NDKTag object referencing this event\n   */\n  tagReference(marker) {\n    let tag;\n    if (this.isParamReplaceable()) {\n      tag = [\"a\", this.tagAddress()];\n    } else {\n      tag = [\"e\", this.tagId()];\n    }\n    if (this.relay) {\n      tag.push(this.relay.url);\n    } else {\n      tag.push(\"\");\n    }\n    tag.push(marker ?? \"\");\n    if (!this.isParamReplaceable()) {\n      tag.push(this.pubkey);\n    }\n    return tag;\n  }\n  /**\n   * Get the tags that can be used to reference this event from another event\n   * @param marker The marker to use in the tag\n   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event\n   * @param forceTag Force a specific tag to be used instead of the default \"e\" or \"a\" tag\n   * @example\n   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *     event.referenceTags(); // [[\"a\", \"30000:pubkey:d-code\"], [\"e\", \"parent-id\"]]\n   *\n   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *     event.referenceTags(); // [[\"e\", \"parent-id\"]]\n   * @returns {NDKTag} The NDKTag object referencing this event\n   */\n  referenceTags(marker, skipAuthorTag, forceTag) {\n    let tags = [];\n    if (this.isParamReplaceable()) {\n      tags = [\n        [forceTag ?? \"a\", this.tagAddress()],\n        [forceTag ?? \"e\", this.id]\n      ];\n    } else {\n      tags = [[forceTag ?? \"e\", this.id]];\n    }\n    tags = tags.map((tag) => {\n      if (tag[0] === \"e\" || marker) {\n        tag.push(this.relay?.url ?? \"\");\n      } else if (this.relay?.url) {\n        tag.push(this.relay?.url);\n      }\n      return tag;\n    });\n    tags.forEach((tag) => {\n      if (tag[0] === \"e\") {\n        tag.push(marker ?? \"\");\n        tag.push(this.pubkey);\n      } else if (marker) {\n        tag.push(marker);\n      }\n    });\n    tags = [...tags, ...this.getMatchingTags(\"h\")];\n    if (!skipAuthorTag) tags.push(...this.author.referenceTags());\n    return tags;\n  }\n  /**\n   * Provides the filter that will return matching events for this event.\n   *\n   * @example\n   *    event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *    event.filter(); // { \"#a\": [\"30000:pubkey:d-code\"] }\n   * @example\n   *    event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *    event.filter(); // { \"#e\": [\"eventid\"] }\n   *\n   * @returns The filter that will return matching events for this event\n   */\n  filter() {\n    if (this.isParamReplaceable()) {\n      return { \"#a\": [this.tagId()] };\n    }\n    return { \"#e\": [this.tagId()] };\n  }\n  nip22Filter() {\n    if (this.isParamReplaceable()) {\n      return { \"#A\": [this.tagId()] };\n    }\n    return { \"#E\": [this.tagId()] };\n  }\n  /**\n   * Generates a deletion event of the current event\n   *\n   * @param reason The reason for the deletion\n   * @param publish Whether to publish the deletion event automatically\n   * @returns The deletion event\n   */\n  async delete(reason, publish = true) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const e = new _NDKEvent(this.ndk, {\n      kind: 5 /* EventDeletion */,\n      content: reason || \"\"\n    });\n    e.tag(this, void 0, true);\n    e.tags.push([\"k\", this.kind?.toString()]);\n    if (publish) {\n      this.emit(\"deleted\");\n      await e.publish();\n    }\n    return e;\n  }\n  /**\n   * Establishes whether this is a NIP-70-protectede event.\n   * @@satisfies NIP-70\n   */\n  set isProtected(val) {\n    this.removeTag(\"-\");\n    if (val) this.tags.push([\"-\"]);\n  }\n  /**\n   * Whether this is a NIP-70-protected event.\n   * @@satisfies NIP-70\n   */\n  get isProtected() {\n    return this.hasTag(\"-\");\n  }\n  /**\n   * Fetch an event tagged with the given tag following relay hints if provided.\n   * @param tag The tag to search for\n   * @param marker The marker to use in the tag (e.g. \"root\")\n   * @returns The fetched event or null if no event was found, undefined if no matching tag was found in the event\n   * * @example\n   * const replyEvent = await ndk.fetchEvent(\"nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd\")\n   * const originalEvent = await replyEvent.fetchTaggedEvent(\"e\", \"reply\");\n   * console.log(replyEvent.encode() + \" is a reply to event \" + originalEvent?.encode());\n   */\n  fetchTaggedEvent = fetchTaggedEvent.bind(this);\n  /**\n   * Fetch the root event of the current event.\n   * @returns The fetched root event or null if no event was found\n   * @example\n   * const replyEvent = await ndk.fetchEvent(\"nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd\")\n   * const rootEvent = await replyEvent.fetchRootEvent();\n   * console.log(replyEvent.encode() + \" is a reply in the thread \" + rootEvent?.encode());\n   */\n  fetchRootEvent = fetchRootEvent.bind(this);\n  /**\n   * Fetch the event the current event is replying to.\n   * @returns The fetched reply event or null if no event was found\n   */\n  fetchReplyEvent = fetchReplyEvent.bind(this);\n  /**\n   * NIP-18 reposting event.\n   *\n   * @param publish Whether to publish the reposted event automatically @default true\n   * @param signer The signer to use for signing the reposted event\n   * @returns The reposted event\n   *\n   * @function\n   */\n  repost = repost.bind(this);\n  /**\n   * React to an existing event\n   *\n   * @param content The content of the reaction\n   */\n  async react(content, publish = true) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const e = new _NDKEvent(this.ndk, {\n      kind: 7 /* Reaction */,\n      content\n    });\n    e.tag(this);\n    if (publish) await e.publish();\n    return e;\n  }\n  /**\n   * Checks whether the event is valid per underlying NIPs.\n   *\n   * This method is meant to be overridden by subclasses that implement specific NIPs\n   * to allow the enforcement of NIP-specific validation rules.\n   *\n   * Otherwise, it will only check for basic event properties.\n   *\n   */\n  get isValid() {\n    return this.validate();\n  }\n  get inspect() {\n    return JSON.stringify(this.rawEvent(), null, 4);\n  }\n  /**\n   * Dump the event to console for debugging purposes.\n   * Prints a JSON stringified version of rawEvent() with indentation\n   * and also lists all relay URLs for onRelays.\n   */\n  dump() {\n    console.debug(JSON.stringify(this.rawEvent(), null, 4));\n    console.debug(\"Event on relays:\", this.onRelays.map((relay) => relay.url).join(\", \"));\n  }\n  /**\n   * Creates a reply event for the current event.\n   *\n   * This function will use NIP-22 when appropriate (i.e. replies to non-kind:1 events).\n   * This function does not have side-effects; it will just return an event with the appropriate tags\n   * to generate the reply event; the caller is responsible for publishing the event.\n   */\n  reply() {\n    const reply = new _NDKEvent(this.ndk);\n    if (this.kind === 1) {\n      reply.kind = 1;\n      const opHasETag = this.hasTag(\"e\");\n      if (opHasETag) {\n        reply.tags = [\n          ...reply.tags,\n          ...this.getMatchingTags(\"e\"),\n          ...this.getMatchingTags(\"p\"),\n          ...this.getMatchingTags(\"a\"),\n          ...this.referenceTags(\"reply\")\n        ];\n      } else {\n        reply.tag(this, \"root\");\n      }\n    } else {\n      reply.kind = 1111 /* GenericReply */;\n      const carryOverTags = [\"A\", \"E\", \"I\", \"P\"];\n      const rootTags = this.tags.filter((tag) => carryOverTags.includes(tag[0]));\n      if (rootTags.length > 0) {\n        const rootKind = this.tagValue(\"K\");\n        reply.tags.push(...rootTags);\n        if (rootKind) reply.tags.push([\"K\", rootKind]);\n        const [type, id, _, ...extra] = this.tagReference();\n        const tag = [type, id, ...extra];\n        reply.tags.push(tag);\n      } else {\n        const [type, id, _, relayHint] = this.tagReference();\n        const tag = [type, id, relayHint ?? \"\"];\n        if (type === \"e\") tag.push(this.pubkey);\n        reply.tags.push(tag);\n        const uppercaseTag = [...tag];\n        uppercaseTag[0] = uppercaseTag[0].toUpperCase();\n        reply.tags.push(uppercaseTag);\n        reply.tags.push([\"K\", this.kind?.toString()]);\n        reply.tags.push([\"P\", this.pubkey]);\n      }\n      reply.tags.push([\"k\", this.kind?.toString()]);\n      reply.tags.push(...this.getMatchingTags(\"p\"));\n      reply.tags.push([\"p\", this.pubkey]);\n    }\n    return reply;\n  }\n};\nvar untrackedUnpublishedEvents = /* @__PURE__ */ new Set([\n  24133 /* NostrConnect */,\n  13194 /* NostrWaletConnectInfo */,\n  23194 /* NostrWalletConnectReq */,\n  23195 /* NostrWalletConnectRes */\n]);\nfunction shouldTrackUnpublishedEvent(event) {\n  return !untrackedUnpublishedEvents.has(event.kind);\n}\n\n// src/relay/pool/index.ts\n\nvar NDKPool = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  // TODO: This should probably be an LRU cache\n  _relays = /* @__PURE__ */ new Map();\n  status = \"idle\";\n  autoConnectRelays = /* @__PURE__ */ new Set();\n  poolBlacklistRelayUrls = /* @__PURE__ */ new Set();\n  debug;\n  temporaryRelayTimers = /* @__PURE__ */ new Map();\n  flappingRelays = /* @__PURE__ */ new Set();\n  // A map to store timeouts for each flapping relay.\n  backoffTimes = /* @__PURE__ */ new Map();\n  ndk;\n  get blacklistRelayUrls() {\n    const val = new Set(this.ndk.blacklistRelayUrls);\n    this.poolBlacklistRelayUrls.forEach((url) => val.add(url));\n    return val;\n  }\n  /**\n   * @param relayUrls - The URLs of the relays to connect to.\n   * @param blacklistedRelayUrls - URLs to blacklist for this pool IN ADDITION to those blacklisted at the ndk-level\n   * @param ndk - The NDK instance.\n   * @param opts - Options for the pool.\n   */\n  constructor(relayUrls, blacklistedRelayUrls, ndk, {\n    debug: debug8,\n    name\n  } = {}) {\n    super();\n    this.debug = debug8 ?? ndk.debug.extend(\"pool\");\n    if (name) this._name = name;\n    this.ndk = ndk;\n    this.relayUrls = relayUrls;\n    this.poolBlacklistRelayUrls = new Set(blacklistedRelayUrls);\n    this.ndk.pools.push(this);\n  }\n  get relays() {\n    return this._relays;\n  }\n  set relayUrls(urls) {\n    this._relays.clear();\n    for (const relayUrl of urls) {\n      const relay = new NDKRelay(relayUrl, void 0, this.ndk);\n      relay.connectivity.netDebug = this.ndk.netDebug;\n      this.addRelay(relay);\n    }\n  }\n  _name = \"unnamed\";\n  get name() {\n    return this._name;\n  }\n  set name(name) {\n    this._name = name;\n    this.debug = this.debug.extend(name);\n  }\n  /**\n   * Adds a relay to the pool, and sets a timer to remove it if it is not used within the specified time.\n   * @param relay - The relay to add to the pool.\n   * @param removeIfUnusedAfter - The time in milliseconds to wait before removing the relay from the pool after it is no longer used.\n   */\n  useTemporaryRelay(relay, removeIfUnusedAfter = 3e4, filters) {\n    const relayAlreadyInPool = this.relays.has(relay.url);\n    if (!relayAlreadyInPool) {\n      this.addRelay(relay);\n      this.debug(\"Adding temporary relay %s for filters %o\", relay.url, filters);\n    }\n    const existingTimer = this.temporaryRelayTimers.get(relay.url);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n    }\n    if (!relayAlreadyInPool || existingTimer) {\n      const timer = setTimeout(() => {\n        if (this.ndk.explicitRelayUrls?.includes(relay.url)) return;\n        this.removeRelay(relay.url);\n      }, removeIfUnusedAfter);\n      this.temporaryRelayTimers.set(relay.url, timer);\n    }\n  }\n  /**\n   * Adds a relay to the pool.\n   *\n   * @param relay - The relay to add to the pool.\n   * @param connect - Whether or not to connect to the relay.\n   */\n  addRelay(relay, connect = true) {\n    const isAlreadyInPool = this.relays.has(relay.url);\n    const isBlacklisted = this.blacklistRelayUrls?.has(relay.url);\n    const isCustomRelayUrl = relay.url.includes(\"/npub1\");\n    let reconnect = true;\n    const relayUrl = relay.url;\n    if (isAlreadyInPool) return;\n    if (isBlacklisted) {\n      this.debug(`Refusing to add relay ${relayUrl}: blacklisted`);\n      return;\n    }\n    if (isCustomRelayUrl) {\n      this.debug(`Refusing to add relay ${relayUrl}: is a filter relay`);\n      return;\n    }\n    if (this.ndk.cacheAdapter?.getRelayStatus) {\n      const info = this.ndk.cacheAdapter.getRelayStatus(relayUrl);\n      if (info?.dontConnectBefore) {\n        if (info.dontConnectBefore > Date.now()) {\n          const delay = info.dontConnectBefore - Date.now();\n          this.debug(`Refusing to add relay ${relayUrl}: delayed connect for ${delay}ms`);\n          setTimeout(() => {\n            this.addRelay(relay, connect);\n          }, delay);\n          return;\n        }\n        reconnect = false;\n      }\n    }\n    const noticeHandler = (notice) => this.emit(\"notice\", relay, notice);\n    const connectHandler = () => this.handleRelayConnect(relayUrl);\n    const readyHandler = () => this.handleRelayReady(relay);\n    const disconnectHandler = () => this.emit(\"relay:disconnect\", relay);\n    const flappingHandler = () => this.handleFlapping(relay);\n    const authHandler = (challenge) => this.emit(\"relay:auth\", relay, challenge);\n    const authedHandler = () => this.emit(\"relay:authed\", relay);\n    relay.off(\"notice\", noticeHandler);\n    relay.off(\"connect\", connectHandler);\n    relay.off(\"ready\", readyHandler);\n    relay.off(\"disconnect\", disconnectHandler);\n    relay.off(\"flapping\", flappingHandler);\n    relay.off(\"auth\", authHandler);\n    relay.off(\"authed\", authedHandler);\n    relay.on(\"notice\", noticeHandler);\n    relay.on(\"connect\", connectHandler);\n    relay.on(\"ready\", readyHandler);\n    relay.on(\"disconnect\", disconnectHandler);\n    relay.on(\"flapping\", flappingHandler);\n    relay.on(\"auth\", authHandler);\n    relay.on(\"authed\", authedHandler);\n    relay.on(\"delayed-connect\", (delay) => {\n      if (this.ndk.cacheAdapter?.updateRelayStatus) {\n        this.ndk.cacheAdapter.updateRelayStatus(relay.url, {\n          dontConnectBefore: Date.now() + delay\n        });\n      }\n    });\n    this._relays.set(relayUrl, relay);\n    if (connect) this.autoConnectRelays.add(relayUrl);\n    if (connect && this.status === \"active\") {\n      this.emit(\"relay:connecting\", relay);\n      relay.connect(void 0, reconnect).catch((e) => {\n        this.debug(`Failed to connect to relay ${relayUrl}`, e);\n      });\n    }\n  }\n  /**\n   * Removes a relay from the pool.\n   * @param relayUrl - The URL of the relay to remove.\n   * @returns {boolean} True if the relay was removed, false if it was not found.\n   */\n  removeRelay(relayUrl) {\n    const relay = this.relays.get(relayUrl);\n    if (relay) {\n      relay.disconnect();\n      this.relays.delete(relayUrl);\n      this.autoConnectRelays.delete(relayUrl);\n      this.emit(\"relay:disconnect\", relay);\n      return true;\n    }\n    const existingTimer = this.temporaryRelayTimers.get(relayUrl);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n      this.temporaryRelayTimers.delete(relayUrl);\n    }\n    return false;\n  }\n  /**\n   * Checks whether a relay is already connected in the pool.\n   */\n  isRelayConnected(url) {\n    const normalizedUrl = normalizeRelayUrl(url);\n    const relay = this.relays.get(normalizedUrl);\n    if (!relay) return false;\n    return relay.status === 5 /* CONNECTED */;\n  }\n  /**\n   * Fetches a relay from the pool, or creates a new one if it does not exist.\n   *\n   * New relays will be attempted to be connected.\n   */\n  getRelay(url, connect = true, temporary = false, filters) {\n    let relay = this.relays.get(normalizeRelayUrl(url));\n    if (!relay) {\n      relay = new NDKRelay(url, void 0, this.ndk);\n      relay.connectivity.netDebug = this.ndk.netDebug;\n      if (temporary) {\n        this.useTemporaryRelay(relay, 3e4, filters);\n      } else {\n        this.addRelay(relay, connect);\n      }\n    }\n    return relay;\n  }\n  handleRelayConnect(relayUrl) {\n    const relay = this.relays.get(relayUrl);\n    if (!relay) {\n      console.error(\"NDK BUG: relay not found in pool\", { relayUrl });\n      return;\n    }\n    this.emit(\"relay:connect\", relay);\n    if (this.stats().connected === this.relays.size) {\n      this.emit(\"connect\");\n    }\n  }\n  handleRelayReady(relay) {\n    this.emit(\"relay:ready\", relay);\n  }\n  /**\n   * Attempts to establish a connection to each relay in the pool.\n   *\n   * @async\n   * @param {number} [timeoutMs] - Optional timeout in milliseconds for each connection attempt.\n   * @returns {Promise<void>} A promise that resolves when all connection attempts have completed.\n   * @throws {Error} If any of the connection attempts result in an error or timeout.\n   */\n  async connect(timeoutMs) {\n    const promises = [];\n    this.status = \"active\";\n    this.debug(`Connecting to ${this.relays.size} relays${timeoutMs ? `, timeout ${timeoutMs}...` : \"\"}`);\n    const relaysToConnect = new Set(this.autoConnectRelays.keys());\n    for (const relayUrl of relaysToConnect) {\n      const relay = this.relays.get(relayUrl);\n      if (!relay) {\n        continue;\n      }\n      const connectPromise = new Promise((resolve, reject) => {\n        this.emit(\"relay:connecting\", relay);\n        return relay.connect(timeoutMs).then(resolve).catch(reject);\n      });\n      if (timeoutMs) {\n        const timeoutPromise = new Promise((_, reject) => {\n          setTimeout(() => reject(`Timed out after ${timeoutMs}ms`), timeoutMs);\n        });\n        promises.push(\n          Promise.race([connectPromise, timeoutPromise]).catch((e) => {\n            this.debug(`Failed to connect to relay ${relay.url}: ${e ?? \"No reason specified\"}`);\n          })\n        );\n      } else {\n        promises.push(connectPromise);\n      }\n    }\n    const maybeEmitConnect = () => {\n      const allConnected = this.stats().connected === this.relays.size;\n      const someConnected = this.stats().connected > 0;\n      if (!allConnected && someConnected) {\n        this.emit(\"connect\");\n      }\n    };\n    if (timeoutMs) setTimeout(maybeEmitConnect, timeoutMs);\n    await Promise.all(promises);\n    maybeEmitConnect();\n  }\n  checkOnFlappingRelays() {\n    const flappingRelaysCount = this.flappingRelays.size;\n    const totalRelays = this.relays.size;\n    if (flappingRelaysCount / totalRelays >= 0.8) {\n      for (const relayUrl of this.flappingRelays) {\n        this.backoffTimes.set(relayUrl, 0);\n      }\n    }\n  }\n  handleFlapping(relay) {\n    this.debug(`Relay ${relay.url} is flapping`);\n    let currentBackoff = this.backoffTimes.get(relay.url) || 5e3;\n    currentBackoff = currentBackoff * 2;\n    this.backoffTimes.set(relay.url, currentBackoff);\n    this.debug(`Backoff time for ${relay.url} is ${currentBackoff}ms`);\n    setTimeout(() => {\n      this.debug(`Attempting to reconnect to ${relay.url}`);\n      this.emit(\"relay:connecting\", relay);\n      relay.connect();\n      this.checkOnFlappingRelays();\n    }, currentBackoff);\n    relay.disconnect();\n    this.emit(\"flapping\", relay);\n  }\n  size() {\n    return this.relays.size;\n  }\n  /**\n   * Returns the status of each relay in the pool.\n   * @returns {NDKPoolStats} An object containing the number of relays in each status.\n   */\n  stats() {\n    const stats = {\n      total: 0,\n      connected: 0,\n      disconnected: 0,\n      connecting: 0\n    };\n    for (const relay of this.relays.values()) {\n      stats.total++;\n      if (relay.status === 5 /* CONNECTED */) {\n        stats.connected++;\n      } else if (relay.status === 1 /* DISCONNECTED */) {\n        stats.disconnected++;\n      } else if (relay.status === 4 /* CONNECTING */) {\n        stats.connecting++;\n      }\n    }\n    return stats;\n  }\n  connectedRelays() {\n    return Array.from(this.relays.values()).filter((relay) => relay.status >= 5 /* CONNECTED */);\n  }\n  permanentAndConnectedRelays() {\n    return Array.from(this.relays.values()).filter(\n      (relay) => relay.status >= 5 /* CONNECTED */ && !this.temporaryRelayTimers.has(relay.url)\n    );\n  }\n  /**\n   * Get a list of all relay urls in the pool.\n   */\n  urls() {\n    return Array.from(this.relays.keys());\n  }\n};\n\n// src/user/index.ts\n\n\n// src/events/kinds/nutzap/mint-list.ts\nvar NDKCashuMintList = class _NDKCashuMintList extends NDKEvent {\n  static kind = 10019 /* CashuMintList */;\n  static kinds = [10019 /* CashuMintList */];\n  _p2pk;\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 10019 /* CashuMintList */;\n  }\n  static from(event) {\n    return new _NDKCashuMintList(event.ndk, event);\n  }\n  set relays(urls) {\n    this.tags = this.tags.filter((t) => t[0] !== \"relay\");\n    for (const url of urls) {\n      this.tags.push([\"relay\", url]);\n    }\n  }\n  get relays() {\n    const r = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"relay\") {\n        r.push(tag[1]);\n      }\n    }\n    return r;\n  }\n  set mints(urls) {\n    this.tags = this.tags.filter((t) => t[0] !== \"mint\");\n    for (const url of urls) {\n      this.tags.push([\"mint\", url]);\n    }\n  }\n  get mints() {\n    const r = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"mint\") {\n        r.push(tag[1]);\n      }\n    }\n    return Array.from(new Set(r));\n  }\n  get p2pk() {\n    if (this._p2pk) {\n      return this._p2pk;\n    }\n    this._p2pk = this.tagValue(\"pubkey\") ?? this.pubkey;\n    return this._p2pk;\n  }\n  set p2pk(pubkey) {\n    this._p2pk = pubkey;\n    this.removeTag(\"pubkey\");\n    if (pubkey) {\n      this.tags.push([\"pubkey\", pubkey]);\n    }\n  }\n  get relaySet() {\n    return NDKRelaySet.fromRelayUrls(this.relays, this.ndk);\n  }\n};\n\n// src/subscription/index.ts\n\n\n// src/events/kinds/article.ts\nvar NDKArticle = class _NDKArticle extends NDKEvent {\n  static kind = 30023 /* Article */;\n  static kinds = [30023 /* Article */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30023 /* Article */;\n  }\n  /**\n   * Creates a NDKArticle from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKArticle from.\n   * @returns NDKArticle\n   */\n  static from(event) {\n    return new _NDKArticle(event.ndk, event);\n  }\n  /**\n   * Getter for the article title.\n   *\n   * @returns {string | undefined} - The article title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the article title.\n   *\n   * @param {string | undefined} title - The title to set for the article.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the article image.\n   *\n   * @returns {string | undefined} - The article image if available, otherwise undefined.\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Setter for the article image.\n   *\n   * @param {string | undefined} image - The image to set for the article.\n   */\n  set image(image) {\n    this.removeTag(\"image\");\n    if (image) this.tags.push([\"image\", image]);\n  }\n  get summary() {\n    return this.tagValue(\"summary\");\n  }\n  set summary(summary) {\n    this.removeTag(\"summary\");\n    if (summary) this.tags.push([\"summary\", summary]);\n  }\n  /**\n   * Getter for the article's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      let val = Number.parseInt(tag);\n      if (val > 1e12) {\n        val = Math.floor(val / 1e3);\n      }\n      return val;\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the article's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the article's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Generates content tags for the article.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n  /**\n   * Getter for the article's URL.\n   *\n   * @returns {string | undefined} - The article's URL if available, otherwise undefined.\n   */\n  get url() {\n    return this.tagValue(\"url\");\n  }\n  /**\n   * Setter for the article's URL.\n   *\n   * @param {string | undefined} url - The URL to set for the article.\n   */\n  set url(url) {\n    if (url) {\n      this.tags.push([\"url\", url]);\n    } else {\n      this.removeTag(\"url\");\n    }\n  }\n};\n\n// src/events/kinds/cashu/token.ts\nfunction proofsTotalBalance(proofs) {\n  return proofs.reduce((acc, proof) => {\n    if (proof.amount < 0) {\n      throw new Error(\"proof amount is negative\");\n    }\n    return acc + proof.amount;\n  }, 0);\n}\nvar NDKCashuToken = class _NDKCashuToken extends NDKEvent {\n  _proofs = [];\n  _mint;\n  static kind = 7375 /* CashuToken */;\n  static kinds = [7375 /* CashuToken */];\n  /**\n   * Tokens that this token superseeds\n   */\n  _deletes = [];\n  original;\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7375 /* CashuToken */;\n  }\n  static async from(event) {\n    const token = new _NDKCashuToken(event.ndk, event);\n    token.original = event;\n    try {\n      await token.decrypt();\n    } catch {\n      token.content = token.original.content;\n    }\n    try {\n      const content = JSON.parse(token.content);\n      token.proofs = content.proofs;\n      token.mint = content.mint ?? token.tagValue(\"mint\");\n      token.deletedTokens = content.del ?? [];\n      if (!Array.isArray(token.proofs)) return;\n    } catch (_e) {\n      return;\n    }\n    return token;\n  }\n  get proofs() {\n    return this._proofs;\n  }\n  set proofs(proofs) {\n    const cs = /* @__PURE__ */ new Set();\n    this._proofs = proofs.filter((proof) => {\n      if (cs.has(proof.C)) {\n        console.warn(\"Passed in proofs had duplicates, ignoring\", proof.C);\n        return false;\n      }\n      if (proof.amount < 0) {\n        console.warn(\"Invalid proof with negative amount\", proof);\n        return false;\n      }\n      cs.add(proof.C);\n      return true;\n    }).map(this.cleanProof);\n  }\n  /**\n   * Returns a minimal proof object with only essential properties\n   */\n  cleanProof(proof) {\n    return {\n      id: proof.id,\n      amount: proof.amount,\n      C: proof.C,\n      secret: proof.secret\n    };\n  }\n  async toNostrEvent(pubkey) {\n    if (!this.ndk) throw new Error(\"no ndk\");\n    if (!this.ndk.signer) throw new Error(\"no signer\");\n    const payload = {\n      proofs: this.proofs.map(this.cleanProof),\n      mint: this.mint,\n      del: this.deletedTokens ?? []\n    };\n    this.content = JSON.stringify(payload);\n    const user = await this.ndk.signer.user();\n    await this.encrypt(user, void 0, \"nip44\");\n    return super.toNostrEvent(pubkey);\n  }\n  set mint(mint) {\n    this._mint = mint;\n  }\n  get mint() {\n    return this._mint;\n  }\n  /**\n   * Tokens that were deleted by the creation of this token.\n   */\n  get deletedTokens() {\n    return this._deletes;\n  }\n  /**\n   * Marks tokens that were deleted by the creation of this token.\n   */\n  set deletedTokens(tokenIds) {\n    this._deletes = tokenIds;\n  }\n  get amount() {\n    return proofsTotalBalance(this.proofs);\n  }\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    if (this.original) {\n      return this.original.publish(relaySet, timeoutMs, requiredRelayCount);\n    }\n    return super.publish(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/events/kinds/highlight.ts\n\nvar NDKHighlight = class _NDKHighlight extends NDKEvent {\n  _article;\n  static kind = 9802 /* Highlight */;\n  static kinds = [9802 /* Highlight */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 9802 /* Highlight */;\n  }\n  static from(event) {\n    return new _NDKHighlight(event.ndk, event);\n  }\n  get url() {\n    return this.tagValue(\"r\");\n  }\n  /**\n   * Context tag.\n   */\n  set context(context) {\n    if (context === void 0) {\n      this.tags = this.tags.filter(([tag, _value]) => tag !== \"context\");\n    } else {\n      this.tags = this.tags.filter(([tag, _value]) => tag !== \"context\");\n      this.tags.push([\"context\", context]);\n    }\n  }\n  get context() {\n    return this.tags.find(([tag, _value]) => tag === \"context\")?.[1] ?? void 0;\n  }\n  /**\n   * Will return the article URL or NDKEvent if they have already been\n   * set (it won't attempt to load remote events)\n   */\n  get article() {\n    return this._article;\n  }\n  /**\n   * Article the highlight is coming from.\n   *\n   * @param article Article URL or NDKEvent.\n   */\n  set article(article) {\n    this._article = article;\n    if (typeof article === \"string\") {\n      this.tags.push([\"r\", article]);\n    } else {\n      this.tag(article);\n    }\n  }\n  getArticleTag() {\n    return this.getMatchingTags(\"a\")[0] || this.getMatchingTags(\"e\")[0] || this.getMatchingTags(\"r\")[0];\n  }\n  async getArticle() {\n    if (this._article !== void 0) return this._article;\n    let taggedBech32;\n    const articleTag = this.getArticleTag();\n    if (!articleTag) return void 0;\n    switch (articleTag[0]) {\n      case \"a\": {\n        const [kind, pubkey, identifier] = articleTag[1].split(\":\");\n        taggedBech32 = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.naddrEncode({\n          kind: Number.parseInt(kind),\n          pubkey,\n          identifier\n        });\n        break;\n      }\n      case \"e\":\n        taggedBech32 = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.noteEncode(articleTag[1]);\n        break;\n      case \"r\":\n        this._article = articleTag[1];\n        break;\n    }\n    if (taggedBech32) {\n      let a = await this.ndk?.fetchEvent(taggedBech32);\n      if (a) {\n        if (a.kind === 30023 /* Article */) {\n          a = NDKArticle.from(a);\n        }\n        this._article = a;\n      }\n    }\n    return this._article;\n  }\n};\n\n// src/utils/imeta.ts\nfunction mapImetaTag(tag) {\n  const data = {};\n  if (tag.length === 2) {\n    const parts = tag[1].split(\" \");\n    for (let i = 0; i < parts.length; i += 2) {\n      const key = parts[i];\n      const value = parts[i + 1];\n      if (key === \"fallback\") {\n        if (!data.fallback) data.fallback = [];\n        data.fallback.push(value);\n      } else {\n        data[key] = value;\n      }\n    }\n    return data;\n  }\n  const tags = tag.slice(1);\n  for (const val of tags) {\n    const parts = val.split(\" \");\n    const key = parts[0];\n    const value = parts.slice(1).join(\" \");\n    if (key === \"fallback\") {\n      if (!data.fallback) data.fallback = [];\n      data.fallback.push(value);\n    } else {\n      data[key] = value;\n    }\n  }\n  return data;\n}\nfunction imetaTagToTag(imeta) {\n  const tag = [\"imeta\"];\n  for (const [key, value] of Object.entries(imeta)) {\n    if (Array.isArray(value)) {\n      for (const v of value) {\n        tag.push(`${key} ${v}`);\n      }\n    } else if (value) {\n      tag.push(`${key} ${value}`);\n    }\n  }\n  return tag;\n}\n\n// src/events/kinds/image.ts\nvar NDKImage = class _NDKImage extends NDKEvent {\n  static kind = 20 /* Image */;\n  static kinds = [20 /* Image */];\n  _imetas;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 20 /* Image */;\n  }\n  /**\n   * Creates a NDKImage from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKImage from.\n   * @returns NDKImage\n   */\n  static from(event) {\n    return new _NDKImage(event.ndk, event.rawEvent());\n  }\n  get isValid() {\n    return this.imetas.length > 0;\n  }\n  get imetas() {\n    if (this._imetas) return this._imetas;\n    this._imetas = this.tags.filter((tag) => tag[0] === \"imeta\").map(mapImetaTag).filter((imeta) => !!imeta.url);\n    return this._imetas;\n  }\n  set imetas(tags) {\n    this._imetas = tags;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"imeta\");\n    this.tags.push(...tags.map(imetaTagToTag));\n  }\n};\n\n// src/events/kinds/lists/index.ts\nvar NDKList = class _NDKList extends NDKEvent {\n  _encryptedTags;\n  static kinds = [\n    10063 /* BlossomList */,\n    30001 /* CategorizedBookmarkList */,\n    10004 /* CommunityList */,\n    10050 /* DirectMessageReceiveRelayList */,\n    10030 /* EmojiList */,\n    10015 /* InterestList */,\n    10001 /* PinList */,\n    10002 /* RelayList */,\n    10007 /* SearchRelayList */,\n    10006 /* BlockRelayList */,\n    10003 /* BookmarkList */\n  ];\n  /**\n   * Stores the number of bytes the content was before decryption\n   * to expire the cache when the content changes.\n   */\n  encryptedTagsLength;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30001 /* CategorizedBookmarkList */;\n  }\n  /**\n   * Wrap a NDKEvent into a NDKList\n   */\n  static from(ndkEvent) {\n    return new _NDKList(ndkEvent.ndk, ndkEvent);\n  }\n  /**\n   * Returns the title of the list. Falls back on fetching the name tag value.\n   */\n  get title() {\n    const titleTag = this.tagValue(\"title\") || this.tagValue(\"name\");\n    if (titleTag) return titleTag;\n    if (this.kind === 3 /* Contacts */) {\n      return \"Contacts\";\n    }\n    if (this.kind === 1e4 /* MuteList */) {\n      return \"Mute\";\n    }\n    if (this.kind === 10001 /* PinList */) {\n      return \"Pinned Notes\";\n    }\n    if (this.kind === 10002 /* RelayList */) {\n      return \"Relay Metadata\";\n    }\n    if (this.kind === 10003 /* BookmarkList */) {\n      return \"Bookmarks\";\n    }\n    if (this.kind === 10004 /* CommunityList */) {\n      return \"Communities\";\n    }\n    if (this.kind === 10005 /* PublicChatList */) {\n      return \"Public Chats\";\n    }\n    if (this.kind === 10006 /* BlockRelayList */) {\n      return \"Blocked Relays\";\n    }\n    if (this.kind === 10007 /* SearchRelayList */) {\n      return \"Search Relays\";\n    }\n    if (this.kind === 10050 /* DirectMessageReceiveRelayList */) {\n      return \"Direct Message Receive Relays\";\n    }\n    if (this.kind === 10015 /* InterestList */) {\n      return \"Interests\";\n    }\n    if (this.kind === 10030 /* EmojiList */) {\n      return \"Emojis\";\n    }\n    return this.tagValue(\"d\");\n  }\n  /**\n   * Sets the title of the list.\n   */\n  set title(title) {\n    this.removeTag([\"title\", \"name\"]);\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Returns the name of the list.\n   * @deprecated Please use \"title\" instead.\n   */\n  get name() {\n    return this.title;\n  }\n  /**\n   * Sets the name of the list.\n   * @deprecated Please use \"title\" instead. This method will use the `title` tag instead.\n   */\n  set name(name) {\n    this.title = name;\n  }\n  /**\n   * Returns the description of the list.\n   */\n  get description() {\n    return this.tagValue(\"description\");\n  }\n  /**\n   * Sets the description of the list.\n   */\n  set description(name) {\n    this.removeTag(\"description\");\n    if (name) this.tags.push([\"description\", name]);\n  }\n  /**\n   * Returns the image of the list.\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Sets the image of the list.\n   */\n  set image(name) {\n    this.removeTag(\"image\");\n    if (name) this.tags.push([\"image\", name]);\n  }\n  isEncryptedTagsCacheValid() {\n    return !!(this._encryptedTags && this.encryptedTagsLength === this.content.length);\n  }\n  /**\n   * Returns the decrypted content of the list.\n   */\n  async encryptedTags(useCache = true) {\n    if (useCache && this.isEncryptedTagsCacheValid()) return this._encryptedTags;\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    const user = await this.ndk.signer.user();\n    try {\n      if (this.content.length > 0) {\n        try {\n          const decryptedContent = await this.ndk.signer.decrypt(user, this.content);\n          const a = JSON.parse(decryptedContent);\n          if (a?.[0]) {\n            this.encryptedTagsLength = this.content.length;\n            return this._encryptedTags = a;\n          }\n          this.encryptedTagsLength = this.content.length;\n          return this._encryptedTags = [];\n        } catch (_e) {\n        }\n      }\n    } catch (_e) {\n    }\n    return [];\n  }\n  /**\n   * This method can be overriden to validate that a tag is valid for this list.\n   *\n   * (i.e. the NDKPersonList can validate that items are NDKUser instances)\n   */\n  validateTag(_tagValue) {\n    return true;\n  }\n  getItems(type) {\n    return this.tags.filter((tag) => tag[0] === type);\n  }\n  /**\n   * Returns the unecrypted items in this list.\n   */\n  get items() {\n    return this.tags.filter((t) => {\n      return ![\n        \"d\",\n        \"L\",\n        \"l\",\n        \"title\",\n        \"name\",\n        \"description\",\n        \"published_at\",\n        \"summary\",\n        \"image\",\n        \"thumb\",\n        \"alt\",\n        \"expiration\",\n        \"subject\",\n        \"client\"\n      ].includes(t[0]);\n    });\n  }\n  /**\n   * Adds a new item to the list.\n   * @param relay Relay to add\n   * @param mark Optional mark to add to the item\n   * @param encrypted Whether to encrypt the item\n   * @param position Where to add the item in the list (top or bottom)\n   */\n  async addItem(item, mark = void 0, encrypted = false, position = \"bottom\") {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    let tags;\n    if (item instanceof NDKEvent) {\n      tags = [item.tagReference(mark)];\n    } else if (item instanceof NDKUser) {\n      tags = item.referenceTags();\n    } else if (item instanceof NDKRelay) {\n      tags = item.referenceTags();\n    } else if (Array.isArray(item)) {\n      tags = [item];\n    } else {\n      throw new Error(\"Invalid object type\");\n    }\n    if (mark) tags[0].push(mark);\n    if (encrypted) {\n      const user = await this.ndk.signer.user();\n      const currentList = await this.encryptedTags();\n      if (position === \"top\") currentList.unshift(...tags);\n      else currentList.push(...tags);\n      this._encryptedTags = currentList;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(currentList);\n      await this.encrypt(user);\n    } else {\n      if (position === \"top\") this.tags.unshift(...tags);\n      else this.tags.push(...tags);\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n  }\n  /**\n   * Removes an item from the list from both the encrypted and unencrypted lists.\n   * @param value value of item to remove from the list\n   * @param publish whether to publish the change\n   * @returns\n   */\n  async removeItemByValue(value, publish = true) {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    const index = this.tags.findIndex((tag) => tag[1] === value);\n    if (index >= 0) {\n      this.tags.splice(index, 1);\n    }\n    const user = await this.ndk.signer.user();\n    const encryptedTags = await this.encryptedTags();\n    const encryptedIndex = encryptedTags.findIndex((tag) => tag[1] === value);\n    if (encryptedIndex >= 0) {\n      encryptedTags.splice(encryptedIndex, 1);\n      this._encryptedTags = encryptedTags;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(encryptedTags);\n      await this.encrypt(user);\n    }\n    if (publish) {\n      return this.publishReplaceable();\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n  }\n  /**\n   * Removes an item from the list.\n   *\n   * @param index The index of the item to remove.\n   * @param encrypted Whether to remove from the encrypted list or not.\n   */\n  async removeItem(index, encrypted) {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    if (encrypted) {\n      const user = await this.ndk.signer.user();\n      const currentList = await this.encryptedTags();\n      currentList.splice(index, 1);\n      this._encryptedTags = currentList;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(currentList);\n      await this.encrypt(user);\n    } else {\n      this.tags.splice(index, 1);\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n    return this;\n  }\n  has(item) {\n    return this.items.some((tag) => tag[1] === item);\n  }\n  /**\n   * Creates a filter that will result in fetching\n   * the items of this list\n   * @example\n   * const list = new NDKList(...);\n   * const filters = list.filterForItems();\n   * const events = await ndk.fetchEvents(filters);\n   */\n  filterForItems() {\n    const ids = /* @__PURE__ */ new Set();\n    const nip33Queries = /* @__PURE__ */ new Map();\n    const filters = [];\n    for (const tag of this.items) {\n      if (tag[0] === \"e\" && tag[1]) {\n        ids.add(tag[1]);\n      } else if (tag[0] === \"a\" && tag[1]) {\n        const [kind, pubkey, dTag] = tag[1].split(\":\");\n        if (!kind || !pubkey) continue;\n        const key = `${kind}:${pubkey}`;\n        const item = nip33Queries.get(key) || [];\n        item.push(dTag || \"\");\n        nip33Queries.set(key, item);\n      }\n    }\n    if (ids.size > 0) {\n      filters.push({ ids: Array.from(ids) });\n    }\n    if (nip33Queries.size > 0) {\n      for (const [key, values] of nip33Queries.entries()) {\n        const [kind, pubkey] = key.split(\":\");\n        filters.push({\n          kinds: [Number.parseInt(kind)],\n          authors: [pubkey],\n          \"#d\": values\n        });\n      }\n    }\n    return filters;\n  }\n};\nvar lists_default = NDKList;\n\n// src/events/kinds/nutzap/index.ts\n\nvar NDKNutzap = class _NDKNutzap extends NDKEvent {\n  debug;\n  _proofs = [];\n  static kind = 9321 /* Nutzap */;\n  static kinds = [_NDKNutzap.kind];\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 9321 /* Nutzap */;\n    this.debug = ndk?.debug.extend(\"nutzap\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:nutzap\");\n    if (!this.alt) this.alt = \"This is a nutzap\";\n    try {\n      const proofTags = this.getMatchingTags(\"proof\");\n      if (proofTags.length) {\n        this._proofs = proofTags.map((tag) => JSON.parse(tag[1]));\n      } else {\n        this._proofs = JSON.parse(this.content);\n      }\n    } catch {\n      return;\n    }\n  }\n  static from(event) {\n    const e = new _NDKNutzap(event.ndk, event);\n    if (!e._proofs || !e._proofs.length) return;\n    return e;\n  }\n  set comment(comment) {\n    this.content = comment ?? \"\";\n  }\n  get comment() {\n    const c = this.tagValue(\"comment\");\n    if (c) return c;\n    return this.content;\n  }\n  set proofs(proofs) {\n    this._proofs = proofs;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"proof\");\n    for (const proof of proofs) {\n      this.tags.push([\"proof\", JSON.stringify(proof)]);\n    }\n  }\n  get proofs() {\n    return this._proofs;\n  }\n  get rawP2pk() {\n    const firstProof = this.proofs[0];\n    try {\n      const secret = JSON.parse(firstProof.secret);\n      let payload;\n      if (typeof secret === \"string\") {\n        payload = JSON.parse(secret);\n        this.debug(\"stringified payload\", firstProof.secret);\n      } else if (typeof secret === \"object\") {\n        payload = secret;\n      }\n      if (Array.isArray(payload) && payload[0] === \"P2PK\" && payload.length > 1 && typeof payload[1] === \"object\" && payload[1] !== null) {\n        return payload[1].data;\n      }\n      if (typeof payload === \"object\" && payload !== null && typeof payload[1]?.data === \"string\") {\n        return payload[1].data;\n      }\n    } catch (e) {\n      this.debug(\"error parsing p2pk pubkey\", e, this.proofs[0]);\n    }\n    return void 0;\n  }\n  /**\n   * Gets the p2pk pubkey that is embedded in the first proof.\n   *\n   * Note that this returns a nostr pubkey, not a cashu pubkey (no \"02\" prefix)\n   */\n  get p2pk() {\n    const rawP2pk = this.rawP2pk;\n    if (!rawP2pk) return;\n    return rawP2pk.startsWith(\"02\") ? rawP2pk.slice(2) : rawP2pk;\n  }\n  /**\n   * Get the mint where this nutzap proofs exist\n   */\n  get mint() {\n    return this.tagValue(\"u\");\n  }\n  set mint(value) {\n    this.replaceTag([\"u\", value]);\n  }\n  get unit() {\n    let _unit = this.tagValue(\"unit\") ?? \"sat\";\n    if (_unit?.startsWith(\"msat\")) _unit = \"sat\";\n    return _unit;\n  }\n  set unit(value) {\n    this.removeTag(\"unit\");\n    if (value?.startsWith(\"msat\")) throw new Error(\"msat is not allowed, use sat denomination instead\");\n    if (value) this.tag([\"unit\", value]);\n  }\n  get amount() {\n    const amount = this.proofs.reduce((total, proof) => total + proof.amount, 0);\n    return amount;\n  }\n  sender = this.author;\n  /**\n   * Set the target of the nutzap\n   * @param target The target of the nutzap (a user or an event)\n   */\n  set target(target) {\n    this.tags = this.tags.filter((t) => t[0] !== \"p\");\n    if (target instanceof NDKEvent) {\n      this.tags.push(target.tagReference());\n    }\n  }\n  set recipientPubkey(pubkey) {\n    this.removeTag(\"p\");\n    this.tag([\"p\", pubkey]);\n  }\n  get recipientPubkey() {\n    return this.tagValue(\"p\");\n  }\n  get recipient() {\n    const pubkey = this.recipientPubkey;\n    if (this.ndk) return this.ndk.getUser({ pubkey });\n    return new NDKUser({ pubkey });\n  }\n  async toNostrEvent() {\n    if (this.unit === \"msat\") {\n      this.unit = \"sat\";\n    }\n    this.removeTag(\"amount\");\n    this.tags.push([\"amount\", this.amount.toString()]);\n    const event = await super.toNostrEvent();\n    event.content = this.comment;\n    return event;\n  }\n  /**\n   * Validates that the nutzap conforms to NIP-61\n   */\n  get isValid() {\n    let eTagCount = 0;\n    let pTagCount = 0;\n    let mintTagCount = 0;\n    for (const tag of this.tags) {\n      if (tag[0] === \"e\") eTagCount++;\n      if (tag[0] === \"p\") pTagCount++;\n      if (tag[0] === \"u\") mintTagCount++;\n    }\n    return (\n      // exactly one recipient and mint\n      pTagCount === 1 && mintTagCount === 1 && // must have at most one e tag\n      eTagCount <= 1 && // must have at least one proof\n      this.proofs.length > 0\n    );\n  }\n};\nfunction proofP2pk(proof) {\n  try {\n    const secret = JSON.parse(proof.secret);\n    let payload = {};\n    if (typeof secret === \"string\") {\n      payload = JSON.parse(secret);\n    } else if (typeof secret === \"object\") {\n      payload = secret;\n    }\n    const isP2PKLocked = payload[0] === \"P2PK\" && payload[1]?.data;\n    if (isP2PKLocked) {\n      return payload[1].data;\n    }\n  } catch (e) {\n    console.error(\"error parsing p2pk pubkey\", e, proof);\n  }\n}\nfunction proofP2pkNostr(proof) {\n  const p2pk = proofP2pk(proof);\n  if (!p2pk) return;\n  if (p2pk.startsWith(\"02\") && p2pk.length === 66) return p2pk.slice(2);\n  return p2pk;\n}\nfunction cashuPubkeyToNostrPubkey(cashuPubkey) {\n  if (cashuPubkey.startsWith(\"02\") && cashuPubkey.length === 66) return cashuPubkey.slice(2);\n  return void 0;\n}\n\n// src/events/kinds/simple-group/member-list.ts\nvar NDKSimpleGroupMemberList = class _NDKSimpleGroupMemberList extends NDKEvent {\n  relaySet;\n  memberSet = /* @__PURE__ */ new Set();\n  static kind = 39002 /* GroupMembers */;\n  static kinds = [39002 /* GroupMembers */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 39002 /* GroupMembers */;\n    this.memberSet = new Set(this.members);\n  }\n  static from(event) {\n    return new _NDKSimpleGroupMemberList(event.ndk, event);\n  }\n  get members() {\n    return this.getMatchingTags(\"p\").map((tag) => tag[1]);\n  }\n  hasMember(member) {\n    return this.memberSet.has(member);\n  }\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    relaySet ??= this.relaySet;\n    return super.publishReplaceable(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/events/kinds/simple-group/metadata.ts\nvar NDKSimpleGroupMetadata = class _NDKSimpleGroupMetadata extends NDKEvent {\n  static kind = 39e3 /* GroupMetadata */;\n  static kinds = [39e3 /* GroupMetadata */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 39e3 /* GroupMetadata */;\n  }\n  static from(event) {\n    return new _NDKSimpleGroupMetadata(event.ndk, event);\n  }\n  get name() {\n    return this.tagValue(\"name\");\n  }\n  get picture() {\n    return this.tagValue(\"picture\");\n  }\n  get about() {\n    return this.tagValue(\"about\");\n  }\n  get scope() {\n    if (this.getMatchingTags(\"public\").length > 0) return \"public\";\n    if (this.getMatchingTags(\"public\").length > 0) return \"private\";\n    return void 0;\n  }\n  set scope(scope) {\n    this.removeTag(\"public\");\n    this.removeTag(\"private\");\n    if (scope === \"public\") {\n      this.tags.push([\"public\", \"\"]);\n    } else if (scope === \"private\") {\n      this.tags.push([\"private\", \"\"]);\n    }\n  }\n  get access() {\n    if (this.getMatchingTags(\"open\").length > 0) return \"open\";\n    if (this.getMatchingTags(\"closed\").length > 0) return \"closed\";\n    return void 0;\n  }\n  set access(access) {\n    this.removeTag(\"open\");\n    this.removeTag(\"closed\");\n    if (access === \"open\") {\n      this.tags.push([\"open\", \"\"]);\n    } else if (access === \"closed\") {\n      this.tags.push([\"closed\", \"\"]);\n    }\n  }\n};\n\n// src/events/kinds/story.ts\nvar NDKStoryStickerType = /* @__PURE__ */ ((NDKStoryStickerType2) => {\n  NDKStoryStickerType2[\"Pubkey\"] = \"pubkey\";\n  NDKStoryStickerType2[\"Event\"] = \"event\";\n  NDKStoryStickerType2[\"Prompt\"] = \"prompt\";\n  NDKStoryStickerType2[\"Text\"] = \"text\";\n  NDKStoryStickerType2[\"Countdown\"] = \"countdown\";\n  return NDKStoryStickerType2;\n})(NDKStoryStickerType || {});\nfunction strToPosition(positionStr) {\n  const [x, y] = positionStr.split(\",\").map(Number);\n  return { x, y };\n}\nfunction strToDimension(dimensionStr) {\n  const [width, height] = dimensionStr.split(\"x\").map(Number);\n  return { width, height };\n}\nvar NDKStorySticker = class _NDKStorySticker {\n  static Text = \"text\" /* Text */;\n  static Pubkey = \"pubkey\" /* Pubkey */;\n  static Event = \"event\" /* Event */;\n  static Prompt = \"prompt\" /* Prompt */;\n  static Countdown = \"countdown\" /* Countdown */;\n  type;\n  value;\n  position;\n  dimension;\n  properties;\n  constructor(arg) {\n    if (Array.isArray(arg)) {\n      const tag = arg;\n      if (tag[0] !== \"sticker\" || tag.length < 5) {\n        throw new Error(\"Invalid sticker tag\");\n      }\n      this.type = tag[1];\n      this.value = tag[2];\n      this.position = strToPosition(tag[3]);\n      this.dimension = strToDimension(tag[4]);\n      const props = {};\n      for (let i = 5; i < tag.length; i++) {\n        const [key, ...rest] = tag[i].split(\" \");\n        props[key] = rest.join(\" \");\n      }\n      if (Object.keys(props).length > 0) {\n        this.properties = props;\n      }\n    } else {\n      this.type = arg;\n      this.value = void 0;\n      this.position = { x: 0, y: 0 };\n      this.dimension = { width: 0, height: 0 };\n    }\n  }\n  static fromTag(tag) {\n    try {\n      return new _NDKStorySticker(tag);\n    } catch {\n      return null;\n    }\n  }\n  get style() {\n    return this.properties?.style;\n  }\n  set style(style) {\n    if (style) this.properties = { ...this.properties, style };\n    else delete this.properties?.style;\n  }\n  get rotation() {\n    return this.properties?.rot ? Number.parseFloat(this.properties.rot) : void 0;\n  }\n  set rotation(rotation) {\n    if (rotation !== void 0) {\n      this.properties = { ...this.properties, rot: rotation.toString() };\n    } else {\n      delete this.properties?.rot;\n    }\n  }\n  /**\n   * Checks if the sticker is valid.\n   *\n   * @returns {boolean} - True if the sticker is valid, false otherwise.\n   */\n  get isValid() {\n    return this.hasValidDimensions() && this.hasValidPosition();\n  }\n  hasValidDimensions = () => {\n    return typeof this.dimension.width === \"number\" && typeof this.dimension.height === \"number\" && !Number.isNaN(this.dimension.width) && !Number.isNaN(this.dimension.height);\n  };\n  hasValidPosition = () => {\n    return typeof this.position.x === \"number\" && typeof this.position.y === \"number\" && !Number.isNaN(this.position.x) && !Number.isNaN(this.position.y);\n  };\n  toTag() {\n    if (!this.isValid) {\n      const errors = [\n        !this.hasValidDimensions() ? \"dimensions is invalid\" : void 0,\n        !this.hasValidPosition() ? \"position is invalid\" : void 0\n      ].filter(Boolean);\n      throw new Error(`Invalid sticker: ${errors.join(\", \")}`);\n    }\n    let value;\n    switch (this.type) {\n      case \"event\" /* Event */:\n        value = this.value.tagId();\n        break;\n      case \"pubkey\" /* Pubkey */:\n        value = this.value.pubkey;\n        break;\n      default:\n        value = this.value;\n    }\n    const tag = [\"sticker\", this.type, value, coordinates(this.position), dimension(this.dimension)];\n    if (this.properties) {\n      for (const [key, propValue] of Object.entries(this.properties)) {\n        tag.push(`${key} ${propValue}`);\n      }\n    }\n    return tag;\n  }\n};\nvar NDKStory = class _NDKStory extends NDKEvent {\n  static kind = 23 /* Story */;\n  static kinds = [23 /* Story */];\n  _imeta;\n  _dimensions;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 23 /* Story */;\n    if (rawEvent) {\n      for (const tag of rawEvent.tags) {\n        switch (tag[0]) {\n          case \"imeta\":\n            this._imeta = mapImetaTag(tag);\n            break;\n          case \"dim\":\n            this.dimensions = strToDimension(tag[1]);\n            break;\n        }\n      }\n    }\n  }\n  /**\n   * Creates a NDKStory from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKStory from.\n   * @returns NDKStory\n   */\n  static from(event) {\n    return new _NDKStory(event.ndk, event);\n  }\n  /**\n   * Checks if the story is valid (has exactly one imeta tag).\n   */\n  get isValid() {\n    return !!this.imeta;\n  }\n  /**\n   * Gets the first imeta tag (there should only be one).\n   */\n  get imeta() {\n    return this._imeta;\n  }\n  /**\n   * Sets a single imeta tag, replacing any existing ones.\n   */\n  set imeta(tag) {\n    this._imeta = tag;\n    this.tags = this.tags.filter((t) => t[0] !== \"imeta\");\n    if (tag) {\n      this.tags.push(imetaTagToTag(tag));\n    }\n  }\n  /**\n   * Getter for the story dimensions.\n   *\n   * @returns {NDKStoryDimension | undefined} - The story dimensions if available, otherwise undefined.\n   */\n  get dimensions() {\n    const dimTag = this.tagValue(\"dim\");\n    if (!dimTag) return void 0;\n    return strToDimension(dimTag);\n  }\n  /**\n   * Setter for the story dimensions.\n   *\n   * @param {NDKStoryDimension | undefined} dimensions - The dimensions to set for the story.\n   */\n  set dimensions(dimensions) {\n    this.removeTag(\"dim\");\n    if (dimensions) {\n      this.tags.push([\"dim\", `${dimensions.width}x${dimensions.height}`]);\n    }\n  }\n  /**\n   * Getter for the story duration.\n   *\n   * @returns {number | undefined} - The story duration in seconds if available, otherwise undefined.\n   */\n  get duration() {\n    const durTag = this.tagValue(\"dur\");\n    if (!durTag) return void 0;\n    return Number.parseInt(durTag);\n  }\n  /**\n   * Setter for the story duration.\n   *\n   * @param {number | undefined} duration - The duration in seconds to set for the story.\n   */\n  set duration(duration) {\n    this.removeTag(\"dur\");\n    if (duration !== void 0) {\n      this.tags.push([\"dur\", duration.toString()]);\n    }\n  }\n  /**\n   * Gets all stickers from the story.\n   *\n   * @returns {NDKStorySticker[]} - Array of stickers in the story.\n   */\n  get stickers() {\n    const stickers = [];\n    for (const tag of this.tags) {\n      if (tag[0] !== \"sticker\" || tag.length < 5) continue;\n      const sticker = NDKStorySticker.fromTag(tag);\n      if (sticker) stickers.push(sticker);\n    }\n    return stickers;\n  }\n  /**\n   * Adds a sticker to the story.\n   *\n   * @param {NDKStorySticker|StorySticker} sticker - The sticker to add.\n   */\n  addSticker(sticker) {\n    let stickerToAdd;\n    if (sticker instanceof NDKStorySticker) {\n      stickerToAdd = sticker;\n    } else {\n      const tag = [\n        \"sticker\",\n        sticker.type,\n        typeof sticker.value === \"string\" ? sticker.value : \"\",\n        coordinates(sticker.position),\n        dimension(sticker.dimension)\n      ];\n      if (sticker.properties) {\n        for (const [key, value] of Object.entries(sticker.properties)) {\n          tag.push(`${key} ${value}`);\n        }\n      }\n      stickerToAdd = new NDKStorySticker(tag);\n      stickerToAdd.value = sticker.value;\n    }\n    if (stickerToAdd.type === \"pubkey\" /* Pubkey */) {\n      this.tag(stickerToAdd.value);\n    } else if (stickerToAdd.type === \"event\" /* Event */) {\n      this.tag(stickerToAdd.value);\n    }\n    this.tags.push(stickerToAdd.toTag());\n  }\n  /**\n   * Removes a sticker from the story.\n   *\n   * @param {number} index - The index of the sticker to remove.\n   */\n  removeSticker(index) {\n    const stickers = this.stickers;\n    if (index < 0 || index >= stickers.length) return;\n    let stickerCount = 0;\n    for (let i = 0; i < this.tags.length; i++) {\n      if (this.tags[i][0] === \"sticker\") {\n        if (stickerCount === index) {\n          this.tags.splice(i, 1);\n          break;\n        }\n        stickerCount++;\n      }\n    }\n  }\n};\nvar coordinates = (position) => `${position.x},${position.y}`;\nvar dimension = (dimension2) => `${dimension2.width}x${dimension2.height}`;\n\n// src/events/kinds/subscriptions/amount.ts\nvar possibleIntervalFrequencies = [\n  \"daily\",\n  \"weekly\",\n  \"monthly\",\n  \"quarterly\",\n  \"yearly\"\n];\nfunction calculateTermDurationInSeconds(term) {\n  switch (term) {\n    case \"daily\":\n      return 24 * 60 * 60;\n    case \"weekly\":\n      return 7 * 24 * 60 * 60;\n    case \"monthly\":\n      return 30 * 24 * 60 * 60;\n    case \"quarterly\":\n      return 3 * 30 * 24 * 60 * 60;\n    case \"yearly\":\n      return 365 * 24 * 60 * 60;\n  }\n}\nfunction newAmount(amount, currency, term) {\n  return [\"amount\", amount.toString(), currency, term];\n}\nfunction parseTagToSubscriptionAmount(tag) {\n  const amount = Number.parseInt(tag[1]);\n  if (Number.isNaN(amount) || amount === void 0 || amount === null || amount <= 0) return void 0;\n  const currency = tag[2];\n  if (currency === void 0 || currency === \"\") return void 0;\n  const term = tag[3];\n  if (term === void 0) return void 0;\n  if (!possibleIntervalFrequencies.includes(term)) return void 0;\n  return {\n    amount,\n    currency,\n    term\n  };\n}\n\n// src/events/kinds/subscriptions/tier.ts\nvar NDKSubscriptionTier = class _NDKSubscriptionTier extends NDKArticle {\n  static kind = 37001 /* SubscriptionTier */;\n  static kinds = [37001 /* SubscriptionTier */];\n  constructor(ndk, rawEvent) {\n    const k = rawEvent?.kind ?? 37001 /* SubscriptionTier */;\n    super(ndk, rawEvent);\n    this.kind = k;\n  }\n  /**\n   * Creates a new NDKSubscriptionTier from an event\n   * @param event\n   * @returns NDKSubscriptionTier\n   */\n  static from(event) {\n    return new _NDKSubscriptionTier(event.ndk, event);\n  }\n  /**\n   * Returns perks for this tier\n   */\n  get perks() {\n    return this.getMatchingTags(\"perk\").map((tag) => tag[1]).filter((perk) => perk !== void 0);\n  }\n  /**\n   * Adds a perk to this tier\n   */\n  addPerk(perk) {\n    this.tags.push([\"perk\", perk]);\n  }\n  /**\n   * Returns the amount for this tier\n   */\n  get amounts() {\n    return this.getMatchingTags(\"amount\").map((tag) => parseTagToSubscriptionAmount(tag)).filter((a) => a !== void 0);\n  }\n  /**\n   * Adds an amount to this tier\n   * @param amount Amount in the smallest unit of the currency (e.g. cents, msats)\n   * @param currency Currency code. Use msat for millisatoshis\n   * @param term One of daily, weekly, monthly, quarterly, yearly\n   */\n  addAmount(amount, currency, term) {\n    this.tags.push(newAmount(amount, currency, term));\n  }\n  /**\n   * Sets a relay where content related to this tier can be found\n   * @param relayUrl URL of the relay\n   */\n  set relayUrl(relayUrl) {\n    this.tags.push([\"r\", relayUrl]);\n  }\n  /**\n   * Returns the relay URLs for this tier\n   */\n  get relayUrls() {\n    return this.getMatchingTags(\"r\").map((tag) => tag[1]).filter((relay) => relay !== void 0);\n  }\n  /**\n   * Gets the verifier pubkey for this tier. This is the pubkey that will generate\n   * subscription payment receipts\n   */\n  get verifierPubkey() {\n    return this.tagValue(\"p\");\n  }\n  /**\n   * Sets the verifier pubkey for this tier.\n   */\n  set verifierPubkey(pubkey) {\n    this.removeTag(\"p\");\n    if (pubkey) this.tags.push([\"p\", pubkey]);\n  }\n  /**\n   * Checks if this tier is valid\n   */\n  get isValid() {\n    return this.title !== void 0 && // Must have a title\n    this.amounts.length > 0;\n  }\n};\n\n// src/events/kinds/video.ts\nvar NDKVideo = class _NDKVideo extends NDKEvent {\n  static kind = 21 /* Video */;\n  static kinds = [34235 /* HorizontalVideo */, 34236 /* VerticalVideo */, 22 /* ShortVideo */, 21 /* Video */];\n  _imetas;\n  /**\n   * Creates a NDKArticle from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKArticle from.\n   * @returns NDKArticle\n   */\n  static from(event) {\n    return new _NDKVideo(event.ndk, event.rawEvent());\n  }\n  /**\n   * Getter for the article title.\n   *\n   * @returns {string | undefined} - The article title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the article title.\n   *\n   * @param {string | undefined} title - The title to set for the article.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the article thumbnail.\n   *\n   * @returns {string | undefined} - The article thumbnail if available, otherwise undefined.\n   */\n  get thumbnail() {\n    let thumbnail;\n    if (this.imetas && this.imetas.length > 0) {\n      thumbnail = this.imetas[0].image?.[0];\n    }\n    return thumbnail ?? this.tagValue(\"thumb\");\n  }\n  get imetas() {\n    if (this._imetas) return this._imetas;\n    this._imetas = this.tags.filter((tag) => tag[0] === \"imeta\").map(mapImetaTag);\n    return this._imetas;\n  }\n  set imetas(tags) {\n    this._imetas = tags;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"imeta\");\n    this.tags.push(...tags.map(imetaTagToTag));\n  }\n  get url() {\n    if (this.imetas && this.imetas.length > 0) {\n      return this.imetas[0].url;\n    }\n    return this.tagValue(\"url\");\n  }\n  /**\n   * Getter for the article's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      return Number.parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Generates content tags for the article.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.kind) {\n      if (this.imetas?.[0]?.dim) {\n        const [width, height] = this.imetas[0].dim.split(\"x\");\n        const isPortrait = width && height && Number.parseInt(width) < Number.parseInt(height);\n        const isShort = this.duration && this.duration < 120;\n        if (isShort && isPortrait) this.kind = 22 /* ShortVideo */;\n        else this.kind = 21 /* Video */;\n      }\n    }\n    return super.generateTags();\n  }\n  get duration() {\n    const tag = this.tagValue(\"duration\");\n    if (tag) {\n      return Number.parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the video's duration\n   *\n   * @param {number | undefined} duration - The duration to set for the video (in seconds)\n   */\n  set duration(dur) {\n    this.removeTag(\"duration\");\n    if (dur !== void 0) {\n      this.tags.push([\"duration\", Math.floor(dur).toString()]);\n    }\n  }\n};\n\n// src/events/kinds/wiki.ts\nvar NDKWiki = class _NDKWiki extends NDKArticle {\n  static kind = 30818 /* Wiki */;\n  static kinds = [30818 /* Wiki */];\n  static from(event) {\n    return new _NDKWiki(event.ndk, event.rawEvent());\n  }\n  get isDefered() {\n    return this.hasTag(\"a\", \"defer\");\n  }\n  get deferedId() {\n    return this.tagValue(\"a\", \"defer\");\n  }\n  /**\n   * Defers the author's wiki event to another wiki event.\n   *\n   * Wiki-events can tag other wiki-events with a `defer` marker to indicate that it considers someone else's entry as a \"better\" version of itself. If using a `defer` marker both `a` and `e` tags SHOULD be used.\n   *\n   * @example\n   * myWiki.defer = betterWikiEntryOnTheSameTopic;\n   * myWiki.publishReplaceable()\n   */\n  set defer(deferedTo) {\n    this.removeTag(\"a\", \"defer\");\n    this.tag(deferedTo, \"defer\");\n  }\n};\nvar NDKWikiMergeRequest = class _NDKWikiMergeRequest extends NDKEvent {\n  static kind = 818 /* WikiMergeRequest */;\n  static kinds = [818 /* WikiMergeRequest */];\n  static from(event) {\n    return new _NDKWikiMergeRequest(event.ndk, event.rawEvent());\n  }\n  /**\n   * The target ID (<kind:pubkey:d-tag>) of the wiki event to merge into.\n   */\n  get targetId() {\n    return this.tagValue(\"a\");\n  }\n  /**\n   * Sets the target ID (<kind:pubkey:d-tag>) of the wiki event to merge into.\n   */\n  set target(targetEvent) {\n    this.tags = this.tags.filter((tag) => {\n      if (tag[0] === \"a\") return true;\n      if (tag[0] === \"e\" && tag[3] !== \"source\") return true;\n    });\n    this.tag(targetEvent);\n  }\n  /**\n   * The source ID of the wiki event to merge from.\n   */\n  get sourceId() {\n    return this.tagValue(\"e\", \"source\");\n  }\n  /**\n   * Sets the event we are asking to get merged into the target.\n   */\n  set source(sourceEvent) {\n    this.removeTag(\"e\", \"source\");\n    this.tag(sourceEvent, \"source\", false, \"e\");\n  }\n};\n\n// src/events/wrap.ts\nfunction wrapEvent(event) {\n  const eventWrappingMap = /* @__PURE__ */ new Map();\n  for (const klass2 of [\n    NDKImage,\n    NDKVideo,\n    NDKCashuMintList,\n    NDKArticle,\n    NDKHighlight,\n    NDKWiki,\n    NDKNutzap,\n    NDKSimpleGroupMemberList,\n    NDKSimpleGroupMetadata,\n    NDKSubscriptionTier,\n    NDKCashuToken,\n    NDKList,\n    NDKStory\n  ]) {\n    for (const kind of klass2.kinds) {\n      eventWrappingMap.set(kind, klass2);\n    }\n  }\n  const klass = eventWrappingMap.get(event.kind);\n  if (klass) return klass.from(event);\n  return event;\n}\n\n// src/subscription/utils.ts\n\nvar MAX_SUBID_LENGTH = 20;\nfunction queryFullyFilled(subscription) {\n  if (filterIncludesIds(subscription.filter)) {\n    if (resultHasAllRequestedIds(subscription)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction compareFilter(filter1, filter2) {\n  if (Object.keys(filter1).length !== Object.keys(filter2).length) return false;\n  for (const [key, value] of Object.entries(filter1)) {\n    const valuesInFilter2 = filter2[key];\n    if (!valuesInFilter2) return false;\n    if (Array.isArray(value) && Array.isArray(valuesInFilter2)) {\n      const v = value;\n      for (const valueInFilter2 of valuesInFilter2) {\n        const val = valueInFilter2;\n        if (!v.includes(val)) {\n          return false;\n        }\n      }\n    } else {\n      if (valuesInFilter2 !== value) return false;\n    }\n  }\n  return true;\n}\nfunction filterIncludesIds(filter) {\n  return !!filter.ids;\n}\nfunction resultHasAllRequestedIds(subscription) {\n  const ids = subscription.filter.ids;\n  return !!ids && ids.length === subscription.eventFirstSeen.size;\n}\nfunction generateSubId(subscriptions, filters) {\n  const subIds = subscriptions.map((sub) => sub.subId).filter(Boolean);\n  const subIdParts = [];\n  const filterNonKindKeys = /* @__PURE__ */ new Set();\n  const filterKinds = /* @__PURE__ */ new Set();\n  if (subIds.length > 0) {\n    subIdParts.push(Array.from(new Set(subIds)).join(\",\"));\n  } else {\n    for (const filter of filters) {\n      for (const key of Object.keys(filter)) {\n        if (key === \"kinds\") {\n          filter.kinds?.forEach((k) => filterKinds.add(k));\n        } else {\n          filterNonKindKeys.add(key);\n        }\n      }\n    }\n    if (filterKinds.size > 0) {\n      subIdParts.push(`kinds:${Array.from(filterKinds).join(\",\")}`);\n    }\n    if (filterNonKindKeys.size > 0) {\n      subIdParts.push(Array.from(filterNonKindKeys).join(\",\"));\n    }\n  }\n  let subId = subIdParts.join(\"-\");\n  if (subId.length > MAX_SUBID_LENGTH) subId = subId.substring(0, MAX_SUBID_LENGTH);\n  subId += `-${Math.floor(Math.random() * 999).toString()}`;\n  return subId;\n}\nfunction filterForEventsTaggingId(id) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(id);\n    switch (decoded.type) {\n      case \"naddr\":\n        return {\n          \"#a\": [`${decoded.data.kind}:${decoded.data.pubkey}:${decoded.data.identifier}`]\n        };\n      case \"nevent\":\n        return { \"#e\": [decoded.data.id] };\n      case \"note\":\n        return { \"#e\": [decoded.data] };\n      case \"nprofile\":\n        return { \"#p\": [decoded.data.pubkey] };\n      case \"npub\":\n        return { \"#p\": [decoded.data] };\n    }\n  } catch {\n  }\n}\nfunction filterAndRelaySetFromBech32(beche2, ndk) {\n  const filter = filterFromId(beche2);\n  const relays = relaysFromBech32(beche2, ndk);\n  if (relays.length === 0) return { filter };\n  return {\n    filter,\n    relaySet: new NDKRelaySet(new Set(relays), ndk)\n  };\n}\nfunction filterFromId(id) {\n  let decoded;\n  if (id.match(NIP33_A_REGEX)) {\n    const [kind, pubkey, identifier] = id.split(\":\");\n    const filter = {\n      authors: [pubkey],\n      kinds: [Number.parseInt(kind)]\n    };\n    if (identifier) {\n      filter[\"#d\"] = [identifier];\n    }\n    return filter;\n  }\n  if (id.match(BECH32_REGEX)) {\n    try {\n      decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(id);\n      switch (decoded.type) {\n        case \"nevent\": {\n          const filter = { ids: [decoded.data.id] };\n          if (decoded.data.author) filter.authors = [decoded.data.author];\n          if (decoded.data.kind) filter.kinds = [decoded.data.kind];\n          return filter;\n        }\n        case \"note\":\n          return { ids: [decoded.data] };\n        case \"naddr\": {\n          const filter = {\n            authors: [decoded.data.pubkey],\n            kinds: [decoded.data.kind]\n          };\n          if (decoded.data.identifier) filter[\"#d\"] = [decoded.data.identifier];\n          return filter;\n        }\n      }\n    } catch (e) {\n      console.error(\"Error decoding\", id, e);\n    }\n  }\n  return { ids: [id] };\n}\nfunction isNip33AValue(value) {\n  return value.match(NIP33_A_REGEX) !== null;\n}\nvar NIP33_A_REGEX = /^(\\d+):([0-9A-Fa-f]+)(?::(.*))?$/;\nvar BECH32_REGEX = /^n(event|ote|profile|pub|addr)1[\\d\\w]+$/;\nfunction relaysFromBech32(bech322, ndk) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(bech322);\n    if ([\"naddr\", \"nevent\"].includes(decoded?.type)) {\n      const data = decoded.data;\n      if (data?.relays) {\n        return data.relays.map((r) => new NDKRelay(r, ndk.relayAuthDefaultPolicy, ndk));\n      }\n    }\n  } catch (_e) {\n  }\n  return [];\n}\n\n// src/subscription/index.ts\nvar NDKSubscriptionCacheUsage = /* @__PURE__ */ ((NDKSubscriptionCacheUsage2) => {\n  NDKSubscriptionCacheUsage2[\"ONLY_CACHE\"] = \"ONLY_CACHE\";\n  NDKSubscriptionCacheUsage2[\"CACHE_FIRST\"] = \"CACHE_FIRST\";\n  NDKSubscriptionCacheUsage2[\"PARALLEL\"] = \"PARALLEL\";\n  NDKSubscriptionCacheUsage2[\"ONLY_RELAY\"] = \"ONLY_RELAY\";\n  return NDKSubscriptionCacheUsage2;\n})(NDKSubscriptionCacheUsage || {});\nvar defaultOpts = {\n  closeOnEose: false,\n  cacheUsage: \"CACHE_FIRST\" /* CACHE_FIRST */,\n  dontSaveToCache: false,\n  groupable: true,\n  groupableDelay: 100,\n  groupableDelayType: \"at-most\",\n  cacheUnconstrainFilter: [\"limit\", \"since\", \"until\"]\n};\nvar NDKSubscription = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  subId;\n  filters;\n  opts;\n  pool;\n  skipVerification = false;\n  skipValidation = false;\n  /**\n   * Tracks the filters as they are executed on each relay\n   */\n  relayFilters;\n  relaySet;\n  ndk;\n  debug;\n  /**\n   * Events that have been seen by the subscription, with the time they were first seen.\n   */\n  eventFirstSeen = /* @__PURE__ */ new Map();\n  /**\n   * Relays that have sent an EOSE.\n   */\n  eosesSeen = /* @__PURE__ */ new Set();\n  /**\n   * The time the last event was received by the subscription.\n   * This is used to calculate when EOSE should be emitted.\n   */\n  lastEventReceivedAt;\n  /**\n   * The most recent event timestamp from cache results.\n   * This is used for addSinceFromCache functionality.\n   */\n  mostRecentCacheEventTimestamp;\n  internalId;\n  /**\n   * Whether the subscription should close when all relays have reached the end of the event stream.\n   */\n  closeOnEose;\n  /**\n   * Pool monitor callback\n   */\n  poolMonitor;\n  skipOptimisticPublishEvent = false;\n  /**\n   * Filters to remove when querying the cache.\n   */\n  cacheUnconstrainFilter;\n  constructor(ndk, filters, opts, subId) {\n    super();\n    this.ndk = ndk;\n    this.opts = { ...defaultOpts, ...opts || {} };\n    this.pool = this.opts.pool || ndk.pool;\n    this.filters = Array.isArray(filters) ? filters : [filters];\n    this.subId = subId || this.opts.subId;\n    this.internalId = Math.random().toString(36).substring(7);\n    this.debug = ndk.debug.extend(`subscription[${this.opts.subId ?? this.internalId}]`);\n    if (this.opts.relaySet) {\n      this.relaySet = this.opts.relaySet;\n    } else if (this.opts.relayUrls) {\n      this.relaySet = NDKRelaySet.fromRelayUrls(this.opts.relayUrls, this.ndk);\n    }\n    this.skipVerification = this.opts.skipVerification || false;\n    this.skipValidation = this.opts.skipValidation || false;\n    this.closeOnEose = this.opts.closeOnEose || false;\n    this.skipOptimisticPublishEvent = this.opts.skipOptimisticPublishEvent || false;\n    this.cacheUnconstrainFilter = this.opts.cacheUnconstrainFilter;\n  }\n  /**\n   * Returns the relays that have not yet sent an EOSE.\n   */\n  relaysMissingEose() {\n    if (!this.relayFilters) return [];\n    const relaysMissingEose = Array.from(this.relayFilters?.keys()).filter(\n      (url) => !this.eosesSeen.has(this.pool.getRelay(url, false, false))\n    );\n    return relaysMissingEose;\n  }\n  /**\n   * Provides access to the first filter of the subscription for\n   * backwards compatibility.\n   */\n  get filter() {\n    return this.filters[0];\n  }\n  get groupableDelay() {\n    if (!this.isGroupable()) return void 0;\n    return this.opts?.groupableDelay;\n  }\n  get groupableDelayType() {\n    return this.opts?.groupableDelayType || \"at-most\";\n  }\n  isGroupable() {\n    return this.opts?.groupable || false;\n  }\n  shouldQueryCache() {\n    if (this.opts.addSinceFromCache) return true;\n    if (this.opts?.cacheUsage === \"ONLY_RELAY\" /* ONLY_RELAY */) return false;\n    const hasNonEphemeralKind = this.filters.some((f) => f.kinds?.some((k) => kindIsEphemeral(k)));\n    if (hasNonEphemeralKind) return true;\n    return true;\n  }\n  shouldQueryRelays() {\n    return this.opts?.cacheUsage !== \"ONLY_CACHE\" /* ONLY_CACHE */;\n  }\n  shouldWaitForCache() {\n    if (this.opts.addSinceFromCache) return true;\n    return (\n      // Must want to close on EOSE; subscriptions\n      // that want to receive further updates must\n      // always hit the relay\n      !!this.opts.closeOnEose && // Cache adapter must claim to be fast\n      !!this.ndk.cacheAdapter?.locking && // If explicitly told to run in parallel, then\n      // we should not wait for the cache\n      this.opts.cacheUsage !== \"PARALLEL\" /* PARALLEL */\n    );\n  }\n  /**\n   * Start the subscription. This is the main method that should be called\n   * after creating a subscription.\n   *\n   * @param emitCachedEvents - Whether to emit events coming from a synchronous cache\n   *\n   * When using a synchronous cache, the events will be returned immediately\n   * by this function. If you will use those returned events, you should\n   * set emitCachedEvents to false to prevent seeing them as duplicate events.\n   */\n  start(emitCachedEvents = true) {\n    let cacheResult;\n    const updateStateFromCacheResults = (events) => {\n      if (emitCachedEvents) {\n        for (const event of events) {\n          if (!this.mostRecentCacheEventTimestamp || event.created_at > this.mostRecentCacheEventTimestamp) {\n            this.mostRecentCacheEventTimestamp = event.created_at;\n          }\n          this.eventReceived(event, void 0, true, false);\n        }\n      } else {\n        cacheResult = [];\n        for (const event of events) {\n          if (!this.mostRecentCacheEventTimestamp || event.created_at > this.mostRecentCacheEventTimestamp) {\n            this.mostRecentCacheEventTimestamp = event.created_at;\n          }\n          event.ndk = this.ndk;\n          const e = this.opts.wrap ? wrapEvent(event) : event;\n          if (!e) break;\n          if (e instanceof Promise) {\n            e.then((wrappedEvent) => {\n              this.emitEvent(false, wrappedEvent, void 0, true, false);\n            });\n            break;\n          }\n          this.eventFirstSeen.set(e.id, Date.now());\n          cacheResult.push(e);\n        }\n      }\n    };\n    const loadFromRelays = () => {\n      if (this.shouldQueryRelays()) {\n        this.startWithRelays();\n        this.startPoolMonitor();\n      } else {\n        this.emit(\"eose\", this);\n      }\n    };\n    if (this.shouldQueryCache()) {\n      cacheResult = this.startWithCache();\n      if (cacheResult instanceof Promise) {\n        if (this.shouldWaitForCache()) {\n          cacheResult.then((events) => {\n            updateStateFromCacheResults(events);\n            if (queryFullyFilled(this)) {\n              this.emit(\"eose\", this);\n              return;\n            }\n            loadFromRelays();\n          });\n          return null;\n        }\n        cacheResult.then((events) => {\n          updateStateFromCacheResults(events);\n        });\n        loadFromRelays();\n        return null;\n      }\n      updateStateFromCacheResults(cacheResult);\n      if (queryFullyFilled(this)) {\n        this.emit(\"eose\", this);\n      } else {\n        loadFromRelays();\n      }\n      return cacheResult;\n    }\n    loadFromRelays();\n    return null;\n  }\n  /**\n   * We want to monitor for new relays that are coming online, in case\n   * they should be part of this subscription.\n   */\n  startPoolMonitor() {\n    const _d = this.debug.extend(\"pool-monitor\");\n    this.poolMonitor = (relay) => {\n      if (this.relayFilters?.has(relay.url)) return;\n      const calc = calculateRelaySetsFromFilters(this.ndk, this.filters, this.pool);\n      if (calc.get(relay.url)) {\n        this.relayFilters?.set(relay.url, this.filters);\n        relay.subscribe(this, this.filters);\n      }\n    };\n    this.pool.on(\"relay:connect\", this.poolMonitor);\n  }\n  onStopped;\n  stop() {\n    this.emit(\"close\", this);\n    this.poolMonitor && this.pool.off(\"relay:connect\", this.poolMonitor);\n    this.onStopped?.();\n  }\n  /**\n   * @returns Whether the subscription has an authors filter.\n   */\n  hasAuthorsFilter() {\n    return this.filters.some((f) => f.authors?.length);\n  }\n  startWithCache() {\n    if (this.ndk.cacheAdapter?.query) {\n      return this.ndk.cacheAdapter.query(this);\n    }\n    return [];\n  }\n  /**\n   * Find available relays that should be part of this subscription and execute in them.\n   *\n   * Note that this is executed in addition to using the pool monitor, so even if the relay set\n   * that is computed (i.e. we don't have any relays available), when relays come online, we will\n   * check if we need to execute in them.\n   */\n  startWithRelays() {\n    let filters = this.filters;\n    if (this.opts.addSinceFromCache && this.mostRecentCacheEventTimestamp) {\n      const sinceTimestamp = this.mostRecentCacheEventTimestamp + 1;\n      filters = filters.map((filter) => ({\n        ...filter,\n        since: Math.max(filter.since || 0, sinceTimestamp)\n      }));\n    }\n    if (!this.relaySet || this.relaySet.relays.size === 0) {\n      this.relayFilters = calculateRelaySetsFromFilters(this.ndk, filters, this.pool);\n    } else {\n      this.relayFilters = /* @__PURE__ */ new Map();\n      for (const relay of this.relaySet.relays) {\n        this.relayFilters.set(relay.url, filters);\n      }\n    }\n    for (const [relayUrl, filters2] of this.relayFilters) {\n      const relay = this.pool.getRelay(relayUrl, true, true, filters2);\n      relay.subscribe(this, filters2);\n    }\n  }\n  // EVENT handling\n  /**\n   * Called when an event is received from a relay or the cache\n   * @param event\n   * @param relay\n   * @param fromCache Whether the event was received from the cache\n   * @param optimisticPublish Whether this event is coming from an optimistic publish\n   */\n  eventReceived(event, relay, fromCache = false, optimisticPublish = false) {\n    const eventId = event.id;\n    const eventAlreadySeen = this.eventFirstSeen.has(eventId);\n    let ndkEvent;\n    if (event instanceof NDKEvent) ndkEvent = event;\n    if (!eventAlreadySeen) {\n      ndkEvent ??= new NDKEvent(this.ndk, event);\n      ndkEvent.ndk = this.ndk;\n      ndkEvent.relay = relay;\n      if (!fromCache && !optimisticPublish) {\n        if (!this.skipValidation) {\n          if (!ndkEvent.isValid) {\n            this.debug(\"Event failed validation %s from relay %s\", eventId, relay?.url);\n            return;\n          }\n        }\n        if (relay) {\n          if (relay?.shouldValidateEvent() !== false) {\n            if (!this.skipVerification) {\n              if (!ndkEvent.verifySignature(true) && !this.ndk.asyncSigVerification) {\n                this.debug(\"Event failed signature validation\", event);\n                return;\n              }\n              if (relay) {\n                relay.addValidatedEvent();\n              }\n            }\n          } else {\n            relay.addNonValidatedEvent();\n          }\n        }\n        if (this.ndk.cacheAdapter && !this.opts.dontSaveToCache) {\n          this.ndk.cacheAdapter.setEvent(ndkEvent, this.filters, relay);\n        }\n      }\n      if (!optimisticPublish || this.skipOptimisticPublishEvent !== true) {\n        this.emitEvent(this.opts?.wrap ?? false, ndkEvent, relay, fromCache, optimisticPublish);\n        this.eventFirstSeen.set(eventId, Date.now());\n      }\n    } else {\n      const timeSinceFirstSeen = Date.now() - (this.eventFirstSeen.get(eventId) || 0);\n      this.emit(\"event:dup\", event, relay, timeSinceFirstSeen, this, fromCache, optimisticPublish);\n      if (relay) {\n        const signature = verifiedSignatures.get(eventId);\n        if (signature && typeof signature === \"string\") {\n          if (event.sig === signature) {\n            relay.addValidatedEvent();\n          }\n        }\n      }\n    }\n    this.lastEventReceivedAt = Date.now();\n  }\n  /**\n   * Optionally wraps, sync or async, and emits the event (if one comes back from the wrapper)\n   */\n  emitEvent(wrap, evt, relay, fromCache, optimisticPublish) {\n    const wrapped = wrap ? wrapEvent(evt) : evt;\n    if (wrapped instanceof Promise) {\n      wrapped.then((e) => this.emitEvent(false, e, relay, fromCache, optimisticPublish));\n    } else if (wrapped) {\n      this.emit(\"event\", wrapped, relay, this, fromCache, optimisticPublish);\n    }\n  }\n  closedReceived(relay, reason) {\n    this.emit(\"closed\", relay, reason);\n  }\n  // EOSE handling\n  eoseTimeout;\n  eosed = false;\n  eoseReceived(relay) {\n    this.debug(\"EOSE received from %s\", relay.url);\n    this.eosesSeen.add(relay);\n    let lastEventSeen = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;\n    const hasSeenAllEoses = this.eosesSeen.size === this.relayFilters?.size;\n    const queryFilled = queryFullyFilled(this);\n    const performEose = (reason) => {\n      this.debug(\"Performing EOSE: %s %d\", reason, this.eosed);\n      if (this.eosed) return;\n      if (this.eoseTimeout) clearTimeout(this.eoseTimeout);\n      this.emit(\"eose\", this);\n      this.eosed = true;\n      if (this.opts?.closeOnEose) this.stop();\n    };\n    if (queryFilled || hasSeenAllEoses) {\n      performEose(\"query filled or seen all\");\n    } else if (this.relayFilters) {\n      let timeToWaitForNextEose = 1e3;\n      const connectedRelays = new Set(this.pool.connectedRelays().map((r) => r.url));\n      const connectedRelaysWithFilters = Array.from(this.relayFilters.keys()).filter(\n        (url) => connectedRelays.has(url)\n      );\n      if (connectedRelaysWithFilters.length === 0) {\n        this.debug(\n          \"No connected relays, waiting for all relays to connect\",\n          Array.from(this.relayFilters.keys()).join(\", \")\n        );\n        return;\n      }\n      const percentageOfRelaysThatHaveSentEose = this.eosesSeen.size / connectedRelaysWithFilters.length;\n      this.debug(\"Percentage of relays that have sent EOSE\", {\n        subId: this.subId,\n        percentageOfRelaysThatHaveSentEose,\n        seen: this.eosesSeen.size,\n        total: connectedRelaysWithFilters.length\n      });\n      if (this.eosesSeen.size >= 2 && percentageOfRelaysThatHaveSentEose >= 0.5) {\n        timeToWaitForNextEose = timeToWaitForNextEose * (1 - percentageOfRelaysThatHaveSentEose);\n        if (timeToWaitForNextEose === 0) {\n          performEose(\"time to wait was 0\");\n          return;\n        }\n        if (this.eoseTimeout) clearTimeout(this.eoseTimeout);\n        const sendEoseTimeout = () => {\n          lastEventSeen = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;\n          if (lastEventSeen !== void 0 && lastEventSeen < 20) {\n            this.eoseTimeout = setTimeout(sendEoseTimeout, timeToWaitForNextEose);\n          } else {\n            performEose(`send eose timeout: ${timeToWaitForNextEose}`);\n          }\n        };\n        this.eoseTimeout = setTimeout(sendEoseTimeout, timeToWaitForNextEose);\n      }\n    }\n  }\n};\nvar kindIsEphemeral = (kind) => kind >= 2e4 && kind < 3e4;\n\n// src/user/follows.ts\nasync function follows(opts, outbox, kind = 3 /* Contacts */) {\n  if (!this.ndk) throw new Error(\"NDK not set\");\n  const contactListEvent = await this.ndk.fetchEvent(\n    { kinds: [kind], authors: [this.pubkey] },\n    opts || { groupable: false }\n  );\n  if (contactListEvent) {\n    const pubkeys = /* @__PURE__ */ new Set();\n    contactListEvent.tags.forEach((tag) => {\n      if (tag[0] === \"p\") pubkeys.add(tag[1]);\n    });\n    if (outbox) {\n      this.ndk?.outboxTracker?.trackUsers(Array.from(pubkeys));\n    }\n    return [...pubkeys].reduce((acc, pubkey) => {\n      const user = new NDKUser({ pubkey });\n      user.ndk = this.ndk;\n      acc.add(user);\n      return acc;\n    }, /* @__PURE__ */ new Set());\n  }\n  return /* @__PURE__ */ new Set();\n}\n\n// src/user/nip05.ts\nvar NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w.-]+)$/;\nasync function getNip05For(ndk, fullname, _fetch = fetch, fetchOpts = {}) {\n  return await ndk.queuesNip05.add({\n    id: fullname,\n    func: async () => {\n      if (ndk.cacheAdapter?.loadNip05) {\n        const profile = await ndk.cacheAdapter.loadNip05(fullname);\n        if (profile !== \"missing\") {\n          if (profile) {\n            const user = new NDKUser({\n              pubkey: profile.pubkey,\n              relayUrls: profile.relays,\n              nip46Urls: profile.nip46\n            });\n            user.ndk = ndk;\n            return user;\n          }\n          if (fetchOpts.cache !== \"no-cache\") {\n            return null;\n          }\n        }\n      }\n      const match = fullname.match(NIP05_REGEX);\n      if (!match) return null;\n      const [_, name = \"_\", domain] = match;\n      try {\n        const res = await _fetch(`https://${domain}/.well-known/nostr.json?name=${name}`, fetchOpts);\n        const { names, relays, nip46 } = parseNIP05Result(await res.json());\n        const pubkey = names[name.toLowerCase()];\n        let profile = null;\n        if (pubkey) {\n          profile = { pubkey, relays: relays?.[pubkey], nip46: nip46?.[pubkey] };\n        }\n        if (ndk?.cacheAdapter?.saveNip05) {\n          ndk.cacheAdapter.saveNip05(fullname, profile);\n        }\n        return profile;\n      } catch (_e) {\n        if (ndk?.cacheAdapter?.saveNip05) {\n          ndk?.cacheAdapter.saveNip05(fullname, null);\n        }\n        console.error(\"Failed to fetch NIP05 for\", fullname, _e);\n        return null;\n      }\n    }\n  });\n}\nfunction parseNIP05Result(json) {\n  const result = {\n    names: {}\n  };\n  for (const [name, pubkey] of Object.entries(json.names)) {\n    if (typeof name === \"string\" && typeof pubkey === \"string\") {\n      result.names[name.toLowerCase()] = pubkey;\n    }\n  }\n  if (json.relays) {\n    result.relays = {};\n    for (const [pubkey, relays] of Object.entries(json.relays)) {\n      if (typeof pubkey === \"string\" && Array.isArray(relays)) {\n        result.relays[pubkey] = relays.filter((relay) => typeof relay === \"string\");\n      }\n    }\n  }\n  if (json.nip46) {\n    result.nip46 = {};\n    for (const [pubkey, nip46] of Object.entries(json.nip46)) {\n      if (typeof pubkey === \"string\" && Array.isArray(nip46)) {\n        result.nip46[pubkey] = nip46.filter((relay) => typeof relay === \"string\");\n      }\n    }\n  }\n  return result;\n}\n\n// src/user/profile.ts\nfunction profileFromEvent(event) {\n  const profile = {};\n  let payload;\n  try {\n    payload = JSON.parse(event.content);\n  } catch (error) {\n    throw new Error(`Failed to parse profile event: ${error}`);\n  }\n  profile.profileEvent = JSON.stringify(event.rawEvent());\n  for (const key of Object.keys(payload)) {\n    switch (key) {\n      case \"name\":\n        profile.name = payload.name;\n        break;\n      case \"display_name\":\n        profile.displayName = payload.display_name;\n        break;\n      case \"image\":\n      case \"picture\":\n        profile.picture = payload.picture || payload.image;\n        profile.image = profile.picture;\n        break;\n      case \"banner\":\n        profile.banner = payload.banner;\n        break;\n      case \"bio\":\n        profile.bio = payload.bio;\n        break;\n      case \"nip05\":\n        profile.nip05 = payload.nip05;\n        break;\n      case \"lud06\":\n        profile.lud06 = payload.lud06;\n        break;\n      case \"lud16\":\n        profile.lud16 = payload.lud16;\n        break;\n      case \"about\":\n        profile.about = payload.about;\n        break;\n      case \"website\":\n        profile.website = payload.website;\n        break;\n      default:\n        profile[key] = payload[key];\n        break;\n    }\n  }\n  profile.created_at = event.created_at;\n  return profile;\n}\nfunction serializeProfile(profile) {\n  const payload = {};\n  for (const [key, val] of Object.entries(profile)) {\n    switch (key) {\n      case \"username\":\n      case \"name\":\n        payload.name = val;\n        break;\n      case \"displayName\":\n        payload.display_name = val;\n        break;\n      case \"image\":\n      case \"picture\":\n        payload.picture = val;\n        break;\n      case \"bio\":\n      case \"about\":\n        payload.about = val;\n        break;\n      default:\n        payload[key] = val;\n        break;\n    }\n  }\n  return JSON.stringify(payload);\n}\n\n// src/user/index.ts\nvar NDKUser = class _NDKUser {\n  ndk;\n  profile;\n  profileEvent;\n  _npub;\n  _pubkey;\n  relayUrls = [];\n  nip46Urls = [];\n  constructor(opts) {\n    if (opts.npub) this._npub = opts.npub;\n    if (opts.hexpubkey) this._pubkey = opts.hexpubkey;\n    if (opts.pubkey) this._pubkey = opts.pubkey;\n    if (opts.relayUrls) this.relayUrls = opts.relayUrls;\n    if (opts.nip46Urls) this.nip46Urls = opts.nip46Urls;\n    if (opts.nprofile) {\n      try {\n        const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(opts.nprofile);\n        if (decoded.type === \"nprofile\") {\n          this._pubkey = decoded.data.pubkey;\n          if (decoded.data.relays && decoded.data.relays.length > 0) {\n            this.relayUrls.push(...decoded.data.relays);\n          }\n        }\n      } catch (e) {\n        console.error(\"Failed to decode nprofile\", e);\n      }\n    }\n  }\n  get npub() {\n    if (!this._npub) {\n      if (!this._pubkey) throw new Error(\"pubkey not set\");\n      this._npub = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.npubEncode(this.pubkey);\n    }\n    return this._npub;\n  }\n  get nprofile() {\n    const relays = this.profileEvent?.onRelays?.map((r) => r.url);\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.nprofileEncode({\n      pubkey: this.pubkey,\n      relays\n    });\n  }\n  set npub(npub2) {\n    this._npub = npub2;\n  }\n  /**\n   * Get the user's pubkey\n   * @returns {string} The user's pubkey\n   */\n  get pubkey() {\n    if (!this._pubkey) {\n      if (!this._npub) throw new Error(\"npub not set\");\n      this._pubkey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(this.npub).data;\n    }\n    return this._pubkey;\n  }\n  /**\n   * Set the user's pubkey\n   * @param pubkey {string} The user's pubkey\n   */\n  set pubkey(pubkey) {\n    this._pubkey = pubkey;\n  }\n  /**\n   * Equivalent to NDKEvent.filters().\n   * @returns {NDKFilter}\n   */\n  filter() {\n    return { \"#p\": [this.pubkey] };\n  }\n  /**\n   * Gets NIP-57 and NIP-61 information that this user has signaled\n   *\n   * @param getAll {boolean} Whether to get all zap info or just the first one\n   */\n  async getZapInfo(timeoutMs) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const promiseWithTimeout = async (promise) => {\n      if (!timeoutMs) return promise;\n      let timeoutId;\n      const timeoutPromise = new Promise((_, reject) => {\n        timeoutId = setTimeout(() => reject(new Error(\"Timeout\")), timeoutMs);\n      });\n      try {\n        const result = await Promise.race([promise, timeoutPromise]);\n        if (timeoutId) clearTimeout(timeoutId);\n        return result;\n      } catch (e) {\n        if (e instanceof Error && e.message === \"Timeout\") {\n          try {\n            const result = await promise;\n            return result;\n          } catch (_originalError) {\n            return void 0;\n          }\n        }\n        return void 0;\n      }\n    };\n    const [userProfile, mintListEvent] = await Promise.all([\n      promiseWithTimeout(this.fetchProfile()),\n      promiseWithTimeout(this.ndk.fetchEvent({ kinds: [10019 /* CashuMintList */], authors: [this.pubkey] }))\n    ]);\n    const res = /* @__PURE__ */ new Map();\n    if (mintListEvent) {\n      const mintList = NDKCashuMintList.from(mintListEvent);\n      if (mintList.mints.length > 0) {\n        res.set(\"nip61\", {\n          mints: mintList.mints,\n          relays: mintList.relays,\n          p2pk: mintList.p2pk\n        });\n      }\n    }\n    if (userProfile) {\n      const { lud06, lud16 } = userProfile;\n      res.set(\"nip57\", { lud06, lud16 });\n    }\n    return res;\n  }\n  /**\n   * Instantiate an NDKUser from a NIP-05 string\n   * @param nip05Id {string} The user's NIP-05\n   * @param ndk {NDK} An NDK instance\n   * @param skipCache {boolean} Whether to skip the cache or not\n   * @returns {NDKUser | undefined} An NDKUser if one is found for the given NIP-05, undefined otherwise.\n   */\n  static async fromNip05(nip05Id, ndk, skipCache = false) {\n    if (!ndk) throw new Error(\"No NDK instance found\");\n    const opts = {};\n    if (skipCache) opts.cache = \"no-cache\";\n    const profile = await getNip05For(ndk, nip05Id, ndk?.httpFetch, opts);\n    if (profile) {\n      const user = new _NDKUser({\n        pubkey: profile.pubkey,\n        relayUrls: profile.relays,\n        nip46Urls: profile.nip46\n      });\n      user.ndk = ndk;\n      return user;\n    }\n  }\n  /**\n   * Fetch a user's profile\n   * @param opts {NDKSubscriptionOptions} A set of NDKSubscriptionOptions\n   * @param storeProfileEvent {boolean} Whether to store the profile event or not\n   * @returns User Profile\n   */\n  async fetchProfile(opts, storeProfileEvent = false) {\n    if (!this.ndk) throw new Error(\"NDK not set\");\n    let setMetadataEvent = null;\n    if (this.ndk.cacheAdapter && (this.ndk.cacheAdapter.fetchProfile || this.ndk.cacheAdapter.fetchProfileSync) && opts?.cacheUsage !== \"ONLY_RELAY\" /* ONLY_RELAY */) {\n      let profile = null;\n      if (this.ndk.cacheAdapter.fetchProfileSync) {\n        profile = this.ndk.cacheAdapter.fetchProfileSync(this.pubkey);\n      } else if (this.ndk.cacheAdapter.fetchProfile) {\n        profile = await this.ndk.cacheAdapter.fetchProfile(this.pubkey);\n      }\n      if (profile) {\n        this.profile = profile;\n        return profile;\n      }\n    }\n    opts ??= {};\n    opts.cacheUsage ??= \"ONLY_RELAY\" /* ONLY_RELAY */;\n    opts.closeOnEose ??= true;\n    opts.groupable ??= true;\n    opts.groupableDelay ??= 250;\n    if (!setMetadataEvent) {\n      setMetadataEvent = await this.ndk.fetchEvent({ kinds: [0], authors: [this.pubkey] }, opts);\n    }\n    if (!setMetadataEvent) return null;\n    this.profile = profileFromEvent(setMetadataEvent);\n    if (storeProfileEvent && this.profile && this.ndk.cacheAdapter && this.ndk.cacheAdapter.saveProfile) {\n      this.ndk.cacheAdapter.saveProfile(this.pubkey, this.profile);\n    }\n    return this.profile;\n  }\n  /**\n   * Returns a set of users that this user follows.\n   *\n   * @deprecated Use followSet instead\n   */\n  follows = follows.bind(this);\n  /**\n   * Returns a set of pubkeys that this user follows.\n   *\n   * @param opts - NDKSubscriptionOptions\n   * @param outbox - boolean\n   * @param kind - number\n   */\n  async followSet(opts, outbox, kind = 3 /* Contacts */) {\n    const follows2 = await this.follows(opts, outbox, kind);\n    return new Set(Array.from(follows2).map((f) => f.pubkey));\n  }\n  /** @deprecated Use referenceTags instead. */\n  /**\n   * Get the tag that can be used to reference this user in an event\n   * @returns {NDKTag} an NDKTag\n   */\n  tagReference() {\n    return [\"p\", this.pubkey];\n  }\n  /**\n   * Get the tags that can be used to reference this user in an event\n   * @returns {NDKTag[]} an array of NDKTag\n   */\n  referenceTags(marker) {\n    const tag = [[\"p\", this.pubkey]];\n    if (!marker) return tag;\n    tag[0].push(\"\", marker);\n    return tag;\n  }\n  /**\n   * Publishes the current profile.\n   */\n  async publish() {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    if (!this.profile) throw new Error(\"No profile available\");\n    this.ndk.assertSigner();\n    const event = new NDKEvent(this.ndk, {\n      kind: 0,\n      content: serializeProfile(this.profile)\n    });\n    await event.publish();\n  }\n  /**\n   * Add a follow to this user's contact list\n   *\n   * @param newFollow {NDKUser} The user to follow\n   * @param currentFollowList {Set<NDKUser>} The current follow list\n   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)\n   * @returns {Promise<boolean>} True if the follow was added, false if the follow already exists\n   */\n  async follow(newFollow, currentFollowList, kind = 3 /* Contacts */) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    if (!currentFollowList) {\n      currentFollowList = await this.follows(void 0, void 0, kind);\n    }\n    if (currentFollowList.has(newFollow)) {\n      return false;\n    }\n    currentFollowList.add(newFollow);\n    const event = new NDKEvent(this.ndk, { kind });\n    for (const follow of currentFollowList) {\n      event.tag(follow);\n    }\n    await event.publish();\n    return true;\n  }\n  /**\n   * Remove a follow from this user's contact list\n   *\n   * @param user {NDKUser} The user to unfollow\n   * @param currentFollowList {Set<NDKUser>} The current follow list\n   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)\n   * @returns The relays were the follow list was published or false if the user wasn't found\n   */\n  async unfollow(user, currentFollowList, kind = 3 /* Contacts */) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    if (!currentFollowList) {\n      currentFollowList = await this.follows(void 0, void 0, kind);\n    }\n    const newUserFollowList = /* @__PURE__ */ new Set();\n    let foundUser = false;\n    for (const follow of currentFollowList) {\n      if (follow.pubkey !== user.pubkey) {\n        newUserFollowList.add(follow);\n      } else {\n        foundUser = true;\n      }\n    }\n    if (!foundUser) return false;\n    const event = new NDKEvent(this.ndk, { kind });\n    for (const follow of newUserFollowList) {\n      event.tag(follow);\n    }\n    return await event.publish();\n  }\n  /**\n   * Validate a user's NIP-05 identifier (usually fetched from their kind:0 profile data)\n   *\n   * @param nip05Id The NIP-05 string to validate\n   * @returns {Promise<boolean | null>} True if the NIP-05 is found and matches this user's pubkey,\n   * False if the NIP-05 is found but doesn't match this user's pubkey,\n   * null if the NIP-05 isn't found on the domain or we're unable to verify (because of network issues, etc.)\n   */\n  async validateNip05(nip05Id) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const profilePointer = await getNip05For(this.ndk, nip05Id);\n    if (profilePointer === null) return null;\n    return profilePointer.pubkey === this.pubkey;\n  }\n};\n\n// src/user/pin.ts\nasync function pinEvent(user, event, pinEvent2, publish) {\n  const kind = 10001 /* PinList */;\n  if (!user.ndk) throw new Error(\"No NDK instance found\");\n  user.ndk.assertSigner();\n  if (!pinEvent2) {\n    const events = await user.ndk.fetchEvents(\n      { kinds: [kind], authors: [user.pubkey] },\n      { cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */ }\n    );\n    if (events.size > 0) {\n      pinEvent2 = lists_default.from(Array.from(events)[0]);\n    } else {\n      pinEvent2 = new NDKEvent(user.ndk, {\n        kind\n      });\n    }\n  }\n  pinEvent2.tag(event);\n  if (publish) {\n    await pinEvent2.publish();\n  }\n  return pinEvent2;\n}\n\n// src/events/kinds/classified.ts\nvar NDKClassified = class _NDKClassified extends NDKEvent {\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30402 /* Classified */;\n  }\n  /**\n   * Creates a NDKClassified from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKClassified from.\n   * @returns NDKClassified\n   */\n  static from(event) {\n    return new _NDKClassified(event.ndk, event);\n  }\n  /**\n   * Getter for the classified title.\n   *\n   * @returns {string | undefined} - The classified title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the classified title.\n   *\n   * @param {string | undefined} title - The title to set for the classified.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the classified summary.\n   *\n   * @returns {string | undefined} - The classified summary if available, otherwise undefined.\n   */\n  get summary() {\n    return this.tagValue(\"summary\");\n  }\n  /**\n   * Setter for the classified summary.\n   *\n   * @param {string | undefined} summary - The summary to set for the classified.\n   */\n  set summary(summary) {\n    this.removeTag(\"summary\");\n    if (summary) this.tags.push([\"summary\", summary]);\n  }\n  /**\n   * Getter for the classified's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the classified was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      return Number.parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the classified's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the classified's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Getter for the classified location.\n   *\n   * @returns {string | undefined} - The classified location if available, otherwise undefined.\n   */\n  get location() {\n    return this.tagValue(\"location\");\n  }\n  /**\n   * Setter for the classified location.\n   *\n   * @param {string | undefined} location - The location to set for the classified.\n   */\n  set location(location) {\n    this.removeTag(\"location\");\n    if (location) this.tags.push([\"location\", location]);\n  }\n  /**\n   * Getter for the classified price.\n   *\n   * @returns {NDKClassifiedPriceTag | undefined} - The classified price if available, otherwise undefined.\n   */\n  get price() {\n    const priceTag = this.tags.find((tag) => tag[0] === \"price\");\n    if (priceTag) {\n      return {\n        amount: Number.parseFloat(priceTag[1]),\n        currency: priceTag[2],\n        frequency: priceTag[3]\n      };\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the classified price.\n   *\n   * @param price - The price to set for the classified.\n   */\n  set price(priceTag) {\n    if (typeof priceTag === \"string\") {\n      priceTag = {\n        amount: Number.parseFloat(priceTag)\n      };\n    }\n    if (priceTag?.amount) {\n      const tag = [\"price\", priceTag.amount.toString()];\n      if (priceTag.currency) tag.push(priceTag.currency);\n      if (priceTag.frequency) tag.push(priceTag.frequency);\n      this.tags.push(tag);\n    } else {\n      this.removeTag(\"price\");\n    }\n  }\n  /**\n   * Generates content tags for the classified.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n};\n\n// src/events/kinds/drafts.ts\nvar NDKDraft = class _NDKDraft extends NDKEvent {\n  _event;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 31234 /* Draft */;\n  }\n  static from(event) {\n    return new _NDKDraft(event.ndk, event);\n  }\n  /**\n   * Sets an identifier (i.e. d-tag)\n   */\n  set identifier(id) {\n    this.removeTag(\"d\");\n    this.tags.push([\"d\", id]);\n  }\n  get identifier() {\n    return this.dTag;\n  }\n  /**\n   * Event that is to be saved.\n   */\n  set event(e) {\n    if (e instanceof NDKEvent) this._event = e.rawEvent();\n    else this._event = e;\n    this.prepareEvent();\n  }\n  /**\n   * Gets the event.\n   * @param param0\n   * @returns NDKEvent of the draft event or null if the draft event has been deleted (emptied).\n   */\n  async getEvent(signer) {\n    if (this._event) return new NDKEvent(this.ndk, this._event);\n    signer ??= this.ndk?.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    if (this.content && this.content.length > 0) {\n      try {\n        await this.decrypt(user, signer);\n        const payload = JSON.parse(this.content);\n        this._event = payload;\n        return new NDKEvent(this.ndk, payload);\n      } catch (e) {\n        console.error(e);\n        return void 0;\n      }\n    } else {\n      return null;\n    }\n  }\n  prepareEvent() {\n    if (!this._event) throw new Error(\"No event has been provided\");\n    this.removeTag(\"k\");\n    if (this._event.kind) this.tags.push([\"k\", this._event.kind.toString()]);\n    this.content = JSON.stringify(this._event);\n  }\n  /**\n   * Generates draft event.\n   *\n   * @param signer: Optional signer to encrypt with\n   * @param publish: Whether to publish, optionally specifying relaySet to publish to\n   */\n  async save({ signer, publish, relaySet }) {\n    signer ??= this.ndk?.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    await this.encrypt(user, signer);\n    if (publish === false) return;\n    return this.publish(relaySet);\n  }\n};\n\n// src/events/kinds/dvm/feedback.ts\nvar NDKDvmJobFeedbackStatus = /* @__PURE__ */ ((NDKDvmJobFeedbackStatus2) => {\n  NDKDvmJobFeedbackStatus2[\"Processing\"] = \"processing\";\n  NDKDvmJobFeedbackStatus2[\"Success\"] = \"success\";\n  NDKDvmJobFeedbackStatus2[\"Scheduled\"] = \"scheduled\";\n  NDKDvmJobFeedbackStatus2[\"PayReq\"] = \"payment_required\";\n  return NDKDvmJobFeedbackStatus2;\n})(NDKDvmJobFeedbackStatus || {});\nvar NDKDVMJobFeedback = class _NDKDVMJobFeedback extends NDKEvent {\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7e3 /* DVMJobFeedback */;\n  }\n  static async from(event) {\n    const e = new _NDKDVMJobFeedback(event.ndk, event.rawEvent());\n    if (e.encrypted) await e.dvmDecrypt();\n    return e;\n  }\n  get status() {\n    return this.tagValue(\"status\");\n  }\n  set status(status) {\n    this.removeTag(\"status\");\n    if (status !== void 0) {\n      this.tags.push([\"status\", status]);\n    }\n  }\n  get encrypted() {\n    return !!this.getMatchingTags(\"encrypted\")[0];\n  }\n  async dvmDecrypt() {\n    await this.decrypt();\n    const decryptedContent = JSON.parse(this.content);\n    this.tags.push(...decryptedContent);\n  }\n};\n\n// src/events/kinds/dvm/request.ts\nvar NDKDVMRequest = class _NDKDVMRequest extends NDKEvent {\n  static from(event) {\n    return new _NDKDVMRequest(event.ndk, event.rawEvent());\n  }\n  set bid(msatAmount) {\n    if (msatAmount === void 0) {\n      this.removeTag(\"bid\");\n    } else {\n      this.tags.push([\"bid\", msatAmount.toString()]);\n    }\n  }\n  get bid() {\n    const v = this.tagValue(\"bid\");\n    if (v === void 0) return void 0;\n    return Number.parseInt(v);\n  }\n  /**\n   * Adds a new input to the job\n   * @param args The arguments to the input\n   */\n  addInput(...args) {\n    this.tags.push([\"i\", ...args]);\n  }\n  /**\n   * Adds a new parameter to the job\n   */\n  addParam(...args) {\n    this.tags.push([\"param\", ...args]);\n  }\n  set output(output) {\n    if (output === void 0) {\n      this.removeTag(\"output\");\n    } else {\n      if (typeof output === \"string\") output = [output];\n      this.tags.push([\"output\", ...output]);\n    }\n  }\n  get output() {\n    const outputTag = this.getMatchingTags(\"output\")[0];\n    return outputTag ? outputTag.slice(1) : void 0;\n  }\n  get params() {\n    const paramTags = this.getMatchingTags(\"param\");\n    return paramTags.map((t) => t.slice(1));\n  }\n  getParam(name) {\n    const paramTag = this.getMatchingTags(\"param\").find((t) => t[1] === name);\n    return paramTag ? paramTag[2] : void 0;\n  }\n  createFeedback(status) {\n    const feedback = new NDKDVMJobFeedback(this.ndk);\n    feedback.tag(this, \"job\");\n    feedback.status = status;\n    return feedback;\n  }\n  /**\n   * Enables job encryption for this event\n   * @param dvm DVM that will receive the event\n   * @param signer Signer to use for encryption\n   */\n  async encryption(dvm, signer) {\n    const dvmTags = [\"i\", \"param\", \"output\", \"relays\", \"bid\"];\n    const tags = this.tags.filter((t) => dvmTags.includes(t[0]));\n    this.tags = this.tags.filter((t) => !dvmTags.includes(t[0]));\n    this.content = JSON.stringify(tags);\n    this.tag(dvm);\n    this.tags.push([\"encrypted\"]);\n    await this.encrypt(dvm, signer);\n  }\n  /**\n   * Sets the DVM that will receive the event\n   */\n  set dvm(dvm) {\n    this.removeTag(\"p\");\n    if (dvm) this.tag(dvm);\n  }\n};\n\n// src/events/kinds/dvm/NDKTranscriptionDVM.ts\nvar NDKTranscriptionDVM = class _NDKTranscriptionDVM extends NDKDVMRequest {\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind = 5e3 /* DVMReqTextExtraction */;\n  }\n  static from(event) {\n    return new _NDKTranscriptionDVM(event.ndk, event.rawEvent());\n  }\n  /**\n   * Returns the original source of the transcription\n   */\n  get url() {\n    const inputTags = this.getMatchingTags(\"i\");\n    if (inputTags.length !== 1) {\n      return void 0;\n    }\n    return inputTags[0][1];\n  }\n  /**\n   * Getter for the title tag\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the title tag\n   */\n  set title(value) {\n    this.removeTag(\"title\");\n    if (value) {\n      this.tags.push([\"title\", value]);\n    }\n  }\n  /**\n   * Getter for the image tag\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Setter for the image tag\n   */\n  set image(value) {\n    this.removeTag(\"image\");\n    if (value) {\n      this.tags.push([\"image\", value]);\n    }\n  }\n};\n\n// src/events/kinds/dvm/result.ts\nvar NDKDVMJobResult = class _NDKDVMJobResult extends NDKEvent {\n  static from(event) {\n    return new _NDKDVMJobResult(event.ndk, event.rawEvent());\n  }\n  setAmount(msat, invoice) {\n    this.removeTag(\"amount\");\n    const tag = [\"amount\", msat.toString()];\n    if (invoice) tag.push(invoice);\n    this.tags.push(tag);\n  }\n  set result(result) {\n    if (result === void 0) {\n      this.content = \"\";\n    } else {\n      this.content = result;\n    }\n  }\n  get result() {\n    if (this.content === \"\") {\n      return void 0;\n    }\n    return this.content;\n  }\n  set status(status) {\n    this.removeTag(\"status\");\n    if (status !== void 0) {\n      this.tags.push([\"status\", status]);\n    }\n  }\n  get status() {\n    return this.tagValue(\"status\");\n  }\n  get jobRequestId() {\n    for (const eTag of this.getMatchingTags(\"e\")) {\n      if (eTag[2] === \"job\") return eTag[1];\n    }\n    if (this.jobRequest) return this.jobRequest.id;\n    return this.tagValue(\"e\");\n  }\n  set jobRequest(event) {\n    this.removeTag(\"request\");\n    if (event) {\n      this.kind = event.kind + 1e3;\n      this.tags.push([\"request\", JSON.stringify(event.rawEvent())]);\n      this.tag(event);\n    }\n  }\n  get jobRequest() {\n    const tag = this.tagValue(\"request\");\n    if (tag === void 0) {\n      return void 0;\n    }\n    return new NDKEvent(this.ndk, JSON.parse(tag));\n  }\n};\n\n// src/events/kinds/cashu/tx.ts\nvar MARKERS = {\n  REDEEMED: \"redeemed\",\n  CREATED: \"created\",\n  DESTROYED: \"destroyed\",\n  RESERVED: \"reserved\"\n};\nvar NDKCashuWalletTx = class _NDKCashuWalletTx extends NDKEvent {\n  static MARKERS = MARKERS;\n  static kind = 7376 /* CashuWalletTx */;\n  static kinds = [7376 /* CashuWalletTx */];\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7376 /* CashuWalletTx */;\n  }\n  static async from(event) {\n    const walletChange = new _NDKCashuWalletTx(event.ndk, event);\n    const prevContent = walletChange.content;\n    try {\n      await walletChange.decrypt();\n    } catch (_e) {\n      walletChange.content ??= prevContent;\n    }\n    try {\n      const contentTags = JSON.parse(walletChange.content);\n      walletChange.tags = [...contentTags, ...walletChange.tags];\n    } catch (_e) {\n      return;\n    }\n    return walletChange;\n  }\n  set direction(direction) {\n    this.removeTag(\"direction\");\n    if (direction) this.tags.push([\"direction\", direction]);\n  }\n  get direction() {\n    return this.tagValue(\"direction\");\n  }\n  set amount(amount) {\n    this.removeTag(\"amount\");\n    this.tags.push([\"amount\", amount.toString()]);\n  }\n  get amount() {\n    const val = this.tagValue(\"amount\");\n    if (val === void 0) return void 0;\n    return Number(val);\n  }\n  set fee(fee) {\n    this.removeTag(\"fee\");\n    this.tags.push([\"fee\", fee.toString()]);\n  }\n  get fee() {\n    const val = this.tagValue(\"fee\");\n    if (val === void 0) return void 0;\n    return Number(val);\n  }\n  set unit(unit) {\n    this.removeTag(\"unit\");\n    if (unit) this.tags.push([\"unit\", unit.toString()]);\n  }\n  get unit() {\n    return this.tagValue(\"unit\");\n  }\n  set description(description) {\n    this.removeTag(\"description\");\n    if (description) this.tags.push([\"description\", description.toString()]);\n  }\n  get description() {\n    return this.tagValue(\"description\");\n  }\n  set mint(mint) {\n    this.removeTag(\"mint\");\n    if (mint) this.tags.push([\"mint\", mint.toString()]);\n  }\n  get mint() {\n    return this.tagValue(\"mint\");\n  }\n  /**\n   * Tags tokens that were created in this history event\n   */\n  set destroyedTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.DESTROYED));\n    }\n  }\n  set destroyedTokenIds(ids) {\n    for (const id of ids) {\n      this.tags.push([\"e\", id, \"\", MARKERS.DESTROYED]);\n    }\n  }\n  /**\n   * Tags tokens that were created in this history event\n   */\n  set createdTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.CREATED));\n    }\n  }\n  set reservedTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.RESERVED));\n    }\n  }\n  addRedeemedNutzap(event) {\n    this.tag(event, MARKERS.REDEEMED);\n  }\n  async toNostrEvent(pubkey) {\n    const encryptedTags = [];\n    const unencryptedTags = [];\n    for (const tag of this.tags) {\n      if (!this.shouldEncryptTag(tag)) {\n        unencryptedTags.push(tag);\n      } else {\n        encryptedTags.push(tag);\n      }\n    }\n    this.tags = unencryptedTags.filter((t) => t[0] !== \"client\");\n    this.content = JSON.stringify(encryptedTags);\n    const user = await this.ndk?.signer?.user();\n    await this.encrypt(user, void 0, \"nip44\");\n    return super.toNostrEvent(pubkey);\n  }\n  /**\n   * Whether this entry includes a redemption of a Nutzap\n   */\n  get hasNutzapRedemption() {\n    return this.getMatchingTags(\"e\", MARKERS.REDEEMED).length > 0;\n  }\n  shouldEncryptTag(tag) {\n    const unencryptedTagNames = [\"client\"];\n    if (unencryptedTagNames.includes(tag[0])) {\n      return false;\n    }\n    if (tag[0] === \"e\" && tag[3] === MARKERS.REDEEMED) {\n      return false;\n    }\n    if (tag[0] === \"p\") return false;\n    return true;\n  }\n};\n\n// src/events/kinds/NDKRelayList.ts\nvar READ_MARKER = \"read\";\nvar WRITE_MARKER = \"write\";\nvar NDKRelayList = class _NDKRelayList extends NDKEvent {\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 10002 /* RelayList */;\n  }\n  static from(ndkEvent) {\n    return new _NDKRelayList(ndkEvent.ndk, ndkEvent.rawEvent());\n  }\n  get readRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2] || tag[2] && tag[2] === READ_MARKER).map((tag) => tryNormalizeRelayUrl(tag[1])).filter((url) => !!url);\n  }\n  set readRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay, READ_MARKER]);\n    }\n  }\n  get writeRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2] || tag[2] && tag[2] === WRITE_MARKER).map((tag) => tryNormalizeRelayUrl(tag[1])).filter((url) => !!url);\n  }\n  set writeRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay, WRITE_MARKER]);\n    }\n  }\n  get bothRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2]).map((tag) => tag[1]);\n  }\n  set bothRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay]);\n    }\n  }\n  get relays() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").map((tag) => tag[1]);\n  }\n  /**\n   * Provides a relaySet for the relays in this list.\n   */\n  get relaySet() {\n    if (!this.ndk) throw new Error(\"NDKRelayList has no NDK instance\");\n    return new NDKRelaySet(\n      new Set(this.relays.map((u) => this.ndk?.pool.getRelay(u)).filter((r) => !!r)),\n      this.ndk\n    );\n  }\n};\nfunction relayListFromKind3(ndk, contactList) {\n  try {\n    const content = JSON.parse(contactList.content);\n    const relayList = new NDKRelayList(ndk);\n    const readRelays = /* @__PURE__ */ new Set();\n    const writeRelays = /* @__PURE__ */ new Set();\n    for (let [key, config] of Object.entries(content)) {\n      try {\n        key = normalizeRelayUrl(key);\n      } catch {\n        continue;\n      }\n      if (!config) {\n        readRelays.add(key);\n        writeRelays.add(key);\n      } else {\n        const relayConfig = config;\n        if (relayConfig.write) writeRelays.add(key);\n        if (relayConfig.read) readRelays.add(key);\n      }\n    }\n    relayList.readRelayUrls = Array.from(readRelays);\n    relayList.writeRelayUrls = Array.from(writeRelays);\n    return relayList;\n  } catch {\n  }\n  return void 0;\n}\n\n// src/events/kinds/nip89/app-handler.ts\nvar NDKAppHandlerEvent = class _NDKAppHandlerEvent extends NDKEvent {\n  profile;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 31990 /* AppHandler */;\n  }\n  static from(ndkEvent) {\n    const event = new _NDKAppHandlerEvent(ndkEvent.ndk, ndkEvent.rawEvent());\n    if (event.isValid) {\n      return event;\n    }\n    return null;\n  }\n  get isValid() {\n    const combinations = /* @__PURE__ */ new Map();\n    const combinationFromTag = (tag) => [tag[0], tag[2]].join(\":\").toLowerCase();\n    const tagsToInspect = [\"web\", \"android\", \"ios\"];\n    for (const tag of this.tags) {\n      if (tagsToInspect.includes(tag[0])) {\n        const combination = combinationFromTag(tag);\n        if (combinations.has(combination)) {\n          if (combinations.get(combination) !== tag[1].toLowerCase()) {\n            return false;\n          }\n        }\n        combinations.set(combination, tag[1].toLowerCase());\n      }\n    }\n    return true;\n  }\n  /**\n   * Fetches app handler information\n   * If no app information is available on the kind:31990,\n   * we fetch the event's author's profile and return that instead.\n   */\n  async fetchProfile() {\n    if (this.profile === void 0 && this.content.length > 0) {\n      try {\n        const profile = JSON.parse(this.content);\n        if (profile?.name) {\n          return profile;\n        }\n        this.profile = null;\n      } catch (_e) {\n        this.profile = null;\n      }\n    }\n    return new Promise((resolve, reject) => {\n      const author = this.author;\n      author.fetchProfile().then(() => {\n        resolve(author.profile);\n      }).catch(reject);\n    });\n  }\n};\n\n// src/events/kinds/repost.ts\nvar NDKRepost = class _NDKRepost extends NDKEvent {\n  _repostedEvents;\n  static from(event) {\n    return new _NDKRepost(event.ndk, event.rawEvent());\n  }\n  /**\n   * Returns all reposted events by the current event.\n   *\n   * @param klass Optional class to convert the events to.\n   * @returns\n   */\n  async repostedEvents(klass, opts) {\n    const items = [];\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (this._repostedEvents !== void 0) return this._repostedEvents;\n    for (const eventId of this.repostedEventIds()) {\n      const filter = filterForId(eventId);\n      const event = await this.ndk.fetchEvent(filter, opts);\n      if (event) {\n        items.push(klass ? klass.from(event) : event);\n      }\n    }\n    return items;\n  }\n  /**\n   * Returns the reposted event IDs.\n   */\n  repostedEventIds() {\n    return this.tags.filter((t) => t[0] === \"e\" || t[0] === \"a\").map((t) => t[1]);\n  }\n};\nfunction filterForId(id) {\n  if (id.match(/:/)) {\n    const [kind, pubkey, identifier] = id.split(\":\");\n    return {\n      kinds: [Number.parseInt(kind)],\n      authors: [pubkey],\n      \"#d\": [identifier]\n    };\n  }\n  return { ids: [id] };\n}\n\n// src/events/kinds/subscriptions/receipt.ts\n\nvar NDKSubscriptionReceipt = class _NDKSubscriptionReceipt extends NDKEvent {\n  debug;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 7003 /* SubscriptionReceipt */;\n    this.debug = ndk?.debug.extend(\"subscription-start\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:subscription-start\");\n  }\n  static from(event) {\n    return new _NDKSubscriptionReceipt(event.ndk, event.rawEvent());\n  }\n  /**\n   * This is the person being subscribed to\n   */\n  get recipient() {\n    const pTag = this.getMatchingTags(\"p\")?.[0];\n    if (!pTag) return void 0;\n    const user = new NDKUser({ pubkey: pTag[1] });\n    return user;\n  }\n  set recipient(user) {\n    this.removeTag(\"p\");\n    if (!user) return;\n    this.tags.push([\"p\", user.pubkey]);\n  }\n  /**\n   * This is the person subscribing\n   */\n  get subscriber() {\n    const PTag = this.getMatchingTags(\"P\")?.[0];\n    if (!PTag) return void 0;\n    const user = new NDKUser({ pubkey: PTag[1] });\n    return user;\n  }\n  set subscriber(user) {\n    this.removeTag(\"P\");\n    if (!user) return;\n    this.tags.push([\"P\", user.pubkey]);\n  }\n  set subscriptionStart(event) {\n    this.debug(`before setting subscription start: ${this.rawEvent}`);\n    this.removeTag(\"e\");\n    this.tag(event, \"subscription\", true);\n    this.debug(`after setting subscription start: ${this.rawEvent}`);\n  }\n  get tierName() {\n    const tag = this.getMatchingTags(\"tier\")?.[0];\n    return tag?.[1];\n  }\n  get isValid() {\n    const period = this.validPeriod;\n    if (!period) {\n      return false;\n    }\n    if (period.start > period.end) {\n      return false;\n    }\n    const pTags = this.getMatchingTags(\"p\");\n    const PTags = this.getMatchingTags(\"P\");\n    if (pTags.length !== 1 || PTags.length !== 1) {\n      return false;\n    }\n    return true;\n  }\n  get validPeriod() {\n    const tag = this.getMatchingTags(\"valid\")?.[0];\n    if (!tag) return void 0;\n    try {\n      return {\n        start: new Date(Number.parseInt(tag[1]) * 1e3),\n        end: new Date(Number.parseInt(tag[2]) * 1e3)\n      };\n    } catch {\n      return void 0;\n    }\n  }\n  set validPeriod(period) {\n    this.removeTag(\"valid\");\n    if (!period) return;\n    this.tags.push([\n      \"valid\",\n      Math.floor(period.start.getTime() / 1e3).toString(),\n      Math.floor(period.end.getTime() / 1e3).toString()\n    ]);\n  }\n  get startPeriod() {\n    return this.validPeriod?.start;\n  }\n  get endPeriod() {\n    return this.validPeriod?.end;\n  }\n  /**\n   * Whether the subscription is currently active\n   */\n  isActive(time) {\n    time ??= /* @__PURE__ */ new Date();\n    const period = this.validPeriod;\n    if (!period) return false;\n    if (time < period.start) return false;\n    if (time > period.end) return false;\n    return true;\n  }\n};\n\n// src/events/kinds/subscriptions/subscription-start.ts\n\nvar NDKSubscriptionStart = class _NDKSubscriptionStart extends NDKEvent {\n  debug;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 7001 /* Subscribe */;\n    this.debug = ndk?.debug.extend(\"subscription-start\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:subscription-start\");\n  }\n  static from(event) {\n    return new _NDKSubscriptionStart(event.ndk, event.rawEvent());\n  }\n  /**\n   * Recipient of the subscription. I.e. The author of this event subscribes to this user.\n   */\n  get recipient() {\n    const pTag = this.getMatchingTags(\"p\")?.[0];\n    if (!pTag) return void 0;\n    const user = new NDKUser({ pubkey: pTag[1] });\n    return user;\n  }\n  set recipient(user) {\n    this.removeTag(\"p\");\n    if (!user) return;\n    this.tags.push([\"p\", user.pubkey]);\n  }\n  /**\n   * The amount of the subscription.\n   */\n  get amount() {\n    const amountTag = this.getMatchingTags(\"amount\")?.[0];\n    if (!amountTag) return void 0;\n    return parseTagToSubscriptionAmount(amountTag);\n  }\n  set amount(amount) {\n    this.removeTag(\"amount\");\n    if (!amount) return;\n    this.tags.push(newAmount(amount.amount, amount.currency, amount.term));\n  }\n  /**\n   * The event id or NIP-33 tag id of the tier that the user is subscribing to.\n   */\n  get tierId() {\n    const eTag = this.getMatchingTags(\"e\")?.[0];\n    const aTag = this.getMatchingTags(\"a\")?.[0];\n    if (!eTag || !aTag) return void 0;\n    return eTag[1] ?? aTag[1];\n  }\n  set tier(tier) {\n    this.removeTag(\"e\");\n    this.removeTag(\"a\");\n    this.removeTag(\"event\");\n    if (!tier) return;\n    this.tag(tier);\n    this.removeTag(\"p\");\n    this.tags.push([\"p\", tier.pubkey]);\n    this.tags.push([\"event\", JSON.stringify(tier.rawEvent())]);\n  }\n  /**\n   * Fetches the tier that the user is subscribing to.\n   */\n  async fetchTier() {\n    const eventTag = this.tagValue(\"event\");\n    if (eventTag) {\n      try {\n        const parsedEvent = JSON.parse(eventTag);\n        return new NDKSubscriptionTier(this.ndk, parsedEvent);\n      } catch {\n        this.debug(\"Failed to parse event tag\");\n      }\n    }\n    const tierId = this.tierId;\n    if (!tierId) return void 0;\n    const e = await this.ndk?.fetchEvent(tierId);\n    if (!e) return void 0;\n    return NDKSubscriptionTier.from(e);\n  }\n  get isValid() {\n    if (this.getMatchingTags(\"amount\").length !== 1) {\n      this.debug(\"Invalid # of amount tag\");\n      return false;\n    }\n    if (!this.amount) {\n      this.debug(\"Invalid amount tag\");\n      return false;\n    }\n    if (this.getMatchingTags(\"p\").length !== 1) {\n      this.debug(\"Invalid # of p tag\");\n      return false;\n    }\n    if (!this.recipient) {\n      this.debug(\"Invalid p tag\");\n      return false;\n    }\n    return true;\n  }\n};\n\n// src/events/gift-wrapping.ts\n\n\n// src/signers/private-key/index.ts\n\n\n\nvar NDKPrivateKeySigner = class _NDKPrivateKeySigner {\n  _user;\n  _privateKey;\n  _pubkey;\n  /**\n   * Create a new signer from a private key.\n   * @param privateKey - The private key to use in hex form or nsec.\n   * @param ndk - The NDK instance to use.\n   */\n  constructor(privateKeyOrNsec, ndk) {\n    if (typeof privateKeyOrNsec === \"string\") {\n      if (privateKeyOrNsec.startsWith(\"nsec1\")) {\n        const { type, data } = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(privateKeyOrNsec);\n        if (type === \"nsec\") this._privateKey = data;\n        else throw new Error(\"Invalid private key provided.\");\n      } else if (privateKeyOrNsec.length === 64) {\n        this._privateKey = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(privateKeyOrNsec);\n      } else {\n        throw new Error(\"Invalid private key provided.\");\n      }\n    } else {\n      this._privateKey = privateKeyOrNsec;\n    }\n    this._pubkey = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.getPublicKey)(this._privateKey);\n    if (ndk) this._user = ndk.getUser({ pubkey: this._pubkey });\n    this._user ??= new NDKUser({ pubkey: this._pubkey });\n  }\n  /**\n   * Get the private key in hex form.\n   */\n  get privateKey() {\n    if (!this._privateKey) throw new Error(\"Not ready\");\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(this._privateKey);\n  }\n  /**\n   * Get the public key in hex form.\n   */\n  get pubkey() {\n    if (!this._pubkey) throw new Error(\"Not ready\");\n    return this._pubkey;\n  }\n  /**\n   * Get the private key in nsec form.\n   */\n  get nsec() {\n    if (!this._privateKey) throw new Error(\"Not ready\");\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.nsecEncode(this._privateKey);\n  }\n  /**\n   * Get the public key in npub form.\n   */\n  get npub() {\n    if (!this._pubkey) throw new Error(\"Not ready\");\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.npubEncode(this._pubkey);\n  }\n  /**\n   * Generate a new private key.\n   */\n  static generate() {\n    const privateKey = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.generateSecretKey)();\n    return new _NDKPrivateKeySigner(privateKey);\n  }\n  /**\n   * Noop in NDKPrivateKeySigner.\n   */\n  async blockUntilReady() {\n    return this._user;\n  }\n  /**\n   * Get the user.\n   */\n  async user() {\n    return this._user;\n  }\n  /**\n   * Get the user.\n   */\n  get userSync() {\n    return this._user;\n  }\n  async sign(event) {\n    if (!this._privateKey) {\n      throw Error(\"Attempted to sign without a private key\");\n    }\n    return (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(event, this._privateKey).sig;\n  }\n  async encryptionEnabled(scheme) {\n    const enabled = [];\n    if (!scheme || scheme === \"nip04\") enabled.push(\"nip04\");\n    if (!scheme || scheme === \"nip44\") enabled.push(\"nip44\");\n    return enabled;\n  }\n  async encrypt(recipient, value, scheme) {\n    if (!this._privateKey || !this.privateKey) {\n      throw Error(\"Attempted to encrypt without a private key\");\n    }\n    const recipientHexPubKey = recipient.pubkey;\n    if (scheme === \"nip44\") {\n      const conversationKey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.utils.getConversationKey(this._privateKey, recipientHexPubKey);\n      return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.encrypt(value, conversationKey);\n    }\n    return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip04.encrypt(this._privateKey, recipientHexPubKey, value);\n  }\n  async decrypt(sender, value, scheme) {\n    if (!this._privateKey || !this.privateKey) {\n      throw Error(\"Attempted to decrypt without a private key\");\n    }\n    const senderHexPubKey = sender.pubkey;\n    if (scheme === \"nip44\") {\n      const conversationKey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.utils.getConversationKey(this._privateKey, senderHexPubKey);\n      return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.decrypt(value, conversationKey);\n    }\n    return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip04.decrypt(this._privateKey, senderHexPubKey, value);\n  }\n  /**\n   * Serializes the signer's private key into a storable format.\n   * @returns A JSON string containing the type and the hex private key.\n   */\n  toPayload() {\n    if (!this._privateKey) throw new Error(\"Private key not available\");\n    const payload = {\n      type: \"private-key\",\n      payload: this.privateKey\n      // Use the hex private key\n    };\n    return JSON.stringify(payload);\n  }\n  /**\n   * Deserializes the signer from a payload string.\n   * @param payloadString The JSON string obtained from toPayload().\n   * @param ndk Optional NDK instance.\n   * @returns An instance of NDKPrivateKeySigner.\n   */\n  static async fromPayload(payloadString, ndk) {\n    const payload = JSON.parse(payloadString);\n    if (payload.type !== \"private-key\") {\n      throw new Error(`Invalid payload type: expected 'private-key', got ${payload.type}`);\n    }\n    if (!payload.payload || typeof payload.payload !== \"string\") {\n      throw new Error(\"Invalid payload content for private-key signer\");\n    }\n    return new _NDKPrivateKeySigner(payload.payload, ndk);\n  }\n};\n\n// src/events/gift-wrapping.ts\nasync function giftWrap(event, recipient, signer, params = {}) {\n  let _signer = signer;\n  params.scheme ??= \"nip44\";\n  if (!_signer) {\n    if (!event.ndk) throw new Error(\"no signer available for giftWrap\");\n    _signer = event.ndk.signer;\n  }\n  if (!_signer) throw new Error(\"no signer\");\n  if (!_signer.encryptionEnabled || !_signer.encryptionEnabled(params.scheme))\n    throw new Error(\"signer is not able to giftWrap\");\n  const rumor = getRumorEvent(event, params?.rumorKind);\n  const seal = await getSealEvent(rumor, recipient, _signer, params.scheme);\n  const wrap = await getWrapEvent(seal, recipient, params);\n  return new NDKEvent(event.ndk, wrap);\n}\nasync function giftUnwrap(event, sender, signer, scheme = \"nip44\") {\n  const _sender = sender || new NDKUser({ pubkey: event.pubkey });\n  let _signer = signer;\n  if (!_signer) {\n    if (!event.ndk) throw new Error(\"no signer available for giftUnwrap\");\n    _signer = event.ndk.signer;\n  }\n  if (!signer) throw new Error(\"no signer\");\n  try {\n    const seal = JSON.parse(await signer.decrypt(_sender, event.content, scheme));\n    if (!seal) throw new Error(\"Failed to decrypt wrapper\");\n    if (!new NDKEvent(void 0, seal).verifySignature(false))\n      throw new Error(\"GiftSeal signature verification failed!\");\n    const rumorSender = new NDKUser({ pubkey: seal.pubkey });\n    const rumor = JSON.parse(await signer.decrypt(rumorSender, seal.content, scheme));\n    if (!rumor) throw new Error(\"Failed to decrypt seal\");\n    if (rumor.pubkey !== seal.pubkey) throw new Error(\"Invalid GiftWrap, sender validation failed!\");\n    return new NDKEvent(event.ndk, rumor);\n  } catch (_e) {\n    return Promise.reject(\"Got error unwrapping event! See console log.\");\n  }\n}\nfunction getRumorEvent(event, kind) {\n  const rumor = event.rawEvent();\n  rumor.kind = kind || rumor.kind || 14 /* PrivateDirectMessage */;\n  rumor.sig = void 0;\n  rumor.id = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.getEventHash)(rumor);\n  return new NDKEvent(event.ndk, rumor);\n}\nasync function getSealEvent(rumor, recipient, signer, scheme = \"nip44\") {\n  const seal = new NDKEvent(rumor.ndk);\n  seal.kind = 13 /* GiftWrapSeal */;\n  seal.created_at = approximateNow(5);\n  seal.content = JSON.stringify(rumor.rawEvent());\n  await seal.encrypt(recipient, signer, scheme);\n  await seal.sign(signer);\n  return seal;\n}\nasync function getWrapEvent(sealed, recipient, params, scheme = \"nip44\") {\n  const signer = NDKPrivateKeySigner.generate();\n  const wrap = new NDKEvent(sealed.ndk);\n  wrap.kind = 1059 /* GiftWrap */;\n  wrap.created_at = approximateNow(5);\n  if (params?.wrapTags) wrap.tags = params.wrapTags;\n  wrap.tag(recipient);\n  wrap.content = JSON.stringify(sealed.rawEvent());\n  await wrap.encrypt(recipient, signer, scheme);\n  await wrap.sign(signer);\n  return wrap;\n}\nfunction approximateNow(drift = 0) {\n  return Math.round(Date.now() / 1e3 - Math.random() * 10 ** drift);\n}\n\n// src/events/kinds/simple-group/index.ts\nvar NDKSimpleGroup = class _NDKSimpleGroup {\n  ndk;\n  groupId;\n  relaySet;\n  fetchingMetadata;\n  metadata;\n  memberList;\n  adminList;\n  constructor(ndk, relaySet, groupId) {\n    this.ndk = ndk;\n    this.groupId = groupId ?? randomId(24);\n    this.relaySet = relaySet;\n  }\n  get id() {\n    return this.groupId;\n  }\n  relayUrls() {\n    return this.relaySet?.relayUrls;\n  }\n  get name() {\n    return this.metadata?.name;\n  }\n  get about() {\n    return this.metadata?.about;\n  }\n  get picture() {\n    return this.metadata?.picture;\n  }\n  get members() {\n    return this.memberList?.members ?? [];\n  }\n  get admins() {\n    return this.adminList?.members ?? [];\n  }\n  async getMetadata() {\n    await this.ensureMetadataEvent();\n    return this.metadata;\n  }\n  /**\n   * Creates the group by publishing a kind:9007 event.\n   * @param signer\n   * @returns\n   */\n  async createGroup(signer) {\n    signer ??= this.ndk.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    if (!user) throw new Error(\"No user available\");\n    const event = new NDKEvent(this.ndk);\n    event.kind = 9007 /* GroupAdminCreateGroup */;\n    event.tags.push([\"h\", this.groupId]);\n    await event.sign(signer);\n    return event.publish(this.relaySet);\n  }\n  async setMetadata({ name, about, picture }) {\n    const event = new NDKEvent(this.ndk);\n    event.kind = 9002 /* GroupAdminEditMetadata */;\n    event.tags.push([\"h\", this.groupId]);\n    if (name) event.tags.push([\"name\", name]);\n    if (about) event.tags.push([\"about\", about]);\n    if (picture) event.tags.push([\"picture\", picture]);\n    await event.sign();\n    return event.publish(this.relaySet);\n  }\n  /**\n   * Adds a user to the group using a kind:9000 event\n   * @param user user to add\n   * @param opts options\n   */\n  async addUser(user) {\n    const addUserEvent = _NDKSimpleGroup.generateAddUserEvent(user.pubkey, this.groupId);\n    addUserEvent.ndk = this.ndk;\n    return addUserEvent;\n  }\n  async getMemberListEvent() {\n    const memberList = await this.ndk.fetchEvent(\n      {\n        kinds: [39002 /* GroupMembers */],\n        \"#d\": [this.groupId]\n      },\n      void 0,\n      this.relaySet\n    );\n    if (!memberList) return null;\n    return NDKSimpleGroupMemberList.from(memberList);\n  }\n  /**\n   * Gets a list of users that belong to this group\n   */\n  async getMembers() {\n    const members = [];\n    const memberPubkeys = /* @__PURE__ */ new Set();\n    const memberListEvent = await this.getMemberListEvent();\n    if (!memberListEvent) return [];\n    for (const pTag of memberListEvent.getMatchingTags(\"p\")) {\n      const pubkey = pTag[1];\n      if (memberPubkeys.has(pubkey)) continue;\n      memberPubkeys.add(pubkey);\n      try {\n        members.push(this.ndk.getUser({ pubkey }));\n      } catch {\n      }\n    }\n    return members;\n  }\n  /**\n   * Generates an event that lists the members of a group.\n   * @param groupId\n   * @returns\n   */\n  static generateUserListEvent(groupId) {\n    const event = new NDKEvent(void 0, {\n      kind: 39002 /* GroupMembers */,\n      tags: [\n        [\"h\", groupId],\n        [\"alt\", \"Group Member List\"]\n      ]\n    });\n    return event;\n  }\n  /**\n   * Generates an event that adds a user to a group.\n   * @param userPubkey pubkey of the user to add\n   * @param groupId group to add the user to\n   * @returns\n   */\n  static generateAddUserEvent(userPubkey, groupId) {\n    const event = new NDKEvent(void 0, {\n      kind: 9e3 /* GroupAdminAddUser */,\n      tags: [[\"h\", groupId]]\n    });\n    event.tags.push([\"p\", userPubkey]);\n    return event;\n  }\n  async requestToJoin(_pubkey, content) {\n    const event = new NDKEvent(this.ndk, {\n      kind: 9021 /* GroupAdminRequestJoin */,\n      content: content ?? \"\",\n      tags: [[\"h\", this.groupId]]\n    });\n    return event.publish(this.relaySet);\n  }\n  /**\n   * Makes sure that a metadata event exists locally\n   */\n  async ensureMetadataEvent() {\n    if (this.metadata) return;\n    if (this.fetchingMetadata) return this.fetchingMetadata;\n    this.fetchingMetadata = this.ndk.fetchEvent(\n      {\n        kinds: [39e3 /* GroupMetadata */],\n        \"#d\": [this.groupId]\n      },\n      void 0,\n      this.relaySet\n    ).then((event) => {\n      if (event) {\n        this.metadata = NDKSimpleGroupMetadata.from(event);\n      } else {\n        this.metadata = new NDKSimpleGroupMetadata(this.ndk);\n        this.metadata.dTag = this.groupId;\n      }\n    }).finally(() => {\n      this.fetchingMetadata = void 0;\n    }).catch(() => {\n      throw new Error(`Failed to fetch metadata for group ${this.groupId}`);\n    });\n    return this.fetchingMetadata;\n  }\n};\nfunction randomId(length) {\n  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  const charsLength = chars.length;\n  let result = \"\";\n  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * charsLength));\n  }\n  return result;\n}\n\n// src/app-settings/index.ts\nvar NDKAppSettings = class _NDKAppSettings extends NDKEvent {\n  appName;\n  settings = {};\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30078 /* AppSpecificData */;\n    this.dTag ??= this.appName;\n    if (this.content.length > 0) {\n      try {\n        this.settings = JSON.parse(this.content);\n      } catch (error) {\n        console.error(\"Error parsing app settings\", error);\n      }\n    }\n  }\n  static from(event) {\n    return new _NDKAppSettings(event.ndk, event);\n  }\n  /**\n   * Set a value for a given key.\n   *\n   * @param key\n   * @param value\n   */\n  set(key, value) {\n    this.settings[key] = value;\n  }\n  /**\n   * Get a value for a given key.\n   *\n   * @param key\n   * @returns\n   */\n  get(key) {\n    return this.settings[key];\n  }\n  async publishReplaceable(relaySet, timeoutMs, requiredRelayCount) {\n    this.content = JSON.stringify(this.settings);\n    return super.publishReplaceable(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/relay/auth-policies.ts\n\nfunction disconnect(pool, debug8) {\n  debug8 ??= debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:relay:auth-policies:disconnect\");\n  return async (relay) => {\n    debug8?.(`Relay ${relay.url} requested authentication, disconnecting`);\n    pool.removeRelay(relay.url);\n  };\n}\nasync function signAndAuth(event, relay, signer, debug8, resolve, reject) {\n  try {\n    await event.sign(signer);\n    resolve(event);\n  } catch (e) {\n    debug8?.(`Failed to publish auth event to relay ${relay.url}`, e);\n    reject(event);\n  }\n}\nfunction signIn({ ndk, signer, debug: debug8 } = {}) {\n  debug8 ??= debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:auth-policies:signIn\");\n  return async (relay, challenge) => {\n    debug8?.(`Relay ${relay.url} requested authentication, signing in`);\n    const event = new NDKEvent(ndk);\n    event.kind = 22242 /* ClientAuth */;\n    event.tags = [\n      [\"relay\", relay.url],\n      [\"challenge\", challenge]\n    ];\n    signer ??= ndk?.signer;\n    return new Promise(async (resolve, reject) => {\n      if (signer) {\n        await signAndAuth(event, relay, signer, debug8, resolve, reject);\n      } else {\n        ndk?.once(\"signer:ready\", async (signer2) => {\n          await signAndAuth(event, relay, signer2, debug8, resolve, reject);\n        });\n      }\n    });\n  };\n}\nvar NDKRelayAuthPolicies = {\n  disconnect,\n  signIn\n};\n\n// src/signers/nip07/index.ts\n\nvar NDKNip07Signer = class _NDKNip07Signer {\n  _userPromise;\n  encryptionQueue = [];\n  encryptionProcessing = false;\n  debug;\n  waitTimeout;\n  _pubkey;\n  ndk;\n  _user;\n  /**\n   * @param waitTimeout - The timeout in milliseconds to wait for the NIP-07 to become available\n   */\n  constructor(waitTimeout = 1e3, ndk) {\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:nip07\");\n    this.waitTimeout = waitTimeout;\n    this.ndk = ndk;\n  }\n  get pubkey() {\n    if (!this._pubkey) throw new Error(\"Not ready\");\n    return this._pubkey;\n  }\n  async blockUntilReady() {\n    await this.waitForExtension();\n    const pubkey = await window.nostr?.getPublicKey();\n    if (!pubkey) {\n      throw new Error(\"User rejected access\");\n    }\n    this._pubkey = pubkey;\n    let user;\n    if (this.ndk) user = this.ndk.getUser({ pubkey });\n    else user = new NDKUser({ pubkey });\n    this._user = user;\n    return user;\n  }\n  /**\n   * Getter for the user property.\n   * @returns The NDKUser instance.\n   */\n  async user() {\n    if (!this._userPromise) {\n      this._userPromise = this.blockUntilReady();\n    }\n    return this._userPromise;\n  }\n  get userSync() {\n    if (!this._user) throw new Error(\"User not ready\");\n    return this._user;\n  }\n  /**\n   * Signs the given Nostr event.\n   * @param event - The Nostr event to be signed.\n   * @returns The signature of the signed event.\n   * @throws Error if the NIP-07 is not available on the window object.\n   */\n  async sign(event) {\n    await this.waitForExtension();\n    const signedEvent = await window.nostr?.signEvent(event);\n    if (!signedEvent) throw new Error(\"Failed to sign event\");\n    return signedEvent.sig;\n  }\n  async relays(ndk) {\n    await this.waitForExtension();\n    const relays = await window.nostr?.getRelays?.() || {};\n    const activeRelays = [];\n    for (const url of Object.keys(relays)) {\n      if (relays[url].read && relays[url].write) {\n        activeRelays.push(url);\n      }\n    }\n    return activeRelays.map((url) => new NDKRelay(url, ndk?.relayAuthDefaultPolicy, ndk));\n  }\n  async encryptionEnabled(nip) {\n    const enabled = [];\n    if ((!nip || nip === \"nip04\") && Boolean(window.nostr?.nip04)) enabled.push(\"nip04\");\n    if ((!nip || nip === \"nip44\") && Boolean(window.nostr?.nip44)) enabled.push(\"nip44\");\n    return enabled;\n  }\n  async encrypt(recipient, value, nip = \"nip04\") {\n    if (!await this.encryptionEnabled(nip))\n      throw new Error(`${nip}encryption is not available from your browser extension`);\n    await this.waitForExtension();\n    const recipientHexPubKey = recipient.pubkey;\n    return this.queueEncryption(nip, \"encrypt\", recipientHexPubKey, value);\n  }\n  async decrypt(sender, value, nip = \"nip04\") {\n    if (!await this.encryptionEnabled(nip))\n      throw new Error(`${nip}encryption is not available from your browser extension`);\n    await this.waitForExtension();\n    const senderHexPubKey = sender.pubkey;\n    return this.queueEncryption(nip, \"decrypt\", senderHexPubKey, value);\n  }\n  async queueEncryption(scheme, method, counterpartyHexpubkey, value) {\n    return new Promise((resolve, reject) => {\n      this.encryptionQueue.push({\n        scheme,\n        method,\n        counterpartyHexpubkey,\n        value,\n        resolve,\n        reject\n      });\n      if (!this.encryptionProcessing) {\n        this.processEncryptionQueue();\n      }\n    });\n  }\n  async processEncryptionQueue(item, retries = 0) {\n    if (!item && this.encryptionQueue.length === 0) {\n      this.encryptionProcessing = false;\n      return;\n    }\n    this.encryptionProcessing = true;\n    const currentItem = item || this.encryptionQueue.shift();\n    if (!currentItem) {\n      this.encryptionProcessing = false;\n      return;\n    }\n    const { scheme, method, counterpartyHexpubkey, value, resolve, reject } = currentItem;\n    this.debug(\"Processing encryption queue item\", {\n      method,\n      counterpartyHexpubkey,\n      value\n    });\n    try {\n      const result = await window.nostr?.[scheme]?.[method](counterpartyHexpubkey, value);\n      if (!result) throw new Error(\"Failed to encrypt/decrypt\");\n      resolve(result);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      if (errorMessage.includes(\"call already executing\") && retries < 5) {\n        this.debug(\"Retrying encryption queue item\", {\n          method,\n          counterpartyHexpubkey,\n          value,\n          retries\n        });\n        setTimeout(() => {\n          this.processEncryptionQueue(currentItem, retries + 1);\n        }, 50 * retries);\n        return;\n      }\n      reject(error instanceof Error ? error : new Error(errorMessage));\n    }\n    this.processEncryptionQueue();\n  }\n  waitForExtension() {\n    return new Promise((resolve, reject) => {\n      if (window.nostr) {\n        resolve();\n        return;\n      }\n      let timerId;\n      const intervalId = setInterval(() => {\n        if (window.nostr) {\n          clearTimeout(timerId);\n          clearInterval(intervalId);\n          resolve();\n        }\n      }, 100);\n      timerId = setTimeout(() => {\n        clearInterval(intervalId);\n        reject(new Error(\"NIP-07 extension not available\"));\n      }, this.waitTimeout);\n    });\n  }\n  /**\n   * Serializes the signer type into a storable format.\n   * NIP-07 signers don't have persistent state to serialize beyond their type.\n   * @returns A JSON string containing the type.\n   */\n  toPayload() {\n    const payload = {\n      type: \"nip07\",\n      payload: \"\"\n      // No specific payload needed for NIP-07\n    };\n    return JSON.stringify(payload);\n  }\n  /**\n   * Deserializes the signer from a payload string.\n   * Creates a new NDKNip07Signer instance.\n   * @param payloadString The JSON string obtained from toPayload().\n   * @param ndk Optional NDK instance.\n   * @returns An instance of NDKNip07Signer.\n   */\n  static async fromPayload(payloadString, ndk) {\n    const payload = JSON.parse(payloadString);\n    if (payload.type !== \"nip07\") {\n      throw new Error(`Invalid payload type: expected 'nip07', got ${payload.type}`);\n    }\n    return new _NDKNip07Signer(void 0, ndk);\n  }\n};\n\n// src/signers/nip46/backend/index.ts\n\n\n// src/signers/nip46/rpc.ts\n\nvar NDKNostrRpc = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  signer;\n  relaySet;\n  debug;\n  encryptionType = \"nip04\";\n  pool;\n  constructor(ndk, signer, debug8, relayUrls) {\n    super();\n    this.ndk = ndk;\n    this.signer = signer;\n    if (relayUrls) {\n      this.pool = new NDKPool(relayUrls, [], ndk, {\n        debug: debug8.extend(\"rpc-pool\"),\n        name: \"Nostr RPC\"\n      });\n      this.relaySet = new NDKRelaySet(/* @__PURE__ */ new Set(), ndk, this.pool);\n      for (const url of relayUrls) {\n        const relay = this.pool.getRelay(url, false, false);\n        relay.authPolicy = NDKRelayAuthPolicies.signIn({ ndk, signer, debug: debug8 });\n        this.relaySet.addRelay(relay);\n        relay.connect();\n      }\n    }\n    this.debug = debug8.extend(\"rpc\");\n  }\n  /**\n   * Subscribe to a filter. This function will resolve once the subscription is ready.\n   */\n  subscribe(filter) {\n    const sub = this.ndk.subscribe(\n      filter,\n      {\n        closeOnEose: false,\n        groupable: false,\n        cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */,\n        pool: this.pool,\n        relaySet: this.relaySet\n      },\n      false\n    );\n    sub.on(\"event\", async (event) => {\n      try {\n        const parsedEvent = await this.parseEvent(event);\n        if (parsedEvent.method) {\n          this.emit(\"request\", parsedEvent);\n        } else {\n          this.emit(`response-${parsedEvent.id}`, parsedEvent);\n        }\n      } catch (e) {\n        this.debug(\"error parsing event\", e, event.rawEvent());\n      }\n    });\n    return new Promise((resolve) => {\n      sub.on(\"eose\", () => {\n        this.debug(\"eosed\");\n        resolve(sub);\n      });\n      sub.start();\n    });\n  }\n  async parseEvent(event) {\n    if (this.encryptionType === \"nip44\" && event.content.includes(\"?iv=\")) {\n      this.encryptionType = \"nip04\";\n    } else if (this.encryptionType === \"nip04\" && !event.content.includes(\"?iv=\")) {\n      this.encryptionType = \"nip44\";\n    }\n    const remoteUser = this.ndk.getUser({ pubkey: event.pubkey });\n    remoteUser.ndk = this.ndk;\n    let decryptedContent;\n    try {\n      decryptedContent = await this.signer.decrypt(remoteUser, event.content, this.encryptionType);\n    } catch (_e) {\n      const otherEncryptionType = this.encryptionType === \"nip04\" ? \"nip44\" : \"nip04\";\n      decryptedContent = await this.signer.decrypt(remoteUser, event.content, otherEncryptionType);\n      this.encryptionType = otherEncryptionType;\n    }\n    const parsedContent = JSON.parse(decryptedContent);\n    const { id, method, params, result, error } = parsedContent;\n    if (method) {\n      return { id, pubkey: event.pubkey, method, params, event };\n    }\n    return { id, result, error, event };\n  }\n  async sendResponse(id, remotePubkey, result, kind = 24133 /* NostrConnect */, error) {\n    const res = { id, result };\n    if (error) {\n      res.error = error;\n    }\n    const localUser = await this.signer.user();\n    const remoteUser = this.ndk.getUser({ pubkey: remotePubkey });\n    const event = new NDKEvent(this.ndk, {\n      kind,\n      content: JSON.stringify(res),\n      tags: [[\"p\", remotePubkey]],\n      pubkey: localUser.pubkey\n    });\n    event.content = await this.signer.encrypt(remoteUser, event.content, this.encryptionType);\n    await event.sign(this.signer);\n    await event.publish(this.relaySet);\n  }\n  /**\n   * Sends a request.\n   * @param remotePubkey\n   * @param method\n   * @param params\n   * @param kind\n   * @param id\n   */\n  async sendRequest(remotePubkey, method, params = [], kind = 24133, cb) {\n    const id = Math.random().toString(36).substring(7);\n    const localUser = await this.signer.user();\n    const remoteUser = this.ndk.getUser({ pubkey: remotePubkey });\n    const request = { id, method, params };\n    const promise = new Promise(() => {\n      const responseHandler = (response) => {\n        if (response.result === \"auth_url\") {\n          this.once(`response-${id}`, responseHandler);\n          this.emit(\"authUrl\", response.error);\n        } else if (cb) {\n          cb(response);\n        }\n      };\n      this.once(`response-${id}`, responseHandler);\n    });\n    const event = new NDKEvent(this.ndk, {\n      kind,\n      content: JSON.stringify(request),\n      tags: [[\"p\", remotePubkey]],\n      pubkey: localUser.pubkey\n    });\n    event.content = await this.signer.encrypt(remoteUser, event.content, this.encryptionType);\n    await event.sign(this.signer);\n    await event.publish(this.relaySet);\n    return promise;\n  }\n};\n\n// src/signers/nip46/backend/connect.ts\nvar ConnectEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [_, token] = params;\n    const debug8 = backend.debug.extend(\"connect\");\n    debug8(`connection request from ${remotePubkey}`);\n    if (token && backend.applyToken) {\n      debug8(\"applying token\");\n      await backend.applyToken(remotePubkey, token);\n    }\n    if (await backend.pubkeyAllowed({\n      id,\n      pubkey: remotePubkey,\n      method: \"connect\",\n      params: token\n    })) {\n      debug8(`connection request from ${remotePubkey} allowed`);\n      return \"ack\";\n    }\n    debug8(`connection request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n};\n\n// src/signers/nip46/backend/get-public-key.ts\nvar GetPublicKeyHandlingStrategy = class {\n  async handle(backend, _id, _remotePubkey, _params) {\n    return backend.localUser?.pubkey;\n  }\n};\n\n// src/signers/nip46/backend/nip04-decrypt.ts\nvar Nip04DecryptHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [senderPubkey, payload] = params;\n    const senderUser = new NDKUser({ pubkey: senderPubkey });\n    const decryptedPayload = await decrypt2(backend, id, remotePubkey, senderUser, payload);\n    return decryptedPayload;\n  }\n};\nasync function decrypt2(backend, id, remotePubkey, senderUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip04_decrypt\",\n    params: payload\n  })) {\n    backend.debug(`decrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.decrypt(senderUser, payload, \"nip04\");\n}\n\n// src/signers/nip46/backend/nip04-encrypt.ts\nvar Nip04EncryptHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [recipientPubkey, payload] = params;\n    const recipientUser = new NDKUser({ pubkey: recipientPubkey });\n    const encryptedPayload = await encrypt2(backend, id, remotePubkey, recipientUser, payload);\n    return encryptedPayload;\n  }\n};\nasync function encrypt2(backend, id, remotePubkey, recipientUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip04_encrypt\",\n    params: payload\n  })) {\n    backend.debug(`encrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.encrypt(recipientUser, payload, \"nip04\");\n}\n\n// src/signers/nip46/backend/nip44-decrypt.ts\nvar Nip04DecryptHandlingStrategy2 = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [senderPubkey, payload] = params;\n    const senderUser = new NDKUser({ pubkey: senderPubkey });\n    const decryptedPayload = await decrypt3(backend, id, remotePubkey, senderUser, payload);\n    return decryptedPayload;\n  }\n};\nasync function decrypt3(backend, id, remotePubkey, senderUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip44_decrypt\",\n    params: payload\n  })) {\n    backend.debug(`decrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.decrypt(senderUser, payload, \"nip44\");\n}\n\n// src/signers/nip46/backend/nip44-encrypt.ts\nvar Nip04EncryptHandlingStrategy2 = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [recipientPubkey, payload] = params;\n    const recipientUser = new NDKUser({ pubkey: recipientPubkey });\n    const encryptedPayload = await encrypt3(backend, id, remotePubkey, recipientUser, payload);\n    return encryptedPayload;\n  }\n};\nasync function encrypt3(backend, id, remotePubkey, recipientUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip44_encrypt\",\n    params: payload\n  })) {\n    backend.debug(`encrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.encrypt(recipientUser, payload, \"nip44\");\n}\n\n// src/signers/nip46/backend/ping.ts\nvar PingEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, _params) {\n    const debug8 = backend.debug.extend(\"ping\");\n    debug8(`ping request from ${remotePubkey}`);\n    if (await backend.pubkeyAllowed({ id, pubkey: remotePubkey, method: \"ping\" })) {\n      debug8(`connection request from ${remotePubkey} allowed`);\n      return \"pong\";\n    }\n    debug8(`connection request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n};\n\n// src/signers/nip46/backend/sign-event.ts\nvar SignEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const event = await signEvent(backend, id, remotePubkey, params);\n    if (!event) return void 0;\n    return JSON.stringify(await event.toNostrEvent());\n  }\n};\nasync function signEvent(backend, id, remotePubkey, params) {\n  const [eventString] = params;\n  backend.debug(`sign event request from ${remotePubkey}`);\n  const event = new NDKEvent(backend.ndk, JSON.parse(eventString));\n  backend.debug(\"event to sign\", event.rawEvent());\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"sign_event\",\n    params: event\n  })) {\n    backend.debug(`sign event request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  backend.debug(`sign event request from ${remotePubkey} allowed`);\n  await event.sign(backend.signer);\n  return event;\n}\n\n// src/signers/nip46/backend/index.ts\nvar NDKNip46Backend = class {\n  ndk;\n  signer;\n  localUser;\n  debug;\n  rpc;\n  permitCallback;\n  relayUrls;\n  /**\n   * @param ndk The NDK instance to use\n   * @param privateKeyOrSigner The private key or signer of the npub that wants to be published as\n   * @param permitCallback Callback executed when permission is requested\n   */\n  constructor(ndk, privateKeyOrSigner, permitCallback, relayUrls) {\n    this.ndk = ndk;\n    if (privateKeyOrSigner instanceof Uint8Array) {\n      this.signer = new NDKPrivateKeySigner(privateKeyOrSigner);\n    } else if (privateKeyOrSigner instanceof String) {\n      this.signer = new NDKPrivateKeySigner((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(privateKeyOrSigner));\n    } else if (privateKeyOrSigner instanceof NDKPrivateKeySigner) {\n      this.signer = privateKeyOrSigner;\n    } else {\n      throw new Error(\"Invalid signer\");\n    }\n    this.debug = ndk.debug.extend(\"nip46:backend\");\n    this.relayUrls = relayUrls ?? Array.from(ndk.pool.relays.keys());\n    this.rpc = new NDKNostrRpc(ndk, this.signer, this.debug, this.relayUrls);\n    this.permitCallback = permitCallback;\n  }\n  /**\n   * This method starts the backend, which will start listening for incoming\n   * requests.\n   */\n  async start() {\n    this.localUser = await this.signer.user();\n    const sub = this.ndk.subscribe(\n      {\n        kinds: [24133],\n        \"#p\": [this.localUser.pubkey]\n      },\n      { closeOnEose: false }\n    );\n    sub.on(\"event\", (e) => this.handleIncomingEvent(e));\n  }\n  handlers = {\n    connect: new ConnectEventHandlingStrategy(),\n    sign_event: new SignEventHandlingStrategy(),\n    nip04_encrypt: new Nip04EncryptHandlingStrategy(),\n    nip04_decrypt: new Nip04DecryptHandlingStrategy(),\n    nip44_encrypt: new Nip04EncryptHandlingStrategy2(),\n    nip44_decrypt: new Nip04DecryptHandlingStrategy2(),\n    get_public_key: new GetPublicKeyHandlingStrategy(),\n    ping: new PingEventHandlingStrategy()\n  };\n  /**\n   * Enables the user to set a custom strategy for handling incoming events.\n   * @param method - The method to set the strategy for\n   * @param strategy - The strategy to set\n   */\n  setStrategy(method, strategy) {\n    this.handlers[method] = strategy;\n  }\n  /**\n   * Overload this method to apply tokens, which can\n   * wrap permission sets to be applied to a pubkey.\n   * @param pubkey public key to apply token to\n   * @param token token to apply\n   */\n  async applyToken(_pubkey, _token) {\n    throw new Error(\"connection token not supported\");\n  }\n  async handleIncomingEvent(event) {\n    const { id, method, params } = await this.rpc.parseEvent(event);\n    const remotePubkey = event.pubkey;\n    let response;\n    this.debug(\"incoming event\", { id, method, params });\n    if (!event.verifySignature(false)) {\n      this.debug(\"invalid signature\", event.rawEvent());\n      return;\n    }\n    const strategy = this.handlers[method];\n    if (strategy) {\n      try {\n        response = await strategy.handle(this, id, remotePubkey, params);\n      } catch (e) {\n        this.debug(\"error handling event\", e, { id, method, params });\n        this.rpc.sendResponse(id, remotePubkey, \"error\", void 0, e.message);\n      }\n    } else {\n      this.debug(\"unsupported method\", { method, params });\n    }\n    if (response) {\n      this.debug(`sending response to ${remotePubkey}`, response);\n      this.rpc.sendResponse(id, remotePubkey, response);\n    } else {\n      this.rpc.sendResponse(id, remotePubkey, \"error\", void 0, \"Not authorized\");\n    }\n  }\n  /**\n   * This method should be overriden by the user to allow or reject incoming\n   * connections.\n   */\n  async pubkeyAllowed(params) {\n    return this.permitCallback(params);\n  }\n};\n\n// src/signers/nip46/index.ts\n\n\n// src/signers/deserialization.ts\nvar signerRegistry = /* @__PURE__ */ new Map();\nsignerRegistry.set(\"private-key\", NDKPrivateKeySigner);\nsignerRegistry.set(\"nip07\", NDKNip07Signer);\nsignerRegistry.set(\"nip46\", NDKNip46Signer);\nasync function ndkSignerFromPayload(payloadString, ndk) {\n  let parsed;\n  try {\n    parsed = JSON.parse(payloadString);\n  } catch (e) {\n    throw new Error(`Failed to parse signer payload: ${e instanceof Error ? e.message : String(e)}`);\n  }\n  const SignerClass = signerRegistry.get(parsed.type);\n  if (!SignerClass) {\n    throw new Error(`Unknown signer type: ${parsed.type}`);\n  }\n  try {\n    return await SignerClass.fromPayload(payloadString, ndk);\n  } catch (e) {\n    const errorMsg = e instanceof Error ? e.message : String(e);\n    throw new Error(`Failed to deserialize signer type ${parsed.type}: ${errorMsg}`);\n  }\n}\n\n// src/signers/nip46/index.ts\nvar NDKNip46Signer = class _NDKNip46Signer extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  _user;\n  /**\n   * The pubkey of the bunker that will be providing signatures\n   */\n  bunkerPubkey;\n  /**\n   * The pubkey of the user that events will be published as\n   */\n  userPubkey;\n  get pubkey() {\n    if (!this.userPubkey) throw new Error(\"Not ready\");\n    return this.userPubkey;\n  }\n  /**\n   * An optional secret value provided to connect to the bunker\n   */\n  secret;\n  localSigner;\n  nip05;\n  rpc;\n  debug;\n  relayUrls;\n  subscription;\n  /**\n   * @param ndk - The NDK instance to use\n   * @param userOrConnectionToken - The public key, or a connection token, of the npub that wants to be published as\n   * @param localSigner - The signer that will be used to request events to be signed\n   */\n  constructor(ndk, userOrConnectionToken, localSigner) {\n    super();\n    this.ndk = ndk;\n    this.debug = ndk.debug.extend(\"nip46:signer\");\n    if (userOrConnectionToken.startsWith(\"bunker://\")) {\n      this.connectionTokenInit(userOrConnectionToken);\n    } else {\n      this.nip05Init(userOrConnectionToken);\n    }\n    if (!localSigner) {\n      this.localSigner = NDKPrivateKeySigner.generate();\n    } else {\n      this.localSigner = localSigner;\n    }\n    this.rpc = new NDKNostrRpc(this.ndk, this.localSigner, this.debug, this.relayUrls);\n  }\n  connectionTokenInit(connectionToken) {\n    const bunkerUrl = new URL(connectionToken);\n    const bunkerPubkey = bunkerUrl.hostname || bunkerUrl.pathname.replace(/^\\/\\//, \"\");\n    const userPubkey = bunkerUrl.searchParams.get(\"pubkey\");\n    const relayUrls = bunkerUrl.searchParams.getAll(\"relay\");\n    const secret = bunkerUrl.searchParams.get(\"secret\");\n    this.bunkerPubkey = bunkerPubkey;\n    this.userPubkey = userPubkey;\n    this.relayUrls = relayUrls;\n    this.secret = secret;\n  }\n  nip05Init(nip05) {\n    this.nip05 = nip05;\n  }\n  /**\n   * We start listening for events from the bunker\n   */\n  async startListening() {\n    if (this.subscription) return;\n    const localUser = await this.localSigner.user();\n    if (!localUser) throw new Error(\"Local signer not ready\");\n    this.subscription = await this.rpc.subscribe({\n      kinds: [24133 /* NostrConnect */],\n      \"#p\": [localUser.pubkey]\n    });\n  }\n  /**\n   * Get the user that is being published as\n   */\n  async user() {\n    if (this._user) return this._user;\n    return this.blockUntilReady();\n  }\n  get userSync() {\n    if (!this._user) throw new Error(\"Remote user not ready synchronously\");\n    return this._user;\n  }\n  async blockUntilReady() {\n    if (this.nip05 && !this.userPubkey) {\n      const user = await NDKUser.fromNip05(this.nip05, this.ndk);\n      if (user) {\n        this._user = user;\n        this.userPubkey = user.pubkey;\n        this.relayUrls = user.nip46Urls;\n        this.rpc = new NDKNostrRpc(this.ndk, this.localSigner, this.debug, this.relayUrls);\n      }\n    }\n    if (!this.bunkerPubkey && this.userPubkey) {\n      this.bunkerPubkey = this.userPubkey;\n    } else if (!this.bunkerPubkey) {\n      throw new Error(\"Bunker pubkey not set\");\n    }\n    await this.startListening();\n    this.rpc.on(\"authUrl\", (...props) => {\n      this.emit(\"authUrl\", ...props);\n    });\n    return new Promise((resolve, reject) => {\n      const connectParams = [this.userPubkey ?? \"\"];\n      if (this.secret) connectParams.push(this.secret);\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(this.bunkerPubkey, \"connect\", connectParams, 24133, (response) => {\n        if (response.result === \"ack\") {\n          this.getPublicKey().then((pubkey) => {\n            this.userPubkey = pubkey;\n            this._user = this.ndk.getUser({ pubkey });\n            resolve(this._user);\n          });\n        } else {\n          reject(response.error);\n        }\n      });\n    });\n  }\n  async getPublicKey() {\n    if (this.userPubkey) return this.userPubkey;\n    return new Promise((resolve, _reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(this.bunkerPubkey, \"get_public_key\", [], 24133, (response) => {\n        resolve(response.result);\n      });\n    });\n  }\n  async encryptionEnabled(scheme) {\n    if (scheme) return [scheme];\n    return Promise.resolve([\"nip04\", \"nip44\"]);\n  }\n  async encrypt(recipient, value, scheme = \"nip04\") {\n    return this.encryption(recipient, value, scheme, \"encrypt\");\n  }\n  async decrypt(sender, value, scheme = \"nip04\") {\n    return this.encryption(sender, value, scheme, \"decrypt\");\n  }\n  async encryption(peer, value, scheme, method) {\n    const promise = new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        `${scheme}_${method}`,\n        [peer.pubkey, value],\n        24133,\n        (response) => {\n          if (!response.error) {\n            resolve(response.result);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n    return promise;\n  }\n  async sign(event) {\n    const promise = new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"sign_event\",\n        [JSON.stringify(event)],\n        24133,\n        (response) => {\n          if (!response.error) {\n            const json = JSON.parse(response.result);\n            resolve(json.sig);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n    return promise;\n  }\n  /**\n   * Allows creating a new account on the remote server.\n   * @param username Desired username for the NIP-05\n   * @param domain Desired domain for the NIP-05\n   * @param email Email address to associate with this account -- Remote servers may use this for recovery\n   * @returns The public key of the newly created account\n   */\n  async createAccount(username, domain, email) {\n    await this.startListening();\n    const req = [];\n    if (username) req.push(username);\n    if (domain) req.push(domain);\n    if (email) req.push(email);\n    return new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"create_account\",\n        req,\n        24133 /* NostrConnect */,\n        (response) => {\n          if (!response.error) {\n            const pubkey = response.result;\n            resolve(pubkey);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n  }\n  /**\n   * Serializes the signer's connection details and local signer state.\n   * @returns A JSON string containing the type, connection info, and local signer payload.\n   */\n  toPayload() {\n    if (!this.bunkerPubkey || !this.userPubkey) {\n      throw new Error(\"NIP-46 signer is not fully initialized for serialization\");\n    }\n    const payload = {\n      type: \"nip46\",\n      payload: {\n        bunkerPubkey: this.bunkerPubkey,\n        userPubkey: this.userPubkey,\n        relayUrls: this.relayUrls,\n        secret: this.secret,\n        localSignerPayload: this.localSigner.toPayload(),\n        // Store nip05 if it was used for initialization, otherwise null\n        nip05: this.nip05 || null\n      }\n    };\n    return JSON.stringify(payload);\n  }\n  /**\n   * Deserializes the signer from a payload string.\n   * @param payloadString The JSON string obtained from toPayload().\n   * @param ndk The NDK instance, required for NIP-46.\n   * @returns An instance of NDKNip46Signer.\n   */\n  static async fromPayload(payloadString, ndk) {\n    if (!ndk) {\n      throw new Error(\"NDK instance is required to deserialize NIP-46 signer\");\n    }\n    const parsed = JSON.parse(payloadString);\n    if (parsed.type !== \"nip46\") {\n      throw new Error(`Invalid payload type: expected 'nip46', got ${parsed.type}`);\n    }\n    const payload = parsed.payload;\n    if (!payload || typeof payload !== \"object\" || !payload.localSignerPayload) {\n      throw new Error(\"Invalid payload content for nip46 signer\");\n    }\n    const localSigner = await ndkSignerFromPayload(payload.localSignerPayload, ndk);\n    if (!localSigner) {\n      throw new Error(\"Failed to deserialize local signer for NIP-46\");\n    }\n    let signer;\n    if (payload.nip05) {\n      signer = new _NDKNip46Signer(ndk, payload.nip05, localSigner);\n      signer.userPubkey = payload.userPubkey;\n      signer.bunkerPubkey = payload.bunkerPubkey;\n      signer.relayUrls = payload.relayUrls;\n      signer.secret = payload.secret;\n    } else {\n      signer = new _NDKNip46Signer(ndk, payload.userPubkey, localSigner);\n      signer.bunkerPubkey = payload.bunkerPubkey;\n      signer.relayUrls = payload.relayUrls;\n      signer.secret = payload.secret;\n    }\n    return signer;\n  }\n};\n\n// src/dvm/schedule.ts\nfunction addRelays(event, relays) {\n  const tags = [];\n  if (!relays || relays.length === 0) {\n    const poolRelays = event.ndk?.pool.relays;\n    relays = poolRelays ? Object.keys(poolRelays) : void 0;\n  }\n  if (relays && relays.length > 0) tags.push([\"relays\", ...relays]);\n  return tags;\n}\nasync function dvmSchedule(events, dvm, relays, encrypted = true, waitForConfirmationForMs) {\n  if (!Array.isArray(events)) {\n    events = [events];\n  }\n  const ndk = events[0].ndk;\n  if (!ndk) throw new Error(\"NDK not set\");\n  for (const event of events) {\n    if (!event.sig) throw new Error(\"Event not signed\");\n    if (!event.created_at) throw new Error(\"Event has no date\");\n    if (!dvm) throw new Error(\"No DVM specified\");\n    if (event.created_at <= Date.now() / 1e3) throw new Error(\"Event needs to be in the future\");\n  }\n  const scheduleEvent = new NDKDVMRequest(ndk, {\n    kind: 5905 /* DVMEventSchedule */\n  });\n  for (const event of events) {\n    scheduleEvent.addInput(JSON.stringify(event.rawEvent()), \"text\");\n  }\n  scheduleEvent.tags.push(...addRelays(events[0], relays));\n  if (encrypted) {\n    await scheduleEvent.encryption(dvm);\n  } else {\n    scheduleEvent.dvm = dvm;\n  }\n  await scheduleEvent.sign();\n  let res;\n  if (waitForConfirmationForMs) {\n    res = ndk.subscribe(\n      {\n        kinds: [5905 /* DVMEventSchedule */ + 1e3, 7e3 /* DVMJobFeedback */],\n        ...scheduleEvent.filter()\n      },\n      { groupable: false, closeOnEose: false }\n    );\n  }\n  const timeoutPromise = new Promise((reject) => {\n    setTimeout(() => {\n      res?.stop();\n      reject(\"Timeout waiting for an answer from the DVM\");\n    }, waitForConfirmationForMs);\n  });\n  const schedulePromise = new Promise((resolve, reject) => {\n    if (waitForConfirmationForMs) {\n      res?.on(\"event\", async (e) => {\n        res?.stop();\n        if (e.kind === 7e3 /* DVMJobFeedback */) {\n          const feedback = await NDKDVMJobFeedback.from(e);\n          if (feedback.status === \"error\") {\n            const statusTag = feedback.getMatchingTags(\"status\");\n            reject(statusTag?.[2] ?? feedback);\n          } else {\n            resolve(feedback);\n          }\n        }\n        resolve(e);\n      });\n    }\n    scheduleEvent.publish().then(() => {\n      if (!waitForConfirmationForMs) resolve(void 0);\n    });\n  });\n  return new Promise((resolve, reject) => {\n    if (waitForConfirmationForMs) {\n      Promise.race([timeoutPromise, schedulePromise]).then((e) => {\n        resolve(e);\n      }).catch(reject);\n    } else {\n      schedulePromise.then(resolve);\n    }\n  });\n}\n\n// src/ndk/index.ts\n\n\n\n// src/events/dedup.ts\nfunction dedup(event1, event2) {\n  if (event1.created_at > event2.created_at) {\n    return event1;\n  }\n  return event2;\n}\n\n// src/outbox/tracker.ts\n\n\n\n// src/utils/get-users-relay-list.ts\nasync function getRelayListForUser(pubkey, ndk) {\n  const list = await getRelayListForUsers([pubkey], ndk);\n  return list.get(pubkey);\n}\nasync function getRelayListForUsers(pubkeys, ndk, skipCache = false, timeout = 1e3) {\n  const pool = ndk.outboxPool || ndk.pool;\n  const set = /* @__PURE__ */ new Set();\n  for (const relay of pool.relays.values()) set.add(relay);\n  const relayLists = /* @__PURE__ */ new Map();\n  const fromContactList = /* @__PURE__ */ new Map();\n  const relaySet = new NDKRelaySet(set, ndk);\n  if (ndk.cacheAdapter?.locking && !skipCache) {\n    const cachedList = await ndk.fetchEvents(\n      { kinds: [3, 10002], authors: Array.from(new Set(pubkeys)) },\n      { cacheUsage: \"ONLY_CACHE\" /* ONLY_CACHE */, subId: \"ndk-relay-list-fetch\" }\n    );\n    for (const relayList of cachedList) {\n      if (relayList.kind === 10002) relayLists.set(relayList.pubkey, NDKRelayList.from(relayList));\n    }\n    for (const relayList of cachedList) {\n      if (relayList.kind === 3) {\n        if (relayLists.has(relayList.pubkey)) continue;\n        const list = relayListFromKind3(ndk, relayList);\n        if (list) fromContactList.set(relayList.pubkey, list);\n      }\n    }\n    pubkeys = pubkeys.filter((pubkey) => !relayLists.has(pubkey) && !fromContactList.has(pubkey));\n  }\n  if (pubkeys.length === 0) return relayLists;\n  const relayListEvents = /* @__PURE__ */ new Map();\n  const contactListEvents = /* @__PURE__ */ new Map();\n  return new Promise((resolve) => {\n    const handleSubscription = async () => {\n      const subscribeOpts = {\n        closeOnEose: true,\n        pool,\n        groupable: true,\n        subId: \"ndk-relay-list-fetch\",\n        addSinceFromCache: true,\n        relaySet\n      };\n      if (relaySet) subscribeOpts.relaySet = relaySet;\n      ndk.subscribe({ kinds: [3, 10002], authors: pubkeys }, subscribeOpts, {\n        onEvent: (event) => {\n          if (event.kind === 10002 /* RelayList */) {\n            const existingEvent = relayListEvents.get(event.pubkey);\n            if (existingEvent && existingEvent.created_at > event.created_at) return;\n            relayListEvents.set(event.pubkey, event);\n          } else if (event.kind === 3 /* Contacts */) {\n            const existingEvent = contactListEvents.get(event.pubkey);\n            if (existingEvent && existingEvent.created_at > event.created_at) return;\n            contactListEvents.set(event.pubkey, event);\n          }\n        },\n        onEose: () => {\n          for (const event of relayListEvents.values()) {\n            relayLists.set(event.pubkey, NDKRelayList.from(event));\n          }\n          for (const pubkey of pubkeys) {\n            if (relayLists.has(pubkey)) continue;\n            const contactList = contactListEvents.get(pubkey);\n            if (!contactList) continue;\n            const list = relayListFromKind3(ndk, contactList);\n            if (list) relayLists.set(pubkey, list);\n          }\n          resolve(relayLists);\n        }\n      });\n      setTimeout(() => {\n        resolve(relayLists);\n      }, timeout);\n    };\n    handleSubscription();\n  });\n}\n\n// src/outbox/tracker.ts\nvar OutboxItem = class {\n  /**\n   * Type of item\n   */\n  type;\n  /**\n   * The relay URLs that are of interest to this item\n   */\n  relayUrlScores;\n  readRelays;\n  writeRelays;\n  constructor(type) {\n    this.type = type;\n    this.relayUrlScores = /* @__PURE__ */ new Map();\n    this.readRelays = /* @__PURE__ */ new Set();\n    this.writeRelays = /* @__PURE__ */ new Set();\n  }\n};\nvar OutboxTracker = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  data;\n  ndk;\n  debug;\n  constructor(ndk) {\n    super();\n    this.ndk = ndk;\n    this.debug = ndk.debug.extend(\"outbox-tracker\");\n    this.data = new typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({\n      maxSize: 1e5,\n      entryExpirationTimeInMS: 2 * 60 * 1e3\n    });\n  }\n  /**\n   * Adds a list of users to the tracker.\n   * @param items\n   * @param skipCache\n   */\n  async trackUsers(items, skipCache = false) {\n    const promises = [];\n    for (let i = 0; i < items.length; i += 400) {\n      const slice = items.slice(i, i + 400);\n      const pubkeys = slice.map((item) => getKeyFromItem(item)).filter((pubkey) => !this.data.has(pubkey));\n      if (pubkeys.length === 0) continue;\n      for (const pubkey of pubkeys) {\n        this.data.set(pubkey, new OutboxItem(\"user\"));\n      }\n      promises.push(\n        new Promise((resolve) => {\n          getRelayListForUsers(pubkeys, this.ndk, skipCache).then((relayLists) => {\n            for (const [pubkey, relayList] of relayLists) {\n              let outboxItem = this.data.get(pubkey);\n              outboxItem ??= new OutboxItem(\"user\");\n              if (relayList) {\n                outboxItem.readRelays = new Set(normalize(relayList.readRelayUrls));\n                outboxItem.writeRelays = new Set(normalize(relayList.writeRelayUrls));\n                for (const relayUrl of outboxItem.readRelays) {\n                  if (this.ndk.pool.blacklistRelayUrls.has(relayUrl)) {\n                    outboxItem.readRelays.delete(relayUrl);\n                  }\n                }\n                for (const relayUrl of outboxItem.writeRelays) {\n                  if (this.ndk.pool.blacklistRelayUrls.has(relayUrl)) {\n                    outboxItem.writeRelays.delete(relayUrl);\n                  }\n                }\n                this.data.set(pubkey, outboxItem);\n              }\n            }\n          }).finally(resolve);\n        })\n      );\n    }\n    return Promise.all(promises);\n  }\n  /**\n   *\n   * @param key\n   * @param score\n   */\n  track(item, type, _skipCache = true) {\n    const key = getKeyFromItem(item);\n    type ??= getTypeFromItem(item);\n    let outboxItem = this.data.get(key);\n    if (!outboxItem) {\n      outboxItem = new OutboxItem(type);\n      if (item instanceof NDKUser) {\n        this.trackUsers([item]);\n      }\n    }\n    return outboxItem;\n  }\n};\nfunction getKeyFromItem(item) {\n  if (item instanceof NDKUser) {\n    return item.pubkey;\n  }\n  return item;\n}\nfunction getTypeFromItem(item) {\n  if (item instanceof NDKUser) {\n    return \"user\";\n  }\n  return \"kind\";\n}\n\n// src/relay/sets/utils.ts\nfunction correctRelaySet(relaySet, pool) {\n  const connectedRelays = pool.connectedRelays();\n  const includesConnectedRelay = Array.from(relaySet.relays).some((relay) => {\n    return connectedRelays.map((r) => r.url).includes(relay.url);\n  });\n  if (!includesConnectedRelay) {\n    for (const relay of connectedRelays) {\n      relaySet.addRelay(relay);\n    }\n  }\n  if (connectedRelays.length === 0) {\n    for (const relay of pool.relays.values()) {\n      relaySet.addRelay(relay);\n    }\n  }\n  return relaySet;\n}\n\n// src/subscription/manager.ts\n\nvar NDKSubscriptionManager = class {\n  subscriptions;\n  seenEvents = /* @__PURE__ */ new Map();\n  constructor() {\n    this.subscriptions = /* @__PURE__ */ new Map();\n  }\n  add(sub) {\n    this.subscriptions.set(sub.internalId, sub);\n    if (sub.onStopped) {\n    }\n    sub.onStopped = () => {\n      this.subscriptions.delete(sub.internalId);\n    };\n    sub.on(\"close\", () => {\n      this.subscriptions.delete(sub.internalId);\n    });\n  }\n  seenEvent(eventId, relay) {\n    const current = this.seenEvents.get(eventId) || [];\n    current.push(relay);\n    this.seenEvents.set(eventId, current);\n  }\n  /**\n   * Whenever an event comes in, this function is called.\n   * This function matches the received event against all the\n   * known (i.e. active) NDKSubscriptions, and if it matches,\n   * it sends the event to the subscription.\n   *\n   * This is the single place in the codebase that matches\n   * incoming events with parties interested in the event.\n   *\n   * This is also what allows for reactivity in NDK apps, such that\n   * whenever an active subscription receives an event that some\n   * other active subscription would want to receive, both receive it.\n   *\n   * TODO This also allows for subscriptions that overlap in meaning\n   * to be collapsed into one.\n   *\n   * I.e. if a subscription with filter: kinds: [1], authors: [alice]\n   * is created and EOSEs, and then a subsequent subscription with\n   * kinds: [1], authors: [alice] is created, once the second subscription\n   * EOSEs we can safely close it, increment its refCount and close it,\n   * and when the first subscription receives a new event from Alice this\n   * code will make the second subscription receive the event even though\n   * it has no active subscription on a relay.\n   * @param event Raw event received from a relay\n   * @param relay Relay that sent the event\n   * @param optimisticPublish Whether the event is coming from an optimistic publish\n   */\n  dispatchEvent(event, relay, optimisticPublish = false) {\n    if (relay) this.seenEvent(event.id, relay);\n    const subscriptions = this.subscriptions.values();\n    const matchingSubs = [];\n    for (const sub of subscriptions) {\n      if ((0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.matchFilters)(sub.filters, event)) {\n        matchingSubs.push(sub);\n      }\n    }\n    for (const sub of matchingSubs) {\n      sub.eventReceived(event, relay, false, optimisticPublish);\n    }\n  }\n};\n\n// src/ndk/active-user.ts\n\nvar debug6 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:active-user\");\nasync function getUserRelayList(user) {\n  if (!this.autoConnectUserRelays) return;\n  const userRelays = await getRelayListForUser(user.pubkey, this);\n  if (!userRelays) return;\n  for (const url of userRelays.relays) {\n    let relay = this.pool.relays.get(url);\n    if (!relay) {\n      relay = new NDKRelay(url, this.relayAuthDefaultPolicy, this);\n      this.pool.addRelay(relay);\n    }\n  }\n  return userRelays;\n}\nasync function setActiveUser(user) {\n  const pool = this.outboxPool || this.pool;\n  if (pool.connectedRelays.length > 0) {\n    setActiveUserConnected.call(this, user);\n  } else {\n    pool.once(\"connect\", () => {\n      setActiveUserConnected.call(this, user);\n    });\n  }\n}\nasync function setActiveUserConnected(user) {\n  const userRelays = await getUserRelayList.call(this, user);\n  const filters = [\n    {\n      kinds: [10006 /* BlockRelayList */],\n      authors: [user.pubkey]\n    }\n  ];\n  if (this.autoFetchUserMutelist) {\n    filters[0].kinds?.push(1e4 /* MuteList */);\n  }\n  const events = /* @__PURE__ */ new Map();\n  const relaySet = userRelays ? userRelays.relaySet : void 0;\n  this.subscribe(\n    filters,\n    { subId: \"active-user-settings\", closeOnEose: true, relaySet },\n    {\n      onEvent: (event) => {\n        const prevEvent = events.get(event.kind);\n        if (prevEvent && prevEvent.created_at >= event.created_at) return;\n        events.set(event.kind, event);\n      },\n      onEose: () => {\n        for (const event of events.values()) {\n          processEvent.call(this, event);\n        }\n      }\n    }\n  );\n}\nasync function processEvent(event) {\n  if (event.kind === 10006 /* BlockRelayList */) {\n    processBlockRelayList.call(this, event);\n  } else if (event.kind === 1e4 /* MuteList */) {\n    processMuteList.call(this, event);\n  }\n}\nfunction processBlockRelayList(event) {\n  const list = lists_default.from(event);\n  for (const item of list.items) {\n    this.pool.blacklistRelayUrls.add(item[0]);\n  }\n  debug6(\"Added %d relays to relay blacklist\", list.items.length);\n}\nfunction processMuteList(muteList) {\n  const list = lists_default.from(muteList);\n  for (const item of list.items) {\n    this.mutedIds.set(item[1], item[0]);\n  }\n  debug6(\"Added %d users to mute list\", list.items.length);\n}\n\n// src/ndk/entity.ts\n\nfunction getEntity(entity) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(entity);\n    if (decoded.type === \"npub\") return npub(this, decoded.data);\n    if (decoded.type === \"nprofile\") return nprofile(this, decoded.data);\n    return decoded;\n  } catch (_e) {\n    return null;\n  }\n}\nfunction npub(ndk, pubkey) {\n  return ndk.getUser({ pubkey });\n}\nfunction nprofile(ndk, profile) {\n  const user = ndk.getUser({ pubkey: profile.pubkey });\n  if (profile.relays) user.relayUrls = profile.relays;\n  return user;\n}\n\n// src/ndk/fetch-event-from-tag.ts\nfunction isValidHint(hint) {\n  if (!hint || hint === \"\") return false;\n  try {\n    new URL(hint);\n    return true;\n  } catch (_e) {\n    return false;\n  }\n}\nasync function fetchEventFromTag(tag, originalEvent, subOpts, fallback = {\n  type: \"timeout\"\n}) {\n  const d4 = this.debug.extend(\"fetch-event-from-tag\");\n  const [_, id, hint] = tag;\n  subOpts = {};\n  d4(\"fetching event from tag\", tag, subOpts, fallback);\n  const authorRelays = getRelaysForSync(this, originalEvent.pubkey);\n  if (authorRelays && authorRelays.size > 0) {\n    d4(\"fetching event from author relays %o\", Array.from(authorRelays));\n    const relaySet2 = NDKRelaySet.fromRelayUrls(Array.from(authorRelays), this);\n    const event2 = await this.fetchEvent(id, subOpts, relaySet2);\n    if (event2) return event2;\n  } else {\n    d4(\"no author relays found for %s\", originalEvent.pubkey, originalEvent);\n  }\n  const relaySet = calculateRelaySetsFromFilters(this, [{ ids: [id] }], this.pool);\n  d4(\"fetching event without relay hint\", relaySet);\n  const event = await this.fetchEvent(id, subOpts);\n  if (event) return event;\n  if (hint && hint !== \"\") {\n    const event2 = await this.fetchEvent(id, subOpts, this.pool.getRelay(hint, true, true, [{ ids: [id] }]));\n    if (event2) return event2;\n  }\n  let result = void 0;\n  const relay = isValidHint(hint) ? this.pool.getRelay(hint, false, true, [{ ids: [id] }]) : void 0;\n  const fetchMaybeWithRelayHint = new Promise((resolve) => {\n    this.fetchEvent(id, subOpts, relay).then(resolve);\n  });\n  if (!isValidHint(hint) || fallback.type === \"none\") {\n    return fetchMaybeWithRelayHint;\n  }\n  const fallbackFetchPromise = new Promise(async (resolve) => {\n    const fallbackRelaySet = fallback.relaySet;\n    const timeout = fallback.timeout ?? 1500;\n    const timeoutPromise = new Promise((resolve2) => setTimeout(resolve2, timeout));\n    if (fallback.type === \"timeout\") await timeoutPromise;\n    if (result) {\n      resolve(result);\n    } else {\n      d4(\"fallback fetch triggered\");\n      const fallbackEvent = await this.fetchEvent(id, subOpts, fallbackRelaySet);\n      resolve(fallbackEvent);\n    }\n  });\n  switch (fallback.type) {\n    case \"timeout\":\n      return Promise.race([fetchMaybeWithRelayHint, fallbackFetchPromise]);\n    case \"eose\":\n      result = await fetchMaybeWithRelayHint;\n      if (result) return result;\n      return fallbackFetchPromise;\n  }\n}\n\n// src/ndk/queue/index.ts\nvar Queue = class {\n  queue = [];\n  maxConcurrency;\n  processing = /* @__PURE__ */ new Set();\n  promises = /* @__PURE__ */ new Map();\n  constructor(_name, maxConcurrency) {\n    this.maxConcurrency = maxConcurrency;\n  }\n  add(item) {\n    if (this.promises.has(item.id)) {\n      return this.promises.get(item.id);\n    }\n    const promise = new Promise((resolve, reject) => {\n      this.queue.push({\n        ...item,\n        func: () => item.func().then(\n          (result) => {\n            resolve(result);\n            return result;\n          },\n          (error) => {\n            reject(error);\n            throw error;\n          }\n        )\n      });\n      this.process();\n    });\n    this.promises.set(item.id, promise);\n    promise.finally(() => {\n      this.promises.delete(item.id);\n      this.processing.delete(item.id);\n      this.process();\n    });\n    return promise;\n  }\n  process() {\n    if (this.processing.size >= this.maxConcurrency || this.queue.length === 0) {\n      return;\n    }\n    const item = this.queue.shift();\n    if (!item || this.processing.has(item.id)) {\n      return;\n    }\n    this.processing.add(item.id);\n    item.func();\n  }\n  clear() {\n    this.queue = [];\n  }\n  clearProcessing() {\n    this.processing.clear();\n  }\n  clearAll() {\n    this.clear();\n    this.clearProcessing();\n  }\n  length() {\n    return this.queue.length;\n  }\n};\n\n// src/ndk/index.ts\nvar DEFAULT_OUTBOX_RELAYS = [\"wss://purplepag.es/\", \"wss://nos.lol/\"];\nvar DEFAULT_BLACKLISTED_RELAYS = [\n  \"wss://brb.io/\",\n  // BRB\n  \"wss://nostr.mutinywallet.com/\"\n  // Don't try to read from this relay since it's a write-only relay\n  // \"wss://purplepag.es/\", // This is a hack, since this is a mostly read-only relay, but not fully. Once we have relay routing this can be removed so it only receives the supported kinds\n];\nvar NDK = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  _explicitRelayUrls;\n  blacklistRelayUrls;\n  pool;\n  outboxPool;\n  _signer;\n  _activeUser;\n  cacheAdapter;\n  debug;\n  devWriteRelaySet;\n  outboxTracker;\n  mutedIds;\n  clientName;\n  clientNip89;\n  queuesZapConfig;\n  queuesNip05;\n  asyncSigVerification = false;\n  initialValidationRatio = 1;\n  lowestValidationRatio = 1;\n  validationRatioFn;\n  subManager;\n  publishingFailureHandled = false;\n  pools = [];\n  /**\n   * Default relay-auth policy that will be used when a relay requests authentication,\n   * if no other policy is specified for that relay.\n   *\n   * @example Disconnect from relays that request authentication:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.disconnect(ndk.pool);\n   * ```\n   *\n   * @example Sign in to relays that request authentication:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.signIn({ndk})\n   * ```\n   *\n   * @example Sign in to relays that request authentication, asking the user for confirmation:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = (relay: NDKRelay) => {\n   *     const signIn = NDKAuthPolicies.signIn({ndk});\n   *     if (confirm(`Relay ${relay.url} is requesting authentication, do you want to sign in?`)) {\n   *        signIn(relay);\n   *     }\n   * }\n   * ```\n   */\n  relayAuthDefaultPolicy;\n  /**\n   * Fetch function to use for HTTP requests.\n   *\n   * @example\n   * ```typescript\n   * import fetch from \"node-fetch\";\n   *\n   * ndk.httpFetch = fetch;\n   * ```\n   */\n  httpFetch;\n  /**\n   * Provide a caller function to receive all networking traffic from relays\n   */\n  netDebug;\n  autoConnectUserRelays = true;\n  autoFetchUserMutelist = true;\n  walletConfig;\n  constructor(opts = {}) {\n    super();\n    this.debug = opts.debug || debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk\");\n    this.netDebug = opts.netDebug;\n    this._explicitRelayUrls = opts.explicitRelayUrls || [];\n    this.blacklistRelayUrls = opts.blacklistRelayUrls || DEFAULT_BLACKLISTED_RELAYS;\n    this.subManager = new NDKSubscriptionManager();\n    this.pool = new NDKPool(opts.explicitRelayUrls || [], [], this);\n    this.pool.name = \"Main\";\n    this.pool.on(\"relay:auth\", async (relay, challenge) => {\n      if (this.relayAuthDefaultPolicy) {\n        await this.relayAuthDefaultPolicy(relay, challenge);\n      }\n    });\n    this.autoConnectUserRelays = opts.autoConnectUserRelays ?? true;\n    this.autoFetchUserMutelist = opts.autoFetchUserMutelist ?? true;\n    this.clientName = opts.clientName;\n    this.clientNip89 = opts.clientNip89;\n    this.relayAuthDefaultPolicy = opts.relayAuthDefaultPolicy;\n    if (opts.enableOutboxModel) {\n      this.outboxPool = new NDKPool(opts.outboxRelayUrls || DEFAULT_OUTBOX_RELAYS, [], this, {\n        debug: this.debug.extend(\"outbox-pool\"),\n        name: \"Outbox Pool\"\n      });\n      this.outboxTracker = new OutboxTracker(this);\n    }\n    this.signer = opts.signer;\n    this.cacheAdapter = opts.cacheAdapter;\n    this.mutedIds = opts.mutedIds || /* @__PURE__ */ new Map();\n    if (opts.devWriteRelayUrls) {\n      this.devWriteRelaySet = NDKRelaySet.fromRelayUrls(opts.devWriteRelayUrls, this);\n    }\n    this.queuesZapConfig = new Queue(\"zaps\", 3);\n    this.queuesNip05 = new Queue(\"nip05\", 10);\n    this.signatureVerificationWorker = opts.signatureVerificationWorker;\n    this.initialValidationRatio = opts.initialValidationRatio || 1;\n    this.lowestValidationRatio = opts.lowestValidationRatio || 1;\n    try {\n      this.httpFetch = fetch;\n    } catch {\n    }\n  }\n  set explicitRelayUrls(urls) {\n    this._explicitRelayUrls = urls.map(normalizeRelayUrl);\n    this.pool.relayUrls = urls;\n  }\n  get explicitRelayUrls() {\n    return this._explicitRelayUrls || [];\n  }\n  set signatureVerificationWorker(worker2) {\n    this.asyncSigVerification = !!worker2;\n    if (worker2) {\n      signatureVerificationInit(worker2);\n    }\n  }\n  /**\n   * Adds an explicit relay to the pool.\n   * @param url\n   * @param relayAuthPolicy Authentication policy to use if different from the default\n   * @param connect Whether to connect to the relay automatically\n   * @returns\n   */\n  addExplicitRelay(urlOrRelay, relayAuthPolicy, connect = true) {\n    let relay;\n    if (typeof urlOrRelay === \"string\") {\n      relay = new NDKRelay(urlOrRelay, relayAuthPolicy, this);\n    } else {\n      relay = urlOrRelay;\n    }\n    this.pool.addRelay(relay, connect);\n    this.explicitRelayUrls?.push(relay.url);\n    return relay;\n  }\n  toJSON() {\n    return { relayCount: this.pool.relays.size }.toString();\n  }\n  get activeUser() {\n    return this._activeUser;\n  }\n  /**\n   * Sets the active user for this NDK instance, typically this will be\n   * called when assigning a signer to the NDK instance.\n   *\n   * This function will automatically connect to the user's relays if\n   * `autoConnectUserRelays` is set to true.\n   *\n   * It will also fetch the user's mutelist if `autoFetchUserMutelist` is set to true.\n   */\n  set activeUser(user) {\n    const differentUser = this._activeUser?.pubkey !== user?.pubkey;\n    this._activeUser = user;\n    if (user && differentUser) {\n      setActiveUser.call(this, user);\n    } else if (!user) {\n      this.mutedIds = /* @__PURE__ */ new Map();\n    }\n  }\n  get signer() {\n    return this._signer;\n  }\n  set signer(newSigner) {\n    this._signer = newSigner;\n    if (newSigner) this.emit(\"signer:ready\", newSigner);\n    newSigner?.user().then((user) => {\n      user.ndk = this;\n      this.activeUser = user;\n    });\n  }\n  /**\n   * Connect to relays with optional timeout.\n   * If the timeout is reached, the connection will be continued to be established in the background.\n   */\n  async connect(timeoutMs) {\n    if (this._signer && this.autoConnectUserRelays) {\n      this.debug(\n        \"Attempting to connect to user relays specified by signer %o\",\n        await this._signer.relays?.(this)\n      );\n      if (this._signer.relays) {\n        const relays = await this._signer.relays(this);\n        relays.forEach((relay) => this.pool.addRelay(relay));\n      }\n    }\n    const connections = [this.pool.connect(timeoutMs)];\n    if (this.outboxPool) {\n      connections.push(this.outboxPool.connect(timeoutMs));\n    }\n    this.debug(\"Connecting to relays %o\", { timeoutMs });\n    return Promise.allSettled(connections).then(() => {\n    });\n  }\n  /**\n   * Get a NDKUser object\n   *\n   * @param opts\n   * @returns\n   */\n  getUser(opts) {\n    const user = new NDKUser(opts);\n    user.ndk = this;\n    return user;\n  }\n  /**\n   * Get a NDKUser from a NIP05\n   * @param nip05 NIP-05 ID\n   * @param skipCache Skip cache\n   * @returns\n   */\n  async getUserFromNip05(nip05, skipCache = false) {\n    return NDKUser.fromNip05(nip05, this, skipCache);\n  }\n  /**\n   * Creates and starts a new subscription.\n   *\n   * Subscriptions automatically start unless `autoStart` is set to `false`.\n   * You can control automatic closing on EOSE via `opts.closeOnEose`.\n   *\n   * @param filters - A single NDKFilter object or an array of filters.\n   * @param opts - Optional NDKSubscriptionOptions to customize behavior (e.g., caching, grouping).\n   * @param handlers - Optional handlers for subscription events. Passing handlers is the preferred method of using ndk.subscribe.\n   *   - `onEvent`: Called for each event received.\n   *  - `onEvents`: Called once with an array of events when the subscription starts (from the cache).\n   *  - `onEose`: Called when the subscription receives EOSE.\n   *  For backwards compatibility, this third parameter also accepts a relaySet, the relaySet should be passed via `opts.relaySet`.\n   *\n   * @param _autoStart - For backwards compatibility, this can be a boolean indicating whether to start the subscription immediately.\n   *  This parameter is deprecated and will be removed in a future version.\n   *   - `false`: Creates the subscription but does not start it (call `subscription.start()` manually).\n   * @returns The created NDKSubscription instance.\n   *\n   * @example Basic subscription\n   * ```typescript\n   * const sub = ndk.subscribe({ kinds: [1], authors: [pubkey] });\n   * sub.on(\"event\", (event) => console.log(\"Kind 1 event:\", event.content));\n   * ```\n   *\n   * @example Subscription with options and direct handlers\n   * ```typescript\n   * const sub = ndk.subscribe(\n   *   { kinds: [0], authors: [pubkey] },\n   *   { closeOnEose: true, cacheUsage: NDKSubscriptionCacheUsage.PARALLEL },\n   *   undefined, // Use default relay set calculation\n   *   {\n   *     onEvents: (events) => { // Renamed parameter\n   *       if (events.length > 0) {\n   *         console.log(`Got ${events.length} profile events from cache:`, events[0].content);\n   *       }\n   *     },\n   *     onEvent: (event) => { // Renamed parameter\n   *       console.log(\"Got profile update from relay:\", event.content); // Clarified source\n   *     },\n   *     onEose: () => console.log(\"Profile subscription finished.\")\n   *   }\n   * );\n   * ```\n   *\n   * @since 2.13.0 `relaySet` parameter removed; pass `relaySet` or `relayUrls` via `opts`.\n   */\n  subscribe(filters, opts, autoStartOrRelaySet = true, _autoStart = true) {\n    let _relaySet = opts?.relaySet;\n    let autoStart = _autoStart;\n    if (autoStartOrRelaySet instanceof NDKRelaySet) {\n      console.warn(\"relaySet is deprecated, use opts.relaySet instead. This will be removed in version v2.14.0\");\n      _relaySet = autoStartOrRelaySet;\n      autoStart = _autoStart;\n    } else if (typeof autoStartOrRelaySet === \"boolean\" || typeof autoStartOrRelaySet === \"object\") {\n      autoStart = autoStartOrRelaySet;\n    }\n    const subscription = new NDKSubscription(this, filters, { relaySet: _relaySet, ...opts });\n    this.subManager.add(subscription);\n    const pool = subscription.pool;\n    if (subscription.relaySet) {\n      for (const relay of subscription.relaySet.relays) {\n        pool.useTemporaryRelay(relay, void 0, subscription.filters);\n      }\n    }\n    if (this.outboxPool && subscription.hasAuthorsFilter()) {\n      const authors = subscription.filters.filter((filter) => filter.authors && filter.authors?.length > 0).flatMap((filter) => filter.authors);\n      this.outboxTracker?.trackUsers(authors);\n    }\n    if (autoStart) {\n      let eventsHandler;\n      if (typeof autoStart === \"object\") {\n        if (autoStart.onEvent) subscription.on(\"event\", autoStart.onEvent);\n        if (autoStart.onEose) subscription.on(\"eose\", autoStart.onEose);\n        if (autoStart.onEvents) eventsHandler = autoStart.onEvents;\n      }\n      setTimeout(() => {\n        const cachedEvents = subscription.start(!eventsHandler);\n        if (cachedEvents && cachedEvents.length > 0 && !!eventsHandler) eventsHandler(cachedEvents);\n      }, 0);\n    }\n    return subscription;\n  }\n  /**\n   * Publish an event to a relay\n   * @param event event to publish\n   * @param relaySet explicit relay set to use\n   * @param timeoutMs timeout in milliseconds to wait for the event to be published\n   * @returns The relays the event was published to\n   *\n   * @deprecated Use `event.publish()` instead\n   */\n  async publish(event, relaySet, timeoutMs) {\n    this.debug(\"Deprecated: Use `event.publish()` instead\");\n    return event.publish(relaySet, timeoutMs);\n  }\n  /**\n   * Attempts to fetch an event from a tag, following relay hints and\n   * other best practices.\n   * @param tag Tag to fetch the event from\n   * @param originalEvent Event where the tag came from\n   * @param subOpts Subscription options to use when fetching the event\n   * @param fallback Fallback options to use when the hint relay doesn't respond\n   * @returns\n   */\n  fetchEventFromTag = fetchEventFromTag.bind(this);\n  /**\n   * Fetch an event from the cache synchronously.\n   * @param idOrFilter event id in bech32 format or filter\n   * @returns events from the cache or null if the cache is empty\n   */\n  fetchEventSync(idOrFilter) {\n    if (!this.cacheAdapter) throw new Error(\"Cache adapter not set\");\n    let filters;\n    if (typeof idOrFilter === \"string\") filters = [filterFromId(idOrFilter)];\n    else filters = idOrFilter;\n    const sub = new NDKSubscription(this, filters);\n    const events = this.cacheAdapter.query(sub);\n    if (events instanceof Promise) throw new Error(\"Cache adapter is async\");\n    return events.map((e) => {\n      e.ndk = this;\n      return e;\n    });\n  }\n  /**\n   * Fetch a single event.\n   *\n   * @param idOrFilter event id in bech32 format or filter\n   * @param opts subscription options\n   * @param relaySetOrRelay explicit relay set to use\n   */\n  async fetchEvent(idOrFilter, opts, relaySetOrRelay) {\n    let filters;\n    let relaySet;\n    if (relaySetOrRelay instanceof NDKRelay) {\n      relaySet = new NDKRelaySet(/* @__PURE__ */ new Set([relaySetOrRelay]), this);\n    } else if (relaySetOrRelay instanceof NDKRelaySet) {\n      relaySet = relaySetOrRelay;\n    }\n    if (!relaySetOrRelay && typeof idOrFilter === \"string\") {\n      if (!isNip33AValue(idOrFilter)) {\n        const relays = relaysFromBech32(idOrFilter, this);\n        if (relays.length > 0) {\n          relaySet = new NDKRelaySet(new Set(relays), this);\n          relaySet = correctRelaySet(relaySet, this.pool);\n        }\n      }\n    }\n    if (typeof idOrFilter === \"string\") {\n      filters = [filterFromId(idOrFilter)];\n    } else if (Array.isArray(idOrFilter)) {\n      filters = idOrFilter;\n    } else {\n      filters = [idOrFilter];\n    }\n    if (filters.length === 0) {\n      throw new Error(`Invalid filter: ${JSON.stringify(idOrFilter)}`);\n    }\n    return new Promise((resolve) => {\n      let fetchedEvent = null;\n      const subscribeOpts = {\n        ...opts || {},\n        closeOnEose: true\n      };\n      if (relaySet) subscribeOpts.relaySet = relaySet;\n      const s = this.subscribe(\n        filters,\n        subscribeOpts,\n        // relaySet, // Removed: Passed via opts\n        false\n        // autoStart = false\n      );\n      const t2 = setTimeout(() => {\n        s.stop();\n        resolve(fetchedEvent);\n      }, 1e4);\n      s.on(\"event\", (event) => {\n        event.ndk = this;\n        if (!event.isReplaceable()) {\n          clearTimeout(t2);\n          resolve(event);\n        } else if (!fetchedEvent || fetchedEvent.created_at < event.created_at) {\n          fetchedEvent = event;\n        }\n      });\n      s.on(\"eose\", () => {\n        clearTimeout(t2);\n        resolve(fetchedEvent);\n      });\n      s.start();\n    });\n  }\n  /**\n   * Fetch events\n   */\n  async fetchEvents(filters, opts, relaySet) {\n    return new Promise((resolve) => {\n      const events = /* @__PURE__ */ new Map();\n      const subscribeOpts = {\n        ...opts || {},\n        closeOnEose: true\n      };\n      if (relaySet) subscribeOpts.relaySet = relaySet;\n      const relaySetSubscription = this.subscribe(\n        filters,\n        subscribeOpts,\n        // relaySet, // Removed: Passed via opts\n        false\n        // autoStart = false\n      );\n      const onEvent = (event) => {\n        let _event;\n        if (!(event instanceof NDKEvent)) _event = new NDKEvent(void 0, event);\n        else _event = event;\n        const dedupKey = _event.deduplicationKey();\n        const existingEvent = events.get(dedupKey);\n        if (existingEvent) {\n          _event = dedup(existingEvent, _event);\n        }\n        _event.ndk = this;\n        events.set(dedupKey, _event);\n      };\n      relaySetSubscription.on(\"event\", onEvent);\n      relaySetSubscription.on(\"eose\", () => {\n        resolve(new Set(events.values()));\n      });\n      relaySetSubscription.start();\n    });\n  }\n  /**\n   * Ensures that a signer is available to sign an event.\n   */\n  assertSigner() {\n    if (!this.signer) {\n      this.emit(\"signer:required\");\n      throw new Error(\"Signer required\");\n    }\n  }\n  getEntity = getEntity.bind(this);\n  set wallet(wallet) {\n    if (!wallet) {\n      this.walletConfig = void 0;\n      return;\n    }\n    this.walletConfig ??= {};\n    this.walletConfig.lnPay = wallet?.lnPay?.bind(wallet);\n    this.walletConfig.cashuPay = wallet?.cashuPay?.bind(wallet);\n  }\n};\n\n// src/zap/invoice.ts\n\nfunction zapInvoiceFromEvent(event) {\n  const description = event.getMatchingTags(\"description\")[0];\n  const bolt11 = event.getMatchingTags(\"bolt11\")[0];\n  let decodedInvoice;\n  let zapRequest;\n  if (!description || !bolt11 || !bolt11[1]) {\n    return null;\n  }\n  try {\n    let zapRequestPayload = description[1];\n    if (zapRequestPayload.startsWith(\"%\")) {\n      zapRequestPayload = decodeURIComponent(zapRequestPayload);\n    }\n    if (zapRequestPayload === \"\") {\n      return null;\n    }\n    zapRequest = JSON.parse(zapRequestPayload);\n    decodedInvoice = (0,light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_7__.decode)(bolt11[1]);\n  } catch (_e) {\n    return null;\n  }\n  const amountSection = decodedInvoice.sections.find((s) => s.name === \"amount\");\n  if (!amountSection) {\n    return null;\n  }\n  const amount = Number.parseInt(amountSection.value);\n  if (!amount) {\n    return null;\n  }\n  const content = zapRequest.content;\n  const sender = zapRequest.pubkey;\n  const recipientTag = event.getMatchingTags(\"p\")[0];\n  const recipient = recipientTag[1];\n  let zappedEvent = event.getMatchingTags(\"e\")[0];\n  if (!zappedEvent) {\n    zappedEvent = event.getMatchingTags(\"a\")[0];\n  }\n  const zappedEventId = zappedEvent ? zappedEvent[1] : void 0;\n  const zapInvoice = {\n    id: event.id,\n    zapper: event.pubkey,\n    zappee: sender,\n    zapped: recipient,\n    zappedEvent: zappedEventId,\n    amount,\n    comment: content\n  };\n  return zapInvoice;\n}\n\n// src/zapper/index.ts\n\n\n\n// src/zapper/ln.ts\n\n\nvar d2 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:zapper:ln\");\nasync function getNip57ZapSpecFromLud({ lud06, lud16 }, ndk) {\n  let zapEndpoint;\n  if (lud16 && !lud16.startsWith(\"LNURL\")) {\n    const [name, domain] = lud16.split(\"@\");\n    zapEndpoint = `https://${domain}/.well-known/lnurlp/${name}`;\n  } else if (lud06) {\n    const { words } = _scure_base__WEBPACK_IMPORTED_MODULE_8__.bech32.decode(lud06, 1e3);\n    const data = _scure_base__WEBPACK_IMPORTED_MODULE_8__.bech32.fromWords(words);\n    const utf8Decoder = new TextDecoder(\"utf-8\");\n    zapEndpoint = utf8Decoder.decode(data);\n  }\n  if (!zapEndpoint) {\n    d2(\"No zap endpoint found %o\", { lud06, lud16 });\n    throw new Error(\"No zap endpoint found\");\n  }\n  try {\n    const _fetch = ndk.httpFetch || fetch;\n    const response = await _fetch(zapEndpoint);\n    if (response.status !== 200) {\n      const text = await response.text();\n      throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${text}`);\n    }\n    return await response.json();\n  } catch (e) {\n    throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${e}`);\n  }\n}\n\n// src/zapper/nip57.ts\n\nasync function generateZapRequest(target, ndk, data, pubkey, amount, relays, comment, tags, signer) {\n  const zapEndpoint = data.callback;\n  const zapRequest = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip57.makeZapRequest({\n    profile: pubkey,\n    // set the event to null since nostr-tools doesn't support nip-33 zaps\n    event: null,\n    amount,\n    comment: comment || \"\",\n    relays: relays.slice(0, 4)\n  });\n  if (target instanceof NDKEvent) {\n    const tags2 = target.referenceTags();\n    const nonPTags = tags2.filter((tag) => tag[0] !== \"p\");\n    zapRequest.tags.push(...nonPTags);\n  }\n  zapRequest.tags.push([\"lnurl\", zapEndpoint]);\n  const event = new NDKEvent(ndk, zapRequest);\n  if (tags) {\n    event.tags = event.tags.concat(tags);\n  }\n  const eTaggedEvents = /* @__PURE__ */ new Set();\n  const aTaggedEvents = /* @__PURE__ */ new Set();\n  for (const tag of event.tags) {\n    if (tag[0] === \"e\") {\n      eTaggedEvents.add(tag[1]);\n    } else if (tag[0] === \"a\") {\n      aTaggedEvents.add(tag[1]);\n    }\n  }\n  if (eTaggedEvents.size > 1) throw new Error(\"Only one e-tag is allowed\");\n  if (aTaggedEvents.size > 1) throw new Error(\"Only one a-tag is allowed\");\n  event.tags = event.tags.filter((tag) => tag[0] !== \"p\");\n  event.tags.push([\"p\", pubkey]);\n  await event.sign(signer);\n  return event;\n}\n\n// src/zapper/index.ts\nvar d3 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:zapper\");\nvar NDKZapper = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  target;\n  ndk;\n  comment;\n  amount;\n  unit;\n  tags;\n  signer;\n  zapMethod;\n  nutzapAsFallback;\n  lnPay;\n  /**\n   * Called when a cashu payment is to be made.\n   * This function should swap/mint proofs for the required amount, in the required unit,\n   * in any of the provided mints and return the proofs and mint used.\n   */\n  cashuPay;\n  onComplete;\n  maxRelays = 3;\n  /**\n   *\n   * @param target The target of the zap\n   * @param amount The amount to send indicated in the unit\n   * @param unit The unit of the amount\n   * @param opts Options for the zap\n   */\n  constructor(target, amount, unit = \"msat\", opts = {}) {\n    super();\n    this.target = target;\n    this.ndk = opts.ndk || target.ndk;\n    if (!this.ndk) {\n      throw new Error(\"No NDK instance provided\");\n    }\n    this.amount = amount;\n    this.comment = opts.comment;\n    this.unit = unit;\n    this.tags = opts.tags;\n    this.signer = opts.signer;\n    this.nutzapAsFallback = opts.nutzapAsFallback ?? false;\n    this.lnPay = opts.lnPay || this.ndk.walletConfig?.lnPay;\n    this.cashuPay = opts.cashuPay || this.ndk.walletConfig?.cashuPay;\n    this.onComplete = opts.onComplete || this.ndk.walletConfig?.onPaymentComplete;\n  }\n  /**\n   * Initiate zapping process\n   *\n   * This function will calculate the splits for this zap and initiate each zap split.\n   */\n  async zap(methods) {\n    const splits = this.getZapSplits();\n    const results = /* @__PURE__ */ new Map();\n    await Promise.all(\n      splits.map(async (split) => {\n        let result;\n        try {\n          result = await this.zapSplit(split, methods);\n        } catch (e) {\n          result = new Error(e.message);\n        }\n        this.emit(\"split:complete\", split, result);\n        results.set(split, result);\n      })\n    );\n    this.emit(\"complete\", results);\n    if (this.onComplete) this.onComplete(results);\n    return results;\n  }\n  async zapNip57(split, data) {\n    if (!this.lnPay) throw new Error(\"No lnPay function available\");\n    const zapSpec = await getNip57ZapSpecFromLud(data, this.ndk);\n    if (!zapSpec) throw new Error(\"No zap spec available for recipient\");\n    const relays = await this.relays(split.pubkey);\n    const zapRequest = await generateZapRequest(\n      this.target,\n      this.ndk,\n      zapSpec,\n      split.pubkey,\n      split.amount,\n      relays,\n      this.comment,\n      this.tags,\n      this.signer\n    );\n    if (!zapRequest) {\n      d3(\"Unable to generate zap request\");\n      throw new Error(\"Unable to generate zap request\");\n    }\n    const pr = await this.getLnInvoice(zapRequest, split.amount, zapSpec);\n    if (!pr) {\n      d3(\"Unable to get payment request\");\n      throw new Error(\"Unable to get payment request\");\n    }\n    this.emit(\"ln_invoice\", {\n      amount: split.amount,\n      recipientPubkey: split.pubkey,\n      unit: this.unit,\n      nip57ZapRequest: zapRequest,\n      pr,\n      type: \"nip57\"\n    });\n    const res = await this.lnPay({\n      target: this.target,\n      recipientPubkey: split.pubkey,\n      paymentDescription: \"NIP-57 Zap\",\n      pr,\n      amount: split.amount,\n      unit: this.unit,\n      nip57ZapRequest: zapRequest\n    });\n    if (res?.preimage) {\n      this.emit(\"ln_payment\", {\n        preimage: res.preimage,\n        amount: split.amount,\n        recipientPubkey: split.pubkey,\n        pr,\n        unit: this.unit,\n        nip57ZapRequest: zapRequest,\n        type: \"nip57\"\n      });\n    }\n    return res;\n  }\n  /**\n   * Fetches information about a NIP-61 zap and asks the caller to create cashu proofs for the zap.\n   *\n   * (note that the cashuPay function can use any method to create the proofs, including using lightning\n   * to mint proofs in the specified mint, the responsibility of minting the proofs is delegated to the caller (e.g. ndk-wallet))\n   */\n  async zapNip61(split, data) {\n    if (!this.cashuPay) throw new Error(\"No cashuPay function available\");\n    let ret;\n    ret = await this.cashuPay(\n      {\n        target: this.target,\n        recipientPubkey: split.pubkey,\n        paymentDescription: \"NIP-61 Zap\",\n        amount: split.amount,\n        unit: this.unit,\n        ...data ?? {}\n      },\n      (pr) => {\n        this.emit(\"ln_invoice\", {\n          pr,\n          amount: split.amount,\n          recipientPubkey: split.pubkey,\n          unit: this.unit,\n          type: \"nip61\"\n        });\n      }\n    );\n    d3(\"NIP-61 Zap result: %o\", ret);\n    if (ret instanceof Error) {\n      return ret;\n    }\n    if (ret) {\n      const { proofs, mint } = ret;\n      if (!proofs || !mint) throw new Error(`Invalid zap confirmation: missing proofs or mint: ${ret}`);\n      const relays = await this.relays(split.pubkey);\n      const relaySet = NDKRelaySet.fromRelayUrls(relays, this.ndk);\n      const nutzap = new NDKNutzap(this.ndk);\n      nutzap.tags = [...nutzap.tags, ...this.tags || []];\n      nutzap.proofs = proofs;\n      nutzap.mint = mint;\n      nutzap.target = this.target;\n      nutzap.comment = this.comment;\n      nutzap.unit = \"sat\";\n      nutzap.recipientPubkey = split.pubkey;\n      await nutzap.sign(this.signer);\n      nutzap.publish(relaySet);\n      return nutzap;\n    }\n  }\n  /**\n   * Get the zap methods available for the recipient and initiates the zap\n   * in the desired method.\n   * @param split\n   * @param methods - The methods to try, if not provided, all methods will be tried.\n   * @returns\n   */\n  async zapSplit(split, methods) {\n    const recipient = this.ndk.getUser({ pubkey: split.pubkey });\n    const zapMethods = await recipient.getZapInfo(2500);\n    let retVal;\n    const canFallbackToNip61 = this.nutzapAsFallback && this.cashuPay;\n    if (zapMethods.size === 0 && !canFallbackToNip61)\n      throw new Error(\"No zap method available for recipient and NIP-61 fallback is disabled\");\n    const nip61Fallback = async () => {\n      if (!this.nutzapAsFallback) return;\n      const relayLists = await getRelayListForUsers([split.pubkey], this.ndk);\n      let relayUrls = relayLists.get(split.pubkey)?.readRelayUrls;\n      relayUrls = this.ndk.pool.connectedRelays().map((r) => r.url);\n      return await this.zapNip61(split, {\n        // use the user's relay list\n        relays: relayUrls,\n        // lock to the user's actual pubkey\n        p2pk: split.pubkey,\n        // allow intramint fallback\n        allowIntramintFallback: !!canFallbackToNip61\n      });\n    };\n    const canUseNip61 = !methods || methods.includes(\"nip61\");\n    const canUseNip57 = !methods || methods.includes(\"nip57\");\n    const nip61Method = zapMethods.get(\"nip61\");\n    if (nip61Method && canUseNip61) {\n      try {\n        retVal = await this.zapNip61(split, nip61Method);\n        if (retVal instanceof NDKNutzap) return retVal;\n      } catch (e) {\n        this.emit(\"notice\", `NIP-61 attempt failed: ${e.message}`);\n      }\n    }\n    const nip57Method = zapMethods.get(\"nip57\");\n    if (nip57Method && canUseNip57) {\n      try {\n        retVal = await this.zapNip57(split, nip57Method);\n        if (!(retVal instanceof Error)) return retVal;\n      } catch (e) {\n        this.emit(\"notice\", `NIP-57 attempt failed: ${e.message}`);\n      }\n    }\n    if (canFallbackToNip61) {\n      retVal = await nip61Fallback();\n      if (retVal instanceof Error) throw retVal;\n      return retVal;\n    }\n    this.emit(\"notice\", \"Zap methods exhausted and there was no fallback to NIP-61\");\n    if (retVal instanceof Error) throw retVal;\n    return retVal;\n  }\n  /**\n   * Gets a bolt11 for a nip57 zap\n   * @param event\n   * @param amount\n   * @param zapEndpoint\n   * @returns\n   */\n  async getLnInvoice(zapRequest, amount, data) {\n    const zapEndpoint = data.callback;\n    const eventPayload = JSON.stringify(zapRequest.rawEvent());\n    d3(\n      `Fetching invoice from ${zapEndpoint}?${new URLSearchParams({\n        amount: amount.toString(),\n        nostr: eventPayload\n      })}`\n    );\n    const url = new URL(zapEndpoint);\n    url.searchParams.append(\"amount\", amount.toString());\n    url.searchParams.append(\"nostr\", eventPayload);\n    d3(`Fetching invoice from ${url.toString()}`);\n    const response = await fetch(url.toString());\n    d3(`Got response from zap endpoint: ${zapEndpoint}`, { status: response.status });\n    if (response.status !== 200) {\n      d3(`Received non-200 status from zap endpoint: ${zapEndpoint}`, {\n        status: response.status,\n        amount,\n        nostr: eventPayload\n      });\n      const text = await response.text();\n      throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${text}`);\n    }\n    const body = await response.json();\n    return body.pr;\n  }\n  getZapSplits() {\n    if (this.target instanceof NDKUser) {\n      return [\n        {\n          pubkey: this.target.pubkey,\n          amount: this.amount\n        }\n      ];\n    }\n    const zapTags = this.target.getMatchingTags(\"zap\");\n    if (zapTags.length === 0) {\n      return [\n        {\n          pubkey: this.target.pubkey,\n          amount: this.amount\n        }\n      ];\n    }\n    const splits = [];\n    const total = zapTags.reduce((acc, tag) => acc + Number.parseInt(tag[2]), 0);\n    for (const tag of zapTags) {\n      const pubkey = tag[1];\n      const amount = Math.floor(Number.parseInt(tag[2]) / total * this.amount);\n      splits.push({ pubkey, amount });\n    }\n    return splits;\n  }\n  /**\n   * Gets the zap method that should be used to zap a pubbkey\n   * @param ndk\n   * @param pubkey\n   * @returns\n   */\n  async getZapMethods(ndk, recipient, timeout = 2500) {\n    const user = ndk.getUser({ pubkey: recipient });\n    return await user.getZapInfo(timeout);\n  }\n  /**\n   * @returns the relays to use for the zap request\n   */\n  async relays(pubkey) {\n    let r = [];\n    if (this.ndk?.activeUser) {\n      const relayLists = await getRelayListForUsers([this.ndk.activeUser.pubkey, pubkey], this.ndk);\n      const relayScores = /* @__PURE__ */ new Map();\n      for (const relayList of relayLists.values()) {\n        for (const url of relayList.readRelayUrls) {\n          const score = relayScores.get(url) || 0;\n          relayScores.set(url, score + 1);\n        }\n      }\n      r = Array.from(relayScores.entries()).sort((a, b) => b[1] - a[1]).map(([url]) => url).slice(0, this.maxRelays);\n    }\n    if (this.ndk?.pool?.permanentAndConnectedRelays().length) {\n      r = this.ndk.pool.permanentAndConnectedRelays().map((relay) => relay.url);\n    }\n    if (!r.length) {\n      r = [];\n    }\n    return r;\n  }\n};\n\n// src/utils/filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    return false;\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {\n    return false;\n  }\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    return false;\n  }\n  for (const f in filter) {\n    if (f[0] === \"#\") {\n      const tagName = f.slice(1);\n      if (tagName === \"t\") {\n        const values = filter[`#${tagName}`]?.map((v) => v.toLowerCase());\n        if (values && !event.tags.find(([t, v]) => t === tagName && values?.indexOf(v.toLowerCase()) !== -1))\n          return false;\n      } else {\n        const values = filter[`#${tagName}`];\n        if (values && !event.tags.find(([t, v]) => t === tagName && values?.indexOf(v) !== -1)) return false;\n      }\n    }\n  }\n  if (filter.since && event.created_at < filter.since) return false;\n  if (filter.until && event.created_at > filter.until) return false;\n  return true;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLXdhbGxldC9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUI7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGVBQWU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNzRDs7QUFFdEQ7QUFDZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVc7QUFDWDtBQUNBLGdFQUFnRSx5QkFBeUIsSUFBSTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxVQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRSwyQkFBMkI7QUFDOUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJLEVBQUUsWUFBWSxNQUFNLE9BQU87QUFDN0MsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJCQUEyQixHQUFHLEdBQUcsOEJBQThCLEVBQUUsV0FBVyxLQUFLLE9BQU87QUFDekc7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdCQUF3QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxHQUFHO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEdBQUc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSyxhQUFhLEtBQUs7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMwQjtBQUNXOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxLQUFLO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUNBQXlDLGtCQUFrQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQkFBa0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsR0FBRztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLCtDQUErQyxrQkFBa0IsSUFBSSxjQUFjO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMERBQTBELG1CQUFtQixFQUFFLFVBQVU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx1QkFBdUIsMkNBQTJDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjtBQUN2Qix1Q0FBdUMsK0NBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0NBQUssY0FBYyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVLElBQUksSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHVGQUF1RixVQUFVO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsVUFBVTtBQUM3RTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGtDQUFrQyxtQ0FBbUM7QUFDckU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0NBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELElBQUk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLEVBQUUsOENBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QixNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQjtBQUNuRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsOENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsU0FBUyw4Q0FBTTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOENBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSyxFQUFFLEVBQUU7QUFDN0I7QUFDQSxNQUFNO0FBQ04sa0JBQWtCLEtBQUssRUFBRSxNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHVCQUF1QixLQUFLLEdBQUcsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsa0NBQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywyQkFBMkI7QUFDNUI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFz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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQ0FBa0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJDQUEyQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4Q0FBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCLEdBQUcsb0JBQW9CLEdBQUcsd0JBQXdCO0FBQ3hGO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUFNO0FBQ3RCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOENBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUNBQWlDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrQ0FBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsbUNBQW1DO0FBQ3JGO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVDQUF1QztBQUM3QyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPLCtCQUErQixLQUFLO0FBQ3ZGLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHNEQUFzRCxNQUFNO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOENBQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhDQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhDQUFNO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhDQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0REFBNEQ7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3Qix5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0IsaUJBQWlCLEtBQUs7QUFDdEIsdUJBQXVCLFNBQVM7QUFDaEMsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxvQ0FBb0M7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDLCtCQUErQixjQUFjO0FBQzdDLGtCQUFrQixTQUFTO0FBQzNCLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQiwrQkFBK0IsY0FBYztBQUM3QyxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxNQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1Q0FBdUM7QUFDL0MsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywrQkFBK0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQzJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsa0NB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTyxHQUFHLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxZQUFZO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDMkI7QUFDMkI7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3NEO0FBQ087O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUEwRDtBQUNsRSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFDQUFxQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywrQ0FBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwREFBUztBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseURBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNpQztBQUNqQyxhQUFhLGtDQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLGtDQUFZO0FBQ3JCLDhCQUE4QiwrQ0FBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0IsaUdBQWlHLElBQUk7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxzQkFBc0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNEQUFzRCxVQUFVO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNEQUFzRCxVQUFVO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFlBQVksR0FBRztBQUM5QztBQUNBO0FBQ0EsT0FBTyxFQUFFO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBLDBDQUEwQyxZQUFZLEtBQUsseUJBQXlCO0FBQ3BGO0FBQ0EsdURBQXVELFlBQVk7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esc0RBQXNELFlBQVksSUFBSSxLQUFLO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0EsUUFBUTtBQUNSLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFxSEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYWJsb2Zlcm5hbmRlei90ZXN0MTIzL1RFTkVYLXBma21jOS9tYWluL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGstd2FsbGV0L25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3R5cGVzLnRzXG52YXIgTmRrTnV0emFwU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoTmRrTnV0emFwU3RhdHVzMikgPT4ge1xuICBOZGtOdXR6YXBTdGF0dXMyW1wiSU5JVElBTFwiXSA9IFwiaW5pdGlhbFwiO1xuICBOZGtOdXR6YXBTdGF0dXMyW1wiUFJPQ0VTU0lOR1wiXSA9IFwicHJvY2Vzc2luZ1wiO1xuICBOZGtOdXR6YXBTdGF0dXMyW1wiUkVERUVNRURcIl0gPSBcInJlZGVlbWVkXCI7XG4gIE5ka051dHphcFN0YXR1czJbXCJTUEVOVFwiXSA9IFwic3BlbnRcIjtcbiAgTmRrTnV0emFwU3RhdHVzMltcIk1JU1NJTkdfUFJJVktFWVwiXSA9IFwibWlzc2luZ19wcml2a2V5XCI7XG4gIE5ka051dHphcFN0YXR1czJbXCJURU1QT1JBUllfRVJST1JcIl0gPSBcInRlbXBvcmFyeV9lcnJvclwiO1xuICBOZGtOdXR6YXBTdGF0dXMyW1wiUEVSTUFORU5UX0VSUk9SXCJdID0gXCJwZXJtYW5lbnRfZXJyb3JcIjtcbiAgTmRrTnV0emFwU3RhdHVzMltcIklOVkFMSURfTlVUWkFQXCJdID0gXCJpbnZhbGlkX251dHphcFwiO1xuICByZXR1cm4gTmRrTnV0emFwU3RhdHVzMjtcbn0pKE5ka051dHphcFN0YXR1cyB8fCB7fSk7XG5cbi8vIHNyYy9ldmVudHMva2luZHMvaW5kZXgudHNcbnZhciBOREtLaW5kID0gLyogQF9fUFVSRV9fICovICgoTkRLS2luZDIpID0+IHtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNZXRhZGF0YVwiXSA9IDBdID0gXCJNZXRhZGF0YVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlRleHRcIl0gPSAxXSA9IFwiVGV4dFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlJlY29tbWVuZFJlbGF5XCJdID0gMl0gPSBcIlJlY29tbWVuZFJlbGF5XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ29udGFjdHNcIl0gPSAzXSA9IFwiQ29udGFjdHNcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJFbmNyeXB0ZWREaXJlY3RNZXNzYWdlXCJdID0gNF0gPSBcIkVuY3J5cHRlZERpcmVjdE1lc3NhZ2VcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJFdmVudERlbGV0aW9uXCJdID0gNV0gPSBcIkV2ZW50RGVsZXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJSZXBvc3RcIl0gPSA2XSA9IFwiUmVwb3N0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUmVhY3Rpb25cIl0gPSA3XSA9IFwiUmVhY3Rpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCYWRnZUF3YXJkXCJdID0gOF0gPSBcIkJhZGdlQXdhcmRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cENoYXRcIl0gPSA5XSA9IFwiR3JvdXBDaGF0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBOb3RlXCJdID0gMTFdID0gXCJHcm91cE5vdGVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cFJlcGx5XCJdID0gMTJdID0gXCJHcm91cFJlcGx5XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR2lmdFdyYXBTZWFsXCJdID0gMTNdID0gXCJHaWZ0V3JhcFNlYWxcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJQcml2YXRlRGlyZWN0TWVzc2FnZVwiXSA9IDE0XSA9IFwiUHJpdmF0ZURpcmVjdE1lc3NhZ2VcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJJbWFnZVwiXSA9IDIwXSA9IFwiSW1hZ2VcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJWaWRlb1wiXSA9IDIxXSA9IFwiVmlkZW9cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJTaG9ydFZpZGVvXCJdID0gMjJdID0gXCJTaG9ydFZpZGVvXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU3RvcnlcIl0gPSAyM10gPSBcIlN0b3J5XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiVmFuaXNoXCJdID0gNjJdID0gXCJWYW5pc2hcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXNodVdhbGxldEJhY2t1cFwiXSA9IDM3NV0gPSBcIkNhc2h1V2FsbGV0QmFja3VwXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR2lmdFdyYXBcIl0gPSAxMDU5XSA9IFwiR2lmdFdyYXBcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHZW5lcmljUmVwb3N0XCJdID0gMTZdID0gXCJHZW5lcmljUmVwb3N0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2hhbm5lbENyZWF0aW9uXCJdID0gNDBdID0gXCJDaGFubmVsQ3JlYXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDaGFubmVsTWV0YWRhdGFcIl0gPSA0MV0gPSBcIkNoYW5uZWxNZXRhZGF0YVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNoYW5uZWxNZXNzYWdlXCJdID0gNDJdID0gXCJDaGFubmVsTWVzc2FnZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNoYW5uZWxIaWRlTWVzc2FnZVwiXSA9IDQzXSA9IFwiQ2hhbm5lbEhpZGVNZXNzYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2hhbm5lbE11dGVVc2VyXCJdID0gNDRdID0gXCJDaGFubmVsTXV0ZVVzZXJcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJXaWtpTWVyZ2VSZXF1ZXN0XCJdID0gODE4XSA9IFwiV2lraU1lcmdlUmVxdWVzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdlbmVyaWNSZXBseVwiXSA9IDExMTFdID0gXCJHZW5lcmljUmVwbHlcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNZWRpYVwiXSA9IDEwNjNdID0gXCJNZWRpYVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlJlcG9ydFwiXSA9IDE5ODRdID0gXCJSZXBvcnRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJMYWJlbFwiXSA9IDE5ODVdID0gXCJMYWJlbFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcVRleHRFeHRyYWN0aW9uXCJdID0gNWUzXSA9IFwiRFZNUmVxVGV4dEV4dHJhY3Rpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFUZXh0U3VtbWFyaXphdGlvblwiXSA9IDUwMDFdID0gXCJEVk1SZXFUZXh0U3VtbWFyaXphdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcVRleHRUcmFuc2xhdGlvblwiXSA9IDUwMDJdID0gXCJEVk1SZXFUZXh0VHJhbnNsYXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFUZXh0R2VuZXJhdGlvblwiXSA9IDUwNTBdID0gXCJEVk1SZXFUZXh0R2VuZXJhdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcUltYWdlR2VuZXJhdGlvblwiXSA9IDUxMDBdID0gXCJEVk1SZXFJbWFnZUdlbmVyYXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFUZXh0VG9TcGVlY2hcIl0gPSA1MjUwXSA9IFwiRFZNUmVxVGV4dFRvU3BlZWNoXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxRGlzY292ZXJ5Tm9zdHJDb250ZW50XCJdID0gNTMwMF0gPSBcIkRWTVJlcURpc2NvdmVyeU5vc3RyQ29udGVudFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcURpc2NvdmVyeU5vc3RyUGVvcGxlXCJdID0gNTMwMV0gPSBcIkRWTVJlcURpc2NvdmVyeU5vc3RyUGVvcGxlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxVGltZXN0YW1waW5nXCJdID0gNTkwMF0gPSBcIkRWTVJlcVRpbWVzdGFtcGluZ1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTUV2ZW50U2NoZWR1bGVcIl0gPSA1OTA1XSA9IFwiRFZNRXZlbnRTY2hlZHVsZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTUpvYkZlZWRiYWNrXCJdID0gN2UzXSA9IFwiRFZNSm9iRmVlZGJhY2tcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJTdWJzY3JpYmVcIl0gPSA3MDAxXSA9IFwiU3Vic2NyaWJlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiVW5zdWJzY3JpYmVcIl0gPSA3MDAyXSA9IFwiVW5zdWJzY3JpYmVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJTdWJzY3JpcHRpb25SZWNlaXB0XCJdID0gNzAwM10gPSBcIlN1YnNjcmlwdGlvblJlY2VpcHRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXNodVJlc2VydmVcIl0gPSA3MzczXSA9IFwiQ2FzaHVSZXNlcnZlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVRdW90ZVwiXSA9IDczNzRdID0gXCJDYXNodVF1b3RlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVUb2tlblwiXSA9IDczNzVdID0gXCJDYXNodVRva2VuXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVXYWxsZXRUeFwiXSA9IDczNzZdID0gXCJDYXNodVdhbGxldFR4XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pbkFkZFVzZXJcIl0gPSA5ZTNdID0gXCJHcm91cEFkbWluQWRkVXNlclwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5SZW1vdmVVc2VyXCJdID0gOTAwMV0gPSBcIkdyb3VwQWRtaW5SZW1vdmVVc2VyXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pbkVkaXRNZXRhZGF0YVwiXSA9IDkwMDJdID0gXCJHcm91cEFkbWluRWRpdE1ldGFkYXRhXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pbkVkaXRTdGF0dXNcIl0gPSA5MDA2XSA9IFwiR3JvdXBBZG1pbkVkaXRTdGF0dXNcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cEFkbWluQ3JlYXRlR3JvdXBcIl0gPSA5MDA3XSA9IFwiR3JvdXBBZG1pbkNyZWF0ZUdyb3VwXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pblJlcXVlc3RKb2luXCJdID0gOTAyMV0gPSBcIkdyb3VwQWRtaW5SZXF1ZXN0Sm9pblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk11dGVMaXN0XCJdID0gMWU0XSA9IFwiTXV0ZUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJQaW5MaXN0XCJdID0gMTAwMDFdID0gXCJQaW5MaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUmVsYXlMaXN0XCJdID0gMTAwMDJdID0gXCJSZWxheUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCb29rbWFya0xpc3RcIl0gPSAxMDAwM10gPSBcIkJvb2ttYXJrTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNvbW11bml0eUxpc3RcIl0gPSAxMDAwNF0gPSBcIkNvbW11bml0eUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJQdWJsaWNDaGF0TGlzdFwiXSA9IDEwMDA1XSA9IFwiUHVibGljQ2hhdExpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCbG9ja1JlbGF5TGlzdFwiXSA9IDEwMDA2XSA9IFwiQmxvY2tSZWxheUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJTZWFyY2hSZWxheUxpc3RcIl0gPSAxMDAwN10gPSBcIlNlYXJjaFJlbGF5TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlNpbXBsZUdyb3VwTGlzdFwiXSA9IDEwMDA5XSA9IFwiU2ltcGxlR3JvdXBMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSW50ZXJlc3RMaXN0XCJdID0gMTAwMTVdID0gXCJJbnRlcmVzdExpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXNodU1pbnRMaXN0XCJdID0gMTAwMTldID0gXCJDYXNodU1pbnRMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRW1vamlMaXN0XCJdID0gMTAwMzBdID0gXCJFbW9qaUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEaXJlY3RNZXNzYWdlUmVjZWl2ZVJlbGF5TGlzdFwiXSA9IDEwMDUwXSA9IFwiRGlyZWN0TWVzc2FnZVJlY2VpdmVSZWxheUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCbG9zc29tTGlzdFwiXSA9IDEwMDYzXSA9IFwiQmxvc3NvbUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJOb3N0cldhbGV0Q29ubmVjdEluZm9cIl0gPSAxMzE5NF0gPSBcIk5vc3RyV2FsZXRDb25uZWN0SW5mb1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlRpZXJMaXN0XCJdID0gMTdlM10gPSBcIlRpZXJMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVXYWxsZXRcIl0gPSAxNzM3NV0gPSBcIkNhc2h1V2FsbGV0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRm9sbG93U2V0XCJdID0gM2U0XSA9IFwiRm9sbG93U2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2F0ZWdvcml6ZWRQZW9wbGVMaXN0XCJdID0gM2U0IC8qIEZvbGxvd1NldCAqL10gPSBcIkNhdGVnb3JpemVkUGVvcGxlTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhdGVnb3JpemVkQm9va21hcmtMaXN0XCJdID0gMzAwMDFdID0gXCJDYXRlZ29yaXplZEJvb2ttYXJrTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlJlbGF5U2V0XCJdID0gMzAwMDJdID0gXCJSZWxheVNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhdGVnb3JpemVkUmVsYXlMaXN0XCJdID0gMzAwMDIgLyogUmVsYXlTZXQgKi9dID0gXCJDYXRlZ29yaXplZFJlbGF5TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkJvb2ttYXJrU2V0XCJdID0gMzAwMDNdID0gXCJCb29rbWFya1NldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkN1cmF0aW9uU2V0XCJdID0gMzAwMDRdID0gXCJDdXJhdGlvblNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkFydGljbGVDdXJhdGlvblNldFwiXSA9IDMwMDA0XSA9IFwiQXJ0aWNsZUN1cmF0aW9uU2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiVmlkZW9DdXJhdGlvblNldFwiXSA9IDMwMDA1XSA9IFwiVmlkZW9DdXJhdGlvblNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkltYWdlQ3VyYXRpb25TZXRcIl0gPSAzMDAwNl0gPSBcIkltYWdlQ3VyYXRpb25TZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJJbnRlcmVzdFNldFwiXSA9IDMwMDE1XSA9IFwiSW50ZXJlc3RTZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJJbnRlcmVzdHNMaXN0XCJdID0gMzAwMTUgLyogSW50ZXJlc3RTZXQgKi9dID0gXCJJbnRlcmVzdHNMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRW1vamlTZXRcIl0gPSAzMDAzMF0gPSBcIkVtb2ppU2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTW9kdWxhckFydGljbGVcIl0gPSAzMDA0MF0gPSBcIk1vZHVsYXJBcnRpY2xlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTW9kdWxhckFydGljbGVJdGVtXCJdID0gMzAwNDFdID0gXCJNb2R1bGFyQXJ0aWNsZUl0ZW1cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJXaWtpXCJdID0gMzA4MThdID0gXCJXaWtpXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRHJhZnRcIl0gPSAzMTIzNF0gPSBcIkRyYWZ0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU3Vic2NyaXB0aW9uVGllclwiXSA9IDM3MDAxXSA9IFwiU3Vic2NyaXB0aW9uVGllclwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkVjYXNoTWludFJlY29tbWVuZGF0aW9uXCJdID0gMzhlM10gPSBcIkVjYXNoTWludFJlY29tbWVuZGF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSGlnaGxpZ2h0U2V0XCJdID0gMzk4MDJdID0gXCJIaWdobGlnaHRTZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXRlZ29yaXplZEhpZ2hsaWdodExpc3RcIl0gPSAzOTgwMiAvKiBIaWdobGlnaHRTZXQgKi9dID0gXCJDYXRlZ29yaXplZEhpZ2hsaWdodExpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJOdXR6YXBcIl0gPSA5MzIxXSA9IFwiTnV0emFwXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiWmFwUmVxdWVzdFwiXSA9IDk3MzRdID0gXCJaYXBSZXF1ZXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiWmFwXCJdID0gOTczNV0gPSBcIlphcFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkhpZ2hsaWdodFwiXSA9IDk4MDJdID0gXCJIaWdobGlnaHRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDbGllbnRBdXRoXCJdID0gMjIyNDJdID0gXCJDbGllbnRBdXRoXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTm9zdHJXYWxsZXRDb25uZWN0UmVxXCJdID0gMjMxOTRdID0gXCJOb3N0cldhbGxldENvbm5lY3RSZXFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJOb3N0cldhbGxldENvbm5lY3RSZXNcIl0gPSAyMzE5NV0gPSBcIk5vc3RyV2FsbGV0Q29ubmVjdFJlc1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk5vc3RyQ29ubmVjdFwiXSA9IDI0MTMzXSA9IFwiTm9zdHJDb25uZWN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQmxvc3NvbVVwbG9hZFwiXSA9IDI0MjQyXSA9IFwiQmxvc3NvbVVwbG9hZFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkh0dHBBdXRoXCJdID0gMjcyMzVdID0gXCJIdHRwQXV0aFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlByb2ZpbGVCYWRnZVwiXSA9IDMwMDA4XSA9IFwiUHJvZmlsZUJhZGdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQmFkZ2VEZWZpbml0aW9uXCJdID0gMzAwMDldID0gXCJCYWRnZURlZmluaXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNYXJrZXRTdGFsbFwiXSA9IDMwMDE3XSA9IFwiTWFya2V0U3RhbGxcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNYXJrZXRQcm9kdWN0XCJdID0gMzAwMThdID0gXCJNYXJrZXRQcm9kdWN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQXJ0aWNsZVwiXSA9IDMwMDIzXSA9IFwiQXJ0aWNsZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkFwcFNwZWNpZmljRGF0YVwiXSA9IDMwMDc4XSA9IFwiQXBwU3BlY2lmaWNEYXRhXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2xhc3NpZmllZFwiXSA9IDMwNDAyXSA9IFwiQ2xhc3NpZmllZFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkhvcml6b250YWxWaWRlb1wiXSA9IDM0MjM1XSA9IFwiSG9yaXpvbnRhbFZpZGVvXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiVmVydGljYWxWaWRlb1wiXSA9IDM0MjM2XSA9IFwiVmVydGljYWxWaWRlb1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkxlZ2FjeUNhc2h1V2FsbGV0XCJdID0gMzczNzVdID0gXCJMZWdhY3lDYXNodVdhbGxldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwTWV0YWRhdGFcIl0gPSAzOWUzXSA9IFwiR3JvdXBNZXRhZGF0YVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5zXCJdID0gMzkwMDFdID0gXCJHcm91cEFkbWluc1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwTWVtYmVyc1wiXSA9IDM5MDAyXSA9IFwiR3JvdXBNZW1iZXJzXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQXBwUmVjb21tZW5kYXRpb25cIl0gPSAzMTk4OV0gPSBcIkFwcFJlY29tbWVuZGF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQXBwSGFuZGxlclwiXSA9IDMxOTkwXSA9IFwiQXBwSGFuZGxlclwiO1xuICByZXR1cm4gTkRLS2luZDI7XG59KShOREtLaW5kIHx8IHt9KTtcbnZhciBOREtMaXN0S2luZHMgPSBbXG4gIDFlNCAvKiBNdXRlTGlzdCAqLyxcbiAgMTAwMDEgLyogUGluTGlzdCAqLyxcbiAgMTAwMDIgLyogUmVsYXlMaXN0ICovLFxuICAxMDAwMyAvKiBCb29rbWFya0xpc3QgKi8sXG4gIDEwMDA0IC8qIENvbW11bml0eUxpc3QgKi8sXG4gIDEwMDA1IC8qIFB1YmxpY0NoYXRMaXN0ICovLFxuICAxMDAwNiAvKiBCbG9ja1JlbGF5TGlzdCAqLyxcbiAgMTAwMDcgLyogU2VhcmNoUmVsYXlMaXN0ICovLFxuICAxMDAxNSAvKiBJbnRlcmVzdExpc3QgKi8sXG4gIDEwMDMwIC8qIEVtb2ppTGlzdCAqLyxcbiAgMTAwNTAgLyogRGlyZWN0TWVzc2FnZVJlY2VpdmVSZWxheUxpc3QgKi8sXG4gIDNlNCAvKiBGb2xsb3dTZXQgKi8sXG4gIDMwMDAzIC8qIEJvb2ttYXJrU2V0ICovLFxuICAzMDAwMSAvKiBDYXRlZ29yaXplZEJvb2ttYXJrTGlzdCAqLyxcbiAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgMzAwMDIgLyogUmVsYXlTZXQgKi8sXG4gIDMwMDA0IC8qIEFydGljbGVDdXJhdGlvblNldCAqLyxcbiAgMzAwMDUgLyogVmlkZW9DdXJhdGlvblNldCAqLyxcbiAgMzAwMTUgLyogSW50ZXJlc3RTZXQgKi8sXG4gIDMwMDMwIC8qIEVtb2ppU2V0ICovLFxuICAzOTgwMiAvKiBIaWdobGlnaHRTZXQgKi9cbl07XG5cbi8vIHNyYy9ldmVudHMvaW5kZXgudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXIyIH0gZnJvbSBcInRzZWVwXCI7XG5cbi8vIHNyYy9yZWxheS9zZXRzL2NhbGN1bGF0ZS50c1xuaW1wb3J0IGNyZWF0ZURlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuXG4vLyBzcmMvb3V0Ym94L3dyaXRlLnRzXG5mdW5jdGlvbiBnZXRSZWxheXNGb3JTeW5jKG5kaywgYXV0aG9yLCB0eXBlID0gXCJ3cml0ZVwiKSB7XG4gIGlmICghbmRrLm91dGJveFRyYWNrZXIpIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IGl0ZW0gPSBuZGsub3V0Ym94VHJhY2tlci5kYXRhLmdldChhdXRob3IpO1xuICBpZiAoIWl0ZW0pIHJldHVybiB2b2lkIDA7XG4gIGlmICh0eXBlID09PSBcIndyaXRlXCIpIHtcbiAgICByZXR1cm4gaXRlbS53cml0ZVJlbGF5cztcbiAgfVxuICByZXR1cm4gaXRlbS5yZWFkUmVsYXlzO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0V3JpdGVSZWxheXNGb3IobmRrLCBhdXRob3IsIHR5cGUgPSBcIndyaXRlXCIpIHtcbiAgaWYgKCFuZGsub3V0Ym94VHJhY2tlcikgcmV0dXJuIHZvaWQgMDtcbiAgaWYgKCFuZGsub3V0Ym94VHJhY2tlci5kYXRhLmhhcyhhdXRob3IpKSB7XG4gICAgYXdhaXQgbmRrLm91dGJveFRyYWNrZXIudHJhY2tVc2VycyhbYXV0aG9yXSk7XG4gIH1cbiAgcmV0dXJuIGdldFJlbGF5c0ZvclN5bmMobmRrLCBhdXRob3IsIHR5cGUpO1xufVxuXG4vLyBzcmMvb3V0Ym94L3JlbGF5LXJhbmtpbmcudHNcbmZ1bmN0aW9uIGdldFRvcFJlbGF5c0ZvckF1dGhvcnMobmRrLCBhdXRob3JzKSB7XG4gIGNvbnN0IHJlbGF5c1dpdGhDb3VudCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGF1dGhvcnMuZm9yRWFjaCgoYXV0aG9yKSA9PiB7XG4gICAgY29uc3Qgd3JpdGVSZWxheXMgPSBnZXRSZWxheXNGb3JTeW5jKG5kaywgYXV0aG9yKTtcbiAgICBpZiAod3JpdGVSZWxheXMpIHtcbiAgICAgIHdyaXRlUmVsYXlzLmZvckVhY2goKHJlbGF5KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gcmVsYXlzV2l0aENvdW50LmdldChyZWxheSkgfHwgMDtcbiAgICAgICAgcmVsYXlzV2l0aENvdW50LnNldChyZWxheSwgY291bnQgKyAxKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHNvcnRlZFJlbGF5cyA9IEFycmF5LmZyb20ocmVsYXlzV2l0aENvdW50LmVudHJpZXMoKSkuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pO1xuICByZXR1cm4gc29ydGVkUmVsYXlzLm1hcCgoZW50cnkpID0+IGVudHJ5WzBdKTtcbn1cblxuLy8gc3JjL291dGJveC9pbmRleC50c1xuZnVuY3Rpb24gZ2V0QWxsUmVsYXlzRm9yQWxsUHVia2V5cyhuZGssIHB1YmtleXMsIHR5cGUgPSBcInJlYWRcIikge1xuICBjb25zdCBwdWJrZXlzVG9SZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBhdXRob3JzTWlzc2luZ1JlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHB1YmtleXMuZm9yRWFjaCgocHVia2V5KSA9PiB7XG4gICAgY29uc3QgcmVsYXlzID0gZ2V0UmVsYXlzRm9yU3luYyhuZGssIHB1YmtleSwgdHlwZSk7XG4gICAgaWYgKHJlbGF5cyAmJiByZWxheXMuc2l6ZSA+IDApIHtcbiAgICAgIHJlbGF5cy5mb3JFYWNoKChyZWxheSkgPT4ge1xuICAgICAgICBjb25zdCBwdWJrZXlzSW5SZWxheSA9IHB1YmtleXNUb1JlbGF5cy5nZXQocmVsYXkpIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgIHB1YmtleXNJblJlbGF5LmFkZChwdWJrZXkpO1xuICAgICAgfSk7XG4gICAgICBwdWJrZXlzVG9SZWxheXMuc2V0KHB1YmtleSwgcmVsYXlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXV0aG9yc01pc3NpbmdSZWxheXMuYWRkKHB1YmtleSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHsgcHVia2V5c1RvUmVsYXlzLCBhdXRob3JzTWlzc2luZ1JlbGF5cyB9O1xufVxuZnVuY3Rpb24gY2hvb3NlUmVsYXlDb21iaW5hdGlvbkZvclB1YmtleXMobmRrLCBwdWJrZXlzLCB0eXBlLCB7IGNvdW50LCBwcmVmZXJyZWRSZWxheXMgfSA9IHt9KSB7XG4gIGNvdW50ID8/PSAyO1xuICBwcmVmZXJyZWRSZWxheXMgPz89IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHBvb2wgPSBuZGsucG9vbDtcbiAgY29uc3QgY29ubmVjdGVkUmVsYXlzID0gcG9vbC5jb25uZWN0ZWRSZWxheXMoKTtcbiAgY29ubmVjdGVkUmVsYXlzLmZvckVhY2goKHJlbGF5KSA9PiB7XG4gICAgcHJlZmVycmVkUmVsYXlzPy5hZGQocmVsYXkudXJsKTtcbiAgfSk7XG4gIGNvbnN0IHJlbGF5VG9BdXRob3JzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgeyBwdWJrZXlzVG9SZWxheXMsIGF1dGhvcnNNaXNzaW5nUmVsYXlzIH0gPSBnZXRBbGxSZWxheXNGb3JBbGxQdWJrZXlzKG5kaywgcHVia2V5cywgdHlwZSk7XG4gIGNvbnN0IHNvcnRlZFJlbGF5cyA9IGdldFRvcFJlbGF5c0ZvckF1dGhvcnMobmRrLCBwdWJrZXlzKTtcbiAgY29uc3QgYWRkQXV0aG9yVG9SZWxheSA9IChhdXRob3IsIHJlbGF5KSA9PiB7XG4gICAgY29uc3QgYXV0aG9yc0luUmVsYXkgPSByZWxheVRvQXV0aG9yc01hcC5nZXQocmVsYXkpIHx8IFtdO1xuICAgIGF1dGhvcnNJblJlbGF5LnB1c2goYXV0aG9yKTtcbiAgICByZWxheVRvQXV0aG9yc01hcC5zZXQocmVsYXksIGF1dGhvcnNJblJlbGF5KTtcbiAgfTtcbiAgZm9yIChjb25zdCBbYXV0aG9yLCBhdXRob3JSZWxheXNdIG9mIHB1YmtleXNUb1JlbGF5cy5lbnRyaWVzKCkpIHtcbiAgICBsZXQgbWlzc2luZ1JlbGF5Q291bnQgPSBjb3VudDtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIGNvbm5lY3RlZFJlbGF5cykge1xuICAgICAgaWYgKGF1dGhvclJlbGF5cy5oYXMocmVsYXkudXJsKSkge1xuICAgICAgICBhZGRBdXRob3JUb1JlbGF5KGF1dGhvciwgcmVsYXkudXJsKTtcbiAgICAgICAgbWlzc2luZ1JlbGF5Q291bnQtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBhdXRob3JSZWxheSBvZiBhdXRob3JSZWxheXMpIHtcbiAgICAgIGlmIChyZWxheVRvQXV0aG9yc01hcC5oYXMoYXV0aG9yUmVsYXkpKSB7XG4gICAgICAgIGFkZEF1dGhvclRvUmVsYXkoYXV0aG9yLCBhdXRob3JSZWxheSk7XG4gICAgICAgIG1pc3NpbmdSZWxheUNvdW50LS07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaXNzaW5nUmVsYXlDb3VudCA8PSAwKSBjb250aW51ZTtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHNvcnRlZFJlbGF5cykge1xuICAgICAgaWYgKG1pc3NpbmdSZWxheUNvdW50IDw9IDApIGJyZWFrO1xuICAgICAgaWYgKGF1dGhvclJlbGF5cy5oYXMocmVsYXkpKSB7XG4gICAgICAgIGFkZEF1dGhvclRvUmVsYXkoYXV0aG9yLCByZWxheSk7XG4gICAgICAgIG1pc3NpbmdSZWxheUNvdW50LS07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgYXV0aG9yIG9mIGF1dGhvcnNNaXNzaW5nUmVsYXlzKSB7XG4gICAgcG9vbC5wZXJtYW5lbnRBbmRDb25uZWN0ZWRSZWxheXMoKS5mb3JFYWNoKChyZWxheSkgPT4ge1xuICAgICAgY29uc3QgYXV0aG9yc0luUmVsYXkgPSByZWxheVRvQXV0aG9yc01hcC5nZXQocmVsYXkudXJsKSB8fCBbXTtcbiAgICAgIGF1dGhvcnNJblJlbGF5LnB1c2goYXV0aG9yKTtcbiAgICAgIHJlbGF5VG9BdXRob3JzTWFwLnNldChyZWxheS51cmwsIGF1dGhvcnNJblJlbGF5KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVsYXlUb0F1dGhvcnNNYXA7XG59XG5cbi8vIHNyYy9vdXRib3gvcmVhZC93aXRoLWF1dGhvcnMudHNcbmZ1bmN0aW9uIGdldFJlbGF5c0ZvckZpbHRlcldpdGhBdXRob3JzKG5kaywgYXV0aG9ycywgcmVsYXlHb2FsUGVyQXV0aG9yID0gMikge1xuICByZXR1cm4gY2hvb3NlUmVsYXlDb21iaW5hdGlvbkZvclB1YmtleXMobmRrLCBhdXRob3JzLCBcIndyaXRlXCIsIHsgY291bnQ6IHJlbGF5R29hbFBlckF1dGhvciB9KTtcbn1cblxuLy8gc3JjL3V0aWxzL25vcm1hbGl6ZS11cmwudHNcbmZ1bmN0aW9uIHRyeU5vcm1hbGl6ZVJlbGF5VXJsKHVybCkge1xuICB0cnkge1xuICAgIHJldHVybiBub3JtYWxpemVSZWxheVVybCh1cmwpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVSZWxheVVybCh1cmwpIHtcbiAgbGV0IHIgPSBub3JtYWxpemVVcmwodXJsLCB7XG4gICAgc3RyaXBBdXRoZW50aWNhdGlvbjogZmFsc2UsXG4gICAgc3RyaXBXV1c6IGZhbHNlLFxuICAgIHN0cmlwSGFzaDogdHJ1ZVxuICB9KTtcbiAgaWYgKCFyLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgIHIgKz0gXCIvXCI7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBub3JtYWxpemUodXJscykge1xuICBjb25zdCBub3JtYWxpemVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCB1cmwgb2YgdXJscykge1xuICAgIHRyeSB7XG4gICAgICBub3JtYWxpemVkLmFkZChub3JtYWxpemVSZWxheVVybCh1cmwpKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20obm9ybWFsaXplZCk7XG59XG52YXIgREFUQV9VUkxfREVGQVVMVF9NSU1FX1RZUEUgPSBcInRleHQvcGxhaW5cIjtcbnZhciBEQVRBX1VSTF9ERUZBVUxUX0NIQVJTRVQgPSBcInVzLWFzY2lpXCI7XG52YXIgdGVzdFBhcmFtZXRlciA9IChuYW1lLCBmaWx0ZXJzKSA9PiBmaWx0ZXJzLnNvbWUoKGZpbHRlcikgPT4gZmlsdGVyIGluc3RhbmNlb2YgUmVnRXhwID8gZmlsdGVyLnRlc3QobmFtZSkgOiBmaWx0ZXIgPT09IG5hbWUpO1xudmFyIHN1cHBvcnRlZFByb3RvY29scyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImh0dHBzOlwiLCBcImh0dHA6XCIsIFwiZmlsZTpcIl0pO1xudmFyIGhhc0N1c3RvbVByb3RvY29sID0gKHVybFN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgcHJvdG9jb2wgfSA9IG5ldyBVUkwodXJsU3RyaW5nKTtcbiAgICByZXR1cm4gcHJvdG9jb2wuZW5kc1dpdGgoXCI6XCIpICYmICFwcm90b2NvbC5pbmNsdWRlcyhcIi5cIikgJiYgIXN1cHBvcnRlZFByb3RvY29scy5oYXMocHJvdG9jb2wpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG52YXIgbm9ybWFsaXplRGF0YVVSTCA9ICh1cmxTdHJpbmcsIHsgc3RyaXBIYXNoIH0pID0+IHtcbiAgY29uc3QgbWF0Y2ggPSAvXmRhdGE6KD88dHlwZT5bXixdKj8pLCg/PGRhdGE+W14jXSo/KSg/OiMoPzxoYXNoPi4qKSk/JC8uZXhlYyh1cmxTdHJpbmcpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFVSTDogJHt1cmxTdHJpbmd9YCk7XG4gIH1cbiAgY29uc3QgdHlwZSA9IG1hdGNoLmdyb3Vwcz8udHlwZSA/PyBcIlwiO1xuICBjb25zdCBkYXRhID0gbWF0Y2guZ3JvdXBzPy5kYXRhID8/IFwiXCI7XG4gIGxldCBoYXNoID0gbWF0Y2guZ3JvdXBzPy5oYXNoID8/IFwiXCI7XG4gIGNvbnN0IG1lZGlhVHlwZSA9IHR5cGUuc3BsaXQoXCI7XCIpO1xuICBoYXNoID0gc3RyaXBIYXNoID8gXCJcIiA6IGhhc2g7XG4gIGxldCBpc0Jhc2U2NCA9IGZhbHNlO1xuICBpZiAobWVkaWFUeXBlW21lZGlhVHlwZS5sZW5ndGggLSAxXSA9PT0gXCJiYXNlNjRcIikge1xuICAgIG1lZGlhVHlwZS5wb3AoKTtcbiAgICBpc0Jhc2U2NCA9IHRydWU7XG4gIH1cbiAgY29uc3QgbWltZVR5cGUgPSBtZWRpYVR5cGUuc2hpZnQoKT8udG9Mb3dlckNhc2UoKSA/PyBcIlwiO1xuICBjb25zdCBhdHRyaWJ1dGVzID0gbWVkaWFUeXBlLm1hcCgoYXR0cmlidXRlKSA9PiB7XG4gICAgbGV0IFtrZXksIHZhbHVlID0gXCJcIl0gPSBhdHRyaWJ1dGUuc3BsaXQoXCI9XCIpLm1hcCgoc3RyaW5nKSA9PiBzdHJpbmcudHJpbSgpKTtcbiAgICBpZiAoa2V5ID09PSBcImNoYXJzZXRcIikge1xuICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHZhbHVlID09PSBEQVRBX1VSTF9ERUZBVUxUX0NIQVJTRVQpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgJHtrZXl9JHt2YWx1ZSA/IGA9JHt2YWx1ZX1gIDogXCJcIn1gO1xuICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IG5vcm1hbGl6ZWRNZWRpYVR5cGUgPSBbLi4uYXR0cmlidXRlc107XG4gIGlmIChpc0Jhc2U2NCkge1xuICAgIG5vcm1hbGl6ZWRNZWRpYVR5cGUucHVzaChcImJhc2U2NFwiKTtcbiAgfVxuICBpZiAobm9ybWFsaXplZE1lZGlhVHlwZS5sZW5ndGggPiAwIHx8IG1pbWVUeXBlICYmIG1pbWVUeXBlICE9PSBEQVRBX1VSTF9ERUZBVUxUX01JTUVfVFlQRSkge1xuICAgIG5vcm1hbGl6ZWRNZWRpYVR5cGUudW5zaGlmdChtaW1lVHlwZSk7XG4gIH1cbiAgcmV0dXJuIGBkYXRhOiR7bm9ybWFsaXplZE1lZGlhVHlwZS5qb2luKFwiO1wiKX0sJHtpc0Jhc2U2NCA/IGRhdGEudHJpbSgpIDogZGF0YX0ke2hhc2ggPyBgIyR7aGFzaH1gIDogXCJcIn1gO1xufTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVVybCh1cmxTdHJpbmcsIG9wdGlvbnMgPSB7fSkge1xuICBvcHRpb25zID0ge1xuICAgIGRlZmF1bHRQcm90b2NvbDogXCJodHRwXCIsXG4gICAgbm9ybWFsaXplUHJvdG9jb2w6IHRydWUsXG4gICAgZm9yY2VIdHRwOiBmYWxzZSxcbiAgICBmb3JjZUh0dHBzOiBmYWxzZSxcbiAgICBzdHJpcEF1dGhlbnRpY2F0aW9uOiB0cnVlLFxuICAgIHN0cmlwSGFzaDogZmFsc2UsXG4gICAgc3RyaXBUZXh0RnJhZ21lbnQ6IHRydWUsXG4gICAgc3RyaXBXV1c6IHRydWUsXG4gICAgcmVtb3ZlUXVlcnlQYXJhbWV0ZXJzOiBbL151dG1fXFx3Ky9pXSxcbiAgICByZW1vdmVUcmFpbGluZ1NsYXNoOiB0cnVlLFxuICAgIHJlbW92ZVNpbmdsZVNsYXNoOiB0cnVlLFxuICAgIHJlbW92ZURpcmVjdG9yeUluZGV4OiBmYWxzZSxcbiAgICByZW1vdmVFeHBsaWNpdFBvcnQ6IGZhbHNlLFxuICAgIHNvcnRRdWVyeVBhcmFtZXRlcnM6IHRydWUsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBpZiAodHlwZW9mIG9wdGlvbnMuZGVmYXVsdFByb3RvY29sID09PSBcInN0cmluZ1wiICYmICFvcHRpb25zLmRlZmF1bHRQcm90b2NvbC5lbmRzV2l0aChcIjpcIikpIHtcbiAgICBvcHRpb25zLmRlZmF1bHRQcm90b2NvbCA9IGAke29wdGlvbnMuZGVmYXVsdFByb3RvY29sfTpgO1xuICB9XG4gIHVybFN0cmluZyA9IHVybFN0cmluZy50cmltKCk7XG4gIGlmICgvXmRhdGE6L2kudGVzdCh1cmxTdHJpbmcpKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZURhdGFVUkwodXJsU3RyaW5nLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoaGFzQ3VzdG9tUHJvdG9jb2wodXJsU3RyaW5nKSkge1xuICAgIHJldHVybiB1cmxTdHJpbmc7XG4gIH1cbiAgY29uc3QgaGFzUmVsYXRpdmVQcm90b2NvbCA9IHVybFN0cmluZy5zdGFydHNXaXRoKFwiLy9cIik7XG4gIGNvbnN0IGlzUmVsYXRpdmVVcmwgPSAhaGFzUmVsYXRpdmVQcm90b2NvbCAmJiAvXlxcLipcXC8vLnRlc3QodXJsU3RyaW5nKTtcbiAgaWYgKCFpc1JlbGF0aXZlVXJsKSB7XG4gICAgdXJsU3RyaW5nID0gdXJsU3RyaW5nLnJlcGxhY2UoL14oPyEoPzpcXHcrOik/XFwvXFwvKXxeXFwvXFwvLywgb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wpO1xuICB9XG4gIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwodXJsU3RyaW5nKTtcbiAgdXJsT2JqZWN0Lmhvc3RuYW1lID0gdXJsT2JqZWN0Lmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChvcHRpb25zLmZvcmNlSHR0cCAmJiBvcHRpb25zLmZvcmNlSHR0cHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYGZvcmNlSHR0cGAgYW5kIGBmb3JjZUh0dHBzYCBvcHRpb25zIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyXCIpO1xuICB9XG4gIGlmIChvcHRpb25zLmZvcmNlSHR0cCAmJiB1cmxPYmplY3QucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIpIHtcbiAgICB1cmxPYmplY3QucHJvdG9jb2wgPSBcImh0dHA6XCI7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZm9yY2VIdHRwcyAmJiB1cmxPYmplY3QucHJvdG9jb2wgPT09IFwiaHR0cDpcIikge1xuICAgIHVybE9iamVjdC5wcm90b2NvbCA9IFwiaHR0cHM6XCI7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RyaXBBdXRoZW50aWNhdGlvbikge1xuICAgIHVybE9iamVjdC51c2VybmFtZSA9IFwiXCI7XG4gICAgdXJsT2JqZWN0LnBhc3N3b3JkID0gXCJcIjtcbiAgfVxuICBpZiAob3B0aW9ucy5zdHJpcEhhc2gpIHtcbiAgICB1cmxPYmplY3QuaGFzaCA9IFwiXCI7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5zdHJpcFRleHRGcmFnbWVudCkge1xuICAgIHVybE9iamVjdC5oYXNoID0gdXJsT2JqZWN0Lmhhc2gucmVwbGFjZSgvIz86fjp0ZXh0Lio/JC9pLCBcIlwiKTtcbiAgfVxuICBpZiAodXJsT2JqZWN0LnBhdGhuYW1lKSB7XG4gICAgY29uc3QgcHJvdG9jb2xSZWdleCA9IC9cXGJbYS16XVthLXpcXGQrXFwtLl17MSw1MH06XFwvXFwvL2c7XG4gICAgbGV0IGxhc3RJbmRleCA9IDA7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yICg7IDsgKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IHByb3RvY29sUmVnZXguZXhlYyh1cmxPYmplY3QucGF0aG5hbWUpO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3RvY29sID0gbWF0Y2hbMF07XG4gICAgICBjb25zdCBwcm90b2NvbEF0SW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgIGNvbnN0IGludGVybWVkaWF0ZSA9IHVybE9iamVjdC5wYXRobmFtZS5zbGljZShsYXN0SW5kZXgsIHByb3RvY29sQXRJbmRleCk7XG4gICAgICByZXN1bHQgKz0gaW50ZXJtZWRpYXRlLnJlcGxhY2UoL1xcL3syLH0vZywgXCIvXCIpO1xuICAgICAgcmVzdWx0ICs9IHByb3RvY29sO1xuICAgICAgbGFzdEluZGV4ID0gcHJvdG9jb2xBdEluZGV4ICsgcHJvdG9jb2wubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZW1uYW50ID0gdXJsT2JqZWN0LnBhdGhuYW1lLnNsaWNlKGxhc3RJbmRleCwgdXJsT2JqZWN0LnBhdGhuYW1lLmxlbmd0aCk7XG4gICAgcmVzdWx0ICs9IHJlbW5hbnQucmVwbGFjZSgvXFwvezIsfS9nLCBcIi9cIik7XG4gICAgdXJsT2JqZWN0LnBhdGhuYW1lID0gcmVzdWx0O1xuICB9XG4gIGlmICh1cmxPYmplY3QucGF0aG5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgdXJsT2JqZWN0LnBhdGhuYW1lID0gZGVjb2RlVVJJKHVybE9iamVjdC5wYXRobmFtZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4ID09PSB0cnVlKSB7XG4gICAgb3B0aW9ucy5yZW1vdmVEaXJlY3RvcnlJbmRleCA9IFsvXmluZGV4XFwuW2Etel0rJC9dO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucmVtb3ZlRGlyZWN0b3J5SW5kZXgpICYmIG9wdGlvbnMucmVtb3ZlRGlyZWN0b3J5SW5kZXgubGVuZ3RoID4gMCkge1xuICAgIGxldCBwYXRoQ29tcG9uZW50cyA9IHVybE9iamVjdC5wYXRobmFtZS5zcGxpdChcIi9cIik7XG4gICAgY29uc3QgbGFzdENvbXBvbmVudCA9IHBhdGhDb21wb25lbnRzW3BhdGhDb21wb25lbnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0ZXN0UGFyYW1ldGVyKGxhc3RDb21wb25lbnQsIG9wdGlvbnMucmVtb3ZlRGlyZWN0b3J5SW5kZXgpKSB7XG4gICAgICBwYXRoQ29tcG9uZW50cyA9IHBhdGhDb21wb25lbnRzLnNsaWNlKDAsIC0xKTtcbiAgICAgIHVybE9iamVjdC5wYXRobmFtZSA9IGAke3BhdGhDb21wb25lbnRzLnNsaWNlKDEpLmpvaW4oXCIvXCIpfS9gO1xuICAgIH1cbiAgfVxuICBpZiAodXJsT2JqZWN0Lmhvc3RuYW1lKSB7XG4gICAgdXJsT2JqZWN0Lmhvc3RuYW1lID0gdXJsT2JqZWN0Lmhvc3RuYW1lLnJlcGxhY2UoL1xcLiQvLCBcIlwiKTtcbiAgICBpZiAob3B0aW9ucy5zdHJpcFdXVyAmJiAvXnd3d1xcLig/IXd3d1xcLilbYS16XFwtXFxkXXsxLDYzfVxcLlthLXouXFwtXFxkXXsyLDYzfSQvLnRlc3QodXJsT2JqZWN0Lmhvc3RuYW1lKSkge1xuICAgICAgdXJsT2JqZWN0Lmhvc3RuYW1lID0gdXJsT2JqZWN0Lmhvc3RuYW1lLnJlcGxhY2UoL153d3dcXC4vLCBcIlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5yZW1vdmVRdWVyeVBhcmFtZXRlcnMpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgWy4uLnVybE9iamVjdC5zZWFyY2hQYXJhbXMua2V5cygpXSkge1xuICAgICAgaWYgKHRlc3RQYXJhbWV0ZXIoa2V5LCBvcHRpb25zLnJlbW92ZVF1ZXJ5UGFyYW1ldGVycykpIHtcbiAgICAgICAgdXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMua2VlcFF1ZXJ5UGFyYW1ldGVycykgJiYgb3B0aW9ucy5yZW1vdmVRdWVyeVBhcmFtZXRlcnMgPT09IHRydWUpIHtcbiAgICB1cmxPYmplY3Quc2VhcmNoID0gXCJcIjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmtlZXBRdWVyeVBhcmFtZXRlcnMpICYmIG9wdGlvbnMua2VlcFF1ZXJ5UGFyYW1ldGVycy5sZW5ndGggPiAwKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgWy4uLnVybE9iamVjdC5zZWFyY2hQYXJhbXMua2V5cygpXSkge1xuICAgICAgaWYgKCF0ZXN0UGFyYW1ldGVyKGtleSwgb3B0aW9ucy5rZWVwUXVlcnlQYXJhbWV0ZXJzKSkge1xuICAgICAgICB1cmxPYmplY3Quc2VhcmNoUGFyYW1zLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5zb3J0UXVlcnlQYXJhbWV0ZXJzKSB7XG4gICAgdXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5zb3J0KCk7XG4gICAgdHJ5IHtcbiAgICAgIHVybE9iamVjdC5zZWFyY2ggPSBkZWNvZGVVUklDb21wb25lbnQodXJsT2JqZWN0LnNlYXJjaCk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLnJlbW92ZVRyYWlsaW5nU2xhc2gpIHtcbiAgICB1cmxPYmplY3QucGF0aG5hbWUgPSB1cmxPYmplY3QucGF0aG5hbWUucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICB9XG4gIGlmIChvcHRpb25zLnJlbW92ZUV4cGxpY2l0UG9ydCAmJiB1cmxPYmplY3QucG9ydCkge1xuICAgIHVybE9iamVjdC5wb3J0ID0gXCJcIjtcbiAgfVxuICBjb25zdCBvbGRVcmxTdHJpbmcgPSB1cmxTdHJpbmc7XG4gIHVybFN0cmluZyA9IHVybE9iamVjdC50b1N0cmluZygpO1xuICBpZiAoIW9wdGlvbnMucmVtb3ZlU2luZ2xlU2xhc2ggJiYgdXJsT2JqZWN0LnBhdGhuYW1lID09PSBcIi9cIiAmJiAhb2xkVXJsU3RyaW5nLmVuZHNXaXRoKFwiL1wiKSAmJiB1cmxPYmplY3QuaGFzaCA9PT0gXCJcIikge1xuICAgIHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gIH1cbiAgaWYgKChvcHRpb25zLnJlbW92ZVRyYWlsaW5nU2xhc2ggfHwgdXJsT2JqZWN0LnBhdGhuYW1lID09PSBcIi9cIikgJiYgdXJsT2JqZWN0Lmhhc2ggPT09IFwiXCIgJiYgb3B0aW9ucy5yZW1vdmVTaW5nbGVTbGFzaCkge1xuICAgIHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gIH1cbiAgaWYgKGhhc1JlbGF0aXZlUHJvdG9jb2wgJiYgIW9wdGlvbnMubm9ybWFsaXplUHJvdG9jb2wpIHtcbiAgICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXmh0dHA6XFwvXFwvLywgXCIvL1wiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5zdHJpcFByb3RvY29sKSB7XG4gICAgdXJsU3RyaW5nID0gdXJsU3RyaW5nLnJlcGxhY2UoL14oPzpodHRwcz86KT9cXC9cXC8vLCBcIlwiKTtcbiAgfVxuICByZXR1cm4gdXJsU3RyaW5nO1xufVxuXG4vLyBzcmMvcmVsYXkvaW5kZXgudHNcbmltcG9ydCBkZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gXCJ0c2VlcFwiO1xuXG4vLyBzcmMvcmVsYXkvY29ubmVjdGl2aXR5LnRzXG52YXIgTUFYX1JFQ09OTkVDVF9BVFRFTVBUUyA9IDU7XG52YXIgRkxBUFBJTkdfVEhSRVNIT0xEX01TID0gMWUzO1xudmFyIE5ES1JlbGF5Q29ubmVjdGl2aXR5ID0gY2xhc3Mge1xuICBuZGtSZWxheTtcbiAgd3M7XG4gIF9zdGF0dXM7XG4gIHRpbWVvdXRNcztcbiAgY29ubmVjdGVkQXQ7XG4gIF9jb25uZWN0aW9uU3RhdHMgPSB7XG4gICAgYXR0ZW1wdHM6IDAsXG4gICAgc3VjY2VzczogMCxcbiAgICBkdXJhdGlvbnM6IFtdXG4gIH07XG4gIGRlYnVnO1xuICBuZXREZWJ1ZztcbiAgY29ubmVjdFRpbWVvdXQ7XG4gIHJlY29ubmVjdFRpbWVvdXQ7XG4gIG5kaztcbiAgb3BlblN1YnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBvcGVuQ291bnRSZXF1ZXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIG9wZW5FdmVudFB1Ymxpc2hlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHNlcmlhbCA9IDA7XG4gIGJhc2VFb3NlVGltZW91dCA9IDQ0MDA7XG4gIGNvbnN0cnVjdG9yKG5ka1JlbGF5LCBuZGspIHtcbiAgICB0aGlzLm5ka1JlbGF5ID0gbmRrUmVsYXk7XG4gICAgdGhpcy5fc3RhdHVzID0gMSAvKiBESVNDT05ORUNURUQgKi87XG4gICAgY29uc3QgcmFuZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlMyk7XG4gICAgdGhpcy5kZWJ1ZyA9IHRoaXMubmRrUmVsYXkuZGVidWcuZXh0ZW5kKGBjb25uZWN0aXZpdHkke3JhbmR9YCk7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIHRoZSBOREsgcmVsYXkgYW5kIGhhbmRsZXMgdGhlIGNvbm5lY3Rpb24gbGlmZWN5Y2xlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBhdHRlbXB0cyB0byBlc3RhYmxpc2ggYSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgTkRLIHJlbGF5IHNwZWNpZmllZCBpbiB0aGUgYG5ka1JlbGF5YCBvYmplY3QuXG4gICAqIElmIHRoZSBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWwsIGl0IHVwZGF0ZXMgdGhlIGNvbm5lY3Rpb24gc3RhdGlzdGljcywgc2V0cyB0aGUgY29ubmVjdGlvbiBzdGF0dXMgdG8gYENPTk5FQ1RFRGAsXG4gICAqIGFuZCBlbWl0cyBgY29ubmVjdGAgYW5kIGByZWFkeWAgZXZlbnRzIG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdC5cbiAgICpcbiAgICogSWYgdGhlIGNvbm5lY3Rpb24gYXR0ZW1wdCBmYWlscywgaXQgaGFuZGxlcyB0aGUgZXJyb3IgYnkgZWl0aGVyIGluaXRpYXRpbmcgYSByZWNvbm5lY3Rpb24gYXR0ZW1wdCBvciBlbWl0dGluZyBhXG4gICAqIGBkZWxheWVkLWNvbm5lY3RgIGV2ZW50IG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdCwgZGVwZW5kaW5nIG9uIHRoZSBgcmVjb25uZWN0YCBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB0aW1lb3V0TXMgLSBUaGUgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQuIElmIG5vdCBwcm92aWRlZCwgdGhlIGRlZmF1bHQgdGltZW91dCBmcm9tIHRoZSBgbmRrUmVsYXlgIG9iamVjdCBpcyB1c2VkLlxuICAgKiBAcGFyYW0gcmVjb25uZWN0IC0gSW5kaWNhdGVzIHdoZXRoZXIgYSByZWNvbm5lY3Rpb24gc2hvdWxkIGJlIGF0dGVtcHRlZCBpZiB0aGUgY29ubmVjdGlvbiBmYWlscy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLCBvciByZWplY3RzIGlmIHRoZSBjb25uZWN0aW9uIGZhaWxzLlxuICAgKi9cbiAgYXN5bmMgY29ubmVjdCh0aW1lb3V0TXMsIHJlY29ubmVjdCA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5fc3RhdHVzICE9PSAyIC8qIFJFQ09OTkVDVElORyAqLyAmJiB0aGlzLl9zdGF0dXMgIT09IDEgLyogRElTQ09OTkVDVEVEICovIHx8IHRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgdGhpcy5kZWJ1ZyhcbiAgICAgICAgXCJSZWxheSByZXF1ZXN0ZWQgdG8gYmUgY29ubmVjdGVkIGJ1dCB3YXMgaW4gc3RhdGUgJXMgb3IgaXQgaGFkIGEgcmVjb25uZWN0IHRpbWVvdXRcIixcbiAgICAgICAgdGhpcy5fc3RhdHVzXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lb3V0KTtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0KTtcbiAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIHRpbWVvdXRNcyA/Pz0gdGhpcy50aW1lb3V0TXM7XG4gICAgaWYgKCF0aGlzLnRpbWVvdXRNcyAmJiB0aW1lb3V0TXMpIHRoaXMudGltZW91dE1zID0gdGltZW91dE1zO1xuICAgIGlmICh0aGlzLnRpbWVvdXRNcykgdGhpcy5jb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5vbkNvbm5lY3Rpb25FcnJvcihyZWNvbm5lY3QpLCB0aGlzLnRpbWVvdXRNcyk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvblN0YXRzLmF0dGVtcHQoKTtcbiAgICAgIGlmICh0aGlzLl9zdGF0dXMgPT09IDEgLyogRElTQ09OTkVDVEVEICovKSB0aGlzLl9zdGF0dXMgPSA0IC8qIENPTk5FQ1RJTkcgKi87XG4gICAgICBlbHNlIHRoaXMuX3N0YXR1cyA9IDIgLyogUkVDT05ORUNUSU5HICovO1xuICAgICAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQodGhpcy5uZGtSZWxheS51cmwpO1xuICAgICAgdGhpcy53cy5vbm9wZW4gPSB0aGlzLm9uQ29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy53cy5vbmNsb3NlID0gdGhpcy5vbkRpc2Nvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gdGhpcy5vbk1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMud3Mub25lcnJvciA9IHRoaXMub25FcnJvci5iaW5kKHRoaXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZGVidWcoYEZhaWxlZCB0byBjb25uZWN0IHRvICR7dGhpcy5uZGtSZWxheS51cmx9YCwgZSk7XG4gICAgICB0aGlzLl9zdGF0dXMgPSAxIC8qIERJU0NPTk5FQ1RFRCAqLztcbiAgICAgIGlmIChyZWNvbm5lY3QpIHRoaXMuaGFuZGxlUmVjb25uZWN0aW9uKCk7XG4gICAgICBlbHNlIHRoaXMubmRrUmVsYXkuZW1pdChcImRlbGF5ZWQtY29ubmVjdFwiLCAyICogMjQgKiA2MCAqIDYwICogMWUzKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIE5ESyByZWxheS5cbiAgICogVGhpcyBtZXRob2Qgc2V0cyB0aGUgY29ubmVjdGlvbiBzdGF0dXMgdG8gYE5ES1JlbGF5U3RhdHVzLkRJU0NPTk5FQ1RJTkdgLFxuICAgKiBhdHRlbXB0cyB0byBjbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24sIGFuZCBzZXRzIHRoZSBzdGF0dXMgdG9cbiAgICogYE5ES1JlbGF5U3RhdHVzLkRJU0NPTk5FQ1RFRGAgaWYgdGhlIGRpc2Nvbm5lY3Qgb3BlcmF0aW9uIGZhaWxzLlxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLl9zdGF0dXMgPSAwIC8qIERJU0NPTk5FQ1RJTkcgKi87XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMud3M/LmNsb3NlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5kZWJ1ZyhcIkZhaWxlZCB0byBkaXNjb25uZWN0XCIsIGUpO1xuICAgICAgdGhpcy5fc3RhdHVzID0gMSAvKiBESVNDT05ORUNURUQgKi87XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBlcnJvciB0aGF0IG9jY3VycmVkIHdoZW4gYXR0ZW1wdGluZyB0byBjb25uZWN0IHRvIHRoZSBOREsgcmVsYXkuXG4gICAqIElmIGByZWNvbm5lY3RgIGlzIGB0cnVlYCwgdGhpcyBtZXRob2Qgd2lsbCBpbml0aWF0ZSBhIHJlY29ubmVjdGlvbiBhdHRlbXB0LlxuICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgZW1pdCBhIGBkZWxheWVkLWNvbm5lY3RgIGV2ZW50IG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdCxcbiAgICogaW5kaWNhdGluZyB0aGF0IGEgcmVjb25uZWN0aW9uIHNob3VsZCBiZSBhdHRlbXB0ZWQgYWZ0ZXIgYSBkZWxheS5cbiAgICpcbiAgICogQHBhcmFtIHJlY29ubmVjdCAtIEluZGljYXRlcyB3aGV0aGVyIGEgcmVjb25uZWN0aW9uIHNob3VsZCBiZSBhdHRlbXB0ZWQuXG4gICAqL1xuICBvbkNvbm5lY3Rpb25FcnJvcihyZWNvbm5lY3QpIHtcbiAgICB0aGlzLmRlYnVnKGBFcnJvciBjb25uZWN0aW5nIHRvICR7dGhpcy5uZGtSZWxheS51cmx9YCwgdGhpcy50aW1lb3V0TXMpO1xuICAgIGlmIChyZWNvbm5lY3QgJiYgIXRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgdGhpcy5oYW5kbGVSZWNvbm5lY3Rpb24oKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGNvbm5lY3Rpb24gZXZlbnQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsbHkgb3BlbmVkLlxuICAgKiBJdCBjbGVhcnMgYW55IGV4aXN0aW5nIGNvbm5lY3Rpb24gYW5kIHJlY29ubmVjdGlvbiB0aW1lb3V0cywgdXBkYXRlcyB0aGUgY29ubmVjdGlvbiBzdGF0aXN0aWNzLFxuICAgKiBzZXRzIHRoZSBjb25uZWN0aW9uIHN0YXR1cyB0byBgQ09OTkVDVEVEYCwgYW5kIGVtaXRzIGBjb25uZWN0YCBhbmQgYHJlYWR5YCBldmVudHMgb24gdGhlIGBuZGtSZWxheWAgb2JqZWN0LlxuICAgKi9cbiAgb25Db25uZWN0KCkge1xuICAgIHRoaXMubmV0RGVidWc/LihcImNvbm5lY3RlZFwiLCB0aGlzLm5ka1JlbGF5KTtcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lb3V0KTtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0KTtcbiAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvblN0YXRzLmNvbm5lY3RlZCgpO1xuICAgIHRoaXMuX3N0YXR1cyA9IDUgLyogQ09OTkVDVEVEICovO1xuICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImNvbm5lY3RcIik7XG4gICAgdGhpcy5uZGtSZWxheS5lbWl0KFwicmVhZHlcIik7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGRpc2Nvbm5lY3Rpb24gZXZlbnQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgY2xvc2VkLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bGx5IGNsb3NlZC5cbiAgICogSXQgdXBkYXRlcyB0aGUgY29ubmVjdGlvbiBzdGF0aXN0aWNzLCBzZXRzIHRoZSBjb25uZWN0aW9uIHN0YXR1cyB0byBgRElTQ09OTkVDVEVEYCxcbiAgICogaW5pdGlhdGVzIGEgcmVjb25uZWN0aW9uIGF0dGVtcHQgaWYgd2UgZGlkbid0IGRpc2Nvbm5lY3Qgb3Vyc2VsdmVzLFxuICAgKiBhbmQgZW1pdHMgYSBgZGlzY29ubmVjdGAgZXZlbnQgb24gdGhlIGBuZGtSZWxheWAgb2JqZWN0LlxuICAgKi9cbiAgb25EaXNjb25uZWN0KCkge1xuICAgIHRoaXMubmV0RGVidWc/LihcImRpc2Nvbm5lY3RlZFwiLCB0aGlzLm5ka1JlbGF5KTtcbiAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25TdGF0cy5kaXNjb25uZWN0ZWQoKTtcbiAgICBpZiAodGhpcy5fc3RhdHVzID09PSA1IC8qIENPTk5FQ1RFRCAqLykge1xuICAgICAgdGhpcy5oYW5kbGVSZWNvbm5lY3Rpb24oKTtcbiAgICB9XG4gICAgdGhpcy5fc3RhdHVzID0gMSAvKiBESVNDT05ORUNURUQgKi87XG4gICAgdGhpcy5uZGtSZWxheS5lbWl0KFwiZGlzY29ubmVjdFwiKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBpbmNvbWluZyBtZXNzYWdlcyBmcm9tIHRoZSBOREsgcmVsYXkgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuZXZlciBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgcmVsYXkuXG4gICAqIEl0IHBhcnNlcyB0aGUgbWVzc2FnZSBkYXRhIGFuZCBkaXNwYXRjaGVzIHRoZSBhcHByb3ByaWF0ZSBoYW5kbGluZyBsb2dpYyBiYXNlZCBvbiB0aGUgbWVzc2FnZSB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgTWVzc2FnZUV2ZW50IGNvbnRhaW5pbmcgdGhlIHJlY2VpdmVkIG1lc3NhZ2UgZGF0YS5cbiAgICovXG4gIG9uTWVzc2FnZShldmVudCkge1xuICAgIHRoaXMubmV0RGVidWc/LihldmVudC5kYXRhLCB0aGlzLm5ka1JlbGF5LCBcInJlY3ZcIik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgY29uc3QgW2NtZCwgaWQsIC4uLl9yZXN0XSA9IGRhdGE7XG4gICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICBjYXNlIFwiRVZFTlRcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoaWQpO1xuICAgICAgICAgIGNvbnN0IGV2ZW50MiA9IGRhdGFbMl07XG4gICAgICAgICAgaWYgKCFzbykge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhgUmVjZWl2ZWQgZXZlbnQgZm9yIHVua25vd24gc3Vic2NyaXB0aW9uICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvLm9uZXZlbnQoZXZlbnQyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkNPVU5UXCI6IHtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YVsyXTtcbiAgICAgICAgICBjb25zdCBjciA9IHRoaXMub3BlbkNvdW50UmVxdWVzdHMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoY3IpIHtcbiAgICAgICAgICAgIGNyLnJlc29sdmUocGF5bG9hZC5jb3VudCk7XG4gICAgICAgICAgICB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiRU9TRVwiOiB7XG4gICAgICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChpZCk7XG4gICAgICAgICAgaWYgKCFzbykgcmV0dXJuO1xuICAgICAgICAgIHNvLm9uZW9zZShpZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPS1wiOiB7XG4gICAgICAgICAgY29uc3Qgb2sgPSBkYXRhWzJdO1xuICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGRhdGFbM107XG4gICAgICAgICAgY29uc3QgZXAgPSB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5nZXQoaWQpO1xuICAgICAgICAgIGNvbnN0IGZpcnN0RXAgPSBlcD8ucG9wKCk7XG4gICAgICAgICAgaWYgKCFlcCB8fCAhZmlyc3RFcCkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIlJlY2VpdmVkIE9LIGZvciB1bmtub3duIGV2ZW50IHB1Ymxpc2hcIiwgaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2spIGZpcnN0RXAucmVzb2x2ZShyZWFzb24pO1xuICAgICAgICAgIGVsc2UgZmlyc3RFcC5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgICAgICAgIGlmIChlcC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChpZCwgZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkNMT1NFRFwiOiB7XG4gICAgICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChpZCk7XG4gICAgICAgICAgaWYgKCFzbykgcmV0dXJuO1xuICAgICAgICAgIHNvLm9uY2xvc2VkKGRhdGFbMl0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiTk9USUNFXCI6XG4gICAgICAgICAgdGhpcy5vbk5vdGljZShkYXRhWzFdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJBVVRIXCI6IHtcbiAgICAgICAgICB0aGlzLm9uQXV0aFJlcXVlc3RlZChkYXRhWzFdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5kZWJ1ZyhgRXJyb3IgcGFyc2luZyBtZXNzYWdlIGZyb20gJHt0aGlzLm5ka1JlbGF5LnVybH06ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcj8uc3RhY2spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBhbiBhdXRoZW50aWNhdGlvbiByZXF1ZXN0IGZyb20gdGhlIE5ESyByZWxheS5cbiAgICpcbiAgICogSWYgYW4gYXV0aGVudGljYXRpb24gcG9saWN5IGlzIGNvbmZpZ3VyZWQsIGl0IHdpbGwgYmUgdXNlZCB0byBhdXRoZW50aWNhdGUgdGhlIGNvbm5lY3Rpb24uXG4gICAqIE90aGVyd2lzZSwgdGhlIGBhdXRoYCBldmVudCB3aWxsIGJlIGVtaXR0ZWQgdG8gYWxsb3cgdGhlIGFwcGxpY2F0aW9uIHRvIGhhbmRsZSB0aGUgYXV0aGVudGljYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBjaGFsbGVuZ2UgLSBUaGUgYXV0aGVudGljYXRpb24gY2hhbGxlbmdlIHByb3ZpZGVkIGJ5IHRoZSBOREsgcmVsYXkuXG4gICAqL1xuICBhc3luYyBvbkF1dGhSZXF1ZXN0ZWQoY2hhbGxlbmdlKSB7XG4gICAgY29uc3QgYXV0aFBvbGljeSA9IHRoaXMubmRrUmVsYXkuYXV0aFBvbGljeSA/PyB0aGlzLm5kaz8ucmVsYXlBdXRoRGVmYXVsdFBvbGljeTtcbiAgICB0aGlzLmRlYnVnKFwiUmVsYXkgcmVxdWVzdGVkIGF1dGhlbnRpY2F0aW9uXCIsIHtcbiAgICAgIGhhdmVQb2xpY3k6ICEhYXV0aFBvbGljeVxuICAgIH0pO1xuICAgIGlmICh0aGlzLl9zdGF0dXMgPT09IDcgLyogQVVUSEVOVElDQVRJTkcgKi8pIHtcbiAgICAgIHRoaXMuZGVidWcoXCJBbHJlYWR5IGF1dGhlbnRpY2F0aW5nLCBpZ25vcmluZ1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc3RhdHVzID0gNiAvKiBBVVRIX1JFUVVFU1RFRCAqLztcbiAgICBpZiAoYXV0aFBvbGljeSkge1xuICAgICAgaWYgKHRoaXMuX3N0YXR1cyA+PSA1IC8qIENPTk5FQ1RFRCAqLykge1xuICAgICAgICB0aGlzLl9zdGF0dXMgPSA3IC8qIEFVVEhFTlRJQ0FUSU5HICovO1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcyA9IGF3YWl0IGF1dGhQb2xpY3kodGhpcy5uZGtSZWxheSwgY2hhbGxlbmdlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMuZGVidWcoXCJBdXRoZW50aWNhdGlvbiBwb2xpY3kgdGhyZXcgYW4gZXJyb3JcIiwgZSk7XG4gICAgICAgICAgcmVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJ1ZyhcIkF1dGhlbnRpY2F0aW9uIHBvbGljeSByZXR1cm5lZFwiLCAhIXJlcyk7XG4gICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBOREtFdmVudCB8fCByZXMgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXV0aChyZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhdXRoZW50aWNhdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovICYmIHRoaXMuX3N0YXR1cyA8IDggLyogQVVUSEVOVElDQVRFRCAqLykge1xuICAgICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kayk7XG4gICAgICAgICAgICAgIGV2ZW50LmtpbmQgPSAyMjI0MiAvKiBDbGllbnRBdXRoICovO1xuICAgICAgICAgICAgICBldmVudC50YWdzID0gW1xuICAgICAgICAgICAgICAgIFtcInJlbGF5XCIsIHRoaXMubmRrUmVsYXkudXJsXSxcbiAgICAgICAgICAgICAgICBbXCJjaGFsbGVuZ2VcIiwgY2hhbGxlbmdlXVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICBhd2FpdCBldmVudC5zaWduKCk7XG4gICAgICAgICAgICAgIHRoaXMuYXV0aChldmVudCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gOCAvKiBBVVRIRU5USUNBVEVEICovO1xuICAgICAgICAgICAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImF1dGhlZFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKFwiQXV0aGVudGljYXRpb24gc3VjY2Vzc2Z1bFwiKTtcbiAgICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSA2IC8qIEFVVEhfUkVRVUVTVEVEICovO1xuICAgICAgICAgICAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImF1dGg6ZmFpbGVkXCIsIGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoXCJBdXRoZW50aWNhdGlvbiBmYWlsZWRcIiwgZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIkF1dGhlbnRpY2F0aW9uIGZhaWxlZCwgaXQgY2hhbmdlZCBzdGF0dXMsIHN0YXR1cyBpcyAlZFwiLCB0aGlzLl9zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHJlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5kaz8uc2lnbmVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVidWcoXCJObyBzaWduZXIgYXZhaWxhYmxlIGZvciBhdXRoZW50aWNhdGlvbiBsb2NhbGhvc3RcIik7XG4gICAgICAgICAgICAgIHRoaXMubmRrPy5vbmNlKFwic2lnbmVyOnJlYWR5XCIsIGF1dGhlbnRpY2F0ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhdXRoZW50aWNhdGUoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhdXRoZW50aWNhdGluZ1wiLCBlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IDUgLyogQ09OTkVDVEVEICovO1xuICAgICAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImF1dGhlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJhdXRoXCIsIGNoYWxsZW5nZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGVycm9ycyB0aGF0IG9jY3VyIG9uIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgcmVsYXkuXG4gICAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciBvciBldmVudCB0aGF0IG9jY3VycmVkLlxuICAgKi9cbiAgb25FcnJvcihlcnJvcikge1xuICAgIHRoaXMuZGVidWcoYFdlYlNvY2tldCBlcnJvciBvbiAke3RoaXMubmRrUmVsYXkudXJsfTpgLCBlcnJvcik7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBOREsgcmVsYXkgY29ubmVjdGlvbi5cbiAgICogQHJldHVybnMge05ES1JlbGF5U3RhdHVzfSBUaGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIE5ESyByZWxheSBjb25uZWN0aW9uLlxuICAgKi9cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIE5ESyByZWxheSBjb25uZWN0aW9uIGlzIGN1cnJlbnRseSBhdmFpbGFibGUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHJlbGF5IGNvbm5lY3Rpb24gaXMgaW4gdGhlIGBDT05ORUNURURgIHN0YXR1cywgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqL1xuICBpc0F2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzID09PSA1IC8qIENPTk5FQ1RFRCAqLztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBOREsgcmVsYXkgY29ubmVjdGlvbiBpcyBmbGFwcGluZywgd2hpY2ggbWVhbnMgdGhlIGNvbm5lY3Rpb24gaXMgcmFwaWRseVxuICAgKiBkaXNjb25uZWN0aW5nIGFuZCByZWNvbm5lY3RpbmcuIFRoaXMgaXMgZGV0ZXJtaW5lZCBieSBhbmFseXppbmcgdGhlIGR1cmF0aW9ucyBvZiB0aGVcbiAgICogbGFzdCB0aHJlZSBjb25uZWN0aW9uIGF0dGVtcHRzLiBJZiB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSBkdXJhdGlvbnMgaXMgbGVzc1xuICAgKiB0aGFuIDEwMDAgbWlsbGlzZWNvbmRzLCB0aGUgY29ubmVjdGlvbiBpcyBjb25zaWRlcmVkIHRvIGJlIGZsYXBwaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBjb25uZWN0aW9uIGlzIGZsYXBwaW5nLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICovXG4gIGlzRmxhcHBpbmcoKSB7XG4gICAgY29uc3QgZHVyYXRpb25zID0gdGhpcy5fY29ubmVjdGlvblN0YXRzLmR1cmF0aW9ucztcbiAgICBpZiAoZHVyYXRpb25zLmxlbmd0aCAlIDMgIT09IDApIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBzdW0gPSBkdXJhdGlvbnMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gICAgY29uc3QgYXZnID0gc3VtIC8gZHVyYXRpb25zLmxlbmd0aDtcbiAgICBjb25zdCB2YXJpYW5jZSA9IGR1cmF0aW9ucy5tYXAoKHgpID0+ICh4IC0gYXZnKSAqKiAyKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIGR1cmF0aW9ucy5sZW5ndGg7XG4gICAgY29uc3Qgc3RkRGV2ID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcbiAgICBjb25zdCBpc0ZsYXBwaW5nID0gc3RkRGV2IDwgRkxBUFBJTkdfVEhSRVNIT0xEX01TO1xuICAgIHJldHVybiBpc0ZsYXBwaW5nO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgbm90aWNlIHJlY2VpdmVkIGZyb20gdGhlIE5ESyByZWxheS5cbiAgICogSWYgdGhlIG5vdGljZSBpbmRpY2F0ZXMgdGhlIHJlbGF5IGlzIGNvbXBsYWluaW5nIChlLmcuIFwidG9vIG1hbnlcIiBvciBcIm1heGltdW1cIiksXG4gICAqIHRoZSBtZXRob2QgZGlzY29ubmVjdHMgZnJvbSB0aGUgcmVsYXkgYW5kIGF0dGVtcHRzIHRvIHJlY29ubmVjdCBhZnRlciBhIDItc2Vjb25kIGRlbGF5LlxuICAgKiBBIGRlYnVnIG1lc3NhZ2UgaXMgbG9nZ2VkIHdpdGggdGhlIHJlbGF5IFVSTCBhbmQgdGhlIG5vdGljZSB0ZXh0LlxuICAgKiBUaGUgXCJub3RpY2VcIiBldmVudCBpcyBlbWl0dGVkIG9uIHRoZSBuZGtSZWxheSBpbnN0YW5jZSB3aXRoIHRoZSBub3RpY2UgdGV4dC5cbiAgICpcbiAgICogQHBhcmFtIG5vdGljZSAtIFRoZSBub3RpY2UgdGV4dCByZWNlaXZlZCBmcm9tIHRoZSBOREsgcmVsYXkuXG4gICAqL1xuICBhc3luYyBvbk5vdGljZShub3RpY2UpIHtcbiAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJub3RpY2VcIiwgbm90aWNlKTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gcmVjb25uZWN0IHRvIHRoZSBOREsgcmVsYXkgYWZ0ZXIgYSBjb25uZWN0aW9uIGlzIGxvc3QuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHJlY3Vyc2l2ZWx5IHRvIGhhbmRsZSBtdWx0aXBsZSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMuXG4gICAqIEl0IGNoZWNrcyBpZiB0aGUgcmVsYXkgaXMgZmxhcHBpbmcgYW5kIGVtaXRzIGEgXCJmbGFwcGluZ1wiIGV2ZW50IGlmIHNvLlxuICAgKiBJdCB0aGVuIGNhbGN1bGF0ZXMgYSBkZWxheSBiZWZvcmUgdGhlIG5leHQgcmVjb25uZWN0aW9uIGF0dGVtcHQgYmFzZWQgb24gdGhlIG51bWJlciBvZiBwcmV2aW91cyBhdHRlbXB0cy5cbiAgICogVGhlIGZ1bmN0aW9uIHNldHMgYSB0aW1lb3V0IHRvIGV4ZWN1dGUgdGhlIG5leHQgcmVjb25uZWN0aW9uIGF0dGVtcHQgYWZ0ZXIgdGhlIGNhbGN1bGF0ZWQgZGVsYXkuXG4gICAqIElmIHRoZSBtYXhpbXVtIG51bWJlciBvZiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgaXMgcmVhY2hlZCwgYSBkZWJ1ZyBtZXNzYWdlIGlzIGxvZ2dlZC5cbiAgICpcbiAgICogQHBhcmFtIGF0dGVtcHQgLSBUaGUgY3VycmVudCBhdHRlbXB0IG51bWJlciAoZGVmYXVsdCBpcyAwKS5cbiAgICovXG4gIGhhbmRsZVJlY29ubmVjdGlvbihhdHRlbXB0ID0gMCkge1xuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHJldHVybjtcbiAgICBpZiAodGhpcy5pc0ZsYXBwaW5nKCkpIHtcbiAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImZsYXBwaW5nXCIsIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cyk7XG4gICAgICB0aGlzLl9zdGF0dXMgPSAzIC8qIEZMQVBQSU5HICovO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWNvbm5lY3REZWxheSA9IHRoaXMuY29ubmVjdGVkQXQgPyBNYXRoLm1heCgwLCA2ZTQgLSAoRGF0ZS5ub3coKSAtIHRoaXMuY29ubmVjdGVkQXQpKSA6IDVlMyAqICh0aGlzLl9jb25uZWN0aW9uU3RhdHMuYXR0ZW1wdHMgKyAxKTtcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IDIgLyogUkVDT05ORUNUSU5HICovO1xuICAgICAgdGhpcy5jb25uZWN0KCkuY2F0Y2goKF9lcnIpID0+IHtcbiAgICAgICAgaWYgKGF0dGVtcHQgPCBNQVhfUkVDT05ORUNUX0FUVEVNUFRTKSB7XG4gICAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZWNvbm5lY3Rpb24oYXR0ZW1wdCArIDEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDFlMyAqIChhdHRlbXB0ICsgMSkgXiA0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRlYnVnKFwiUmVjb25uZWN0IGZhaWxlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgcmVjb25uZWN0RGVsYXkpO1xuICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImRlbGF5ZWQtY29ubmVjdFwiLCByZWNvbm5lY3REZWxheSk7XG4gICAgdGhpcy5kZWJ1ZyhcIlJlY29ubmVjdGluZyBpblwiLCByZWNvbm5lY3REZWxheSk7XG4gICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLm5leHRSZWNvbm5lY3RBdCA9IERhdGUubm93KCkgKyByZWNvbm5lY3REZWxheTtcbiAgfVxuICAvKipcbiAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBOREsgcmVsYXkgaWYgdGhlIGNvbm5lY3Rpb24gaXMgaW4gdGhlIENPTk5FQ1RFRCBzdGF0ZSBhbmQgdGhlIFdlYlNvY2tldCBpcyBvcGVuLlxuICAgKiBJZiB0aGUgY29ubmVjdGlvbiBpcyBub3QgaW4gdGhlIENPTk5FQ1RFRCBzdGF0ZSBvciB0aGUgV2ViU29ja2V0IGlzIG5vdCBvcGVuLCBsb2dzIGEgZGVidWcgbWVzc2FnZSBhbmQgdGhyb3dzIGFuIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIHNlbmQgdG8gdGhlIE5ESyByZWxheS5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIGF0dGVtcHRpbmcgdG8gc2VuZCBvbiBhIGNsb3NlZCByZWxheSBjb25uZWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgc2VuZChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuX3N0YXR1cyA+PSA1IC8qIENPTk5FQ1RFRCAqLyAmJiB0aGlzLndzPy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgdGhpcy53cz8uc2VuZChtZXNzYWdlKTtcbiAgICAgIHRoaXMubmV0RGVidWc/LihtZXNzYWdlLCB0aGlzLm5ka1JlbGF5LCBcInNlbmRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVidWcoYE5vdCBjb25uZWN0ZWQgdG8gJHt0aGlzLm5ka1JlbGF5LnVybH0gKCVkKSwgbm90IHNlbmRpbmcgbWVzc2FnZSAke21lc3NhZ2V9YCwgdGhpcy5fc3RhdHVzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEF1dGhlbnRpY2F0ZXMgdGhlIE5ESyBldmVudCBieSBzZW5kaW5nIGl0IHRvIHRoZSBOREsgcmVsYXkgYW5kIHJldHVybmluZyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBOREsgZXZlbnQgdG8gYXV0aGVudGljYXRlLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBhdXRoZW50aWNhdGlvbiByZXN1bHQuXG4gICAqL1xuICBhc3luYyBhdXRoKGV2ZW50KSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdmFsID0gdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZ2V0KGV2ZW50LmlkKSA/PyBbXTtcbiAgICAgIHZhbC5wdXNoKHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuc2V0KGV2ZW50LmlkLCB2YWwpO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZChgW1wiQVVUSFwiLCR7SlNPTi5zdHJpbmdpZnkoZXZlbnQucmF3RXZlbnQoKSl9XWApO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2hlcyBhbiBOREsgZXZlbnQgdG8gdGhlIHJlbGF5IGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIE5ESyBldmVudCB0byBwdWJsaXNoLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIGV2ZW50IHB1YmxpY2F0aW9uLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYXR0ZW1wdGluZyB0byBwdWJsaXNoIG9uIGEgY2xvc2VkIHJlbGF5IGNvbm5lY3Rpb24uXG4gICAqL1xuICBhc3luYyBwdWJsaXNoKGV2ZW50KSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdmFsID0gdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZ2V0KGV2ZW50LmlkKSA/PyBbXTtcbiAgICAgIGlmICh2YWwubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYER1cGxpY2F0ZSBldmVudCBwdWJsaXNoaW5nIGRldGVjdGVkLCB5b3UgYXJlIHB1Ymxpc2hpbmcgZXZlbnQgJHtldmVudC5pZH0gdHdpY2VgKTtcbiAgICAgIH1cbiAgICAgIHZhbC5wdXNoKHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuc2V0KGV2ZW50LmlkLCB2YWwpO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZChgW1wiRVZFTlRcIiwke0pTT04uc3RyaW5naWZ5KGV2ZW50KX1dYCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAvKipcbiAgICogQ291bnRzIHRoZSBudW1iZXIgb2YgZXZlbnRzIHRoYXQgbWF0Y2ggdGhlIHByb3ZpZGVkIGZpbHRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSBmaWx0ZXJzIC0gVGhlIGZpbHRlcnMgdG8gYXBwbHkgdG8gdGhlIGNvdW50IHJlcXVlc3QuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBBbiBvcHRpb25hbCBvYmplY3QgY29udGFpbmluZyBhIGN1c3RvbSBpZCBmb3IgdGhlIGNvdW50IHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG51bWJlciBvZiBtYXRjaGluZyBldmVudHMuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhdHRlbXB0aW5nIHRvIHNlbmQgdGhlIGNvdW50IHJlcXVlc3Qgb24gYSBjbG9zZWQgcmVsYXkgY29ubmVjdGlvbi5cbiAgICovXG4gIGFzeW5jIGNvdW50KGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHRoaXMuc2VyaWFsKys7XG4gICAgY29uc3QgaWQgPSBwYXJhbXM/LmlkIHx8IGBjb3VudDoke3RoaXMuc2VyaWFsfWA7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5zZXQoaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZChgW1wiQ09VTlRcIixcIiR7aWR9XCIsJHtKU09OLnN0cmluZ2lmeShmaWx0ZXJzKS5zdWJzdHJpbmcoMSl9YCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBjbG9zZShzdWJJZCwgcmVhc29uKSB7XG4gICAgdGhpcy5zZW5kKGBbXCJDTE9TRVwiLFwiJHtzdWJJZH1cIl1gKTtcbiAgICBjb25zdCBzdWIgPSB0aGlzLm9wZW5TdWJzLmdldChzdWJJZCk7XG4gICAgdGhpcy5vcGVuU3Vicy5kZWxldGUoc3ViSWQpO1xuICAgIGlmIChzdWIpIHN1Yi5vbmNsb3NlKHJlYXNvbik7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZXMgdG8gdGhlIE5ESyByZWxheSB3aXRoIHRoZSBwcm92aWRlZCBmaWx0ZXJzIGFuZCBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gZmlsdGVycyAtIFRoZSBmaWx0ZXJzIHRvIGFwcGx5IHRvIHRoZSBzdWJzY3JpcHRpb24uXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgc3Vic2NyaXB0aW9uIHBhcmFtZXRlcnMsIGluY2x1ZGluZyBhbiBvcHRpb25hbCBjdXN0b20gaWQuXG4gICAqIEByZXR1cm5zIEEgbmV3IE5ES1JlbGF5U3Vic2NyaXB0aW9uIGluc3RhbmNlLlxuICAgKi9cbiAgcmVxKHJlbGF5U3ViKSB7XG4gICAgYCR7dGhpcy5zZW5kKGBbXCJSRVFcIixcIiR7cmVsYXlTdWIuc3ViSWR9XCIsJHtKU09OLnN0cmluZ2lmeShyZWxheVN1Yi5leGVjdXRlRmlsdGVycykuc3Vic3RyaW5nKDEpfWApfV1gO1xuICAgIHRoaXMub3BlblN1YnMuc2V0KHJlbGF5U3ViLnN1YklkLCByZWxheVN1Yik7XG4gIH1cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHVwZGF0ZSB0aGUgY29ubmVjdGlvbiBzdGF0cy5cbiAgICovXG4gIHVwZGF0ZUNvbm5lY3Rpb25TdGF0cyA9IHtcbiAgICBjb25uZWN0ZWQ6ICgpID0+IHtcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5zdWNjZXNzKys7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuY29ubmVjdGVkQXQgPSBEYXRlLm5vdygpO1xuICAgIH0sXG4gICAgZGlzY29ubmVjdGVkOiAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fY29ubmVjdGlvblN0YXRzLmNvbm5lY3RlZEF0KSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5kdXJhdGlvbnMucHVzaChEYXRlLm5vdygpIC0gdGhpcy5fY29ubmVjdGlvblN0YXRzLmNvbm5lY3RlZEF0KTtcbiAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5kdXJhdGlvbnMubGVuZ3RoID4gMTAwKSB7XG4gICAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmR1cmF0aW9ucy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuY29ubmVjdGVkQXQgPSB2b2lkIDA7XG4gICAgfSxcbiAgICBhdHRlbXB0OiAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuYXR0ZW1wdHMrKztcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgfVxuICB9O1xuICAvKiogUmV0dXJucyB0aGUgY29ubmVjdGlvbiBzdGF0cy4gKi9cbiAgZ2V0IGNvbm5lY3Rpb25TdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblN0YXRzO1xuICB9XG4gIC8qKiBSZXR1cm5zIHRoZSByZWxheSBVUkwgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5uZGtSZWxheS51cmw7XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovICYmIHRoaXMud3M/LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOO1xuICB9XG59O1xuXG4vLyBzcmMvcmVsYXkvcHVibGlzaGVyLnRzXG52YXIgTkRLUmVsYXlQdWJsaXNoZXIgPSBjbGFzcyB7XG4gIG5ka1JlbGF5O1xuICBkZWJ1ZztcbiAgY29uc3RydWN0b3IobmRrUmVsYXkpIHtcbiAgICB0aGlzLm5ka1JlbGF5ID0gbmRrUmVsYXk7XG4gICAgdGhpcy5kZWJ1ZyA9IG5ka1JlbGF5LmRlYnVnLmV4dGVuZChcInB1Ymxpc2hlclwiKTtcbiAgfVxuICAvKipcbiAgICogUHVibGlzaGVkIGFuIGV2ZW50IHRvIHRoZSByZWxheTsgaWYgdGhlIHJlbGF5IGlzIG5vdCBjb25uZWN0ZWQsIGl0IHdpbGxcbiAgICogd2FpdCBmb3IgdGhlIHJlbGF5IHRvIGNvbm5lY3QgYmVmb3JlIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBJZiB0aGUgcmVsYXkgZG9lcyBub3QgY29ubmVjdCB3aXRoaW4gdGhlIHRpbWVvdXQsIHRoZSBwdWJsaXNoIG9wZXJhdGlvblxuICAgKiB3aWxsIGZhaWwuXG4gICAqIEBwYXJhbSBldmVudCAgVGhlIGV2ZW50IHRvIHB1Ymxpc2hcbiAgICogQHBhcmFtIHRpbWVvdXRNcyAgVGhlIHRpbWVvdXQgZm9yIHRoZSBwdWJsaXNoIG9wZXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgZXZlbnQgaGFzIGJlZW4gcHVibGlzaGVkIG9yIHJlamVjdHMgaWYgdGhlIG9wZXJhdGlvbiB0aW1lcyBvdXRcbiAgICovXG4gIGFzeW5jIHB1Ymxpc2goZXZlbnQsIHRpbWVvdXRNcyA9IDI1MDApIHtcbiAgICBsZXQgdGltZW91dDtcbiAgICBjb25zdCBwdWJsaXNoQ29ubmVjdGVkID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnB1Ymxpc2hFdmVudChldmVudCkudGhlbigoX3Jlc3VsdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uZGtSZWxheS5lbWl0KFwicHVibGlzaGVkXCIsIGV2ZW50KTtcbiAgICAgICAgICAgIGV2ZW50LmVtaXQoXCJyZWxheTpwdWJsaXNoZWRcIiwgdGhpcy5uZGtSZWxheSk7XG4gICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aW1lb3V0ID0gdm9pZCAwO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGBUaW1lb3V0OiAke3RpbWVvdXRNc31tc2ApKTtcbiAgICAgIH0sIHRpbWVvdXRNcyk7XG4gICAgfSk7XG4gICAgY29uc3Qgb25Db25uZWN0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHB1Ymxpc2hDb25uZWN0ZWQoKS50aGVuKChyZXN1bHQpID0+IGNvbm5lY3RSZXNvbHZlKHJlc3VsdCkpLmNhdGNoKChlcnIpID0+IGNvbm5lY3RSZWplY3QoZXJyKSk7XG4gICAgfTtcbiAgICBsZXQgY29ubmVjdFJlc29sdmU7XG4gICAgbGV0IGNvbm5lY3RSZWplY3Q7XG4gICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgIHRoaXMubmRrUmVsYXkuZGVidWcoXCJQdWJsaXNoIGZhaWxlZFwiLCBlcnIsIGV2ZW50LmlkKTtcbiAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcInB1Ymxpc2g6ZmFpbGVkXCIsIGV2ZW50LCBlcnIpO1xuICAgICAgZXZlbnQuZW1pdChcInJlbGF5OnB1Ymxpc2g6ZmFpbGVkXCIsIHRoaXMubmRrUmVsYXksIGVycik7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfTtcbiAgICBjb25zdCBvbkZpbmFsbHkgPSAoKSA9PiB7XG4gICAgICBpZiAodGltZW91dCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGhpcy5uZGtSZWxheS5yZW1vdmVMaXN0ZW5lcihcImNvbm5lY3RcIiwgb25Db25uZWN0SGFuZGxlcik7XG4gICAgfTtcbiAgICBpZiAodGhpcy5uZGtSZWxheS5zdGF0dXMgPj0gNSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW3B1Ymxpc2hDb25uZWN0ZWQoKSwgdGltZW91dFByb21pc2VdKS5jYXRjaChvbkVycm9yKS5maW5hbGx5KG9uRmluYWxseSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm5ka1JlbGF5LnN0YXR1cyA8PSAxIC8qIERJU0NPTk5FQ1RFRCAqLykge1xuICAgICAgY29uc29sZS53YXJuKFwiUmVsYXkgaXMgZGlzY29ubmVjdGVkLCB0cnlpbmcgdG8gY29ubmVjdCB0byBwdWJsaXNoIGFuIGV2ZW50XCIsIHRoaXMubmRrUmVsYXkudXJsKTtcbiAgICAgIHRoaXMubmRrUmVsYXkuY29ubmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJSZWxheSBub3QgY29ubmVjdGVkLCB3YWl0aW5nIGZvciBjb25uZWN0aW9uIHRvIHB1Ymxpc2ggYW4gZXZlbnRcIiwgdGhpcy5uZGtSZWxheS51cmwpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29ubmVjdFJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICBjb25uZWN0UmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB0aGlzLm5ka1JlbGF5Lm9uY2UoXCJjb25uZWN0XCIsIG9uQ29ubmVjdEhhbmRsZXIpO1xuICAgICAgfSksXG4gICAgICB0aW1lb3V0UHJvbWlzZVxuICAgIF0pLmNhdGNoKG9uRXJyb3IpLmZpbmFsbHkob25GaW5hbGx5KTtcbiAgfVxuICBhc3luYyBwdWJsaXNoRXZlbnQoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5uZGtSZWxheS5jb25uZWN0aXZpdHkucHVibGlzaChldmVudC5yYXdFdmVudCgpKTtcbiAgfVxufTtcblxuLy8gc3JjL3N1YnNjcmlwdGlvbi9ncm91cGluZy50c1xuZnVuY3Rpb24gZmlsdGVyRmluZ2VycHJpbnQoZmlsdGVycywgY2xvc2VPbkVvc2UpIHtcbiAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgZm9yIChjb25zdCBmaWx0ZXIgb2YgZmlsdGVycykge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3QuZW50cmllcyhmaWx0ZXIgfHwge30pLm1hcCgoW2tleSwgdmFsdWVzXSkgPT4ge1xuICAgICAgaWYgKFtcInNpbmNlXCIsIFwidW50aWxcIl0uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gYCR7a2V5fToke3ZhbHVlc31gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleTtcbiAgICB9KS5zb3J0KCkuam9pbihcIi1cIik7XG4gICAgZWxlbWVudHMucHVzaChrZXlzKTtcbiAgfVxuICBsZXQgaWQgPSBjbG9zZU9uRW9zZSA/IFwiK1wiIDogXCJcIjtcbiAgaWQgKz0gZWxlbWVudHMuam9pbihcInxcIik7XG4gIHJldHVybiBpZDtcbn1cbmZ1bmN0aW9uIG1lcmdlRmlsdGVycyhmaWx0ZXJzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBsYXN0UmVzdWx0ID0ge307XG4gIGZpbHRlcnMuZmlsdGVyKChmKSA9PiAhIWYubGltaXQpLmZvckVhY2goKGZpbHRlcldpdGhMaW1pdCkgPT4gcmVzdWx0LnB1c2goZmlsdGVyV2l0aExpbWl0KSk7XG4gIGZpbHRlcnMgPSBmaWx0ZXJzLmZpbHRlcigoZikgPT4gIWYubGltaXQpO1xuICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDApIHJldHVybiByZXN1bHQ7XG4gIGZpbHRlcnMuZm9yRWFjaCgoZmlsdGVyKSA9PiB7XG4gICAgT2JqZWN0LmVudHJpZXMoZmlsdGVyKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAobGFzdFJlc3VsdFtrZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgICBsYXN0UmVzdWx0W2tleV0gPSBbLi4udmFsdWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RSZXN1bHRba2V5XSA9IEFycmF5LmZyb20oLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLmxhc3RSZXN1bHRba2V5XSwgLi4udmFsdWVdKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RSZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIFsuLi5yZXN1bHQsIGxhc3RSZXN1bHRdO1xufVxuXG4vLyBzcmMvcmVsYXkvc3Vic2NyaXB0aW9uLnRzXG52YXIgTkRLUmVsYXlTdWJzY3JpcHRpb24gPSBjbGFzcyB7XG4gIGZpbmdlcnByaW50O1xuICBpdGVtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHRvcFN1Yk1hbmFnZXI7XG4gIGRlYnVnO1xuICAvKipcbiAgICogVHJhY2tzIHRoZSBzdGF0dXMgb2YgdGhpcyBSRVEuXG4gICAqL1xuICBzdGF0dXMgPSAwIC8qIElOSVRJQUwgKi87XG4gIG9uQ2xvc2U7XG4gIHJlbGF5O1xuICAvKipcbiAgICogV2hldGhlciB0aGlzIHN1YnNjcmlwdGlvbiBoYXMgcmVhY2hlZCBFT1NFLlxuICAgKi9cbiAgZW9zZWQgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFRpbWVvdXQgYXQgd2hpY2ggdGhpcyBzdWJzY3JpcHRpb24gd2lsbFxuICAgKiBzdGFydCBleGVjdXRpbmcuXG4gICAqL1xuICBleGVjdXRpb25UaW1lcjtcbiAgLyoqXG4gICAqIFRyYWNrIHRoZSB0aW1lIGF0IHdoaWNoIHRoaXMgc3Vic2NyaXB0aW9uIHdpbGwgZmlyZS5cbiAgICovXG4gIGZpcmVUaW1lO1xuICAvKipcbiAgICogVGhlIGRlbGF5IHR5cGUgdGhhdCB0aGUgY3VycmVudCBmaXJlVGltZSB3YXMgY2FsY3VsYXRlZCB3aXRoLlxuICAgKi9cbiAgZGVsYXlUeXBlO1xuICAvKipcbiAgICogVGhlIGZpbHRlcnMgdGhhdCBoYXZlIGJlZW4gZXhlY3V0ZWQuXG4gICAqL1xuICBleGVjdXRlRmlsdGVycztcbiAgaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyk7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gZmluZ2VycHJpbnQgVGhlIGZpbmdlcnByaW50IG9mIHRoaXMgc3Vic2NyaXB0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVsYXksIGZpbmdlcnByaW50LCB0b3BTdWJNYW5hZ2VyKSB7XG4gICAgdGhpcy5yZWxheSA9IHJlbGF5O1xuICAgIHRoaXMudG9wU3ViTWFuYWdlciA9IHRvcFN1Yk1hbmFnZXI7XG4gICAgdGhpcy5kZWJ1ZyA9IHJlbGF5LmRlYnVnLmV4dGVuZChgc3ViWyR7dGhpcy5pZH1dYCk7XG4gICAgdGhpcy5maW5nZXJwcmludCA9IGZpbmdlcnByaW50IHx8IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KTtcbiAgfVxuICBfc3ViSWQ7XG4gIGdldCBzdWJJZCgpIHtcbiAgICBpZiAodGhpcy5fc3ViSWQpIHJldHVybiB0aGlzLl9zdWJJZDtcbiAgICB0aGlzLl9zdWJJZCA9IHRoaXMuZmluZ2VycHJpbnQuc2xpY2UoMCwgMTUpO1xuICAgIHJldHVybiB0aGlzLl9zdWJJZDtcbiAgfVxuICBzdWJJZFBhcnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgYWRkU3ViSWRQYXJ0KHBhcnQpIHtcbiAgICB0aGlzLnN1YklkUGFydHMuYWRkKHBhcnQpO1xuICB9XG4gIGFkZEl0ZW0oc3Vic2NyaXB0aW9uLCBmaWx0ZXJzKSB7XG4gICAgdGhpcy5kZWJ1ZyhcIkFkZGluZyBpdGVtXCIsIHtcbiAgICAgIGZpbHRlcnMsXG4gICAgICBpbnRlcm5hbElkOiBzdWJzY3JpcHRpb24uaW50ZXJuYWxJZCxcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBmaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCxcbiAgICAgIGlkOiB0aGlzLnN1YklkLFxuICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICBpdGVtc1NpemU6IHRoaXMuaXRlbXMuc2l6ZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLml0ZW1zLmhhcyhzdWJzY3JpcHRpb24uaW50ZXJuYWxJZCkpIHJldHVybjtcbiAgICBzdWJzY3JpcHRpb24ub24oXCJjbG9zZVwiLCB0aGlzLnJlbW92ZUl0ZW0uYmluZCh0aGlzLCBzdWJzY3JpcHRpb24pKTtcbiAgICB0aGlzLml0ZW1zLnNldChzdWJzY3JpcHRpb24uaW50ZXJuYWxJZCwgeyBzdWJzY3JpcHRpb24sIGZpbHRlcnMgfSk7XG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSAzIC8qIFJVTk5JTkcgKi8pIHtcbiAgICAgIGlmIChzdWJzY3JpcHRpb24uc3ViSWQgJiYgKCF0aGlzLl9zdWJJZCB8fCB0aGlzLl9zdWJJZC5sZW5ndGggPCA0OCkpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAwIC8qIElOSVRJQUwgKi8gfHwgdGhpcy5zdGF0dXMgPT09IDEgLyogUEVORElORyAqLykge1xuICAgICAgICAgIHRoaXMuYWRkU3ViSWRQYXJ0KHN1YnNjcmlwdGlvbi5zdWJJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLnN0YXR1cykge1xuICAgICAgY2FzZSAwIC8qIElOSVRJQUwgKi86XG4gICAgICAgIHRoaXMuZXZhbHVhdGVFeGVjdXRpb25QbGFuKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzIC8qIFJVTk5JTkcgKi86XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxIC8qIFBFTkRJTkcgKi86XG4gICAgICAgIHRoaXMuZXZhbHVhdGVFeGVjdXRpb25QbGFuKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0IC8qIENMT1NFRCAqLzpcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIlN1YnNjcmlwdGlvbiBpcyBjbG9zZWQsIGNhbm5vdCBhZGQgbmV3IGl0ZW1zICVvICglbylcIiwgc3Vic2NyaXB0aW9uLCBmaWx0ZXJzKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCBuZXcgaXRlbXMgdG8gYSBjbG9zZWQgc3Vic2NyaXB0aW9uXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQSBzdWJzY3JpcHRpb24gaGFzIGJlZW4gY2xvc2VkLCByZW1vdmUgaXQgZnJvbSB0aGUgbGlzdCBvZiBpdGVtcy5cbiAgICogQHBhcmFtIHN1YnNjcmlwdGlvblxuICAgKi9cbiAgcmVtb3ZlSXRlbShzdWJzY3JpcHRpb24pIHtcbiAgICB0aGlzLml0ZW1zLmRlbGV0ZShzdWJzY3JpcHRpb24uaW50ZXJuYWxJZCk7XG4gICAgaWYgKHRoaXMuaXRlbXMuc2l6ZSA9PT0gMCkge1xuICAgICAgaWYgKCF0aGlzLmVvc2VkKSByZXR1cm47XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICB9XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSA0IC8qIENMT1NFRCAqLykgcmV0dXJuO1xuICAgIGNvbnN0IHByZXZTdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgICB0aGlzLnN0YXR1cyA9IDQgLyogQ0xPU0VEICovO1xuICAgIGlmIChwcmV2U3RhdHVzID09PSAzIC8qIFJVTk5JTkcgKi8pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMucmVsYXkuY2xvc2UodGhpcy5zdWJJZCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJFcnJvciBjbG9zaW5nIHN1YnNjcmlwdGlvblwiLCBlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWJ1ZyhcIlN1YnNjcmlwdGlvbiB3YW50ZWQgdG8gY2xvc2UgYnV0IGl0IHdhc24ndCBydW5uaW5nLCB0aGlzIGlzIHByb2JhYmx5IG9rXCIsIHtcbiAgICAgICAgc3ViSWQ6IHRoaXMuc3ViSWQsXG4gICAgICAgIHByZXZTdGF0dXMsXG4gICAgICAgIHN1YjogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmV4ZWN1dGlvblRpbWVyKTtcbiAgICB0aGlzLnJlbGF5Lm9mZihcInJlYWR5XCIsIHRoaXMuZXhlY3V0ZU9uUmVsYXlSZWFkeSk7XG4gICAgdGhpcy5yZWxheS5vZmYoXCJhdXRoZWRcIiwgdGhpcy5yZUV4ZWN1dGVBZnRlckF1dGgpO1xuICAgIGlmICh0aGlzLm9uQ2xvc2UpIHRoaXMub25DbG9zZSh0aGlzKTtcbiAgfVxuICBldmFsdWF0ZUV4ZWN1dGlvblBsYW4oc3Vic2NyaXB0aW9uKSB7XG4gICAgaWYgKCFzdWJzY3JpcHRpb24uaXNHcm91cGFibGUoKSkge1xuICAgICAgdGhpcy5zdGF0dXMgPSAxIC8qIFBFTkRJTkcgKi87XG4gICAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5maWx0ZXJzLmZpbmQoKGZpbHRlcikgPT4gISFmaWx0ZXIubGltaXQpKSB7XG4gICAgICB0aGlzLmV4ZWN1dGVGaWx0ZXJzID0gdGhpcy5jb21waWxlRmlsdGVycygpO1xuICAgICAgaWYgKHRoaXMuZXhlY3V0ZUZpbHRlcnMubGVuZ3RoID49IDEwKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgICAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkZWxheSA9IHN1YnNjcmlwdGlvbi5ncm91cGFibGVEZWxheTtcbiAgICBjb25zdCBkZWxheVR5cGUgPSBzdWJzY3JpcHRpb24uZ3JvdXBhYmxlRGVsYXlUeXBlO1xuICAgIGlmICghZGVsYXkpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBncm91cCBhIHN1YnNjcmlwdGlvbiB3aXRob3V0IGEgZGVsYXlcIik7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSAwIC8qIElOSVRJQUwgKi8pIHtcbiAgICAgIHRoaXMuc2NoZWR1bGUoZGVsYXksIGRlbGF5VHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nRGVsYXlUeXBlID0gdGhpcy5kZWxheVR5cGU7XG4gICAgICBjb25zdCB0aW1lVW50aWxGaXJlID0gdGhpcy5maXJlVGltZSAtIERhdGUubm93KCk7XG4gICAgICBpZiAoZXhpc3RpbmdEZWxheVR5cGUgPT09IFwiYXQtbGVhc3RcIiAmJiBkZWxheVR5cGUgPT09IFwiYXQtbGVhc3RcIikge1xuICAgICAgICBpZiAodGltZVVudGlsRmlyZSA8IGRlbGF5KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmV4ZWN1dGlvblRpbWVyKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlKGRlbGF5LCBkZWxheVR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nRGVsYXlUeXBlID09PSBcImF0LWxlYXN0XCIgJiYgZGVsYXlUeXBlID09PSBcImF0LW1vc3RcIikge1xuICAgICAgICBpZiAodGltZVVudGlsRmlyZSA+IGRlbGF5KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmV4ZWN1dGlvblRpbWVyKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlKGRlbGF5LCBkZWxheVR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nRGVsYXlUeXBlID09PSBcImF0LW1vc3RcIiAmJiBkZWxheVR5cGUgPT09IFwiYXQtbW9zdFwiKSB7XG4gICAgICAgIGlmICh0aW1lVW50aWxGaXJlID4gZGVsYXkpIHtcbiAgICAgICAgICBpZiAodGhpcy5leGVjdXRpb25UaW1lcikgY2xlYXJUaW1lb3V0KHRoaXMuZXhlY3V0aW9uVGltZXIpO1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGUoZGVsYXksIGRlbGF5VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdEZWxheVR5cGUgPT09IFwiYXQtbW9zdFwiICYmIGRlbGF5VHlwZSA9PT0gXCJhdC1sZWFzdFwiKSB7XG4gICAgICAgIGlmICh0aW1lVW50aWxGaXJlID4gZGVsYXkpIHtcbiAgICAgICAgICBpZiAodGhpcy5leGVjdXRpb25UaW1lcikgY2xlYXJUaW1lb3V0KHRoaXMuZXhlY3V0aW9uVGltZXIpO1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGUoZGVsYXksIGRlbGF5VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkZWxheSB0eXBlIGNvbWJpbmF0aW9uICR7ZXhpc3RpbmdEZWxheVR5cGV9ICR7ZGVsYXlUeXBlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzY2hlZHVsZShkZWxheSwgZGVsYXlUeXBlKSB7XG4gICAgdGhpcy5zdGF0dXMgPSAxIC8qIFBFTkRJTkcgKi87XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuZmlyZVRpbWUgPSBjdXJyZW50VGltZSArIGRlbGF5O1xuICAgIHRoaXMuZGVsYXlUeXBlID0gZGVsYXlUeXBlO1xuICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCh0aGlzLmV4ZWN1dGUuYmluZCh0aGlzKSwgZGVsYXkpO1xuICAgIGlmIChkZWxheVR5cGUgPT09IFwiYXQtbGVhc3RcIikge1xuICAgICAgdGhpcy5leGVjdXRpb25UaW1lciA9IHRpbWVyO1xuICAgIH1cbiAgfVxuICBleGVjdXRlT25SZWxheVJlYWR5ID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gMiAvKiBXQUlUSU5HICovKSByZXR1cm47XG4gICAgaWYgKHRoaXMuaXRlbXMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5kZWJ1ZyhcIk5vIGl0ZW1zIHRvIGV4ZWN1dGU7IHRoaXMgcmVsYXkgd2FzIHByb2JhYmx5IHRvbyBzbG93IHRvIHJlc3BvbmQgYW5kIHRoZSBjYWxsZXIgZ2F2ZSB1cFwiLCB7XG4gICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgIGZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LFxuICAgICAgICBpdGVtczogdGhpcy5pdGVtcyxcbiAgICAgICAgaXRlbXNTaXplOiB0aGlzLml0ZW1zLnNpemUsXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBzdWJJZDogdGhpcy5zdWJJZFxuICAgICAgfSk7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyhcIkV4ZWN1dGluZyBvbiByZWxheSByZWFkeVwiLCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgZmluZ2VycHJpbnQ6IHRoaXMuZmluZ2VycHJpbnQsXG4gICAgICBpdGVtczogdGhpcy5pdGVtcyxcbiAgICAgIGl0ZW1zU2l6ZTogdGhpcy5pdGVtcy5zaXplXG4gICAgfSk7XG4gICAgdGhpcy5zdGF0dXMgPSAxIC8qIFBFTkRJTkcgKi87XG4gICAgdGhpcy5leGVjdXRlKCk7XG4gIH07XG4gIGZpbmFsaXplU3ViSWQoKSB7XG4gICAgaWYgKHRoaXMuc3ViSWRQYXJ0cy5zaXplID4gMCkge1xuICAgICAgdGhpcy5fc3ViSWQgPSBBcnJheS5mcm9tKHRoaXMuc3ViSWRQYXJ0cykuam9pbihcIi1cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N1YklkID0gdGhpcy5maW5nZXJwcmludC5zbGljZSgwLCAxNSk7XG4gICAgfVxuICAgIHRoaXMuX3N1YklkICs9IGAtJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgNyl9YDtcbiAgfVxuICAvLyB3ZSBkbyBpdCB0aGlzIHdheSBzbyB0aGF0IHdlIGNhbiByZW1vdmUgdGhlIGxpc3RlbmVyXG4gIHJlRXhlY3V0ZUFmdGVyQXV0aCA9ICgoKSA9PiB7XG4gICAgY29uc3Qgb2xkU3ViSWQgPSB0aGlzLnN1YklkO1xuICAgIHRoaXMuZGVidWcoXCJSZS1leGVjdXRpbmcgYWZ0ZXIgYXV0aFwiLCB0aGlzLml0ZW1zLnNpemUpO1xuICAgIGlmICh0aGlzLmVvc2VkKSB7XG4gICAgICB0aGlzLnJlbGF5LmNsb3NlKHRoaXMuc3ViSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlYnVnKFwiV2UgYXJlIGFiYW5kb25pbmcgYW4gb3BlbmVkIHN1YnNjcmlwdGlvbiwgb25jZSBpdCBFT1NFJ3MsIHRoZSBoYW5kbGVyIHdpbGwgY2xvc2UgaXRcIiwge1xuICAgICAgICBvbGRTdWJJZFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3N1YklkID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgIHRoaXMuZXhlY3V0ZSgpO1xuICAgIHRoaXMuZGVidWcoXCJSZS1leGVjdXRlZCBhZnRlciBhdXRoICVzIFxcdXsxRjQ0OX0gJXNcIiwgb2xkU3ViSWQsIHRoaXMuc3ViSWQpO1xuICB9KS5iaW5kKHRoaXMpO1xuICBleGVjdXRlKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gMSAvKiBQRU5ESU5HICovKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5yZWxheS5jb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMuc3RhdHVzID0gMiAvKiBXQUlUSU5HICovO1xuICAgICAgdGhpcy5kZWJ1ZyhcIldhaXRpbmcgZm9yIHJlbGF5IHRvIGJlIHJlYWR5XCIsIHtcbiAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgaWQ6IHRoaXMuc3ViSWQsXG4gICAgICAgIGZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LFxuICAgICAgICBpdGVtczogdGhpcy5pdGVtcyxcbiAgICAgICAgaXRlbXNTaXplOiB0aGlzLml0ZW1zLnNpemVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZWxheS5vbmNlKFwicmVhZHlcIiwgdGhpcy5leGVjdXRlT25SZWxheVJlYWR5KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVsYXkuc3RhdHVzIDwgOCAvKiBBVVRIRU5USUNBVEVEICovKSB7XG4gICAgICB0aGlzLnJlbGF5Lm9uY2UoXCJhdXRoZWRcIiwgdGhpcy5yZUV4ZWN1dGVBZnRlckF1dGgpO1xuICAgIH1cbiAgICB0aGlzLnN0YXR1cyA9IDMgLyogUlVOTklORyAqLztcbiAgICB0aGlzLmZpbmFsaXplU3ViSWQoKTtcbiAgICB0aGlzLmV4ZWN1dGVGaWx0ZXJzID0gdGhpcy5jb21waWxlRmlsdGVycygpO1xuICAgIHRoaXMucmVsYXkucmVxKHRoaXMpO1xuICB9XG4gIG9uc3RhcnQoKSB7XG4gIH1cbiAgb25ldmVudChldmVudCkge1xuICAgIHRoaXMudG9wU3ViTWFuYWdlci5kaXNwYXRjaEV2ZW50KGV2ZW50LCB0aGlzLnJlbGF5KTtcbiAgfVxuICBvbmVvc2Uoc3ViSWQpIHtcbiAgICB0aGlzLmVvc2VkID0gdHJ1ZTtcbiAgICBpZiAoc3ViSWQgIT09IHRoaXMuc3ViSWQpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJSZWNlaXZlZCBFT1NFIGZvciBhbiBhYmFuZG9uZWQgc3Vic2NyaXB0aW9uXCIsIHN1YklkLCB0aGlzLnN1YklkKTtcbiAgICAgIHRoaXMucmVsYXkuY2xvc2Uoc3ViSWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pdGVtcy5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgeyBzdWJzY3JpcHRpb24gfSBvZiB0aGlzLml0ZW1zLnZhbHVlcygpKSB7XG4gICAgICBzdWJzY3JpcHRpb24uZW9zZVJlY2VpdmVkKHRoaXMucmVsYXkpO1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbi5jbG9zZU9uRW9zZSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiUmVtb3ZpbmcgaXRlbSBiZWNhdXNlIG9mIEVPU0VcIiwge1xuICAgICAgICAgIGZpbHRlcnM6IHN1YnNjcmlwdGlvbi5maWx0ZXJzLFxuICAgICAgICAgIGludGVybmFsSWQ6IHN1YnNjcmlwdGlvbi5pbnRlcm5hbElkLFxuICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgZmluZ2VycHJpbnQ6IHRoaXMuZmluZ2VycHJpbnQsXG4gICAgICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICAgICAgaXRlbXNTaXplOiB0aGlzLml0ZW1zLnNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShzdWJzY3JpcHRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbmNsb3NlKF9yZWFzb24pIHtcbiAgICB0aGlzLnN0YXR1cyA9IDQgLyogQ0xPU0VEICovO1xuICB9XG4gIG9uY2xvc2VkKHJlYXNvbikge1xuICAgIGlmICghcmVhc29uKSByZXR1cm47XG4gICAgZm9yIChjb25zdCB7IHN1YnNjcmlwdGlvbiB9IG9mIHRoaXMuaXRlbXMudmFsdWVzKCkpIHtcbiAgICAgIHN1YnNjcmlwdGlvbi5jbG9zZWRSZWNlaXZlZCh0aGlzLnJlbGF5LCByZWFzb24pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR3JhYnMgdGhlIGZpbHRlcnMgZnJvbSBhbGwgdGhlIHN1YnNjcmlwdGlvbnNcbiAgICogYW5kIG1lcmdlcyB0aGVtIGludG8gYSBzaW5nbGUgZmlsdGVyLlxuICAgKi9cbiAgY29tcGlsZUZpbHRlcnMoKSB7XG4gICAgY29uc3QgbWVyZ2VkRmlsdGVycyA9IFtdO1xuICAgIGNvbnN0IGZpbHRlcnMgPSBBcnJheS5mcm9tKHRoaXMuaXRlbXMudmFsdWVzKCkpLm1hcCgoaXRlbSkgPT4gaXRlbS5maWx0ZXJzKTtcbiAgICBpZiAoIWZpbHRlcnNbMF0pIHtcbiAgICAgIHRoaXMuZGVidWcoXCJcXHV7MUY0NDB9IE5vIGZpbHRlcnMgdG8gbWVyZ2VcIiwgdGhpcy5pdGVtcyk7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQlVHOiBObyBmaWx0ZXJzIHRvIG1lcmdlIVwiLCB0aGlzLml0ZW1zKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgZmlsdGVyQ291bnQgPSBmaWx0ZXJzWzBdLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlckNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFsbEZpbHRlcnNBdEluZGV4ID0gZmlsdGVycy5tYXAoKGZpbHRlcikgPT4gZmlsdGVyW2ldKTtcbiAgICAgIG1lcmdlZEZpbHRlcnMucHVzaCguLi5tZXJnZUZpbHRlcnMoYWxsRmlsdGVyc0F0SW5kZXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZEZpbHRlcnM7XG4gIH1cbn07XG5cbi8vIHNyYy9yZWxheS9zdWItbWFuYWdlci50c1xudmFyIE5ES1JlbGF5U3Vic2NyaXB0aW9uTWFuYWdlciA9IGNsYXNzIHtcbiAgcmVsYXk7XG4gIHN1YnNjcmlwdGlvbnM7XG4gIGdlbmVyYWxTdWJNYW5hZ2VyO1xuICAvKipcbiAgICogQHBhcmFtIHJlbGF5IC0gVGhlIHJlbGF5IGluc3RhbmNlLlxuICAgKiBAcGFyYW0gZ2VuZXJhbFN1Yk1hbmFnZXIgLSBUaGUgc3Vic2NyaXB0aW9uIG1hbmFnZXIgaW5zdGFuY2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZWxheSwgZ2VuZXJhbFN1Yk1hbmFnZXIpIHtcbiAgICB0aGlzLnJlbGF5ID0gcmVsYXk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmdlbmVyYWxTdWJNYW5hZ2VyID0gZ2VuZXJhbFN1Yk1hbmFnZXI7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBzdWJzY3JpcHRpb24gdG8gdGhlIG1hbmFnZXIuXG4gICAqL1xuICBhZGRTdWJzY3JpcHRpb24oc3ViLCBmaWx0ZXJzKSB7XG4gICAgbGV0IHJlbGF5U3ViO1xuICAgIGlmICghc3ViLmlzR3JvdXBhYmxlKCkpIHtcbiAgICAgIHJlbGF5U3ViID0gdGhpcy5jcmVhdGVTdWJzY3JpcHRpb24oc3ViLCBmaWx0ZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZmlsdGVyRnAgPSBmaWx0ZXJGaW5nZXJwcmludChmaWx0ZXJzLCBzdWIuY2xvc2VPbkVvc2UpO1xuICAgICAgaWYgKGZpbHRlckZwKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nU3VicyA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQoZmlsdGVyRnApO1xuICAgICAgICByZWxheVN1YiA9IChleGlzdGluZ1N1YnMgfHwgW10pLmZpbmQoKHN1YjIpID0+IHN1YjIuc3RhdHVzIDwgMyAvKiBSVU5OSU5HICovKTtcbiAgICAgIH1cbiAgICAgIHJlbGF5U3ViID8/PSB0aGlzLmNyZWF0ZVN1YnNjcmlwdGlvbihzdWIsIGZpbHRlcnMsIGZpbHRlckZwKTtcbiAgICB9XG4gICAgcmVsYXlTdWIuYWRkSXRlbShzdWIsIGZpbHRlcnMpO1xuICB9XG4gIGNyZWF0ZVN1YnNjcmlwdGlvbihfc3ViLCBfZmlsdGVycywgZmluZ2VycHJpbnQpIHtcbiAgICBjb25zdCByZWxheVN1YiA9IG5ldyBOREtSZWxheVN1YnNjcmlwdGlvbih0aGlzLnJlbGF5LCBmaW5nZXJwcmludCB8fCBudWxsLCB0aGlzLmdlbmVyYWxTdWJNYW5hZ2VyKTtcbiAgICByZWxheVN1Yi5vbkNsb3NlID0gdGhpcy5vblJlbGF5U3Vic2NyaXB0aW9uQ2xvc2UuYmluZCh0aGlzKTtcbiAgICBjb25zdCBjdXJyZW50VmFsID0gdGhpcy5zdWJzY3JpcHRpb25zLmdldChyZWxheVN1Yi5maW5nZXJwcmludCkgPz8gW107XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChyZWxheVN1Yi5maW5nZXJwcmludCwgWy4uLmN1cnJlbnRWYWwsIHJlbGF5U3ViXSk7XG4gICAgcmV0dXJuIHJlbGF5U3ViO1xuICB9XG4gIG9uUmVsYXlTdWJzY3JpcHRpb25DbG9zZShzdWIpIHtcbiAgICBsZXQgY3VycmVudFZhbCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQoc3ViLmZpbmdlcnByaW50KSA/PyBbXTtcbiAgICBpZiAoIWN1cnJlbnRWYWwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlVuZXhwZWN0ZWRseSBkaWQgbm90IGZpbmQgYSBzdWJzY3JpcHRpb24gd2l0aCBmaW5nZXJwcmludFwiLCBzdWIuZmluZ2VycHJpbnQpO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudFZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kZWxldGUoc3ViLmZpbmdlcnByaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFZhbCA9IGN1cnJlbnRWYWwuZmlsdGVyKChzKSA9PiBzLmlkICE9PSBzdWIuaWQpO1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChzdWIuZmluZ2VycHJpbnQsIGN1cnJlbnRWYWwpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3JlbGF5L2luZGV4LnRzXG52YXIgTkRLUmVsYXlTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChOREtSZWxheVN0YXR1czIpID0+IHtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkRJU0NPTk5FQ1RJTkdcIl0gPSAwXSA9IFwiRElTQ09OTkVDVElOR1wiO1xuICBOREtSZWxheVN0YXR1czJbTkRLUmVsYXlTdGF0dXMyW1wiRElTQ09OTkVDVEVEXCJdID0gMV0gPSBcIkRJU0NPTk5FQ1RFRFwiO1xuICBOREtSZWxheVN0YXR1czJbTkRLUmVsYXlTdGF0dXMyW1wiUkVDT05ORUNUSU5HXCJdID0gMl0gPSBcIlJFQ09OTkVDVElOR1wiO1xuICBOREtSZWxheVN0YXR1czJbTkRLUmVsYXlTdGF0dXMyW1wiRkxBUFBJTkdcIl0gPSAzXSA9IFwiRkxBUFBJTkdcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkNPTk5FQ1RJTkdcIl0gPSA0XSA9IFwiQ09OTkVDVElOR1wiO1xuICBOREtSZWxheVN0YXR1czJbTkRLUmVsYXlTdGF0dXMyW1wiQ09OTkVDVEVEXCJdID0gNV0gPSBcIkNPTk5FQ1RFRFwiO1xuICBOREtSZWxheVN0YXR1czJbTkRLUmVsYXlTdGF0dXMyW1wiQVVUSF9SRVFVRVNURURcIl0gPSA2XSA9IFwiQVVUSF9SRVFVRVNURURcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkFVVEhFTlRJQ0FUSU5HXCJdID0gN10gPSBcIkFVVEhFTlRJQ0FUSU5HXCI7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJBVVRIRU5USUNBVEVEXCJdID0gOF0gPSBcIkFVVEhFTlRJQ0FURURcIjtcbiAgcmV0dXJuIE5ES1JlbGF5U3RhdHVzMjtcbn0pKE5ES1JlbGF5U3RhdHVzIHx8IHt9KTtcbnZhciBOREtSZWxheSA9IGNsYXNzIF9OREtSZWxheSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHVybDtcbiAgc2NvcmVzO1xuICBjb25uZWN0aXZpdHk7XG4gIHN1YnM7XG4gIHB1Ymxpc2hlcjtcbiAgYXV0aFBvbGljeTtcbiAgLyoqXG4gICAqIFRoZSBsb3dlc3QgdmFsaWRhdGlvbiByYXRpbyB0aGlzIHJlbGF5IGNhbiByZWFjaC5cbiAgICovXG4gIGxvd2VzdFZhbGlkYXRpb25SYXRpbztcbiAgLyoqXG4gICAqIEN1cnJlbnQgdmFsaWRhdGlvbiByYXRpbyB0aGlzIHJlbGF5IGlzIHRhcmdldGluZy5cbiAgICovXG4gIHRhcmdldFZhbGlkYXRpb25SYXRpbztcbiAgdmFsaWRhdGlvblJhdGlvRm47XG4gIC8qKlxuICAgKiBUaGlzIHRyYWNrcyBldmVudHMgdGhhdCBoYXZlIGJlZW4gc2VlbiBieSB0aGlzIHJlbGF5XG4gICAqIHdpdGggYSB2YWxpZCBzaWduYXR1cmUuXG4gICAqL1xuICB2YWxpZGF0ZWRFdmVudENvdW50ID0gMDtcbiAgLyoqXG4gICAqIFRoaXMgdHJhY2tzIGV2ZW50cyB0aGF0IGhhdmUgYmVlbiBzZWVuIGJ5IHRoaXMgcmVsYXlcbiAgICogYnV0IGhhdmUgbm90IGJlZW4gdmFsaWRhdGVkLlxuICAgKi9cbiAgbm9uVmFsaWRhdGVkRXZlbnRDb3VudCA9IDA7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgcmVsYXkgaXMgdHJ1c3RlZC5cbiAgICpcbiAgICogVHJ1c3RlZCByZWxheSdzIGV2ZW50cyBkbyBub3QgZ2V0IHRoZWlyIHNpZ25hdHVyZSB2ZXJpZmllZC5cbiAgICovXG4gIHRydXN0ZWQgPSBmYWxzZTtcbiAgY29tcGxhaW5pbmcgPSBmYWxzZTtcbiAgZGVidWc7XG4gIHN0YXRpYyBkZWZhdWx0VmFsaWRhdGlvblJhdGlvVXBkYXRlRm4gPSAocmVsYXksIHZhbGlkYXRlZENvdW50LCBfbm9uVmFsaWRhdGVkQ291bnQpID0+IHtcbiAgICBpZiAocmVsYXkubG93ZXN0VmFsaWRhdGlvblJhdGlvID09PSB2b2lkIDAgfHwgcmVsYXkudGFyZ2V0VmFsaWRhdGlvblJhdGlvID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgIGxldCBuZXdSYXRpbyA9IHJlbGF5LnZhbGlkYXRpb25SYXRpbztcbiAgICBpZiAocmVsYXkudmFsaWRhdGlvblJhdGlvID4gcmVsYXkudGFyZ2V0VmFsaWRhdGlvblJhdGlvKSB7XG4gICAgICBjb25zdCBmYWN0b3IgPSB2YWxpZGF0ZWRDb3VudCAvIDEwMDtcbiAgICAgIG5ld1JhdGlvID0gTWF0aC5tYXgocmVsYXkubG93ZXN0VmFsaWRhdGlvblJhdGlvLCByZWxheS52YWxpZGF0aW9uUmF0aW8gLSBmYWN0b3IpO1xuICAgIH1cbiAgICBpZiAobmV3UmF0aW8gPCByZWxheS52YWxpZGF0aW9uUmF0aW8pIHtcbiAgICAgIHJldHVybiBuZXdSYXRpbztcbiAgICB9XG4gICAgcmV0dXJuIHJlbGF5LnZhbGlkYXRpb25SYXRpbztcbiAgfTtcbiAgY29uc3RydWN0b3IodXJsLCBhdXRoUG9saWN5LCBuZGspIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudXJsID0gbm9ybWFsaXplUmVsYXlVcmwodXJsKTtcbiAgICB0aGlzLnNjb3JlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnKGBuZGs6cmVsYXk6JHt1cmx9YCk7XG4gICAgdGhpcy5jb25uZWN0aXZpdHkgPSBuZXcgTkRLUmVsYXlDb25uZWN0aXZpdHkodGhpcywgbmRrKTtcbiAgICB0aGlzLmNvbm5lY3Rpdml0eS5uZXREZWJ1ZyA9IG5kaz8ubmV0RGVidWc7XG4gICAgdGhpcy5yZXEgPSB0aGlzLmNvbm5lY3Rpdml0eS5yZXEuYmluZCh0aGlzLmNvbm5lY3Rpdml0eSk7XG4gICAgdGhpcy5jbG9zZSA9IHRoaXMuY29ubmVjdGl2aXR5LmNsb3NlLmJpbmQodGhpcy5jb25uZWN0aXZpdHkpO1xuICAgIHRoaXMuc3VicyA9IG5ldyBOREtSZWxheVN1YnNjcmlwdGlvbk1hbmFnZXIodGhpcywgbmRrLnN1Yk1hbmFnZXIpO1xuICAgIHRoaXMucHVibGlzaGVyID0gbmV3IE5ES1JlbGF5UHVibGlzaGVyKHRoaXMpO1xuICAgIHRoaXMuYXV0aFBvbGljeSA9IGF1dGhQb2xpY3k7XG4gICAgdGhpcy50YXJnZXRWYWxpZGF0aW9uUmF0aW8gPSBuZGs/LmluaXRpYWxWYWxpZGF0aW9uUmF0aW87XG4gICAgdGhpcy5sb3dlc3RWYWxpZGF0aW9uUmF0aW8gPSBuZGs/Lmxvd2VzdFZhbGlkYXRpb25SYXRpbztcbiAgICB0aGlzLnZhbGlkYXRpb25SYXRpb0ZuID0gKG5kaz8udmFsaWRhdGlvblJhdGlvRm4gPz8gX05ES1JlbGF5LmRlZmF1bHRWYWxpZGF0aW9uUmF0aW9VcGRhdGVGbikuYmluZCh0aGlzKTtcbiAgICB0aGlzLnVwZGF0ZVZhbGlkYXRpb25SYXRpbygpO1xuICAgIGlmICghbmRrKSB7XG4gICAgICBjb25zb2xlLnRyYWNlKFwicmVsYXkgY3JlYXRlZCB3aXRob3V0IG5ka1wiKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlVmFsaWRhdGlvblJhdGlvKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVWYWxpZGF0aW9uUmF0aW8oKTtcbiAgICB9LCAzZTQpO1xuICB9XG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGl2aXR5LnN0YXR1cztcbiAgfVxuICBnZXQgY29ubmVjdGlvblN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eS5jb25uZWN0aW9uU3RhdHM7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIHRoZSByZWxheS5cbiAgICovXG4gIGFzeW5jIGNvbm5lY3QodGltZW91dE1zLCByZWNvbm5lY3QgPSB0cnVlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGl2aXR5LmNvbm5lY3QodGltZW91dE1zLCByZWNvbm5lY3QpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyBmcm9tIHRoZSByZWxheS5cbiAgICovXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSAxIC8qIERJU0NPTk5FQ1RFRCAqLykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3Rpdml0eS5kaXNjb25uZWN0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFF1ZXVlcyBvciBleGVjdXRlcyB0aGUgc3Vic2NyaXB0aW9uIG9mIGEgc3BlY2lmaWMgc2V0IG9mIGZpbHRlcnNcbiAgICogd2l0aGluIHRoaXMgcmVsYXkuXG4gICAqXG4gICAqIEBwYXJhbSBzdWJzY3JpcHRpb24gTkRLU3Vic2NyaXB0aW9uIHRoaXMgZmlsdGVycyBiZWxvbmcgdG8uXG4gICAqIEBwYXJhbSBmaWx0ZXJzIEZpbHRlcnMgdG8gZXhlY3V0ZVxuICAgKi9cbiAgc3Vic2NyaWJlKHN1YnNjcmlwdGlvbiwgZmlsdGVycykge1xuICAgIHRoaXMuc3Vicy5hZGRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uLCBmaWx0ZXJzKTtcbiAgfVxuICAvKipcbiAgICogUHVibGlzaGVzIGFuIGV2ZW50IHRvIHRoZSByZWxheSB3aXRoIGFuIG9wdGlvbmFsIHRpbWVvdXQuXG4gICAqXG4gICAqIElmIHRoZSByZWxheSBpcyBub3QgY29ubmVjdGVkLCB0aGUgZXZlbnQgd2lsbCBiZSBwdWJsaXNoZWQgd2hlbiB0aGUgcmVsYXkgY29ubmVjdHMsXG4gICAqIHVubGVzcyB0aGUgdGltZW91dCBpcyByZWFjaGVkIGJlZm9yZSB0aGUgcmVsYXkgY29ubmVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gcHVibGlzaFxuICAgKiBAcGFyYW0gdGltZW91dE1zIFRoZSB0aW1lb3V0IGZvciB0aGUgcHVibGlzaCBvcGVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGV2ZW50IGhhcyBiZWVuIHB1Ymxpc2hlZCBvciByZWplY3RzIGlmIHRoZSBvcGVyYXRpb24gdGltZXMgb3V0XG4gICAqL1xuICBhc3luYyBwdWJsaXNoKGV2ZW50LCB0aW1lb3V0TXMgPSAyNTAwKSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLnB1Ymxpc2goZXZlbnQsIHRpbWVvdXRNcyk7XG4gIH1cbiAgcmVmZXJlbmNlVGFncygpIHtcbiAgICByZXR1cm4gW1tcInJcIiwgdGhpcy51cmxdXTtcbiAgfVxuICBhZGRWYWxpZGF0ZWRFdmVudCgpIHtcbiAgICB0aGlzLnZhbGlkYXRlZEV2ZW50Q291bnQrKztcbiAgfVxuICBhZGROb25WYWxpZGF0ZWRFdmVudCgpIHtcbiAgICB0aGlzLm5vblZhbGlkYXRlZEV2ZW50Q291bnQrKztcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgdmFsaWRhdGlvbiByYXRpbyB0aGlzIHJlbGF5IGhhcyBhY2hpZXZlZC5cbiAgICovXG4gIGdldCB2YWxpZGF0aW9uUmF0aW8oKSB7XG4gICAgaWYgKHRoaXMubm9uVmFsaWRhdGVkRXZlbnRDb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlZEV2ZW50Q291bnQgLyAodGhpcy52YWxpZGF0ZWRFdmVudENvdW50ICsgdGhpcy5ub25WYWxpZGF0ZWRFdmVudENvdW50KTtcbiAgfVxuICBzaG91bGRWYWxpZGF0ZUV2ZW50KCkge1xuICAgIGlmICh0aGlzLnRydXN0ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGFyZ2V0VmFsaWRhdGlvblJhdGlvID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52YWxpZGF0aW9uUmF0aW8gPCB0aGlzLnRhcmdldFZhbGlkYXRpb25SYXRpbztcbiAgfVxuICBnZXQgY29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eS5jb25uZWN0ZWQ7XG4gIH1cbiAgcmVxO1xuICBjbG9zZTtcbn07XG5cbi8vIHNyYy9yZWxheS9zZXRzL2luZGV4LnRzXG52YXIgTkRLUHVibGlzaEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGVycm9ycztcbiAgcHVibGlzaGVkVG9SZWxheXM7XG4gIC8qKlxuICAgKiBJbnRlbmRlZCByZWxheSBzZXQgd2hlcmUgdGhlIHB1Ymxpc2hpbmcgd2FzIGludGVuZGVkIHRvIGhhcHBlbi5cbiAgICovXG4gIGludGVuZGVkUmVsYXlTZXQ7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGVycm9ycywgcHVibGlzaGVkVG9SZWxheXMsIGludGVuZGVkUmVsYXlTZXQpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB0aGlzLnB1Ymxpc2hlZFRvUmVsYXlzID0gcHVibGlzaGVkVG9SZWxheXM7XG4gICAgdGhpcy5pbnRlbmRlZFJlbGF5U2V0ID0gaW50ZW5kZWRSZWxheVNldDtcbiAgfVxuICBnZXQgcmVsYXlFcnJvcnMoKSB7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgZm9yIChjb25zdCBbcmVsYXksIGVycl0gb2YgdGhpcy5lcnJvcnMpIHtcbiAgICAgIGVycm9ycy5wdXNoKGAke3JlbGF5LnVybH06ICR7ZXJyfWApO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzLmpvaW4oXCJcXG5cIik7XG4gIH1cbn07XG52YXIgTkRLUmVsYXlTZXQgPSBjbGFzcyBfTkRLUmVsYXlTZXQge1xuICByZWxheXM7XG4gIGRlYnVnO1xuICBuZGs7XG4gIHBvb2w7XG4gIGNvbnN0cnVjdG9yKHJlbGF5cywgbmRrLCBwb29sKSB7XG4gICAgdGhpcy5yZWxheXMgPSByZWxheXM7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgdGhpcy5wb29sID0gcG9vbCA/PyBuZGsucG9vbDtcbiAgICB0aGlzLmRlYnVnID0gbmRrLmRlYnVnLmV4dGVuZChcInJlbGF5c2V0XCIpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcmVsYXkgdG8gdGhpcyBzZXQuXG4gICAqL1xuICBhZGRSZWxheShyZWxheSkge1xuICAgIHRoaXMucmVsYXlzLmFkZChyZWxheSk7XG4gIH1cbiAgZ2V0IHJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlbGF5cykubWFwKChyKSA9PiByLnVybCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZWxheSBzZXQgZnJvbSBhIGxpc3Qgb2YgcmVsYXkgVVJMcy5cbiAgICpcbiAgICogSWYgbm8gY29ubmVjdGlvbiB0byB0aGUgcmVsYXkgaXMgZm91bmQgaW4gdGhlIHBvb2wgaXQgd2lsbCB0ZW1wb3JhcmlseVxuICAgKiBjb25uZWN0IHRvIGl0LlxuICAgKlxuICAgKiBAcGFyYW0gcmVsYXlVcmxzIC0gbGlzdCBvZiByZWxheSBVUkxzIHRvIGluY2x1ZGUgaW4gdGhpcyBzZXRcbiAgICogQHBhcmFtIG5ka1xuICAgKiBAcGFyYW0gY29ubmVjdCAtIHdoZXRoZXIgdG8gY29ubmVjdCB0byB0aGUgcmVsYXkgaW1tZWRpYXRlbHkgaWYgaXQgd2FzIGFscmVhZHkgaW4gdGhlIHBvb2wgYnV0IG5vdCBjb25uZWN0ZWRcbiAgICogQHJldHVybnMgTkRLUmVsYXlTZXRcbiAgICovXG4gIHN0YXRpYyBmcm9tUmVsYXlVcmxzKHJlbGF5VXJscywgbmRrLCBjb25uZWN0ID0gdHJ1ZSwgcG9vbCkge1xuICAgIHBvb2wgPSBwb29sID8/IG5kay5wb29sO1xuICAgIGlmICghcG9vbCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gcG9vbCBwcm92aWRlZFwiKTtcbiAgICBjb25zdCByZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIHJlbGF5VXJscykge1xuICAgICAgY29uc3QgcmVsYXkgPSBwb29sLnJlbGF5cy5nZXQobm9ybWFsaXplUmVsYXlVcmwodXJsKSk7XG4gICAgICBpZiAocmVsYXkpIHtcbiAgICAgICAgaWYgKHJlbGF5LnN0YXR1cyA8IDUgLyogQ09OTkVDVEVEICovICYmIGNvbm5lY3QpIHtcbiAgICAgICAgICByZWxheS5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVsYXlzLmFkZChyZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZW1wb3JhcnlSZWxheSA9IG5ldyBOREtSZWxheShub3JtYWxpemVSZWxheVVybCh1cmwpLCBuZGs/LnJlbGF5QXV0aERlZmF1bHRQb2xpY3ksIG5kayk7XG4gICAgICAgIHBvb2wudXNlVGVtcG9yYXJ5UmVsYXkodGVtcG9yYXJ5UmVsYXksIHZvaWQgMCwgYHJlcXVlc3RlZCBmcm9tIGZyb21SZWxheVVybHMgJHtyZWxheVVybHN9YCk7XG4gICAgICAgIHJlbGF5cy5hZGQodGVtcG9yYXJ5UmVsYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IF9OREtSZWxheVNldChuZXcgU2V0KHJlbGF5cyksIG5kaywgcG9vbCk7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYW4gZXZlbnQgdG8gYWxsIHJlbGF5cyBpbiB0aGlzIHJlbGF5IHNldC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaW1wbGVtZW50cyBhIHJvYnVzdCBtZWNoYW5pc20gZm9yIHB1Ymxpc2hpbmcgZXZlbnRzIHRvIG11bHRpcGxlIHJlbGF5cyB3aXRoXG4gICAqIGJ1aWx0LWluIGhhbmRsaW5nIGZvciByYWNlIGNvbmRpdGlvbnMsIHRpbWVvdXRzLCBhbmQgcGFydGlhbCBmYWlsdXJlcy4gVGhlIGltcGxlbWVudGF0aW9uXG4gICAqIHVzZXMgYSBkdWFsLXRyYWNraW5nIG1lY2hhbmlzbSB0byBlbnN1cmUgYWNjdXJhdGUgcmVwb3J0aW5nIG9mIHdoaWNoIHJlbGF5cyBzdWNjZXNzZnVsbHlcbiAgICogcmVjZWl2ZWQgYW4gZXZlbnQuXG4gICAqXG4gICAqIEtleSBhc3BlY3RzIG9mIHRoaXMgaW1wbGVtZW50YXRpb246XG4gICAqXG4gICAqIDEuIERVQUwtVFJBQ0tJTkcgTUVDSEFOSVNNOlxuICAgKiAgICAtIFByb21pc2UtYmFzZWQgdHJhY2tpbmc6IFJlY29yZHMgc3VjY2Vzc2VzL2ZhaWx1cmVzIGZyb20gdGhlIHByb21pc2VzIHJldHVybmVkIGJ5IHJlbGF5LnB1Ymxpc2goKVxuICAgKiAgICAtIEV2ZW50LWJhc2VkIHRyYWNraW5nOiBMaXN0ZW5zIGZvciAncmVsYXk6cHVibGlzaGVkJyBldmVudHMgdGhhdCBpbmRpY2F0ZSBzdWNjZXNzZnVsIHB1Ymxpc2hpbmdcbiAgICogICAgVGhpcyBhcHByb2FjaCBlbnN1cmVzIHdlIGRvbid0IG1pc3Mgc3VjY2Vzc2Z1bCBwdWJsaXNoZXMgZXZlbiBpZiB0aGVyZSBhcmUgc3Vic2VxdWVudCBlcnJvcnMgaW5cbiAgICogICAgdGhlIHByb21pc2UgY2hhaW4uXG4gICAqXG4gICAqIDIuIFJBQ0UgQ09ORElUSU9OIEhBTkRMSU5HOlxuICAgKiAgICAtIElmIGEgcmVsYXkgZW1pdHMgYSBzdWNjZXNzIGV2ZW50IGJ1dCBsYXRlciBmYWlscyBpbiB0aGUgcHJvbWlzZSBjaGFpbiwgd2Ugc3RpbGwgY291bnQgaXQgYXMgYSBzdWNjZXNzXG4gICAqICAgIC0gSWYgYSByZWxheSB0aW1lcyBvdXQgYWZ0ZXIgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hpbmcsIHdlIHN0aWxsIGNvdW50IGl0IGFzIGEgc3VjY2Vzc1xuICAgKiAgICAtIEFsbCByZWxheSBvcGVyYXRpb25zIGhhcHBlbiBpbiBwYXJhbGxlbCwgd2l0aCBwcm9wZXIgdHJhY2tpbmcgcmVnYXJkbGVzcyBvZiBjb21wbGV0aW9uIG9yZGVyXG4gICAqXG4gICAqIDMuIFRJTUVPVVQgTUFOQUdFTUVOVDpcbiAgICogICAgLSBJbmRpdmlkdWFsIHRpbWVvdXRzIGZvciBlYWNoIHJlbGF5IG9wZXJhdGlvblxuICAgKiAgICAtIFByb3BlciBjbGVhbnVwIG9mIHRpbWVvdXRzIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAqICAgIC0gQ2xlYXIgdGltZW91dCBlcnJvciByZXBvcnRpbmdcbiAgICpcbiAgICogNC4gRVJST1IgSEFORExJTkc6XG4gICAqICAgIC0gRGV0YWlsZWQgdHJhY2tpbmcgb2Ygc3BlY2lmaWMgZXJyb3JzIGZvciBlYWNoIGZhaWxlZCByZWxheVxuICAgKiAgICAtIFNwZWNpYWwgaGFuZGxpbmcgZm9yIGVwaGVtZXJhbCBldmVudHMgKHdoaWNoIGRvbid0IGV4cGVjdCBhY2tub3dsZWRnZW1lbnQpXG4gICAqICAgIC0gUmVxdWlyZWRSZWxheUNvdW50IHBhcmFtZXRlciB0byBjb250cm9sIHRoZSBtaW5pbXVtIHN1Y2Nlc3MgdGhyZXNob2xkXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBFdmVudCB0byBwdWJsaXNoXG4gICAqIEBwYXJhbSB0aW1lb3V0TXMgVGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIGVhY2ggcmVsYXkgcHVibGlzaCBvcGVyYXRpb25cbiAgICogQHBhcmFtIHJlcXVpcmVkUmVsYXlDb3VudCBUaGUgbWluaW11bSBudW1iZXIgb2YgcmVsYXlzIHdlIGV4cGVjdCB0aGUgZXZlbnQgdG8gYmUgcHVibGlzaGVkIHRvXG4gICAqIEByZXR1cm5zIEEgc2V0IG9mIHJlbGF5cyB0aGUgZXZlbnQgd2FzIHB1Ymxpc2hlZCB0b1xuICAgKiBAdGhyb3dzIHtOREtQdWJsaXNoRXJyb3J9IElmIHRoZSBldmVudCBjb3VsZCBub3QgYmUgcHVibGlzaGVkIHRvIGF0IGxlYXN0IGByZXF1aXJlZFJlbGF5Q291bnRgIHJlbGF5c1xuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlbGF5U2V0ID0gbmV3IE5ES1JlbGF5U2V0KG5ldyBTZXQoW3JlbGF5MSwgcmVsYXkyXSksIG5kayk7XG4gICAqIGNvbnN0IHB1Ymxpc2hlZFRvUmVsYXlzID0gYXdhaXQgcmVsYXlTZXQucHVibGlzaChldmVudCk7XG4gICAqIC8vIHB1Ymxpc2hlZFRvUmVsYXlzIGNhbiBjb250YWluIHJlbGF5MSwgcmVsYXkyLCBib3RoLCBvciBub25lXG4gICAqIC8vIGRlcGVuZGluZyBvbiB3aGljaCByZWxheXMgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkIHRvXG4gICAqIGlmIChwdWJsaXNoZWRUb1JlbGF5cy5zaXplID4gMCkge1xuICAgKiAgIGNvbnNvbGUubG9nKFwiRXZlbnQgcHVibGlzaGVkIHRvIGF0IGxlYXN0IG9uZSByZWxheVwiKTtcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHB1Ymxpc2goZXZlbnQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50ID0gMSkge1xuICAgIGNvbnN0IHB1Ymxpc2hlZFRvUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBlcnJvcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGlzRXBoZW1lcmFsMiA9IGV2ZW50LmlzRXBoZW1lcmFsKCk7XG4gICAgZXZlbnQucHVibGlzaFN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgIGNvbnN0IHJlbGF5UHVibGlzaGVkSGFuZGxlciA9IChyZWxheSkgPT4ge1xuICAgICAgcHVibGlzaGVkVG9SZWxheXMuYWRkKHJlbGF5KTtcbiAgICB9O1xuICAgIGV2ZW50Lm9uKFwicmVsYXk6cHVibGlzaGVkXCIsIHJlbGF5UHVibGlzaGVkSGFuZGxlcik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh0aGlzLnJlbGF5cykubWFwKChyZWxheSkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSB0aW1lb3V0TXMgPyBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghcHVibGlzaGVkVG9SZWxheXMuaGFzKHJlbGF5KSkge1xuICAgICAgICAgICAgICBlcnJvcnMuc2V0KHJlbGF5LCBuZXcgRXJyb3IoYFB1Ymxpc2ggdGltZW91dCBhZnRlciAke3RpbWVvdXRNc31tc2ApKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGltZW91dE1zKSA6IG51bGw7XG4gICAgICAgICAgcmVsYXkucHVibGlzaChldmVudCwgdGltZW91dE1zKS50aGVuKChzdWNjZXNzKSA9PiB7XG4gICAgICAgICAgICBpZiAodGltZW91dElkKSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgIHB1Ymxpc2hlZFRvUmVsYXlzLmFkZChyZWxheSk7XG4gICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAodGltZW91dElkKSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIGlmICghaXNFcGhlbWVyYWwyKSB7XG4gICAgICAgICAgICAgIGVycm9ycy5zZXQocmVsYXksIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIGlmIChwdWJsaXNoZWRUb1JlbGF5cy5zaXplIDwgcmVxdWlyZWRSZWxheUNvdW50KSB7XG4gICAgICAgIGlmICghaXNFcGhlbWVyYWwyKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTkRLUHVibGlzaEVycm9yKFxuICAgICAgICAgICAgXCJOb3QgZW5vdWdoIHJlbGF5cyByZWNlaXZlZCB0aGUgZXZlbnRcIixcbiAgICAgICAgICAgIGVycm9ycyxcbiAgICAgICAgICAgIHB1Ymxpc2hlZFRvUmVsYXlzLFxuICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXZlbnQucHVibGlzaFN0YXR1cyA9IFwiZXJyb3JcIjtcbiAgICAgICAgICBldmVudC5wdWJsaXNoRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICB0aGlzLm5kaz8uZW1pdChcImV2ZW50OnB1Ymxpc2gtZmFpbGVkXCIsIGV2ZW50LCBlcnJvciwgdGhpcy5yZWxheVVybHMpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldmVudC5wdWJsaXNoU3RhdHVzID0gXCJzdWNjZXNzXCI7XG4gICAgICAgIGV2ZW50LmVtaXQoXCJwdWJsaXNoZWRcIiwgeyByZWxheVNldDogdGhpcywgcHVibGlzaGVkVG9SZWxheXMgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHVibGlzaGVkVG9SZWxheXM7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV2ZW50Lm9mZihcInJlbGF5OnB1Ymxpc2hlZFwiLCByZWxheVB1Ymxpc2hlZEhhbmRsZXIpO1xuICAgIH1cbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWxheXMuc2l6ZTtcbiAgfVxufTtcblxuLy8gc3JjL3JlbGF5L3NldHMvY2FsY3VsYXRlLnRzXG52YXIgZCA9IGNyZWF0ZURlYnVnKFwibmRrOm91dGJveDpjYWxjdWxhdGVcIik7XG5hc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVSZWxheVNldEZyb21FdmVudChuZGssIGV2ZW50KSB7XG4gIGNvbnN0IHJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGF1dGhvcldyaXRlUmVsYXlzID0gYXdhaXQgZ2V0V3JpdGVSZWxheXNGb3IobmRrLCBldmVudC5wdWJrZXkpO1xuICBpZiAoYXV0aG9yV3JpdGVSZWxheXMpIHtcbiAgICBhdXRob3JXcml0ZVJlbGF5cy5mb3JFYWNoKChyZWxheVVybCkgPT4ge1xuICAgICAgY29uc3QgcmVsYXkgPSBuZGsucG9vbD8uZ2V0UmVsYXkocmVsYXlVcmwpO1xuICAgICAgaWYgKHJlbGF5KSByZWxheXMuYWRkKHJlbGF5KTtcbiAgICB9KTtcbiAgfVxuICBsZXQgcmVsYXlIaW50cyA9IGV2ZW50LnRhZ3MuZmlsdGVyKCh0YWcpID0+IFtcImFcIiwgXCJlXCJdLmluY2x1ZGVzKHRhZ1swXSkpLm1hcCgodGFnKSA9PiB0YWdbMl0pLmZpbHRlcigodXJsKSA9PiB1cmw/LnN0YXJ0c1dpdGgoXCJ3c3M6Ly9cIikpLmZpbHRlcigodXJsKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBVUkwodXJsKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSkubWFwKCh1cmwpID0+IG5vcm1hbGl6ZVJlbGF5VXJsKHVybCkpO1xuICByZWxheUhpbnRzID0gQXJyYXkuZnJvbShuZXcgU2V0KHJlbGF5SGludHMpKS5zbGljZSgwLCA1KTtcbiAgcmVsYXlIaW50cy5mb3JFYWNoKChyZWxheVVybCkgPT4ge1xuICAgIGNvbnN0IHJlbGF5ID0gbmRrLnBvb2w/LmdldFJlbGF5KHJlbGF5VXJsLCB0cnVlLCB0cnVlKTtcbiAgICBpZiAocmVsYXkpIHtcbiAgICAgIGQoXCJBZGRpbmcgcmVsYXkgaGludCAlc1wiLCByZWxheVVybCk7XG4gICAgICByZWxheXMuYWRkKHJlbGF5KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBwVGFncyA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcInBcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gIGlmIChwVGFncy5sZW5ndGggPCA1KSB7XG4gICAgY29uc3QgcFRhZ2dlZFJlbGF5cyA9IEFycmF5LmZyb20oXG4gICAgICBjaG9vc2VSZWxheUNvbWJpbmF0aW9uRm9yUHVia2V5cyhuZGssIHBUYWdzLCBcInJlYWRcIiwge1xuICAgICAgICBwcmVmZXJyZWRSZWxheXM6IG5ldyBTZXQoYXV0aG9yV3JpdGVSZWxheXMpXG4gICAgICB9KS5rZXlzKClcbiAgICApO1xuICAgIHBUYWdnZWRSZWxheXMuZm9yRWFjaCgocmVsYXlVcmwpID0+IHtcbiAgICAgIGNvbnN0IHJlbGF5ID0gbmRrLnBvb2w/LmdldFJlbGF5KHJlbGF5VXJsLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICBpZiAocmVsYXkpIHtcbiAgICAgICAgZChcIkFkZGluZyBwLXRhZ2dlZCByZWxheSAlc1wiLCByZWxheVVybCk7XG4gICAgICAgIHJlbGF5cy5hZGQocmVsYXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGQoXCJUb28gbWFueSBwLXRhZ3MgdG8gY29uc2lkZXIgJWRcIiwgcFRhZ3MubGVuZ3RoKTtcbiAgfVxuICBuZGsucG9vbD8ucGVybWFuZW50QW5kQ29ubmVjdGVkUmVsYXlzKCkuZm9yRWFjaCgocmVsYXkpID0+IHJlbGF5cy5hZGQocmVsYXkpKTtcbiAgcmV0dXJuIG5ldyBOREtSZWxheVNldChyZWxheXMsIG5kayk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVSZWxheVNldHNGcm9tRmlsdGVyKG5kaywgZmlsdGVycywgcG9vbCkge1xuICBjb25zdCByZXN1bHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBhdXRob3JzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZmlsdGVycy5mb3JFYWNoKChmaWx0ZXIpID0+IHtcbiAgICBpZiAoZmlsdGVyLmF1dGhvcnMpIHtcbiAgICAgIGZpbHRlci5hdXRob3JzLmZvckVhY2goKGF1dGhvcikgPT4gYXV0aG9ycy5hZGQoYXV0aG9yKSk7XG4gICAgfVxuICB9KTtcbiAgaWYgKGF1dGhvcnMuc2l6ZSA+IDApIHtcbiAgICBjb25zdCBhdXRob3JUb1JlbGF5c01hcCA9IGdldFJlbGF5c0ZvckZpbHRlcldpdGhBdXRob3JzKG5kaywgQXJyYXkuZnJvbShhdXRob3JzKSk7XG4gICAgZm9yIChjb25zdCByZWxheVVybCBvZiBhdXRob3JUb1JlbGF5c01hcC5rZXlzKCkpIHtcbiAgICAgIHJlc3VsdC5zZXQocmVsYXlVcmwsIFtdKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgZmlsdGVycykge1xuICAgICAgaWYgKGZpbHRlci5hdXRob3JzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW3JlbGF5VXJsLCBhdXRob3JzMl0gb2YgYXV0aG9yVG9SZWxheXNNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgY29uc3QgYXV0aG9yRmlsdGVyQW5kUmVsYXlQdWJrZXlJbnRlcnNlY3Rpb24gPSBmaWx0ZXIuYXV0aG9ycy5maWx0ZXIoXG4gICAgICAgICAgICAoYXV0aG9yKSA9PiBhdXRob3JzMi5pbmNsdWRlcyhhdXRob3IpXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bHQuc2V0KHJlbGF5VXJsLCBbXG4gICAgICAgICAgICAuLi5yZXN1bHQuZ2V0KHJlbGF5VXJsKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4uZmlsdGVyLFxuICAgICAgICAgICAgICAvLyBPdmVyd3JpdGUgYXV0aG9ycyBzZW50IHRvIHRoaXMgcmVsYXkgd2l0aCB0aGUgYXV0aG9ycyB0aGF0IHdlcmVcbiAgICAgICAgICAgICAgLy8gcHJlc2VudCBpbiB0aGUgZmlsdGVyIGFuZCBhcmUgYWxzbyBwcmVzZW50IGluIHRoZSByZWxheVxuICAgICAgICAgICAgICBhdXRob3JzOiBhdXRob3JGaWx0ZXJBbmRSZWxheVB1YmtleUludGVyc2VjdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIGF1dGhvclRvUmVsYXlzTWFwLmtleXMoKSkge1xuICAgICAgICAgIHJlc3VsdC5zZXQocmVsYXlVcmwsIFsuLi5yZXN1bHQuZ2V0KHJlbGF5VXJsKSwgZmlsdGVyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG5kay5leHBsaWNpdFJlbGF5VXJscykge1xuICAgICAgbmRrLmV4cGxpY2l0UmVsYXlVcmxzLmZvckVhY2goKHJlbGF5VXJsKSA9PiB7XG4gICAgICAgIHJlc3VsdC5zZXQocmVsYXlVcmwsIGZpbHRlcnMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChyZXN1bHQuc2l6ZSA9PT0gMCkge1xuICAgIHBvb2wucGVybWFuZW50QW5kQ29ubmVjdGVkUmVsYXlzKCkuc2xpY2UoMCwgNSkuZm9yRWFjaCgocmVsYXkpID0+IHtcbiAgICAgIHJlc3VsdC5zZXQocmVsYXkudXJsLCBmaWx0ZXJzKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXlTZXRzRnJvbUZpbHRlcnMobmRrLCBmaWx0ZXJzLCBwb29sKSB7XG4gIGNvbnN0IGEgPSBjYWxjdWxhdGVSZWxheVNldHNGcm9tRmlsdGVyKG5kaywgZmlsdGVycywgcG9vbCk7XG4gIHJldHVybiBhO1xufVxuXG4vLyBzcmMvZXZlbnRzL2NvbnRlbnQtdGFnZ2VyLnRzXG5pbXBvcnQgeyBuaXAxOSB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuZnVuY3Rpb24gbWVyZ2VUYWdzKHRhZ3MxLCB0YWdzMikge1xuICBjb25zdCB0YWdNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBnZW5lcmF0ZUtleSA9ICh0YWcpID0+IHRhZy5qb2luKFwiLFwiKTtcbiAgY29uc3QgaXNDb250YWluZWQgPSAoc21hbGxlciwgbGFyZ2VyKSA9PiB7XG4gICAgcmV0dXJuIHNtYWxsZXIuZXZlcnkoKHZhbHVlLCBpbmRleCkgPT4gdmFsdWUgPT09IGxhcmdlcltpbmRleF0pO1xuICB9O1xuICBjb25zdCBwcm9jZXNzVGFnID0gKHRhZykgPT4ge1xuICAgIGZvciAoY29uc3QgW2tleSwgZXhpc3RpbmdUYWddIG9mIHRhZ01hcCkge1xuICAgICAgaWYgKGlzQ29udGFpbmVkKGV4aXN0aW5nVGFnLCB0YWcpIHx8IGlzQ29udGFpbmVkKHRhZywgZXhpc3RpbmdUYWcpKSB7XG4gICAgICAgIGlmICh0YWcubGVuZ3RoID49IGV4aXN0aW5nVGFnLmxlbmd0aCkge1xuICAgICAgICAgIHRhZ01hcC5zZXQoa2V5LCB0YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGFnTWFwLnNldChnZW5lcmF0ZUtleSh0YWcpLCB0YWcpO1xuICB9O1xuICB0YWdzMS5jb25jYXQodGFnczIpLmZvckVhY2gocHJvY2Vzc1RhZyk7XG4gIHJldHVybiBBcnJheS5mcm9tKHRhZ01hcC52YWx1ZXMoKSk7XG59XG5mdW5jdGlvbiB1bmlxdWVUYWcoYSwgYikge1xuICBjb25zdCBhTGVuZ3RoID0gYS5sZW5ndGg7XG4gIGNvbnN0IGJMZW5ndGggPSBiLmxlbmd0aDtcbiAgY29uc3Qgc2FtZUxlbmd0aCA9IGFMZW5ndGggPT09IGJMZW5ndGg7XG4gIGlmIChzYW1lTGVuZ3RoKSB7XG4gICAgaWYgKGEuZXZlcnkoKHYsIGkpID0+IHYgPT09IGJbaV0pKSB7XG4gICAgICByZXR1cm4gW2FdO1xuICAgIH1cbiAgICByZXR1cm4gW2EsIGJdO1xuICB9XG4gIGlmIChhTGVuZ3RoID4gYkxlbmd0aCAmJiBhLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBiW2ldKSkge1xuICAgIHJldHVybiBbYV07XG4gIH1cbiAgaWYgKGJMZW5ndGggPiBhTGVuZ3RoICYmIGIuZXZlcnkoKHYsIGkpID0+IHYgPT09IGFbaV0pKSB7XG4gICAgcmV0dXJuIFtiXTtcbiAgfVxuICByZXR1cm4gW2EsIGJdO1xufVxudmFyIGhhc2h0YWdSZWdleCA9IC8oPzw9XFxzfF4pKCNbXlxccyFAIyQlXiYqKCk9Ky4vLFt7XFxdfTs6J1wiPz48XSspL2c7XG5mdW5jdGlvbiBnZW5lcmF0ZUhhc2h0YWdzKGNvbnRlbnQpIHtcbiAgY29uc3QgaGFzaHRhZ3MgPSBjb250ZW50Lm1hdGNoKGhhc2h0YWdSZWdleCk7XG4gIGNvbnN0IHRhZ0lkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHRhZyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGlmIChoYXNodGFncykge1xuICAgIGZvciAoY29uc3QgaGFzaHRhZyBvZiBoYXNodGFncykge1xuICAgICAgaWYgKHRhZ0lkcy5oYXMoaGFzaHRhZy5zbGljZSgxKSkpIGNvbnRpbnVlO1xuICAgICAgdGFnLmFkZChoYXNodGFnLnNsaWNlKDEpKTtcbiAgICAgIHRhZ0lkcy5hZGQoaGFzaHRhZy5zbGljZSgxKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHRhZyk7XG59XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRUYWdzKGNvbnRlbnQsIHRhZ3MgPSBbXSkge1xuICBjb25zdCB0YWdSZWdleCA9IC8oQHxub3N0cjopKG5wdWJ8bnByb2ZpbGV8bm90ZXxuZXZlbnR8bmFkZHIpW2EtekEtWjAtOV0rL2c7XG4gIGNvbnN0IHByb21pc2VzID0gW107XG4gIGNvbnN0IGFkZFRhZ0lmTmV3ID0gKHQpID0+IHtcbiAgICBpZiAoIXRhZ3MuZmluZCgodDIpID0+IFtcInFcIiwgdFswXV0uaW5jbHVkZXModDJbMF0pICYmIHQyWzFdID09PSB0WzFdKSkge1xuICAgICAgdGFncy5wdXNoKHQpO1xuICAgIH1cbiAgfTtcbiAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSh0YWdSZWdleCwgKHRhZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSB0YWcuc3BsaXQoLyhAfG5vc3RyOikvKVsyXTtcbiAgICAgIGNvbnN0IHsgdHlwZSwgZGF0YSB9ID0gbmlwMTkuZGVjb2RlKGVudGl0eSk7XG4gICAgICBsZXQgdDtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwibnB1YlwiOlxuICAgICAgICAgIHQgPSBbXCJwXCIsIGRhdGFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnByb2ZpbGVcIjpcbiAgICAgICAgICB0ID0gW1wicFwiLCBkYXRhLnB1YmtleV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgIGFkZFRhZ0lmTmV3KFtcInFcIiwgZGF0YSwgYXdhaXQgbWF5YmVHZXRFdmVudFJlbGF5VXJsKGVudGl0eSldKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibmV2ZW50XCI6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgaWQsIGF1dGhvciB9ID0gZGF0YTtcbiAgICAgICAgICAgICAgbGV0IHsgcmVsYXlzIH0gPSBkYXRhO1xuICAgICAgICAgICAgICBpZiAoIXJlbGF5cyB8fCByZWxheXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVsYXlzID0gW2F3YWl0IG1heWJlR2V0RXZlbnRSZWxheVVybChlbnRpdHkpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhZGRUYWdJZk5ldyhbXCJxXCIsIGlkLCByZWxheXNbMF1dKTtcbiAgICAgICAgICAgICAgaWYgKGF1dGhvcikgYWRkVGFnSWZOZXcoW1wicFwiLCBhdXRob3JdKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibmFkZHJcIjpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgaWQgPSBbZGF0YS5raW5kLCBkYXRhLnB1YmtleSwgZGF0YS5pZGVudGlmaWVyXS5qb2luKFwiOlwiKTtcbiAgICAgICAgICAgICAgbGV0IHJlbGF5cyA9IGRhdGEucmVsYXlzID8/IFtdO1xuICAgICAgICAgICAgICBpZiAocmVsYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlbGF5cyA9IFthd2FpdCBtYXliZUdldEV2ZW50UmVsYXlVcmwoZW50aXR5KV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYWRkVGFnSWZOZXcoW1wicVwiLCBpZCwgcmVsYXlzWzBdXSk7XG4gICAgICAgICAgICAgIGFkZFRhZ0lmTmV3KFtcInBcIiwgZGF0YS5wdWJrZXldKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICB9XG4gICAgICBpZiAodCkgYWRkVGFnSWZOZXcodCk7XG4gICAgICByZXR1cm4gYG5vc3RyOiR7ZW50aXR5fWA7XG4gICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgfSk7XG4gIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgY29uc3QgbmV3VGFncyA9IGdlbmVyYXRlSGFzaHRhZ3MoY29udGVudCkubWFwKChoYXNodGFnKSA9PiBbXCJ0XCIsIGhhc2h0YWddKTtcbiAgdGFncyA9IG1lcmdlVGFncyh0YWdzLCBuZXdUYWdzKTtcbiAgcmV0dXJuIHsgY29udGVudCwgdGFncyB9O1xufVxuYXN5bmMgZnVuY3Rpb24gbWF5YmVHZXRFdmVudFJlbGF5VXJsKF9uaXAxOUlkKSB7XG4gIHJldHVybiBcIlwiO1xufVxuXG4vLyBzcmMvZXZlbnRzL2VuY3J5cHRpb24udHNcbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHQocmVjaXBpZW50LCBzaWduZXIsIHNjaGVtZSA9IFwibmlwNDRcIikge1xuICBsZXQgZW5jcnlwdGVkO1xuICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmQhXCIpO1xuICBsZXQgY3VycmVudFNpZ25lciA9IHNpZ25lcjtcbiAgaWYgKCFjdXJyZW50U2lnbmVyKSB7XG4gICAgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCk7XG4gICAgY3VycmVudFNpZ25lciA9IHRoaXMubmRrLnNpZ25lcjtcbiAgfVxuICBpZiAoIWN1cnJlbnRTaWduZXIpIHRocm93IG5ldyBFcnJvcihcIm5vIE5ESyBzaWduZXJcIik7XG4gIGNvbnN0IGN1cnJlbnRSZWNpcGllbnQgPSByZWNpcGllbnQgfHwgKCgpID0+IHtcbiAgICBjb25zdCBwVGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKTtcbiAgICBpZiAocFRhZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZWNpcGllbnQgY291bGQgYmUgZGV0ZXJtaW5lZCBhbmQgbm8gZXhwbGljaXQgcmVjaXBpZW50IHdhcyBwcm92aWRlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXk6IHBUYWdzWzBdWzFdIH0pO1xuICB9KSgpO1xuICBpZiAoc2NoZW1lID09PSBcIm5pcDQ0XCIgJiYgYXdhaXQgaXNFbmNyeXB0aW9uRW5hYmxlZChjdXJyZW50U2lnbmVyLCBcIm5pcDQ0XCIpKSB7XG4gICAgZW5jcnlwdGVkID0gYXdhaXQgY3VycmVudFNpZ25lci5lbmNyeXB0KGN1cnJlbnRSZWNpcGllbnQsIHRoaXMuY29udGVudCwgXCJuaXA0NFwiKTtcbiAgfVxuICBpZiAoKCFlbmNyeXB0ZWQgfHwgc2NoZW1lID09PSBcIm5pcDA0XCIpICYmIGF3YWl0IGlzRW5jcnlwdGlvbkVuYWJsZWQoY3VycmVudFNpZ25lciwgXCJuaXAwNFwiKSkge1xuICAgIGVuY3J5cHRlZCA9IGF3YWl0IGN1cnJlbnRTaWduZXIuZW5jcnlwdChjdXJyZW50UmVjaXBpZW50LCB0aGlzLmNvbnRlbnQsIFwibmlwMDRcIik7XG4gIH1cbiAgaWYgKCFlbmNyeXB0ZWQpIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBlbmNyeXB0IGV2ZW50LlwiKTtcbiAgdGhpcy5jb250ZW50ID0gZW5jcnlwdGVkO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdChzZW5kZXIsIHNpZ25lciwgc2NoZW1lKSB7XG4gIGlmICh0aGlzLm5kaz8uY2FjaGVBZGFwdGVyPy5nZXREZWNyeXB0ZWRFdmVudCkge1xuICAgIGxldCBjYWNoZWRFdmVudCA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZ2V0RGVjcnlwdGVkRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2FjaGVkRXZlbnQgPSB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZ2V0RGVjcnlwdGVkRXZlbnQodGhpcy5pZCk7XG4gICAgfVxuICAgIGlmIChjYWNoZWRFdmVudCkge1xuICAgICAgdGhpcy5jb250ZW50ID0gY2FjaGVkRXZlbnQuY29udGVudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbGV0IGRlY3J5cHRlZDtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kIVwiKTtcbiAgbGV0IGN1cnJlbnRTaWduZXIgPSBzaWduZXI7XG4gIGlmICghY3VycmVudFNpZ25lcikge1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGN1cnJlbnRTaWduZXIgPSB0aGlzLm5kay5zaWduZXI7XG4gIH1cbiAgaWYgKCFjdXJyZW50U2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBOREsgc2lnbmVyXCIpO1xuICBjb25zdCBjdXJyZW50U2VuZGVyID0gc2VuZGVyIHx8IHRoaXMuYXV0aG9yO1xuICBpZiAoIWN1cnJlbnRTZW5kZXIpIHRocm93IG5ldyBFcnJvcihcIk5vIHNlbmRlciBwcm92aWRlZCBhbmQgbm8gYXV0aG9yIGF2YWlsYWJsZVwiKTtcbiAgY29uc3QgY3VycmVudFNjaGVtZSA9IHNjaGVtZSB8fCAodGhpcy5jb250ZW50Lm1hdGNoKC9cXFxcP2l2PS8pID8gXCJuaXAwNFwiIDogXCJuaXA0NFwiKTtcbiAgaWYgKChjdXJyZW50U2NoZW1lID09PSBcIm5pcDA0XCIgfHwgdGhpcy5raW5kID09PSA0KSAmJiBhd2FpdCBpc0VuY3J5cHRpb25FbmFibGVkKGN1cnJlbnRTaWduZXIsIFwibmlwMDRcIikgJiYgdGhpcy5jb250ZW50LnNlYXJjaChcIlxcXFw/aXY9XCIpKSB7XG4gICAgZGVjcnlwdGVkID0gYXdhaXQgY3VycmVudFNpZ25lci5kZWNyeXB0KGN1cnJlbnRTZW5kZXIsIHRoaXMuY29udGVudCwgXCJuaXAwNFwiKTtcbiAgfVxuICBpZiAoIWRlY3J5cHRlZCAmJiBjdXJyZW50U2NoZW1lID09PSBcIm5pcDQ0XCIgJiYgYXdhaXQgaXNFbmNyeXB0aW9uRW5hYmxlZChjdXJyZW50U2lnbmVyLCBcIm5pcDQ0XCIpKSB7XG4gICAgZGVjcnlwdGVkID0gYXdhaXQgY3VycmVudFNpZ25lci5kZWNyeXB0KGN1cnJlbnRTZW5kZXIsIHRoaXMuY29udGVudCwgXCJuaXA0NFwiKTtcbiAgfVxuICBpZiAoIWRlY3J5cHRlZCkgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY3J5cHQgZXZlbnQuXCIpO1xuICB0aGlzLmNvbnRlbnQgPSBkZWNyeXB0ZWQ7XG4gIGlmICh0aGlzLm5kaz8uY2FjaGVBZGFwdGVyPy5hZGREZWNyeXB0ZWRFdmVudCkge1xuICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5hZGREZWNyeXB0ZWRFdmVudCh0aGlzKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaXNFbmNyeXB0aW9uRW5hYmxlZChzaWduZXIsIHNjaGVtZSkge1xuICBpZiAoIXNpZ25lci5lbmNyeXB0aW9uRW5hYmxlZCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIXNjaGVtZSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBCb29sZWFuKGF3YWl0IHNpZ25lci5lbmNyeXB0aW9uRW5hYmxlZChzY2hlbWUpKTtcbn1cblxuLy8gc3JjL3RocmVhZC9pbmRleC50c1xuZnVuY3Rpb24gZXZlbnRzQnlTYW1lQXV0aG9yKG9wLCBldmVudHMpIHtcbiAgY29uc3QgZXZlbnRzQnlBdXRob3IgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBldmVudHNCeUF1dGhvci5zZXQob3AuaWQsIG9wKTtcbiAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LnB1YmtleSA9PT0gb3AucHVia2V5KSB7XG4gICAgICBldmVudHNCeUF1dGhvci5zZXQoZXZlbnQuaWQsIGV2ZW50KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZXZlbnRzQnlBdXRob3I7XG59XG52YXIgaGFzTWFya2VycyA9IChldmVudCwgdGFnVHlwZSkgPT4ge1xuICByZXR1cm4gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKHRhZ1R5cGUpLnNvbWUoKHRhZykgPT4gdGFnWzNdICYmIHRhZ1szXSAhPT0gXCJcIik7XG59O1xuZnVuY3Rpb24gZXZlbnRJc1JlcGx5KG9wLCBldmVudCwgdGhyZWFkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgdGFnVHlwZSkge1xuICB0YWdUeXBlID8/PSBvcC50YWdUeXBlKCk7XG4gIGNvbnN0IHRhZ3MgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3ModGFnVHlwZSk7XG4gIHRocmVhZElkcy5hZGQob3AudGFnSWQoKSk7XG4gIGlmICh0aHJlYWRJZHMuaGFzKGV2ZW50LnRhZ0lkKCkpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGhlZWRFeHBsaWNpdFJlcGx5TWFya2VyID0gKCkgPT4ge1xuICAgIGxldCBldmVudElzVGFnZ2VkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGFncykge1xuICAgICAgaWYgKHRhZ1szXSA9PT0gXCJyZXBseVwiKSByZXR1cm4gdGhyZWFkSWRzLmhhcyh0YWdbMV0pO1xuICAgICAgY29uc3QgbWFya2VySXNFbXB0eSA9IHRhZ1szXSA9PT0gXCJcIiB8fCB0YWdbM10gPT09IHZvaWQgMDtcbiAgICAgIGNvbnN0IG1hcmtlcklzUm9vdCA9IHRhZ1szXSA9PT0gXCJyb290XCI7XG4gICAgICBpZiAodGFnWzFdID09PSBvcC50YWdJZCgpICYmIChtYXJrZXJJc0VtcHR5IHx8IG1hcmtlcklzUm9vdCkpIHtcbiAgICAgICAgZXZlbnRJc1RhZ2dlZCA9IG1hcmtlcklzUm9vdCA/IFwicm9vdFwiIDogdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFldmVudElzVGFnZ2VkKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGV2ZW50SXNUYWdnZWQgPT09IFwicm9vdFwiKSByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgY29uc3QgZXhwbGljaXRSZXBseU1hcmtlciA9IGhlZWRFeHBsaWNpdFJlcGx5TWFya2VyKCk7XG4gIGlmIChleHBsaWNpdFJlcGx5TWFya2VyICE9PSB2b2lkIDApIHJldHVybiBleHBsaWNpdFJlcGx5TWFya2VyO1xuICBpZiAoaGFzTWFya2VycyhldmVudCwgdGFnVHlwZSkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgZXhwZWN0ZWRUYWdzID0gb3AuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKS5tYXAoKHRhZykgPT4gdGFnWzFdKTtcbiAgZXhwZWN0ZWRUYWdzLnB1c2gob3AuaWQpO1xuICByZXR1cm4gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKS5ldmVyeSgodGFnKSA9PiBleHBlY3RlZFRhZ3MuaW5jbHVkZXModGFnWzFdKSk7XG59XG5mdW5jdGlvbiBldmVudFRocmVhZHMob3AsIGV2ZW50cykge1xuICBjb25zdCBldmVudHNCeUF1dGhvciA9IGV2ZW50c0J5U2FtZUF1dGhvcihvcCwgZXZlbnRzKTtcbiAgY29uc3QgdGhyZWFkRXZlbnRzID0gZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IGV2ZW50SXNQYXJ0T2ZUaHJlYWQob3AsIGV2ZW50LCBldmVudHNCeUF1dGhvcikpO1xuICByZXR1cm4gdGhyZWFkRXZlbnRzLnNvcnQoKGEsIGIpID0+IGEuY3JlYXRlZF9hdCAtIGIuY3JlYXRlZF9hdCk7XG59XG5mdW5jdGlvbiBnZXRFdmVudFJlcGx5SWQoZXZlbnQpIHtcbiAgY29uc3QgcmVwbHlUYWcgPSBnZXRSZXBseVRhZyhldmVudCk7XG4gIGlmIChyZXBseVRhZykgcmV0dXJuIHJlcGx5VGFnWzFdO1xuICBjb25zdCByb290VGFnID0gZ2V0Um9vdFRhZyhldmVudCk7XG4gIGlmIChyb290VGFnKSByZXR1cm4gcm9vdFRhZ1sxXTtcbn1cbmZ1bmN0aW9uIGlzRXZlbnRPcmlnaW5hbFBvc3QoZXZlbnQpIHtcbiAgcmV0dXJuIGdldEV2ZW50UmVwbHlJZChldmVudCkgPT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGV2ZW50VGhyZWFkSWRzKG9wLCBldmVudHMpIHtcbiAgY29uc3QgdGhyZWFkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgdGhyZWFkRXZlbnRzID0gZXZlbnRUaHJlYWRzKG9wLCBldmVudHMpO1xuICB0aHJlYWRFdmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHRocmVhZElkcy5zZXQoZXZlbnQuaWQsIGV2ZW50KSk7XG4gIHJldHVybiB0aHJlYWRJZHM7XG59XG5mdW5jdGlvbiBldmVudFJlcGxpZXMob3AsIGV2ZW50cywgdGhyZWFkRXZlbnRJZHMpIHtcbiAgdGhyZWFkRXZlbnRJZHMgPz89IG5ldyBTZXQoZXZlbnRUaHJlYWRJZHMob3AsIGV2ZW50cykua2V5cygpKTtcbiAgcmV0dXJuIGV2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiBldmVudElzUmVwbHkob3AsIGV2ZW50LCB0aHJlYWRFdmVudElkcykpO1xufVxuZnVuY3Rpb24gZXZlbnRJc1BhcnRPZlRocmVhZChvcCwgZXZlbnQsIGV2ZW50c0J5QXV0aG9yKSB7XG4gIGlmIChvcC5wdWJrZXkgIT09IGV2ZW50LnB1YmtleSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCB0YWdnZWRFdmVudElkcyA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gIGNvbnN0IGFsbFRhZ2dlZEV2ZW50c0FyZUJ5T3JpZ2luYWxBdXRob3IgPSB0YWdnZWRFdmVudElkcy5ldmVyeSgoaWQpID0+IGV2ZW50c0J5QXV0aG9yLmhhcyhpZCkpO1xuICByZXR1cm4gYWxsVGFnZ2VkRXZlbnRzQXJlQnlPcmlnaW5hbEF1dGhvcjtcbn1cbmZ1bmN0aW9uIGV2ZW50SGFzRVRhZ01hcmtlcnMoZXZlbnQpIHtcbiAgZm9yIChjb25zdCB0YWcgb2YgZXZlbnQudGFncykge1xuICAgIGlmICh0YWdbMF0gPT09IFwiZVwiICYmICh0YWdbM10gPz8gXCJcIikubGVuZ3RoID4gMCkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0Um9vdEV2ZW50SWQoZXZlbnQsIHNlYXJjaFRhZykge1xuICBzZWFyY2hUYWcgPz89IGV2ZW50LnRhZ1R5cGUoKTtcbiAgY29uc3Qgcm9vdEV2ZW50VGFnID0gZ2V0Um9vdFRhZyhldmVudCwgc2VhcmNoVGFnKTtcbiAgaWYgKHJvb3RFdmVudFRhZykgcmV0dXJuIHJvb3RFdmVudFRhZ1sxXTtcbiAgY29uc3QgcmVwbHlUYWcgPSBnZXRSZXBseVRhZyhldmVudCwgc2VhcmNoVGFnKTtcbiAgcmV0dXJuIHJlcGx5VGFnPy5bMV07XG59XG5mdW5jdGlvbiBnZXRSb290VGFnKGV2ZW50LCBzZWFyY2hUYWcpIHtcbiAgc2VhcmNoVGFnID8/PSBldmVudC50YWdUeXBlKCk7XG4gIGNvbnN0IHJvb3RFdmVudFRhZyA9IGV2ZW50LnRhZ3MuZmluZChpc1RhZ1Jvb3RUYWcpO1xuICBpZiAoIXJvb3RFdmVudFRhZykge1xuICAgIGlmIChldmVudEhhc0VUYWdNYXJrZXJzKGV2ZW50KSkgcmV0dXJuO1xuICAgIGNvbnN0IG1hdGNoaW5nVGFncyA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhzZWFyY2hUYWcpO1xuICAgIGlmIChtYXRjaGluZ1RhZ3MubGVuZ3RoIDwgMykgcmV0dXJuIG1hdGNoaW5nVGFnc1swXTtcbiAgfVxuICByZXR1cm4gcm9vdEV2ZW50VGFnO1xufVxudmFyIG5pcDIyUm9vdFRhZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJBXCIsIFwiRVwiLCBcIklcIl0pO1xudmFyIG5pcDIyUmVwbHlUYWdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiYVwiLCBcImVcIiwgXCJpXCJdKTtcbmZ1bmN0aW9uIGdldFJlcGx5VGFnKGV2ZW50LCBzZWFyY2hUYWcpIHtcbiAgaWYgKGV2ZW50LmtpbmQgPT09IDExMTEgLyogR2VuZXJpY1JlcGx5ICovKSB7XG4gICAgbGV0IHJlcGx5VGFnMjtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiBldmVudC50YWdzKSB7XG4gICAgICBpZiAobmlwMjJSb290VGFncy5oYXModGFnWzBdKSkgcmVwbHlUYWcyID0gdGFnO1xuICAgICAgZWxzZSBpZiAobmlwMjJSZXBseVRhZ3MuaGFzKHRhZ1swXSkpIHtcbiAgICAgICAgcmVwbHlUYWcyID0gdGFnO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcGx5VGFnMjtcbiAgfVxuICBzZWFyY2hUYWcgPz89IGV2ZW50LnRhZ1R5cGUoKTtcbiAgbGV0IGhhc01hcmtlcnMyID0gZmFsc2U7XG4gIGxldCByZXBseVRhZztcbiAgZm9yIChjb25zdCB0YWcgb2YgZXZlbnQudGFncykge1xuICAgIGlmICh0YWdbMF0gIT09IHNlYXJjaFRhZykgY29udGludWU7XG4gICAgaWYgKCh0YWdbM10gPz8gXCJcIikubGVuZ3RoID4gMCkgaGFzTWFya2VyczIgPSB0cnVlO1xuICAgIGlmIChoYXNNYXJrZXJzMiAmJiB0YWdbM10gPT09IFwicmVwbHlcIikgcmV0dXJuIHRhZztcbiAgICBpZiAoaGFzTWFya2VyczIgJiYgdGFnWzNdID09PSBcInJvb3RcIikgcmVwbHlUYWcgPSB0YWc7XG4gICAgaWYgKCFoYXNNYXJrZXJzMikgcmVwbHlUYWcgPSB0YWc7XG4gIH1cbiAgcmV0dXJuIHJlcGx5VGFnO1xufVxuZnVuY3Rpb24gaXNUYWdSb290VGFnKHRhZykge1xuICByZXR1cm4gdGFnWzBdID09PSBcIkVcIiB8fCB0YWdbM10gPT09IFwicm9vdFwiO1xufVxuXG4vLyBzcmMvZXZlbnRzL2ZldGNoLXRhZ2dlZC1ldmVudC50c1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hUYWdnZWRFdmVudCh0YWcsIG1hcmtlcikge1xuICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IGZvdW5kXCIpO1xuICBjb25zdCB0ID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3ModGFnLCBtYXJrZXIpO1xuICBpZiAodC5sZW5ndGggPT09IDApIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IFtfLCBpZCwgaGludF0gPSB0WzBdO1xuICBsZXQgcmVsYXkgPSBoaW50ICE9PSBcIlwiID8gdGhpcy5uZGsucG9vbC5nZXRSZWxheShoaW50KSA6IHZvaWQgMDtcbiAgY29uc3QgZXZlbnQgPSBhd2FpdCB0aGlzLm5kay5mZXRjaEV2ZW50KGlkLCB7fSwgcmVsYXkpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFJvb3RFdmVudChzdWJPcHRzKSB7XG4gIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3QgZm91bmRcIik7XG4gIGNvbnN0IHJvb3RUYWcgPSBnZXRSb290VGFnKHRoaXMpO1xuICBpZiAoIXJvb3RUYWcpIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiB0aGlzLm5kay5mZXRjaEV2ZW50RnJvbVRhZyhyb290VGFnLCB0aGlzLCBzdWJPcHRzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoUmVwbHlFdmVudChzdWJPcHRzKSB7XG4gIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3QgZm91bmRcIik7XG4gIGNvbnN0IHJlcGx5VGFnID0gZ2V0UmVwbHlUYWcodGhpcyk7XG4gIGlmICghcmVwbHlUYWcpIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiB0aGlzLm5kay5mZXRjaEV2ZW50RnJvbVRhZyhyZXBseVRhZywgdGhpcywgc3ViT3B0cyk7XG59XG5cbi8vIHNyYy9ldmVudHMva2luZC50c1xuZnVuY3Rpb24gaXNSZXBsYWNlYWJsZSgpIHtcbiAgaWYgKHRoaXMua2luZCA9PT0gdm9pZCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJLaW5kIG5vdCBzZXRcIik7XG4gIHJldHVybiBbMCwgM10uaW5jbHVkZXModGhpcy5raW5kKSB8fCB0aGlzLmtpbmQgPj0gMWU0ICYmIHRoaXMua2luZCA8IDJlNCB8fCB0aGlzLmtpbmQgPj0gM2U0ICYmIHRoaXMua2luZCA8IDRlNDtcbn1cbmZ1bmN0aW9uIGlzRXBoZW1lcmFsKCkge1xuICBpZiAodGhpcy5raW5kID09PSB2b2lkIDApIHRocm93IG5ldyBFcnJvcihcIktpbmQgbm90IHNldFwiKTtcbiAgcmV0dXJuIHRoaXMua2luZCA+PSAyZTQgJiYgdGhpcy5raW5kIDwgM2U0O1xufVxuZnVuY3Rpb24gaXNQYXJhbVJlcGxhY2VhYmxlKCkge1xuICBpZiAodGhpcy5raW5kID09PSB2b2lkIDApIHRocm93IG5ldyBFcnJvcihcIktpbmQgbm90IHNldFwiKTtcbiAgcmV0dXJuIHRoaXMua2luZCA+PSAzZTQgJiYgdGhpcy5raW5kIDwgNGU0O1xufVxuXG4vLyBzcmMvZXZlbnRzL25pcDE5LnRzXG5pbXBvcnQgeyBuaXAxOSBhcyBuaXAxOTIgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbnZhciBERUZBVUxUX1JFTEFZX0NPVU5UID0gMjtcbmZ1bmN0aW9uIGVuY29kZShtYXhSZWxheUNvdW50ID0gREVGQVVMVF9SRUxBWV9DT1VOVCkge1xuICBsZXQgcmVsYXlzID0gW107XG4gIGlmICh0aGlzLm9uUmVsYXlzLmxlbmd0aCA+IDApIHtcbiAgICByZWxheXMgPSB0aGlzLm9uUmVsYXlzLm1hcCgocmVsYXkpID0+IHJlbGF5LnVybCk7XG4gIH0gZWxzZSBpZiAodGhpcy5yZWxheSkge1xuICAgIHJlbGF5cyA9IFt0aGlzLnJlbGF5LnVybF07XG4gIH1cbiAgaWYgKHJlbGF5cy5sZW5ndGggPiBtYXhSZWxheUNvdW50KSB7XG4gICAgcmVsYXlzID0gcmVsYXlzLnNsaWNlKDAsIG1heFJlbGF5Q291bnQpO1xuICB9XG4gIGlmICh0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSB7XG4gICAgcmV0dXJuIG5pcDE5Mi5uYWRkckVuY29kZSh7XG4gICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICBwdWJrZXk6IHRoaXMucHVia2V5LFxuICAgICAgaWRlbnRpZmllcjogdGhpcy5yZXBsYWNlYWJsZURUYWcoKSxcbiAgICAgIHJlbGF5c1xuICAgIH0pO1xuICB9XG4gIGlmIChyZWxheXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBuaXAxOTIubmV2ZW50RW5jb2RlKHtcbiAgICAgIGlkOiB0aGlzLnRhZ0lkKCksXG4gICAgICByZWxheXMsXG4gICAgICBhdXRob3I6IHRoaXMucHVia2V5XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5pcDE5Mi5ub3RlRW5jb2RlKHRoaXMudGFnSWQoKSk7XG59XG5cbi8vIHNyYy9ldmVudHMvcmVwb3N0LnRzXG5hc3luYyBmdW5jdGlvbiByZXBvc3QocHVibGlzaCA9IHRydWUsIHNpZ25lcikge1xuICBpZiAoIXNpZ25lciAmJiBwdWJsaXNoKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIHNpZ25lciA9IHRoaXMubmRrLnNpZ25lcjtcbiAgfVxuICBjb25zdCBlID0gbmV3IE5ES0V2ZW50KHRoaXMubmRrLCB7XG4gICAga2luZDogZ2V0S2luZCh0aGlzKVxuICB9KTtcbiAgaWYgKCF0aGlzLmlzUHJvdGVjdGVkKSBlLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnJhd0V2ZW50KCkpO1xuICBlLnRhZyh0aGlzKTtcbiAgaWYgKHRoaXMua2luZCAhPT0gMSAvKiBUZXh0ICovKSB7XG4gICAgZS50YWdzLnB1c2goW1wia1wiLCBgJHt0aGlzLmtpbmR9YF0pO1xuICB9XG4gIGlmIChzaWduZXIpIGF3YWl0IGUuc2lnbihzaWduZXIpO1xuICBpZiAocHVibGlzaCkgYXdhaXQgZS5wdWJsaXNoKCk7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gZ2V0S2luZChldmVudCkge1xuICBpZiAoZXZlbnQua2luZCA9PT0gMSkge1xuICAgIHJldHVybiA2IC8qIFJlcG9zdCAqLztcbiAgfVxuICByZXR1cm4gMTYgLyogR2VuZXJpY1JlcG9zdCAqLztcbn1cblxuLy8gc3JjL2V2ZW50cy9zZXJpYWxpemVyLnRzXG5mdW5jdGlvbiBzZXJpYWxpemUoaW5jbHVkZVNpZyA9IGZhbHNlLCBpbmNsdWRlSWQgPSBmYWxzZSkge1xuICBjb25zdCBwYXlsb2FkID0gWzAsIHRoaXMucHVia2V5LCB0aGlzLmNyZWF0ZWRfYXQsIHRoaXMua2luZCwgdGhpcy50YWdzLCB0aGlzLmNvbnRlbnRdO1xuICBpZiAoaW5jbHVkZVNpZykgcGF5bG9hZC5wdXNoKHRoaXMuc2lnKTtcbiAgaWYgKGluY2x1ZGVJZCkgcGF5bG9hZC5wdXNoKHRoaXMuaWQpO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShzZXJpYWxpemVkRXZlbnQpIHtcbiAgY29uc3QgZXZlbnRBcnJheSA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZEV2ZW50KTtcbiAgY29uc3QgcmV0ID0ge1xuICAgIHB1YmtleTogZXZlbnRBcnJheVsxXSxcbiAgICBjcmVhdGVkX2F0OiBldmVudEFycmF5WzJdLFxuICAgIGtpbmQ6IGV2ZW50QXJyYXlbM10sXG4gICAgdGFnczogZXZlbnRBcnJheVs0XSxcbiAgICBjb250ZW50OiBldmVudEFycmF5WzVdXG4gIH07XG4gIGlmIChldmVudEFycmF5Lmxlbmd0aCA+PSA3KSB7XG4gICAgY29uc3QgZmlyc3QgPSBldmVudEFycmF5WzZdO1xuICAgIGNvbnN0IHNlY29uZCA9IGV2ZW50QXJyYXlbN107XG4gICAgaWYgKGZpcnN0ICYmIGZpcnN0Lmxlbmd0aCA9PT0gMTI4KSB7XG4gICAgICByZXQuc2lnID0gZmlyc3Q7XG4gICAgICBpZiAoc2Vjb25kICYmIHNlY29uZC5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgIHJldC5pZCA9IHNlY29uZDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZpcnN0ICYmIGZpcnN0Lmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgIHJldC5pZCA9IGZpcnN0O1xuICAgICAgaWYgKHNlY29uZCAmJiBzZWNvbmQubGVuZ3RoID09PSAxMjgpIHtcbiAgICAgICAgcmV0LnNpZyA9IHNlY29uZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gc3JjL2V2ZW50cy92YWxpZGF0aW9uLnRzXG5pbXBvcnQgeyBzY2hub3JyIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIjtcbmltcG9ydCB7IGJ5dGVzVG9IZXggfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuaW1wb3J0IHsgTFJVQ2FjaGUgfSBmcm9tIFwidHlwZXNjcmlwdC1scnUtY2FjaGVcIjtcblxuLy8gc3JjL2V2ZW50cy9zaWduYXR1cmUudHNcbnZhciB3b3JrZXI7XG52YXIgcHJvY2Vzc2luZ1F1ZXVlID0ge307XG5mdW5jdGlvbiBzaWduYXR1cmVWZXJpZmljYXRpb25Jbml0KHcpIHtcbiAgd29ya2VyID0gdztcbiAgd29ya2VyLm9ubWVzc2FnZSA9IChtc2cpID0+IHtcbiAgICBjb25zdCBbZXZlbnRJZCwgcmVzdWx0XSA9IG1zZy5kYXRhO1xuICAgIGNvbnN0IHJlY29yZCA9IHByb2Nlc3NpbmdRdWV1ZVtldmVudElkXTtcbiAgICBpZiAoIXJlY29yZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIk5vIHJlY29yZCBmb3VuZCBmb3IgZXZlbnRcIiwgZXZlbnRJZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBwcm9jZXNzaW5nUXVldWVbZXZlbnRJZF07XG4gICAgZm9yIChjb25zdCByZXNvbHZlIG9mIHJlY29yZC5yZXNvbHZlcykge1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZUFzeW5jKGV2ZW50LCBfcGVyc2lzdCkge1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gZXZlbnQuc2VyaWFsaXplKCk7XG4gICAgbGV0IGVucXVldWUgPSBmYWxzZTtcbiAgICBpZiAoIXByb2Nlc3NpbmdRdWV1ZVtldmVudC5pZF0pIHtcbiAgICAgIHByb2Nlc3NpbmdRdWV1ZVtldmVudC5pZF0gPSB7IGV2ZW50LCByZXNvbHZlczogW10gfTtcbiAgICAgIGVucXVldWUgPSB0cnVlO1xuICAgIH1cbiAgICBwcm9jZXNzaW5nUXVldWVbZXZlbnQuaWRdLnJlc29sdmVzLnB1c2gocmVzb2x2ZSk7XG4gICAgaWYgKCFlbnF1ZXVlKSByZXR1cm47XG4gICAgd29ya2VyPy5wb3N0TWVzc2FnZSh7XG4gICAgICBzZXJpYWxpemVkLFxuICAgICAgaWQ6IGV2ZW50LmlkLFxuICAgICAgc2lnOiBldmVudC5zaWcsXG4gICAgICBwdWJrZXk6IGV2ZW50LnB1YmtleVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIHNyYy9ldmVudHMvdmFsaWRhdGlvbi50c1xudmFyIFBVQktFWV9SRUdFWCA9IC9eW2EtZjAtOV17NjR9JC87XG5mdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgaWYgKHR5cGVvZiB0aGlzLmtpbmQgIT09IFwibnVtYmVyXCIpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB0aGlzLmNvbnRlbnQgIT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB0aGlzLmNyZWF0ZWRfYXQgIT09IFwibnVtYmVyXCIpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB0aGlzLnB1YmtleSAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuICBpZiAoIXRoaXMucHVia2V5Lm1hdGNoKFBVQktFWV9SRUdFWCkpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMudGFncykpIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ3NbaV07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRhZykpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRhZy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKHR5cGVvZiB0YWdbal0gPT09IFwib2JqZWN0XCIpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG52YXIgdmVyaWZpZWRTaWduYXR1cmVzID0gbmV3IExSVUNhY2hlKHtcbiAgbWF4U2l6ZTogMWUzLFxuICBlbnRyeUV4cGlyYXRpb25UaW1lSW5NUzogNmU0XG59KTtcbmZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZShwZXJzaXN0KSB7XG4gIGlmICh0eXBlb2YgdGhpcy5zaWduYXR1cmVWZXJpZmllZCA9PT0gXCJib29sZWFuXCIpIHJldHVybiB0aGlzLnNpZ25hdHVyZVZlcmlmaWVkO1xuICBjb25zdCBwcmV2VmVyaWZpY2F0aW9uID0gdmVyaWZpZWRTaWduYXR1cmVzLmdldCh0aGlzLmlkKTtcbiAgaWYgKHByZXZWZXJpZmljYXRpb24gIT09IG51bGwpIHtcbiAgICB0aGlzLnNpZ25hdHVyZVZlcmlmaWVkID0gISFwcmV2VmVyaWZpY2F0aW9uO1xuICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZVZlcmlmaWVkO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKHRoaXMubmRrPy5hc3luY1NpZ1ZlcmlmaWNhdGlvbikge1xuICAgICAgdmVyaWZ5U2lnbmF0dXJlQXN5bmModGhpcywgcGVyc2lzdCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChwZXJzaXN0KSB7XG4gICAgICAgICAgdGhpcy5zaWduYXR1cmVWZXJpZmllZCA9IHJlc3VsdDtcbiAgICAgICAgICBpZiAocmVzdWx0KSB2ZXJpZmllZFNpZ25hdHVyZXMuc2V0KHRoaXMuaWQsIHRoaXMuc2lnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIHRoaXMubmRrPy5lbWl0KFwiZXZlbnQ6aW52YWxpZC1zaWdcIiwgdGhpcyk7XG4gICAgICAgICAgdmVyaWZpZWRTaWduYXR1cmVzLnNldCh0aGlzLmlkLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoYXNoID0gc2hhMjU2KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0aGlzLnNlcmlhbGl6ZSgpKSk7XG4gICAgICBjb25zdCByZXMgPSBzY2hub3JyLnZlcmlmeSh0aGlzLnNpZywgaGFzaCwgdGhpcy5wdWJrZXkpO1xuICAgICAgaWYgKHJlcykgdmVyaWZpZWRTaWduYXR1cmVzLnNldCh0aGlzLmlkLCB0aGlzLnNpZyk7XG4gICAgICBlbHNlIHZlcmlmaWVkU2lnbmF0dXJlcy5zZXQodGhpcy5pZCwgZmFsc2UpO1xuICAgICAgdGhpcy5zaWduYXR1cmVWZXJpZmllZCA9IHJlcztcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9IGNhdGNoIChfZXJyKSB7XG4gICAgdGhpcy5zaWduYXR1cmVWZXJpZmllZCA9IGZhbHNlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RXZlbnRIYXNoKCkge1xuICByZXR1cm4gZ2V0RXZlbnRIYXNoRnJvbVNlcmlhbGl6ZWRFdmVudCh0aGlzLnNlcmlhbGl6ZSgpKTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50SGFzaEZyb21TZXJpYWxpemVkRXZlbnQoc2VyaWFsaXplZEV2ZW50KSB7XG4gIGNvbnN0IGV2ZW50SGFzaCA9IHNoYTI1NihuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc2VyaWFsaXplZEV2ZW50KSk7XG4gIHJldHVybiBieXRlc1RvSGV4KGV2ZW50SGFzaCk7XG59XG5cbi8vIHNyYy9ldmVudHMvaW5kZXgudHNcbnZhciBza2lwQ2xpZW50VGFnT25LaW5kcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgMCAvKiBNZXRhZGF0YSAqLyxcbiAgNCAvKiBFbmNyeXB0ZWREaXJlY3RNZXNzYWdlICovLFxuICAxMDU5IC8qIEdpZnRXcmFwICovLFxuICAxMyAvKiBHaWZ0V3JhcFNlYWwgKi8sXG4gIDMgLyogQ29udGFjdHMgKi8sXG4gIDk3MzQgLyogWmFwUmVxdWVzdCAqLyxcbiAgNSAvKiBFdmVudERlbGV0aW9uICovXG5dKTtcbnZhciBOREtFdmVudCA9IGNsYXNzIF9OREtFdmVudCBleHRlbmRzIEV2ZW50RW1pdHRlcjIge1xuICBuZGs7XG4gIGNyZWF0ZWRfYXQ7XG4gIGNvbnRlbnQgPSBcIlwiO1xuICB0YWdzID0gW107XG4gIGtpbmQ7XG4gIGlkID0gXCJcIjtcbiAgc2lnO1xuICBwdWJrZXkgPSBcIlwiO1xuICBzaWduYXR1cmVWZXJpZmllZDtcbiAgX2F1dGhvciA9IHZvaWQgMDtcbiAgLyoqXG4gICAqIFRoZSByZWxheSB0aGF0IHRoaXMgZXZlbnQgd2FzIGZpcnN0IHJlY2VpdmVkIGZyb20uXG4gICAqL1xuICByZWxheTtcbiAgLyoqXG4gICAqIFRoZSByZWxheXMgdGhhdCB0aGlzIGV2ZW50IHdhcyByZWNlaXZlZCBmcm9tIGFuZC9vciBzdWNjZXNzZnVsbHkgcHVibGlzaGVkIHRvLlxuICAgKi9cbiAgZ2V0IG9uUmVsYXlzKCkge1xuICAgIGxldCByZXMgPSBbXTtcbiAgICBpZiAoIXRoaXMubmRrKSB7XG4gICAgICBpZiAodGhpcy5yZWxheSkgcmVzLnB1c2godGhpcy5yZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHRoaXMubmRrLnN1Yk1hbmFnZXIuc2VlbkV2ZW50cy5nZXQodGhpcy5pZCkgfHwgW107XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzdGF0dXMgb2YgdGhlIHB1Ymxpc2ggb3BlcmF0aW9uLlxuICAgKi9cbiAgcHVibGlzaFN0YXR1cyA9IFwic3VjY2Vzc1wiO1xuICBwdWJsaXNoRXJyb3I7XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMuY3JlYXRlZF9hdCA9IGV2ZW50Py5jcmVhdGVkX2F0O1xuICAgIHRoaXMuY29udGVudCA9IGV2ZW50Py5jb250ZW50IHx8IFwiXCI7XG4gICAgdGhpcy50YWdzID0gZXZlbnQ/LnRhZ3MgfHwgW107XG4gICAgdGhpcy5pZCA9IGV2ZW50Py5pZCB8fCBcIlwiO1xuICAgIHRoaXMuc2lnID0gZXZlbnQ/LnNpZztcbiAgICB0aGlzLnB1YmtleSA9IGV2ZW50Py5wdWJrZXkgfHwgXCJcIjtcbiAgICB0aGlzLmtpbmQgPSBldmVudD8ua2luZDtcbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBfTkRLRXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLnJlbGF5KSB7XG4gICAgICAgIHRoaXMucmVsYXkgPSBldmVudC5yZWxheTtcbiAgICAgICAgdGhpcy5uZGs/LnN1Yk1hbmFnZXIuc2VlbkV2ZW50KGV2ZW50LmlkLCB0aGlzLnJlbGF5KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHVibGlzaFN0YXR1cyA9IGV2ZW50LnB1Ymxpc2hTdGF0dXM7XG4gICAgICB0aGlzLnB1Ymxpc2hFcnJvciA9IGV2ZW50LnB1Ymxpc2hFcnJvcjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGFuIE5ES0V2ZW50IGZyb20gYSBzZXJpYWxpemVkIHBheWxvYWQuXG4gICAqIEBwYXJhbSBuZGtcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBzdGF0aWMgZGVzZXJpYWxpemUobmRrLCBldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0V2ZW50KG5kaywgZGVzZXJpYWxpemUoZXZlbnQpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXZlbnQgYXMgaXMuXG4gICAqL1xuICByYXdFdmVudCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlZF9hdDogdGhpcy5jcmVhdGVkX2F0LFxuICAgICAgY29udGVudDogdGhpcy5jb250ZW50LFxuICAgICAgdGFnczogdGhpcy50YWdzLFxuICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgcHVia2V5OiB0aGlzLnB1YmtleSxcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgc2lnOiB0aGlzLnNpZ1xuICAgIH07XG4gIH1cbiAgc2V0IGF1dGhvcih1c2VyKSB7XG4gICAgdGhpcy5wdWJrZXkgPSB1c2VyLnB1YmtleTtcbiAgICB0aGlzLl9hdXRob3IgPSB1c2VyO1xuICAgIHRoaXMuX2F1dGhvci5uZGsgPz89IHRoaXMubmRrO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIE5ES1VzZXIgZm9yIHRoZSBhdXRob3Igb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgZ2V0IGF1dGhvcigpIHtcbiAgICBpZiAodGhpcy5fYXV0aG9yKSByZXR1cm4gdGhpcy5fYXV0aG9yO1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICBjb25zdCB1c2VyID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogdGhpcy5wdWJrZXkgfSk7XG4gICAgdGhpcy5fYXV0aG9yID0gdXNlcjtcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICAvKipcbiAgICogTklQLTczIHRhZ2dpbmcgb2YgZXh0ZXJuYWwgZW50aXRpZXNcbiAgICogQHBhcmFtIGVudGl0eSB0byBiZSB0YWdnZWRcbiAgICogQHBhcmFtIHR5cGUgb2YgdGhlIGVudGl0eVxuICAgKiBAcGFyYW0gbWFya2VyVXJsIHRvIGJlIHVzZWQgYXMgdGhlIG1hcmtlciBVUkxcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBldmVudC50YWdFeHRlcm5hbChcImh0dHBzOi8vZXhhbXBsZS5jb20vYXJ0aWNsZS8xMjMjbm9zdHJcIiwgXCJ1cmxcIik7XG4gICAqIGV2ZW50LnRhZ3MgPT4gW1tcImlcIiwgXCJodHRwczovL2V4YW1wbGUuY29tLzEyM1wiXSwgW1wia1wiLCBcImh0dHBzOi8vZXhhbXBsZS5jb21cIl1dXG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZSB0YWcgYSBwb2RjYXN0Oml0ZW06Z3VpZFxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGV2ZW50LnRhZ0V4dGVybmFsKFwiZTMyYjQ4OTAtYjllYS00YWVmLWEwYmYtNTRiNzg3ODMzZGM1XCIsIFwicG9kY2FzdDppdGVtOmd1aWRcIik7XG4gICAqIGV2ZW50LnRhZ3MgPT4gW1tcImlcIiwgXCJwb2RjYXN0Oml0ZW06Z3VpZDplMzJiNDg5MC1iOWVhLTRhZWYtYTBiZi01NGI3ODc4MzNkYzVcIl0sIFtcImtcIiwgXCJwb2RjYXN0Oml0ZW06Z3VpZFwiXV1cbiAgICogYGBgXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNzMubWRcbiAgICovXG4gIHRhZ0V4dGVybmFsKGVudGl0eSwgdHlwZSwgbWFya2VyVXJsKSB7XG4gICAgY29uc3QgaVRhZyA9IFtcImlcIl07XG4gICAgY29uc3Qga1RhZyA9IFtcImtcIl07XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwidXJsXCI6IHtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChlbnRpdHkpO1xuICAgICAgICB1cmwuaGFzaCA9IFwiXCI7XG4gICAgICAgIGlUYWcucHVzaCh1cmwudG9TdHJpbmcoKSk7XG4gICAgICAgIGtUYWcucHVzaChgJHt1cmwucHJvdG9jb2x9Ly8ke3VybC5ob3N0fWApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJoYXNodGFnXCI6XG4gICAgICAgIGlUYWcucHVzaChgIyR7ZW50aXR5LnRvTG93ZXJDYXNlKCl9YCk7XG4gICAgICAgIGtUYWcucHVzaChcIiNcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImdlb2hhc2hcIjpcbiAgICAgICAgaVRhZy5wdXNoKGBnZW86JHtlbnRpdHkudG9Mb3dlckNhc2UoKX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwiZ2VvXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpc2JuXCI6XG4gICAgICAgIGlUYWcucHVzaChgaXNibjoke2VudGl0eS5yZXBsYWNlKC8tL2csIFwiXCIpfWApO1xuICAgICAgICBrVGFnLnB1c2goXCJpc2JuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb2RjYXN0Omd1aWRcIjpcbiAgICAgICAgaVRhZy5wdXNoKGBwb2RjYXN0Omd1aWQ6JHtlbnRpdHl9YCk7XG4gICAgICAgIGtUYWcucHVzaChcInBvZGNhc3Q6Z3VpZFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicG9kY2FzdDppdGVtOmd1aWRcIjpcbiAgICAgICAgaVRhZy5wdXNoKGBwb2RjYXN0Oml0ZW06Z3VpZDoke2VudGl0eX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwicG9kY2FzdDppdGVtOmd1aWRcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvZGNhc3Q6cHVibGlzaGVyOmd1aWRcIjpcbiAgICAgICAgaVRhZy5wdXNoKGBwb2RjYXN0OnB1Ymxpc2hlcjpndWlkOiR7ZW50aXR5fWApO1xuICAgICAgICBrVGFnLnB1c2goXCJwb2RjYXN0OnB1Ymxpc2hlcjpndWlkXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpc2FuXCI6XG4gICAgICAgIGlUYWcucHVzaChgaXNhbjoke2VudGl0eS5zcGxpdChcIi1cIikuc2xpY2UoMCwgNCkuam9pbihcIi1cIil9YCk7XG4gICAgICAgIGtUYWcucHVzaChcImlzYW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRvaVwiOlxuICAgICAgICBpVGFnLnB1c2goYGRvaToke2VudGl0eS50b0xvd2VyQ2FzZSgpfWApO1xuICAgICAgICBrVGFnLnB1c2goXCJkb2lcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBOSVAtNzMgZW50aXR5IHR5cGU6ICR7dHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKG1hcmtlclVybCkge1xuICAgICAgaVRhZy5wdXNoKG1hcmtlclVybCk7XG4gICAgfVxuICAgIHRoaXMudGFncy5wdXNoKGlUYWcpO1xuICAgIHRoaXMudGFncy5wdXNoKGtUYWcpO1xuICB9XG4gIC8qKlxuICAgKiBUYWcgYSB1c2VyIHdpdGggYW4gb3B0aW9uYWwgbWFya2VyLlxuICAgKiBAcGFyYW0gdGFyZ2V0IFdoYXQgaXMgdG8gYmUgdGFnZ2VkLiBDYW4gYmUgYW4gTkRLVXNlciwgTkRLRXZlbnQsIG9yIGFuIE5ES1RhZy5cbiAgICogQHBhcmFtIG1hcmtlciBUaGUgbWFya2VyIHRvIHVzZSBpbiB0aGUgdGFnLlxuICAgKiBAcGFyYW0gc2tpcEF1dGhvclRhZyBXaGV0aGVyIHRvIGV4cGxpY2l0bHkgc2tpcCBhZGRpbmcgdGhlIGF1dGhvciB0YWcgb2YgdGhlIGV2ZW50LlxuICAgKiBAcGFyYW0gZm9yY2VUYWcgRm9yY2UgYSBzcGVjaWZpYyB0YWcgdG8gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IFwiZVwiIG9yIFwiYVwiIHRhZy5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiByZXBseS50YWcob3BFdmVudCwgXCJyZXBseVwiKTtcbiAgICogLy8gcmVwbHkudGFncyA9PiBbW1wiZVwiLCA8aWQ+LCA8cmVsYXk+LCBcInJlcGx5XCJdXVxuICAgKiBgYGBcbiAgICovXG4gIHRhZyh0YXJnZXQsIG1hcmtlciwgc2tpcEF1dGhvclRhZywgZm9yY2VUYWcpIHtcbiAgICBsZXQgdGFncyA9IFtdO1xuICAgIGNvbnN0IGlzTkRLVXNlciA9IHRhcmdldC5mZXRjaFByb2ZpbGUgIT09IHZvaWQgMDtcbiAgICBpZiAoaXNOREtVc2VyKSB7XG4gICAgICBmb3JjZVRhZyA/Pz0gXCJwXCI7XG4gICAgICBjb25zdCB0YWcgPSBbZm9yY2VUYWcsIHRhcmdldC5wdWJrZXldO1xuICAgICAgaWYgKG1hcmtlcikgdGFnLnB1c2goLi4uW1wiXCIsIG1hcmtlcl0pO1xuICAgICAgdGFncy5wdXNoKHRhZyk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBfTkRLRXZlbnQpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gdGFyZ2V0O1xuICAgICAgc2tpcEF1dGhvclRhZyA/Pz0gZXZlbnQ/LnB1YmtleSA9PT0gdGhpcy5wdWJrZXk7XG4gICAgICB0YWdzID0gZXZlbnQucmVmZXJlbmNlVGFncyhtYXJrZXIsIHNraXBBdXRob3JUYWcsIGZvcmNlVGFnKTtcbiAgICAgIGZvciAoY29uc3QgcFRhZyBvZiBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpKSB7XG4gICAgICAgIGlmIChwVGFnWzFdID09PSB0aGlzLnB1YmtleSkgY29udGludWU7XG4gICAgICAgIGlmICh0aGlzLnRhZ3MuZmluZCgodCkgPT4gdFswXSA9PT0gXCJwXCIgJiYgdFsxXSA9PT0gcFRhZ1sxXSkpIGNvbnRpbnVlO1xuICAgICAgICB0aGlzLnRhZ3MucHVzaChbXCJwXCIsIHBUYWdbMV1dKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgdGFncyA9IFt0YXJnZXRdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIsIHRhcmdldCk7XG4gICAgfVxuICAgIHRoaXMudGFncyA9IG1lcmdlVGFncyh0aGlzLnRhZ3MsIHRhZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYSBOb3N0ckV2ZW50IG9iamVjdCwgdHJ5aW5nIHRvIGZpbGwgaW4gbWlzc2luZyBmaWVsZHNcbiAgICogd2hlbiBwb3NzaWJsZSwgYWRkaW5nIHRhZ3Mgd2hlbiBuZWNlc3NhcnkuXG4gICAqIEBwYXJhbSBwdWJrZXkge3N0cmluZ30gVGhlIHB1YmtleSBvZiB0aGUgdXNlciB3aG8gdGhlIGV2ZW50IGJlbG9uZ3MgdG8uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE5vc3RyRXZlbnQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIE5vc3RyRXZlbnQuXG4gICAqL1xuICBhc3luYyB0b05vc3RyRXZlbnQocHVia2V5KSB7XG4gICAgaWYgKCFwdWJrZXkgJiYgdGhpcy5wdWJrZXkgPT09IFwiXCIpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5kaz8uc2lnbmVyPy51c2VyKCk7XG4gICAgICB0aGlzLnB1YmtleSA9IHVzZXI/LnB1YmtleSB8fCBcIlwiO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY3JlYXRlZF9hdCkge1xuICAgICAgdGhpcy5jcmVhdGVkX2F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZW50LCB0YWdzIH0gPSBhd2FpdCB0aGlzLmdlbmVyYXRlVGFncygpO1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQgfHwgXCJcIjtcbiAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmlkID0gdGhpcy5nZXRFdmVudEhhc2goKTtcbiAgICB9IGNhdGNoIChfZSkge1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yYXdFdmVudCgpO1xuICB9XG4gIHNlcmlhbGl6ZSA9IHNlcmlhbGl6ZS5iaW5kKHRoaXMpO1xuICBnZXRFdmVudEhhc2ggPSBnZXRFdmVudEhhc2guYmluZCh0aGlzKTtcbiAgdmFsaWRhdGUgPSB2YWxpZGF0ZS5iaW5kKHRoaXMpO1xuICB2ZXJpZnlTaWduYXR1cmUgPSB2ZXJpZnlTaWduYXR1cmUuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIElzIHRoaXMgZXZlbnQgcmVwbGFjZWFibGUgKHdoZXRoZXIgcGFyYW1ldGVyaXplZCBvciBub3QpP1xuICAgKlxuICAgKiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgZm9yIGtpbmQgMCwgMywgMTBrLTIwayBhbmQgMzBrLTQwa1xuICAgKi9cbiAgaXNSZXBsYWNlYWJsZSA9IGlzUmVwbGFjZWFibGUuYmluZCh0aGlzKTtcbiAgaXNFcGhlbWVyYWwgPSBpc0VwaGVtZXJhbC5iaW5kKHRoaXMpO1xuICBpc0R2bSA9ICgpID0+IHRoaXMua2luZCAmJiB0aGlzLmtpbmQgPj0gNWUzICYmIHRoaXMua2luZCA8PSA3ZTM7XG4gIC8qKlxuICAgKiBJcyB0aGlzIGV2ZW50IHBhcmFtZXRlcml6ZWQgcmVwbGFjZWFibGU/XG4gICAqXG4gICAqIFRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBmb3Iga2luZCAzMGstNDBrXG4gICAqL1xuICBpc1BhcmFtUmVwbGFjZWFibGUgPSBpc1BhcmFtUmVwbGFjZWFibGUuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIEVuY29kZXMgYSBiZWNoMzIgaWQuXG4gICAqXG4gICAqIEBwYXJhbSByZWxheXMge3N0cmluZ1tdfSBUaGUgcmVsYXlzIHRvIGVuY29kZSBpbiB0aGUgaWRcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBFbmNvZGVkIG5hZGRyLCBub3RlIG9yIG5ldmVudC5cbiAgICovXG4gIGVuY29kZSA9IGVuY29kZS5iaW5kKHRoaXMpO1xuICBlbmNyeXB0ID0gZW5jcnlwdC5iaW5kKHRoaXMpO1xuICBkZWNyeXB0ID0gZGVjcnlwdC5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogR2V0IGFsbCB0YWdzIHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICogQHBhcmFtIHRhZ05hbWUge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIHRhZyB0byBzZWFyY2ggZm9yXG4gICAqIEByZXR1cm5zIHtOREtUYWdbXX0gQW4gYXJyYXkgb2YgdGhlIG1hdGNoaW5nIHRhZ3NcbiAgICovXG4gIGdldE1hdGNoaW5nVGFncyh0YWdOYW1lLCBtYXJrZXIpIHtcbiAgICBjb25zdCB0ID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IHRhZ05hbWUpO1xuICAgIGlmIChtYXJrZXIgPT09IHZvaWQgMCkgcmV0dXJuIHQ7XG4gICAgcmV0dXJuIHQuZmlsdGVyKCh0YWcpID0+IHRhZ1szXSA9PT0gbWFya2VyKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGV2ZW50IGhhcyBhIHRhZyB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqIEBwYXJhbSB0YWdOYW1lXG4gICAqIEBwYXJhbSBtYXJrZXJcbiAgICogQHJldHVybnNcbiAgICovXG4gIGhhc1RhZyh0YWdOYW1lLCBtYXJrZXIpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLnNvbWUoKHRhZykgPT4gdGFnWzBdID09PSB0YWdOYW1lICYmICghbWFya2VyIHx8IHRhZ1szXSA9PT0gbWFya2VyKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZmlyc3QgdGFnIHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICogQHBhcmFtIHRhZ05hbWUgVGFnIG5hbWUgdG8gc2VhcmNoIGZvclxuICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IHRhZyB3aXRoIHRoZSBnaXZlbiBuYW1lLCBvciB1bmRlZmluZWQgaWYgbm8gc3VjaCB0YWcgZXhpc3RzXG4gICAqL1xuICB0YWdWYWx1ZSh0YWdOYW1lLCBtYXJrZXIpIHtcbiAgICBjb25zdCB0YWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3ModGFnTmFtZSwgbWFya2VyKTtcbiAgICBpZiAodGFncy5sZW5ndGggPT09IDApIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIHRhZ3NbMF1bMV07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIE5JUC0zMSBcImFsdFwiIHRhZyBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBnZXQgYWx0KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiYWx0XCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBOSVAtMzEgXCJhbHRcIiB0YWcgb2YgdGhlIGV2ZW50LiBVc2UgdGhpcyB0byBzZXQgYW4gYWx0IHRhZyBzb1xuICAgKiBjbGllbnRzIHRoYXQgZG9uJ3QgaGFuZGxlIGEgcGFydGljdWxhciBldmVudCBraW5kIGNhbiBkaXNwbGF5IHNvbWV0aGluZ1xuICAgKiB1c2VmdWwgZm9yIHVzZXJzLlxuICAgKi9cbiAgc2V0IGFsdChhbHQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImFsdFwiKTtcbiAgICBpZiAoYWx0KSB0aGlzLnRhZ3MucHVzaChbXCJhbHRcIiwgYWx0XSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIE5JUC0zMyBcImRcIiB0YWcgb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgZ2V0IGRUYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBOSVAtMzMgXCJkXCIgdGFnIG9mIHRoZSBldmVudC5cbiAgICovXG4gIHNldCBkVGFnKHZhbHVlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkXCIpO1xuICAgIGlmICh2YWx1ZSkgdGhpcy50YWdzLnB1c2goW1wiZFwiLCB2YWx1ZV0pO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIHRhZ3Mgd2l0aCB0aGUgZ2l2ZW4gbmFtZSAoZS5nLiBcImRcIiwgXCJhXCIsIFwicFwiKVxuICAgKiBAcGFyYW0gdGFnTmFtZSBUYWcgbmFtZShzKSB0byBzZWFyY2ggZm9yIGFuZCByZW1vdmVcbiAgICogQHBhcmFtIG1hcmtlciBPcHRpb25hbCBtYXJrZXIgdG8gY2hlY2sgZm9yIHRvb1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBSZW1vdmUgYSB0YWdzIHdpdGggYSBcImRlZmVyXCIgbWFya2VyXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogZXZlbnQudGFncyA9IFtcbiAgICogICBbXCJhXCIsIFwiLi4uLlwiLCBcImRlZmVyXCJdLFxuICAgKiAgIFtcImFcIiwgXCIuLi4uXCIsIFwibm8tZGVmZXJcIl0sXG4gICAqIF1cbiAgICpcbiAgICogZXZlbnQucmVtb3ZlVGFnKFwiYVwiLCBcImRlZmVyXCIpO1xuICAgKlxuICAgKiAvLyBldmVudC50YWdzID0+IFtbXCJhXCIsIFwiLi4uLlwiLCBcIm5vLWRlZmVyXCJdXVxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHJlbW92ZVRhZyh0YWdOYW1lLCBtYXJrZXIpIHtcbiAgICBjb25zdCB0YWdOYW1lcyA9IEFycmF5LmlzQXJyYXkodGFnTmFtZSkgPyB0YWdOYW1lIDogW3RhZ05hbWVdO1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4ge1xuICAgICAgY29uc3QgaW5jbHVkZSA9IHRhZ05hbWVzLmluY2x1ZGVzKHRhZ1swXSk7XG4gICAgICBjb25zdCBoYXNNYXJrZXIgPSBtYXJrZXIgPyB0YWdbM10gPT09IG1hcmtlciA6IHRydWU7XG4gICAgICByZXR1cm4gIShpbmNsdWRlICYmIGhhc01hcmtlcik7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlcGxhY2UgYSB0YWcgd2l0aCBhIG5ldyB2YWx1ZS4gSWYgbm90IGZvdW5kLCBpdCB3aWxsIGJlIGFkZGVkLlxuICAgKiBAcGFyYW0gdGFnIFRoZSB0YWcgdG8gcmVwbGFjZS5cbiAgICogQHBhcmFtIHZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSB0YWcuXG4gICAqL1xuICByZXBsYWNlVGFnKHRhZykge1xuICAgIHRoaXMucmVtb3ZlVGFnKHRhZ1swXSk7XG4gICAgdGhpcy50YWdzLnB1c2godGFnKTtcbiAgfVxuICAvKipcbiAgICogU2lnbiB0aGUgZXZlbnQgaWYgYSBzaWduZXIgaXMgcHJlc2VudC5cbiAgICpcbiAgICogSXQgd2lsbCBnZW5lcmF0ZSB0YWdzLlxuICAgKiBSZXBsZWFjYWJsZSBldmVudHMgd2lsbCBoYXZlIHRoZWlyIGNyZWF0ZWRfYXQgZmllbGQgc2V0IHRvIHRoZSBjdXJyZW50IHRpbWUuXG4gICAqIEBwYXJhbSBzaWduZXIge05ES1NpZ25lcn0gVGhlIE5ES1NpZ25lciB0byB1c2UgdG8gc2lnbiB0aGUgZXZlbnRcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHNpZ25hdHVyZSBvZiB0aGUgc2lnbmVkIGV2ZW50LlxuICAgKi9cbiAgYXN5bmMgc2lnbihzaWduZXIpIHtcbiAgICBpZiAoIXNpZ25lcikge1xuICAgICAgdGhpcy5uZGs/LmFzc2VydFNpZ25lcigpO1xuICAgICAgc2lnbmVyID0gdGhpcy5uZGs/LnNpZ25lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hdXRob3IgPSBhd2FpdCBzaWduZXIudXNlcigpO1xuICAgIH1cbiAgICBjb25zdCBub3N0ckV2ZW50ID0gYXdhaXQgdGhpcy50b05vc3RyRXZlbnQoKTtcbiAgICB0aGlzLnNpZyA9IGF3YWl0IHNpZ25lci5zaWduKG5vc3RyRXZlbnQpO1xuICAgIHJldHVybiB0aGlzLnNpZztcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHJlbGF5U2V0XG4gICAqIEBwYXJhbSB0aW1lb3V0TXNcbiAgICogQHBhcmFtIHJlcXVpcmVkUmVsYXlDb3VudFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgcHVibGlzaFJlcGxhY2VhYmxlKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgIHRoaXMuaWQgPSBcIlwiO1xuICAgIHRoaXMuY3JlYXRlZF9hdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgdGhpcy5zaWcgPSBcIlwiO1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2gocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdCB0byBzaWduIGFuZCB0aGVuIHB1Ymxpc2ggYW4gTkRLRXZlbnQgdG8gYSBnaXZlbiByZWxheVNldC5cbiAgICogSWYgbm8gcmVsYXlTZXQgaXMgcHJvdmlkZWQsIHRoZSByZWxheVNldCB3aWxsIGJlIGNhbGN1bGF0ZWQgYnkgTkRLLlxuICAgKiBAcGFyYW0gcmVsYXlTZXQge05ES1JlbGF5U2V0fSBUaGUgcmVsYXlTZXQgdG8gcHVibGlzaCB0aGUgZXZlbiB0by5cbiAgICogQHBhcmFtIHRpbWVvdXRNIHtudW1iZXJ9IFRoZSB0aW1lb3V0IGZvciB0aGUgcHVibGlzaCBvcGVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBAcGFyYW0gcmVxdWlyZWRSZWxheUNvdW50IFRoZSBudW1iZXIgb2YgcmVsYXlzIHRoYXQgbXVzdCByZWNlaXZlIHRoZSBldmVudCBmb3IgdGhlIHB1Ymxpc2ggdG8gYmUgY29uc2lkZXJlZCBzdWNjZXNzZnVsLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVsYXlzIHRoZSBldmVudCB3YXMgcHVibGlzaGVkIHRvLlxuICAgKi9cbiAgYXN5bmMgcHVibGlzaChyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpIHtcbiAgICBpZiAoIXRoaXMuc2lnKSBhd2FpdCB0aGlzLnNpZ24oKTtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREtFdmVudCBtdXN0IGJlIGFzc29jaWF0ZWQgd2l0aCBhbiBOREsgaW5zdGFuY2UgdG8gcHVibGlzaFwiKTtcbiAgICBpZiAoIXJlbGF5U2V0IHx8IHJlbGF5U2V0LnNpemUgPT09IDApIHtcbiAgICAgIHJlbGF5U2V0ID0gdGhpcy5uZGsuZGV2V3JpdGVSZWxheVNldCB8fCBhd2FpdCBjYWxjdWxhdGVSZWxheVNldEZyb21FdmVudCh0aGlzLm5kaywgdGhpcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDUgLyogRXZlbnREZWxldGlvbiAqLyAmJiB0aGlzLm5kay5jYWNoZUFkYXB0ZXI/LmRlbGV0ZUV2ZW50SWRzKSB7XG4gICAgICBjb25zdCBlVGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKS5tYXAoKHRhZykgPT4gdGFnWzFdKTtcbiAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5kZWxldGVFdmVudElkcyhlVGFncyk7XG4gICAgfVxuICAgIGNvbnN0IHJhd0V2ZW50ID0gdGhpcy5yYXdFdmVudCgpO1xuICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXI/LmFkZFVucHVibGlzaGVkRXZlbnQgJiYgc2hvdWxkVHJhY2tVbnB1Ymxpc2hlZEV2ZW50KHRoaXMpKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuYWRkVW5wdWJsaXNoZWRFdmVudCh0aGlzLCByZWxheVNldC5yZWxheVVybHMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWRkaW5nIHVucHVibGlzaGVkIGV2ZW50IHRvIGNhY2hlXCIsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSA1IC8qIEV2ZW50RGVsZXRpb24gKi8gJiYgdGhpcy5uZGsuY2FjaGVBZGFwdGVyPy5kZWxldGVFdmVudElkcykge1xuICAgICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmRlbGV0ZUV2ZW50SWRzKHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKS5tYXAoKHRhZykgPT4gdGFnWzFdKSk7XG4gICAgfVxuICAgIHRoaXMubmRrLnN1Yk1hbmFnZXIuZGlzcGF0Y2hFdmVudChyYXdFdmVudCwgdm9pZCAwLCB0cnVlKTtcbiAgICBjb25zdCByZWxheXMgPSBhd2FpdCByZWxheVNldC5wdWJsaXNoKHRoaXMsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KTtcbiAgICByZWxheXMuZm9yRWFjaCgocmVsYXkpID0+IHRoaXMubmRrPy5zdWJNYW5hZ2VyLnNlZW5FdmVudCh0aGlzLmlkLCByZWxheSkpO1xuICAgIHJldHVybiByZWxheXM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0YWdzIGZvciB1c2Vycywgbm90ZXMsIGFuZCBvdGhlciBldmVudHMgdGFnZ2VkIGluIGNvbnRlbnQuXG4gICAqIFdpbGwgYWxzbyBnZW5lcmF0ZSByYW5kb20gXCJkXCIgdGFnIGZvciBwYXJhbWV0ZXJpemVkIHJlcGxhY2VhYmxlIGV2ZW50cyB3aGVyZSBuZWVkZWQuXG4gICAqIEByZXR1cm5zIHtDb250ZW50VGFnfSBUaGUgdGFncyBhbmQgY29udGVudCBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZVRhZ3MoKSB7XG4gICAgbGV0IHRhZ3MgPSBbXTtcbiAgICBjb25zdCBnID0gYXdhaXQgZ2VuZXJhdGVDb250ZW50VGFncyh0aGlzLmNvbnRlbnQsIHRoaXMudGFncyk7XG4gICAgY29uc3QgY29udGVudCA9IGcuY29udGVudDtcbiAgICB0YWdzID0gZy50YWdzO1xuICAgIGlmICh0aGlzLmtpbmQgJiYgdGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgICAgY29uc3QgZFRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiZFwiKVswXTtcbiAgICAgIGlmICghZFRhZykge1xuICAgICAgICBjb25zdCB0aXRsZSA9IHRoaXMudGFnVmFsdWUoXCJ0aXRsZVwiKTtcbiAgICAgICAgY29uc3QgcmFuZExlbmd0aCA9IHRpdGxlID8gNiA6IDE2O1xuICAgICAgICBsZXQgc3RyID0gWy4uLkFycmF5KHJhbmRMZW5ndGgpXS5tYXAoKCkgPT4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNilbMl0pLmpvaW4oXCJcIik7XG4gICAgICAgIGlmICh0aXRsZSAmJiB0aXRsZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3RyID0gYCR7dGl0bGUucmVwbGFjZSgvW15hLXowLTldKy9naSwgXCItXCIpLnJlcGxhY2UoL14tfC0kL2csIFwiXCIpfS0ke3N0cn1gO1xuICAgICAgICB9XG4gICAgICAgIHRhZ3MucHVzaChbXCJkXCIsIHN0cl0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zaG91bGRBZGRDbGllbnRUYWcpIHtcbiAgICAgIGNvbnN0IGNsaWVudFRhZyA9IFtcImNsaWVudFwiLCB0aGlzLm5kaz8uY2xpZW50TmFtZSA/PyBcIlwiXTtcbiAgICAgIGlmICh0aGlzLm5kaz8uY2xpZW50TmlwODkpIGNsaWVudFRhZy5wdXNoKHRoaXMubmRrPy5jbGllbnROaXA4OSk7XG4gICAgICB0YWdzLnB1c2goY2xpZW50VGFnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2hvdWxkU3RyaXBDbGllbnRUYWcpIHtcbiAgICAgIHRhZ3MgPSB0YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwiY2xpZW50XCIpO1xuICAgIH1cbiAgICByZXR1cm4geyBjb250ZW50OiBjb250ZW50IHx8IFwiXCIsIHRhZ3MgfTtcbiAgfVxuICBnZXQgc2hvdWxkQWRkQ2xpZW50VGFnKCkge1xuICAgIGlmICghdGhpcy5uZGs/LmNsaWVudE5hbWUgJiYgIXRoaXMubmRrPy5jbGllbnROaXA4OSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChza2lwQ2xpZW50VGFnT25LaW5kcy5oYXModGhpcy5raW5kKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aGlzLmlzRXBoZW1lcmFsKCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy5pc1JlcGxhY2VhYmxlKCkgJiYgIXRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy5pc0R2bSgpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuaGFzVGFnKFwiY2xpZW50XCIpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0IHNob3VsZFN0cmlwQ2xpZW50VGFnKCkge1xuICAgIHJldHVybiBza2lwQ2xpZW50VGFnT25LaW5kcy5oYXModGhpcy5raW5kKTtcbiAgfVxuICBtdXRlZCgpIHtcbiAgICBjb25zdCBhdXRob3JNdXRlZEVudHJ5ID0gdGhpcy5uZGs/Lm11dGVkSWRzLmdldCh0aGlzLnB1YmtleSk7XG4gICAgaWYgKGF1dGhvck11dGVkRW50cnkgJiYgYXV0aG9yTXV0ZWRFbnRyeSA9PT0gXCJwXCIpIHJldHVybiBcImF1dGhvclwiO1xuICAgIGNvbnN0IGV2ZW50VGFnUmVmZXJlbmNlID0gdGhpcy50YWdSZWZlcmVuY2UoKTtcbiAgICBjb25zdCBldmVudE11dGVkRW50cnkgPSB0aGlzLm5kaz8ubXV0ZWRJZHMuZ2V0KGV2ZW50VGFnUmVmZXJlbmNlWzFdKTtcbiAgICBpZiAoZXZlbnRNdXRlZEVudHJ5ICYmIGV2ZW50TXV0ZWRFbnRyeSA9PT0gZXZlbnRUYWdSZWZlcmVuY2VbMF0pIHJldHVybiBcImV2ZW50XCI7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFwiZFwiIHRhZyBvZiBhIHBhcmFtZXRlcml6ZWQgcmVwbGFjZWFibGUgZXZlbnQgb3IgdGhyb3dzIGFuIGVycm9yIGlmIHRoZSBldmVudCBpc24ndFxuICAgKiBhIHBhcmFtZXRlcml6ZWQgcmVwbGFjZWFibGUgZXZlbnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBcImRcIiB0YWcgb2YgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYGRUYWdgIGluc3RlYWQuXG4gICAqL1xuICByZXBsYWNlYWJsZURUYWcoKSB7XG4gICAgaWYgKHRoaXMua2luZCAmJiB0aGlzLmtpbmQgPj0gM2U0ICYmIHRoaXMua2luZCA8PSA0ZTQpIHtcbiAgICAgIGNvbnN0IGRUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImRcIilbMF07XG4gICAgICBjb25zdCBkVGFnSWQgPSBkVGFnID8gZFRhZ1sxXSA6IFwiXCI7XG4gICAgICByZXR1cm4gZFRhZ0lkO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBpcyBub3QgYSBwYXJhbWV0ZXJpemVkIHJlcGxhY2VhYmxlIGV2ZW50XCIpO1xuICB9XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIGRlZHVwbGljYXRpb24ga2V5IGZvciB0aGUgZXZlbnQuXG4gICAqXG4gICAqIEZvciBraW5kcyAwLCAzLCAxMGstMjBrIHRoaXMgd2lsbCBiZSB0aGUgZXZlbnQgPGtpbmQ+OjxwdWJrZXk+XG4gICAqIEZvciBraW5kcyAzMGstNDBrIHRoaXMgd2lsbCBiZSB0aGUgZXZlbnQgPGtpbmQ+OjxwdWJrZXk+OjxkLXRhZz5cbiAgICogRm9yIGFsbCBvdGhlciBraW5kcyB0aGlzIHdpbGwgYmUgdGhlIGV2ZW50IGlkXG4gICAqL1xuICBkZWR1cGxpY2F0aW9uS2V5KCkge1xuICAgIGlmICh0aGlzLmtpbmQgPT09IDAgfHwgdGhpcy5raW5kID09PSAzIHx8IHRoaXMua2luZCAmJiB0aGlzLmtpbmQgPj0gMWU0ICYmIHRoaXMua2luZCA8IDJlNCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMua2luZH06JHt0aGlzLnB1YmtleX1gO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50YWdJZCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpZCBvZiB0aGUgZXZlbnQgb3IsIGlmIGl0J3MgYSBwYXJhbWV0ZXJpemVkIGV2ZW50LCB0aGUgZ2VuZXJhdGVkIGlkIG9mIHRoZSBldmVudCB1c2luZyBcImRcIiB0YWcsIHB1YmtleSwgYW5kIGtpbmQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBpZFxuICAgKi9cbiAgdGFnSWQoKSB7XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRhZ0FkZHJlc3MoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaWQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdGFibGUgcmVmZXJlbmNlIHZhbHVlIGZvciBhIHJlcGxhY2VhYmxlIGV2ZW50LlxuICAgKlxuICAgKiBQYXJhbSByZXBsYWNlYWJsZSBldmVudHMgYXJlIHJldHVybmVkIGluIHRoZSBleHBlY3RlZCBmb3JtYXQgb2YgYDxraW5kPjo8cHVia2V5Pjo8ZC10YWc+YC5cbiAgICogS2luZC1yZXBsYWNlYWJsZSBldmVudHMgYXJlIHJldHVybmVkIGluIHRoZSBmb3JtYXQgb2YgYDxraW5kPjo8cHVia2V5PjpgLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0YWJsZSByZWZlcmVuY2UgdmFsdWUgZm9yIHJlcGxhY2VhYmxlIGV2ZW50c1xuICAgKi9cbiAgdGFnQWRkcmVzcygpIHtcbiAgICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgICAgY29uc3QgZFRhZ0lkID0gdGhpcy5kVGFnID8/IFwiXCI7XG4gICAgICByZXR1cm4gYCR7dGhpcy5raW5kfToke3RoaXMucHVia2V5fToke2RUYWdJZH1gO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1JlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLmtpbmR9OiR7dGhpcy5wdWJrZXl9OmA7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IGlzIG5vdCBhIHJlcGxhY2VhYmxlIGV2ZW50XCIpO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSB0eXBlIG9mIHRhZyB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGlzIGV2ZW50IGZyb20gYW5vdGhlciBldmVudC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHRhZyB0eXBlXG4gICAqIEBleGFtcGxlXG4gICAqIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAzMDAwMCwgcHVia2V5OiAncHVia2V5JywgdGFnczogWyBbXCJkXCIsIFwiZC1jb2RlXCJdIF0gfSk7XG4gICAqIGV2ZW50LnRhZ1R5cGUoKTsgLy8gXCJhXCJcbiAgICovXG4gIHRhZ1R5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkgPyBcImFcIiA6IFwiZVwiO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHRhZyB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGlzIGV2ZW50IGZyb20gYW5vdGhlciBldmVudC5cbiAgICpcbiAgICogQ29uc2lkZXIgdXNpbmcgcmVmZXJlbmNlVGFncygpIGluc3RlYWQgKHVubGVzcyB5b3UgaGF2ZSBhIGdvb2QgcmVhc29uIHRvIHVzZSB0aGlzKVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDMwMDAwLCBwdWJrZXk6ICdwdWJrZXknLCB0YWdzOiBbIFtcImRcIiwgXCJkLWNvZGVcIl0gXSB9KTtcbiAgICogICAgIGV2ZW50LnRhZ1JlZmVyZW5jZSgpOyAvLyBbXCJhXCIsIFwiMzAwMDA6cHVia2V5OmQtY29kZVwiXVxuICAgKlxuICAgKiAgICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDEsIHB1YmtleTogJ3B1YmtleScsIGlkOiBcImV2ZW50aWRcIiB9KTtcbiAgICogICAgIGV2ZW50LnRhZ1JlZmVyZW5jZSgpOyAvLyBbXCJlXCIsIFwiZXZlbnRpZFwiXVxuICAgKiBAcmV0dXJucyB7TkRLVGFnfSBUaGUgTkRLVGFnIG9iamVjdCByZWZlcmVuY2luZyB0aGlzIGV2ZW50XG4gICAqL1xuICB0YWdSZWZlcmVuY2UobWFya2VyKSB7XG4gICAgbGV0IHRhZztcbiAgICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgICAgdGFnID0gW1wiYVwiLCB0aGlzLnRhZ0FkZHJlc3MoKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZyA9IFtcImVcIiwgdGhpcy50YWdJZCgpXTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVsYXkpIHtcbiAgICAgIHRhZy5wdXNoKHRoaXMucmVsYXkudXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFnLnB1c2goXCJcIik7XG4gICAgfVxuICAgIHRhZy5wdXNoKG1hcmtlciA/PyBcIlwiKTtcbiAgICBpZiAoIXRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHRhZy5wdXNoKHRoaXMucHVia2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhZztcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB0YWdzIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVmZXJlbmNlIHRoaXMgZXZlbnQgZnJvbSBhbm90aGVyIGV2ZW50XG4gICAqIEBwYXJhbSBtYXJrZXIgVGhlIG1hcmtlciB0byB1c2UgaW4gdGhlIHRhZ1xuICAgKiBAcGFyYW0gc2tpcEF1dGhvclRhZyBXaGV0aGVyIHRvIGV4cGxpY2l0bHkgc2tpcCBhZGRpbmcgdGhlIGF1dGhvciB0YWcgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBmb3JjZVRhZyBGb3JjZSBhIHNwZWNpZmljIHRhZyB0byBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgXCJlXCIgb3IgXCJhXCIgdGFnXG4gICAqIEBleGFtcGxlXG4gICAqICAgICBldmVudCA9IG5ldyBOREtFdmVudChuZGssIHsga2luZDogMzAwMDAsIHB1YmtleTogJ3B1YmtleScsIHRhZ3M6IFsgW1wiZFwiLCBcImQtY29kZVwiXSBdIH0pO1xuICAgKiAgICAgZXZlbnQucmVmZXJlbmNlVGFncygpOyAvLyBbW1wiYVwiLCBcIjMwMDAwOnB1YmtleTpkLWNvZGVcIl0sIFtcImVcIiwgXCJwYXJlbnQtaWRcIl1dXG4gICAqXG4gICAqICAgICBldmVudCA9IG5ldyBOREtFdmVudChuZGssIHsga2luZDogMSwgcHVia2V5OiAncHVia2V5JywgaWQ6IFwiZXZlbnRpZFwiIH0pO1xuICAgKiAgICAgZXZlbnQucmVmZXJlbmNlVGFncygpOyAvLyBbW1wiZVwiLCBcInBhcmVudC1pZFwiXV1cbiAgICogQHJldHVybnMge05ES1RhZ30gVGhlIE5ES1RhZyBvYmplY3QgcmVmZXJlbmNpbmcgdGhpcyBldmVudFxuICAgKi9cbiAgcmVmZXJlbmNlVGFncyhtYXJrZXIsIHNraXBBdXRob3JUYWcsIGZvcmNlVGFnKSB7XG4gICAgbGV0IHRhZ3MgPSBbXTtcbiAgICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgICAgdGFncyA9IFtcbiAgICAgICAgW2ZvcmNlVGFnID8/IFwiYVwiLCB0aGlzLnRhZ0FkZHJlc3MoKV0sXG4gICAgICAgIFtmb3JjZVRhZyA/PyBcImVcIiwgdGhpcy5pZF1cbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ3MgPSBbW2ZvcmNlVGFnID8/IFwiZVwiLCB0aGlzLmlkXV07XG4gICAgfVxuICAgIHRhZ3MgPSB0YWdzLm1hcCgodGFnKSA9PiB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIiB8fCBtYXJrZXIpIHtcbiAgICAgICAgdGFnLnB1c2godGhpcy5yZWxheT8udXJsID8/IFwiXCIpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnJlbGF5Py51cmwpIHtcbiAgICAgICAgdGFnLnB1c2godGhpcy5yZWxheT8udXJsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWc7XG4gICAgfSk7XG4gICAgdGFncy5mb3JFYWNoKCh0YWcpID0+IHtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwiZVwiKSB7XG4gICAgICAgIHRhZy5wdXNoKG1hcmtlciA/PyBcIlwiKTtcbiAgICAgICAgdGFnLnB1c2godGhpcy5wdWJrZXkpO1xuICAgICAgfSBlbHNlIGlmIChtYXJrZXIpIHtcbiAgICAgICAgdGFnLnB1c2gobWFya2VyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWdzID0gWy4uLnRhZ3MsIC4uLnRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiaFwiKV07XG4gICAgaWYgKCFza2lwQXV0aG9yVGFnKSB0YWdzLnB1c2goLi4udGhpcy5hdXRob3IucmVmZXJlbmNlVGFncygpKTtcbiAgICByZXR1cm4gdGFncztcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgdGhlIGZpbHRlciB0aGF0IHdpbGwgcmV0dXJuIG1hdGNoaW5nIGV2ZW50cyBmb3IgdGhpcyBldmVudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDMwMDAwLCBwdWJrZXk6ICdwdWJrZXknLCB0YWdzOiBbIFtcImRcIiwgXCJkLWNvZGVcIl0gXSB9KTtcbiAgICogICAgZXZlbnQuZmlsdGVyKCk7IC8vIHsgXCIjYVwiOiBbXCIzMDAwMDpwdWJrZXk6ZC1jb2RlXCJdIH1cbiAgICogQGV4YW1wbGVcbiAgICogICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDEsIHB1YmtleTogJ3B1YmtleScsIGlkOiBcImV2ZW50aWRcIiB9KTtcbiAgICogICAgZXZlbnQuZmlsdGVyKCk7IC8vIHsgXCIjZVwiOiBbXCJldmVudGlkXCJdIH1cbiAgICpcbiAgICogQHJldHVybnMgVGhlIGZpbHRlciB0aGF0IHdpbGwgcmV0dXJuIG1hdGNoaW5nIGV2ZW50cyBmb3IgdGhpcyBldmVudFxuICAgKi9cbiAgZmlsdGVyKCkge1xuICAgIGlmICh0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSB7XG4gICAgICByZXR1cm4geyBcIiNhXCI6IFt0aGlzLnRhZ0lkKCldIH07XG4gICAgfVxuICAgIHJldHVybiB7IFwiI2VcIjogW3RoaXMudGFnSWQoKV0gfTtcbiAgfVxuICBuaXAyMkZpbHRlcigpIHtcbiAgICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgICAgcmV0dXJuIHsgXCIjQVwiOiBbdGhpcy50YWdJZCgpXSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBcIiNFXCI6IFt0aGlzLnRhZ0lkKCldIH07XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIGRlbGV0aW9uIGV2ZW50IG9mIHRoZSBjdXJyZW50IGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSByZWFzb24gVGhlIHJlYXNvbiBmb3IgdGhlIGRlbGV0aW9uXG4gICAqIEBwYXJhbSBwdWJsaXNoIFdoZXRoZXIgdG8gcHVibGlzaCB0aGUgZGVsZXRpb24gZXZlbnQgYXV0b21hdGljYWxseVxuICAgKiBAcmV0dXJucyBUaGUgZGVsZXRpb24gZXZlbnRcbiAgICovXG4gIGFzeW5jIGRlbGV0ZShyZWFzb24sIHB1Ymxpc2ggPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGNvbnN0IGUgPSBuZXcgX05ES0V2ZW50KHRoaXMubmRrLCB7XG4gICAgICBraW5kOiA1IC8qIEV2ZW50RGVsZXRpb24gKi8sXG4gICAgICBjb250ZW50OiByZWFzb24gfHwgXCJcIlxuICAgIH0pO1xuICAgIGUudGFnKHRoaXMsIHZvaWQgMCwgdHJ1ZSk7XG4gICAgZS50YWdzLnB1c2goW1wia1wiLCB0aGlzLmtpbmQ/LnRvU3RyaW5nKCldKTtcbiAgICBpZiAocHVibGlzaCkge1xuICAgICAgdGhpcy5lbWl0KFwiZGVsZXRlZFwiKTtcbiAgICAgIGF3YWl0IGUucHVibGlzaCgpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICAvKipcbiAgICogRXN0YWJsaXNoZXMgd2hldGhlciB0aGlzIGlzIGEgTklQLTcwLXByb3RlY3RlZGUgZXZlbnQuXG4gICAqIEBAc2F0aXNmaWVzIE5JUC03MFxuICAgKi9cbiAgc2V0IGlzUHJvdGVjdGVkKHZhbCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiLVwiKTtcbiAgICBpZiAodmFsKSB0aGlzLnRhZ3MucHVzaChbXCItXCJdKTtcbiAgfVxuICAvKipcbiAgICogV2hldGhlciB0aGlzIGlzIGEgTklQLTcwLXByb3RlY3RlZCBldmVudC5cbiAgICogQEBzYXRpc2ZpZXMgTklQLTcwXG4gICAqL1xuICBnZXQgaXNQcm90ZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzVGFnKFwiLVwiKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYW4gZXZlbnQgdGFnZ2VkIHdpdGggdGhlIGdpdmVuIHRhZyBmb2xsb3dpbmcgcmVsYXkgaGludHMgaWYgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSB0YWcgVGhlIHRhZyB0byBzZWFyY2ggZm9yXG4gICAqIEBwYXJhbSBtYXJrZXIgVGhlIG1hcmtlciB0byB1c2UgaW4gdGhlIHRhZyAoZS5nLiBcInJvb3RcIilcbiAgICogQHJldHVybnMgVGhlIGZldGNoZWQgZXZlbnQgb3IgbnVsbCBpZiBubyBldmVudCB3YXMgZm91bmQsIHVuZGVmaW5lZCBpZiBubyBtYXRjaGluZyB0YWcgd2FzIGZvdW5kIGluIHRoZSBldmVudFxuICAgKiAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJlcGx5RXZlbnQgPSBhd2FpdCBuZGsuZmV0Y2hFdmVudChcIm5ldmVudDFxcXM4eDh2bnljeWhhNzNncnYzODBnbXZsdXJ5NHd0bXgwbnI5YTVkczJkbmdxd2d1ODd3bjZncHplbWh4dWU2OXVoaHlldHZ2OXVqdXVyamQ5a2t6bXB3ZGVqaGdxM3FsMnZ5aDQ3bWsycDBxbHNrdTdoZzB2bjI5ZmFlaHk5aHkzNHlnYWNscG42NnVrcXAzYWZxejRjd2pkXCIpXG4gICAqIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSBhd2FpdCByZXBseUV2ZW50LmZldGNoVGFnZ2VkRXZlbnQoXCJlXCIsIFwicmVwbHlcIik7XG4gICAqIGNvbnNvbGUubG9nKHJlcGx5RXZlbnQuZW5jb2RlKCkgKyBcIiBpcyBhIHJlcGx5IHRvIGV2ZW50IFwiICsgb3JpZ2luYWxFdmVudD8uZW5jb2RlKCkpO1xuICAgKi9cbiAgZmV0Y2hUYWdnZWRFdmVudCA9IGZldGNoVGFnZ2VkRXZlbnQuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIEZldGNoIHRoZSByb290IGV2ZW50IG9mIHRoZSBjdXJyZW50IGV2ZW50LlxuICAgKiBAcmV0dXJucyBUaGUgZmV0Y2hlZCByb290IGV2ZW50IG9yIG51bGwgaWYgbm8gZXZlbnQgd2FzIGZvdW5kXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJlcGx5RXZlbnQgPSBhd2FpdCBuZGsuZmV0Y2hFdmVudChcIm5ldmVudDFxcXM4eDh2bnljeWhhNzNncnYzODBnbXZsdXJ5NHd0bXgwbnI5YTVkczJkbmdxd2d1ODd3bjZncHplbWh4dWU2OXVoaHlldHZ2OXVqdXVyamQ5a2t6bXB3ZGVqaGdxM3FsMnZ5aDQ3bWsycDBxbHNrdTdoZzB2bjI5ZmFlaHk5aHkzNHlnYWNscG42NnVrcXAzYWZxejRjd2pkXCIpXG4gICAqIGNvbnN0IHJvb3RFdmVudCA9IGF3YWl0IHJlcGx5RXZlbnQuZmV0Y2hSb290RXZlbnQoKTtcbiAgICogY29uc29sZS5sb2cocmVwbHlFdmVudC5lbmNvZGUoKSArIFwiIGlzIGEgcmVwbHkgaW4gdGhlIHRocmVhZCBcIiArIHJvb3RFdmVudD8uZW5jb2RlKCkpO1xuICAgKi9cbiAgZmV0Y2hSb290RXZlbnQgPSBmZXRjaFJvb3RFdmVudC5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogRmV0Y2ggdGhlIGV2ZW50IHRoZSBjdXJyZW50IGV2ZW50IGlzIHJlcGx5aW5nIHRvLlxuICAgKiBAcmV0dXJucyBUaGUgZmV0Y2hlZCByZXBseSBldmVudCBvciBudWxsIGlmIG5vIGV2ZW50IHdhcyBmb3VuZFxuICAgKi9cbiAgZmV0Y2hSZXBseUV2ZW50ID0gZmV0Y2hSZXBseUV2ZW50LmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBOSVAtMTggcmVwb3N0aW5nIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gcHVibGlzaCBXaGV0aGVyIHRvIHB1Ymxpc2ggdGhlIHJlcG9zdGVkIGV2ZW50IGF1dG9tYXRpY2FsbHkgQGRlZmF1bHQgdHJ1ZVxuICAgKiBAcGFyYW0gc2lnbmVyIFRoZSBzaWduZXIgdG8gdXNlIGZvciBzaWduaW5nIHRoZSByZXBvc3RlZCBldmVudFxuICAgKiBAcmV0dXJucyBUaGUgcmVwb3N0ZWQgZXZlbnRcbiAgICpcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICByZXBvc3QgPSByZXBvc3QuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIFJlYWN0IHRvIGFuIGV4aXN0aW5nIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSBjb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSByZWFjdGlvblxuICAgKi9cbiAgYXN5bmMgcmVhY3QoY29udGVudCwgcHVibGlzaCA9IHRydWUpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCk7XG4gICAgY29uc3QgZSA9IG5ldyBfTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IDcgLyogUmVhY3Rpb24gKi8sXG4gICAgICBjb250ZW50XG4gICAgfSk7XG4gICAgZS50YWcodGhpcyk7XG4gICAgaWYgKHB1Ymxpc2gpIGF3YWl0IGUucHVibGlzaCgpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZXZlbnQgaXMgdmFsaWQgcGVyIHVuZGVybHlpbmcgTklQcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzIHRoYXQgaW1wbGVtZW50IHNwZWNpZmljIE5JUHNcbiAgICogdG8gYWxsb3cgdGhlIGVuZm9yY2VtZW50IG9mIE5JUC1zcGVjaWZpYyB2YWxpZGF0aW9uIHJ1bGVzLlxuICAgKlxuICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgb25seSBjaGVjayBmb3IgYmFzaWMgZXZlbnQgcHJvcGVydGllcy5cbiAgICpcbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKCk7XG4gIH1cbiAgZ2V0IGluc3BlY3QoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMucmF3RXZlbnQoKSwgbnVsbCwgNCk7XG4gIH1cbiAgLyoqXG4gICAqIER1bXAgdGhlIGV2ZW50IHRvIGNvbnNvbGUgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cbiAgICogUHJpbnRzIGEgSlNPTiBzdHJpbmdpZmllZCB2ZXJzaW9uIG9mIHJhd0V2ZW50KCkgd2l0aCBpbmRlbnRhdGlvblxuICAgKiBhbmQgYWxzbyBsaXN0cyBhbGwgcmVsYXkgVVJMcyBmb3Igb25SZWxheXMuXG4gICAqL1xuICBkdW1wKCkge1xuICAgIGNvbnNvbGUuZGVidWcoSlNPTi5zdHJpbmdpZnkodGhpcy5yYXdFdmVudCgpLCBudWxsLCA0KSk7XG4gICAgY29uc29sZS5kZWJ1ZyhcIkV2ZW50IG9uIHJlbGF5czpcIiwgdGhpcy5vblJlbGF5cy5tYXAoKHJlbGF5KSA9PiByZWxheS51cmwpLmpvaW4oXCIsIFwiKSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZXBseSBldmVudCBmb3IgdGhlIGN1cnJlbnQgZXZlbnQuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCB1c2UgTklQLTIyIHdoZW4gYXBwcm9wcmlhdGUgKGkuZS4gcmVwbGllcyB0byBub24ta2luZDoxIGV2ZW50cykuXG4gICAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaGF2ZSBzaWRlLWVmZmVjdHM7IGl0IHdpbGwganVzdCByZXR1cm4gYW4gZXZlbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgdGFnc1xuICAgKiB0byBnZW5lcmF0ZSB0aGUgcmVwbHkgZXZlbnQ7IHRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICAgKi9cbiAgcmVwbHkoKSB7XG4gICAgY29uc3QgcmVwbHkgPSBuZXcgX05ES0V2ZW50KHRoaXMubmRrKTtcbiAgICBpZiAodGhpcy5raW5kID09PSAxKSB7XG4gICAgICByZXBseS5raW5kID0gMTtcbiAgICAgIGNvbnN0IG9wSGFzRVRhZyA9IHRoaXMuaGFzVGFnKFwiZVwiKTtcbiAgICAgIGlmIChvcEhhc0VUYWcpIHtcbiAgICAgICAgcmVwbHkudGFncyA9IFtcbiAgICAgICAgICAuLi5yZXBseS50YWdzLFxuICAgICAgICAgIC4uLnRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKSxcbiAgICAgICAgICAuLi50aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIiksXG4gICAgICAgICAgLi4udGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhXCIpLFxuICAgICAgICAgIC4uLnRoaXMucmVmZXJlbmNlVGFncyhcInJlcGx5XCIpXG4gICAgICAgIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXBseS50YWcodGhpcywgXCJyb290XCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXBseS5raW5kID0gMTExMSAvKiBHZW5lcmljUmVwbHkgKi87XG4gICAgICBjb25zdCBjYXJyeU92ZXJUYWdzID0gW1wiQVwiLCBcIkVcIiwgXCJJXCIsIFwiUFwiXTtcbiAgICAgIGNvbnN0IHJvb3RUYWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiBjYXJyeU92ZXJUYWdzLmluY2x1ZGVzKHRhZ1swXSkpO1xuICAgICAgaWYgKHJvb3RUYWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgcm9vdEtpbmQgPSB0aGlzLnRhZ1ZhbHVlKFwiS1wiKTtcbiAgICAgICAgcmVwbHkudGFncy5wdXNoKC4uLnJvb3RUYWdzKTtcbiAgICAgICAgaWYgKHJvb3RLaW5kKSByZXBseS50YWdzLnB1c2goW1wiS1wiLCByb290S2luZF0pO1xuICAgICAgICBjb25zdCBbdHlwZSwgaWQsIF8sIC4uLmV4dHJhXSA9IHRoaXMudGFnUmVmZXJlbmNlKCk7XG4gICAgICAgIGNvbnN0IHRhZyA9IFt0eXBlLCBpZCwgLi4uZXh0cmFdO1xuICAgICAgICByZXBseS50YWdzLnB1c2godGFnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IFt0eXBlLCBpZCwgXywgcmVsYXlIaW50XSA9IHRoaXMudGFnUmVmZXJlbmNlKCk7XG4gICAgICAgIGNvbnN0IHRhZyA9IFt0eXBlLCBpZCwgcmVsYXlIaW50ID8/IFwiXCJdO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJlXCIpIHRhZy5wdXNoKHRoaXMucHVia2V5KTtcbiAgICAgICAgcmVwbHkudGFncy5wdXNoKHRhZyk7XG4gICAgICAgIGNvbnN0IHVwcGVyY2FzZVRhZyA9IFsuLi50YWddO1xuICAgICAgICB1cHBlcmNhc2VUYWdbMF0gPSB1cHBlcmNhc2VUYWdbMF0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgcmVwbHkudGFncy5wdXNoKHVwcGVyY2FzZVRhZyk7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaChbXCJLXCIsIHRoaXMua2luZD8udG9TdHJpbmcoKV0pO1xuICAgICAgICByZXBseS50YWdzLnB1c2goW1wiUFwiLCB0aGlzLnB1YmtleV0pO1xuICAgICAgfVxuICAgICAgcmVwbHkudGFncy5wdXNoKFtcImtcIiwgdGhpcy5raW5kPy50b1N0cmluZygpXSk7XG4gICAgICByZXBseS50YWdzLnB1c2goLi4udGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpKTtcbiAgICAgIHJlcGx5LnRhZ3MucHVzaChbXCJwXCIsIHRoaXMucHVia2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXBseTtcbiAgfVxufTtcbnZhciB1bnRyYWNrZWRVbnB1Ymxpc2hlZEV2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgMjQxMzMgLyogTm9zdHJDb25uZWN0ICovLFxuICAxMzE5NCAvKiBOb3N0cldhbGV0Q29ubmVjdEluZm8gKi8sXG4gIDIzMTk0IC8qIE5vc3RyV2FsbGV0Q29ubmVjdFJlcSAqLyxcbiAgMjMxOTUgLyogTm9zdHJXYWxsZXRDb25uZWN0UmVzICovXG5dKTtcbmZ1bmN0aW9uIHNob3VsZFRyYWNrVW5wdWJsaXNoZWRFdmVudChldmVudCkge1xuICByZXR1cm4gIXVudHJhY2tlZFVucHVibGlzaGVkRXZlbnRzLmhhcyhldmVudC5raW5kKTtcbn1cblxuLy8gc3JjL3JlbGF5L3Bvb2wvaW5kZXgudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXIzIH0gZnJvbSBcInRzZWVwXCI7XG52YXIgTkRLUG9vbCA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyMyB7XG4gIC8vIFRPRE86IFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIGFuIExSVSBjYWNoZVxuICBfcmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgc3RhdHVzID0gXCJpZGxlXCI7XG4gIGF1dG9Db25uZWN0UmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcG9vbEJsYWNrbGlzdFJlbGF5VXJscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGRlYnVnO1xuICB0ZW1wb3JhcnlSZWxheVRpbWVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZsYXBwaW5nUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgLy8gQSBtYXAgdG8gc3RvcmUgdGltZW91dHMgZm9yIGVhY2ggZmxhcHBpbmcgcmVsYXkuXG4gIGJhY2tvZmZUaW1lcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIG5kaztcbiAgZ2V0IGJsYWNrbGlzdFJlbGF5VXJscygpIHtcbiAgICBjb25zdCB2YWwgPSBuZXcgU2V0KHRoaXMubmRrLmJsYWNrbGlzdFJlbGF5VXJscyk7XG4gICAgdGhpcy5wb29sQmxhY2tsaXN0UmVsYXlVcmxzLmZvckVhY2goKHVybCkgPT4gdmFsLmFkZCh1cmwpKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gcmVsYXlVcmxzIC0gVGhlIFVSTHMgb2YgdGhlIHJlbGF5cyB0byBjb25uZWN0IHRvLlxuICAgKiBAcGFyYW0gYmxhY2tsaXN0ZWRSZWxheVVybHMgLSBVUkxzIHRvIGJsYWNrbGlzdCBmb3IgdGhpcyBwb29sIElOIEFERElUSU9OIHRvIHRob3NlIGJsYWNrbGlzdGVkIGF0IHRoZSBuZGstbGV2ZWxcbiAgICogQHBhcmFtIG5kayAtIFRoZSBOREsgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBmb3IgdGhlIHBvb2wuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZWxheVVybHMsIGJsYWNrbGlzdGVkUmVsYXlVcmxzLCBuZGssIHtcbiAgICBkZWJ1ZzogZGVidWc4LFxuICAgIG5hbWVcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRlYnVnID0gZGVidWc4ID8/IG5kay5kZWJ1Zy5leHRlbmQoXCJwb29sXCIpO1xuICAgIGlmIChuYW1lKSB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLnJlbGF5VXJscyA9IHJlbGF5VXJscztcbiAgICB0aGlzLnBvb2xCbGFja2xpc3RSZWxheVVybHMgPSBuZXcgU2V0KGJsYWNrbGlzdGVkUmVsYXlVcmxzKTtcbiAgICB0aGlzLm5kay5wb29scy5wdXNoKHRoaXMpO1xuICB9XG4gIGdldCByZWxheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbGF5cztcbiAgfVxuICBzZXQgcmVsYXlVcmxzKHVybHMpIHtcbiAgICB0aGlzLl9yZWxheXMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIHVybHMpIHtcbiAgICAgIGNvbnN0IHJlbGF5ID0gbmV3IE5ES1JlbGF5KHJlbGF5VXJsLCB2b2lkIDAsIHRoaXMubmRrKTtcbiAgICAgIHJlbGF5LmNvbm5lY3Rpdml0eS5uZXREZWJ1ZyA9IHRoaXMubmRrLm5ldERlYnVnO1xuICAgICAgdGhpcy5hZGRSZWxheShyZWxheSk7XG4gICAgfVxuICB9XG4gIF9uYW1lID0gXCJ1bm5hbWVkXCI7XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9XG4gIHNldCBuYW1lKG5hbWUpIHtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRlYnVnID0gdGhpcy5kZWJ1Zy5leHRlbmQobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSByZWxheSB0byB0aGUgcG9vbCwgYW5kIHNldHMgYSB0aW1lciB0byByZW1vdmUgaXQgaWYgaXQgaXMgbm90IHVzZWQgd2l0aGluIHRoZSBzcGVjaWZpZWQgdGltZS5cbiAgICogQHBhcmFtIHJlbGF5IC0gVGhlIHJlbGF5IHRvIGFkZCB0byB0aGUgcG9vbC5cbiAgICogQHBhcmFtIHJlbW92ZUlmVW51c2VkQWZ0ZXIgLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgcmVtb3ZpbmcgdGhlIHJlbGF5IGZyb20gdGhlIHBvb2wgYWZ0ZXIgaXQgaXMgbm8gbG9uZ2VyIHVzZWQuXG4gICAqL1xuICB1c2VUZW1wb3JhcnlSZWxheShyZWxheSwgcmVtb3ZlSWZVbnVzZWRBZnRlciA9IDNlNCwgZmlsdGVycykge1xuICAgIGNvbnN0IHJlbGF5QWxyZWFkeUluUG9vbCA9IHRoaXMucmVsYXlzLmhhcyhyZWxheS51cmwpO1xuICAgIGlmICghcmVsYXlBbHJlYWR5SW5Qb29sKSB7XG4gICAgICB0aGlzLmFkZFJlbGF5KHJlbGF5KTtcbiAgICAgIHRoaXMuZGVidWcoXCJBZGRpbmcgdGVtcG9yYXJ5IHJlbGF5ICVzIGZvciBmaWx0ZXJzICVvXCIsIHJlbGF5LnVybCwgZmlsdGVycyk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nVGltZXIgPSB0aGlzLnRlbXBvcmFyeVJlbGF5VGltZXJzLmdldChyZWxheS51cmwpO1xuICAgIGlmIChleGlzdGluZ1RpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZXhpc3RpbmdUaW1lcik7XG4gICAgfVxuICAgIGlmICghcmVsYXlBbHJlYWR5SW5Qb29sIHx8IGV4aXN0aW5nVGltZXIpIHtcbiAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm5kay5leHBsaWNpdFJlbGF5VXJscz8uaW5jbHVkZXMocmVsYXkudXJsKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlbW92ZVJlbGF5KHJlbGF5LnVybCk7XG4gICAgICB9LCByZW1vdmVJZlVudXNlZEFmdGVyKTtcbiAgICAgIHRoaXMudGVtcG9yYXJ5UmVsYXlUaW1lcnMuc2V0KHJlbGF5LnVybCwgdGltZXIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHJlbGF5IHRvIHRoZSBwb29sLlxuICAgKlxuICAgKiBAcGFyYW0gcmVsYXkgLSBUaGUgcmVsYXkgdG8gYWRkIHRvIHRoZSBwb29sLlxuICAgKiBAcGFyYW0gY29ubmVjdCAtIFdoZXRoZXIgb3Igbm90IHRvIGNvbm5lY3QgdG8gdGhlIHJlbGF5LlxuICAgKi9cbiAgYWRkUmVsYXkocmVsYXksIGNvbm5lY3QgPSB0cnVlKSB7XG4gICAgY29uc3QgaXNBbHJlYWR5SW5Qb29sID0gdGhpcy5yZWxheXMuaGFzKHJlbGF5LnVybCk7XG4gICAgY29uc3QgaXNCbGFja2xpc3RlZCA9IHRoaXMuYmxhY2tsaXN0UmVsYXlVcmxzPy5oYXMocmVsYXkudXJsKTtcbiAgICBjb25zdCBpc0N1c3RvbVJlbGF5VXJsID0gcmVsYXkudXJsLmluY2x1ZGVzKFwiL25wdWIxXCIpO1xuICAgIGxldCByZWNvbm5lY3QgPSB0cnVlO1xuICAgIGNvbnN0IHJlbGF5VXJsID0gcmVsYXkudXJsO1xuICAgIGlmIChpc0FscmVhZHlJblBvb2wpIHJldHVybjtcbiAgICBpZiAoaXNCbGFja2xpc3RlZCkge1xuICAgICAgdGhpcy5kZWJ1ZyhgUmVmdXNpbmcgdG8gYWRkIHJlbGF5ICR7cmVsYXlVcmx9OiBibGFja2xpc3RlZGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNDdXN0b21SZWxheVVybCkge1xuICAgICAgdGhpcy5kZWJ1ZyhgUmVmdXNpbmcgdG8gYWRkIHJlbGF5ICR7cmVsYXlVcmx9OiBpcyBhIGZpbHRlciByZWxheWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZGsuY2FjaGVBZGFwdGVyPy5nZXRSZWxheVN0YXR1cykge1xuICAgICAgY29uc3QgaW5mbyA9IHRoaXMubmRrLmNhY2hlQWRhcHRlci5nZXRSZWxheVN0YXR1cyhyZWxheVVybCk7XG4gICAgICBpZiAoaW5mbz8uZG9udENvbm5lY3RCZWZvcmUpIHtcbiAgICAgICAgaWYgKGluZm8uZG9udENvbm5lY3RCZWZvcmUgPiBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgY29uc3QgZGVsYXkgPSBpbmZvLmRvbnRDb25uZWN0QmVmb3JlIC0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB0aGlzLmRlYnVnKGBSZWZ1c2luZyB0byBhZGQgcmVsYXkgJHtyZWxheVVybH06IGRlbGF5ZWQgY29ubmVjdCBmb3IgJHtkZWxheX1tc2ApO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRSZWxheShyZWxheSwgY29ubmVjdCk7XG4gICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm90aWNlSGFuZGxlciA9IChub3RpY2UpID0+IHRoaXMuZW1pdChcIm5vdGljZVwiLCByZWxheSwgbm90aWNlKTtcbiAgICBjb25zdCBjb25uZWN0SGFuZGxlciA9ICgpID0+IHRoaXMuaGFuZGxlUmVsYXlDb25uZWN0KHJlbGF5VXJsKTtcbiAgICBjb25zdCByZWFkeUhhbmRsZXIgPSAoKSA9PiB0aGlzLmhhbmRsZVJlbGF5UmVhZHkocmVsYXkpO1xuICAgIGNvbnN0IGRpc2Nvbm5lY3RIYW5kbGVyID0gKCkgPT4gdGhpcy5lbWl0KFwicmVsYXk6ZGlzY29ubmVjdFwiLCByZWxheSk7XG4gICAgY29uc3QgZmxhcHBpbmdIYW5kbGVyID0gKCkgPT4gdGhpcy5oYW5kbGVGbGFwcGluZyhyZWxheSk7XG4gICAgY29uc3QgYXV0aEhhbmRsZXIgPSAoY2hhbGxlbmdlKSA9PiB0aGlzLmVtaXQoXCJyZWxheTphdXRoXCIsIHJlbGF5LCBjaGFsbGVuZ2UpO1xuICAgIGNvbnN0IGF1dGhlZEhhbmRsZXIgPSAoKSA9PiB0aGlzLmVtaXQoXCJyZWxheTphdXRoZWRcIiwgcmVsYXkpO1xuICAgIHJlbGF5Lm9mZihcIm5vdGljZVwiLCBub3RpY2VIYW5kbGVyKTtcbiAgICByZWxheS5vZmYoXCJjb25uZWN0XCIsIGNvbm5lY3RIYW5kbGVyKTtcbiAgICByZWxheS5vZmYoXCJyZWFkeVwiLCByZWFkeUhhbmRsZXIpO1xuICAgIHJlbGF5Lm9mZihcImRpc2Nvbm5lY3RcIiwgZGlzY29ubmVjdEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9mZihcImZsYXBwaW5nXCIsIGZsYXBwaW5nSGFuZGxlcik7XG4gICAgcmVsYXkub2ZmKFwiYXV0aFwiLCBhdXRoSGFuZGxlcik7XG4gICAgcmVsYXkub2ZmKFwiYXV0aGVkXCIsIGF1dGhlZEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwibm90aWNlXCIsIG5vdGljZUhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwiY29ubmVjdFwiLCBjb25uZWN0SGFuZGxlcik7XG4gICAgcmVsYXkub24oXCJyZWFkeVwiLCByZWFkeUhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwiZGlzY29ubmVjdFwiLCBkaXNjb25uZWN0SGFuZGxlcik7XG4gICAgcmVsYXkub24oXCJmbGFwcGluZ1wiLCBmbGFwcGluZ0hhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwiYXV0aFwiLCBhdXRoSGFuZGxlcik7XG4gICAgcmVsYXkub24oXCJhdXRoZWRcIiwgYXV0aGVkSGFuZGxlcik7XG4gICAgcmVsYXkub24oXCJkZWxheWVkLWNvbm5lY3RcIiwgKGRlbGF5KSA9PiB7XG4gICAgICBpZiAodGhpcy5uZGsuY2FjaGVBZGFwdGVyPy51cGRhdGVSZWxheVN0YXR1cykge1xuICAgICAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIudXBkYXRlUmVsYXlTdGF0dXMocmVsYXkudXJsLCB7XG4gICAgICAgICAgZG9udENvbm5lY3RCZWZvcmU6IERhdGUubm93KCkgKyBkZWxheVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9yZWxheXMuc2V0KHJlbGF5VXJsLCByZWxheSk7XG4gICAgaWYgKGNvbm5lY3QpIHRoaXMuYXV0b0Nvbm5lY3RSZWxheXMuYWRkKHJlbGF5VXJsKTtcbiAgICBpZiAoY29ubmVjdCAmJiB0aGlzLnN0YXR1cyA9PT0gXCJhY3RpdmVcIikge1xuICAgICAgdGhpcy5lbWl0KFwicmVsYXk6Y29ubmVjdGluZ1wiLCByZWxheSk7XG4gICAgICByZWxheS5jb25uZWN0KHZvaWQgMCwgcmVjb25uZWN0KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICB0aGlzLmRlYnVnKGBGYWlsZWQgdG8gY29ubmVjdCB0byByZWxheSAke3JlbGF5VXJsfWAsIGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgcmVsYXkgZnJvbSB0aGUgcG9vbC5cbiAgICogQHBhcmFtIHJlbGF5VXJsIC0gVGhlIFVSTCBvZiB0aGUgcmVsYXkgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcmVsYXkgd2FzIHJlbW92ZWQsIGZhbHNlIGlmIGl0IHdhcyBub3QgZm91bmQuXG4gICAqL1xuICByZW1vdmVSZWxheShyZWxheVVybCkge1xuICAgIGNvbnN0IHJlbGF5ID0gdGhpcy5yZWxheXMuZ2V0KHJlbGF5VXJsKTtcbiAgICBpZiAocmVsYXkpIHtcbiAgICAgIHJlbGF5LmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMucmVsYXlzLmRlbGV0ZShyZWxheVVybCk7XG4gICAgICB0aGlzLmF1dG9Db25uZWN0UmVsYXlzLmRlbGV0ZShyZWxheVVybCk7XG4gICAgICB0aGlzLmVtaXQoXCJyZWxheTpkaXNjb25uZWN0XCIsIHJlbGF5KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ1RpbWVyID0gdGhpcy50ZW1wb3JhcnlSZWxheVRpbWVycy5nZXQocmVsYXlVcmwpO1xuICAgIGlmIChleGlzdGluZ1RpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZXhpc3RpbmdUaW1lcik7XG4gICAgICB0aGlzLnRlbXBvcmFyeVJlbGF5VGltZXJzLmRlbGV0ZShyZWxheVVybCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSByZWxheSBpcyBhbHJlYWR5IGNvbm5lY3RlZCBpbiB0aGUgcG9vbC5cbiAgICovXG4gIGlzUmVsYXlDb25uZWN0ZWQodXJsKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFVybCA9IG5vcm1hbGl6ZVJlbGF5VXJsKHVybCk7XG4gICAgY29uc3QgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQobm9ybWFsaXplZFVybCk7XG4gICAgaWYgKCFyZWxheSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiByZWxheS5zdGF0dXMgPT09IDUgLyogQ09OTkVDVEVEICovO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaGVzIGEgcmVsYXkgZnJvbSB0aGUgcG9vbCwgb3IgY3JlYXRlcyBhIG5ldyBvbmUgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gICAqXG4gICAqIE5ldyByZWxheXMgd2lsbCBiZSBhdHRlbXB0ZWQgdG8gYmUgY29ubmVjdGVkLlxuICAgKi9cbiAgZ2V0UmVsYXkodXJsLCBjb25uZWN0ID0gdHJ1ZSwgdGVtcG9yYXJ5ID0gZmFsc2UsIGZpbHRlcnMpIHtcbiAgICBsZXQgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQobm9ybWFsaXplUmVsYXlVcmwodXJsKSk7XG4gICAgaWYgKCFyZWxheSkge1xuICAgICAgcmVsYXkgPSBuZXcgTkRLUmVsYXkodXJsLCB2b2lkIDAsIHRoaXMubmRrKTtcbiAgICAgIHJlbGF5LmNvbm5lY3Rpdml0eS5uZXREZWJ1ZyA9IHRoaXMubmRrLm5ldERlYnVnO1xuICAgICAgaWYgKHRlbXBvcmFyeSkge1xuICAgICAgICB0aGlzLnVzZVRlbXBvcmFyeVJlbGF5KHJlbGF5LCAzZTQsIGZpbHRlcnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRSZWxheShyZWxheSwgY29ubmVjdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWxheTtcbiAgfVxuICBoYW5kbGVSZWxheUNvbm5lY3QocmVsYXlVcmwpIHtcbiAgICBjb25zdCByZWxheSA9IHRoaXMucmVsYXlzLmdldChyZWxheVVybCk7XG4gICAgaWYgKCFyZWxheSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIk5ESyBCVUc6IHJlbGF5IG5vdCBmb3VuZCBpbiBwb29sXCIsIHsgcmVsYXlVcmwgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW1pdChcInJlbGF5OmNvbm5lY3RcIiwgcmVsYXkpO1xuICAgIGlmICh0aGlzLnN0YXRzKCkuY29ubmVjdGVkID09PSB0aGlzLnJlbGF5cy5zaXplKSB7XG4gICAgICB0aGlzLmVtaXQoXCJjb25uZWN0XCIpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVSZWxheVJlYWR5KHJlbGF5KSB7XG4gICAgdGhpcy5lbWl0KFwicmVsYXk6cmVhZHlcIiwgcmVsYXkpO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHRvIGVhY2ggcmVsYXkgaW4gdGhlIHBvb2wuXG4gICAqXG4gICAqIEBhc3luY1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVvdXRNc10gLSBPcHRpb25hbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgZWFjaCBjb25uZWN0aW9uIGF0dGVtcHQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCBjb25uZWN0aW9uIGF0dGVtcHRzIGhhdmUgY29tcGxldGVkLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYW55IG9mIHRoZSBjb25uZWN0aW9uIGF0dGVtcHRzIHJlc3VsdCBpbiBhbiBlcnJvciBvciB0aW1lb3V0LlxuICAgKi9cbiAgYXN5bmMgY29ubmVjdCh0aW1lb3V0TXMpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIHRoaXMuc3RhdHVzID0gXCJhY3RpdmVcIjtcbiAgICB0aGlzLmRlYnVnKGBDb25uZWN0aW5nIHRvICR7dGhpcy5yZWxheXMuc2l6ZX0gcmVsYXlzJHt0aW1lb3V0TXMgPyBgLCB0aW1lb3V0ICR7dGltZW91dE1zfS4uLmAgOiBcIlwifWApO1xuICAgIGNvbnN0IHJlbGF5c1RvQ29ubmVjdCA9IG5ldyBTZXQodGhpcy5hdXRvQ29ubmVjdFJlbGF5cy5rZXlzKCkpO1xuICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2YgcmVsYXlzVG9Db25uZWN0KSB7XG4gICAgICBjb25zdCByZWxheSA9IHRoaXMucmVsYXlzLmdldChyZWxheVVybCk7XG4gICAgICBpZiAoIXJlbGF5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY29ubmVjdFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChcInJlbGF5OmNvbm5lY3RpbmdcIiwgcmVsYXkpO1xuICAgICAgICByZXR1cm4gcmVsYXkuY29ubmVjdCh0aW1lb3V0TXMpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRpbWVvdXRNcykge1xuICAgICAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChgVGltZWQgb3V0IGFmdGVyICR7dGltZW91dE1zfW1zYCksIHRpbWVvdXRNcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgIFByb21pc2UucmFjZShbY29ubmVjdFByb21pc2UsIHRpbWVvdXRQcm9taXNlXSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoYEZhaWxlZCB0byBjb25uZWN0IHRvIHJlbGF5ICR7cmVsYXkudXJsfTogJHtlID8/IFwiTm8gcmVhc29uIHNwZWNpZmllZFwifWApO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlcy5wdXNoKGNvbm5lY3RQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWF5YmVFbWl0Q29ubmVjdCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGFsbENvbm5lY3RlZCA9IHRoaXMuc3RhdHMoKS5jb25uZWN0ZWQgPT09IHRoaXMucmVsYXlzLnNpemU7XG4gICAgICBjb25zdCBzb21lQ29ubmVjdGVkID0gdGhpcy5zdGF0cygpLmNvbm5lY3RlZCA+IDA7XG4gICAgICBpZiAoIWFsbENvbm5lY3RlZCAmJiBzb21lQ29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodGltZW91dE1zKSBzZXRUaW1lb3V0KG1heWJlRW1pdENvbm5lY3QsIHRpbWVvdXRNcyk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIG1heWJlRW1pdENvbm5lY3QoKTtcbiAgfVxuICBjaGVja09uRmxhcHBpbmdSZWxheXMoKSB7XG4gICAgY29uc3QgZmxhcHBpbmdSZWxheXNDb3VudCA9IHRoaXMuZmxhcHBpbmdSZWxheXMuc2l6ZTtcbiAgICBjb25zdCB0b3RhbFJlbGF5cyA9IHRoaXMucmVsYXlzLnNpemU7XG4gICAgaWYgKGZsYXBwaW5nUmVsYXlzQ291bnQgLyB0b3RhbFJlbGF5cyA+PSAwLjgpIHtcbiAgICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2YgdGhpcy5mbGFwcGluZ1JlbGF5cykge1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lcy5zZXQocmVsYXlVcmwsIDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYW5kbGVGbGFwcGluZyhyZWxheSkge1xuICAgIHRoaXMuZGVidWcoYFJlbGF5ICR7cmVsYXkudXJsfSBpcyBmbGFwcGluZ2ApO1xuICAgIGxldCBjdXJyZW50QmFja29mZiA9IHRoaXMuYmFja29mZlRpbWVzLmdldChyZWxheS51cmwpIHx8IDVlMztcbiAgICBjdXJyZW50QmFja29mZiA9IGN1cnJlbnRCYWNrb2ZmICogMjtcbiAgICB0aGlzLmJhY2tvZmZUaW1lcy5zZXQocmVsYXkudXJsLCBjdXJyZW50QmFja29mZik7XG4gICAgdGhpcy5kZWJ1ZyhgQmFja29mZiB0aW1lIGZvciAke3JlbGF5LnVybH0gaXMgJHtjdXJyZW50QmFja29mZn1tc2ApO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5kZWJ1ZyhgQXR0ZW1wdGluZyB0byByZWNvbm5lY3QgdG8gJHtyZWxheS51cmx9YCk7XG4gICAgICB0aGlzLmVtaXQoXCJyZWxheTpjb25uZWN0aW5nXCIsIHJlbGF5KTtcbiAgICAgIHJlbGF5LmNvbm5lY3QoKTtcbiAgICAgIHRoaXMuY2hlY2tPbkZsYXBwaW5nUmVsYXlzKCk7XG4gICAgfSwgY3VycmVudEJhY2tvZmYpO1xuICAgIHJlbGF5LmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLmVtaXQoXCJmbGFwcGluZ1wiLCByZWxheSk7XG4gIH1cbiAgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWxheXMuc2l6ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhdHVzIG9mIGVhY2ggcmVsYXkgaW4gdGhlIHBvb2wuXG4gICAqIEByZXR1cm5zIHtOREtQb29sU3RhdHN9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBudW1iZXIgb2YgcmVsYXlzIGluIGVhY2ggc3RhdHVzLlxuICAgKi9cbiAgc3RhdHMoKSB7XG4gICAgY29uc3Qgc3RhdHMgPSB7XG4gICAgICB0b3RhbDogMCxcbiAgICAgIGNvbm5lY3RlZDogMCxcbiAgICAgIGRpc2Nvbm5lY3RlZDogMCxcbiAgICAgIGNvbm5lY3Rpbmc6IDBcbiAgICB9O1xuICAgIGZvciAoY29uc3QgcmVsYXkgb2YgdGhpcy5yZWxheXMudmFsdWVzKCkpIHtcbiAgICAgIHN0YXRzLnRvdGFsKys7XG4gICAgICBpZiAocmVsYXkuc3RhdHVzID09PSA1IC8qIENPTk5FQ1RFRCAqLykge1xuICAgICAgICBzdGF0cy5jb25uZWN0ZWQrKztcbiAgICAgIH0gZWxzZSBpZiAocmVsYXkuc3RhdHVzID09PSAxIC8qIERJU0NPTk5FQ1RFRCAqLykge1xuICAgICAgICBzdGF0cy5kaXNjb25uZWN0ZWQrKztcbiAgICAgIH0gZWxzZSBpZiAocmVsYXkuc3RhdHVzID09PSA0IC8qIENPTk5FQ1RJTkcgKi8pIHtcbiAgICAgICAgc3RhdHMuY29ubmVjdGluZysrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdHM7XG4gIH1cbiAgY29ubmVjdGVkUmVsYXlzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucmVsYXlzLnZhbHVlcygpKS5maWx0ZXIoKHJlbGF5KSA9PiByZWxheS5zdGF0dXMgPj0gNSAvKiBDT05ORUNURUQgKi8pO1xuICB9XG4gIHBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlbGF5cy52YWx1ZXMoKSkuZmlsdGVyKFxuICAgICAgKHJlbGF5KSA9PiByZWxheS5zdGF0dXMgPj0gNSAvKiBDT05ORUNURUQgKi8gJiYgIXRoaXMudGVtcG9yYXJ5UmVsYXlUaW1lcnMuaGFzKHJlbGF5LnVybClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGFsbCByZWxheSB1cmxzIGluIHRoZSBwb29sLlxuICAgKi9cbiAgdXJscygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlbGF5cy5rZXlzKCkpO1xuICB9XG59O1xuXG4vLyBzcmMvdXNlci9pbmRleC50c1xuaW1wb3J0IHsgbmlwMTkgYXMgbmlwMTk1IH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG5cbi8vIHNyYy9ldmVudHMva2luZHMvbnV0emFwL21pbnQtbGlzdC50c1xudmFyIE5ES0Nhc2h1TWludExpc3QgPSBjbGFzcyBfTkRLQ2FzaHVNaW50TGlzdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGtpbmQgPSAxMDAxOSAvKiBDYXNodU1pbnRMaXN0ICovO1xuICBzdGF0aWMga2luZHMgPSBbMTAwMTkgLyogQ2FzaHVNaW50TGlzdCAqL107XG4gIF9wMnBrO1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIobmRrLCBldmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAxMDAxOSAvKiBDYXNodU1pbnRMaXN0ICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLQ2FzaHVNaW50TGlzdChldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICBzZXQgcmVsYXlzKHVybHMpIHtcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0KSA9PiB0WzBdICE9PSBcInJlbGF5XCIpO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIHVybHMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInJlbGF5XCIsIHVybF0pO1xuICAgIH1cbiAgfVxuICBnZXQgcmVsYXlzKCkge1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLnRhZ3MpIHtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwicmVsYXlcIikge1xuICAgICAgICByLnB1c2godGFnWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgc2V0IG1pbnRzKHVybHMpIHtcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0KSA9PiB0WzBdICE9PSBcIm1pbnRcIik7XG4gICAgZm9yIChjb25zdCB1cmwgb2YgdXJscykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wibWludFwiLCB1cmxdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG1pbnRzKCkge1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLnRhZ3MpIHtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwibWludFwiKSB7XG4gICAgICAgIHIucHVzaCh0YWdbMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KHIpKTtcbiAgfVxuICBnZXQgcDJwaygpIHtcbiAgICBpZiAodGhpcy5fcDJwaykge1xuICAgICAgcmV0dXJuIHRoaXMuX3AycGs7XG4gICAgfVxuICAgIHRoaXMuX3AycGsgPSB0aGlzLnRhZ1ZhbHVlKFwicHVia2V5XCIpID8/IHRoaXMucHVia2V5O1xuICAgIHJldHVybiB0aGlzLl9wMnBrO1xuICB9XG4gIHNldCBwMnBrKHB1YmtleSkge1xuICAgIHRoaXMuX3AycGsgPSBwdWJrZXk7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwdWJrZXlcIik7XG4gICAgaWYgKHB1YmtleSkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicHVia2V5XCIsIHB1YmtleV0pO1xuICAgIH1cbiAgfVxuICBnZXQgcmVsYXlTZXQoKSB7XG4gICAgcmV0dXJuIE5ES1JlbGF5U2V0LmZyb21SZWxheVVybHModGhpcy5yZWxheXMsIHRoaXMubmRrKTtcbiAgfVxufTtcblxuLy8gc3JjL3N1YnNjcmlwdGlvbi9pbmRleC50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjQgfSBmcm9tIFwidHNlZXBcIjtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9hcnRpY2xlLnRzXG52YXIgTkRLQXJ0aWNsZSA9IGNsYXNzIF9OREtBcnRpY2xlIGV4dGVuZHMgTkRLRXZlbnQge1xuICBzdGF0aWMga2luZCA9IDMwMDIzIC8qIEFydGljbGUgKi87XG4gIHN0YXRpYyBraW5kcyA9IFszMDAyMyAvKiBBcnRpY2xlICovXTtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzAwMjMgLyogQXJ0aWNsZSAqLztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIE5ES0FydGljbGUgZnJvbSBhbiBleGlzdGluZyBOREtFdmVudC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IE5ES0V2ZW50IHRvIGNyZWF0ZSB0aGUgTkRLQXJ0aWNsZSBmcm9tLlxuICAgKiBAcmV0dXJucyBOREtBcnRpY2xlXG4gICAqL1xuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0FydGljbGUoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGFydGljbGUgdGl0bGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGFydGljbGUgdGl0bGUgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwidGl0bGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGFydGljbGUgdGl0bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSB0aXRsZSAtIFRoZSB0aXRsZSB0byBzZXQgZm9yIHRoZSBhcnRpY2xlLlxuICAgKi9cbiAgc2V0IHRpdGxlKHRpdGxlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJ0aXRsZVwiKTtcbiAgICBpZiAodGl0bGUpIHRoaXMudGFncy5wdXNoKFtcInRpdGxlXCIsIHRpdGxlXSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGFydGljbGUgaW1hZ2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGFydGljbGUgaW1hZ2UgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IGltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiaW1hZ2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGFydGljbGUgaW1hZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBpbWFnZSAtIFRoZSBpbWFnZSB0byBzZXQgZm9yIHRoZSBhcnRpY2xlLlxuICAgKi9cbiAgc2V0IGltYWdlKGltYWdlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJpbWFnZVwiKTtcbiAgICBpZiAoaW1hZ2UpIHRoaXMudGFncy5wdXNoKFtcImltYWdlXCIsIGltYWdlXSk7XG4gIH1cbiAgZ2V0IHN1bW1hcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJzdW1tYXJ5XCIpO1xuICB9XG4gIHNldCBzdW1tYXJ5KHN1bW1hcnkpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInN1bW1hcnlcIik7XG4gICAgaWYgKHN1bW1hcnkpIHRoaXMudGFncy5wdXNoKFtcInN1bW1hcnlcIiwgc3VtbWFyeV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlJ3MgcHVibGljYXRpb24gdGltZXN0YW1wLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfSAtIFRoZSBVbml4IHRpbWVzdGFtcCBvZiB3aGVuIHRoZSBhcnRpY2xlIHdhcyBwdWJsaXNoZWQgb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHB1Ymxpc2hlZF9hdCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwicHVibGlzaGVkX2F0XCIpO1xuICAgIGlmICh0YWcpIHtcbiAgICAgIGxldCB2YWwgPSBOdW1iZXIucGFyc2VJbnQodGFnKTtcbiAgICAgIGlmICh2YWwgPiAxZTEyKSB7XG4gICAgICAgIHZhbCA9IE1hdGguZmxvb3IodmFsIC8gMWUzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGFydGljbGUncyBwdWJsaWNhdGlvbiB0aW1lc3RhbXAuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSB0aW1lc3RhbXAgLSBUaGUgVW5peCB0aW1lc3RhbXAgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZSdzIHB1YmxpY2F0aW9uIGRhdGUuXG4gICAqL1xuICBzZXQgcHVibGlzaGVkX2F0KHRpbWVzdGFtcCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicHVibGlzaGVkX2F0XCIpO1xuICAgIGlmICh0aW1lc3RhbXAgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicHVibGlzaGVkX2F0XCIsIHRpbWVzdGFtcC50b1N0cmluZygpXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgY29udGVudCB0YWdzIGZvciB0aGUgYXJ0aWNsZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZmlyc3QgY2hlY2tzIGFuZCBzZXRzIHRoZSBwdWJsaWNhdGlvbiBkYXRlIGlmIG5vdCBhdmFpbGFibGUsXG4gICAqIGFuZCB0aGVuIGdlbmVyYXRlcyBjb250ZW50IHRhZ3MgYmFzZWQgb24gdGhlIGJhc2UgTkRLRXZlbnQgY2xhc3MuXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb250ZW50VGFnfSAtIFRoZSBnZW5lcmF0ZWQgY29udGVudCB0YWdzLlxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVUYWdzKCkge1xuICAgIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICAgIGlmICghdGhpcy5wdWJsaXNoZWRfYXQpIHtcbiAgICAgIHRoaXMucHVibGlzaGVkX2F0ID0gdGhpcy5jcmVhdGVkX2F0O1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZ2VuZXJhdGVUYWdzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGFydGljbGUncyBVUkwuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGFydGljbGUncyBVUkwgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInVybFwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYXJ0aWNsZSdzIFVSTC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHVybCAtIFRoZSBVUkwgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZS5cbiAgICovXG4gIHNldCB1cmwodXJsKSB7XG4gICAgaWYgKHVybCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1widXJsXCIsIHVybF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZVRhZyhcInVybFwiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvY2FzaHUvdG9rZW4udHNcbmZ1bmN0aW9uIHByb29mc1RvdGFsQmFsYW5jZShwcm9vZnMpIHtcbiAgcmV0dXJuIHByb29mcy5yZWR1Y2UoKGFjYywgcHJvb2YpID0+IHtcbiAgICBpZiAocHJvb2YuYW1vdW50IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvb2YgYW1vdW50IGlzIG5lZ2F0aXZlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjICsgcHJvb2YuYW1vdW50O1xuICB9LCAwKTtcbn1cbnZhciBOREtDYXNodVRva2VuID0gY2xhc3MgX05ES0Nhc2h1VG9rZW4gZXh0ZW5kcyBOREtFdmVudCB7XG4gIF9wcm9vZnMgPSBbXTtcbiAgX21pbnQ7XG4gIHN0YXRpYyBraW5kID0gNzM3NSAvKiBDYXNodVRva2VuICovO1xuICBzdGF0aWMga2luZHMgPSBbNzM3NSAvKiBDYXNodVRva2VuICovXTtcbiAgLyoqXG4gICAqIFRva2VucyB0aGF0IHRoaXMgdG9rZW4gc3VwZXJzZWVkc1xuICAgKi9cbiAgX2RlbGV0ZXMgPSBbXTtcbiAgb3JpZ2luYWw7XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcihuZGssIGV2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDczNzUgLyogQ2FzaHVUb2tlbiAqLztcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbShldmVudCkge1xuICAgIGNvbnN0IHRva2VuID0gbmV3IF9OREtDYXNodVRva2VuKGV2ZW50Lm5kaywgZXZlbnQpO1xuICAgIHRva2VuLm9yaWdpbmFsID0gZXZlbnQ7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRva2VuLmRlY3J5cHQoKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRva2VuLmNvbnRlbnQgPSB0b2tlbi5vcmlnaW5hbC5jb250ZW50O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgY29udGVudCA9IEpTT04ucGFyc2UodG9rZW4uY29udGVudCk7XG4gICAgICB0b2tlbi5wcm9vZnMgPSBjb250ZW50LnByb29mcztcbiAgICAgIHRva2VuLm1pbnQgPSBjb250ZW50Lm1pbnQgPz8gdG9rZW4udGFnVmFsdWUoXCJtaW50XCIpO1xuICAgICAgdG9rZW4uZGVsZXRlZFRva2VucyA9IGNvbnRlbnQuZGVsID8/IFtdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRva2VuLnByb29mcykpIHJldHVybjtcbiAgICB9IGNhdGNoIChfZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW47XG4gIH1cbiAgZ2V0IHByb29mcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvb2ZzO1xuICB9XG4gIHNldCBwcm9vZnMocHJvb2ZzKSB7XG4gICAgY29uc3QgY3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuX3Byb29mcyA9IHByb29mcy5maWx0ZXIoKHByb29mKSA9PiB7XG4gICAgICBpZiAoY3MuaGFzKHByb29mLkMpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlBhc3NlZCBpbiBwcm9vZnMgaGFkIGR1cGxpY2F0ZXMsIGlnbm9yaW5nXCIsIHByb29mLkMpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAocHJvb2YuYW1vdW50IDwgMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHByb29mIHdpdGggbmVnYXRpdmUgYW1vdW50XCIsIHByb29mKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY3MuYWRkKHByb29mLkMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkubWFwKHRoaXMuY2xlYW5Qcm9vZik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBtaW5pbWFsIHByb29mIG9iamVjdCB3aXRoIG9ubHkgZXNzZW50aWFsIHByb3BlcnRpZXNcbiAgICovXG4gIGNsZWFuUHJvb2YocHJvb2YpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHByb29mLmlkLFxuICAgICAgYW1vdW50OiBwcm9vZi5hbW91bnQsXG4gICAgICBDOiBwcm9vZi5DLFxuICAgICAgc2VjcmV0OiBwcm9vZi5zZWNyZXRcbiAgICB9O1xuICB9XG4gIGFzeW5jIHRvTm9zdHJFdmVudChwdWJrZXkpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBuZGtcIik7XG4gICAgaWYgKCF0aGlzLm5kay5zaWduZXIpIHRocm93IG5ldyBFcnJvcihcIm5vIHNpZ25lclwiKTtcbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgcHJvb2ZzOiB0aGlzLnByb29mcy5tYXAodGhpcy5jbGVhblByb29mKSxcbiAgICAgIG1pbnQ6IHRoaXMubWludCxcbiAgICAgIGRlbDogdGhpcy5kZWxldGVkVG9rZW5zID8/IFtdXG4gICAgfTtcbiAgICB0aGlzLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLnVzZXIoKTtcbiAgICBhd2FpdCB0aGlzLmVuY3J5cHQodXNlciwgdm9pZCAwLCBcIm5pcDQ0XCIpO1xuICAgIHJldHVybiBzdXBlci50b05vc3RyRXZlbnQocHVia2V5KTtcbiAgfVxuICBzZXQgbWludChtaW50KSB7XG4gICAgdGhpcy5fbWludCA9IG1pbnQ7XG4gIH1cbiAgZ2V0IG1pbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFRva2VucyB0aGF0IHdlcmUgZGVsZXRlZCBieSB0aGUgY3JlYXRpb24gb2YgdGhpcyB0b2tlbi5cbiAgICovXG4gIGdldCBkZWxldGVkVG9rZW5zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWxldGVzO1xuICB9XG4gIC8qKlxuICAgKiBNYXJrcyB0b2tlbnMgdGhhdCB3ZXJlIGRlbGV0ZWQgYnkgdGhlIGNyZWF0aW9uIG9mIHRoaXMgdG9rZW4uXG4gICAqL1xuICBzZXQgZGVsZXRlZFRva2Vucyh0b2tlbklkcykge1xuICAgIHRoaXMuX2RlbGV0ZXMgPSB0b2tlbklkcztcbiAgfVxuICBnZXQgYW1vdW50KCkge1xuICAgIHJldHVybiBwcm9vZnNUb3RhbEJhbGFuY2UodGhpcy5wcm9vZnMpO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2gocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWwpIHtcbiAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsLnB1Ymxpc2gocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnB1Ymxpc2gocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9oaWdobGlnaHQudHNcbmltcG9ydCB7IG5pcDE5IGFzIG5pcDE5MyB9IGZyb20gXCJub3N0ci10b29sc1wiO1xudmFyIE5ES0hpZ2hsaWdodCA9IGNsYXNzIF9OREtIaWdobGlnaHQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIF9hcnRpY2xlO1xuICBzdGF0aWMga2luZCA9IDk4MDIgLyogSGlnaGxpZ2h0ICovO1xuICBzdGF0aWMga2luZHMgPSBbOTgwMiAvKiBIaWdobGlnaHQgKi9dO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSA5ODAyIC8qIEhpZ2hsaWdodCAqLztcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0hpZ2hsaWdodChldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiclwiKTtcbiAgfVxuICAvKipcbiAgICogQ29udGV4dCB0YWcuXG4gICAqL1xuICBzZXQgY29udGV4dChjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigoW3RhZywgX3ZhbHVlXSkgPT4gdGFnICE9PSBcImNvbnRleHRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKFt0YWcsIF92YWx1ZV0pID0+IHRhZyAhPT0gXCJjb250ZXh0XCIpO1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiY29udGV4dFwiLCBjb250ZXh0XSk7XG4gICAgfVxuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmluZCgoW3RhZywgX3ZhbHVlXSkgPT4gdGFnID09PSBcImNvbnRleHRcIik/LlsxXSA/PyB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIFdpbGwgcmV0dXJuIHRoZSBhcnRpY2xlIFVSTCBvciBOREtFdmVudCBpZiB0aGV5IGhhdmUgYWxyZWFkeSBiZWVuXG4gICAqIHNldCAoaXQgd29uJ3QgYXR0ZW1wdCB0byBsb2FkIHJlbW90ZSBldmVudHMpXG4gICAqL1xuICBnZXQgYXJ0aWNsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJ0aWNsZTtcbiAgfVxuICAvKipcbiAgICogQXJ0aWNsZSB0aGUgaGlnaGxpZ2h0IGlzIGNvbWluZyBmcm9tLlxuICAgKlxuICAgKiBAcGFyYW0gYXJ0aWNsZSBBcnRpY2xlIFVSTCBvciBOREtFdmVudC5cbiAgICovXG4gIHNldCBhcnRpY2xlKGFydGljbGUpIHtcbiAgICB0aGlzLl9hcnRpY2xlID0gYXJ0aWNsZTtcbiAgICBpZiAodHlwZW9mIGFydGljbGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInJcIiwgYXJ0aWNsZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhZyhhcnRpY2xlKTtcbiAgICB9XG4gIH1cbiAgZ2V0QXJ0aWNsZVRhZygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhXCIpWzBdIHx8IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKVswXSB8fCB0aGlzLmdldE1hdGNoaW5nVGFncyhcInJcIilbMF07XG4gIH1cbiAgYXN5bmMgZ2V0QXJ0aWNsZSgpIHtcbiAgICBpZiAodGhpcy5fYXJ0aWNsZSAhPT0gdm9pZCAwKSByZXR1cm4gdGhpcy5fYXJ0aWNsZTtcbiAgICBsZXQgdGFnZ2VkQmVjaDMyO1xuICAgIGNvbnN0IGFydGljbGVUYWcgPSB0aGlzLmdldEFydGljbGVUYWcoKTtcbiAgICBpZiAoIWFydGljbGVUYWcpIHJldHVybiB2b2lkIDA7XG4gICAgc3dpdGNoIChhcnRpY2xlVGFnWzBdKSB7XG4gICAgICBjYXNlIFwiYVwiOiB7XG4gICAgICAgIGNvbnN0IFtraW5kLCBwdWJrZXksIGlkZW50aWZpZXJdID0gYXJ0aWNsZVRhZ1sxXS5zcGxpdChcIjpcIik7XG4gICAgICAgIHRhZ2dlZEJlY2gzMiA9IG5pcDE5My5uYWRkckVuY29kZSh7XG4gICAgICAgICAga2luZDogTnVtYmVyLnBhcnNlSW50KGtpbmQpLFxuICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICBpZGVudGlmaWVyXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJlXCI6XG4gICAgICAgIHRhZ2dlZEJlY2gzMiA9IG5pcDE5My5ub3RlRW5jb2RlKGFydGljbGVUYWdbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyXCI6XG4gICAgICAgIHRoaXMuX2FydGljbGUgPSBhcnRpY2xlVGFnWzFdO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRhZ2dlZEJlY2gzMikge1xuICAgICAgbGV0IGEgPSBhd2FpdCB0aGlzLm5kaz8uZmV0Y2hFdmVudCh0YWdnZWRCZWNoMzIpO1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgaWYgKGEua2luZCA9PT0gMzAwMjMgLyogQXJ0aWNsZSAqLykge1xuICAgICAgICAgIGEgPSBOREtBcnRpY2xlLmZyb20oYSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXJ0aWNsZSA9IGE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hcnRpY2xlO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvaW1ldGEudHNcbmZ1bmN0aW9uIG1hcEltZXRhVGFnKHRhZykge1xuICBjb25zdCBkYXRhID0ge307XG4gIGlmICh0YWcubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc3QgcGFydHMgPSB0YWdbMV0uc3BsaXQoXCIgXCIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGtleSA9IHBhcnRzW2ldO1xuICAgICAgY29uc3QgdmFsdWUgPSBwYXJ0c1tpICsgMV07XG4gICAgICBpZiAoa2V5ID09PSBcImZhbGxiYWNrXCIpIHtcbiAgICAgICAgaWYgKCFkYXRhLmZhbGxiYWNrKSBkYXRhLmZhbGxiYWNrID0gW107XG4gICAgICAgIGRhdGEuZmFsbGJhY2sucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgY29uc3QgdGFncyA9IHRhZy5zbGljZSgxKTtcbiAgZm9yIChjb25zdCB2YWwgb2YgdGFncykge1xuICAgIGNvbnN0IHBhcnRzID0gdmFsLnNwbGl0KFwiIFwiKTtcbiAgICBjb25zdCBrZXkgPSBwYXJ0c1swXTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnRzLnNsaWNlKDEpLmpvaW4oXCIgXCIpO1xuICAgIGlmIChrZXkgPT09IFwiZmFsbGJhY2tcIikge1xuICAgICAgaWYgKCFkYXRhLmZhbGxiYWNrKSBkYXRhLmZhbGxiYWNrID0gW107XG4gICAgICBkYXRhLmZhbGxiYWNrLnB1c2godmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBpbWV0YVRhZ1RvVGFnKGltZXRhKSB7XG4gIGNvbnN0IHRhZyA9IFtcImltZXRhXCJdO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhpbWV0YSkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICB0YWcucHVzaChgJHtrZXl9ICR7dn1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICB0YWcucHVzaChgJHtrZXl9ICR7dmFsdWV9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YWc7XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvaW1hZ2UudHNcbnZhciBOREtJbWFnZSA9IGNsYXNzIF9OREtJbWFnZSBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGtpbmQgPSAyMCAvKiBJbWFnZSAqLztcbiAgc3RhdGljIGtpbmRzID0gWzIwIC8qIEltYWdlICovXTtcbiAgX2ltZXRhcztcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMjAgLyogSW1hZ2UgKi87XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOREtJbWFnZSBmcm9tIGFuIGV4aXN0aW5nIE5ES0V2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgTkRLRXZlbnQgdG8gY3JlYXRlIHRoZSBOREtJbWFnZSBmcm9tLlxuICAgKiBAcmV0dXJucyBOREtJbWFnZVxuICAgKi9cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtJbWFnZShldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmltZXRhcy5sZW5ndGggPiAwO1xuICB9XG4gIGdldCBpbWV0YXMoKSB7XG4gICAgaWYgKHRoaXMuX2ltZXRhcykgcmV0dXJuIHRoaXMuX2ltZXRhcztcbiAgICB0aGlzLl9pbWV0YXMgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJpbWV0YVwiKS5tYXAobWFwSW1ldGFUYWcpLmZpbHRlcigoaW1ldGEpID0+ICEhaW1ldGEudXJsKTtcbiAgICByZXR1cm4gdGhpcy5faW1ldGFzO1xuICB9XG4gIHNldCBpbWV0YXModGFncykge1xuICAgIHRoaXMuX2ltZXRhcyA9IHRhZ3M7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwiaW1ldGFcIik7XG4gICAgdGhpcy50YWdzLnB1c2goLi4udGFncy5tYXAoaW1ldGFUYWdUb1RhZykpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2xpc3RzL2luZGV4LnRzXG52YXIgTkRLTGlzdCA9IGNsYXNzIF9OREtMaXN0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBfZW5jcnlwdGVkVGFncztcbiAgc3RhdGljIGtpbmRzID0gW1xuICAgIDEwMDYzIC8qIEJsb3Nzb21MaXN0ICovLFxuICAgIDMwMDAxIC8qIENhdGVnb3JpemVkQm9va21hcmtMaXN0ICovLFxuICAgIDEwMDA0IC8qIENvbW11bml0eUxpc3QgKi8sXG4gICAgMTAwNTAgLyogRGlyZWN0TWVzc2FnZVJlY2VpdmVSZWxheUxpc3QgKi8sXG4gICAgMTAwMzAgLyogRW1vamlMaXN0ICovLFxuICAgIDEwMDE1IC8qIEludGVyZXN0TGlzdCAqLyxcbiAgICAxMDAwMSAvKiBQaW5MaXN0ICovLFxuICAgIDEwMDAyIC8qIFJlbGF5TGlzdCAqLyxcbiAgICAxMDAwNyAvKiBTZWFyY2hSZWxheUxpc3QgKi8sXG4gICAgMTAwMDYgLyogQmxvY2tSZWxheUxpc3QgKi8sXG4gICAgMTAwMDMgLyogQm9va21hcmtMaXN0ICovXG4gIF07XG4gIC8qKlxuICAgKiBTdG9yZXMgdGhlIG51bWJlciBvZiBieXRlcyB0aGUgY29udGVudCB3YXMgYmVmb3JlIGRlY3J5cHRpb25cbiAgICogdG8gZXhwaXJlIHRoZSBjYWNoZSB3aGVuIHRoZSBjb250ZW50IGNoYW5nZXMuXG4gICAqL1xuICBlbmNyeXB0ZWRUYWdzTGVuZ3RoO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzMDAwMSAvKiBDYXRlZ29yaXplZEJvb2ttYXJrTGlzdCAqLztcbiAgfVxuICAvKipcbiAgICogV3JhcCBhIE5ES0V2ZW50IGludG8gYSBOREtMaXN0XG4gICAqL1xuICBzdGF0aWMgZnJvbShuZGtFdmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0xpc3QobmRrRXZlbnQubmRrLCBuZGtFdmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRpdGxlIG9mIHRoZSBsaXN0LiBGYWxscyBiYWNrIG9uIGZldGNoaW5nIHRoZSBuYW1lIHRhZyB2YWx1ZS5cbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICBjb25zdCB0aXRsZVRhZyA9IHRoaXMudGFnVmFsdWUoXCJ0aXRsZVwiKSB8fCB0aGlzLnRhZ1ZhbHVlKFwibmFtZVwiKTtcbiAgICBpZiAodGl0bGVUYWcpIHJldHVybiB0aXRsZVRhZztcbiAgICBpZiAodGhpcy5raW5kID09PSAzIC8qIENvbnRhY3RzICovKSB7XG4gICAgICByZXR1cm4gXCJDb250YWN0c1wiO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSAxZTQgLyogTXV0ZUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIk11dGVcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMTAwMDEgLyogUGluTGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiUGlubmVkIE5vdGVzXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDAyIC8qIFJlbGF5TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiUmVsYXkgTWV0YWRhdGFcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMTAwMDMgLyogQm9va21hcmtMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJCb29rbWFya3NcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMTAwMDQgLyogQ29tbXVuaXR5TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiQ29tbXVuaXRpZXNcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMTAwMDUgLyogUHVibGljQ2hhdExpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIlB1YmxpYyBDaGF0c1wiO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSAxMDAwNiAvKiBCbG9ja1JlbGF5TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiQmxvY2tlZCBSZWxheXNcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMTAwMDcgLyogU2VhcmNoUmVsYXlMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJTZWFyY2ggUmVsYXlzXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDUwIC8qIERpcmVjdE1lc3NhZ2VSZWNlaXZlUmVsYXlMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJEaXJlY3QgTWVzc2FnZSBSZWNlaXZlIFJlbGF5c1wiO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSAxMDAxNSAvKiBJbnRlcmVzdExpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIkludGVyZXN0c1wiO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSAxMDAzMCAvKiBFbW9qaUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIkVtb2ppc1wiO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRpdGxlIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgc2V0IHRpdGxlKHRpdGxlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoW1widGl0bGVcIiwgXCJuYW1lXCJdKTtcbiAgICBpZiAodGl0bGUpIHRoaXMudGFncy5wdXNoKFtcInRpdGxlXCIsIHRpdGxlXSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGxpc3QuXG4gICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgXCJ0aXRsZVwiIGluc3RlYWQuXG4gICAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy50aXRsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbmFtZSBvZiB0aGUgbGlzdC5cbiAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBcInRpdGxlXCIgaW5zdGVhZC4gVGhpcyBtZXRob2Qgd2lsbCB1c2UgdGhlIGB0aXRsZWAgdGFnIGluc3RlYWQuXG4gICAqL1xuICBzZXQgbmFtZShuYW1lKSB7XG4gICAgdGhpcy50aXRsZSA9IG5hbWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZGVzY3JpcHRpb25cIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgc2V0IGRlc2NyaXB0aW9uKG5hbWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImRlc2NyaXB0aW9uXCIpO1xuICAgIGlmIChuYW1lKSB0aGlzLnRhZ3MucHVzaChbXCJkZXNjcmlwdGlvblwiLCBuYW1lXSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGltYWdlIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgZ2V0IGltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiaW1hZ2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGltYWdlIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgc2V0IGltYWdlKG5hbWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImltYWdlXCIpO1xuICAgIGlmIChuYW1lKSB0aGlzLnRhZ3MucHVzaChbXCJpbWFnZVwiLCBuYW1lXSk7XG4gIH1cbiAgaXNFbmNyeXB0ZWRUYWdzQ2FjaGVWYWxpZCgpIHtcbiAgICByZXR1cm4gISEodGhpcy5fZW5jcnlwdGVkVGFncyAmJiB0aGlzLmVuY3J5cHRlZFRhZ3NMZW5ndGggPT09IHRoaXMuY29udGVudC5sZW5ndGgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZWNyeXB0ZWQgY29udGVudCBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGFzeW5jIGVuY3J5cHRlZFRhZ3ModXNlQ2FjaGUgPSB0cnVlKSB7XG4gICAgaWYgKHVzZUNhY2hlICYmIHRoaXMuaXNFbmNyeXB0ZWRUYWdzQ2FjaGVWYWxpZCgpKSByZXR1cm4gdGhpcy5fZW5jcnlwdGVkVGFncztcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IHNldFwiKTtcbiAgICBpZiAoIXRoaXMubmRrLnNpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwiTkRLIHNpZ25lciBub3Qgc2V0XCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5kay5zaWduZXIudXNlcigpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBkZWNyeXB0ZWRDb250ZW50ID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLmRlY3J5cHQodXNlciwgdGhpcy5jb250ZW50KTtcbiAgICAgICAgICBjb25zdCBhID0gSlNPTi5wYXJzZShkZWNyeXB0ZWRDb250ZW50KTtcbiAgICAgICAgICBpZiAoYT8uWzBdKSB7XG4gICAgICAgICAgICB0aGlzLmVuY3J5cHRlZFRhZ3NMZW5ndGggPSB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VuY3J5cHRlZFRhZ3MgPSBhO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVuY3J5cHRlZFRhZ3NMZW5ndGggPSB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9lbmNyeXB0ZWRUYWdzID0gW107XG4gICAgICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChfZSkge1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZW4gdG8gdmFsaWRhdGUgdGhhdCBhIHRhZyBpcyB2YWxpZCBmb3IgdGhpcyBsaXN0LlxuICAgKlxuICAgKiAoaS5lLiB0aGUgTkRLUGVyc29uTGlzdCBjYW4gdmFsaWRhdGUgdGhhdCBpdGVtcyBhcmUgTkRLVXNlciBpbnN0YW5jZXMpXG4gICAqL1xuICB2YWxpZGF0ZVRhZyhfdGFnVmFsdWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXRJdGVtcyh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdID09PSB0eXBlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdW5lY3J5cHRlZCBpdGVtcyBpbiB0aGlzIGxpc3QuXG4gICAqL1xuICBnZXQgaXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFncy5maWx0ZXIoKHQpID0+IHtcbiAgICAgIHJldHVybiAhW1xuICAgICAgICBcImRcIixcbiAgICAgICAgXCJMXCIsXG4gICAgICAgIFwibFwiLFxuICAgICAgICBcInRpdGxlXCIsXG4gICAgICAgIFwibmFtZVwiLFxuICAgICAgICBcImRlc2NyaXB0aW9uXCIsXG4gICAgICAgIFwicHVibGlzaGVkX2F0XCIsXG4gICAgICAgIFwic3VtbWFyeVwiLFxuICAgICAgICBcImltYWdlXCIsXG4gICAgICAgIFwidGh1bWJcIixcbiAgICAgICAgXCJhbHRcIixcbiAgICAgICAgXCJleHBpcmF0aW9uXCIsXG4gICAgICAgIFwic3ViamVjdFwiLFxuICAgICAgICBcImNsaWVudFwiXG4gICAgICBdLmluY2x1ZGVzKHRbMF0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGl0ZW0gdG8gdGhlIGxpc3QuXG4gICAqIEBwYXJhbSByZWxheSBSZWxheSB0byBhZGRcbiAgICogQHBhcmFtIG1hcmsgT3B0aW9uYWwgbWFyayB0byBhZGQgdG8gdGhlIGl0ZW1cbiAgICogQHBhcmFtIGVuY3J5cHRlZCBXaGV0aGVyIHRvIGVuY3J5cHQgdGhlIGl0ZW1cbiAgICogQHBhcmFtIHBvc2l0aW9uIFdoZXJlIHRvIGFkZCB0aGUgaXRlbSBpbiB0aGUgbGlzdCAodG9wIG9yIGJvdHRvbSlcbiAgICovXG4gIGFzeW5jIGFkZEl0ZW0oaXRlbSwgbWFyayA9IHZvaWQgMCwgZW5jcnlwdGVkID0gZmFsc2UsIHBvc2l0aW9uID0gXCJib3R0b21cIikge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3Qgc2V0XCIpO1xuICAgIGlmICghdGhpcy5uZGsuc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgc2lnbmVyIG5vdCBzZXRcIik7XG4gICAgbGV0IHRhZ3M7XG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtFdmVudCkge1xuICAgICAgdGFncyA9IFtpdGVtLnRhZ1JlZmVyZW5jZShtYXJrKV07XG4gICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgTkRLVXNlcikge1xuICAgICAgdGFncyA9IGl0ZW0ucmVmZXJlbmNlVGFncygpO1xuICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES1JlbGF5KSB7XG4gICAgICB0YWdzID0gaXRlbS5yZWZlcmVuY2VUYWdzKCk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICB0YWdzID0gW2l0ZW1dO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9iamVjdCB0eXBlXCIpO1xuICAgIH1cbiAgICBpZiAobWFyaykgdGFnc1swXS5wdXNoKG1hcmspO1xuICAgIGlmIChlbmNyeXB0ZWQpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5kay5zaWduZXIudXNlcigpO1xuICAgICAgY29uc3QgY3VycmVudExpc3QgPSBhd2FpdCB0aGlzLmVuY3J5cHRlZFRhZ3MoKTtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJ0b3BcIikgY3VycmVudExpc3QudW5zaGlmdCguLi50YWdzKTtcbiAgICAgIGVsc2UgY3VycmVudExpc3QucHVzaCguLi50YWdzKTtcbiAgICAgIHRoaXMuX2VuY3J5cHRlZFRhZ3MgPSBjdXJyZW50TGlzdDtcbiAgICAgIHRoaXMuZW5jcnlwdGVkVGFnc0xlbmd0aCA9IHRoaXMuY29udGVudC5sZW5ndGg7XG4gICAgICB0aGlzLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShjdXJyZW50TGlzdCk7XG4gICAgICBhd2FpdCB0aGlzLmVuY3J5cHQodXNlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJ0b3BcIikgdGhpcy50YWdzLnVuc2hpZnQoLi4udGFncyk7XG4gICAgICBlbHNlIHRoaXMudGFncy5wdXNoKC4uLnRhZ3MpO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZWRfYXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpO1xuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIGxpc3QgZnJvbSBib3RoIHRoZSBlbmNyeXB0ZWQgYW5kIHVuZW5jcnlwdGVkIGxpc3RzLlxuICAgKiBAcGFyYW0gdmFsdWUgdmFsdWUgb2YgaXRlbSB0byByZW1vdmUgZnJvbSB0aGUgbGlzdFxuICAgKiBAcGFyYW0gcHVibGlzaCB3aGV0aGVyIHRvIHB1Ymxpc2ggdGhlIGNoYW5nZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgcmVtb3ZlSXRlbUJ5VmFsdWUodmFsdWUsIHB1Ymxpc2ggPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBzZXRcIik7XG4gICAgaWYgKCF0aGlzLm5kay5zaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5ESyBzaWduZXIgbm90IHNldFwiKTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMudGFncy5maW5kSW5kZXgoKHRhZykgPT4gdGFnWzFdID09PSB2YWx1ZSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMudGFncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLnVzZXIoKTtcbiAgICBjb25zdCBlbmNyeXB0ZWRUYWdzID0gYXdhaXQgdGhpcy5lbmNyeXB0ZWRUYWdzKCk7XG4gICAgY29uc3QgZW5jcnlwdGVkSW5kZXggPSBlbmNyeXB0ZWRUYWdzLmZpbmRJbmRleCgodGFnKSA9PiB0YWdbMV0gPT09IHZhbHVlKTtcbiAgICBpZiAoZW5jcnlwdGVkSW5kZXggPj0gMCkge1xuICAgICAgZW5jcnlwdGVkVGFncy5zcGxpY2UoZW5jcnlwdGVkSW5kZXgsIDEpO1xuICAgICAgdGhpcy5fZW5jcnlwdGVkVGFncyA9IGVuY3J5cHRlZFRhZ3M7XG4gICAgICB0aGlzLmVuY3J5cHRlZFRhZ3NMZW5ndGggPSB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoZW5jcnlwdGVkVGFncyk7XG4gICAgICBhd2FpdCB0aGlzLmVuY3J5cHQodXNlcik7XG4gICAgfVxuICAgIGlmIChwdWJsaXNoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdWJsaXNoUmVwbGFjZWFibGUoKTtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVkX2F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBsaXN0LlxuICAgKlxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBpdGVtIHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIGVuY3J5cHRlZCBXaGV0aGVyIHRvIHJlbW92ZSBmcm9tIHRoZSBlbmNyeXB0ZWQgbGlzdCBvciBub3QuXG4gICAqL1xuICBhc3luYyByZW1vdmVJdGVtKGluZGV4LCBlbmNyeXB0ZWQpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IHNldFwiKTtcbiAgICBpZiAoIXRoaXMubmRrLnNpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwiTkRLIHNpZ25lciBub3Qgc2V0XCIpO1xuICAgIGlmIChlbmNyeXB0ZWQpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5kay5zaWduZXIudXNlcigpO1xuICAgICAgY29uc3QgY3VycmVudExpc3QgPSBhd2FpdCB0aGlzLmVuY3J5cHRlZFRhZ3MoKTtcbiAgICAgIGN1cnJlbnRMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB0aGlzLl9lbmNyeXB0ZWRUYWdzID0gY3VycmVudExpc3Q7XG4gICAgICB0aGlzLmVuY3J5cHRlZFRhZ3NMZW5ndGggPSB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoY3VycmVudExpc3QpO1xuICAgICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVkX2F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaGFzKGl0ZW0pIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5zb21lKCh0YWcpID0+IHRhZ1sxXSA9PT0gaXRlbSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmaWx0ZXIgdGhhdCB3aWxsIHJlc3VsdCBpbiBmZXRjaGluZ1xuICAgKiB0aGUgaXRlbXMgb2YgdGhpcyBsaXN0XG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGxpc3QgPSBuZXcgTkRLTGlzdCguLi4pO1xuICAgKiBjb25zdCBmaWx0ZXJzID0gbGlzdC5maWx0ZXJGb3JJdGVtcygpO1xuICAgKiBjb25zdCBldmVudHMgPSBhd2FpdCBuZGsuZmV0Y2hFdmVudHMoZmlsdGVycyk7XG4gICAqL1xuICBmaWx0ZXJGb3JJdGVtcygpIHtcbiAgICBjb25zdCBpZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IG5pcDMzUXVlcmllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgZmlsdGVycyA9IFtdO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwiZVwiICYmIHRhZ1sxXSkge1xuICAgICAgICBpZHMuYWRkKHRhZ1sxXSk7XG4gICAgICB9IGVsc2UgaWYgKHRhZ1swXSA9PT0gXCJhXCIgJiYgdGFnWzFdKSB7XG4gICAgICAgIGNvbnN0IFtraW5kLCBwdWJrZXksIGRUYWddID0gdGFnWzFdLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgaWYgKCFraW5kIHx8ICFwdWJrZXkpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBrZXkgPSBgJHtraW5kfToke3B1YmtleX1gO1xuICAgICAgICBjb25zdCBpdGVtID0gbmlwMzNRdWVyaWVzLmdldChrZXkpIHx8IFtdO1xuICAgICAgICBpdGVtLnB1c2goZFRhZyB8fCBcIlwiKTtcbiAgICAgICAgbmlwMzNRdWVyaWVzLnNldChrZXksIGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaWRzLnNpemUgPiAwKSB7XG4gICAgICBmaWx0ZXJzLnB1c2goeyBpZHM6IEFycmF5LmZyb20oaWRzKSB9KTtcbiAgICB9XG4gICAgaWYgKG5pcDMzUXVlcmllcy5zaXplID4gMCkge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIG5pcDMzUXVlcmllcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgW2tpbmQsIHB1YmtleV0gPSBrZXkuc3BsaXQoXCI6XCIpO1xuICAgICAgICBmaWx0ZXJzLnB1c2goe1xuICAgICAgICAgIGtpbmRzOiBbTnVtYmVyLnBhcnNlSW50KGtpbmQpXSxcbiAgICAgICAgICBhdXRob3JzOiBbcHVia2V5XSxcbiAgICAgICAgICBcIiNkXCI6IHZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcnM7XG4gIH1cbn07XG52YXIgbGlzdHNfZGVmYXVsdCA9IE5ES0xpc3Q7XG5cbi8vIHNyYy9ldmVudHMva2luZHMvbnV0emFwL2luZGV4LnRzXG5pbXBvcnQgZGVidWcyIGZyb20gXCJkZWJ1Z1wiO1xudmFyIE5ES051dHphcCA9IGNsYXNzIF9OREtOdXR6YXAgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGRlYnVnO1xuICBfcHJvb2ZzID0gW107XG4gIHN0YXRpYyBraW5kID0gOTMyMSAvKiBOdXR6YXAgKi87XG4gIHN0YXRpYyBraW5kcyA9IFtfTkRLTnV0emFwLmtpbmRdO1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIobmRrLCBldmVudCk7XG4gICAgdGhpcy5raW5kID8/PSA5MzIxIC8qIE51dHphcCAqLztcbiAgICB0aGlzLmRlYnVnID0gbmRrPy5kZWJ1Zy5leHRlbmQoXCJudXR6YXBcIikgPz8gZGVidWcyKFwibmRrOm51dHphcFwiKTtcbiAgICBpZiAoIXRoaXMuYWx0KSB0aGlzLmFsdCA9IFwiVGhpcyBpcyBhIG51dHphcFwiO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9vZlRhZ3MgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInByb29mXCIpO1xuICAgICAgaWYgKHByb29mVGFncy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fcHJvb2ZzID0gcHJvb2ZUYWdzLm1hcCgodGFnKSA9PiBKU09OLnBhcnNlKHRhZ1sxXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcHJvb2ZzID0gSlNPTi5wYXJzZSh0aGlzLmNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIGNvbnN0IGUgPSBuZXcgX05ES051dHphcChldmVudC5uZGssIGV2ZW50KTtcbiAgICBpZiAoIWUuX3Byb29mcyB8fCAhZS5fcHJvb2ZzLmxlbmd0aCkgcmV0dXJuO1xuICAgIHJldHVybiBlO1xuICB9XG4gIHNldCBjb21tZW50KGNvbW1lbnQpIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb21tZW50ID8/IFwiXCI7XG4gIH1cbiAgZ2V0IGNvbW1lbnQoKSB7XG4gICAgY29uc3QgYyA9IHRoaXMudGFnVmFsdWUoXCJjb21tZW50XCIpO1xuICAgIGlmIChjKSByZXR1cm4gYztcbiAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuICB9XG4gIHNldCBwcm9vZnMocHJvb2ZzKSB7XG4gICAgdGhpcy5fcHJvb2ZzID0gcHJvb2ZzO1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcInByb29mXCIpO1xuICAgIGZvciAoY29uc3QgcHJvb2Ygb2YgcHJvb2ZzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwcm9vZlwiLCBKU09OLnN0cmluZ2lmeShwcm9vZildKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHByb29mcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvb2ZzO1xuICB9XG4gIGdldCByYXdQMnBrKCkge1xuICAgIGNvbnN0IGZpcnN0UHJvb2YgPSB0aGlzLnByb29mc1swXTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2VjcmV0ID0gSlNPTi5wYXJzZShmaXJzdFByb29mLnNlY3JldCk7XG4gICAgICBsZXQgcGF5bG9hZDtcbiAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKHNlY3JldCk7XG4gICAgICAgIHRoaXMuZGVidWcoXCJzdHJpbmdpZmllZCBwYXlsb2FkXCIsIGZpcnN0UHJvb2Yuc2VjcmV0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlY3JldCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBwYXlsb2FkID0gc2VjcmV0O1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkgJiYgcGF5bG9hZFswXSA9PT0gXCJQMlBLXCIgJiYgcGF5bG9hZC5sZW5ndGggPiAxICYmIHR5cGVvZiBwYXlsb2FkWzFdID09PSBcIm9iamVjdFwiICYmIHBheWxvYWRbMV0gIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHBheWxvYWRbMV0uZGF0YTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gXCJvYmplY3RcIiAmJiBwYXlsb2FkICE9PSBudWxsICYmIHR5cGVvZiBwYXlsb2FkWzFdPy5kYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkWzFdLmRhdGE7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5kZWJ1ZyhcImVycm9yIHBhcnNpbmcgcDJwayBwdWJrZXlcIiwgZSwgdGhpcy5wcm9vZnNbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwMnBrIHB1YmtleSB0aGF0IGlzIGVtYmVkZGVkIGluIHRoZSBmaXJzdCBwcm9vZi5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgcmV0dXJucyBhIG5vc3RyIHB1YmtleSwgbm90IGEgY2FzaHUgcHVia2V5IChubyBcIjAyXCIgcHJlZml4KVxuICAgKi9cbiAgZ2V0IHAycGsoKSB7XG4gICAgY29uc3QgcmF3UDJwayA9IHRoaXMucmF3UDJwaztcbiAgICBpZiAoIXJhd1AycGspIHJldHVybjtcbiAgICByZXR1cm4gcmF3UDJway5zdGFydHNXaXRoKFwiMDJcIikgPyByYXdQMnBrLnNsaWNlKDIpIDogcmF3UDJwaztcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtaW50IHdoZXJlIHRoaXMgbnV0emFwIHByb29mcyBleGlzdFxuICAgKi9cbiAgZ2V0IG1pbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ1XCIpO1xuICB9XG4gIHNldCBtaW50KHZhbHVlKSB7XG4gICAgdGhpcy5yZXBsYWNlVGFnKFtcInVcIiwgdmFsdWVdKTtcbiAgfVxuICBnZXQgdW5pdCgpIHtcbiAgICBsZXQgX3VuaXQgPSB0aGlzLnRhZ1ZhbHVlKFwidW5pdFwiKSA/PyBcInNhdFwiO1xuICAgIGlmIChfdW5pdD8uc3RhcnRzV2l0aChcIm1zYXRcIikpIF91bml0ID0gXCJzYXRcIjtcbiAgICByZXR1cm4gX3VuaXQ7XG4gIH1cbiAgc2V0IHVuaXQodmFsdWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInVuaXRcIik7XG4gICAgaWYgKHZhbHVlPy5zdGFydHNXaXRoKFwibXNhdFwiKSkgdGhyb3cgbmV3IEVycm9yKFwibXNhdCBpcyBub3QgYWxsb3dlZCwgdXNlIHNhdCBkZW5vbWluYXRpb24gaW5zdGVhZFwiKTtcbiAgICBpZiAodmFsdWUpIHRoaXMudGFnKFtcInVuaXRcIiwgdmFsdWVdKTtcbiAgfVxuICBnZXQgYW1vdW50KCkge1xuICAgIGNvbnN0IGFtb3VudCA9IHRoaXMucHJvb2ZzLnJlZHVjZSgodG90YWwsIHByb29mKSA9PiB0b3RhbCArIHByb29mLmFtb3VudCwgMCk7XG4gICAgcmV0dXJuIGFtb3VudDtcbiAgfVxuICBzZW5kZXIgPSB0aGlzLmF1dGhvcjtcbiAgLyoqXG4gICAqIFNldCB0aGUgdGFyZ2V0IG9mIHRoZSBudXR6YXBcbiAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9mIHRoZSBudXR6YXAgKGEgdXNlciBvciBhbiBldmVudClcbiAgICovXG4gIHNldCB0YXJnZXQodGFyZ2V0KSB7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gdFswXSAhPT0gXCJwXCIpO1xuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBOREtFdmVudCkge1xuICAgICAgdGhpcy50YWdzLnB1c2godGFyZ2V0LnRhZ1JlZmVyZW5jZSgpKTtcbiAgICB9XG4gIH1cbiAgc2V0IHJlY2lwaWVudFB1YmtleShwdWJrZXkpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInBcIik7XG4gICAgdGhpcy50YWcoW1wicFwiLCBwdWJrZXldKTtcbiAgfVxuICBnZXQgcmVjaXBpZW50UHVia2V5KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwicFwiKTtcbiAgfVxuICBnZXQgcmVjaXBpZW50KCkge1xuICAgIGNvbnN0IHB1YmtleSA9IHRoaXMucmVjaXBpZW50UHVia2V5O1xuICAgIGlmICh0aGlzLm5kaykgcmV0dXJuIHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXkgfSk7XG4gICAgcmV0dXJuIG5ldyBOREtVc2VyKHsgcHVia2V5IH0pO1xuICB9XG4gIGFzeW5jIHRvTm9zdHJFdmVudCgpIHtcbiAgICBpZiAodGhpcy51bml0ID09PSBcIm1zYXRcIikge1xuICAgICAgdGhpcy51bml0ID0gXCJzYXRcIjtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhbW91bnRcIik7XG4gICAgdGhpcy50YWdzLnB1c2goW1wiYW1vdW50XCIsIHRoaXMuYW1vdW50LnRvU3RyaW5nKCldKTtcbiAgICBjb25zdCBldmVudCA9IGF3YWl0IHN1cGVyLnRvTm9zdHJFdmVudCgpO1xuICAgIGV2ZW50LmNvbnRlbnQgPSB0aGlzLmNvbW1lbnQ7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgbnV0emFwIGNvbmZvcm1zIHRvIE5JUC02MVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgbGV0IGVUYWdDb3VudCA9IDA7XG4gICAgbGV0IHBUYWdDb3VudCA9IDA7XG4gICAgbGV0IG1pbnRUYWdDb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIikgZVRhZ0NvdW50Kys7XG4gICAgICBpZiAodGFnWzBdID09PSBcInBcIikgcFRhZ0NvdW50Kys7XG4gICAgICBpZiAodGFnWzBdID09PSBcInVcIikgbWludFRhZ0NvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAvLyBleGFjdGx5IG9uZSByZWNpcGllbnQgYW5kIG1pbnRcbiAgICAgIHBUYWdDb3VudCA9PT0gMSAmJiBtaW50VGFnQ291bnQgPT09IDEgJiYgLy8gbXVzdCBoYXZlIGF0IG1vc3Qgb25lIGUgdGFnXG4gICAgICBlVGFnQ291bnQgPD0gMSAmJiAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHByb29mXG4gICAgICB0aGlzLnByb29mcy5sZW5ndGggPiAwXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHByb29mUDJwayhwcm9vZikge1xuICB0cnkge1xuICAgIGNvbnN0IHNlY3JldCA9IEpTT04ucGFyc2UocHJvb2Yuc2VjcmV0KTtcbiAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShzZWNyZXQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlY3JldCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcGF5bG9hZCA9IHNlY3JldDtcbiAgICB9XG4gICAgY29uc3QgaXNQMlBLTG9ja2VkID0gcGF5bG9hZFswXSA9PT0gXCJQMlBLXCIgJiYgcGF5bG9hZFsxXT8uZGF0YTtcbiAgICBpZiAoaXNQMlBLTG9ja2VkKSB7XG4gICAgICByZXR1cm4gcGF5bG9hZFsxXS5kYXRhO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJlcnJvciBwYXJzaW5nIHAycGsgcHVia2V5XCIsIGUsIHByb29mKTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvb2ZQMnBrTm9zdHIocHJvb2YpIHtcbiAgY29uc3QgcDJwayA9IHByb29mUDJwayhwcm9vZik7XG4gIGlmICghcDJwaykgcmV0dXJuO1xuICBpZiAocDJway5zdGFydHNXaXRoKFwiMDJcIikgJiYgcDJway5sZW5ndGggPT09IDY2KSByZXR1cm4gcDJway5zbGljZSgyKTtcbiAgcmV0dXJuIHAycGs7XG59XG5mdW5jdGlvbiBjYXNodVB1YmtleVRvTm9zdHJQdWJrZXkoY2FzaHVQdWJrZXkpIHtcbiAgaWYgKGNhc2h1UHVia2V5LnN0YXJ0c1dpdGgoXCIwMlwiKSAmJiBjYXNodVB1YmtleS5sZW5ndGggPT09IDY2KSByZXR1cm4gY2FzaHVQdWJrZXkuc2xpY2UoMik7XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc2ltcGxlLWdyb3VwL21lbWJlci1saXN0LnRzXG52YXIgTkRLU2ltcGxlR3JvdXBNZW1iZXJMaXN0ID0gY2xhc3MgX05ES1NpbXBsZUdyb3VwTWVtYmVyTGlzdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgcmVsYXlTZXQ7XG4gIG1lbWJlclNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHN0YXRpYyBraW5kID0gMzkwMDIgLyogR3JvdXBNZW1iZXJzICovO1xuICBzdGF0aWMga2luZHMgPSBbMzkwMDIgLyogR3JvdXBNZW1iZXJzICovXTtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzkwMDIgLyogR3JvdXBNZW1iZXJzICovO1xuICAgIHRoaXMubWVtYmVyU2V0ID0gbmV3IFNldCh0aGlzLm1lbWJlcnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLU2ltcGxlR3JvdXBNZW1iZXJMaXN0KGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIGdldCBtZW1iZXJzKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gIH1cbiAgaGFzTWVtYmVyKG1lbWJlcikge1xuICAgIHJldHVybiB0aGlzLm1lbWJlclNldC5oYXMobWVtYmVyKTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgIHJlbGF5U2V0ID8/PSB0aGlzLnJlbGF5U2V0O1xuICAgIHJldHVybiBzdXBlci5wdWJsaXNoUmVwbGFjZWFibGUocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9zaW1wbGUtZ3JvdXAvbWV0YWRhdGEudHNcbnZhciBOREtTaW1wbGVHcm91cE1ldGFkYXRhID0gY2xhc3MgX05ES1NpbXBsZUdyb3VwTWV0YWRhdGEgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMzllMyAvKiBHcm91cE1ldGFkYXRhICovO1xuICBzdGF0aWMga2luZHMgPSBbMzllMyAvKiBHcm91cE1ldGFkYXRhICovXTtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzllMyAvKiBHcm91cE1ldGFkYXRhICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLU2ltcGxlR3JvdXBNZXRhZGF0YShldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcIm5hbWVcIik7XG4gIH1cbiAgZ2V0IHBpY3R1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJwaWN0dXJlXCIpO1xuICB9XG4gIGdldCBhYm91dCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImFib3V0XCIpO1xuICB9XG4gIGdldCBzY29wZSgpIHtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwdWJsaWNcIikubGVuZ3RoID4gMCkgcmV0dXJuIFwicHVibGljXCI7XG4gICAgaWYgKHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicHVibGljXCIpLmxlbmd0aCA+IDApIHJldHVybiBcInByaXZhdGVcIjtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHNldCBzY29wZShzY29wZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicHVibGljXCIpO1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicHJpdmF0ZVwiKTtcbiAgICBpZiAoc2NvcGUgPT09IFwicHVibGljXCIpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInB1YmxpY1wiLCBcIlwiXSk7XG4gICAgfSBlbHNlIGlmIChzY29wZSA9PT0gXCJwcml2YXRlXCIpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInByaXZhdGVcIiwgXCJcIl0pO1xuICAgIH1cbiAgfVxuICBnZXQgYWNjZXNzKCkge1xuICAgIGlmICh0aGlzLmdldE1hdGNoaW5nVGFncyhcIm9wZW5cIikubGVuZ3RoID4gMCkgcmV0dXJuIFwib3BlblwiO1xuICAgIGlmICh0aGlzLmdldE1hdGNoaW5nVGFncyhcImNsb3NlZFwiKS5sZW5ndGggPiAwKSByZXR1cm4gXCJjbG9zZWRcIjtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHNldCBhY2Nlc3MoYWNjZXNzKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJvcGVuXCIpO1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiY2xvc2VkXCIpO1xuICAgIGlmIChhY2Nlc3MgPT09IFwib3BlblwiKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJvcGVuXCIsIFwiXCJdKTtcbiAgICB9IGVsc2UgaWYgKGFjY2VzcyA9PT0gXCJjbG9zZWRcIikge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiY2xvc2VkXCIsIFwiXCJdKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc3RvcnkudHNcbnZhciBOREtTdG9yeVN0aWNrZXJUeXBlID0gLyogQF9fUFVSRV9fICovICgoTkRLU3RvcnlTdGlja2VyVHlwZTIpID0+IHtcbiAgTkRLU3RvcnlTdGlja2VyVHlwZTJbXCJQdWJrZXlcIl0gPSBcInB1YmtleVwiO1xuICBOREtTdG9yeVN0aWNrZXJUeXBlMltcIkV2ZW50XCJdID0gXCJldmVudFwiO1xuICBOREtTdG9yeVN0aWNrZXJUeXBlMltcIlByb21wdFwiXSA9IFwicHJvbXB0XCI7XG4gIE5ES1N0b3J5U3RpY2tlclR5cGUyW1wiVGV4dFwiXSA9IFwidGV4dFwiO1xuICBOREtTdG9yeVN0aWNrZXJUeXBlMltcIkNvdW50ZG93blwiXSA9IFwiY291bnRkb3duXCI7XG4gIHJldHVybiBOREtTdG9yeVN0aWNrZXJUeXBlMjtcbn0pKE5ES1N0b3J5U3RpY2tlclR5cGUgfHwge30pO1xuZnVuY3Rpb24gc3RyVG9Qb3NpdGlvbihwb3NpdGlvblN0cikge1xuICBjb25zdCBbeCwgeV0gPSBwb3NpdGlvblN0ci5zcGxpdChcIixcIikubWFwKE51bWJlcik7XG4gIHJldHVybiB7IHgsIHkgfTtcbn1cbmZ1bmN0aW9uIHN0clRvRGltZW5zaW9uKGRpbWVuc2lvblN0cikge1xuICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSBkaW1lbnNpb25TdHIuc3BsaXQoXCJ4XCIpLm1hcChOdW1iZXIpO1xuICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0IH07XG59XG52YXIgTkRLU3RvcnlTdGlja2VyID0gY2xhc3MgX05ES1N0b3J5U3RpY2tlciB7XG4gIHN0YXRpYyBUZXh0ID0gXCJ0ZXh0XCIgLyogVGV4dCAqLztcbiAgc3RhdGljIFB1YmtleSA9IFwicHVia2V5XCIgLyogUHVia2V5ICovO1xuICBzdGF0aWMgRXZlbnQgPSBcImV2ZW50XCIgLyogRXZlbnQgKi87XG4gIHN0YXRpYyBQcm9tcHQgPSBcInByb21wdFwiIC8qIFByb21wdCAqLztcbiAgc3RhdGljIENvdW50ZG93biA9IFwiY291bnRkb3duXCIgLyogQ291bnRkb3duICovO1xuICB0eXBlO1xuICB2YWx1ZTtcbiAgcG9zaXRpb247XG4gIGRpbWVuc2lvbjtcbiAgcHJvcGVydGllcztcbiAgY29uc3RydWN0b3IoYXJnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgY29uc3QgdGFnID0gYXJnO1xuICAgICAgaWYgKHRhZ1swXSAhPT0gXCJzdGlja2VyXCIgfHwgdGFnLmxlbmd0aCA8IDUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGlja2VyIHRhZ1wiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHlwZSA9IHRhZ1sxXTtcbiAgICAgIHRoaXMudmFsdWUgPSB0YWdbMl07XG4gICAgICB0aGlzLnBvc2l0aW9uID0gc3RyVG9Qb3NpdGlvbih0YWdbM10pO1xuICAgICAgdGhpcy5kaW1lbnNpb24gPSBzdHJUb0RpbWVuc2lvbih0YWdbNF0pO1xuICAgICAgY29uc3QgcHJvcHMgPSB7fTtcbiAgICAgIGZvciAobGV0IGkgPSA1OyBpIDwgdGFnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IFtrZXksIC4uLnJlc3RdID0gdGFnW2ldLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgcHJvcHNba2V5XSA9IHJlc3Quam9pbihcIiBcIik7XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcHM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHlwZSA9IGFyZztcbiAgICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgICB0aGlzLnBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gICAgICB0aGlzLmRpbWVuc2lvbiA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbVRhZyh0YWcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBfTkRLU3RvcnlTdGlja2VyKHRhZyk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgZ2V0IHN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXM/LnN0eWxlO1xuICB9XG4gIHNldCBzdHlsZShzdHlsZSkge1xuICAgIGlmIChzdHlsZSkgdGhpcy5wcm9wZXJ0aWVzID0geyAuLi50aGlzLnByb3BlcnRpZXMsIHN0eWxlIH07XG4gICAgZWxzZSBkZWxldGUgdGhpcy5wcm9wZXJ0aWVzPy5zdHlsZTtcbiAgfVxuICBnZXQgcm90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcz8ucm90ID8gTnVtYmVyLnBhcnNlRmxvYXQodGhpcy5wcm9wZXJ0aWVzLnJvdCkgOiB2b2lkIDA7XG4gIH1cbiAgc2V0IHJvdGF0aW9uKHJvdGF0aW9uKSB7XG4gICAgaWYgKHJvdGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucHJvcGVydGllcyA9IHsgLi4udGhpcy5wcm9wZXJ0aWVzLCByb3Q6IHJvdGF0aW9uLnRvU3RyaW5nKCkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMucHJvcGVydGllcz8ucm90O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBzdGlja2VyIGlzIHZhbGlkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBzdGlja2VyIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNWYWxpZERpbWVuc2lvbnMoKSAmJiB0aGlzLmhhc1ZhbGlkUG9zaXRpb24oKTtcbiAgfVxuICBoYXNWYWxpZERpbWVuc2lvbnMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLmRpbWVuc2lvbi53aWR0aCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgdGhpcy5kaW1lbnNpb24uaGVpZ2h0ID09PSBcIm51bWJlclwiICYmICFOdW1iZXIuaXNOYU4odGhpcy5kaW1lbnNpb24ud2lkdGgpICYmICFOdW1iZXIuaXNOYU4odGhpcy5kaW1lbnNpb24uaGVpZ2h0KTtcbiAgfTtcbiAgaGFzVmFsaWRQb3NpdGlvbiA9ICgpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMucG9zaXRpb24ueCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgdGhpcy5wb3NpdGlvbi55ID09PSBcIm51bWJlclwiICYmICFOdW1iZXIuaXNOYU4odGhpcy5wb3NpdGlvbi54KSAmJiAhTnVtYmVyLmlzTmFOKHRoaXMucG9zaXRpb24ueSk7XG4gIH07XG4gIHRvVGFnKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICBjb25zdCBlcnJvcnMgPSBbXG4gICAgICAgICF0aGlzLmhhc1ZhbGlkRGltZW5zaW9ucygpID8gXCJkaW1lbnNpb25zIGlzIGludmFsaWRcIiA6IHZvaWQgMCxcbiAgICAgICAgIXRoaXMuaGFzVmFsaWRQb3NpdGlvbigpID8gXCJwb3NpdGlvbiBpcyBpbnZhbGlkXCIgOiB2b2lkIDBcbiAgICAgIF0uZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0aWNrZXI6ICR7ZXJyb3JzLmpvaW4oXCIsIFwiKX1gKTtcbiAgICB9XG4gICAgbGV0IHZhbHVlO1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIFwiZXZlbnRcIiAvKiBFdmVudCAqLzpcbiAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlLnRhZ0lkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInB1YmtleVwiIC8qIFB1YmtleSAqLzpcbiAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlLnB1YmtleTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHRhZyA9IFtcInN0aWNrZXJcIiwgdGhpcy50eXBlLCB2YWx1ZSwgY29vcmRpbmF0ZXModGhpcy5wb3NpdGlvbiksIGRpbWVuc2lvbih0aGlzLmRpbWVuc2lvbildO1xuICAgIGlmICh0aGlzLnByb3BlcnRpZXMpIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgcHJvcFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnByb3BlcnRpZXMpKSB7XG4gICAgICAgIHRhZy5wdXNoKGAke2tleX0gJHtwcm9wVmFsdWV9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWc7XG4gIH1cbn07XG52YXIgTkRLU3RvcnkgPSBjbGFzcyBfTkRLU3RvcnkgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMjMgLyogU3RvcnkgKi87XG4gIHN0YXRpYyBraW5kcyA9IFsyMyAvKiBTdG9yeSAqL107XG4gIF9pbWV0YTtcbiAgX2RpbWVuc2lvbnM7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDIzIC8qIFN0b3J5ICovO1xuICAgIGlmIChyYXdFdmVudCkge1xuICAgICAgZm9yIChjb25zdCB0YWcgb2YgcmF3RXZlbnQudGFncykge1xuICAgICAgICBzd2l0Y2ggKHRhZ1swXSkge1xuICAgICAgICAgIGNhc2UgXCJpbWV0YVwiOlxuICAgICAgICAgICAgdGhpcy5faW1ldGEgPSBtYXBJbWV0YVRhZyh0YWcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImRpbVwiOlxuICAgICAgICAgICAgdGhpcy5kaW1lbnNpb25zID0gc3RyVG9EaW1lbnNpb24odGFnWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTkRLU3RvcnkgZnJvbSBhbiBleGlzdGluZyBOREtFdmVudC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IE5ES0V2ZW50IHRvIGNyZWF0ZSB0aGUgTkRLU3RvcnkgZnJvbS5cbiAgICogQHJldHVybnMgTkRLU3RvcnlcbiAgICovXG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLU3RvcnkoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgc3RvcnkgaXMgdmFsaWQgKGhhcyBleGFjdGx5IG9uZSBpbWV0YSB0YWcpLlxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5pbWV0YTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgZmlyc3QgaW1ldGEgdGFnICh0aGVyZSBzaG91bGQgb25seSBiZSBvbmUpLlxuICAgKi9cbiAgZ2V0IGltZXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9pbWV0YTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhIHNpbmdsZSBpbWV0YSB0YWcsIHJlcGxhY2luZyBhbnkgZXhpc3Rpbmcgb25lcy5cbiAgICovXG4gIHNldCBpbWV0YSh0YWcpIHtcbiAgICB0aGlzLl9pbWV0YSA9IHRhZztcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0KSA9PiB0WzBdICE9PSBcImltZXRhXCIpO1xuICAgIGlmICh0YWcpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKGltZXRhVGFnVG9UYWcodGFnKSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBzdG9yeSBkaW1lbnNpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyB7TkRLU3RvcnlEaW1lbnNpb24gfCB1bmRlZmluZWR9IC0gVGhlIHN0b3J5IGRpbWVuc2lvbnMgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IGRpbWVuc2lvbnMoKSB7XG4gICAgY29uc3QgZGltVGFnID0gdGhpcy50YWdWYWx1ZShcImRpbVwiKTtcbiAgICBpZiAoIWRpbVRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gc3RyVG9EaW1lbnNpb24oZGltVGFnKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgc3RvcnkgZGltZW5zaW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtOREtTdG9yeURpbWVuc2lvbiB8IHVuZGVmaW5lZH0gZGltZW5zaW9ucyAtIFRoZSBkaW1lbnNpb25zIHRvIHNldCBmb3IgdGhlIHN0b3J5LlxuICAgKi9cbiAgc2V0IGRpbWVuc2lvbnMoZGltZW5zaW9ucykge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZGltXCIpO1xuICAgIGlmIChkaW1lbnNpb25zKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJkaW1cIiwgYCR7ZGltZW5zaW9ucy53aWR0aH14JHtkaW1lbnNpb25zLmhlaWdodH1gXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBzdG9yeSBkdXJhdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH0gLSBUaGUgc3RvcnkgZHVyYXRpb24gaW4gc2Vjb25kcyBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgZHVyYXRpb24oKSB7XG4gICAgY29uc3QgZHVyVGFnID0gdGhpcy50YWdWYWx1ZShcImR1clwiKTtcbiAgICBpZiAoIWR1clRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KGR1clRhZyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIHN0b3J5IGR1cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gZHVyYXRpb24gLSBUaGUgZHVyYXRpb24gaW4gc2Vjb25kcyB0byBzZXQgZm9yIHRoZSBzdG9yeS5cbiAgICovXG4gIHNldCBkdXJhdGlvbihkdXJhdGlvbikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZHVyXCIpO1xuICAgIGlmIChkdXJhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJkdXJcIiwgZHVyYXRpb24udG9TdHJpbmcoKV0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0cyBhbGwgc3RpY2tlcnMgZnJvbSB0aGUgc3RvcnkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtOREtTdG9yeVN0aWNrZXJbXX0gLSBBcnJheSBvZiBzdGlja2VycyBpbiB0aGUgc3RvcnkuXG4gICAqL1xuICBnZXQgc3RpY2tlcnMoKSB7XG4gICAgY29uc3Qgc3RpY2tlcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLnRhZ3MpIHtcbiAgICAgIGlmICh0YWdbMF0gIT09IFwic3RpY2tlclwiIHx8IHRhZy5sZW5ndGggPCA1KSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHN0aWNrZXIgPSBOREtTdG9yeVN0aWNrZXIuZnJvbVRhZyh0YWcpO1xuICAgICAgaWYgKHN0aWNrZXIpIHN0aWNrZXJzLnB1c2goc3RpY2tlcik7XG4gICAgfVxuICAgIHJldHVybiBzdGlja2VycztcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHN0aWNrZXIgdG8gdGhlIHN0b3J5LlxuICAgKlxuICAgKiBAcGFyYW0ge05ES1N0b3J5U3RpY2tlcnxTdG9yeVN0aWNrZXJ9IHN0aWNrZXIgLSBUaGUgc3RpY2tlciB0byBhZGQuXG4gICAqL1xuICBhZGRTdGlja2VyKHN0aWNrZXIpIHtcbiAgICBsZXQgc3RpY2tlclRvQWRkO1xuICAgIGlmIChzdGlja2VyIGluc3RhbmNlb2YgTkRLU3RvcnlTdGlja2VyKSB7XG4gICAgICBzdGlja2VyVG9BZGQgPSBzdGlja2VyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0YWcgPSBbXG4gICAgICAgIFwic3RpY2tlclwiLFxuICAgICAgICBzdGlja2VyLnR5cGUsXG4gICAgICAgIHR5cGVvZiBzdGlja2VyLnZhbHVlID09PSBcInN0cmluZ1wiID8gc3RpY2tlci52YWx1ZSA6IFwiXCIsXG4gICAgICAgIGNvb3JkaW5hdGVzKHN0aWNrZXIucG9zaXRpb24pLFxuICAgICAgICBkaW1lbnNpb24oc3RpY2tlci5kaW1lbnNpb24pXG4gICAgICBdO1xuICAgICAgaWYgKHN0aWNrZXIucHJvcGVydGllcykge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzdGlja2VyLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgdGFnLnB1c2goYCR7a2V5fSAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGlja2VyVG9BZGQgPSBuZXcgTkRLU3RvcnlTdGlja2VyKHRhZyk7XG4gICAgICBzdGlja2VyVG9BZGQudmFsdWUgPSBzdGlja2VyLnZhbHVlO1xuICAgIH1cbiAgICBpZiAoc3RpY2tlclRvQWRkLnR5cGUgPT09IFwicHVia2V5XCIgLyogUHVia2V5ICovKSB7XG4gICAgICB0aGlzLnRhZyhzdGlja2VyVG9BZGQudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoc3RpY2tlclRvQWRkLnR5cGUgPT09IFwiZXZlbnRcIiAvKiBFdmVudCAqLykge1xuICAgICAgdGhpcy50YWcoc3RpY2tlclRvQWRkLnZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy50YWdzLnB1c2goc3RpY2tlclRvQWRkLnRvVGFnKCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgc3RpY2tlciBmcm9tIHRoZSBzdG9yeS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBzdGlja2VyIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZVN0aWNrZXIoaW5kZXgpIHtcbiAgICBjb25zdCBzdGlja2VycyA9IHRoaXMuc3RpY2tlcnM7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzdGlja2Vycy5sZW5ndGgpIHJldHVybjtcbiAgICBsZXQgc3RpY2tlckNvdW50ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMudGFnc1tpXVswXSA9PT0gXCJzdGlja2VyXCIpIHtcbiAgICAgICAgaWYgKHN0aWNrZXJDb3VudCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICB0aGlzLnRhZ3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0aWNrZXJDb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBjb29yZGluYXRlcyA9IChwb3NpdGlvbikgPT4gYCR7cG9zaXRpb24ueH0sJHtwb3NpdGlvbi55fWA7XG52YXIgZGltZW5zaW9uID0gKGRpbWVuc2lvbjIpID0+IGAke2RpbWVuc2lvbjIud2lkdGh9eCR7ZGltZW5zaW9uMi5oZWlnaHR9YDtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9zdWJzY3JpcHRpb25zL2Ftb3VudC50c1xudmFyIHBvc3NpYmxlSW50ZXJ2YWxGcmVxdWVuY2llcyA9IFtcbiAgXCJkYWlseVwiLFxuICBcIndlZWtseVwiLFxuICBcIm1vbnRobHlcIixcbiAgXCJxdWFydGVybHlcIixcbiAgXCJ5ZWFybHlcIlxuXTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZVRlcm1EdXJhdGlvbkluU2Vjb25kcyh0ZXJtKSB7XG4gIHN3aXRjaCAodGVybSkge1xuICAgIGNhc2UgXCJkYWlseVwiOlxuICAgICAgcmV0dXJuIDI0ICogNjAgKiA2MDtcbiAgICBjYXNlIFwid2Vla2x5XCI6XG4gICAgICByZXR1cm4gNyAqIDI0ICogNjAgKiA2MDtcbiAgICBjYXNlIFwibW9udGhseVwiOlxuICAgICAgcmV0dXJuIDMwICogMjQgKiA2MCAqIDYwO1xuICAgIGNhc2UgXCJxdWFydGVybHlcIjpcbiAgICAgIHJldHVybiAzICogMzAgKiAyNCAqIDYwICogNjA7XG4gICAgY2FzZSBcInllYXJseVwiOlxuICAgICAgcmV0dXJuIDM2NSAqIDI0ICogNjAgKiA2MDtcbiAgfVxufVxuZnVuY3Rpb24gbmV3QW1vdW50KGFtb3VudCwgY3VycmVuY3ksIHRlcm0pIHtcbiAgcmV0dXJuIFtcImFtb3VudFwiLCBhbW91bnQudG9TdHJpbmcoKSwgY3VycmVuY3ksIHRlcm1dO1xufVxuZnVuY3Rpb24gcGFyc2VUYWdUb1N1YnNjcmlwdGlvbkFtb3VudCh0YWcpIHtcbiAgY29uc3QgYW1vdW50ID0gTnVtYmVyLnBhcnNlSW50KHRhZ1sxXSk7XG4gIGlmIChOdW1iZXIuaXNOYU4oYW1vdW50KSB8fCBhbW91bnQgPT09IHZvaWQgMCB8fCBhbW91bnQgPT09IG51bGwgfHwgYW1vdW50IDw9IDApIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IGN1cnJlbmN5ID0gdGFnWzJdO1xuICBpZiAoY3VycmVuY3kgPT09IHZvaWQgMCB8fCBjdXJyZW5jeSA9PT0gXCJcIikgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgdGVybSA9IHRhZ1szXTtcbiAgaWYgKHRlcm0gPT09IHZvaWQgMCkgcmV0dXJuIHZvaWQgMDtcbiAgaWYgKCFwb3NzaWJsZUludGVydmFsRnJlcXVlbmNpZXMuaW5jbHVkZXModGVybSkpIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiB7XG4gICAgYW1vdW50LFxuICAgIGN1cnJlbmN5LFxuICAgIHRlcm1cbiAgfTtcbn1cblxuLy8gc3JjL2V2ZW50cy9raW5kcy9zdWJzY3JpcHRpb25zL3RpZXIudHNcbnZhciBOREtTdWJzY3JpcHRpb25UaWVyID0gY2xhc3MgX05ES1N1YnNjcmlwdGlvblRpZXIgZXh0ZW5kcyBOREtBcnRpY2xlIHtcbiAgc3RhdGljIGtpbmQgPSAzNzAwMSAvKiBTdWJzY3JpcHRpb25UaWVyICovO1xuICBzdGF0aWMga2luZHMgPSBbMzcwMDEgLyogU3Vic2NyaXB0aW9uVGllciAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBjb25zdCBrID0gcmF3RXZlbnQ/LmtpbmQgPz8gMzcwMDEgLyogU3Vic2NyaXB0aW9uVGllciAqLztcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPSBrO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IE5ES1N1YnNjcmlwdGlvblRpZXIgZnJvbSBhbiBldmVudFxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICogQHJldHVybnMgTkRLU3Vic2NyaXB0aW9uVGllclxuICAgKi9cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtTdWJzY3JpcHRpb25UaWVyKGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHBlcmtzIGZvciB0aGlzIHRpZXJcbiAgICovXG4gIGdldCBwZXJrcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwZXJrXCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pLmZpbHRlcigocGVyaykgPT4gcGVyayAhPT0gdm9pZCAwKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHBlcmsgdG8gdGhpcyB0aWVyXG4gICAqL1xuICBhZGRQZXJrKHBlcmspIHtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJwZXJrXCIsIHBlcmtdKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYW1vdW50IGZvciB0aGlzIHRpZXJcbiAgICovXG4gIGdldCBhbW91bnRzKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVGFncyhcImFtb3VudFwiKS5tYXAoKHRhZykgPT4gcGFyc2VUYWdUb1N1YnNjcmlwdGlvbkFtb3VudCh0YWcpKS5maWx0ZXIoKGEpID0+IGEgIT09IHZvaWQgMCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gYW1vdW50IHRvIHRoaXMgdGllclxuICAgKiBAcGFyYW0gYW1vdW50IEFtb3VudCBpbiB0aGUgc21hbGxlc3QgdW5pdCBvZiB0aGUgY3VycmVuY3kgKGUuZy4gY2VudHMsIG1zYXRzKVxuICAgKiBAcGFyYW0gY3VycmVuY3kgQ3VycmVuY3kgY29kZS4gVXNlIG1zYXQgZm9yIG1pbGxpc2F0b3NoaXNcbiAgICogQHBhcmFtIHRlcm0gT25lIG9mIGRhaWx5LCB3ZWVrbHksIG1vbnRobHksIHF1YXJ0ZXJseSwgeWVhcmx5XG4gICAqL1xuICBhZGRBbW91bnQoYW1vdW50LCBjdXJyZW5jeSwgdGVybSkge1xuICAgIHRoaXMudGFncy5wdXNoKG5ld0Ftb3VudChhbW91bnQsIGN1cnJlbmN5LCB0ZXJtKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYSByZWxheSB3aGVyZSBjb250ZW50IHJlbGF0ZWQgdG8gdGhpcyB0aWVyIGNhbiBiZSBmb3VuZFxuICAgKiBAcGFyYW0gcmVsYXlVcmwgVVJMIG9mIHRoZSByZWxheVxuICAgKi9cbiAgc2V0IHJlbGF5VXJsKHJlbGF5VXJsKSB7XG4gICAgdGhpcy50YWdzLnB1c2goW1wiclwiLCByZWxheVVybF0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZWxheSBVUkxzIGZvciB0aGlzIHRpZXJcbiAgICovXG4gIGdldCByZWxheVVybHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiclwiKS5tYXAoKHRhZykgPT4gdGFnWzFdKS5maWx0ZXIoKHJlbGF5KSA9PiByZWxheSAhPT0gdm9pZCAwKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgdmVyaWZpZXIgcHVia2V5IGZvciB0aGlzIHRpZXIuIFRoaXMgaXMgdGhlIHB1YmtleSB0aGF0IHdpbGwgZ2VuZXJhdGVcbiAgICogc3Vic2NyaXB0aW9uIHBheW1lbnQgcmVjZWlwdHNcbiAgICovXG4gIGdldCB2ZXJpZmllclB1YmtleSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInBcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZlcmlmaWVyIHB1YmtleSBmb3IgdGhpcyB0aWVyLlxuICAgKi9cbiAgc2V0IHZlcmlmaWVyUHVia2V5KHB1YmtleSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicFwiKTtcbiAgICBpZiAocHVia2V5KSB0aGlzLnRhZ3MucHVzaChbXCJwXCIsIHB1YmtleV0pO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyB0aWVyIGlzIHZhbGlkXG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy50aXRsZSAhPT0gdm9pZCAwICYmIC8vIE11c3QgaGF2ZSBhIHRpdGxlXG4gICAgdGhpcy5hbW91bnRzLmxlbmd0aCA+IDA7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvdmlkZW8udHNcbnZhciBOREtWaWRlbyA9IGNsYXNzIF9OREtWaWRlbyBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGtpbmQgPSAyMSAvKiBWaWRlbyAqLztcbiAgc3RhdGljIGtpbmRzID0gWzM0MjM1IC8qIEhvcml6b250YWxWaWRlbyAqLywgMzQyMzYgLyogVmVydGljYWxWaWRlbyAqLywgMjIgLyogU2hvcnRWaWRlbyAqLywgMjEgLyogVmlkZW8gKi9dO1xuICBfaW1ldGFzO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIE5ES0FydGljbGUgZnJvbSBhbiBleGlzdGluZyBOREtFdmVudC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IE5ES0V2ZW50IHRvIGNyZWF0ZSB0aGUgTkRLQXJ0aWNsZSBmcm9tLlxuICAgKiBAcmV0dXJucyBOREtBcnRpY2xlXG4gICAqL1xuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1ZpZGVvKGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGFydGljbGUgdGl0bGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGFydGljbGUgdGl0bGUgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwidGl0bGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGFydGljbGUgdGl0bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSB0aXRsZSAtIFRoZSB0aXRsZSB0byBzZXQgZm9yIHRoZSBhcnRpY2xlLlxuICAgKi9cbiAgc2V0IHRpdGxlKHRpdGxlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJ0aXRsZVwiKTtcbiAgICBpZiAodGl0bGUpIHRoaXMudGFncy5wdXNoKFtcInRpdGxlXCIsIHRpdGxlXSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGFydGljbGUgdGh1bWJuYWlsLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBhcnRpY2xlIHRodW1ibmFpbCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgdGh1bWJuYWlsKCkge1xuICAgIGxldCB0aHVtYm5haWw7XG4gICAgaWYgKHRoaXMuaW1ldGFzICYmIHRoaXMuaW1ldGFzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRodW1ibmFpbCA9IHRoaXMuaW1ldGFzWzBdLmltYWdlPy5bMF07XG4gICAgfVxuICAgIHJldHVybiB0aHVtYm5haWwgPz8gdGhpcy50YWdWYWx1ZShcInRodW1iXCIpO1xuICB9XG4gIGdldCBpbWV0YXMoKSB7XG4gICAgaWYgKHRoaXMuX2ltZXRhcykgcmV0dXJuIHRoaXMuX2ltZXRhcztcbiAgICB0aGlzLl9pbWV0YXMgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJpbWV0YVwiKS5tYXAobWFwSW1ldGFUYWcpO1xuICAgIHJldHVybiB0aGlzLl9pbWV0YXM7XG4gIH1cbiAgc2V0IGltZXRhcyh0YWdzKSB7XG4gICAgdGhpcy5faW1ldGFzID0gdGFncztcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSAhPT0gXCJpbWV0YVwiKTtcbiAgICB0aGlzLnRhZ3MucHVzaCguLi50YWdzLm1hcChpbWV0YVRhZ1RvVGFnKSk7XG4gIH1cbiAgZ2V0IHVybCgpIHtcbiAgICBpZiAodGhpcy5pbWV0YXMgJiYgdGhpcy5pbWV0YXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW1ldGFzWzBdLnVybDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ1cmxcIik7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGFydGljbGUncyBwdWJsaWNhdGlvbiB0aW1lc3RhbXAuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9IC0gVGhlIFVuaXggdGltZXN0YW1wIG9mIHdoZW4gdGhlIGFydGljbGUgd2FzIHB1Ymxpc2hlZCBvciB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgcHVibGlzaGVkX2F0KCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnVmFsdWUoXCJwdWJsaXNoZWRfYXRcIik7XG4gICAgaWYgKHRhZykge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludCh0YWcpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgY29udGVudCB0YWdzIGZvciB0aGUgYXJ0aWNsZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZmlyc3QgY2hlY2tzIGFuZCBzZXRzIHRoZSBwdWJsaWNhdGlvbiBkYXRlIGlmIG5vdCBhdmFpbGFibGUsXG4gICAqIGFuZCB0aGVuIGdlbmVyYXRlcyBjb250ZW50IHRhZ3MgYmFzZWQgb24gdGhlIGJhc2UgTkRLRXZlbnQgY2xhc3MuXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb250ZW50VGFnfSAtIFRoZSBnZW5lcmF0ZWQgY29udGVudCB0YWdzLlxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVUYWdzKCkge1xuICAgIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICAgIGlmICghdGhpcy5raW5kKSB7XG4gICAgICBpZiAodGhpcy5pbWV0YXM/LlswXT8uZGltKSB7XG4gICAgICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuaW1ldGFzWzBdLmRpbS5zcGxpdChcInhcIik7XG4gICAgICAgIGNvbnN0IGlzUG9ydHJhaXQgPSB3aWR0aCAmJiBoZWlnaHQgJiYgTnVtYmVyLnBhcnNlSW50KHdpZHRoKSA8IE51bWJlci5wYXJzZUludChoZWlnaHQpO1xuICAgICAgICBjb25zdCBpc1Nob3J0ID0gdGhpcy5kdXJhdGlvbiAmJiB0aGlzLmR1cmF0aW9uIDwgMTIwO1xuICAgICAgICBpZiAoaXNTaG9ydCAmJiBpc1BvcnRyYWl0KSB0aGlzLmtpbmQgPSAyMiAvKiBTaG9ydFZpZGVvICovO1xuICAgICAgICBlbHNlIHRoaXMua2luZCA9IDIxIC8qIFZpZGVvICovO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZ2VuZXJhdGVUYWdzKCk7XG4gIH1cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnVmFsdWUoXCJkdXJhdGlvblwiKTtcbiAgICBpZiAodGFnKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHRhZyk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIHZpZGVvJ3MgZHVyYXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGR1cmF0aW9uIC0gVGhlIGR1cmF0aW9uIHRvIHNldCBmb3IgdGhlIHZpZGVvIChpbiBzZWNvbmRzKVxuICAgKi9cbiAgc2V0IGR1cmF0aW9uKGR1cikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZHVyYXRpb25cIik7XG4gICAgaWYgKGR1ciAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJkdXJhdGlvblwiLCBNYXRoLmZsb29yKGR1cikudG9TdHJpbmcoKV0pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy93aWtpLnRzXG52YXIgTkRLV2lraSA9IGNsYXNzIF9OREtXaWtpIGV4dGVuZHMgTkRLQXJ0aWNsZSB7XG4gIHN0YXRpYyBraW5kID0gMzA4MTggLyogV2lraSAqLztcbiAgc3RhdGljIGtpbmRzID0gWzMwODE4IC8qIFdpa2kgKi9dO1xuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1dpa2koZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICBnZXQgaXNEZWZlcmVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc1RhZyhcImFcIiwgXCJkZWZlclwiKTtcbiAgfVxuICBnZXQgZGVmZXJlZElkKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiYVwiLCBcImRlZmVyXCIpO1xuICB9XG4gIC8qKlxuICAgKiBEZWZlcnMgdGhlIGF1dGhvcidzIHdpa2kgZXZlbnQgdG8gYW5vdGhlciB3aWtpIGV2ZW50LlxuICAgKlxuICAgKiBXaWtpLWV2ZW50cyBjYW4gdGFnIG90aGVyIHdpa2ktZXZlbnRzIHdpdGggYSBgZGVmZXJgIG1hcmtlciB0byBpbmRpY2F0ZSB0aGF0IGl0IGNvbnNpZGVycyBzb21lb25lIGVsc2UncyBlbnRyeSBhcyBhIFwiYmV0dGVyXCIgdmVyc2lvbiBvZiBpdHNlbGYuIElmIHVzaW5nIGEgYGRlZmVyYCBtYXJrZXIgYm90aCBgYWAgYW5kIGBlYCB0YWdzIFNIT1VMRCBiZSB1c2VkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBteVdpa2kuZGVmZXIgPSBiZXR0ZXJXaWtpRW50cnlPblRoZVNhbWVUb3BpYztcbiAgICogbXlXaWtpLnB1Ymxpc2hSZXBsYWNlYWJsZSgpXG4gICAqL1xuICBzZXQgZGVmZXIoZGVmZXJlZFRvKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhXCIsIFwiZGVmZXJcIik7XG4gICAgdGhpcy50YWcoZGVmZXJlZFRvLCBcImRlZmVyXCIpO1xuICB9XG59O1xudmFyIE5ES1dpa2lNZXJnZVJlcXVlc3QgPSBjbGFzcyBfTkRLV2lraU1lcmdlUmVxdWVzdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGtpbmQgPSA4MTggLyogV2lraU1lcmdlUmVxdWVzdCAqLztcbiAgc3RhdGljIGtpbmRzID0gWzgxOCAvKiBXaWtpTWVyZ2VSZXF1ZXN0ICovXTtcbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtXaWtpTWVyZ2VSZXF1ZXN0KGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB0YXJnZXQgSUQgKDxraW5kOnB1YmtleTpkLXRhZz4pIG9mIHRoZSB3aWtpIGV2ZW50IHRvIG1lcmdlIGludG8uXG4gICAqL1xuICBnZXQgdGFyZ2V0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJhXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0YXJnZXQgSUQgKDxraW5kOnB1YmtleTpkLXRhZz4pIG9mIHRoZSB3aWtpIGV2ZW50IHRvIG1lcmdlIGludG8uXG4gICAqL1xuICBzZXQgdGFyZ2V0KHRhcmdldEV2ZW50KSB7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImFcIikgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiB0YWdbM10gIT09IFwic291cmNlXCIpIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIHRoaXMudGFnKHRhcmdldEV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogVGhlIHNvdXJjZSBJRCBvZiB0aGUgd2lraSBldmVudCB0byBtZXJnZSBmcm9tLlxuICAgKi9cbiAgZ2V0IHNvdXJjZUlkKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZVwiLCBcInNvdXJjZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZXZlbnQgd2UgYXJlIGFza2luZyB0byBnZXQgbWVyZ2VkIGludG8gdGhlIHRhcmdldC5cbiAgICovXG4gIHNldCBzb3VyY2Uoc291cmNlRXZlbnQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImVcIiwgXCJzb3VyY2VcIik7XG4gICAgdGhpcy50YWcoc291cmNlRXZlbnQsIFwic291cmNlXCIsIGZhbHNlLCBcImVcIik7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMvd3JhcC50c1xuZnVuY3Rpb24gd3JhcEV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IGV2ZW50V3JhcHBpbmdNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IGtsYXNzMiBvZiBbXG4gICAgTkRLSW1hZ2UsXG4gICAgTkRLVmlkZW8sXG4gICAgTkRLQ2FzaHVNaW50TGlzdCxcbiAgICBOREtBcnRpY2xlLFxuICAgIE5ES0hpZ2hsaWdodCxcbiAgICBOREtXaWtpLFxuICAgIE5ES051dHphcCxcbiAgICBOREtTaW1wbGVHcm91cE1lbWJlckxpc3QsXG4gICAgTkRLU2ltcGxlR3JvdXBNZXRhZGF0YSxcbiAgICBOREtTdWJzY3JpcHRpb25UaWVyLFxuICAgIE5ES0Nhc2h1VG9rZW4sXG4gICAgTkRLTGlzdCxcbiAgICBOREtTdG9yeVxuICBdKSB7XG4gICAgZm9yIChjb25zdCBraW5kIG9mIGtsYXNzMi5raW5kcykge1xuICAgICAgZXZlbnRXcmFwcGluZ01hcC5zZXQoa2luZCwga2xhc3MyKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qga2xhc3MgPSBldmVudFdyYXBwaW5nTWFwLmdldChldmVudC5raW5kKTtcbiAgaWYgKGtsYXNzKSByZXR1cm4ga2xhc3MuZnJvbShldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLy8gc3JjL3N1YnNjcmlwdGlvbi91dGlscy50c1xuaW1wb3J0IHsgbmlwMTkgYXMgbmlwMTk0IH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG52YXIgTUFYX1NVQklEX0xFTkdUSCA9IDIwO1xuZnVuY3Rpb24gcXVlcnlGdWxseUZpbGxlZChzdWJzY3JpcHRpb24pIHtcbiAgaWYgKGZpbHRlckluY2x1ZGVzSWRzKHN1YnNjcmlwdGlvbi5maWx0ZXIpKSB7XG4gICAgaWYgKHJlc3VsdEhhc0FsbFJlcXVlc3RlZElkcyhzdWJzY3JpcHRpb24pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29tcGFyZUZpbHRlcihmaWx0ZXIxLCBmaWx0ZXIyKSB7XG4gIGlmIChPYmplY3Qua2V5cyhmaWx0ZXIxKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGZpbHRlcjIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmaWx0ZXIxKSkge1xuICAgIGNvbnN0IHZhbHVlc0luRmlsdGVyMiA9IGZpbHRlcjJba2V5XTtcbiAgICBpZiAoIXZhbHVlc0luRmlsdGVyMikgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHZhbHVlc0luRmlsdGVyMikpIHtcbiAgICAgIGNvbnN0IHYgPSB2YWx1ZTtcbiAgICAgIGZvciAoY29uc3QgdmFsdWVJbkZpbHRlcjIgb2YgdmFsdWVzSW5GaWx0ZXIyKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHZhbHVlSW5GaWx0ZXIyO1xuICAgICAgICBpZiAoIXYuaW5jbHVkZXModmFsKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWVzSW5GaWx0ZXIyICE9PSB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGZpbHRlckluY2x1ZGVzSWRzKGZpbHRlcikge1xuICByZXR1cm4gISFmaWx0ZXIuaWRzO1xufVxuZnVuY3Rpb24gcmVzdWx0SGFzQWxsUmVxdWVzdGVkSWRzKHN1YnNjcmlwdGlvbikge1xuICBjb25zdCBpZHMgPSBzdWJzY3JpcHRpb24uZmlsdGVyLmlkcztcbiAgcmV0dXJuICEhaWRzICYmIGlkcy5sZW5ndGggPT09IHN1YnNjcmlwdGlvbi5ldmVudEZpcnN0U2Vlbi5zaXplO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVTdWJJZChzdWJzY3JpcHRpb25zLCBmaWx0ZXJzKSB7XG4gIGNvbnN0IHN1YklkcyA9IHN1YnNjcmlwdGlvbnMubWFwKChzdWIpID0+IHN1Yi5zdWJJZCkuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBzdWJJZFBhcnRzID0gW107XG4gIGNvbnN0IGZpbHRlck5vbktpbmRLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgZmlsdGVyS2luZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBpZiAoc3ViSWRzLmxlbmd0aCA+IDApIHtcbiAgICBzdWJJZFBhcnRzLnB1c2goQXJyYXkuZnJvbShuZXcgU2V0KHN1YklkcykpLmpvaW4oXCIsXCIpKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBmaWx0ZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhmaWx0ZXIpKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwia2luZHNcIikge1xuICAgICAgICAgIGZpbHRlci5raW5kcz8uZm9yRWFjaCgoaykgPT4gZmlsdGVyS2luZHMuYWRkKGspKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWx0ZXJOb25LaW5kS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmlsdGVyS2luZHMuc2l6ZSA+IDApIHtcbiAgICAgIHN1YklkUGFydHMucHVzaChga2luZHM6JHtBcnJheS5mcm9tKGZpbHRlcktpbmRzKS5qb2luKFwiLFwiKX1gKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlck5vbktpbmRLZXlzLnNpemUgPiAwKSB7XG4gICAgICBzdWJJZFBhcnRzLnB1c2goQXJyYXkuZnJvbShmaWx0ZXJOb25LaW5kS2V5cykuam9pbihcIixcIikpO1xuICAgIH1cbiAgfVxuICBsZXQgc3ViSWQgPSBzdWJJZFBhcnRzLmpvaW4oXCItXCIpO1xuICBpZiAoc3ViSWQubGVuZ3RoID4gTUFYX1NVQklEX0xFTkdUSCkgc3ViSWQgPSBzdWJJZC5zdWJzdHJpbmcoMCwgTUFYX1NVQklEX0xFTkdUSCk7XG4gIHN1YklkICs9IGAtJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA5OTkpLnRvU3RyaW5nKCl9YDtcbiAgcmV0dXJuIHN1YklkO1xufVxuZnVuY3Rpb24gZmlsdGVyRm9yRXZlbnRzVGFnZ2luZ0lkKGlkKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IG5pcDE5NC5kZWNvZGUoaWQpO1xuICAgIHN3aXRjaCAoZGVjb2RlZC50eXBlKSB7XG4gICAgICBjYXNlIFwibmFkZHJcIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBcIiNhXCI6IFtgJHtkZWNvZGVkLmRhdGEua2luZH06JHtkZWNvZGVkLmRhdGEucHVia2V5fToke2RlY29kZWQuZGF0YS5pZGVudGlmaWVyfWBdXG4gICAgICAgIH07XG4gICAgICBjYXNlIFwibmV2ZW50XCI6XG4gICAgICAgIHJldHVybiB7IFwiI2VcIjogW2RlY29kZWQuZGF0YS5pZF0gfTtcbiAgICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICAgIHJldHVybiB7IFwiI2VcIjogW2RlY29kZWQuZGF0YV0gfTtcbiAgICAgIGNhc2UgXCJucHJvZmlsZVwiOlxuICAgICAgICByZXR1cm4geyBcIiNwXCI6IFtkZWNvZGVkLmRhdGEucHVia2V5XSB9O1xuICAgICAgY2FzZSBcIm5wdWJcIjpcbiAgICAgICAgcmV0dXJuIHsgXCIjcFwiOiBbZGVjb2RlZC5kYXRhXSB9O1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbHRlckFuZFJlbGF5U2V0RnJvbUJlY2gzMihiZWNoZTIsIG5kaykge1xuICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJGcm9tSWQoYmVjaGUyKTtcbiAgY29uc3QgcmVsYXlzID0gcmVsYXlzRnJvbUJlY2gzMihiZWNoZTIsIG5kayk7XG4gIGlmIChyZWxheXMubGVuZ3RoID09PSAwKSByZXR1cm4geyBmaWx0ZXIgfTtcbiAgcmV0dXJuIHtcbiAgICBmaWx0ZXIsXG4gICAgcmVsYXlTZXQ6IG5ldyBOREtSZWxheVNldChuZXcgU2V0KHJlbGF5cyksIG5kaylcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlckZyb21JZChpZCkge1xuICBsZXQgZGVjb2RlZDtcbiAgaWYgKGlkLm1hdGNoKE5JUDMzX0FfUkVHRVgpKSB7XG4gICAgY29uc3QgW2tpbmQsIHB1YmtleSwgaWRlbnRpZmllcl0gPSBpZC5zcGxpdChcIjpcIik7XG4gICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgYXV0aG9yczogW3B1YmtleV0sXG4gICAgICBraW5kczogW051bWJlci5wYXJzZUludChraW5kKV1cbiAgICB9O1xuICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICBmaWx0ZXJbXCIjZFwiXSA9IFtpZGVudGlmaWVyXTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcjtcbiAgfVxuICBpZiAoaWQubWF0Y2goQkVDSDMyX1JFR0VYKSkge1xuICAgIHRyeSB7XG4gICAgICBkZWNvZGVkID0gbmlwMTk0LmRlY29kZShpZCk7XG4gICAgICBzd2l0Y2ggKGRlY29kZWQudHlwZSkge1xuICAgICAgICBjYXNlIFwibmV2ZW50XCI6IHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB7IGlkczogW2RlY29kZWQuZGF0YS5pZF0gfTtcbiAgICAgICAgICBpZiAoZGVjb2RlZC5kYXRhLmF1dGhvcikgZmlsdGVyLmF1dGhvcnMgPSBbZGVjb2RlZC5kYXRhLmF1dGhvcl07XG4gICAgICAgICAgaWYgKGRlY29kZWQuZGF0YS5raW5kKSBmaWx0ZXIua2luZHMgPSBbZGVjb2RlZC5kYXRhLmtpbmRdO1xuICAgICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm5vdGVcIjpcbiAgICAgICAgICByZXR1cm4geyBpZHM6IFtkZWNvZGVkLmRhdGFdIH07XG4gICAgICAgIGNhc2UgXCJuYWRkclwiOiB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICAgICAgYXV0aG9yczogW2RlY29kZWQuZGF0YS5wdWJrZXldLFxuICAgICAgICAgICAga2luZHM6IFtkZWNvZGVkLmRhdGEua2luZF1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChkZWNvZGVkLmRhdGEuaWRlbnRpZmllcikgZmlsdGVyW1wiI2RcIl0gPSBbZGVjb2RlZC5kYXRhLmlkZW50aWZpZXJdO1xuICAgICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGVjb2RpbmdcIiwgaWQsIGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBpZHM6IFtpZF0gfTtcbn1cbmZ1bmN0aW9uIGlzTmlwMzNBVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLm1hdGNoKE5JUDMzX0FfUkVHRVgpICE9PSBudWxsO1xufVxudmFyIE5JUDMzX0FfUkVHRVggPSAvXihcXGQrKTooWzAtOUEtRmEtZl0rKSg/OjooLiopKT8kLztcbnZhciBCRUNIMzJfUkVHRVggPSAvXm4oZXZlbnR8b3RlfHByb2ZpbGV8cHVifGFkZHIpMVtcXGRcXHddKyQvO1xuZnVuY3Rpb24gcmVsYXlzRnJvbUJlY2gzMihiZWNoMzIyLCBuZGspIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkZWNvZGVkID0gbmlwMTk0LmRlY29kZShiZWNoMzIyKTtcbiAgICBpZiAoW1wibmFkZHJcIiwgXCJuZXZlbnRcIl0uaW5jbHVkZXMoZGVjb2RlZD8udHlwZSkpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBkZWNvZGVkLmRhdGE7XG4gICAgICBpZiAoZGF0YT8ucmVsYXlzKSB7XG4gICAgICAgIHJldHVybiBkYXRhLnJlbGF5cy5tYXAoKHIpID0+IG5ldyBOREtSZWxheShyLCBuZGsucmVsYXlBdXRoRGVmYXVsdFBvbGljeSwgbmRrKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChfZSkge1xuICB9XG4gIHJldHVybiBbXTtcbn1cblxuLy8gc3JjL3N1YnNjcmlwdGlvbi9pbmRleC50c1xudmFyIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UgPSAvKiBAX19QVVJFX18gKi8gKChOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlMikgPT4ge1xuICBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlMltcIk9OTFlfQ0FDSEVcIl0gPSBcIk9OTFlfQ0FDSEVcIjtcbiAgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTJbXCJDQUNIRV9GSVJTVFwiXSA9IFwiQ0FDSEVfRklSU1RcIjtcbiAgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTJbXCJQQVJBTExFTFwiXSA9IFwiUEFSQUxMRUxcIjtcbiAgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTJbXCJPTkxZX1JFTEFZXCJdID0gXCJPTkxZX1JFTEFZXCI7XG4gIHJldHVybiBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlMjtcbn0pKE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UgfHwge30pO1xudmFyIGRlZmF1bHRPcHRzID0ge1xuICBjbG9zZU9uRW9zZTogZmFsc2UsXG4gIGNhY2hlVXNhZ2U6IFwiQ0FDSEVfRklSU1RcIiAvKiBDQUNIRV9GSVJTVCAqLyxcbiAgZG9udFNhdmVUb0NhY2hlOiBmYWxzZSxcbiAgZ3JvdXBhYmxlOiB0cnVlLFxuICBncm91cGFibGVEZWxheTogMTAwLFxuICBncm91cGFibGVEZWxheVR5cGU6IFwiYXQtbW9zdFwiLFxuICBjYWNoZVVuY29uc3RyYWluRmlsdGVyOiBbXCJsaW1pdFwiLCBcInNpbmNlXCIsIFwidW50aWxcIl1cbn07XG52YXIgTkRLU3Vic2NyaXB0aW9uID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXI0IHtcbiAgc3ViSWQ7XG4gIGZpbHRlcnM7XG4gIG9wdHM7XG4gIHBvb2w7XG4gIHNraXBWZXJpZmljYXRpb24gPSBmYWxzZTtcbiAgc2tpcFZhbGlkYXRpb24gPSBmYWxzZTtcbiAgLyoqXG4gICAqIFRyYWNrcyB0aGUgZmlsdGVycyBhcyB0aGV5IGFyZSBleGVjdXRlZCBvbiBlYWNoIHJlbGF5XG4gICAqL1xuICByZWxheUZpbHRlcnM7XG4gIHJlbGF5U2V0O1xuICBuZGs7XG4gIGRlYnVnO1xuICAvKipcbiAgICogRXZlbnRzIHRoYXQgaGF2ZSBiZWVuIHNlZW4gYnkgdGhlIHN1YnNjcmlwdGlvbiwgd2l0aCB0aGUgdGltZSB0aGV5IHdlcmUgZmlyc3Qgc2Vlbi5cbiAgICovXG4gIGV2ZW50Rmlyc3RTZWVuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLyoqXG4gICAqIFJlbGF5cyB0aGF0IGhhdmUgc2VudCBhbiBFT1NFLlxuICAgKi9cbiAgZW9zZXNTZWVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgLyoqXG4gICAqIFRoZSB0aW1lIHRoZSBsYXN0IGV2ZW50IHdhcyByZWNlaXZlZCBieSB0aGUgc3Vic2NyaXB0aW9uLlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHdoZW4gRU9TRSBzaG91bGQgYmUgZW1pdHRlZC5cbiAgICovXG4gIGxhc3RFdmVudFJlY2VpdmVkQXQ7XG4gIC8qKlxuICAgKiBUaGUgbW9zdCByZWNlbnQgZXZlbnQgdGltZXN0YW1wIGZyb20gY2FjaGUgcmVzdWx0cy5cbiAgICogVGhpcyBpcyB1c2VkIGZvciBhZGRTaW5jZUZyb21DYWNoZSBmdW5jdGlvbmFsaXR5LlxuICAgKi9cbiAgbW9zdFJlY2VudENhY2hlRXZlbnRUaW1lc3RhbXA7XG4gIGludGVybmFsSWQ7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdWJzY3JpcHRpb24gc2hvdWxkIGNsb3NlIHdoZW4gYWxsIHJlbGF5cyBoYXZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgc3RyZWFtLlxuICAgKi9cbiAgY2xvc2VPbkVvc2U7XG4gIC8qKlxuICAgKiBQb29sIG1vbml0b3IgY2FsbGJhY2tcbiAgICovXG4gIHBvb2xNb25pdG9yO1xuICBza2lwT3B0aW1pc3RpY1B1Ymxpc2hFdmVudCA9IGZhbHNlO1xuICAvKipcbiAgICogRmlsdGVycyB0byByZW1vdmUgd2hlbiBxdWVyeWluZyB0aGUgY2FjaGUuXG4gICAqL1xuICBjYWNoZVVuY29uc3RyYWluRmlsdGVyO1xuICBjb25zdHJ1Y3RvcihuZGssIGZpbHRlcnMsIG9wdHMsIHN1YklkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRzLCAuLi5vcHRzIHx8IHt9IH07XG4gICAgdGhpcy5wb29sID0gdGhpcy5vcHRzLnBvb2wgfHwgbmRrLnBvb2w7XG4gICAgdGhpcy5maWx0ZXJzID0gQXJyYXkuaXNBcnJheShmaWx0ZXJzKSA/IGZpbHRlcnMgOiBbZmlsdGVyc107XG4gICAgdGhpcy5zdWJJZCA9IHN1YklkIHx8IHRoaXMub3B0cy5zdWJJZDtcbiAgICB0aGlzLmludGVybmFsSWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyk7XG4gICAgdGhpcy5kZWJ1ZyA9IG5kay5kZWJ1Zy5leHRlbmQoYHN1YnNjcmlwdGlvblske3RoaXMub3B0cy5zdWJJZCA/PyB0aGlzLmludGVybmFsSWR9XWApO1xuICAgIGlmICh0aGlzLm9wdHMucmVsYXlTZXQpIHtcbiAgICAgIHRoaXMucmVsYXlTZXQgPSB0aGlzLm9wdHMucmVsYXlTZXQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdHMucmVsYXlVcmxzKSB7XG4gICAgICB0aGlzLnJlbGF5U2V0ID0gTkRLUmVsYXlTZXQuZnJvbVJlbGF5VXJscyh0aGlzLm9wdHMucmVsYXlVcmxzLCB0aGlzLm5kayk7XG4gICAgfVxuICAgIHRoaXMuc2tpcFZlcmlmaWNhdGlvbiA9IHRoaXMub3B0cy5za2lwVmVyaWZpY2F0aW9uIHx8IGZhbHNlO1xuICAgIHRoaXMuc2tpcFZhbGlkYXRpb24gPSB0aGlzLm9wdHMuc2tpcFZhbGlkYXRpb24gfHwgZmFsc2U7XG4gICAgdGhpcy5jbG9zZU9uRW9zZSA9IHRoaXMub3B0cy5jbG9zZU9uRW9zZSB8fCBmYWxzZTtcbiAgICB0aGlzLnNraXBPcHRpbWlzdGljUHVibGlzaEV2ZW50ID0gdGhpcy5vcHRzLnNraXBPcHRpbWlzdGljUHVibGlzaEV2ZW50IHx8IGZhbHNlO1xuICAgIHRoaXMuY2FjaGVVbmNvbnN0cmFpbkZpbHRlciA9IHRoaXMub3B0cy5jYWNoZVVuY29uc3RyYWluRmlsdGVyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZWxheXMgdGhhdCBoYXZlIG5vdCB5ZXQgc2VudCBhbiBFT1NFLlxuICAgKi9cbiAgcmVsYXlzTWlzc2luZ0Vvc2UoKSB7XG4gICAgaWYgKCF0aGlzLnJlbGF5RmlsdGVycykgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHJlbGF5c01pc3NpbmdFb3NlID0gQXJyYXkuZnJvbSh0aGlzLnJlbGF5RmlsdGVycz8ua2V5cygpKS5maWx0ZXIoXG4gICAgICAodXJsKSA9PiAhdGhpcy5lb3Nlc1NlZW4uaGFzKHRoaXMucG9vbC5nZXRSZWxheSh1cmwsIGZhbHNlLCBmYWxzZSkpXG4gICAgKTtcbiAgICByZXR1cm4gcmVsYXlzTWlzc2luZ0Vvc2U7XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGFjY2VzcyB0byB0aGUgZmlyc3QgZmlsdGVyIG9mIHRoZSBzdWJzY3JpcHRpb24gZm9yXG4gICAqIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgKi9cbiAgZ2V0IGZpbHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXJzWzBdO1xuICB9XG4gIGdldCBncm91cGFibGVEZWxheSgpIHtcbiAgICBpZiAoIXRoaXMuaXNHcm91cGFibGUoKSkgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gdGhpcy5vcHRzPy5ncm91cGFibGVEZWxheTtcbiAgfVxuICBnZXQgZ3JvdXBhYmxlRGVsYXlUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLm9wdHM/Lmdyb3VwYWJsZURlbGF5VHlwZSB8fCBcImF0LW1vc3RcIjtcbiAgfVxuICBpc0dyb3VwYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRzPy5ncm91cGFibGUgfHwgZmFsc2U7XG4gIH1cbiAgc2hvdWxkUXVlcnlDYWNoZSgpIHtcbiAgICBpZiAodGhpcy5vcHRzLmFkZFNpbmNlRnJvbUNhY2hlKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5vcHRzPy5jYWNoZVVzYWdlID09PSBcIk9OTFlfUkVMQVlcIiAvKiBPTkxZX1JFTEFZICovKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgaGFzTm9uRXBoZW1lcmFsS2luZCA9IHRoaXMuZmlsdGVycy5zb21lKChmKSA9PiBmLmtpbmRzPy5zb21lKChrKSA9PiBraW5kSXNFcGhlbWVyYWwoaykpKTtcbiAgICBpZiAoaGFzTm9uRXBoZW1lcmFsS2luZCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2hvdWxkUXVlcnlSZWxheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0cz8uY2FjaGVVc2FnZSAhPT0gXCJPTkxZX0NBQ0hFXCIgLyogT05MWV9DQUNIRSAqLztcbiAgfVxuICBzaG91bGRXYWl0Rm9yQ2FjaGUoKSB7XG4gICAgaWYgKHRoaXMub3B0cy5hZGRTaW5jZUZyb21DYWNoZSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIChcbiAgICAgIC8vIE11c3Qgd2FudCB0byBjbG9zZSBvbiBFT1NFOyBzdWJzY3JpcHRpb25zXG4gICAgICAvLyB0aGF0IHdhbnQgdG8gcmVjZWl2ZSBmdXJ0aGVyIHVwZGF0ZXMgbXVzdFxuICAgICAgLy8gYWx3YXlzIGhpdCB0aGUgcmVsYXlcbiAgICAgICEhdGhpcy5vcHRzLmNsb3NlT25Fb3NlICYmIC8vIENhY2hlIGFkYXB0ZXIgbXVzdCBjbGFpbSB0byBiZSBmYXN0XG4gICAgICAhIXRoaXMubmRrLmNhY2hlQWRhcHRlcj8ubG9ja2luZyAmJiAvLyBJZiBleHBsaWNpdGx5IHRvbGQgdG8gcnVuIGluIHBhcmFsbGVsLCB0aGVuXG4gICAgICAvLyB3ZSBzaG91bGQgbm90IHdhaXQgZm9yIHRoZSBjYWNoZVxuICAgICAgdGhpcy5vcHRzLmNhY2hlVXNhZ2UgIT09IFwiUEFSQUxMRUxcIiAvKiBQQVJBTExFTCAqL1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBzdWJzY3JpcHRpb24uIFRoaXMgaXMgdGhlIG1haW4gbWV0aG9kIHRoYXQgc2hvdWxkIGJlIGNhbGxlZFxuICAgKiBhZnRlciBjcmVhdGluZyBhIHN1YnNjcmlwdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGVtaXRDYWNoZWRFdmVudHMgLSBXaGV0aGVyIHRvIGVtaXQgZXZlbnRzIGNvbWluZyBmcm9tIGEgc3luY2hyb25vdXMgY2FjaGVcbiAgICpcbiAgICogV2hlbiB1c2luZyBhIHN5bmNocm9ub3VzIGNhY2hlLCB0aGUgZXZlbnRzIHdpbGwgYmUgcmV0dXJuZWQgaW1tZWRpYXRlbHlcbiAgICogYnkgdGhpcyBmdW5jdGlvbi4gSWYgeW91IHdpbGwgdXNlIHRob3NlIHJldHVybmVkIGV2ZW50cywgeW91IHNob3VsZFxuICAgKiBzZXQgZW1pdENhY2hlZEV2ZW50cyB0byBmYWxzZSB0byBwcmV2ZW50IHNlZWluZyB0aGVtIGFzIGR1cGxpY2F0ZSBldmVudHMuXG4gICAqL1xuICBzdGFydChlbWl0Q2FjaGVkRXZlbnRzID0gdHJ1ZSkge1xuICAgIGxldCBjYWNoZVJlc3VsdDtcbiAgICBjb25zdCB1cGRhdGVTdGF0ZUZyb21DYWNoZVJlc3VsdHMgPSAoZXZlbnRzKSA9PiB7XG4gICAgICBpZiAoZW1pdENhY2hlZEV2ZW50cykge1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICAgIGlmICghdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCB8fCBldmVudC5jcmVhdGVkX2F0ID4gdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCkge1xuICAgICAgICAgICAgdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCA9IGV2ZW50LmNyZWF0ZWRfYXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZXZlbnRSZWNlaXZlZChldmVudCwgdm9pZCAwLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlUmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLm1vc3RSZWNlbnRDYWNoZUV2ZW50VGltZXN0YW1wIHx8IGV2ZW50LmNyZWF0ZWRfYXQgPiB0aGlzLm1vc3RSZWNlbnRDYWNoZUV2ZW50VGltZXN0YW1wKSB7XG4gICAgICAgICAgICB0aGlzLm1vc3RSZWNlbnRDYWNoZUV2ZW50VGltZXN0YW1wID0gZXZlbnQuY3JlYXRlZF9hdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXZlbnQubmRrID0gdGhpcy5uZGs7XG4gICAgICAgICAgY29uc3QgZSA9IHRoaXMub3B0cy53cmFwID8gd3JhcEV2ZW50KGV2ZW50KSA6IGV2ZW50O1xuICAgICAgICAgIGlmICghZSkgYnJlYWs7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBlLnRoZW4oKHdyYXBwZWRFdmVudCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudChmYWxzZSwgd3JhcHBlZEV2ZW50LCB2b2lkIDAsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZXZlbnRGaXJzdFNlZW4uc2V0KGUuaWQsIERhdGUubm93KCkpO1xuICAgICAgICAgIGNhY2hlUmVzdWx0LnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxvYWRGcm9tUmVsYXlzID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc2hvdWxkUXVlcnlSZWxheXMoKSkge1xuICAgICAgICB0aGlzLnN0YXJ0V2l0aFJlbGF5cygpO1xuICAgICAgICB0aGlzLnN0YXJ0UG9vbE1vbml0b3IoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdChcImVvc2VcIiwgdGhpcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodGhpcy5zaG91bGRRdWVyeUNhY2hlKCkpIHtcbiAgICAgIGNhY2hlUmVzdWx0ID0gdGhpcy5zdGFydFdpdGhDYWNoZSgpO1xuICAgICAgaWYgKGNhY2hlUmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRXYWl0Rm9yQ2FjaGUoKSkge1xuICAgICAgICAgIGNhY2hlUmVzdWx0LnRoZW4oKGV2ZW50cykgPT4ge1xuICAgICAgICAgICAgdXBkYXRlU3RhdGVGcm9tQ2FjaGVSZXN1bHRzKGV2ZW50cyk7XG4gICAgICAgICAgICBpZiAocXVlcnlGdWxseUZpbGxlZCh0aGlzKSkge1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlb3NlXCIsIHRoaXMpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2FkRnJvbVJlbGF5cygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlUmVzdWx0LnRoZW4oKGV2ZW50cykgPT4ge1xuICAgICAgICAgIHVwZGF0ZVN0YXRlRnJvbUNhY2hlUmVzdWx0cyhldmVudHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgbG9hZEZyb21SZWxheXMoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB1cGRhdGVTdGF0ZUZyb21DYWNoZVJlc3VsdHMoY2FjaGVSZXN1bHQpO1xuICAgICAgaWYgKHF1ZXJ5RnVsbHlGaWxsZWQodGhpcykpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZW9zZVwiLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRGcm9tUmVsYXlzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGVSZXN1bHQ7XG4gICAgfVxuICAgIGxvYWRGcm9tUmVsYXlzKCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFdlIHdhbnQgdG8gbW9uaXRvciBmb3IgbmV3IHJlbGF5cyB0aGF0IGFyZSBjb21pbmcgb25saW5lLCBpbiBjYXNlXG4gICAqIHRoZXkgc2hvdWxkIGJlIHBhcnQgb2YgdGhpcyBzdWJzY3JpcHRpb24uXG4gICAqL1xuICBzdGFydFBvb2xNb25pdG9yKCkge1xuICAgIGNvbnN0IF9kID0gdGhpcy5kZWJ1Zy5leHRlbmQoXCJwb29sLW1vbml0b3JcIik7XG4gICAgdGhpcy5wb29sTW9uaXRvciA9IChyZWxheSkgPT4ge1xuICAgICAgaWYgKHRoaXMucmVsYXlGaWx0ZXJzPy5oYXMocmVsYXkudXJsKSkgcmV0dXJuO1xuICAgICAgY29uc3QgY2FsYyA9IGNhbGN1bGF0ZVJlbGF5U2V0c0Zyb21GaWx0ZXJzKHRoaXMubmRrLCB0aGlzLmZpbHRlcnMsIHRoaXMucG9vbCk7XG4gICAgICBpZiAoY2FsYy5nZXQocmVsYXkudXJsKSkge1xuICAgICAgICB0aGlzLnJlbGF5RmlsdGVycz8uc2V0KHJlbGF5LnVybCwgdGhpcy5maWx0ZXJzKTtcbiAgICAgICAgcmVsYXkuc3Vic2NyaWJlKHRoaXMsIHRoaXMuZmlsdGVycyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnBvb2wub24oXCJyZWxheTpjb25uZWN0XCIsIHRoaXMucG9vbE1vbml0b3IpO1xuICB9XG4gIG9uU3RvcHBlZDtcbiAgc3RvcCgpIHtcbiAgICB0aGlzLmVtaXQoXCJjbG9zZVwiLCB0aGlzKTtcbiAgICB0aGlzLnBvb2xNb25pdG9yICYmIHRoaXMucG9vbC5vZmYoXCJyZWxheTpjb25uZWN0XCIsIHRoaXMucG9vbE1vbml0b3IpO1xuICAgIHRoaXMub25TdG9wcGVkPy4oKTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgc3Vic2NyaXB0aW9uIGhhcyBhbiBhdXRob3JzIGZpbHRlci5cbiAgICovXG4gIGhhc0F1dGhvcnNGaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVycy5zb21lKChmKSA9PiBmLmF1dGhvcnM/Lmxlbmd0aCk7XG4gIH1cbiAgc3RhcnRXaXRoQ2FjaGUoKSB7XG4gICAgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlcj8ucXVlcnkpIHtcbiAgICAgIHJldHVybiB0aGlzLm5kay5jYWNoZUFkYXB0ZXIucXVlcnkodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICAvKipcbiAgICogRmluZCBhdmFpbGFibGUgcmVsYXlzIHRoYXQgc2hvdWxkIGJlIHBhcnQgb2YgdGhpcyBzdWJzY3JpcHRpb24gYW5kIGV4ZWN1dGUgaW4gdGhlbS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgaXMgZXhlY3V0ZWQgaW4gYWRkaXRpb24gdG8gdXNpbmcgdGhlIHBvb2wgbW9uaXRvciwgc28gZXZlbiBpZiB0aGUgcmVsYXkgc2V0XG4gICAqIHRoYXQgaXMgY29tcHV0ZWQgKGkuZS4gd2UgZG9uJ3QgaGF2ZSBhbnkgcmVsYXlzIGF2YWlsYWJsZSksIHdoZW4gcmVsYXlzIGNvbWUgb25saW5lLCB3ZSB3aWxsXG4gICAqIGNoZWNrIGlmIHdlIG5lZWQgdG8gZXhlY3V0ZSBpbiB0aGVtLlxuICAgKi9cbiAgc3RhcnRXaXRoUmVsYXlzKCkge1xuICAgIGxldCBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzO1xuICAgIGlmICh0aGlzLm9wdHMuYWRkU2luY2VGcm9tQ2FjaGUgJiYgdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCkge1xuICAgICAgY29uc3Qgc2luY2VUaW1lc3RhbXAgPSB0aGlzLm1vc3RSZWNlbnRDYWNoZUV2ZW50VGltZXN0YW1wICsgMTtcbiAgICAgIGZpbHRlcnMgPSBmaWx0ZXJzLm1hcCgoZmlsdGVyKSA9PiAoe1xuICAgICAgICAuLi5maWx0ZXIsXG4gICAgICAgIHNpbmNlOiBNYXRoLm1heChmaWx0ZXIuc2luY2UgfHwgMCwgc2luY2VUaW1lc3RhbXApXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5yZWxheVNldCB8fCB0aGlzLnJlbGF5U2V0LnJlbGF5cy5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLnJlbGF5RmlsdGVycyA9IGNhbGN1bGF0ZVJlbGF5U2V0c0Zyb21GaWx0ZXJzKHRoaXMubmRrLCBmaWx0ZXJzLCB0aGlzLnBvb2wpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbGF5RmlsdGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHRoaXMucmVsYXlTZXQucmVsYXlzKSB7XG4gICAgICAgIHRoaXMucmVsYXlGaWx0ZXJzLnNldChyZWxheS51cmwsIGZpbHRlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtyZWxheVVybCwgZmlsdGVyczJdIG9mIHRoaXMucmVsYXlGaWx0ZXJzKSB7XG4gICAgICBjb25zdCByZWxheSA9IHRoaXMucG9vbC5nZXRSZWxheShyZWxheVVybCwgdHJ1ZSwgdHJ1ZSwgZmlsdGVyczIpO1xuICAgICAgcmVsYXkuc3Vic2NyaWJlKHRoaXMsIGZpbHRlcnMyKTtcbiAgICB9XG4gIH1cbiAgLy8gRVZFTlQgaGFuZGxpbmdcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGFuIGV2ZW50IGlzIHJlY2VpdmVkIGZyb20gYSByZWxheSBvciB0aGUgY2FjaGVcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEBwYXJhbSByZWxheVxuICAgKiBAcGFyYW0gZnJvbUNhY2hlIFdoZXRoZXIgdGhlIGV2ZW50IHdhcyByZWNlaXZlZCBmcm9tIHRoZSBjYWNoZVxuICAgKiBAcGFyYW0gb3B0aW1pc3RpY1B1Ymxpc2ggV2hldGhlciB0aGlzIGV2ZW50IGlzIGNvbWluZyBmcm9tIGFuIG9wdGltaXN0aWMgcHVibGlzaFxuICAgKi9cbiAgZXZlbnRSZWNlaXZlZChldmVudCwgcmVsYXksIGZyb21DYWNoZSA9IGZhbHNlLCBvcHRpbWlzdGljUHVibGlzaCA9IGZhbHNlKSB7XG4gICAgY29uc3QgZXZlbnRJZCA9IGV2ZW50LmlkO1xuICAgIGNvbnN0IGV2ZW50QWxyZWFkeVNlZW4gPSB0aGlzLmV2ZW50Rmlyc3RTZWVuLmhhcyhldmVudElkKTtcbiAgICBsZXQgbmRrRXZlbnQ7XG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgTkRLRXZlbnQpIG5ka0V2ZW50ID0gZXZlbnQ7XG4gICAgaWYgKCFldmVudEFscmVhZHlTZWVuKSB7XG4gICAgICBuZGtFdmVudCA/Pz0gbmV3IE5ES0V2ZW50KHRoaXMubmRrLCBldmVudCk7XG4gICAgICBuZGtFdmVudC5uZGsgPSB0aGlzLm5kaztcbiAgICAgIG5ka0V2ZW50LnJlbGF5ID0gcmVsYXk7XG4gICAgICBpZiAoIWZyb21DYWNoZSAmJiAhb3B0aW1pc3RpY1B1Ymxpc2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgaWYgKCFuZGtFdmVudC5pc1ZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKFwiRXZlbnQgZmFpbGVkIHZhbGlkYXRpb24gJXMgZnJvbSByZWxheSAlc1wiLCBldmVudElkLCByZWxheT8udXJsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbGF5KSB7XG4gICAgICAgICAgaWYgKHJlbGF5Py5zaG91bGRWYWxpZGF0ZUV2ZW50KCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2tpcFZlcmlmaWNhdGlvbikge1xuICAgICAgICAgICAgICBpZiAoIW5ka0V2ZW50LnZlcmlmeVNpZ25hdHVyZSh0cnVlKSAmJiAhdGhpcy5uZGsuYXN5bmNTaWdWZXJpZmljYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKFwiRXZlbnQgZmFpbGVkIHNpZ25hdHVyZSB2YWxpZGF0aW9uXCIsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlbGF5KSB7XG4gICAgICAgICAgICAgICAgcmVsYXkuYWRkVmFsaWRhdGVkRXZlbnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWxheS5hZGROb25WYWxpZGF0ZWRFdmVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZGsuY2FjaGVBZGFwdGVyICYmICF0aGlzLm9wdHMuZG9udFNhdmVUb0NhY2hlKSB7XG4gICAgICAgICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLnNldEV2ZW50KG5ka0V2ZW50LCB0aGlzLmZpbHRlcnMsIHJlbGF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFvcHRpbWlzdGljUHVibGlzaCB8fCB0aGlzLnNraXBPcHRpbWlzdGljUHVibGlzaEV2ZW50ICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KHRoaXMub3B0cz8ud3JhcCA/PyBmYWxzZSwgbmRrRXZlbnQsIHJlbGF5LCBmcm9tQ2FjaGUsIG9wdGltaXN0aWNQdWJsaXNoKTtcbiAgICAgICAgdGhpcy5ldmVudEZpcnN0U2Vlbi5zZXQoZXZlbnRJZCwgRGF0ZS5ub3coKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRpbWVTaW5jZUZpcnN0U2VlbiA9IERhdGUubm93KCkgLSAodGhpcy5ldmVudEZpcnN0U2Vlbi5nZXQoZXZlbnRJZCkgfHwgMCk7XG4gICAgICB0aGlzLmVtaXQoXCJldmVudDpkdXBcIiwgZXZlbnQsIHJlbGF5LCB0aW1lU2luY2VGaXJzdFNlZW4sIHRoaXMsIGZyb21DYWNoZSwgb3B0aW1pc3RpY1B1Ymxpc2gpO1xuICAgICAgaWYgKHJlbGF5KSB7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHZlcmlmaWVkU2lnbmF0dXJlcy5nZXQoZXZlbnRJZCk7XG4gICAgICAgIGlmIChzaWduYXR1cmUgJiYgdHlwZW9mIHNpZ25hdHVyZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmIChldmVudC5zaWcgPT09IHNpZ25hdHVyZSkge1xuICAgICAgICAgICAgcmVsYXkuYWRkVmFsaWRhdGVkRXZlbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sYXN0RXZlbnRSZWNlaXZlZEF0ID0gRGF0ZS5ub3coKTtcbiAgfVxuICAvKipcbiAgICogT3B0aW9uYWxseSB3cmFwcywgc3luYyBvciBhc3luYywgYW5kIGVtaXRzIHRoZSBldmVudCAoaWYgb25lIGNvbWVzIGJhY2sgZnJvbSB0aGUgd3JhcHBlcilcbiAgICovXG4gIGVtaXRFdmVudCh3cmFwLCBldnQsIHJlbGF5LCBmcm9tQ2FjaGUsIG9wdGltaXN0aWNQdWJsaXNoKSB7XG4gICAgY29uc3Qgd3JhcHBlZCA9IHdyYXAgPyB3cmFwRXZlbnQoZXZ0KSA6IGV2dDtcbiAgICBpZiAod3JhcHBlZCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHdyYXBwZWQudGhlbigoZSkgPT4gdGhpcy5lbWl0RXZlbnQoZmFsc2UsIGUsIHJlbGF5LCBmcm9tQ2FjaGUsIG9wdGltaXN0aWNQdWJsaXNoKSk7XG4gICAgfSBlbHNlIGlmICh3cmFwcGVkKSB7XG4gICAgICB0aGlzLmVtaXQoXCJldmVudFwiLCB3cmFwcGVkLCByZWxheSwgdGhpcywgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCk7XG4gICAgfVxuICB9XG4gIGNsb3NlZFJlY2VpdmVkKHJlbGF5LCByZWFzb24pIHtcbiAgICB0aGlzLmVtaXQoXCJjbG9zZWRcIiwgcmVsYXksIHJlYXNvbik7XG4gIH1cbiAgLy8gRU9TRSBoYW5kbGluZ1xuICBlb3NlVGltZW91dDtcbiAgZW9zZWQgPSBmYWxzZTtcbiAgZW9zZVJlY2VpdmVkKHJlbGF5KSB7XG4gICAgdGhpcy5kZWJ1ZyhcIkVPU0UgcmVjZWl2ZWQgZnJvbSAlc1wiLCByZWxheS51cmwpO1xuICAgIHRoaXMuZW9zZXNTZWVuLmFkZChyZWxheSk7XG4gICAgbGV0IGxhc3RFdmVudFNlZW4gPSB0aGlzLmxhc3RFdmVudFJlY2VpdmVkQXQgPyBEYXRlLm5vdygpIC0gdGhpcy5sYXN0RXZlbnRSZWNlaXZlZEF0IDogdm9pZCAwO1xuICAgIGNvbnN0IGhhc1NlZW5BbGxFb3NlcyA9IHRoaXMuZW9zZXNTZWVuLnNpemUgPT09IHRoaXMucmVsYXlGaWx0ZXJzPy5zaXplO1xuICAgIGNvbnN0IHF1ZXJ5RmlsbGVkID0gcXVlcnlGdWxseUZpbGxlZCh0aGlzKTtcbiAgICBjb25zdCBwZXJmb3JtRW9zZSA9IChyZWFzb24pID0+IHtcbiAgICAgIHRoaXMuZGVidWcoXCJQZXJmb3JtaW5nIEVPU0U6ICVzICVkXCIsIHJlYXNvbiwgdGhpcy5lb3NlZCk7XG4gICAgICBpZiAodGhpcy5lb3NlZCkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuZW9zZVRpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLmVvc2VUaW1lb3V0KTtcbiAgICAgIHRoaXMuZW1pdChcImVvc2VcIiwgdGhpcyk7XG4gICAgICB0aGlzLmVvc2VkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLm9wdHM/LmNsb3NlT25Fb3NlKSB0aGlzLnN0b3AoKTtcbiAgICB9O1xuICAgIGlmIChxdWVyeUZpbGxlZCB8fCBoYXNTZWVuQWxsRW9zZXMpIHtcbiAgICAgIHBlcmZvcm1Fb3NlKFwicXVlcnkgZmlsbGVkIG9yIHNlZW4gYWxsXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZWxheUZpbHRlcnMpIHtcbiAgICAgIGxldCB0aW1lVG9XYWl0Rm9yTmV4dEVvc2UgPSAxZTM7XG4gICAgICBjb25zdCBjb25uZWN0ZWRSZWxheXMgPSBuZXcgU2V0KHRoaXMucG9vbC5jb25uZWN0ZWRSZWxheXMoKS5tYXAoKHIpID0+IHIudXJsKSk7XG4gICAgICBjb25zdCBjb25uZWN0ZWRSZWxheXNXaXRoRmlsdGVycyA9IEFycmF5LmZyb20odGhpcy5yZWxheUZpbHRlcnMua2V5cygpKS5maWx0ZXIoXG4gICAgICAgICh1cmwpID0+IGNvbm5lY3RlZFJlbGF5cy5oYXModXJsKVxuICAgICAgKTtcbiAgICAgIGlmIChjb25uZWN0ZWRSZWxheXNXaXRoRmlsdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcbiAgICAgICAgICBcIk5vIGNvbm5lY3RlZCByZWxheXMsIHdhaXRpbmcgZm9yIGFsbCByZWxheXMgdG8gY29ubmVjdFwiLFxuICAgICAgICAgIEFycmF5LmZyb20odGhpcy5yZWxheUZpbHRlcnMua2V5cygpKS5qb2luKFwiLCBcIilcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGVyY2VudGFnZU9mUmVsYXlzVGhhdEhhdmVTZW50RW9zZSA9IHRoaXMuZW9zZXNTZWVuLnNpemUgLyBjb25uZWN0ZWRSZWxheXNXaXRoRmlsdGVycy5sZW5ndGg7XG4gICAgICB0aGlzLmRlYnVnKFwiUGVyY2VudGFnZSBvZiByZWxheXMgdGhhdCBoYXZlIHNlbnQgRU9TRVwiLCB7XG4gICAgICAgIHN1YklkOiB0aGlzLnN1YklkLFxuICAgICAgICBwZXJjZW50YWdlT2ZSZWxheXNUaGF0SGF2ZVNlbnRFb3NlLFxuICAgICAgICBzZWVuOiB0aGlzLmVvc2VzU2Vlbi5zaXplLFxuICAgICAgICB0b3RhbDogY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLmVvc2VzU2Vlbi5zaXplID49IDIgJiYgcGVyY2VudGFnZU9mUmVsYXlzVGhhdEhhdmVTZW50RW9zZSA+PSAwLjUpIHtcbiAgICAgICAgdGltZVRvV2FpdEZvck5leHRFb3NlID0gdGltZVRvV2FpdEZvck5leHRFb3NlICogKDEgLSBwZXJjZW50YWdlT2ZSZWxheXNUaGF0SGF2ZVNlbnRFb3NlKTtcbiAgICAgICAgaWYgKHRpbWVUb1dhaXRGb3JOZXh0RW9zZSA9PT0gMCkge1xuICAgICAgICAgIHBlcmZvcm1Fb3NlKFwidGltZSB0byB3YWl0IHdhcyAwXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lb3NlVGltZW91dCkgY2xlYXJUaW1lb3V0KHRoaXMuZW9zZVRpbWVvdXQpO1xuICAgICAgICBjb25zdCBzZW5kRW9zZVRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICAgICAgbGFzdEV2ZW50U2VlbiA9IHRoaXMubGFzdEV2ZW50UmVjZWl2ZWRBdCA/IERhdGUubm93KCkgLSB0aGlzLmxhc3RFdmVudFJlY2VpdmVkQXQgOiB2b2lkIDA7XG4gICAgICAgICAgaWYgKGxhc3RFdmVudFNlZW4gIT09IHZvaWQgMCAmJiBsYXN0RXZlbnRTZWVuIDwgMjApIHtcbiAgICAgICAgICAgIHRoaXMuZW9zZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHNlbmRFb3NlVGltZW91dCwgdGltZVRvV2FpdEZvck5leHRFb3NlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVyZm9ybUVvc2UoYHNlbmQgZW9zZSB0aW1lb3V0OiAke3RpbWVUb1dhaXRGb3JOZXh0RW9zZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW9zZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHNlbmRFb3NlVGltZW91dCwgdGltZVRvV2FpdEZvck5leHRFb3NlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIga2luZElzRXBoZW1lcmFsID0gKGtpbmQpID0+IGtpbmQgPj0gMmU0ICYmIGtpbmQgPCAzZTQ7XG5cbi8vIHNyYy91c2VyL2ZvbGxvd3MudHNcbmFzeW5jIGZ1bmN0aW9uIGZvbGxvd3Mob3B0cywgb3V0Ym94LCBraW5kID0gMyAvKiBDb250YWN0cyAqLykge1xuICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgbm90IHNldFwiKTtcbiAgY29uc3QgY29udGFjdExpc3RFdmVudCA9IGF3YWl0IHRoaXMubmRrLmZldGNoRXZlbnQoXG4gICAgeyBraW5kczogW2tpbmRdLCBhdXRob3JzOiBbdGhpcy5wdWJrZXldIH0sXG4gICAgb3B0cyB8fCB7IGdyb3VwYWJsZTogZmFsc2UgfVxuICApO1xuICBpZiAoY29udGFjdExpc3RFdmVudCkge1xuICAgIGNvbnN0IHB1YmtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnRhY3RMaXN0RXZlbnQudGFncy5mb3JFYWNoKCh0YWcpID0+IHtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwicFwiKSBwdWJrZXlzLmFkZCh0YWdbMV0pO1xuICAgIH0pO1xuICAgIGlmIChvdXRib3gpIHtcbiAgICAgIHRoaXMubmRrPy5vdXRib3hUcmFja2VyPy50cmFja1VzZXJzKEFycmF5LmZyb20ocHVia2V5cykpO1xuICAgIH1cbiAgICByZXR1cm4gWy4uLnB1YmtleXNdLnJlZHVjZSgoYWNjLCBwdWJrZXkpID0+IHtcbiAgICAgIGNvbnN0IHVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleSB9KTtcbiAgICAgIHVzZXIubmRrID0gdGhpcy5uZGs7XG4gICAgICBhY2MuYWRkKHVzZXIpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbn1cblxuLy8gc3JjL3VzZXIvbmlwMDUudHNcbnZhciBOSVAwNV9SRUdFWCA9IC9eKD86KFtcXHcuKy1dKylAKT8oW1xcdy4tXSspJC87XG5hc3luYyBmdW5jdGlvbiBnZXROaXAwNUZvcihuZGssIGZ1bGxuYW1lLCBfZmV0Y2ggPSBmZXRjaCwgZmV0Y2hPcHRzID0ge30pIHtcbiAgcmV0dXJuIGF3YWl0IG5kay5xdWV1ZXNOaXAwNS5hZGQoe1xuICAgIGlkOiBmdWxsbmFtZSxcbiAgICBmdW5jOiBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAobmRrLmNhY2hlQWRhcHRlcj8ubG9hZE5pcDA1KSB7XG4gICAgICAgIGNvbnN0IHByb2ZpbGUgPSBhd2FpdCBuZGsuY2FjaGVBZGFwdGVyLmxvYWROaXAwNShmdWxsbmFtZSk7XG4gICAgICAgIGlmIChwcm9maWxlICE9PSBcIm1pc3NpbmdcIikge1xuICAgICAgICAgIGlmIChwcm9maWxlKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gbmV3IE5ES1VzZXIoe1xuICAgICAgICAgICAgICBwdWJrZXk6IHByb2ZpbGUucHVia2V5LFxuICAgICAgICAgICAgICByZWxheVVybHM6IHByb2ZpbGUucmVsYXlzLFxuICAgICAgICAgICAgICBuaXA0NlVybHM6IHByb2ZpbGUubmlwNDZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdXNlci5uZGsgPSBuZGs7XG4gICAgICAgICAgICByZXR1cm4gdXNlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZldGNoT3B0cy5jYWNoZSAhPT0gXCJuby1jYWNoZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hdGNoID0gZnVsbG5hbWUubWF0Y2goTklQMDVfUkVHRVgpO1xuICAgICAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBbXywgbmFtZSA9IFwiX1wiLCBkb21haW5dID0gbWF0Y2g7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBfZmV0Y2goYGh0dHBzOi8vJHtkb21haW59Ly53ZWxsLWtub3duL25vc3RyLmpzb24/bmFtZT0ke25hbWV9YCwgZmV0Y2hPcHRzKTtcbiAgICAgICAgY29uc3QgeyBuYW1lcywgcmVsYXlzLCBuaXA0NiB9ID0gcGFyc2VOSVAwNVJlc3VsdChhd2FpdCByZXMuanNvbigpKTtcbiAgICAgICAgY29uc3QgcHVia2V5ID0gbmFtZXNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgbGV0IHByb2ZpbGUgPSBudWxsO1xuICAgICAgICBpZiAocHVia2V5KSB7XG4gICAgICAgICAgcHJvZmlsZSA9IHsgcHVia2V5LCByZWxheXM6IHJlbGF5cz8uW3B1YmtleV0sIG5pcDQ2OiBuaXA0Nj8uW3B1YmtleV0gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmRrPy5jYWNoZUFkYXB0ZXI/LnNhdmVOaXAwNSkge1xuICAgICAgICAgIG5kay5jYWNoZUFkYXB0ZXIuc2F2ZU5pcDA1KGZ1bGxuYW1lLCBwcm9maWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvZmlsZTtcbiAgICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICAgIGlmIChuZGs/LmNhY2hlQWRhcHRlcj8uc2F2ZU5pcDA1KSB7XG4gICAgICAgICAgbmRrPy5jYWNoZUFkYXB0ZXIuc2F2ZU5pcDA1KGZ1bGxuYW1lLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIE5JUDA1IGZvclwiLCBmdWxsbmFtZSwgX2UpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VOSVAwNVJlc3VsdChqc29uKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBuYW1lczoge31cbiAgfTtcbiAgZm9yIChjb25zdCBbbmFtZSwgcHVia2V5XSBvZiBPYmplY3QuZW50cmllcyhqc29uLm5hbWVzKSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcHVia2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXN1bHQubmFtZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHB1YmtleTtcbiAgICB9XG4gIH1cbiAgaWYgKGpzb24ucmVsYXlzKSB7XG4gICAgcmVzdWx0LnJlbGF5cyA9IHt9O1xuICAgIGZvciAoY29uc3QgW3B1YmtleSwgcmVsYXlzXSBvZiBPYmplY3QuZW50cmllcyhqc29uLnJlbGF5cykpIHtcbiAgICAgIGlmICh0eXBlb2YgcHVia2V5ID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkocmVsYXlzKSkge1xuICAgICAgICByZXN1bHQucmVsYXlzW3B1YmtleV0gPSByZWxheXMuZmlsdGVyKChyZWxheSkgPT4gdHlwZW9mIHJlbGF5ID09PSBcInN0cmluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGpzb24ubmlwNDYpIHtcbiAgICByZXN1bHQubmlwNDYgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtwdWJrZXksIG5pcDQ2XSBvZiBPYmplY3QuZW50cmllcyhqc29uLm5pcDQ2KSkge1xuICAgICAgaWYgKHR5cGVvZiBwdWJrZXkgPT09IFwic3RyaW5nXCIgJiYgQXJyYXkuaXNBcnJheShuaXA0NikpIHtcbiAgICAgICAgcmVzdWx0Lm5pcDQ2W3B1YmtleV0gPSBuaXA0Ni5maWx0ZXIoKHJlbGF5KSA9PiB0eXBlb2YgcmVsYXkgPT09IFwic3RyaW5nXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvdXNlci9wcm9maWxlLnRzXG5mdW5jdGlvbiBwcm9maWxlRnJvbUV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IHByb2ZpbGUgPSB7fTtcbiAgbGV0IHBheWxvYWQ7XG4gIHRyeSB7XG4gICAgcGF5bG9hZCA9IEpTT04ucGFyc2UoZXZlbnQuY29udGVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgcHJvZmlsZSBldmVudDogJHtlcnJvcn1gKTtcbiAgfVxuICBwcm9maWxlLnByb2ZpbGVFdmVudCA9IEpTT04uc3RyaW5naWZ5KGV2ZW50LnJhd0V2ZW50KCkpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwYXlsb2FkKSkge1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICBwcm9maWxlLm5hbWUgPSBwYXlsb2FkLm5hbWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRpc3BsYXlfbmFtZVwiOlxuICAgICAgICBwcm9maWxlLmRpc3BsYXlOYW1lID0gcGF5bG9hZC5kaXNwbGF5X25hbWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICBjYXNlIFwicGljdHVyZVwiOlxuICAgICAgICBwcm9maWxlLnBpY3R1cmUgPSBwYXlsb2FkLnBpY3R1cmUgfHwgcGF5bG9hZC5pbWFnZTtcbiAgICAgICAgcHJvZmlsZS5pbWFnZSA9IHByb2ZpbGUucGljdHVyZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmFubmVyXCI6XG4gICAgICAgIHByb2ZpbGUuYmFubmVyID0gcGF5bG9hZC5iYW5uZXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJpb1wiOlxuICAgICAgICBwcm9maWxlLmJpbyA9IHBheWxvYWQuYmlvO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJuaXAwNVwiOlxuICAgICAgICBwcm9maWxlLm5pcDA1ID0gcGF5bG9hZC5uaXAwNTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibHVkMDZcIjpcbiAgICAgICAgcHJvZmlsZS5sdWQwNiA9IHBheWxvYWQubHVkMDY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImx1ZDE2XCI6XG4gICAgICAgIHByb2ZpbGUubHVkMTYgPSBwYXlsb2FkLmx1ZDE2O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJhYm91dFwiOlxuICAgICAgICBwcm9maWxlLmFib3V0ID0gcGF5bG9hZC5hYm91dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwid2Vic2l0ZVwiOlxuICAgICAgICBwcm9maWxlLndlYnNpdGUgPSBwYXlsb2FkLndlYnNpdGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcHJvZmlsZVtrZXldID0gcGF5bG9hZFtrZXldO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcHJvZmlsZS5jcmVhdGVkX2F0ID0gZXZlbnQuY3JlYXRlZF9hdDtcbiAgcmV0dXJuIHByb2ZpbGU7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVQcm9maWxlKHByb2ZpbGUpIHtcbiAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMocHJvZmlsZSkpIHtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBcInVzZXJuYW1lXCI6XG4gICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICBwYXlsb2FkLm5hbWUgPSB2YWw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRpc3BsYXlOYW1lXCI6XG4gICAgICAgIHBheWxvYWQuZGlzcGxheV9uYW1lID0gdmFsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgY2FzZSBcInBpY3R1cmVcIjpcbiAgICAgICAgcGF5bG9hZC5waWN0dXJlID0gdmFsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJiaW9cIjpcbiAgICAgIGNhc2UgXCJhYm91dFwiOlxuICAgICAgICBwYXlsb2FkLmFib3V0ID0gdmFsO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHBheWxvYWRba2V5XSA9IHZhbDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbn1cblxuLy8gc3JjL3VzZXIvaW5kZXgudHNcbnZhciBOREtVc2VyID0gY2xhc3MgX05ES1VzZXIge1xuICBuZGs7XG4gIHByb2ZpbGU7XG4gIHByb2ZpbGVFdmVudDtcbiAgX25wdWI7XG4gIF9wdWJrZXk7XG4gIHJlbGF5VXJscyA9IFtdO1xuICBuaXA0NlVybHMgPSBbXTtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIGlmIChvcHRzLm5wdWIpIHRoaXMuX25wdWIgPSBvcHRzLm5wdWI7XG4gICAgaWYgKG9wdHMuaGV4cHVia2V5KSB0aGlzLl9wdWJrZXkgPSBvcHRzLmhleHB1YmtleTtcbiAgICBpZiAob3B0cy5wdWJrZXkpIHRoaXMuX3B1YmtleSA9IG9wdHMucHVia2V5O1xuICAgIGlmIChvcHRzLnJlbGF5VXJscykgdGhpcy5yZWxheVVybHMgPSBvcHRzLnJlbGF5VXJscztcbiAgICBpZiAob3B0cy5uaXA0NlVybHMpIHRoaXMubmlwNDZVcmxzID0gb3B0cy5uaXA0NlVybHM7XG4gICAgaWYgKG9wdHMubnByb2ZpbGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBuaXAxOTUuZGVjb2RlKG9wdHMubnByb2ZpbGUpO1xuICAgICAgICBpZiAoZGVjb2RlZC50eXBlID09PSBcIm5wcm9maWxlXCIpIHtcbiAgICAgICAgICB0aGlzLl9wdWJrZXkgPSBkZWNvZGVkLmRhdGEucHVia2V5O1xuICAgICAgICAgIGlmIChkZWNvZGVkLmRhdGEucmVsYXlzICYmIGRlY29kZWQuZGF0YS5yZWxheXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZWxheVVybHMucHVzaCguLi5kZWNvZGVkLmRhdGEucmVsYXlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBkZWNvZGUgbnByb2ZpbGVcIiwgZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBucHViKCkge1xuICAgIGlmICghdGhpcy5fbnB1Yikge1xuICAgICAgaWYgKCF0aGlzLl9wdWJrZXkpIHRocm93IG5ldyBFcnJvcihcInB1YmtleSBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5fbnB1YiA9IG5pcDE5NS5ucHViRW5jb2RlKHRoaXMucHVia2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX25wdWI7XG4gIH1cbiAgZ2V0IG5wcm9maWxlKCkge1xuICAgIGNvbnN0IHJlbGF5cyA9IHRoaXMucHJvZmlsZUV2ZW50Py5vblJlbGF5cz8ubWFwKChyKSA9PiByLnVybCk7XG4gICAgcmV0dXJuIG5pcDE5NS5ucHJvZmlsZUVuY29kZSh7XG4gICAgICBwdWJrZXk6IHRoaXMucHVia2V5LFxuICAgICAgcmVsYXlzXG4gICAgfSk7XG4gIH1cbiAgc2V0IG5wdWIobnB1YjIpIHtcbiAgICB0aGlzLl9ucHViID0gbnB1YjI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlcidzIHB1YmtleVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdXNlcidzIHB1YmtleVxuICAgKi9cbiAgZ2V0IHB1YmtleSgpIHtcbiAgICBpZiAoIXRoaXMuX3B1YmtleSkge1xuICAgICAgaWYgKCF0aGlzLl9ucHViKSB0aHJvdyBuZXcgRXJyb3IoXCJucHViIG5vdCBzZXRcIik7XG4gICAgICB0aGlzLl9wdWJrZXkgPSBuaXAxOTUuZGVjb2RlKHRoaXMubnB1YikuZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3B1YmtleTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSB1c2VyJ3MgcHVia2V5XG4gICAqIEBwYXJhbSBwdWJrZXkge3N0cmluZ30gVGhlIHVzZXIncyBwdWJrZXlcbiAgICovXG4gIHNldCBwdWJrZXkocHVia2V5KSB7XG4gICAgdGhpcy5fcHVia2V5ID0gcHVia2V5O1xuICB9XG4gIC8qKlxuICAgKiBFcXVpdmFsZW50IHRvIE5ES0V2ZW50LmZpbHRlcnMoKS5cbiAgICogQHJldHVybnMge05ES0ZpbHRlcn1cbiAgICovXG4gIGZpbHRlcigpIHtcbiAgICByZXR1cm4geyBcIiNwXCI6IFt0aGlzLnB1YmtleV0gfTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBOSVAtNTcgYW5kIE5JUC02MSBpbmZvcm1hdGlvbiB0aGF0IHRoaXMgdXNlciBoYXMgc2lnbmFsZWRcbiAgICpcbiAgICogQHBhcmFtIGdldEFsbCB7Ym9vbGVhbn0gV2hldGhlciB0byBnZXQgYWxsIHphcCBpbmZvIG9yIGp1c3QgdGhlIGZpcnN0IG9uZVxuICAgKi9cbiAgYXN5bmMgZ2V0WmFwSW5mbyh0aW1lb3V0TXMpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgY29uc3QgcHJvbWlzZVdpdGhUaW1lb3V0ID0gYXN5bmMgKHByb21pc2UpID0+IHtcbiAgICAgIGlmICghdGltZW91dE1zKSByZXR1cm4gcHJvbWlzZTtcbiAgICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKFwiVGltZW91dFwiKSksIHRpbWVvdXRNcyk7XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmFjZShbcHJvbWlzZSwgdGltZW91dFByb21pc2VdKTtcbiAgICAgICAgaWYgKHRpbWVvdXRJZCkgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlID09PSBcIlRpbWVvdXRcIikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9IGNhdGNoIChfb3JpZ2luYWxFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IFt1c2VyUHJvZmlsZSwgbWludExpc3RFdmVudF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBwcm9taXNlV2l0aFRpbWVvdXQodGhpcy5mZXRjaFByb2ZpbGUoKSksXG4gICAgICBwcm9taXNlV2l0aFRpbWVvdXQodGhpcy5uZGsuZmV0Y2hFdmVudCh7IGtpbmRzOiBbMTAwMTkgLyogQ2FzaHVNaW50TGlzdCAqL10sIGF1dGhvcnM6IFt0aGlzLnB1YmtleV0gfSkpXG4gICAgXSk7XG4gICAgY29uc3QgcmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBpZiAobWludExpc3RFdmVudCkge1xuICAgICAgY29uc3QgbWludExpc3QgPSBOREtDYXNodU1pbnRMaXN0LmZyb20obWludExpc3RFdmVudCk7XG4gICAgICBpZiAobWludExpc3QubWludHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXMuc2V0KFwibmlwNjFcIiwge1xuICAgICAgICAgIG1pbnRzOiBtaW50TGlzdC5taW50cyxcbiAgICAgICAgICByZWxheXM6IG1pbnRMaXN0LnJlbGF5cyxcbiAgICAgICAgICBwMnBrOiBtaW50TGlzdC5wMnBrXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXNlclByb2ZpbGUpIHtcbiAgICAgIGNvbnN0IHsgbHVkMDYsIGx1ZDE2IH0gPSB1c2VyUHJvZmlsZTtcbiAgICAgIHJlcy5zZXQoXCJuaXA1N1wiLCB7IGx1ZDA2LCBsdWQxNiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICAvKipcbiAgICogSW5zdGFudGlhdGUgYW4gTkRLVXNlciBmcm9tIGEgTklQLTA1IHN0cmluZ1xuICAgKiBAcGFyYW0gbmlwMDVJZCB7c3RyaW5nfSBUaGUgdXNlcidzIE5JUC0wNVxuICAgKiBAcGFyYW0gbmRrIHtOREt9IEFuIE5ESyBpbnN0YW5jZVxuICAgKiBAcGFyYW0gc2tpcENhY2hlIHtib29sZWFufSBXaGV0aGVyIHRvIHNraXAgdGhlIGNhY2hlIG9yIG5vdFxuICAgKiBAcmV0dXJucyB7TkRLVXNlciB8IHVuZGVmaW5lZH0gQW4gTkRLVXNlciBpZiBvbmUgaXMgZm91bmQgZm9yIHRoZSBnaXZlbiBOSVAtMDUsIHVuZGVmaW5lZCBvdGhlcndpc2UuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZnJvbU5pcDA1KG5pcDA1SWQsIG5kaywgc2tpcENhY2hlID0gZmFsc2UpIHtcbiAgICBpZiAoIW5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICBpZiAoc2tpcENhY2hlKSBvcHRzLmNhY2hlID0gXCJuby1jYWNoZVwiO1xuICAgIGNvbnN0IHByb2ZpbGUgPSBhd2FpdCBnZXROaXAwNUZvcihuZGssIG5pcDA1SWQsIG5kaz8uaHR0cEZldGNoLCBvcHRzKTtcbiAgICBpZiAocHJvZmlsZSkge1xuICAgICAgY29uc3QgdXNlciA9IG5ldyBfTkRLVXNlcih7XG4gICAgICAgIHB1YmtleTogcHJvZmlsZS5wdWJrZXksXG4gICAgICAgIHJlbGF5VXJsczogcHJvZmlsZS5yZWxheXMsXG4gICAgICAgIG5pcDQ2VXJsczogcHJvZmlsZS5uaXA0NlxuICAgICAgfSk7XG4gICAgICB1c2VyLm5kayA9IG5kaztcbiAgICAgIHJldHVybiB1c2VyO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSB1c2VyJ3MgcHJvZmlsZVxuICAgKiBAcGFyYW0gb3B0cyB7TkRLU3Vic2NyaXB0aW9uT3B0aW9uc30gQSBzZXQgb2YgTkRLU3Vic2NyaXB0aW9uT3B0aW9uc1xuICAgKiBAcGFyYW0gc3RvcmVQcm9maWxlRXZlbnQge2Jvb2xlYW59IFdoZXRoZXIgdG8gc3RvcmUgdGhlIHByb2ZpbGUgZXZlbnQgb3Igbm90XG4gICAqIEByZXR1cm5zIFVzZXIgUHJvZmlsZVxuICAgKi9cbiAgYXN5bmMgZmV0Y2hQcm9maWxlKG9wdHMsIHN0b3JlUHJvZmlsZUV2ZW50ID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgbm90IHNldFwiKTtcbiAgICBsZXQgc2V0TWV0YWRhdGFFdmVudCA9IG51bGw7XG4gICAgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlciAmJiAodGhpcy5uZGsuY2FjaGVBZGFwdGVyLmZldGNoUHJvZmlsZSB8fCB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZmV0Y2hQcm9maWxlU3luYykgJiYgb3B0cz8uY2FjaGVVc2FnZSAhPT0gXCJPTkxZX1JFTEFZXCIgLyogT05MWV9SRUxBWSAqLykge1xuICAgICAgbGV0IHByb2ZpbGUgPSBudWxsO1xuICAgICAgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlci5mZXRjaFByb2ZpbGVTeW5jKSB7XG4gICAgICAgIHByb2ZpbGUgPSB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZmV0Y2hQcm9maWxlU3luYyh0aGlzLnB1YmtleSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlci5mZXRjaFByb2ZpbGUpIHtcbiAgICAgICAgcHJvZmlsZSA9IGF3YWl0IHRoaXMubmRrLmNhY2hlQWRhcHRlci5mZXRjaFByb2ZpbGUodGhpcy5wdWJrZXkpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2ZpbGUpIHtcbiAgICAgICAgdGhpcy5wcm9maWxlID0gcHJvZmlsZTtcbiAgICAgICAgcmV0dXJuIHByb2ZpbGU7XG4gICAgICB9XG4gICAgfVxuICAgIG9wdHMgPz89IHt9O1xuICAgIG9wdHMuY2FjaGVVc2FnZSA/Pz0gXCJPTkxZX1JFTEFZXCIgLyogT05MWV9SRUxBWSAqLztcbiAgICBvcHRzLmNsb3NlT25Fb3NlID8/PSB0cnVlO1xuICAgIG9wdHMuZ3JvdXBhYmxlID8/PSB0cnVlO1xuICAgIG9wdHMuZ3JvdXBhYmxlRGVsYXkgPz89IDI1MDtcbiAgICBpZiAoIXNldE1ldGFkYXRhRXZlbnQpIHtcbiAgICAgIHNldE1ldGFkYXRhRXZlbnQgPSBhd2FpdCB0aGlzLm5kay5mZXRjaEV2ZW50KHsga2luZHM6IFswXSwgYXV0aG9yczogW3RoaXMucHVia2V5XSB9LCBvcHRzKTtcbiAgICB9XG4gICAgaWYgKCFzZXRNZXRhZGF0YUV2ZW50KSByZXR1cm4gbnVsbDtcbiAgICB0aGlzLnByb2ZpbGUgPSBwcm9maWxlRnJvbUV2ZW50KHNldE1ldGFkYXRhRXZlbnQpO1xuICAgIGlmIChzdG9yZVByb2ZpbGVFdmVudCAmJiB0aGlzLnByb2ZpbGUgJiYgdGhpcy5uZGsuY2FjaGVBZGFwdGVyICYmIHRoaXMubmRrLmNhY2hlQWRhcHRlci5zYXZlUHJvZmlsZSkge1xuICAgICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLnNhdmVQcm9maWxlKHRoaXMucHVia2V5LCB0aGlzLnByb2ZpbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9maWxlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2V0IG9mIHVzZXJzIHRoYXQgdGhpcyB1c2VyIGZvbGxvd3MuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBmb2xsb3dTZXQgaW5zdGVhZFxuICAgKi9cbiAgZm9sbG93cyA9IGZvbGxvd3MuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBzZXQgb2YgcHVia2V5cyB0aGF0IHRoaXMgdXNlciBmb2xsb3dzLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0cyAtIE5ES1N1YnNjcmlwdGlvbk9wdGlvbnNcbiAgICogQHBhcmFtIG91dGJveCAtIGJvb2xlYW5cbiAgICogQHBhcmFtIGtpbmQgLSBudW1iZXJcbiAgICovXG4gIGFzeW5jIGZvbGxvd1NldChvcHRzLCBvdXRib3gsIGtpbmQgPSAzIC8qIENvbnRhY3RzICovKSB7XG4gICAgY29uc3QgZm9sbG93czIgPSBhd2FpdCB0aGlzLmZvbGxvd3Mob3B0cywgb3V0Ym94LCBraW5kKTtcbiAgICByZXR1cm4gbmV3IFNldChBcnJheS5mcm9tKGZvbGxvd3MyKS5tYXAoKGYpID0+IGYucHVia2V5KSk7XG4gIH1cbiAgLyoqIEBkZXByZWNhdGVkIFVzZSByZWZlcmVuY2VUYWdzIGluc3RlYWQuICovXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRhZyB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGlzIHVzZXIgaW4gYW4gZXZlbnRcbiAgICogQHJldHVybnMge05ES1RhZ30gYW4gTkRLVGFnXG4gICAqL1xuICB0YWdSZWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIFtcInBcIiwgdGhpcy5wdWJrZXldO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHRhZ3MgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyB1c2VyIGluIGFuIGV2ZW50XG4gICAqIEByZXR1cm5zIHtOREtUYWdbXX0gYW4gYXJyYXkgb2YgTkRLVGFnXG4gICAqL1xuICByZWZlcmVuY2VUYWdzKG1hcmtlcikge1xuICAgIGNvbnN0IHRhZyA9IFtbXCJwXCIsIHRoaXMucHVia2V5XV07XG4gICAgaWYgKCFtYXJrZXIpIHJldHVybiB0YWc7XG4gICAgdGFnWzBdLnB1c2goXCJcIiwgbWFya2VyKTtcbiAgICByZXR1cm4gdGFnO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoZXMgdGhlIGN1cnJlbnQgcHJvZmlsZS5cbiAgICovXG4gIGFzeW5jIHB1Ymxpc2goKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIGlmICghdGhpcy5wcm9maWxlKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm9maWxlIGF2YWlsYWJsZVwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywge1xuICAgICAga2luZDogMCxcbiAgICAgIGNvbnRlbnQ6IHNlcmlhbGl6ZVByb2ZpbGUodGhpcy5wcm9maWxlKVxuICAgIH0pO1xuICAgIGF3YWl0IGV2ZW50LnB1Ymxpc2goKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgZm9sbG93IHRvIHRoaXMgdXNlcidzIGNvbnRhY3QgbGlzdFxuICAgKlxuICAgKiBAcGFyYW0gbmV3Rm9sbG93IHtOREtVc2VyfSBUaGUgdXNlciB0byBmb2xsb3dcbiAgICogQHBhcmFtIGN1cnJlbnRGb2xsb3dMaXN0IHtTZXQ8TkRLVXNlcj59IFRoZSBjdXJyZW50IGZvbGxvdyBsaXN0XG4gICAqIEBwYXJhbSBraW5kIHtOREtLaW5kfSBUaGUga2luZCB0byB1c2UgZm9yIHRoaXMgY29udGFjdCBsaXN0IChkZWZhdWx0cyB0byBgM2ApXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBUcnVlIGlmIHRoZSBmb2xsb3cgd2FzIGFkZGVkLCBmYWxzZSBpZiB0aGUgZm9sbG93IGFscmVhZHkgZXhpc3RzXG4gICAqL1xuICBhc3luYyBmb2xsb3cobmV3Rm9sbG93LCBjdXJyZW50Rm9sbG93TGlzdCwga2luZCA9IDMgLyogQ29udGFjdHMgKi8pIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCk7XG4gICAgaWYgKCFjdXJyZW50Rm9sbG93TGlzdCkge1xuICAgICAgY3VycmVudEZvbGxvd0xpc3QgPSBhd2FpdCB0aGlzLmZvbGxvd3Modm9pZCAwLCB2b2lkIDAsIGtpbmQpO1xuICAgIH1cbiAgICBpZiAoY3VycmVudEZvbGxvd0xpc3QuaGFzKG5ld0ZvbGxvdykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY3VycmVudEZvbGxvd0xpc3QuYWRkKG5ld0ZvbGxvdyk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHsga2luZCB9KTtcbiAgICBmb3IgKGNvbnN0IGZvbGxvdyBvZiBjdXJyZW50Rm9sbG93TGlzdCkge1xuICAgICAgZXZlbnQudGFnKGZvbGxvdyk7XG4gICAgfVxuICAgIGF3YWl0IGV2ZW50LnB1Ymxpc2goKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGEgZm9sbG93IGZyb20gdGhpcyB1c2VyJ3MgY29udGFjdCBsaXN0XG4gICAqXG4gICAqIEBwYXJhbSB1c2VyIHtOREtVc2VyfSBUaGUgdXNlciB0byB1bmZvbGxvd1xuICAgKiBAcGFyYW0gY3VycmVudEZvbGxvd0xpc3Qge1NldDxOREtVc2VyPn0gVGhlIGN1cnJlbnQgZm9sbG93IGxpc3RcbiAgICogQHBhcmFtIGtpbmQge05ES0tpbmR9IFRoZSBraW5kIHRvIHVzZSBmb3IgdGhpcyBjb250YWN0IGxpc3QgKGRlZmF1bHRzIHRvIGAzYClcbiAgICogQHJldHVybnMgVGhlIHJlbGF5cyB3ZXJlIHRoZSBmb2xsb3cgbGlzdCB3YXMgcHVibGlzaGVkIG9yIGZhbHNlIGlmIHRoZSB1c2VyIHdhc24ndCBmb3VuZFxuICAgKi9cbiAgYXN5bmMgdW5mb2xsb3codXNlciwgY3VycmVudEZvbGxvd0xpc3QsIGtpbmQgPSAzIC8qIENvbnRhY3RzICovKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGlmICghY3VycmVudEZvbGxvd0xpc3QpIHtcbiAgICAgIGN1cnJlbnRGb2xsb3dMaXN0ID0gYXdhaXQgdGhpcy5mb2xsb3dzKHZvaWQgMCwgdm9pZCAwLCBraW5kKTtcbiAgICB9XG4gICAgY29uc3QgbmV3VXNlckZvbGxvd0xpc3QgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxldCBmb3VuZFVzZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGZvbGxvdyBvZiBjdXJyZW50Rm9sbG93TGlzdCkge1xuICAgICAgaWYgKGZvbGxvdy5wdWJrZXkgIT09IHVzZXIucHVia2V5KSB7XG4gICAgICAgIG5ld1VzZXJGb2xsb3dMaXN0LmFkZChmb2xsb3cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRVc2VyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmb3VuZFVzZXIpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywgeyBraW5kIH0pO1xuICAgIGZvciAoY29uc3QgZm9sbG93IG9mIG5ld1VzZXJGb2xsb3dMaXN0KSB7XG4gICAgICBldmVudC50YWcoZm9sbG93KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGV2ZW50LnB1Ymxpc2goKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgYSB1c2VyJ3MgTklQLTA1IGlkZW50aWZpZXIgKHVzdWFsbHkgZmV0Y2hlZCBmcm9tIHRoZWlyIGtpbmQ6MCBwcm9maWxlIGRhdGEpXG4gICAqXG4gICAqIEBwYXJhbSBuaXAwNUlkIFRoZSBOSVAtMDUgc3RyaW5nIHRvIHZhbGlkYXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4gfCBudWxsPn0gVHJ1ZSBpZiB0aGUgTklQLTA1IGlzIGZvdW5kIGFuZCBtYXRjaGVzIHRoaXMgdXNlcidzIHB1YmtleSxcbiAgICogRmFsc2UgaWYgdGhlIE5JUC0wNSBpcyBmb3VuZCBidXQgZG9lc24ndCBtYXRjaCB0aGlzIHVzZXIncyBwdWJrZXksXG4gICAqIG51bGwgaWYgdGhlIE5JUC0wNSBpc24ndCBmb3VuZCBvbiB0aGUgZG9tYWluIG9yIHdlJ3JlIHVuYWJsZSB0byB2ZXJpZnkgKGJlY2F1c2Ugb2YgbmV0d29yayBpc3N1ZXMsIGV0Yy4pXG4gICAqL1xuICBhc3luYyB2YWxpZGF0ZU5pcDA1KG5pcDA1SWQpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgY29uc3QgcHJvZmlsZVBvaW50ZXIgPSBhd2FpdCBnZXROaXAwNUZvcih0aGlzLm5kaywgbmlwMDVJZCk7XG4gICAgaWYgKHByb2ZpbGVQb2ludGVyID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcHJvZmlsZVBvaW50ZXIucHVia2V5ID09PSB0aGlzLnB1YmtleTtcbiAgfVxufTtcblxuLy8gc3JjL3VzZXIvcGluLnRzXG5hc3luYyBmdW5jdGlvbiBwaW5FdmVudCh1c2VyLCBldmVudCwgcGluRXZlbnQyLCBwdWJsaXNoKSB7XG4gIGNvbnN0IGtpbmQgPSAxMDAwMSAvKiBQaW5MaXN0ICovO1xuICBpZiAoIXVzZXIubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gIHVzZXIubmRrLmFzc2VydFNpZ25lcigpO1xuICBpZiAoIXBpbkV2ZW50Mikge1xuICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IHVzZXIubmRrLmZldGNoRXZlbnRzKFxuICAgICAgeyBraW5kczogW2tpbmRdLCBhdXRob3JzOiBbdXNlci5wdWJrZXldIH0sXG4gICAgICB7IGNhY2hlVXNhZ2U6IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi8gfVxuICAgICk7XG4gICAgaWYgKGV2ZW50cy5zaXplID4gMCkge1xuICAgICAgcGluRXZlbnQyID0gbGlzdHNfZGVmYXVsdC5mcm9tKEFycmF5LmZyb20oZXZlbnRzKVswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBpbkV2ZW50MiA9IG5ldyBOREtFdmVudCh1c2VyLm5kaywge1xuICAgICAgICBraW5kXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcGluRXZlbnQyLnRhZyhldmVudCk7XG4gIGlmIChwdWJsaXNoKSB7XG4gICAgYXdhaXQgcGluRXZlbnQyLnB1Ymxpc2goKTtcbiAgfVxuICByZXR1cm4gcGluRXZlbnQyO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2NsYXNzaWZpZWQudHNcbnZhciBOREtDbGFzc2lmaWVkID0gY2xhc3MgX05ES0NsYXNzaWZpZWQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMwNDAyIC8qIENsYXNzaWZpZWQgKi87XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOREtDbGFzc2lmaWVkIGZyb20gYW4gZXhpc3RpbmcgTkRLRXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBOREtFdmVudCB0byBjcmVhdGUgdGhlIE5ES0NsYXNzaWZpZWQgZnJvbS5cbiAgICogQHJldHVybnMgTkRLQ2xhc3NpZmllZFxuICAgKi9cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtDbGFzc2lmaWVkKGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIHRpdGxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBjbGFzc2lmaWVkIHRpdGxlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIHRpdGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gdGl0bGUgLSBUaGUgdGl0bGUgdG8gc2V0IGZvciB0aGUgY2xhc3NpZmllZC5cbiAgICovXG4gIHNldCB0aXRsZSh0aXRsZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHRpdGxlKSB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB0aXRsZV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIHN1bW1hcnkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGNsYXNzaWZpZWQgc3VtbWFyeSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgc3VtbWFyeSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInN1bW1hcnlcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgc3VtbWFyeS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHN1bW1hcnkgLSBUaGUgc3VtbWFyeSB0byBzZXQgZm9yIHRoZSBjbGFzc2lmaWVkLlxuICAgKi9cbiAgc2V0IHN1bW1hcnkoc3VtbWFyeSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwic3VtbWFyeVwiKTtcbiAgICBpZiAoc3VtbWFyeSkgdGhpcy50YWdzLnB1c2goW1wic3VtbWFyeVwiLCBzdW1tYXJ5XSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQncyBwdWJsaWNhdGlvbiB0aW1lc3RhbXAuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9IC0gVGhlIFVuaXggdGltZXN0YW1wIG9mIHdoZW4gdGhlIGNsYXNzaWZpZWQgd2FzIHB1Ymxpc2hlZCBvciB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgcHVibGlzaGVkX2F0KCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnVmFsdWUoXCJwdWJsaXNoZWRfYXRcIik7XG4gICAgaWYgKHRhZykge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludCh0YWcpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkJ3MgcHVibGljYXRpb24gdGltZXN0YW1wLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gdGltZXN0YW1wIC0gVGhlIFVuaXggdGltZXN0YW1wIHRvIHNldCBmb3IgdGhlIGNsYXNzaWZpZWQncyBwdWJsaWNhdGlvbiBkYXRlLlxuICAgKi9cbiAgc2V0IHB1Ymxpc2hlZF9hdCh0aW1lc3RhbXApIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInB1Ymxpc2hlZF9hdFwiKTtcbiAgICBpZiAodGltZXN0YW1wICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInB1Ymxpc2hlZF9hdFwiLCB0aW1lc3RhbXAudG9TdHJpbmcoKV0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCBsb2NhdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gLSBUaGUgY2xhc3NpZmllZCBsb2NhdGlvbiBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgbG9jYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJsb2NhdGlvblwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCBsb2NhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGxvY2F0aW9uIC0gVGhlIGxvY2F0aW9uIHRvIHNldCBmb3IgdGhlIGNsYXNzaWZpZWQuXG4gICAqL1xuICBzZXQgbG9jYXRpb24obG9jYXRpb24pIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImxvY2F0aW9uXCIpO1xuICAgIGlmIChsb2NhdGlvbikgdGhpcy50YWdzLnB1c2goW1wibG9jYXRpb25cIiwgbG9jYXRpb25dKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCBwcmljZS5cbiAgICpcbiAgICogQHJldHVybnMge05ES0NsYXNzaWZpZWRQcmljZVRhZyB8IHVuZGVmaW5lZH0gLSBUaGUgY2xhc3NpZmllZCBwcmljZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgcHJpY2UoKSB7XG4gICAgY29uc3QgcHJpY2VUYWcgPSB0aGlzLnRhZ3MuZmluZCgodGFnKSA9PiB0YWdbMF0gPT09IFwicHJpY2VcIik7XG4gICAgaWYgKHByaWNlVGFnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhbW91bnQ6IE51bWJlci5wYXJzZUZsb2F0KHByaWNlVGFnWzFdKSxcbiAgICAgICAgY3VycmVuY3k6IHByaWNlVGFnWzJdLFxuICAgICAgICBmcmVxdWVuY3k6IHByaWNlVGFnWzNdXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIHByaWNlLlxuICAgKlxuICAgKiBAcGFyYW0gcHJpY2UgLSBUaGUgcHJpY2UgdG8gc2V0IGZvciB0aGUgY2xhc3NpZmllZC5cbiAgICovXG4gIHNldCBwcmljZShwcmljZVRhZykge1xuICAgIGlmICh0eXBlb2YgcHJpY2VUYWcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHByaWNlVGFnID0ge1xuICAgICAgICBhbW91bnQ6IE51bWJlci5wYXJzZUZsb2F0KHByaWNlVGFnKVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHByaWNlVGFnPy5hbW91bnQpIHtcbiAgICAgIGNvbnN0IHRhZyA9IFtcInByaWNlXCIsIHByaWNlVGFnLmFtb3VudC50b1N0cmluZygpXTtcbiAgICAgIGlmIChwcmljZVRhZy5jdXJyZW5jeSkgdGFnLnB1c2gocHJpY2VUYWcuY3VycmVuY3kpO1xuICAgICAgaWYgKHByaWNlVGFnLmZyZXF1ZW5jeSkgdGFnLnB1c2gocHJpY2VUYWcuZnJlcXVlbmN5KTtcbiAgICAgIHRoaXMudGFncy5wdXNoKHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlVGFnKFwicHJpY2VcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgY29udGVudCB0YWdzIGZvciB0aGUgY2xhc3NpZmllZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZmlyc3QgY2hlY2tzIGFuZCBzZXRzIHRoZSBwdWJsaWNhdGlvbiBkYXRlIGlmIG5vdCBhdmFpbGFibGUsXG4gICAqIGFuZCB0aGVuIGdlbmVyYXRlcyBjb250ZW50IHRhZ3MgYmFzZWQgb24gdGhlIGJhc2UgTkRLRXZlbnQgY2xhc3MuXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb250ZW50VGFnfSAtIFRoZSBnZW5lcmF0ZWQgY29udGVudCB0YWdzLlxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVUYWdzKCkge1xuICAgIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICAgIGlmICghdGhpcy5wdWJsaXNoZWRfYXQpIHtcbiAgICAgIHRoaXMucHVibGlzaGVkX2F0ID0gdGhpcy5jcmVhdGVkX2F0O1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZ2VuZXJhdGVUYWdzKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvZHJhZnRzLnRzXG52YXIgTkRLRHJhZnQgPSBjbGFzcyBfTkRLRHJhZnQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIF9ldmVudDtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzEyMzQgLyogRHJhZnQgKi87XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtEcmFmdChldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhbiBpZGVudGlmaWVyIChpLmUuIGQtdGFnKVxuICAgKi9cbiAgc2V0IGlkZW50aWZpZXIoaWQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImRcIik7XG4gICAgdGhpcy50YWdzLnB1c2goW1wiZFwiLCBpZF0pO1xuICB9XG4gIGdldCBpZGVudGlmaWVyKCkge1xuICAgIHJldHVybiB0aGlzLmRUYWc7XG4gIH1cbiAgLyoqXG4gICAqIEV2ZW50IHRoYXQgaXMgdG8gYmUgc2F2ZWQuXG4gICAqL1xuICBzZXQgZXZlbnQoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgTkRLRXZlbnQpIHRoaXMuX2V2ZW50ID0gZS5yYXdFdmVudCgpO1xuICAgIGVsc2UgdGhpcy5fZXZlbnQgPSBlO1xuICAgIHRoaXMucHJlcGFyZUV2ZW50KCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGV2ZW50LlxuICAgKiBAcGFyYW0gcGFyYW0wXG4gICAqIEByZXR1cm5zIE5ES0V2ZW50IG9mIHRoZSBkcmFmdCBldmVudCBvciBudWxsIGlmIHRoZSBkcmFmdCBldmVudCBoYXMgYmVlbiBkZWxldGVkIChlbXB0aWVkKS5cbiAgICovXG4gIGFzeW5jIGdldEV2ZW50KHNpZ25lcikge1xuICAgIGlmICh0aGlzLl9ldmVudCkgcmV0dXJuIG5ldyBOREtFdmVudCh0aGlzLm5kaywgdGhpcy5fZXZlbnQpO1xuICAgIHNpZ25lciA/Pz0gdGhpcy5uZGs/LnNpZ25lcjtcbiAgICBpZiAoIXNpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgc2lnbmVyLnVzZXIoKTtcbiAgICBpZiAodGhpcy5jb250ZW50ICYmIHRoaXMuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmRlY3J5cHQodXNlciwgc2lnbmVyKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UodGhpcy5jb250ZW50KTtcbiAgICAgICAgdGhpcy5fZXZlbnQgPSBwYXlsb2FkO1xuICAgICAgICByZXR1cm4gbmV3IE5ES0V2ZW50KHRoaXMubmRrLCBwYXlsb2FkKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHByZXBhcmVFdmVudCgpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJObyBldmVudCBoYXMgYmVlbiBwcm92aWRlZFwiKTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImtcIik7XG4gICAgaWYgKHRoaXMuX2V2ZW50LmtpbmQpIHRoaXMudGFncy5wdXNoKFtcImtcIiwgdGhpcy5fZXZlbnQua2luZC50b1N0cmluZygpXSk7XG4gICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkodGhpcy5fZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgZHJhZnQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBzaWduZXI6IE9wdGlvbmFsIHNpZ25lciB0byBlbmNyeXB0IHdpdGhcbiAgICogQHBhcmFtIHB1Ymxpc2g6IFdoZXRoZXIgdG8gcHVibGlzaCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIHJlbGF5U2V0IHRvIHB1Ymxpc2ggdG9cbiAgICovXG4gIGFzeW5jIHNhdmUoeyBzaWduZXIsIHB1Ymxpc2gsIHJlbGF5U2V0IH0pIHtcbiAgICBzaWduZXIgPz89IHRoaXMubmRrPy5zaWduZXI7XG4gICAgaWYgKCFzaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHNpZ25lci51c2VyKCk7XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIsIHNpZ25lcik7XG4gICAgaWYgKHB1Ymxpc2ggPT09IGZhbHNlKSByZXR1cm47XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaChyZWxheVNldCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvZHZtL2ZlZWRiYWNrLnRzXG52YXIgTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChOREtEdm1Kb2JGZWVkYmFja1N0YXR1czIpID0+IHtcbiAgTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMyW1wiUHJvY2Vzc2luZ1wiXSA9IFwicHJvY2Vzc2luZ1wiO1xuICBOREtEdm1Kb2JGZWVkYmFja1N0YXR1czJbXCJTdWNjZXNzXCJdID0gXCJzdWNjZXNzXCI7XG4gIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzMltcIlNjaGVkdWxlZFwiXSA9IFwic2NoZWR1bGVkXCI7XG4gIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzMltcIlBheVJlcVwiXSA9IFwicGF5bWVudF9yZXF1aXJlZFwiO1xuICByZXR1cm4gTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMyO1xufSkoTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMgfHwge30pO1xudmFyIE5ES0RWTUpvYkZlZWRiYWNrID0gY2xhc3MgX05ES0RWTUpvYkZlZWRiYWNrIGV4dGVuZHMgTkRLRXZlbnQge1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIobmRrLCBldmVudCk7XG4gICAgdGhpcy5raW5kID8/PSA3ZTMgLyogRFZNSm9iRmVlZGJhY2sgKi87XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb20oZXZlbnQpIHtcbiAgICBjb25zdCBlID0gbmV3IF9OREtEVk1Kb2JGZWVkYmFjayhldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICAgIGlmIChlLmVuY3J5cHRlZCkgYXdhaXQgZS5kdm1EZWNyeXB0KCk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInN0YXR1c1wiKTtcbiAgfVxuICBzZXQgc3RhdHVzKHN0YXR1cykge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwic3RhdHVzXCIpO1xuICAgIGlmIChzdGF0dXMgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wic3RhdHVzXCIsIHN0YXR1c10pO1xuICAgIH1cbiAgfVxuICBnZXQgZW5jcnlwdGVkKCkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiZW5jcnlwdGVkXCIpWzBdO1xuICB9XG4gIGFzeW5jIGR2bURlY3J5cHQoKSB7XG4gICAgYXdhaXQgdGhpcy5kZWNyeXB0KCk7XG4gICAgY29uc3QgZGVjcnlwdGVkQ29udGVudCA9IEpTT04ucGFyc2UodGhpcy5jb250ZW50KTtcbiAgICB0aGlzLnRhZ3MucHVzaCguLi5kZWNyeXB0ZWRDb250ZW50KTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9kdm0vcmVxdWVzdC50c1xudmFyIE5ES0RWTVJlcXVlc3QgPSBjbGFzcyBfTkRLRFZNUmVxdWVzdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtEVk1SZXF1ZXN0KGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgc2V0IGJpZChtc2F0QW1vdW50KSB7XG4gICAgaWYgKG1zYXRBbW91bnQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW1vdmVUYWcoXCJiaWRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcImJpZFwiLCBtc2F0QW1vdW50LnRvU3RyaW5nKCldKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGJpZCgpIHtcbiAgICBjb25zdCB2ID0gdGhpcy50YWdWYWx1ZShcImJpZFwiKTtcbiAgICBpZiAodiA9PT0gdm9pZCAwKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQodik7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgaW5wdXQgdG8gdGhlIGpvYlxuICAgKiBAcGFyYW0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHRoZSBpbnB1dFxuICAgKi9cbiAgYWRkSW5wdXQoLi4uYXJncykge1xuICAgIHRoaXMudGFncy5wdXNoKFtcImlcIiwgLi4uYXJnc10pO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IHBhcmFtZXRlciB0byB0aGUgam9iXG4gICAqL1xuICBhZGRQYXJhbSguLi5hcmdzKSB7XG4gICAgdGhpcy50YWdzLnB1c2goW1wicGFyYW1cIiwgLi4uYXJnc10pO1xuICB9XG4gIHNldCBvdXRwdXQob3V0cHV0KSB7XG4gICAgaWYgKG91dHB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbW92ZVRhZyhcIm91dHB1dFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBvdXRwdXQgPT09IFwic3RyaW5nXCIpIG91dHB1dCA9IFtvdXRwdXRdO1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wib3V0cHV0XCIsIC4uLm91dHB1dF0pO1xuICAgIH1cbiAgfVxuICBnZXQgb3V0cHV0KCkge1xuICAgIGNvbnN0IG91dHB1dFRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwib3V0cHV0XCIpWzBdO1xuICAgIHJldHVybiBvdXRwdXRUYWcgPyBvdXRwdXRUYWcuc2xpY2UoMSkgOiB2b2lkIDA7XG4gIH1cbiAgZ2V0IHBhcmFtcygpIHtcbiAgICBjb25zdCBwYXJhbVRhZ3MgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBhcmFtXCIpO1xuICAgIHJldHVybiBwYXJhbVRhZ3MubWFwKCh0KSA9PiB0LnNsaWNlKDEpKTtcbiAgfVxuICBnZXRQYXJhbShuYW1lKSB7XG4gICAgY29uc3QgcGFyYW1UYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBhcmFtXCIpLmZpbmQoKHQpID0+IHRbMV0gPT09IG5hbWUpO1xuICAgIHJldHVybiBwYXJhbVRhZyA/IHBhcmFtVGFnWzJdIDogdm9pZCAwO1xuICB9XG4gIGNyZWF0ZUZlZWRiYWNrKHN0YXR1cykge1xuICAgIGNvbnN0IGZlZWRiYWNrID0gbmV3IE5ES0RWTUpvYkZlZWRiYWNrKHRoaXMubmRrKTtcbiAgICBmZWVkYmFjay50YWcodGhpcywgXCJqb2JcIik7XG4gICAgZmVlZGJhY2suc3RhdHVzID0gc3RhdHVzO1xuICAgIHJldHVybiBmZWVkYmFjaztcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBqb2IgZW5jcnlwdGlvbiBmb3IgdGhpcyBldmVudFxuICAgKiBAcGFyYW0gZHZtIERWTSB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHNpZ25lciBTaWduZXIgdG8gdXNlIGZvciBlbmNyeXB0aW9uXG4gICAqL1xuICBhc3luYyBlbmNyeXB0aW9uKGR2bSwgc2lnbmVyKSB7XG4gICAgY29uc3QgZHZtVGFncyA9IFtcImlcIiwgXCJwYXJhbVwiLCBcIm91dHB1dFwiLCBcInJlbGF5c1wiLCBcImJpZFwiXTtcbiAgICBjb25zdCB0YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gZHZtVGFncy5pbmNsdWRlcyh0WzBdKSk7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gIWR2bVRhZ3MuaW5jbHVkZXModFswXSkpO1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHRhZ3MpO1xuICAgIHRoaXMudGFnKGR2bSk7XG4gICAgdGhpcy50YWdzLnB1c2goW1wiZW5jcnlwdGVkXCJdKTtcbiAgICBhd2FpdCB0aGlzLmVuY3J5cHQoZHZtLCBzaWduZXIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBEVk0gdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50XG4gICAqL1xuICBzZXQgZHZtKGR2bSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicFwiKTtcbiAgICBpZiAoZHZtKSB0aGlzLnRhZyhkdm0pO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2R2bS9OREtUcmFuc2NyaXB0aW9uRFZNLnRzXG52YXIgTkRLVHJhbnNjcmlwdGlvbkRWTSA9IGNsYXNzIF9OREtUcmFuc2NyaXB0aW9uRFZNIGV4dGVuZHMgTkRLRFZNUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcihuZGssIGV2ZW50KTtcbiAgICB0aGlzLmtpbmQgPSA1ZTMgLyogRFZNUmVxVGV4dEV4dHJhY3Rpb24gKi87XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtUcmFuc2NyaXB0aW9uRFZNKGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBvZiB0aGUgdHJhbnNjcmlwdGlvblxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICBjb25zdCBpbnB1dFRhZ3MgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImlcIik7XG4gICAgaWYgKGlucHV0VGFncy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFRhZ3NbMF1bMV07XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIHRpdGxlIHRhZ1xuICAgKi9cbiAgZ2V0IHRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwidGl0bGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIHRpdGxlIHRhZ1xuICAgKi9cbiAgc2V0IHRpdGxlKHZhbHVlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJ0aXRsZVwiKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInRpdGxlXCIsIHZhbHVlXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBpbWFnZSB0YWdcbiAgICovXG4gIGdldCBpbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImltYWdlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBpbWFnZSB0YWdcbiAgICovXG4gIHNldCBpbWFnZSh2YWx1ZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiaW1hZ2VcIik7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJpbWFnZVwiLCB2YWx1ZV0pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9kdm0vcmVzdWx0LnRzXG52YXIgTkRLRFZNSm9iUmVzdWx0ID0gY2xhc3MgX05ES0RWTUpvYlJlc3VsdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtEVk1Kb2JSZXN1bHQoZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICBzZXRBbW91bnQobXNhdCwgaW52b2ljZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiYW1vdW50XCIpO1xuICAgIGNvbnN0IHRhZyA9IFtcImFtb3VudFwiLCBtc2F0LnRvU3RyaW5nKCldO1xuICAgIGlmIChpbnZvaWNlKSB0YWcucHVzaChpbnZvaWNlKTtcbiAgICB0aGlzLnRhZ3MucHVzaCh0YWcpO1xuICB9XG4gIHNldCByZXN1bHQocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmNvbnRlbnQgPSBcIlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbnRlbnQgPSByZXN1bHQ7XG4gICAgfVxuICB9XG4gIGdldCByZXN1bHQoKSB7XG4gICAgaWYgKHRoaXMuY29udGVudCA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgfVxuICBzZXQgc3RhdHVzKHN0YXR1cykge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwic3RhdHVzXCIpO1xuICAgIGlmIChzdGF0dXMgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wic3RhdHVzXCIsIHN0YXR1c10pO1xuICAgIH1cbiAgfVxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwic3RhdHVzXCIpO1xuICB9XG4gIGdldCBqb2JSZXF1ZXN0SWQoKSB7XG4gICAgZm9yIChjb25zdCBlVGFnIG9mIHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKSkge1xuICAgICAgaWYgKGVUYWdbMl0gPT09IFwiam9iXCIpIHJldHVybiBlVGFnWzFdO1xuICAgIH1cbiAgICBpZiAodGhpcy5qb2JSZXF1ZXN0KSByZXR1cm4gdGhpcy5qb2JSZXF1ZXN0LmlkO1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZVwiKTtcbiAgfVxuICBzZXQgam9iUmVxdWVzdChldmVudCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicmVxdWVzdFwiKTtcbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIHRoaXMua2luZCA9IGV2ZW50LmtpbmQgKyAxZTM7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJyZXF1ZXN0XCIsIEpTT04uc3RyaW5naWZ5KGV2ZW50LnJhd0V2ZW50KCkpXSk7XG4gICAgICB0aGlzLnRhZyhldmVudCk7XG4gICAgfVxuICB9XG4gIGdldCBqb2JSZXF1ZXN0KCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnVmFsdWUoXCJyZXF1ZXN0XCIpO1xuICAgIGlmICh0YWcgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOREtFdmVudCh0aGlzLm5kaywgSlNPTi5wYXJzZSh0YWcpKTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9jYXNodS90eC50c1xudmFyIE1BUktFUlMgPSB7XG4gIFJFREVFTUVEOiBcInJlZGVlbWVkXCIsXG4gIENSRUFURUQ6IFwiY3JlYXRlZFwiLFxuICBERVNUUk9ZRUQ6IFwiZGVzdHJveWVkXCIsXG4gIFJFU0VSVkVEOiBcInJlc2VydmVkXCJcbn07XG52YXIgTkRLQ2FzaHVXYWxsZXRUeCA9IGNsYXNzIF9OREtDYXNodVdhbGxldFR4IGV4dGVuZHMgTkRLRXZlbnQge1xuICBzdGF0aWMgTUFSS0VSUyA9IE1BUktFUlM7XG4gIHN0YXRpYyBraW5kID0gNzM3NiAvKiBDYXNodVdhbGxldFR4ICovO1xuICBzdGF0aWMga2luZHMgPSBbNzM3NiAvKiBDYXNodVdhbGxldFR4ICovXTtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gNzM3NiAvKiBDYXNodVdhbGxldFR4ICovO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tKGV2ZW50KSB7XG4gICAgY29uc3Qgd2FsbGV0Q2hhbmdlID0gbmV3IF9OREtDYXNodVdhbGxldFR4KGV2ZW50Lm5kaywgZXZlbnQpO1xuICAgIGNvbnN0IHByZXZDb250ZW50ID0gd2FsbGV0Q2hhbmdlLmNvbnRlbnQ7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHdhbGxldENoYW5nZS5kZWNyeXB0KCk7XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgIHdhbGxldENoYW5nZS5jb250ZW50ID8/PSBwcmV2Q29udGVudDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnRlbnRUYWdzID0gSlNPTi5wYXJzZSh3YWxsZXRDaGFuZ2UuY29udGVudCk7XG4gICAgICB3YWxsZXRDaGFuZ2UudGFncyA9IFsuLi5jb250ZW50VGFncywgLi4ud2FsbGV0Q2hhbmdlLnRhZ3NdO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB3YWxsZXRDaGFuZ2U7XG4gIH1cbiAgc2V0IGRpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImRpcmVjdGlvblwiKTtcbiAgICBpZiAoZGlyZWN0aW9uKSB0aGlzLnRhZ3MucHVzaChbXCJkaXJlY3Rpb25cIiwgZGlyZWN0aW9uXSk7XG4gIH1cbiAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImRpcmVjdGlvblwiKTtcbiAgfVxuICBzZXQgYW1vdW50KGFtb3VudCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiYW1vdW50XCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImFtb3VudFwiLCBhbW91bnQudG9TdHJpbmcoKV0pO1xuICB9XG4gIGdldCBhbW91bnQoKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy50YWdWYWx1ZShcImFtb3VudFwiKTtcbiAgICBpZiAodmFsID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIE51bWJlcih2YWwpO1xuICB9XG4gIHNldCBmZWUoZmVlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJmZWVcIik7XG4gICAgdGhpcy50YWdzLnB1c2goW1wiZmVlXCIsIGZlZS50b1N0cmluZygpXSk7XG4gIH1cbiAgZ2V0IGZlZSgpIHtcbiAgICBjb25zdCB2YWwgPSB0aGlzLnRhZ1ZhbHVlKFwiZmVlXCIpO1xuICAgIGlmICh2YWwgPT09IHZvaWQgMCkgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gTnVtYmVyKHZhbCk7XG4gIH1cbiAgc2V0IHVuaXQodW5pdCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidW5pdFwiKTtcbiAgICBpZiAodW5pdCkgdGhpcy50YWdzLnB1c2goW1widW5pdFwiLCB1bml0LnRvU3RyaW5nKCldKTtcbiAgfVxuICBnZXQgdW5pdCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInVuaXRcIik7XG4gIH1cbiAgc2V0IGRlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkZXNjcmlwdGlvblwiKTtcbiAgICBpZiAoZGVzY3JpcHRpb24pIHRoaXMudGFncy5wdXNoKFtcImRlc2NyaXB0aW9uXCIsIGRlc2NyaXB0aW9uLnRvU3RyaW5nKCldKTtcbiAgfVxuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJkZXNjcmlwdGlvblwiKTtcbiAgfVxuICBzZXQgbWludChtaW50KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJtaW50XCIpO1xuICAgIGlmIChtaW50KSB0aGlzLnRhZ3MucHVzaChbXCJtaW50XCIsIG1pbnQudG9TdHJpbmcoKV0pO1xuICB9XG4gIGdldCBtaW50KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwibWludFwiKTtcbiAgfVxuICAvKipcbiAgICogVGFncyB0b2tlbnMgdGhhdCB3ZXJlIGNyZWF0ZWQgaW4gdGhpcyBoaXN0b3J5IGV2ZW50XG4gICAqL1xuICBzZXQgZGVzdHJveWVkVG9rZW5zKGV2ZW50cykge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChldmVudC50YWdSZWZlcmVuY2UoTUFSS0VSUy5ERVNUUk9ZRUQpKTtcbiAgICB9XG4gIH1cbiAgc2V0IGRlc3Ryb3llZFRva2VuSWRzKGlkcykge1xuICAgIGZvciAoY29uc3QgaWQgb2YgaWRzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJlXCIsIGlkLCBcIlwiLCBNQVJLRVJTLkRFU1RST1lFRF0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGFncyB0b2tlbnMgdGhhdCB3ZXJlIGNyZWF0ZWQgaW4gdGhpcyBoaXN0b3J5IGV2ZW50XG4gICAqL1xuICBzZXQgY3JlYXRlZFRva2VucyhldmVudHMpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goZXZlbnQudGFnUmVmZXJlbmNlKE1BUktFUlMuQ1JFQVRFRCkpO1xuICAgIH1cbiAgfVxuICBzZXQgcmVzZXJ2ZWRUb2tlbnMoZXZlbnRzKSB7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKGV2ZW50LnRhZ1JlZmVyZW5jZShNQVJLRVJTLlJFU0VSVkVEKSk7XG4gICAgfVxuICB9XG4gIGFkZFJlZGVlbWVkTnV0emFwKGV2ZW50KSB7XG4gICAgdGhpcy50YWcoZXZlbnQsIE1BUktFUlMuUkVERUVNRUQpO1xuICB9XG4gIGFzeW5jIHRvTm9zdHJFdmVudChwdWJrZXkpIHtcbiAgICBjb25zdCBlbmNyeXB0ZWRUYWdzID0gW107XG4gICAgY29uc3QgdW5lbmNyeXB0ZWRUYWdzID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICBpZiAoIXRoaXMuc2hvdWxkRW5jcnlwdFRhZyh0YWcpKSB7XG4gICAgICAgIHVuZW5jcnlwdGVkVGFncy5wdXNoKHRhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmNyeXB0ZWRUYWdzLnB1c2godGFnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50YWdzID0gdW5lbmNyeXB0ZWRUYWdzLmZpbHRlcigodCkgPT4gdFswXSAhPT0gXCJjbGllbnRcIik7XG4gICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoZW5jcnlwdGVkVGFncyk7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubmRrPy5zaWduZXI/LnVzZXIoKTtcbiAgICBhd2FpdCB0aGlzLmVuY3J5cHQodXNlciwgdm9pZCAwLCBcIm5pcDQ0XCIpO1xuICAgIHJldHVybiBzdXBlci50b05vc3RyRXZlbnQocHVia2V5KTtcbiAgfVxuICAvKipcbiAgICogV2hldGhlciB0aGlzIGVudHJ5IGluY2x1ZGVzIGEgcmVkZW1wdGlvbiBvZiBhIE51dHphcFxuICAgKi9cbiAgZ2V0IGhhc051dHphcFJlZGVtcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiLCBNQVJLRVJTLlJFREVFTUVEKS5sZW5ndGggPiAwO1xuICB9XG4gIHNob3VsZEVuY3J5cHRUYWcodGFnKSB7XG4gICAgY29uc3QgdW5lbmNyeXB0ZWRUYWdOYW1lcyA9IFtcImNsaWVudFwiXTtcbiAgICBpZiAodW5lbmNyeXB0ZWRUYWdOYW1lcy5pbmNsdWRlcyh0YWdbMF0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0YWdbMF0gPT09IFwiZVwiICYmIHRhZ1szXSA9PT0gTUFSS0VSUy5SRURFRU1FRCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGFnWzBdID09PSBcInBcIikgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL05ES1JlbGF5TGlzdC50c1xudmFyIFJFQURfTUFSS0VSID0gXCJyZWFkXCI7XG52YXIgV1JJVEVfTUFSS0VSID0gXCJ3cml0ZVwiO1xudmFyIE5ES1JlbGF5TGlzdCA9IGNsYXNzIF9OREtSZWxheUxpc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDEwMDAyIC8qIFJlbGF5TGlzdCAqLztcbiAgfVxuICBzdGF0aWMgZnJvbShuZGtFdmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1JlbGF5TGlzdChuZGtFdmVudC5uZGssIG5ka0V2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIGdldCByZWFkUmVsYXlVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJyXCIgfHwgdGFnWzBdID09PSBcInJlbGF5XCIpLmZpbHRlcigodGFnKSA9PiAhdGFnWzJdIHx8IHRhZ1syXSAmJiB0YWdbMl0gPT09IFJFQURfTUFSS0VSKS5tYXAoKHRhZykgPT4gdHJ5Tm9ybWFsaXplUmVsYXlVcmwodGFnWzFdKSkuZmlsdGVyKCh1cmwpID0+ICEhdXJsKTtcbiAgfVxuICBzZXQgcmVhZFJlbGF5VXJscyhyZWxheXMpIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHJlbGF5cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiclwiLCByZWxheSwgUkVBRF9NQVJLRVJdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHdyaXRlUmVsYXlVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJyXCIgfHwgdGFnWzBdID09PSBcInJlbGF5XCIpLmZpbHRlcigodGFnKSA9PiAhdGFnWzJdIHx8IHRhZ1syXSAmJiB0YWdbMl0gPT09IFdSSVRFX01BUktFUikubWFwKCh0YWcpID0+IHRyeU5vcm1hbGl6ZVJlbGF5VXJsKHRhZ1sxXSkpLmZpbHRlcigodXJsKSA9PiAhIXVybCk7XG4gIH1cbiAgc2V0IHdyaXRlUmVsYXlVcmxzKHJlbGF5cykge1xuICAgIGZvciAoY29uc3QgcmVsYXkgb2YgcmVsYXlzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJyXCIsIHJlbGF5LCBXUklURV9NQVJLRVJdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGJvdGhSZWxheVVybHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdID09PSBcInJcIiB8fCB0YWdbMF0gPT09IFwicmVsYXlcIikuZmlsdGVyKCh0YWcpID0+ICF0YWdbMl0pLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICB9XG4gIHNldCBib3RoUmVsYXlVcmxzKHJlbGF5cykge1xuICAgIGZvciAoY29uc3QgcmVsYXkgb2YgcmVsYXlzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJyXCIsIHJlbGF5XSk7XG4gICAgfVxuICB9XG4gIGdldCByZWxheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdID09PSBcInJcIiB8fCB0YWdbMF0gPT09IFwicmVsYXlcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEgcmVsYXlTZXQgZm9yIHRoZSByZWxheXMgaW4gdGhpcyBsaXN0LlxuICAgKi9cbiAgZ2V0IHJlbGF5U2V0KCkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ES1JlbGF5TGlzdCBoYXMgbm8gTkRLIGluc3RhbmNlXCIpO1xuICAgIHJldHVybiBuZXcgTkRLUmVsYXlTZXQoXG4gICAgICBuZXcgU2V0KHRoaXMucmVsYXlzLm1hcCgodSkgPT4gdGhpcy5uZGs/LnBvb2wuZ2V0UmVsYXkodSkpLmZpbHRlcigocikgPT4gISFyKSksXG4gICAgICB0aGlzLm5ka1xuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiByZWxheUxpc3RGcm9tS2luZDMobmRrLCBjb250YWN0TGlzdCkge1xuICB0cnkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBKU09OLnBhcnNlKGNvbnRhY3RMaXN0LmNvbnRlbnQpO1xuICAgIGNvbnN0IHJlbGF5TGlzdCA9IG5ldyBOREtSZWxheUxpc3QobmRrKTtcbiAgICBjb25zdCByZWFkUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCB3cml0ZVJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgW2tleSwgY29uZmlnXSBvZiBPYmplY3QuZW50cmllcyhjb250ZW50KSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAga2V5ID0gbm9ybWFsaXplUmVsYXlVcmwoa2V5KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgIHJlYWRSZWxheXMuYWRkKGtleSk7XG4gICAgICAgIHdyaXRlUmVsYXlzLmFkZChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVsYXlDb25maWcgPSBjb25maWc7XG4gICAgICAgIGlmIChyZWxheUNvbmZpZy53cml0ZSkgd3JpdGVSZWxheXMuYWRkKGtleSk7XG4gICAgICAgIGlmIChyZWxheUNvbmZpZy5yZWFkKSByZWFkUmVsYXlzLmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZWxheUxpc3QucmVhZFJlbGF5VXJscyA9IEFycmF5LmZyb20ocmVhZFJlbGF5cyk7XG4gICAgcmVsYXlMaXN0LndyaXRlUmVsYXlVcmxzID0gQXJyYXkuZnJvbSh3cml0ZVJlbGF5cyk7XG4gICAgcmV0dXJuIHJlbGF5TGlzdDtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gc3JjL2V2ZW50cy9raW5kcy9uaXA4OS9hcHAtaGFuZGxlci50c1xudmFyIE5ES0FwcEhhbmRsZXJFdmVudCA9IGNsYXNzIF9OREtBcHBIYW5kbGVyRXZlbnQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHByb2ZpbGU7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMxOTkwIC8qIEFwcEhhbmRsZXIgKi87XG4gIH1cbiAgc3RhdGljIGZyb20obmRrRXZlbnQpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBfTkRLQXBwSGFuZGxlckV2ZW50KG5ka0V2ZW50Lm5kaywgbmRrRXZlbnQucmF3RXZlbnQoKSk7XG4gICAgaWYgKGV2ZW50LmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgY29uc3QgY29tYmluYXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBjb21iaW5hdGlvbkZyb21UYWcgPSAodGFnKSA9PiBbdGFnWzBdLCB0YWdbMl1dLmpvaW4oXCI6XCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgdGFnc1RvSW5zcGVjdCA9IFtcIndlYlwiLCBcImFuZHJvaWRcIiwgXCJpb3NcIl07XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICBpZiAodGFnc1RvSW5zcGVjdC5pbmNsdWRlcyh0YWdbMF0pKSB7XG4gICAgICAgIGNvbnN0IGNvbWJpbmF0aW9uID0gY29tYmluYXRpb25Gcm9tVGFnKHRhZyk7XG4gICAgICAgIGlmIChjb21iaW5hdGlvbnMuaGFzKGNvbWJpbmF0aW9uKSkge1xuICAgICAgICAgIGlmIChjb21iaW5hdGlvbnMuZ2V0KGNvbWJpbmF0aW9uKSAhPT0gdGFnWzFdLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29tYmluYXRpb25zLnNldChjb21iaW5hdGlvbiwgdGFnWzFdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2hlcyBhcHAgaGFuZGxlciBpbmZvcm1hdGlvblxuICAgKiBJZiBubyBhcHAgaW5mb3JtYXRpb24gaXMgYXZhaWxhYmxlIG9uIHRoZSBraW5kOjMxOTkwLFxuICAgKiB3ZSBmZXRjaCB0aGUgZXZlbnQncyBhdXRob3IncyBwcm9maWxlIGFuZCByZXR1cm4gdGhhdCBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZmV0Y2hQcm9maWxlKCkge1xuICAgIGlmICh0aGlzLnByb2ZpbGUgPT09IHZvaWQgMCAmJiB0aGlzLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHJvZmlsZSA9IEpTT04ucGFyc2UodGhpcy5jb250ZW50KTtcbiAgICAgICAgaWYgKHByb2ZpbGU/Lm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gcHJvZmlsZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2ZpbGUgPSBudWxsO1xuICAgICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgICAgdGhpcy5wcm9maWxlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGF1dGhvciA9IHRoaXMuYXV0aG9yO1xuICAgICAgYXV0aG9yLmZldGNoUHJvZmlsZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXNvbHZlKGF1dGhvci5wcm9maWxlKTtcbiAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvcmVwb3N0LnRzXG52YXIgTkRLUmVwb3N0ID0gY2xhc3MgX05ES1JlcG9zdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgX3JlcG9zdGVkRXZlbnRzO1xuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1JlcG9zdChldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCByZXBvc3RlZCBldmVudHMgYnkgdGhlIGN1cnJlbnQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBrbGFzcyBPcHRpb25hbCBjbGFzcyB0byBjb252ZXJ0IHRoZSBldmVudHMgdG8uXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyByZXBvc3RlZEV2ZW50cyhrbGFzcywgb3B0cykge1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBzZXRcIik7XG4gICAgaWYgKHRoaXMuX3JlcG9zdGVkRXZlbnRzICE9PSB2b2lkIDApIHJldHVybiB0aGlzLl9yZXBvc3RlZEV2ZW50cztcbiAgICBmb3IgKGNvbnN0IGV2ZW50SWQgb2YgdGhpcy5yZXBvc3RlZEV2ZW50SWRzKCkpIHtcbiAgICAgIGNvbnN0IGZpbHRlciA9IGZpbHRlckZvcklkKGV2ZW50SWQpO1xuICAgICAgY29uc3QgZXZlbnQgPSBhd2FpdCB0aGlzLm5kay5mZXRjaEV2ZW50KGZpbHRlciwgb3B0cyk7XG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgaXRlbXMucHVzaChrbGFzcyA/IGtsYXNzLmZyb20oZXZlbnQpIDogZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlcG9zdGVkIGV2ZW50IElEcy5cbiAgICovXG4gIHJlcG9zdGVkRXZlbnRJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFncy5maWx0ZXIoKHQpID0+IHRbMF0gPT09IFwiZVwiIHx8IHRbMF0gPT09IFwiYVwiKS5tYXAoKHQpID0+IHRbMV0pO1xuICB9XG59O1xuZnVuY3Rpb24gZmlsdGVyRm9ySWQoaWQpIHtcbiAgaWYgKGlkLm1hdGNoKC86LykpIHtcbiAgICBjb25zdCBba2luZCwgcHVia2V5LCBpZGVudGlmaWVyXSA9IGlkLnNwbGl0KFwiOlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAga2luZHM6IFtOdW1iZXIucGFyc2VJbnQoa2luZCldLFxuICAgICAgYXV0aG9yczogW3B1YmtleV0sXG4gICAgICBcIiNkXCI6IFtpZGVudGlmaWVyXVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHsgaWRzOiBbaWRdIH07XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc3Vic2NyaXB0aW9ucy9yZWNlaXB0LnRzXG5pbXBvcnQgZGVidWczIGZyb20gXCJkZWJ1Z1wiO1xudmFyIE5ES1N1YnNjcmlwdGlvblJlY2VpcHQgPSBjbGFzcyBfTkRLU3Vic2NyaXB0aW9uUmVjZWlwdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgZGVidWc7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDcwMDMgLyogU3Vic2NyaXB0aW9uUmVjZWlwdCAqLztcbiAgICB0aGlzLmRlYnVnID0gbmRrPy5kZWJ1Zy5leHRlbmQoXCJzdWJzY3JpcHRpb24tc3RhcnRcIikgPz8gZGVidWczKFwibmRrOnN1YnNjcmlwdGlvbi1zdGFydFwiKTtcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1N1YnNjcmlwdGlvblJlY2VpcHQoZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgcGVyc29uIGJlaW5nIHN1YnNjcmliZWQgdG9cbiAgICovXG4gIGdldCByZWNpcGllbnQoKSB7XG4gICAgY29uc3QgcFRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKT8uWzBdO1xuICAgIGlmICghcFRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCB1c2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXk6IHBUYWdbMV0gfSk7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgc2V0IHJlY2lwaWVudCh1c2VyKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwXCIpO1xuICAgIGlmICghdXNlcikgcmV0dXJuO1xuICAgIHRoaXMudGFncy5wdXNoKFtcInBcIiwgdXNlci5wdWJrZXldKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgcGVyc29uIHN1YnNjcmliaW5nXG4gICAqL1xuICBnZXQgc3Vic2NyaWJlcigpIHtcbiAgICBjb25zdCBQVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJQXCIpPy5bMF07XG4gICAgaWYgKCFQVGFnKSByZXR1cm4gdm9pZCAwO1xuICAgIGNvbnN0IHVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogUFRhZ1sxXSB9KTtcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICBzZXQgc3Vic2NyaWJlcih1c2VyKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJQXCIpO1xuICAgIGlmICghdXNlcikgcmV0dXJuO1xuICAgIHRoaXMudGFncy5wdXNoKFtcIlBcIiwgdXNlci5wdWJrZXldKTtcbiAgfVxuICBzZXQgc3Vic2NyaXB0aW9uU3RhcnQoZXZlbnQpIHtcbiAgICB0aGlzLmRlYnVnKGBiZWZvcmUgc2V0dGluZyBzdWJzY3JpcHRpb24gc3RhcnQ6ICR7dGhpcy5yYXdFdmVudH1gKTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImVcIik7XG4gICAgdGhpcy50YWcoZXZlbnQsIFwic3Vic2NyaXB0aW9uXCIsIHRydWUpO1xuICAgIHRoaXMuZGVidWcoYGFmdGVyIHNldHRpbmcgc3Vic2NyaXB0aW9uIHN0YXJ0OiAke3RoaXMucmF3RXZlbnR9YCk7XG4gIH1cbiAgZ2V0IHRpZXJOYW1lKCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwidGllclwiKT8uWzBdO1xuICAgIHJldHVybiB0YWc/LlsxXTtcbiAgfVxuICBnZXQgaXNWYWxpZCgpIHtcbiAgICBjb25zdCBwZXJpb2QgPSB0aGlzLnZhbGlkUGVyaW9kO1xuICAgIGlmICghcGVyaW9kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwZXJpb2Quc3RhcnQgPiBwZXJpb2QuZW5kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBUYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpO1xuICAgIGNvbnN0IFBUYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJQXCIpO1xuICAgIGlmIChwVGFncy5sZW5ndGggIT09IDEgfHwgUFRhZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCB2YWxpZFBlcmlvZCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInZhbGlkXCIpPy5bMF07XG4gICAgaWYgKCF0YWcpIHJldHVybiB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBuZXcgRGF0ZShOdW1iZXIucGFyc2VJbnQodGFnWzFdKSAqIDFlMyksXG4gICAgICAgIGVuZDogbmV3IERhdGUoTnVtYmVyLnBhcnNlSW50KHRhZ1syXSkgKiAxZTMpXG4gICAgICB9O1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgc2V0IHZhbGlkUGVyaW9kKHBlcmlvZCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidmFsaWRcIik7XG4gICAgaWYgKCFwZXJpb2QpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChbXG4gICAgICBcInZhbGlkXCIsXG4gICAgICBNYXRoLmZsb29yKHBlcmlvZC5zdGFydC5nZXRUaW1lKCkgLyAxZTMpLnRvU3RyaW5nKCksXG4gICAgICBNYXRoLmZsb29yKHBlcmlvZC5lbmQuZ2V0VGltZSgpIC8gMWUzKS50b1N0cmluZygpXG4gICAgXSk7XG4gIH1cbiAgZ2V0IHN0YXJ0UGVyaW9kKCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkUGVyaW9kPy5zdGFydDtcbiAgfVxuICBnZXQgZW5kUGVyaW9kKCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkUGVyaW9kPy5lbmQ7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHN1YnNjcmlwdGlvbiBpcyBjdXJyZW50bHkgYWN0aXZlXG4gICAqL1xuICBpc0FjdGl2ZSh0aW1lKSB7XG4gICAgdGltZSA/Pz0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgY29uc3QgcGVyaW9kID0gdGhpcy52YWxpZFBlcmlvZDtcbiAgICBpZiAoIXBlcmlvZCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aW1lIDwgcGVyaW9kLnN0YXJ0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRpbWUgPiBwZXJpb2QuZW5kKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc3Vic2NyaXB0aW9ucy9zdWJzY3JpcHRpb24tc3RhcnQudHNcbmltcG9ydCBkZWJ1ZzQgZnJvbSBcImRlYnVnXCI7XG52YXIgTkRLU3Vic2NyaXB0aW9uU3RhcnQgPSBjbGFzcyBfTkRLU3Vic2NyaXB0aW9uU3RhcnQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGRlYnVnO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSA3MDAxIC8qIFN1YnNjcmliZSAqLztcbiAgICB0aGlzLmRlYnVnID0gbmRrPy5kZWJ1Zy5leHRlbmQoXCJzdWJzY3JpcHRpb24tc3RhcnRcIikgPz8gZGVidWc0KFwibmRrOnN1YnNjcmlwdGlvbi1zdGFydFwiKTtcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1N1YnNjcmlwdGlvblN0YXJ0KGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlY2lwaWVudCBvZiB0aGUgc3Vic2NyaXB0aW9uLiBJLmUuIFRoZSBhdXRob3Igb2YgdGhpcyBldmVudCBzdWJzY3JpYmVzIHRvIHRoaXMgdXNlci5cbiAgICovXG4gIGdldCByZWNpcGllbnQoKSB7XG4gICAgY29uc3QgcFRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKT8uWzBdO1xuICAgIGlmICghcFRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCB1c2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXk6IHBUYWdbMV0gfSk7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgc2V0IHJlY2lwaWVudCh1c2VyKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwXCIpO1xuICAgIGlmICghdXNlcikgcmV0dXJuO1xuICAgIHRoaXMudGFncy5wdXNoKFtcInBcIiwgdXNlci5wdWJrZXldKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiB0aGUgc3Vic2NyaXB0aW9uLlxuICAgKi9cbiAgZ2V0IGFtb3VudCgpIHtcbiAgICBjb25zdCBhbW91bnRUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImFtb3VudFwiKT8uWzBdO1xuICAgIGlmICghYW1vdW50VGFnKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBwYXJzZVRhZ1RvU3Vic2NyaXB0aW9uQW1vdW50KGFtb3VudFRhZyk7XG4gIH1cbiAgc2V0IGFtb3VudChhbW91bnQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImFtb3VudFwiKTtcbiAgICBpZiAoIWFtb3VudCkgcmV0dXJuO1xuICAgIHRoaXMudGFncy5wdXNoKG5ld0Ftb3VudChhbW91bnQuYW1vdW50LCBhbW91bnQuY3VycmVuY3ksIGFtb3VudC50ZXJtKSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBldmVudCBpZCBvciBOSVAtMzMgdGFnIGlkIG9mIHRoZSB0aWVyIHRoYXQgdGhlIHVzZXIgaXMgc3Vic2NyaWJpbmcgdG8uXG4gICAqL1xuICBnZXQgdGllcklkKCkge1xuICAgIGNvbnN0IGVUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIik/LlswXTtcbiAgICBjb25zdCBhVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhXCIpPy5bMF07XG4gICAgaWYgKCFlVGFnIHx8ICFhVGFnKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBlVGFnWzFdID8/IGFUYWdbMV07XG4gIH1cbiAgc2V0IHRpZXIodGllcikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZVwiKTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImFcIik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJldmVudFwiKTtcbiAgICBpZiAoIXRpZXIpIHJldHVybjtcbiAgICB0aGlzLnRhZyh0aWVyKTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInBcIik7XG4gICAgdGhpcy50YWdzLnB1c2goW1wicFwiLCB0aWVyLnB1YmtleV0pO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImV2ZW50XCIsIEpTT04uc3RyaW5naWZ5KHRpZXIucmF3RXZlbnQoKSldKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2hlcyB0aGUgdGllciB0aGF0IHRoZSB1c2VyIGlzIHN1YnNjcmliaW5nIHRvLlxuICAgKi9cbiAgYXN5bmMgZmV0Y2hUaWVyKCkge1xuICAgIGNvbnN0IGV2ZW50VGFnID0gdGhpcy50YWdWYWx1ZShcImV2ZW50XCIpO1xuICAgIGlmIChldmVudFRhZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkRXZlbnQgPSBKU09OLnBhcnNlKGV2ZW50VGFnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOREtTdWJzY3JpcHRpb25UaWVyKHRoaXMubmRrLCBwYXJzZWRFdmVudCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIkZhaWxlZCB0byBwYXJzZSBldmVudCB0YWdcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRpZXJJZCA9IHRoaXMudGllcklkO1xuICAgIGlmICghdGllcklkKSByZXR1cm4gdm9pZCAwO1xuICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLm5kaz8uZmV0Y2hFdmVudCh0aWVySWQpO1xuICAgIGlmICghZSkgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gTkRLU3Vic2NyaXB0aW9uVGllci5mcm9tKGUpO1xuICB9XG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIGlmICh0aGlzLmdldE1hdGNoaW5nVGFncyhcImFtb3VudFwiKS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJJbnZhbGlkICMgb2YgYW1vdW50IHRhZ1wiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmFtb3VudCkge1xuICAgICAgdGhpcy5kZWJ1ZyhcIkludmFsaWQgYW1vdW50IHRhZ1wiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJJbnZhbGlkICMgb2YgcCB0YWdcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5yZWNpcGllbnQpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJJbnZhbGlkIHAgdGFnXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9naWZ0LXdyYXBwaW5nLnRzXG5pbXBvcnQgeyBnZXRFdmVudEhhc2ggYXMgZ2V0RXZlbnRIYXNoMiB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuXG4vLyBzcmMvc2lnbmVycy9wcml2YXRlLWtleS9pbmRleC50c1xuaW1wb3J0IHsgZmluYWxpemVFdmVudCwgZ2VuZXJhdGVTZWNyZXRLZXksIGdldFB1YmxpY0tleSwgbmlwMDQsIG5pcDQ0IH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG5pbXBvcnQgeyBieXRlc1RvSGV4IGFzIGJ5dGVzVG9IZXgyLCBoZXhUb0J5dGVzIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IG5pcDE5IGFzIG5pcDE5NiB9IGZyb20gXCJub3N0ci10b29sc1wiO1xudmFyIE5ES1ByaXZhdGVLZXlTaWduZXIgPSBjbGFzcyBfTkRLUHJpdmF0ZUtleVNpZ25lciB7XG4gIF91c2VyO1xuICBfcHJpdmF0ZUtleTtcbiAgX3B1YmtleTtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzaWduZXIgZnJvbSBhIHByaXZhdGUga2V5LlxuICAgKiBAcGFyYW0gcHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSB0byB1c2UgaW4gaGV4IGZvcm0gb3IgbnNlYy5cbiAgICogQHBhcmFtIG5kayAtIFRoZSBOREsgaW5zdGFuY2UgdG8gdXNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZUtleU9yTnNlYywgbmRrKSB7XG4gICAgaWYgKHR5cGVvZiBwcml2YXRlS2V5T3JOc2VjID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAocHJpdmF0ZUtleU9yTnNlYy5zdGFydHNXaXRoKFwibnNlYzFcIikpIHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBkYXRhIH0gPSBuaXAxOTYuZGVjb2RlKHByaXZhdGVLZXlPck5zZWMpO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJuc2VjXCIpIHRoaXMuX3ByaXZhdGVLZXkgPSBkYXRhO1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJpdmF0ZSBrZXkgcHJvdmlkZWQuXCIpO1xuICAgICAgfSBlbHNlIGlmIChwcml2YXRlS2V5T3JOc2VjLmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZUtleSA9IGhleFRvQnl0ZXMocHJpdmF0ZUtleU9yTnNlYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByaXZhdGUga2V5IHByb3ZpZGVkLlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcHJpdmF0ZUtleSA9IHByaXZhdGVLZXlPck5zZWM7XG4gICAgfVxuICAgIHRoaXMuX3B1YmtleSA9IGdldFB1YmxpY0tleSh0aGlzLl9wcml2YXRlS2V5KTtcbiAgICBpZiAobmRrKSB0aGlzLl91c2VyID0gbmRrLmdldFVzZXIoeyBwdWJrZXk6IHRoaXMuX3B1YmtleSB9KTtcbiAgICB0aGlzLl91c2VyID8/PSBuZXcgTkRLVXNlcih7IHB1YmtleTogdGhpcy5fcHVia2V5IH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHByaXZhdGUga2V5IGluIGhleCBmb3JtLlxuICAgKi9cbiAgZ2V0IHByaXZhdGVLZXkoKSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlS2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgcmVhZHlcIik7XG4gICAgcmV0dXJuIGJ5dGVzVG9IZXgyKHRoaXMuX3ByaXZhdGVLZXkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1YmxpYyBrZXkgaW4gaGV4IGZvcm0uXG4gICAqL1xuICBnZXQgcHVia2V5KCkge1xuICAgIGlmICghdGhpcy5fcHVia2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgcmVhZHlcIik7XG4gICAgcmV0dXJuIHRoaXMuX3B1YmtleTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBwcml2YXRlIGtleSBpbiBuc2VjIGZvcm0uXG4gICAqL1xuICBnZXQgbnNlYygpIHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGVLZXkpIHRocm93IG5ldyBFcnJvcihcIk5vdCByZWFkeVwiKTtcbiAgICByZXR1cm4gbmlwMTk2Lm5zZWNFbmNvZGUodGhpcy5fcHJpdmF0ZUtleSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgcHVibGljIGtleSBpbiBucHViIGZvcm0uXG4gICAqL1xuICBnZXQgbnB1YigpIHtcbiAgICBpZiAoIXRoaXMuX3B1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiTm90IHJlYWR5XCIpO1xuICAgIHJldHVybiBuaXAxOTYubnB1YkVuY29kZSh0aGlzLl9wdWJrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyBwcml2YXRlIGtleS5cbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZSgpIHtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gZ2VuZXJhdGVTZWNyZXRLZXkoKTtcbiAgICByZXR1cm4gbmV3IF9OREtQcml2YXRlS2V5U2lnbmVyKHByaXZhdGVLZXkpO1xuICB9XG4gIC8qKlxuICAgKiBOb29wIGluIE5ES1ByaXZhdGVLZXlTaWduZXIuXG4gICAqL1xuICBhc3luYyBibG9ja1VudGlsUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlci5cbiAgICovXG4gIGFzeW5jIHVzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlci5cbiAgICovXG4gIGdldCB1c2VyU3luYygpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlcjtcbiAgfVxuICBhc3luYyBzaWduKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkF0dGVtcHRlZCB0byBzaWduIHdpdGhvdXQgYSBwcml2YXRlIGtleVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmFsaXplRXZlbnQoZXZlbnQsIHRoaXMuX3ByaXZhdGVLZXkpLnNpZztcbiAgfVxuICBhc3luYyBlbmNyeXB0aW9uRW5hYmxlZChzY2hlbWUpIHtcbiAgICBjb25zdCBlbmFibGVkID0gW107XG4gICAgaWYgKCFzY2hlbWUgfHwgc2NoZW1lID09PSBcIm5pcDA0XCIpIGVuYWJsZWQucHVzaChcIm5pcDA0XCIpO1xuICAgIGlmICghc2NoZW1lIHx8IHNjaGVtZSA9PT0gXCJuaXA0NFwiKSBlbmFibGVkLnB1c2goXCJuaXA0NFwiKTtcbiAgICByZXR1cm4gZW5hYmxlZDtcbiAgfVxuICBhc3luYyBlbmNyeXB0KHJlY2lwaWVudCwgdmFsdWUsIHNjaGVtZSkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSB8fCAhdGhpcy5wcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkF0dGVtcHRlZCB0byBlbmNyeXB0IHdpdGhvdXQgYSBwcml2YXRlIGtleVwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVjaXBpZW50SGV4UHViS2V5ID0gcmVjaXBpZW50LnB1YmtleTtcbiAgICBpZiAoc2NoZW1lID09PSBcIm5pcDQ0XCIpIHtcbiAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbktleSA9IG5pcDQ0LnYyLnV0aWxzLmdldENvbnZlcnNhdGlvbktleSh0aGlzLl9wcml2YXRlS2V5LCByZWNpcGllbnRIZXhQdWJLZXkpO1xuICAgICAgcmV0dXJuIGF3YWl0IG5pcDQ0LnYyLmVuY3J5cHQodmFsdWUsIGNvbnZlcnNhdGlvbktleSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBuaXAwNC5lbmNyeXB0KHRoaXMuX3ByaXZhdGVLZXksIHJlY2lwaWVudEhleFB1YktleSwgdmFsdWUpO1xuICB9XG4gIGFzeW5jIGRlY3J5cHQoc2VuZGVyLCB2YWx1ZSwgc2NoZW1lKSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlS2V5IHx8ICF0aGlzLnByaXZhdGVLZXkpIHtcbiAgICAgIHRocm93IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGRlY3J5cHQgd2l0aG91dCBhIHByaXZhdGUga2V5XCIpO1xuICAgIH1cbiAgICBjb25zdCBzZW5kZXJIZXhQdWJLZXkgPSBzZW5kZXIucHVia2V5O1xuICAgIGlmIChzY2hlbWUgPT09IFwibmlwNDRcIikge1xuICAgICAgY29uc3QgY29udmVyc2F0aW9uS2V5ID0gbmlwNDQudjIudXRpbHMuZ2V0Q29udmVyc2F0aW9uS2V5KHRoaXMuX3ByaXZhdGVLZXksIHNlbmRlckhleFB1YktleSk7XG4gICAgICByZXR1cm4gYXdhaXQgbmlwNDQudjIuZGVjcnlwdCh2YWx1ZSwgY29udmVyc2F0aW9uS2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IG5pcDA0LmRlY3J5cHQodGhpcy5fcHJpdmF0ZUtleSwgc2VuZGVySGV4UHViS2V5LCB2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIHNpZ25lcidzIHByaXZhdGUga2V5IGludG8gYSBzdG9yYWJsZSBmb3JtYXQuXG4gICAqIEByZXR1cm5zIEEgSlNPTiBzdHJpbmcgY29udGFpbmluZyB0aGUgdHlwZSBhbmQgdGhlIGhleCBwcml2YXRlIGtleS5cbiAgICovXG4gIHRvUGF5bG9hZCgpIHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGVLZXkpIHRocm93IG5ldyBFcnJvcihcIlByaXZhdGUga2V5IG5vdCBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIHR5cGU6IFwicHJpdmF0ZS1rZXlcIixcbiAgICAgIHBheWxvYWQ6IHRoaXMucHJpdmF0ZUtleVxuICAgICAgLy8gVXNlIHRoZSBoZXggcHJpdmF0ZSBrZXlcbiAgICB9O1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgfVxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBzaWduZXIgZnJvbSBhIHBheWxvYWQgc3RyaW5nLlxuICAgKiBAcGFyYW0gcGF5bG9hZFN0cmluZyBUaGUgSlNPTiBzdHJpbmcgb2J0YWluZWQgZnJvbSB0b1BheWxvYWQoKS5cbiAgICogQHBhcmFtIG5kayBPcHRpb25hbCBOREsgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIE5ES1ByaXZhdGVLZXlTaWduZXIuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZnJvbVBheWxvYWQocGF5bG9hZFN0cmluZywgbmRrKSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UocGF5bG9hZFN0cmluZyk7XG4gICAgaWYgKHBheWxvYWQudHlwZSAhPT0gXCJwcml2YXRlLWtleVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGF5bG9hZCB0eXBlOiBleHBlY3RlZCAncHJpdmF0ZS1rZXknLCBnb3QgJHtwYXlsb2FkLnR5cGV9YCk7XG4gICAgfVxuICAgIGlmICghcGF5bG9hZC5wYXlsb2FkIHx8IHR5cGVvZiBwYXlsb2FkLnBheWxvYWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGF5bG9hZCBjb250ZW50IGZvciBwcml2YXRlLWtleSBzaWduZXJcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX05ES1ByaXZhdGVLZXlTaWduZXIocGF5bG9hZC5wYXlsb2FkLCBuZGspO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2dpZnQtd3JhcHBpbmcudHNcbmFzeW5jIGZ1bmN0aW9uIGdpZnRXcmFwKGV2ZW50LCByZWNpcGllbnQsIHNpZ25lciwgcGFyYW1zID0ge30pIHtcbiAgbGV0IF9zaWduZXIgPSBzaWduZXI7XG4gIHBhcmFtcy5zY2hlbWUgPz89IFwibmlwNDRcIjtcbiAgaWYgKCFfc2lnbmVyKSB7XG4gICAgaWYgKCFldmVudC5uZGspIHRocm93IG5ldyBFcnJvcihcIm5vIHNpZ25lciBhdmFpbGFibGUgZm9yIGdpZnRXcmFwXCIpO1xuICAgIF9zaWduZXIgPSBldmVudC5uZGsuc2lnbmVyO1xuICB9XG4gIGlmICghX3NpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwibm8gc2lnbmVyXCIpO1xuICBpZiAoIV9zaWduZXIuZW5jcnlwdGlvbkVuYWJsZWQgfHwgIV9zaWduZXIuZW5jcnlwdGlvbkVuYWJsZWQocGFyYW1zLnNjaGVtZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwic2lnbmVyIGlzIG5vdCBhYmxlIHRvIGdpZnRXcmFwXCIpO1xuICBjb25zdCBydW1vciA9IGdldFJ1bW9yRXZlbnQoZXZlbnQsIHBhcmFtcz8ucnVtb3JLaW5kKTtcbiAgY29uc3Qgc2VhbCA9IGF3YWl0IGdldFNlYWxFdmVudChydW1vciwgcmVjaXBpZW50LCBfc2lnbmVyLCBwYXJhbXMuc2NoZW1lKTtcbiAgY29uc3Qgd3JhcCA9IGF3YWl0IGdldFdyYXBFdmVudChzZWFsLCByZWNpcGllbnQsIHBhcmFtcyk7XG4gIHJldHVybiBuZXcgTkRLRXZlbnQoZXZlbnQubmRrLCB3cmFwKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdpZnRVbndyYXAoZXZlbnQsIHNlbmRlciwgc2lnbmVyLCBzY2hlbWUgPSBcIm5pcDQ0XCIpIHtcbiAgY29uc3QgX3NlbmRlciA9IHNlbmRlciB8fCBuZXcgTkRLVXNlcih7IHB1YmtleTogZXZlbnQucHVia2V5IH0pO1xuICBsZXQgX3NpZ25lciA9IHNpZ25lcjtcbiAgaWYgKCFfc2lnbmVyKSB7XG4gICAgaWYgKCFldmVudC5uZGspIHRocm93IG5ldyBFcnJvcihcIm5vIHNpZ25lciBhdmFpbGFibGUgZm9yIGdpZnRVbndyYXBcIik7XG4gICAgX3NpZ25lciA9IGV2ZW50Lm5kay5zaWduZXI7XG4gIH1cbiAgaWYgKCFzaWduZXIpIHRocm93IG5ldyBFcnJvcihcIm5vIHNpZ25lclwiKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZWFsID0gSlNPTi5wYXJzZShhd2FpdCBzaWduZXIuZGVjcnlwdChfc2VuZGVyLCBldmVudC5jb250ZW50LCBzY2hlbWUpKTtcbiAgICBpZiAoIXNlYWwpIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNyeXB0IHdyYXBwZXJcIik7XG4gICAgaWYgKCFuZXcgTkRLRXZlbnQodm9pZCAwLCBzZWFsKS52ZXJpZnlTaWduYXR1cmUoZmFsc2UpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2lmdFNlYWwgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQhXCIpO1xuICAgIGNvbnN0IHJ1bW9yU2VuZGVyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXk6IHNlYWwucHVia2V5IH0pO1xuICAgIGNvbnN0IHJ1bW9yID0gSlNPTi5wYXJzZShhd2FpdCBzaWduZXIuZGVjcnlwdChydW1vclNlbmRlciwgc2VhbC5jb250ZW50LCBzY2hlbWUpKTtcbiAgICBpZiAoIXJ1bW9yKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVjcnlwdCBzZWFsXCIpO1xuICAgIGlmIChydW1vci5wdWJrZXkgIT09IHNlYWwucHVia2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdpZnRXcmFwLCBzZW5kZXIgdmFsaWRhdGlvbiBmYWlsZWQhXCIpO1xuICAgIHJldHVybiBuZXcgTkRLRXZlbnQoZXZlbnQubmRrLCBydW1vcik7XG4gIH0gY2F0Y2ggKF9lKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiR290IGVycm9yIHVud3JhcHBpbmcgZXZlbnQhIFNlZSBjb25zb2xlIGxvZy5cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJ1bW9yRXZlbnQoZXZlbnQsIGtpbmQpIHtcbiAgY29uc3QgcnVtb3IgPSBldmVudC5yYXdFdmVudCgpO1xuICBydW1vci5raW5kID0ga2luZCB8fCBydW1vci5raW5kIHx8IDE0IC8qIFByaXZhdGVEaXJlY3RNZXNzYWdlICovO1xuICBydW1vci5zaWcgPSB2b2lkIDA7XG4gIHJ1bW9yLmlkID0gZ2V0RXZlbnRIYXNoMihydW1vcik7XG4gIHJldHVybiBuZXcgTkRLRXZlbnQoZXZlbnQubmRrLCBydW1vcik7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTZWFsRXZlbnQocnVtb3IsIHJlY2lwaWVudCwgc2lnbmVyLCBzY2hlbWUgPSBcIm5pcDQ0XCIpIHtcbiAgY29uc3Qgc2VhbCA9IG5ldyBOREtFdmVudChydW1vci5uZGspO1xuICBzZWFsLmtpbmQgPSAxMyAvKiBHaWZ0V3JhcFNlYWwgKi87XG4gIHNlYWwuY3JlYXRlZF9hdCA9IGFwcHJveGltYXRlTm93KDUpO1xuICBzZWFsLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShydW1vci5yYXdFdmVudCgpKTtcbiAgYXdhaXQgc2VhbC5lbmNyeXB0KHJlY2lwaWVudCwgc2lnbmVyLCBzY2hlbWUpO1xuICBhd2FpdCBzZWFsLnNpZ24oc2lnbmVyKTtcbiAgcmV0dXJuIHNlYWw7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRXcmFwRXZlbnQoc2VhbGVkLCByZWNpcGllbnQsIHBhcmFtcywgc2NoZW1lID0gXCJuaXA0NFwiKSB7XG4gIGNvbnN0IHNpZ25lciA9IE5ES1ByaXZhdGVLZXlTaWduZXIuZ2VuZXJhdGUoKTtcbiAgY29uc3Qgd3JhcCA9IG5ldyBOREtFdmVudChzZWFsZWQubmRrKTtcbiAgd3JhcC5raW5kID0gMTA1OSAvKiBHaWZ0V3JhcCAqLztcbiAgd3JhcC5jcmVhdGVkX2F0ID0gYXBwcm94aW1hdGVOb3coNSk7XG4gIGlmIChwYXJhbXM/LndyYXBUYWdzKSB3cmFwLnRhZ3MgPSBwYXJhbXMud3JhcFRhZ3M7XG4gIHdyYXAudGFnKHJlY2lwaWVudCk7XG4gIHdyYXAuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHNlYWxlZC5yYXdFdmVudCgpKTtcbiAgYXdhaXQgd3JhcC5lbmNyeXB0KHJlY2lwaWVudCwgc2lnbmVyLCBzY2hlbWUpO1xuICBhd2FpdCB3cmFwLnNpZ24oc2lnbmVyKTtcbiAgcmV0dXJuIHdyYXA7XG59XG5mdW5jdGlvbiBhcHByb3hpbWF0ZU5vdyhkcmlmdCA9IDApIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDFlMyAtIE1hdGgucmFuZG9tKCkgKiAxMCAqKiBkcmlmdCk7XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc2ltcGxlLWdyb3VwL2luZGV4LnRzXG52YXIgTkRLU2ltcGxlR3JvdXAgPSBjbGFzcyBfTkRLU2ltcGxlR3JvdXAge1xuICBuZGs7XG4gIGdyb3VwSWQ7XG4gIHJlbGF5U2V0O1xuICBmZXRjaGluZ01ldGFkYXRhO1xuICBtZXRhZGF0YTtcbiAgbWVtYmVyTGlzdDtcbiAgYWRtaW5MaXN0O1xuICBjb25zdHJ1Y3RvcihuZGssIHJlbGF5U2V0LCBncm91cElkKSB7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgdGhpcy5ncm91cElkID0gZ3JvdXBJZCA/PyByYW5kb21JZCgyNCk7XG4gICAgdGhpcy5yZWxheVNldCA9IHJlbGF5U2V0O1xuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ncm91cElkO1xuICB9XG4gIHJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy5yZWxheVNldD8ucmVsYXlVcmxzO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhPy5uYW1lO1xuICB9XG4gIGdldCBhYm91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRhZGF0YT8uYWJvdXQ7XG4gIH1cbiAgZ2V0IHBpY3R1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGE/LnBpY3R1cmU7XG4gIH1cbiAgZ2V0IG1lbWJlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVtYmVyTGlzdD8ubWVtYmVycyA/PyBbXTtcbiAgfVxuICBnZXQgYWRtaW5zKCkge1xuICAgIHJldHVybiB0aGlzLmFkbWluTGlzdD8ubWVtYmVycyA/PyBbXTtcbiAgfVxuICBhc3luYyBnZXRNZXRhZGF0YSgpIHtcbiAgICBhd2FpdCB0aGlzLmVuc3VyZU1ldGFkYXRhRXZlbnQoKTtcbiAgICByZXR1cm4gdGhpcy5tZXRhZGF0YTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgZ3JvdXAgYnkgcHVibGlzaGluZyBhIGtpbmQ6OTAwNyBldmVudC5cbiAgICogQHBhcmFtIHNpZ25lclxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlR3JvdXAoc2lnbmVyKSB7XG4gICAgc2lnbmVyID8/PSB0aGlzLm5kay5zaWduZXI7XG4gICAgaWYgKCFzaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHNpZ25lci51c2VyKCk7XG4gICAgaWYgKCF1c2VyKSB0aHJvdyBuZXcgRXJyb3IoXCJObyB1c2VyIGF2YWlsYWJsZVwiKTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kayk7XG4gICAgZXZlbnQua2luZCA9IDkwMDcgLyogR3JvdXBBZG1pbkNyZWF0ZUdyb3VwICovO1xuICAgIGV2ZW50LnRhZ3MucHVzaChbXCJoXCIsIHRoaXMuZ3JvdXBJZF0pO1xuICAgIGF3YWl0IGV2ZW50LnNpZ24oc2lnbmVyKTtcbiAgICByZXR1cm4gZXZlbnQucHVibGlzaCh0aGlzLnJlbGF5U2V0KTtcbiAgfVxuICBhc3luYyBzZXRNZXRhZGF0YSh7IG5hbWUsIGFib3V0LCBwaWN0dXJlIH0pIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kayk7XG4gICAgZXZlbnQua2luZCA9IDkwMDIgLyogR3JvdXBBZG1pbkVkaXRNZXRhZGF0YSAqLztcbiAgICBldmVudC50YWdzLnB1c2goW1wiaFwiLCB0aGlzLmdyb3VwSWRdKTtcbiAgICBpZiAobmFtZSkgZXZlbnQudGFncy5wdXNoKFtcIm5hbWVcIiwgbmFtZV0pO1xuICAgIGlmIChhYm91dCkgZXZlbnQudGFncy5wdXNoKFtcImFib3V0XCIsIGFib3V0XSk7XG4gICAgaWYgKHBpY3R1cmUpIGV2ZW50LnRhZ3MucHVzaChbXCJwaWN0dXJlXCIsIHBpY3R1cmVdKTtcbiAgICBhd2FpdCBldmVudC5zaWduKCk7XG4gICAgcmV0dXJuIGV2ZW50LnB1Ymxpc2godGhpcy5yZWxheVNldCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSB1c2VyIHRvIHRoZSBncm91cCB1c2luZyBhIGtpbmQ6OTAwMCBldmVudFxuICAgKiBAcGFyYW0gdXNlciB1c2VyIHRvIGFkZFxuICAgKiBAcGFyYW0gb3B0cyBvcHRpb25zXG4gICAqL1xuICBhc3luYyBhZGRVc2VyKHVzZXIpIHtcbiAgICBjb25zdCBhZGRVc2VyRXZlbnQgPSBfTkRLU2ltcGxlR3JvdXAuZ2VuZXJhdGVBZGRVc2VyRXZlbnQodXNlci5wdWJrZXksIHRoaXMuZ3JvdXBJZCk7XG4gICAgYWRkVXNlckV2ZW50Lm5kayA9IHRoaXMubmRrO1xuICAgIHJldHVybiBhZGRVc2VyRXZlbnQ7XG4gIH1cbiAgYXN5bmMgZ2V0TWVtYmVyTGlzdEV2ZW50KCkge1xuICAgIGNvbnN0IG1lbWJlckxpc3QgPSBhd2FpdCB0aGlzLm5kay5mZXRjaEV2ZW50KFxuICAgICAge1xuICAgICAgICBraW5kczogWzM5MDAyIC8qIEdyb3VwTWVtYmVycyAqL10sXG4gICAgICAgIFwiI2RcIjogW3RoaXMuZ3JvdXBJZF1cbiAgICAgIH0sXG4gICAgICB2b2lkIDAsXG4gICAgICB0aGlzLnJlbGF5U2V0XG4gICAgKTtcbiAgICBpZiAoIW1lbWJlckxpc3QpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBOREtTaW1wbGVHcm91cE1lbWJlckxpc3QuZnJvbShtZW1iZXJMaXN0KTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIGxpc3Qgb2YgdXNlcnMgdGhhdCBiZWxvbmcgdG8gdGhpcyBncm91cFxuICAgKi9cbiAgYXN5bmMgZ2V0TWVtYmVycygpIHtcbiAgICBjb25zdCBtZW1iZXJzID0gW107XG4gICAgY29uc3QgbWVtYmVyUHVia2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgbWVtYmVyTGlzdEV2ZW50ID0gYXdhaXQgdGhpcy5nZXRNZW1iZXJMaXN0RXZlbnQoKTtcbiAgICBpZiAoIW1lbWJlckxpc3RFdmVudCkgcmV0dXJuIFtdO1xuICAgIGZvciAoY29uc3QgcFRhZyBvZiBtZW1iZXJMaXN0RXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKSkge1xuICAgICAgY29uc3QgcHVia2V5ID0gcFRhZ1sxXTtcbiAgICAgIGlmIChtZW1iZXJQdWJrZXlzLmhhcyhwdWJrZXkpKSBjb250aW51ZTtcbiAgICAgIG1lbWJlclB1YmtleXMuYWRkKHB1YmtleSk7XG4gICAgICB0cnkge1xuICAgICAgICBtZW1iZXJzLnB1c2godGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleSB9KSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lbWJlcnM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBldmVudCB0aGF0IGxpc3RzIHRoZSBtZW1iZXJzIG9mIGEgZ3JvdXAuXG4gICAqIEBwYXJhbSBncm91cElkXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBzdGF0aWMgZ2VuZXJhdGVVc2VyTGlzdEV2ZW50KGdyb3VwSWQpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh2b2lkIDAsIHtcbiAgICAgIGtpbmQ6IDM5MDAyIC8qIEdyb3VwTWVtYmVycyAqLyxcbiAgICAgIHRhZ3M6IFtcbiAgICAgICAgW1wiaFwiLCBncm91cElkXSxcbiAgICAgICAgW1wiYWx0XCIsIFwiR3JvdXAgTWVtYmVyIExpc3RcIl1cbiAgICAgIF1cbiAgICB9KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBldmVudCB0aGF0IGFkZHMgYSB1c2VyIHRvIGEgZ3JvdXAuXG4gICAqIEBwYXJhbSB1c2VyUHVia2V5IHB1YmtleSBvZiB0aGUgdXNlciB0byBhZGRcbiAgICogQHBhcmFtIGdyb3VwSWQgZ3JvdXAgdG8gYWRkIHRoZSB1c2VyIHRvXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBzdGF0aWMgZ2VuZXJhdGVBZGRVc2VyRXZlbnQodXNlclB1YmtleSwgZ3JvdXBJZCkge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KHZvaWQgMCwge1xuICAgICAga2luZDogOWUzIC8qIEdyb3VwQWRtaW5BZGRVc2VyICovLFxuICAgICAgdGFnczogW1tcImhcIiwgZ3JvdXBJZF1dXG4gICAgfSk7XG4gICAgZXZlbnQudGFncy5wdXNoKFtcInBcIiwgdXNlclB1YmtleV0pO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICBhc3luYyByZXF1ZXN0VG9Kb2luKF9wdWJrZXksIGNvbnRlbnQpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywge1xuICAgICAga2luZDogOTAyMSAvKiBHcm91cEFkbWluUmVxdWVzdEpvaW4gKi8sXG4gICAgICBjb250ZW50OiBjb250ZW50ID8/IFwiXCIsXG4gICAgICB0YWdzOiBbW1wiaFwiLCB0aGlzLmdyb3VwSWRdXVxuICAgIH0pO1xuICAgIHJldHVybiBldmVudC5wdWJsaXNoKHRoaXMucmVsYXlTZXQpO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBzdXJlIHRoYXQgYSBtZXRhZGF0YSBldmVudCBleGlzdHMgbG9jYWxseVxuICAgKi9cbiAgYXN5bmMgZW5zdXJlTWV0YWRhdGFFdmVudCgpIHtcbiAgICBpZiAodGhpcy5tZXRhZGF0YSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmZldGNoaW5nTWV0YWRhdGEpIHJldHVybiB0aGlzLmZldGNoaW5nTWV0YWRhdGE7XG4gICAgdGhpcy5mZXRjaGluZ01ldGFkYXRhID0gdGhpcy5uZGsuZmV0Y2hFdmVudChcbiAgICAgIHtcbiAgICAgICAga2luZHM6IFszOWUzIC8qIEdyb3VwTWV0YWRhdGEgKi9dLFxuICAgICAgICBcIiNkXCI6IFt0aGlzLmdyb3VwSWRdXG4gICAgICB9LFxuICAgICAgdm9pZCAwLFxuICAgICAgdGhpcy5yZWxheVNldFxuICAgICkudGhlbigoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gTkRLU2ltcGxlR3JvdXBNZXRhZGF0YS5mcm9tKGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBuZXcgTkRLU2ltcGxlR3JvdXBNZXRhZGF0YSh0aGlzLm5kayk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuZFRhZyA9IHRoaXMuZ3JvdXBJZDtcbiAgICAgIH1cbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMuZmV0Y2hpbmdNZXRhZGF0YSA9IHZvaWQgMDtcbiAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBtZXRhZGF0YSBmb3IgZ3JvdXAgJHt0aGlzLmdyb3VwSWR9YCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hpbmdNZXRhZGF0YTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJhbmRvbUlkKGxlbmd0aCkge1xuICBjb25zdCBjaGFycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlcIjtcbiAgY29uc3QgY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGg7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IGNoYXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyc0xlbmd0aCkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy9hcHAtc2V0dGluZ3MvaW5kZXgudHNcbnZhciBOREtBcHBTZXR0aW5ncyA9IGNsYXNzIF9OREtBcHBTZXR0aW5ncyBleHRlbmRzIE5ES0V2ZW50IHtcbiAgYXBwTmFtZTtcbiAgc2V0dGluZ3MgPSB7fTtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzAwNzggLyogQXBwU3BlY2lmaWNEYXRhICovO1xuICAgIHRoaXMuZFRhZyA/Pz0gdGhpcy5hcHBOYW1lO1xuICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IEpTT04ucGFyc2UodGhpcy5jb250ZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwYXJzaW5nIGFwcCBzZXR0aW5nc1wiLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLQXBwU2V0dGluZ3MoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhIHZhbHVlIGZvciBhIGdpdmVuIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5zZXR0aW5nc1trZXldID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHZhbHVlIGZvciBhIGdpdmVuIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLnNldHRpbmdzW2tleV07XG4gIH1cbiAgYXN5bmMgcHVibGlzaFJlcGxhY2VhYmxlKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHRoaXMuc2V0dGluZ3MpO1xuICAgIHJldHVybiBzdXBlci5wdWJsaXNoUmVwbGFjZWFibGUocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KTtcbiAgfVxufTtcblxuLy8gc3JjL3JlbGF5L2F1dGgtcG9saWNpZXMudHNcbmltcG9ydCBjcmVhdGVEZWJ1ZzIgZnJvbSBcImRlYnVnXCI7XG5mdW5jdGlvbiBkaXNjb25uZWN0KHBvb2wsIGRlYnVnOCkge1xuICBkZWJ1ZzggPz89IGNyZWF0ZURlYnVnMihcIm5kazpyZWxheTphdXRoLXBvbGljaWVzOmRpc2Nvbm5lY3RcIik7XG4gIHJldHVybiBhc3luYyAocmVsYXkpID0+IHtcbiAgICBkZWJ1Zzg/LihgUmVsYXkgJHtyZWxheS51cmx9IHJlcXVlc3RlZCBhdXRoZW50aWNhdGlvbiwgZGlzY29ubmVjdGluZ2ApO1xuICAgIHBvb2wucmVtb3ZlUmVsYXkocmVsYXkudXJsKTtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25BbmRBdXRoKGV2ZW50LCByZWxheSwgc2lnbmVyLCBkZWJ1ZzgsIHJlc29sdmUsIHJlamVjdCkge1xuICB0cnkge1xuICAgIGF3YWl0IGV2ZW50LnNpZ24oc2lnbmVyKTtcbiAgICByZXNvbHZlKGV2ZW50KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnOD8uKGBGYWlsZWQgdG8gcHVibGlzaCBhdXRoIGV2ZW50IHRvIHJlbGF5ICR7cmVsYXkudXJsfWAsIGUpO1xuICAgIHJlamVjdChldmVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNpZ25Jbih7IG5kaywgc2lnbmVyLCBkZWJ1ZzogZGVidWc4IH0gPSB7fSkge1xuICBkZWJ1ZzggPz89IGNyZWF0ZURlYnVnMihcIm5kazphdXRoLXBvbGljaWVzOnNpZ25JblwiKTtcbiAgcmV0dXJuIGFzeW5jIChyZWxheSwgY2hhbGxlbmdlKSA9PiB7XG4gICAgZGVidWc4Py4oYFJlbGF5ICR7cmVsYXkudXJsfSByZXF1ZXN0ZWQgYXV0aGVudGljYXRpb24sIHNpZ25pbmcgaW5gKTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudChuZGspO1xuICAgIGV2ZW50LmtpbmQgPSAyMjI0MiAvKiBDbGllbnRBdXRoICovO1xuICAgIGV2ZW50LnRhZ3MgPSBbXG4gICAgICBbXCJyZWxheVwiLCByZWxheS51cmxdLFxuICAgICAgW1wiY2hhbGxlbmdlXCIsIGNoYWxsZW5nZV1cbiAgICBdO1xuICAgIHNpZ25lciA/Pz0gbmRrPy5zaWduZXI7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChzaWduZXIpIHtcbiAgICAgICAgYXdhaXQgc2lnbkFuZEF1dGgoZXZlbnQsIHJlbGF5LCBzaWduZXIsIGRlYnVnOCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5kaz8ub25jZShcInNpZ25lcjpyZWFkeVwiLCBhc3luYyAoc2lnbmVyMikgPT4ge1xuICAgICAgICAgIGF3YWl0IHNpZ25BbmRBdXRoKGV2ZW50LCByZWxheSwgc2lnbmVyMiwgZGVidWc4LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cbnZhciBOREtSZWxheUF1dGhQb2xpY2llcyA9IHtcbiAgZGlzY29ubmVjdCxcbiAgc2lnbkluXG59O1xuXG4vLyBzcmMvc2lnbmVycy9uaXAwNy9pbmRleC50c1xuaW1wb3J0IGRlYnVnNSBmcm9tIFwiZGVidWdcIjtcbnZhciBOREtOaXAwN1NpZ25lciA9IGNsYXNzIF9OREtOaXAwN1NpZ25lciB7XG4gIF91c2VyUHJvbWlzZTtcbiAgZW5jcnlwdGlvblF1ZXVlID0gW107XG4gIGVuY3J5cHRpb25Qcm9jZXNzaW5nID0gZmFsc2U7XG4gIGRlYnVnO1xuICB3YWl0VGltZW91dDtcbiAgX3B1YmtleTtcbiAgbmRrO1xuICBfdXNlcjtcbiAgLyoqXG4gICAqIEBwYXJhbSB3YWl0VGltZW91dCAtIFRoZSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciB0aGUgTklQLTA3IHRvIGJlY29tZSBhdmFpbGFibGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdhaXRUaW1lb3V0ID0gMWUzLCBuZGspIHtcbiAgICB0aGlzLmRlYnVnID0gZGVidWc1KFwibmRrOm5pcDA3XCIpO1xuICAgIHRoaXMud2FpdFRpbWVvdXQgPSB3YWl0VGltZW91dDtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgfVxuICBnZXQgcHVia2V5KCkge1xuICAgIGlmICghdGhpcy5fcHVia2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgcmVhZHlcIik7XG4gICAgcmV0dXJuIHRoaXMuX3B1YmtleTtcbiAgfVxuICBhc3luYyBibG9ja1VudGlsUmVhZHkoKSB7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3QgcHVia2V5ID0gYXdhaXQgd2luZG93Lm5vc3RyPy5nZXRQdWJsaWNLZXkoKTtcbiAgICBpZiAoIXB1YmtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlciByZWplY3RlZCBhY2Nlc3NcIik7XG4gICAgfVxuICAgIHRoaXMuX3B1YmtleSA9IHB1YmtleTtcbiAgICBsZXQgdXNlcjtcbiAgICBpZiAodGhpcy5uZGspIHVzZXIgPSB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5IH0pO1xuICAgIGVsc2UgdXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5IH0pO1xuICAgIHRoaXMuX3VzZXIgPSB1c2VyO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSB1c2VyIHByb3BlcnR5LlxuICAgKiBAcmV0dXJucyBUaGUgTkRLVXNlciBpbnN0YW5jZS5cbiAgICovXG4gIGFzeW5jIHVzZXIoKSB7XG4gICAgaWYgKCF0aGlzLl91c2VyUHJvbWlzZSkge1xuICAgICAgdGhpcy5fdXNlclByb21pc2UgPSB0aGlzLmJsb2NrVW50aWxSZWFkeSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdXNlclByb21pc2U7XG4gIH1cbiAgZ2V0IHVzZXJTeW5jKCkge1xuICAgIGlmICghdGhpcy5fdXNlcikgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBub3QgcmVhZHlcIik7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXI7XG4gIH1cbiAgLyoqXG4gICAqIFNpZ25zIHRoZSBnaXZlbiBOb3N0ciBldmVudC5cbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIE5vc3RyIGV2ZW50IHRvIGJlIHNpZ25lZC5cbiAgICogQHJldHVybnMgVGhlIHNpZ25hdHVyZSBvZiB0aGUgc2lnbmVkIGV2ZW50LlxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBOSVAtMDcgaXMgbm90IGF2YWlsYWJsZSBvbiB0aGUgd2luZG93IG9iamVjdC5cbiAgICovXG4gIGFzeW5jIHNpZ24oZXZlbnQpIHtcbiAgICBhd2FpdCB0aGlzLndhaXRGb3JFeHRlbnNpb24oKTtcbiAgICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IHdpbmRvdy5ub3N0cj8uc2lnbkV2ZW50KGV2ZW50KTtcbiAgICBpZiAoIXNpZ25lZEV2ZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gc2lnbiBldmVudFwiKTtcbiAgICByZXR1cm4gc2lnbmVkRXZlbnQuc2lnO1xuICB9XG4gIGFzeW5jIHJlbGF5cyhuZGspIHtcbiAgICBhd2FpdCB0aGlzLndhaXRGb3JFeHRlbnNpb24oKTtcbiAgICBjb25zdCByZWxheXMgPSBhd2FpdCB3aW5kb3cubm9zdHI/LmdldFJlbGF5cz8uKCkgfHwge307XG4gICAgY29uc3QgYWN0aXZlUmVsYXlzID0gW107XG4gICAgZm9yIChjb25zdCB1cmwgb2YgT2JqZWN0LmtleXMocmVsYXlzKSkge1xuICAgICAgaWYgKHJlbGF5c1t1cmxdLnJlYWQgJiYgcmVsYXlzW3VybF0ud3JpdGUpIHtcbiAgICAgICAgYWN0aXZlUmVsYXlzLnB1c2godXJsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZVJlbGF5cy5tYXAoKHVybCkgPT4gbmV3IE5ES1JlbGF5KHVybCwgbmRrPy5yZWxheUF1dGhEZWZhdWx0UG9saWN5LCBuZGspKTtcbiAgfVxuICBhc3luYyBlbmNyeXB0aW9uRW5hYmxlZChuaXApIHtcbiAgICBjb25zdCBlbmFibGVkID0gW107XG4gICAgaWYgKCghbmlwIHx8IG5pcCA9PT0gXCJuaXAwNFwiKSAmJiBCb29sZWFuKHdpbmRvdy5ub3N0cj8ubmlwMDQpKSBlbmFibGVkLnB1c2goXCJuaXAwNFwiKTtcbiAgICBpZiAoKCFuaXAgfHwgbmlwID09PSBcIm5pcDQ0XCIpICYmIEJvb2xlYW4od2luZG93Lm5vc3RyPy5uaXA0NCkpIGVuYWJsZWQucHVzaChcIm5pcDQ0XCIpO1xuICAgIHJldHVybiBlbmFibGVkO1xuICB9XG4gIGFzeW5jIGVuY3J5cHQocmVjaXBpZW50LCB2YWx1ZSwgbmlwID0gXCJuaXAwNFwiKSB7XG4gICAgaWYgKCFhd2FpdCB0aGlzLmVuY3J5cHRpb25FbmFibGVkKG5pcCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmlwfWVuY3J5cHRpb24gaXMgbm90IGF2YWlsYWJsZSBmcm9tIHlvdXIgYnJvd3NlciBleHRlbnNpb25gKTtcbiAgICBhd2FpdCB0aGlzLndhaXRGb3JFeHRlbnNpb24oKTtcbiAgICBjb25zdCByZWNpcGllbnRIZXhQdWJLZXkgPSByZWNpcGllbnQucHVia2V5O1xuICAgIHJldHVybiB0aGlzLnF1ZXVlRW5jcnlwdGlvbihuaXAsIFwiZW5jcnlwdFwiLCByZWNpcGllbnRIZXhQdWJLZXksIHZhbHVlKTtcbiAgfVxuICBhc3luYyBkZWNyeXB0KHNlbmRlciwgdmFsdWUsIG5pcCA9IFwibmlwMDRcIikge1xuICAgIGlmICghYXdhaXQgdGhpcy5lbmNyeXB0aW9uRW5hYmxlZChuaXApKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25pcH1lbmNyeXB0aW9uIGlzIG5vdCBhdmFpbGFibGUgZnJvbSB5b3VyIGJyb3dzZXIgZXh0ZW5zaW9uYCk7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3Qgc2VuZGVySGV4UHViS2V5ID0gc2VuZGVyLnB1YmtleTtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZUVuY3J5cHRpb24obmlwLCBcImRlY3J5cHRcIiwgc2VuZGVySGV4UHViS2V5LCB2YWx1ZSk7XG4gIH1cbiAgYXN5bmMgcXVldWVFbmNyeXB0aW9uKHNjaGVtZSwgbWV0aG9kLCBjb3VudGVycGFydHlIZXhwdWJrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblF1ZXVlLnB1c2goe1xuICAgICAgICBzY2hlbWUsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgY291bnRlcnBhcnR5SGV4cHVia2V5LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0XG4gICAgICB9KTtcbiAgICAgIGlmICghdGhpcy5lbmNyeXB0aW9uUHJvY2Vzc2luZykge1xuICAgICAgICB0aGlzLnByb2Nlc3NFbmNyeXB0aW9uUXVldWUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBwcm9jZXNzRW5jcnlwdGlvblF1ZXVlKGl0ZW0sIHJldHJpZXMgPSAwKSB7XG4gICAgaWYgKCFpdGVtICYmIHRoaXMuZW5jcnlwdGlvblF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5lbmNyeXB0aW9uUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVuY3J5cHRpb25Qcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICBjb25zdCBjdXJyZW50SXRlbSA9IGl0ZW0gfHwgdGhpcy5lbmNyeXB0aW9uUXVldWUuc2hpZnQoKTtcbiAgICBpZiAoIWN1cnJlbnRJdGVtKSB7XG4gICAgICB0aGlzLmVuY3J5cHRpb25Qcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgc2NoZW1lLCBtZXRob2QsIGNvdW50ZXJwYXJ0eUhleHB1YmtleSwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCB9ID0gY3VycmVudEl0ZW07XG4gICAgdGhpcy5kZWJ1ZyhcIlByb2Nlc3NpbmcgZW5jcnlwdGlvbiBxdWV1ZSBpdGVtXCIsIHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIGNvdW50ZXJwYXJ0eUhleHB1YmtleSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdpbmRvdy5ub3N0cj8uW3NjaGVtZV0/LlttZXRob2RdKGNvdW50ZXJwYXJ0eUhleHB1YmtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFyZXN1bHQpIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBlbmNyeXB0L2RlY3J5cHRcIik7XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgIGlmIChlcnJvck1lc3NhZ2UuaW5jbHVkZXMoXCJjYWxsIGFscmVhZHkgZXhlY3V0aW5nXCIpICYmIHJldHJpZXMgPCA1KSB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJSZXRyeWluZyBlbmNyeXB0aW9uIHF1ZXVlIGl0ZW1cIiwge1xuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICBjb3VudGVycGFydHlIZXhwdWJrZXksXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgcmV0cmllc1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5wcm9jZXNzRW5jcnlwdGlvblF1ZXVlKGN1cnJlbnRJdGVtLCByZXRyaWVzICsgMSk7XG4gICAgICAgIH0sIDUwICogcmV0cmllcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlamVjdChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSk7XG4gICAgfVxuICAgIHRoaXMucHJvY2Vzc0VuY3J5cHRpb25RdWV1ZSgpO1xuICB9XG4gIHdhaXRGb3JFeHRlbnNpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh3aW5kb3cubm9zdHIpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgdGltZXJJZDtcbiAgICAgIGNvbnN0IGludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmICh3aW5kb3cubm9zdHIpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMCk7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJOSVAtMDcgZXh0ZW5zaW9uIG5vdCBhdmFpbGFibGVcIikpO1xuICAgICAgfSwgdGhpcy53YWl0VGltZW91dCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIHNpZ25lciB0eXBlIGludG8gYSBzdG9yYWJsZSBmb3JtYXQuXG4gICAqIE5JUC0wNyBzaWduZXJzIGRvbid0IGhhdmUgcGVyc2lzdGVudCBzdGF0ZSB0byBzZXJpYWxpemUgYmV5b25kIHRoZWlyIHR5cGUuXG4gICAqIEByZXR1cm5zIEEgSlNPTiBzdHJpbmcgY29udGFpbmluZyB0aGUgdHlwZS5cbiAgICovXG4gIHRvUGF5bG9hZCgpIHtcbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgdHlwZTogXCJuaXAwN1wiLFxuICAgICAgcGF5bG9hZDogXCJcIlxuICAgICAgLy8gTm8gc3BlY2lmaWMgcGF5bG9hZCBuZWVkZWQgZm9yIE5JUC0wN1xuICAgIH07XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICB9XG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgdGhlIHNpZ25lciBmcm9tIGEgcGF5bG9hZCBzdHJpbmcuXG4gICAqIENyZWF0ZXMgYSBuZXcgTkRLTmlwMDdTaWduZXIgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBwYXlsb2FkU3RyaW5nIFRoZSBKU09OIHN0cmluZyBvYnRhaW5lZCBmcm9tIHRvUGF5bG9hZCgpLlxuICAgKiBAcGFyYW0gbmRrIE9wdGlvbmFsIE5ESyBpbnN0YW5jZS5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgTkRLTmlwMDdTaWduZXIuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZnJvbVBheWxvYWQocGF5bG9hZFN0cmluZywgbmRrKSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UocGF5bG9hZFN0cmluZyk7XG4gICAgaWYgKHBheWxvYWQudHlwZSAhPT0gXCJuaXAwN1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGF5bG9hZCB0eXBlOiBleHBlY3RlZCAnbmlwMDcnLCBnb3QgJHtwYXlsb2FkLnR5cGV9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX05ES05pcDA3U2lnbmVyKHZvaWQgMCwgbmRrKTtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9pbmRleC50c1xuaW1wb3J0IHsgaGV4VG9CeXRlcyBhcyBoZXhUb0J5dGVzMiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L3JwYy50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjUgfSBmcm9tIFwidHNlZXBcIjtcbnZhciBOREtOb3N0clJwYyA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyNSB7XG4gIG5kaztcbiAgc2lnbmVyO1xuICByZWxheVNldDtcbiAgZGVidWc7XG4gIGVuY3J5cHRpb25UeXBlID0gXCJuaXAwNFwiO1xuICBwb29sO1xuICBjb25zdHJ1Y3RvcihuZGssIHNpZ25lciwgZGVidWc4LCByZWxheVVybHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMuc2lnbmVyID0gc2lnbmVyO1xuICAgIGlmIChyZWxheVVybHMpIHtcbiAgICAgIHRoaXMucG9vbCA9IG5ldyBOREtQb29sKHJlbGF5VXJscywgW10sIG5kaywge1xuICAgICAgICBkZWJ1ZzogZGVidWc4LmV4dGVuZChcInJwYy1wb29sXCIpLFxuICAgICAgICBuYW1lOiBcIk5vc3RyIFJQQ1wiXG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVsYXlTZXQgPSBuZXcgTkRLUmVsYXlTZXQoLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgbmRrLCB0aGlzLnBvb2wpO1xuICAgICAgZm9yIChjb25zdCB1cmwgb2YgcmVsYXlVcmxzKSB7XG4gICAgICAgIGNvbnN0IHJlbGF5ID0gdGhpcy5wb29sLmdldFJlbGF5KHVybCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgcmVsYXkuYXV0aFBvbGljeSA9IE5ES1JlbGF5QXV0aFBvbGljaWVzLnNpZ25Jbih7IG5kaywgc2lnbmVyLCBkZWJ1ZzogZGVidWc4IH0pO1xuICAgICAgICB0aGlzLnJlbGF5U2V0LmFkZFJlbGF5KHJlbGF5KTtcbiAgICAgICAgcmVsYXkuY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRlYnVnID0gZGVidWc4LmV4dGVuZChcInJwY1wiKTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIGEgZmlsdGVyLiBUaGlzIGZ1bmN0aW9uIHdpbGwgcmVzb2x2ZSBvbmNlIHRoZSBzdWJzY3JpcHRpb24gaXMgcmVhZHkuXG4gICAqL1xuICBzdWJzY3JpYmUoZmlsdGVyKSB7XG4gICAgY29uc3Qgc3ViID0gdGhpcy5uZGsuc3Vic2NyaWJlKFxuICAgICAgZmlsdGVyLFxuICAgICAge1xuICAgICAgICBjbG9zZU9uRW9zZTogZmFsc2UsXG4gICAgICAgIGdyb3VwYWJsZTogZmFsc2UsXG4gICAgICAgIGNhY2hlVXNhZ2U6IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi8sXG4gICAgICAgIHBvb2w6IHRoaXMucG9vbCxcbiAgICAgICAgcmVsYXlTZXQ6IHRoaXMucmVsYXlTZXRcbiAgICAgIH0sXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgc3ViLm9uKFwiZXZlbnRcIiwgYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWRFdmVudCA9IGF3YWl0IHRoaXMucGFyc2VFdmVudChldmVudCk7XG4gICAgICAgIGlmIChwYXJzZWRFdmVudC5tZXRob2QpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJyZXF1ZXN0XCIsIHBhcnNlZEV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVtaXQoYHJlc3BvbnNlLSR7cGFyc2VkRXZlbnQuaWR9YCwgcGFyc2VkRXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJlcnJvciBwYXJzaW5nIGV2ZW50XCIsIGUsIGV2ZW50LnJhd0V2ZW50KCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgc3ViLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJlb3NlZFwiKTtcbiAgICAgICAgcmVzb2x2ZShzdWIpO1xuICAgICAgfSk7XG4gICAgICBzdWIuc3RhcnQoKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBwYXJzZUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZW5jcnlwdGlvblR5cGUgPT09IFwibmlwNDRcIiAmJiBldmVudC5jb250ZW50LmluY2x1ZGVzKFwiP2l2PVwiKSkge1xuICAgICAgdGhpcy5lbmNyeXB0aW9uVHlwZSA9IFwibmlwMDRcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZW5jcnlwdGlvblR5cGUgPT09IFwibmlwMDRcIiAmJiAhZXZlbnQuY29udGVudC5pbmNsdWRlcyhcIj9pdj1cIikpIHtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblR5cGUgPSBcIm5pcDQ0XCI7XG4gICAgfVxuICAgIGNvbnN0IHJlbW90ZVVzZXIgPSB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5OiBldmVudC5wdWJrZXkgfSk7XG4gICAgcmVtb3RlVXNlci5uZGsgPSB0aGlzLm5kaztcbiAgICBsZXQgZGVjcnlwdGVkQ29udGVudDtcbiAgICB0cnkge1xuICAgICAgZGVjcnlwdGVkQ29udGVudCA9IGF3YWl0IHRoaXMuc2lnbmVyLmRlY3J5cHQocmVtb3RlVXNlciwgZXZlbnQuY29udGVudCwgdGhpcy5lbmNyeXB0aW9uVHlwZSk7XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgIGNvbnN0IG90aGVyRW5jcnlwdGlvblR5cGUgPSB0aGlzLmVuY3J5cHRpb25UeXBlID09PSBcIm5pcDA0XCIgPyBcIm5pcDQ0XCIgOiBcIm5pcDA0XCI7XG4gICAgICBkZWNyeXB0ZWRDb250ZW50ID0gYXdhaXQgdGhpcy5zaWduZXIuZGVjcnlwdChyZW1vdGVVc2VyLCBldmVudC5jb250ZW50LCBvdGhlckVuY3J5cHRpb25UeXBlKTtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblR5cGUgPSBvdGhlckVuY3J5cHRpb25UeXBlO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRDb250ZW50ID0gSlNPTi5wYXJzZShkZWNyeXB0ZWRDb250ZW50KTtcbiAgICBjb25zdCB7IGlkLCBtZXRob2QsIHBhcmFtcywgcmVzdWx0LCBlcnJvciB9ID0gcGFyc2VkQ29udGVudDtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICByZXR1cm4geyBpZCwgcHVia2V5OiBldmVudC5wdWJrZXksIG1ldGhvZCwgcGFyYW1zLCBldmVudCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBpZCwgcmVzdWx0LCBlcnJvciwgZXZlbnQgfTtcbiAgfVxuICBhc3luYyBzZW5kUmVzcG9uc2UoaWQsIHJlbW90ZVB1YmtleSwgcmVzdWx0LCBraW5kID0gMjQxMzMgLyogTm9zdHJDb25uZWN0ICovLCBlcnJvcikge1xuICAgIGNvbnN0IHJlcyA9IHsgaWQsIHJlc3VsdCB9O1xuICAgIGlmIChlcnJvcikge1xuICAgICAgcmVzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGxvY2FsVXNlciA9IGF3YWl0IHRoaXMuc2lnbmVyLnVzZXIoKTtcbiAgICBjb25zdCByZW1vdGVVc2VyID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogcmVtb3RlUHVia2V5IH0pO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KHRoaXMubmRrLCB7XG4gICAgICBraW5kLFxuICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkocmVzKSxcbiAgICAgIHRhZ3M6IFtbXCJwXCIsIHJlbW90ZVB1YmtleV1dLFxuICAgICAgcHVia2V5OiBsb2NhbFVzZXIucHVia2V5XG4gICAgfSk7XG4gICAgZXZlbnQuY29udGVudCA9IGF3YWl0IHRoaXMuc2lnbmVyLmVuY3J5cHQocmVtb3RlVXNlciwgZXZlbnQuY29udGVudCwgdGhpcy5lbmNyeXB0aW9uVHlwZSk7XG4gICAgYXdhaXQgZXZlbnQuc2lnbih0aGlzLnNpZ25lcik7XG4gICAgYXdhaXQgZXZlbnQucHVibGlzaCh0aGlzLnJlbGF5U2V0KTtcbiAgfVxuICAvKipcbiAgICogU2VuZHMgYSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gcmVtb3RlUHVia2V5XG4gICAqIEBwYXJhbSBtZXRob2RcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0ga2luZFxuICAgKiBAcGFyYW0gaWRcbiAgICovXG4gIGFzeW5jIHNlbmRSZXF1ZXN0KHJlbW90ZVB1YmtleSwgbWV0aG9kLCBwYXJhbXMgPSBbXSwga2luZCA9IDI0MTMzLCBjYikge1xuICAgIGNvbnN0IGlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpO1xuICAgIGNvbnN0IGxvY2FsVXNlciA9IGF3YWl0IHRoaXMuc2lnbmVyLnVzZXIoKTtcbiAgICBjb25zdCByZW1vdGVVc2VyID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogcmVtb3RlUHVia2V5IH0pO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7IGlkLCBtZXRob2QsIHBhcmFtcyB9O1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoKSA9PiB7XG4gICAgICBjb25zdCByZXNwb25zZUhhbmRsZXIgPSAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnJlc3VsdCA9PT0gXCJhdXRoX3VybFwiKSB7XG4gICAgICAgICAgdGhpcy5vbmNlKGByZXNwb25zZS0ke2lkfWAsIHJlc3BvbnNlSGFuZGxlcik7XG4gICAgICAgICAgdGhpcy5lbWl0KFwiYXV0aFVybFwiLCByZXNwb25zZS5lcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgICAgICBjYihyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLm9uY2UoYHJlc3BvbnNlLSR7aWR9YCwgcmVzcG9uc2VIYW5kbGVyKTtcbiAgICB9KTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywge1xuICAgICAga2luZCxcbiAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLFxuICAgICAgdGFnczogW1tcInBcIiwgcmVtb3RlUHVia2V5XV0sXG4gICAgICBwdWJrZXk6IGxvY2FsVXNlci5wdWJrZXlcbiAgICB9KTtcbiAgICBldmVudC5jb250ZW50ID0gYXdhaXQgdGhpcy5zaWduZXIuZW5jcnlwdChyZW1vdGVVc2VyLCBldmVudC5jb250ZW50LCB0aGlzLmVuY3J5cHRpb25UeXBlKTtcbiAgICBhd2FpdCBldmVudC5zaWduKHRoaXMuc2lnbmVyKTtcbiAgICBhd2FpdCBldmVudC5wdWJsaXNoKHRoaXMucmVsYXlTZXQpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL2Nvbm5lY3QudHNcbnZhciBDb25uZWN0RXZlbnRIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gICAgY29uc3QgW18sIHRva2VuXSA9IHBhcmFtcztcbiAgICBjb25zdCBkZWJ1ZzggPSBiYWNrZW5kLmRlYnVnLmV4dGVuZChcImNvbm5lY3RcIik7XG4gICAgZGVidWc4KGBjb25uZWN0aW9uIHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX1gKTtcbiAgICBpZiAodG9rZW4gJiYgYmFja2VuZC5hcHBseVRva2VuKSB7XG4gICAgICBkZWJ1ZzgoXCJhcHBseWluZyB0b2tlblwiKTtcbiAgICAgIGF3YWl0IGJhY2tlbmQuYXBwbHlUb2tlbihyZW1vdGVQdWJrZXksIHRva2VuKTtcbiAgICB9XG4gICAgaWYgKGF3YWl0IGJhY2tlbmQucHVia2V5QWxsb3dlZCh7XG4gICAgICBpZCxcbiAgICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgICAgbWV0aG9kOiBcImNvbm5lY3RcIixcbiAgICAgIHBhcmFtczogdG9rZW5cbiAgICB9KSkge1xuICAgICAgZGVidWc4KGBjb25uZWN0aW9uIHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gYWxsb3dlZGApO1xuICAgICAgcmV0dXJuIFwiYWNrXCI7XG4gICAgfVxuICAgIGRlYnVnOChgY29ubmVjdGlvbiByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9nZXQtcHVibGljLWtleS50c1xudmFyIEdldFB1YmxpY0tleUhhbmRsaW5nU3RyYXRlZ3kgPSBjbGFzcyB7XG4gIGFzeW5jIGhhbmRsZShiYWNrZW5kLCBfaWQsIF9yZW1vdGVQdWJrZXksIF9wYXJhbXMpIHtcbiAgICByZXR1cm4gYmFja2VuZC5sb2NhbFVzZXI/LnB1YmtleTtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9uaXAwNC1kZWNyeXB0LnRzXG52YXIgTmlwMDREZWNyeXB0SGFuZGxpbmdTdHJhdGVneSA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtzZW5kZXJQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHNlbmRlclVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogc2VuZGVyUHVia2V5IH0pO1xuICAgIGNvbnN0IGRlY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBkZWNyeXB0MihiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBzZW5kZXJVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZGVjcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQyKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHNlbmRlclVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXAwNF9kZWNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZGVjcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZGVjcnlwdChzZW5kZXJVc2VyLCBwYXlsb2FkLCBcIm5pcDA0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL25pcDA0LWVuY3J5cHQudHNcbnZhciBOaXAwNEVuY3J5cHRIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gICAgY29uc3QgW3JlY2lwaWVudFB1YmtleSwgcGF5bG9hZF0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVjaXBpZW50VXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiByZWNpcGllbnRQdWJrZXkgfSk7XG4gICAgY29uc3QgZW5jcnlwdGVkUGF5bG9hZCA9IGF3YWl0IGVuY3J5cHQyKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHJlY2lwaWVudFVzZXIsIHBheWxvYWQpO1xuICAgIHJldHVybiBlbmNyeXB0ZWRQYXlsb2FkO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdDIoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcmVjaXBpZW50VXNlciwgcGF5bG9hZCkge1xuICBpZiAoIWF3YWl0IGJhY2tlbmQucHVia2V5QWxsb3dlZCh7XG4gICAgaWQsXG4gICAgcHVia2V5OiByZW1vdGVQdWJrZXksXG4gICAgbWV0aG9kOiBcIm5pcDA0X2VuY3J5cHRcIixcbiAgICBwYXJhbXM6IHBheWxvYWRcbiAgfSkpIHtcbiAgICBiYWNrZW5kLmRlYnVnKGBlbmNyeXB0IHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gcmVqZWN0ZWRgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBhd2FpdCBiYWNrZW5kLnNpZ25lci5lbmNyeXB0KHJlY2lwaWVudFVzZXIsIHBheWxvYWQsIFwibmlwMDRcIik7XG59XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvbmlwNDQtZGVjcnlwdC50c1xudmFyIE5pcDA0RGVjcnlwdEhhbmRsaW5nU3RyYXRlZ3kyID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gICAgY29uc3QgW3NlbmRlclB1YmtleSwgcGF5bG9hZF0gPSBwYXJhbXM7XG4gICAgY29uc3Qgc2VuZGVyVXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBzZW5kZXJQdWJrZXkgfSk7XG4gICAgY29uc3QgZGVjcnlwdGVkUGF5bG9hZCA9IGF3YWl0IGRlY3J5cHQzKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHNlbmRlclVzZXIsIHBheWxvYWQpO1xuICAgIHJldHVybiBkZWNyeXB0ZWRQYXlsb2FkO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdDMoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgc2VuZGVyVXNlciwgcGF5bG9hZCkge1xuICBpZiAoIWF3YWl0IGJhY2tlbmQucHVia2V5QWxsb3dlZCh7XG4gICAgaWQsXG4gICAgcHVia2V5OiByZW1vdGVQdWJrZXksXG4gICAgbWV0aG9kOiBcIm5pcDQ0X2RlY3J5cHRcIixcbiAgICBwYXJhbXM6IHBheWxvYWRcbiAgfSkpIHtcbiAgICBiYWNrZW5kLmRlYnVnKGBkZWNyeXB0IHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gcmVqZWN0ZWRgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBhd2FpdCBiYWNrZW5kLnNpZ25lci5kZWNyeXB0KHNlbmRlclVzZXIsIHBheWxvYWQsIFwibmlwNDRcIik7XG59XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvbmlwNDQtZW5jcnlwdC50c1xudmFyIE5pcDA0RW5jcnlwdEhhbmRsaW5nU3RyYXRlZ3kyID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gICAgY29uc3QgW3JlY2lwaWVudFB1YmtleSwgcGF5bG9hZF0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVjaXBpZW50VXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiByZWNpcGllbnRQdWJrZXkgfSk7XG4gICAgY29uc3QgZW5jcnlwdGVkUGF5bG9hZCA9IGF3YWl0IGVuY3J5cHQzKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHJlY2lwaWVudFVzZXIsIHBheWxvYWQpO1xuICAgIHJldHVybiBlbmNyeXB0ZWRQYXlsb2FkO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdDMoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcmVjaXBpZW50VXNlciwgcGF5bG9hZCkge1xuICBpZiAoIWF3YWl0IGJhY2tlbmQucHVia2V5QWxsb3dlZCh7XG4gICAgaWQsXG4gICAgcHVia2V5OiByZW1vdGVQdWJrZXksXG4gICAgbWV0aG9kOiBcIm5pcDQ0X2VuY3J5cHRcIixcbiAgICBwYXJhbXM6IHBheWxvYWRcbiAgfSkpIHtcbiAgICBiYWNrZW5kLmRlYnVnKGBlbmNyeXB0IHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gcmVqZWN0ZWRgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBhd2FpdCBiYWNrZW5kLnNpZ25lci5lbmNyeXB0KHJlY2lwaWVudFVzZXIsIHBheWxvYWQsIFwibmlwNDRcIik7XG59XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvcGluZy50c1xudmFyIFBpbmdFdmVudEhhbmRsaW5nU3RyYXRlZ3kgPSBjbGFzcyB7XG4gIGFzeW5jIGhhbmRsZShiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBfcGFyYW1zKSB7XG4gICAgY29uc3QgZGVidWc4ID0gYmFja2VuZC5kZWJ1Zy5leHRlbmQoXCJwaW5nXCIpO1xuICAgIGRlYnVnOChgcGluZyByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9YCk7XG4gICAgaWYgKGF3YWl0IGJhY2tlbmQucHVia2V5QWxsb3dlZCh7IGlkLCBwdWJrZXk6IHJlbW90ZVB1YmtleSwgbWV0aG9kOiBcInBpbmdcIiB9KSkge1xuICAgICAgZGVidWc4KGBjb25uZWN0aW9uIHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gYWxsb3dlZGApO1xuICAgICAgcmV0dXJuIFwicG9uZ1wiO1xuICAgIH1cbiAgICBkZWJ1ZzgoYGNvbm5lY3Rpb24gcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSByZWplY3RlZGApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvc2lnbi1ldmVudC50c1xudmFyIFNpZ25FdmVudEhhbmRsaW5nU3RyYXRlZ3kgPSBjbGFzcyB7XG4gIGFzeW5jIGhhbmRsZShiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBwYXJhbXMpIHtcbiAgICBjb25zdCBldmVudCA9IGF3YWl0IHNpZ25FdmVudChiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBwYXJhbXMpO1xuICAgIGlmICghZXZlbnQpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGF3YWl0IGV2ZW50LnRvTm9zdHJFdmVudCgpKTtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIHNpZ25FdmVudChiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBwYXJhbXMpIHtcbiAgY29uc3QgW2V2ZW50U3RyaW5nXSA9IHBhcmFtcztcbiAgYmFja2VuZC5kZWJ1Zyhgc2lnbiBldmVudCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9YCk7XG4gIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KGJhY2tlbmQubmRrLCBKU09OLnBhcnNlKGV2ZW50U3RyaW5nKSk7XG4gIGJhY2tlbmQuZGVidWcoXCJldmVudCB0byBzaWduXCIsIGV2ZW50LnJhd0V2ZW50KCkpO1xuICBpZiAoIWF3YWl0IGJhY2tlbmQucHVia2V5QWxsb3dlZCh7XG4gICAgaWQsXG4gICAgcHVia2V5OiByZW1vdGVQdWJrZXksXG4gICAgbWV0aG9kOiBcInNpZ25fZXZlbnRcIixcbiAgICBwYXJhbXM6IGV2ZW50XG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1Zyhgc2lnbiBldmVudCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBiYWNrZW5kLmRlYnVnKGBzaWduIGV2ZW50IHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gYWxsb3dlZGApO1xuICBhd2FpdCBldmVudC5zaWduKGJhY2tlbmQuc2lnbmVyKTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL2luZGV4LnRzXG52YXIgTkRLTmlwNDZCYWNrZW5kID0gY2xhc3Mge1xuICBuZGs7XG4gIHNpZ25lcjtcbiAgbG9jYWxVc2VyO1xuICBkZWJ1ZztcbiAgcnBjO1xuICBwZXJtaXRDYWxsYmFjaztcbiAgcmVsYXlVcmxzO1xuICAvKipcbiAgICogQHBhcmFtIG5kayBUaGUgTkRLIGluc3RhbmNlIHRvIHVzZVxuICAgKiBAcGFyYW0gcHJpdmF0ZUtleU9yU2lnbmVyIFRoZSBwcml2YXRlIGtleSBvciBzaWduZXIgb2YgdGhlIG5wdWIgdGhhdCB3YW50cyB0byBiZSBwdWJsaXNoZWQgYXNcbiAgICogQHBhcmFtIHBlcm1pdENhbGxiYWNrIENhbGxiYWNrIGV4ZWN1dGVkIHdoZW4gcGVybWlzc2lvbiBpcyByZXF1ZXN0ZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKG5kaywgcHJpdmF0ZUtleU9yU2lnbmVyLCBwZXJtaXRDYWxsYmFjaywgcmVsYXlVcmxzKSB7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgaWYgKHByaXZhdGVLZXlPclNpZ25lciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHRoaXMuc2lnbmVyID0gbmV3IE5ES1ByaXZhdGVLZXlTaWduZXIocHJpdmF0ZUtleU9yU2lnbmVyKTtcbiAgICB9IGVsc2UgaWYgKHByaXZhdGVLZXlPclNpZ25lciBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgdGhpcy5zaWduZXIgPSBuZXcgTkRLUHJpdmF0ZUtleVNpZ25lcihoZXhUb0J5dGVzMihwcml2YXRlS2V5T3JTaWduZXIpKTtcbiAgICB9IGVsc2UgaWYgKHByaXZhdGVLZXlPclNpZ25lciBpbnN0YW5jZW9mIE5ES1ByaXZhdGVLZXlTaWduZXIpIHtcbiAgICAgIHRoaXMuc2lnbmVyID0gcHJpdmF0ZUtleU9yU2lnbmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNpZ25lclwiKTtcbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyA9IG5kay5kZWJ1Zy5leHRlbmQoXCJuaXA0NjpiYWNrZW5kXCIpO1xuICAgIHRoaXMucmVsYXlVcmxzID0gcmVsYXlVcmxzID8/IEFycmF5LmZyb20obmRrLnBvb2wucmVsYXlzLmtleXMoKSk7XG4gICAgdGhpcy5ycGMgPSBuZXcgTkRLTm9zdHJScGMobmRrLCB0aGlzLnNpZ25lciwgdGhpcy5kZWJ1ZywgdGhpcy5yZWxheVVybHMpO1xuICAgIHRoaXMucGVybWl0Q2FsbGJhY2sgPSBwZXJtaXRDYWxsYmFjaztcbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgc3RhcnRzIHRoZSBiYWNrZW5kLCB3aGljaCB3aWxsIHN0YXJ0IGxpc3RlbmluZyBmb3IgaW5jb21pbmdcbiAgICogcmVxdWVzdHMuXG4gICAqL1xuICBhc3luYyBzdGFydCgpIHtcbiAgICB0aGlzLmxvY2FsVXNlciA9IGF3YWl0IHRoaXMuc2lnbmVyLnVzZXIoKTtcbiAgICBjb25zdCBzdWIgPSB0aGlzLm5kay5zdWJzY3JpYmUoXG4gICAgICB7XG4gICAgICAgIGtpbmRzOiBbMjQxMzNdLFxuICAgICAgICBcIiNwXCI6IFt0aGlzLmxvY2FsVXNlci5wdWJrZXldXG4gICAgICB9LFxuICAgICAgeyBjbG9zZU9uRW9zZTogZmFsc2UgfVxuICAgICk7XG4gICAgc3ViLm9uKFwiZXZlbnRcIiwgKGUpID0+IHRoaXMuaGFuZGxlSW5jb21pbmdFdmVudChlKSk7XG4gIH1cbiAgaGFuZGxlcnMgPSB7XG4gICAgY29ubmVjdDogbmV3IENvbm5lY3RFdmVudEhhbmRsaW5nU3RyYXRlZ3koKSxcbiAgICBzaWduX2V2ZW50OiBuZXcgU2lnbkV2ZW50SGFuZGxpbmdTdHJhdGVneSgpLFxuICAgIG5pcDA0X2VuY3J5cHQ6IG5ldyBOaXAwNEVuY3J5cHRIYW5kbGluZ1N0cmF0ZWd5KCksXG4gICAgbmlwMDRfZGVjcnlwdDogbmV3IE5pcDA0RGVjcnlwdEhhbmRsaW5nU3RyYXRlZ3koKSxcbiAgICBuaXA0NF9lbmNyeXB0OiBuZXcgTmlwMDRFbmNyeXB0SGFuZGxpbmdTdHJhdGVneTIoKSxcbiAgICBuaXA0NF9kZWNyeXB0OiBuZXcgTmlwMDREZWNyeXB0SGFuZGxpbmdTdHJhdGVneTIoKSxcbiAgICBnZXRfcHVibGljX2tleTogbmV3IEdldFB1YmxpY0tleUhhbmRsaW5nU3RyYXRlZ3koKSxcbiAgICBwaW5nOiBuZXcgUGluZ0V2ZW50SGFuZGxpbmdTdHJhdGVneSgpXG4gIH07XG4gIC8qKlxuICAgKiBFbmFibGVzIHRoZSB1c2VyIHRvIHNldCBhIGN1c3RvbSBzdHJhdGVneSBmb3IgaGFuZGxpbmcgaW5jb21pbmcgZXZlbnRzLlxuICAgKiBAcGFyYW0gbWV0aG9kIC0gVGhlIG1ldGhvZCB0byBzZXQgdGhlIHN0cmF0ZWd5IGZvclxuICAgKiBAcGFyYW0gc3RyYXRlZ3kgLSBUaGUgc3RyYXRlZ3kgdG8gc2V0XG4gICAqL1xuICBzZXRTdHJhdGVneShtZXRob2QsIHN0cmF0ZWd5KSB7XG4gICAgdGhpcy5oYW5kbGVyc1ttZXRob2RdID0gc3RyYXRlZ3k7XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJsb2FkIHRoaXMgbWV0aG9kIHRvIGFwcGx5IHRva2Vucywgd2hpY2ggY2FuXG4gICAqIHdyYXAgcGVybWlzc2lvbiBzZXRzIHRvIGJlIGFwcGxpZWQgdG8gYSBwdWJrZXkuXG4gICAqIEBwYXJhbSBwdWJrZXkgcHVibGljIGtleSB0byBhcHBseSB0b2tlbiB0b1xuICAgKiBAcGFyYW0gdG9rZW4gdG9rZW4gdG8gYXBwbHlcbiAgICovXG4gIGFzeW5jIGFwcGx5VG9rZW4oX3B1YmtleSwgX3Rva2VuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29ubmVjdGlvbiB0b2tlbiBub3Qgc3VwcG9ydGVkXCIpO1xuICB9XG4gIGFzeW5jIGhhbmRsZUluY29taW5nRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCB7IGlkLCBtZXRob2QsIHBhcmFtcyB9ID0gYXdhaXQgdGhpcy5ycGMucGFyc2VFdmVudChldmVudCk7XG4gICAgY29uc3QgcmVtb3RlUHVia2V5ID0gZXZlbnQucHVia2V5O1xuICAgIGxldCByZXNwb25zZTtcbiAgICB0aGlzLmRlYnVnKFwiaW5jb21pbmcgZXZlbnRcIiwgeyBpZCwgbWV0aG9kLCBwYXJhbXMgfSk7XG4gICAgaWYgKCFldmVudC52ZXJpZnlTaWduYXR1cmUoZmFsc2UpKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiaW52YWxpZCBzaWduYXR1cmVcIiwgZXZlbnQucmF3RXZlbnQoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0cmF0ZWd5ID0gdGhpcy5oYW5kbGVyc1ttZXRob2RdO1xuICAgIGlmIChzdHJhdGVneSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBzdHJhdGVneS5oYW5kbGUodGhpcywgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcImVycm9yIGhhbmRsaW5nIGV2ZW50XCIsIGUsIHsgaWQsIG1ldGhvZCwgcGFyYW1zIH0pO1xuICAgICAgICB0aGlzLnJwYy5zZW5kUmVzcG9uc2UoaWQsIHJlbW90ZVB1YmtleSwgXCJlcnJvclwiLCB2b2lkIDAsIGUubWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVidWcoXCJ1bnN1cHBvcnRlZCBtZXRob2RcIiwgeyBtZXRob2QsIHBhcmFtcyB9KTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICB0aGlzLmRlYnVnKGBzZW5kaW5nIHJlc3BvbnNlIHRvICR7cmVtb3RlUHVia2V5fWAsIHJlc3BvbnNlKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXNwb25zZShpZCwgcmVtb3RlUHVia2V5LCByZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXNwb25zZShpZCwgcmVtb3RlUHVia2V5LCBcImVycm9yXCIsIHZvaWQgMCwgXCJOb3QgYXV0aG9yaXplZFwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZW4gYnkgdGhlIHVzZXIgdG8gYWxsb3cgb3IgcmVqZWN0IGluY29taW5nXG4gICAqIGNvbm5lY3Rpb25zLlxuICAgKi9cbiAgYXN5bmMgcHVia2V5QWxsb3dlZChwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5wZXJtaXRDYWxsYmFjayhwYXJhbXMpO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9pbmRleC50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjYgfSBmcm9tIFwidHNlZXBcIjtcblxuLy8gc3JjL3NpZ25lcnMvZGVzZXJpYWxpemF0aW9uLnRzXG52YXIgc2lnbmVyUmVnaXN0cnkgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuc2lnbmVyUmVnaXN0cnkuc2V0KFwicHJpdmF0ZS1rZXlcIiwgTkRLUHJpdmF0ZUtleVNpZ25lcik7XG5zaWduZXJSZWdpc3RyeS5zZXQoXCJuaXAwN1wiLCBOREtOaXAwN1NpZ25lcik7XG5zaWduZXJSZWdpc3RyeS5zZXQoXCJuaXA0NlwiLCBOREtOaXA0NlNpZ25lcik7XG5hc3luYyBmdW5jdGlvbiBuZGtTaWduZXJGcm9tUGF5bG9hZChwYXlsb2FkU3RyaW5nLCBuZGspIHtcbiAgbGV0IHBhcnNlZDtcbiAgdHJ5IHtcbiAgICBwYXJzZWQgPSBKU09OLnBhcnNlKHBheWxvYWRTdHJpbmcpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2Ugc2lnbmVyIHBheWxvYWQ6ICR7ZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpfWApO1xuICB9XG4gIGNvbnN0IFNpZ25lckNsYXNzID0gc2lnbmVyUmVnaXN0cnkuZ2V0KHBhcnNlZC50eXBlKTtcbiAgaWYgKCFTaWduZXJDbGFzcykge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzaWduZXIgdHlwZTogJHtwYXJzZWQudHlwZX1gKTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBTaWduZXJDbGFzcy5mcm9tUGF5bG9hZChwYXlsb2FkU3RyaW5nLCBuZGspO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc3QgZXJyb3JNc2cgPSBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGVzZXJpYWxpemUgc2lnbmVyIHR5cGUgJHtwYXJzZWQudHlwZX06ICR7ZXJyb3JNc2d9YCk7XG4gIH1cbn1cblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvaW5kZXgudHNcbnZhciBOREtOaXA0NlNpZ25lciA9IGNsYXNzIF9OREtOaXA0NlNpZ25lciBleHRlbmRzIEV2ZW50RW1pdHRlcjYge1xuICBuZGs7XG4gIF91c2VyO1xuICAvKipcbiAgICogVGhlIHB1YmtleSBvZiB0aGUgYnVua2VyIHRoYXQgd2lsbCBiZSBwcm92aWRpbmcgc2lnbmF0dXJlc1xuICAgKi9cbiAgYnVua2VyUHVia2V5O1xuICAvKipcbiAgICogVGhlIHB1YmtleSBvZiB0aGUgdXNlciB0aGF0IGV2ZW50cyB3aWxsIGJlIHB1Ymxpc2hlZCBhc1xuICAgKi9cbiAgdXNlclB1YmtleTtcbiAgZ2V0IHB1YmtleSgpIHtcbiAgICBpZiAoIXRoaXMudXNlclB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiTm90IHJlYWR5XCIpO1xuICAgIHJldHVybiB0aGlzLnVzZXJQdWJrZXk7XG4gIH1cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIHNlY3JldCB2YWx1ZSBwcm92aWRlZCB0byBjb25uZWN0IHRvIHRoZSBidW5rZXJcbiAgICovXG4gIHNlY3JldDtcbiAgbG9jYWxTaWduZXI7XG4gIG5pcDA1O1xuICBycGM7XG4gIGRlYnVnO1xuICByZWxheVVybHM7XG4gIHN1YnNjcmlwdGlvbjtcbiAgLyoqXG4gICAqIEBwYXJhbSBuZGsgLSBUaGUgTkRLIGluc3RhbmNlIHRvIHVzZVxuICAgKiBAcGFyYW0gdXNlck9yQ29ubmVjdGlvblRva2VuIC0gVGhlIHB1YmxpYyBrZXksIG9yIGEgY29ubmVjdGlvbiB0b2tlbiwgb2YgdGhlIG5wdWIgdGhhdCB3YW50cyB0byBiZSBwdWJsaXNoZWQgYXNcbiAgICogQHBhcmFtIGxvY2FsU2lnbmVyIC0gVGhlIHNpZ25lciB0aGF0IHdpbGwgYmUgdXNlZCB0byByZXF1ZXN0IGV2ZW50cyB0byBiZSBzaWduZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKG5kaywgdXNlck9yQ29ubmVjdGlvblRva2VuLCBsb2NhbFNpZ25lcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgdGhpcy5kZWJ1ZyA9IG5kay5kZWJ1Zy5leHRlbmQoXCJuaXA0NjpzaWduZXJcIik7XG4gICAgaWYgKHVzZXJPckNvbm5lY3Rpb25Ub2tlbi5zdGFydHNXaXRoKFwiYnVua2VyOi8vXCIpKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25Ub2tlbkluaXQodXNlck9yQ29ubmVjdGlvblRva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uaXAwNUluaXQodXNlck9yQ29ubmVjdGlvblRva2VuKTtcbiAgICB9XG4gICAgaWYgKCFsb2NhbFNpZ25lcikge1xuICAgICAgdGhpcy5sb2NhbFNpZ25lciA9IE5ES1ByaXZhdGVLZXlTaWduZXIuZ2VuZXJhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2NhbFNpZ25lciA9IGxvY2FsU2lnbmVyO1xuICAgIH1cbiAgICB0aGlzLnJwYyA9IG5ldyBOREtOb3N0clJwYyh0aGlzLm5kaywgdGhpcy5sb2NhbFNpZ25lciwgdGhpcy5kZWJ1ZywgdGhpcy5yZWxheVVybHMpO1xuICB9XG4gIGNvbm5lY3Rpb25Ub2tlbkluaXQoY29ubmVjdGlvblRva2VuKSB7XG4gICAgY29uc3QgYnVua2VyVXJsID0gbmV3IFVSTChjb25uZWN0aW9uVG9rZW4pO1xuICAgIGNvbnN0IGJ1bmtlclB1YmtleSA9IGJ1bmtlclVybC5ob3N0bmFtZSB8fCBidW5rZXJVcmwucGF0aG5hbWUucmVwbGFjZSgvXlxcL1xcLy8sIFwiXCIpO1xuICAgIGNvbnN0IHVzZXJQdWJrZXkgPSBidW5rZXJVcmwuc2VhcmNoUGFyYW1zLmdldChcInB1YmtleVwiKTtcbiAgICBjb25zdCByZWxheVVybHMgPSBidW5rZXJVcmwuc2VhcmNoUGFyYW1zLmdldEFsbChcInJlbGF5XCIpO1xuICAgIGNvbnN0IHNlY3JldCA9IGJ1bmtlclVybC5zZWFyY2hQYXJhbXMuZ2V0KFwic2VjcmV0XCIpO1xuICAgIHRoaXMuYnVua2VyUHVia2V5ID0gYnVua2VyUHVia2V5O1xuICAgIHRoaXMudXNlclB1YmtleSA9IHVzZXJQdWJrZXk7XG4gICAgdGhpcy5yZWxheVVybHMgPSByZWxheVVybHM7XG4gICAgdGhpcy5zZWNyZXQgPSBzZWNyZXQ7XG4gIH1cbiAgbmlwMDVJbml0KG5pcDA1KSB7XG4gICAgdGhpcy5uaXAwNSA9IG5pcDA1O1xuICB9XG4gIC8qKlxuICAgKiBXZSBzdGFydCBsaXN0ZW5pbmcgZm9yIGV2ZW50cyBmcm9tIHRoZSBidW5rZXJcbiAgICovXG4gIGFzeW5jIHN0YXJ0TGlzdGVuaW5nKCkge1xuICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikgcmV0dXJuO1xuICAgIGNvbnN0IGxvY2FsVXNlciA9IGF3YWl0IHRoaXMubG9jYWxTaWduZXIudXNlcigpO1xuICAgIGlmICghbG9jYWxVc2VyKSB0aHJvdyBuZXcgRXJyb3IoXCJMb2NhbCBzaWduZXIgbm90IHJlYWR5XCIpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gYXdhaXQgdGhpcy5ycGMuc3Vic2NyaWJlKHtcbiAgICAgIGtpbmRzOiBbMjQxMzMgLyogTm9zdHJDb25uZWN0ICovXSxcbiAgICAgIFwiI3BcIjogW2xvY2FsVXNlci5wdWJrZXldXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlciB0aGF0IGlzIGJlaW5nIHB1Ymxpc2hlZCBhc1xuICAgKi9cbiAgYXN5bmMgdXNlcigpIHtcbiAgICBpZiAodGhpcy5fdXNlcikgcmV0dXJuIHRoaXMuX3VzZXI7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tVbnRpbFJlYWR5KCk7XG4gIH1cbiAgZ2V0IHVzZXJTeW5jKCkge1xuICAgIGlmICghdGhpcy5fdXNlcikgdGhyb3cgbmV3IEVycm9yKFwiUmVtb3RlIHVzZXIgbm90IHJlYWR5IHN5bmNocm9ub3VzbHlcIik7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXI7XG4gIH1cbiAgYXN5bmMgYmxvY2tVbnRpbFJlYWR5KCkge1xuICAgIGlmICh0aGlzLm5pcDA1ICYmICF0aGlzLnVzZXJQdWJrZXkpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBOREtVc2VyLmZyb21OaXAwNSh0aGlzLm5pcDA1LCB0aGlzLm5kayk7XG4gICAgICBpZiAodXNlcikge1xuICAgICAgICB0aGlzLl91c2VyID0gdXNlcjtcbiAgICAgICAgdGhpcy51c2VyUHVia2V5ID0gdXNlci5wdWJrZXk7XG4gICAgICAgIHRoaXMucmVsYXlVcmxzID0gdXNlci5uaXA0NlVybHM7XG4gICAgICAgIHRoaXMucnBjID0gbmV3IE5ES05vc3RyUnBjKHRoaXMubmRrLCB0aGlzLmxvY2FsU2lnbmVyLCB0aGlzLmRlYnVnLCB0aGlzLnJlbGF5VXJscyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkgJiYgdGhpcy51c2VyUHVia2V5KSB7XG4gICAgICB0aGlzLmJ1bmtlclB1YmtleSA9IHRoaXMudXNlclB1YmtleTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmJ1bmtlclB1YmtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVua2VyIHB1YmtleSBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnN0YXJ0TGlzdGVuaW5nKCk7XG4gICAgdGhpcy5ycGMub24oXCJhdXRoVXJsXCIsICguLi5wcm9wcykgPT4ge1xuICAgICAgdGhpcy5lbWl0KFwiYXV0aFVybFwiLCAuLi5wcm9wcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNvbm5lY3RQYXJhbXMgPSBbdGhpcy51c2VyUHVia2V5ID8/IFwiXCJdO1xuICAgICAgaWYgKHRoaXMuc2VjcmV0KSBjb25uZWN0UGFyYW1zLnB1c2godGhpcy5zZWNyZXQpO1xuICAgICAgaWYgKCF0aGlzLmJ1bmtlclB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiQnVua2VyIHB1YmtleSBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QodGhpcy5idW5rZXJQdWJrZXksIFwiY29ubmVjdFwiLCBjb25uZWN0UGFyYW1zLCAyNDEzMywgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5yZXN1bHQgPT09IFwiYWNrXCIpIHtcbiAgICAgICAgICB0aGlzLmdldFB1YmxpY0tleSgpLnRoZW4oKHB1YmtleSkgPT4ge1xuICAgICAgICAgICAgdGhpcy51c2VyUHVia2V5ID0gcHVia2V5O1xuICAgICAgICAgICAgdGhpcy5fdXNlciA9IHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXkgfSk7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMuX3VzZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChyZXNwb25zZS5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldFB1YmxpY0tleSgpIHtcbiAgICBpZiAodGhpcy51c2VyUHVia2V5KSByZXR1cm4gdGhpcy51c2VyUHVia2V5O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgX3JlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmJ1bmtlclB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiQnVua2VyIHB1YmtleSBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QodGhpcy5idW5rZXJQdWJrZXksIFwiZ2V0X3B1YmxpY19rZXlcIiwgW10sIDI0MTMzLCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdGlvbkVuYWJsZWQoc2NoZW1lKSB7XG4gICAgaWYgKHNjaGVtZSkgcmV0dXJuIFtzY2hlbWVdO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW1wibmlwMDRcIiwgXCJuaXA0NFwiXSk7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdChyZWNpcGllbnQsIHZhbHVlLCBzY2hlbWUgPSBcIm5pcDA0XCIpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uKHJlY2lwaWVudCwgdmFsdWUsIHNjaGVtZSwgXCJlbmNyeXB0XCIpO1xuICB9XG4gIGFzeW5jIGRlY3J5cHQoc2VuZGVyLCB2YWx1ZSwgc2NoZW1lID0gXCJuaXAwNFwiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvbihzZW5kZXIsIHZhbHVlLCBzY2hlbWUsIFwiZGVjcnlwdFwiKTtcbiAgfVxuICBhc3luYyBlbmNyeXB0aW9uKHBlZXIsIHZhbHVlLCBzY2hlbWUsIG1ldGhvZCkge1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMuYnVua2VyUHVia2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJCdW5rZXIgcHVia2V5IG5vdCBzZXRcIik7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVxdWVzdChcbiAgICAgICAgdGhpcy5idW5rZXJQdWJrZXksXG4gICAgICAgIGAke3NjaGVtZX1fJHttZXRob2R9YCxcbiAgICAgICAgW3BlZXIucHVia2V5LCB2YWx1ZV0sXG4gICAgICAgIDI0MTMzLFxuICAgICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChyZXNwb25zZS5lcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGFzeW5jIHNpZ24oZXZlbnQpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmJ1bmtlclB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiQnVua2VyIHB1YmtleSBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QoXG4gICAgICAgIHRoaXMuYnVua2VyUHVia2V5LFxuICAgICAgICBcInNpZ25fZXZlbnRcIixcbiAgICAgICAgW0pTT04uc3RyaW5naWZ5KGV2ZW50KV0sXG4gICAgICAgIDI0MTMzLFxuICAgICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgICAgcmVzb2x2ZShqc29uLnNpZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChyZXNwb25zZS5lcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvd3MgY3JlYXRpbmcgYSBuZXcgYWNjb3VudCBvbiB0aGUgcmVtb3RlIHNlcnZlci5cbiAgICogQHBhcmFtIHVzZXJuYW1lIERlc2lyZWQgdXNlcm5hbWUgZm9yIHRoZSBOSVAtMDVcbiAgICogQHBhcmFtIGRvbWFpbiBEZXNpcmVkIGRvbWFpbiBmb3IgdGhlIE5JUC0wNVxuICAgKiBAcGFyYW0gZW1haWwgRW1haWwgYWRkcmVzcyB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGFjY291bnQgLS0gUmVtb3RlIHNlcnZlcnMgbWF5IHVzZSB0aGlzIGZvciByZWNvdmVyeVxuICAgKiBAcmV0dXJucyBUaGUgcHVibGljIGtleSBvZiB0aGUgbmV3bHkgY3JlYXRlZCBhY2NvdW50XG4gICAqL1xuICBhc3luYyBjcmVhdGVBY2NvdW50KHVzZXJuYW1lLCBkb21haW4sIGVtYWlsKSB7XG4gICAgYXdhaXQgdGhpcy5zdGFydExpc3RlbmluZygpO1xuICAgIGNvbnN0IHJlcSA9IFtdO1xuICAgIGlmICh1c2VybmFtZSkgcmVxLnB1c2godXNlcm5hbWUpO1xuICAgIGlmIChkb21haW4pIHJlcS5wdXNoKGRvbWFpbik7XG4gICAgaWYgKGVtYWlsKSByZXEucHVzaChlbWFpbCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KFxuICAgICAgICB0aGlzLmJ1bmtlclB1YmtleSxcbiAgICAgICAgXCJjcmVhdGVfYWNjb3VudFwiLFxuICAgICAgICByZXEsXG4gICAgICAgIDI0MTMzIC8qIE5vc3RyQ29ubmVjdCAqLyxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgY29uc3QgcHVia2V5ID0gcmVzcG9uc2UucmVzdWx0O1xuICAgICAgICAgICAgcmVzb2x2ZShwdWJrZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplcyB0aGUgc2lnbmVyJ3MgY29ubmVjdGlvbiBkZXRhaWxzIGFuZCBsb2NhbCBzaWduZXIgc3RhdGUuXG4gICAqIEByZXR1cm5zIEEgSlNPTiBzdHJpbmcgY29udGFpbmluZyB0aGUgdHlwZSwgY29ubmVjdGlvbiBpbmZvLCBhbmQgbG9jYWwgc2lnbmVyIHBheWxvYWQuXG4gICAqL1xuICB0b1BheWxvYWQoKSB7XG4gICAgaWYgKCF0aGlzLmJ1bmtlclB1YmtleSB8fCAhdGhpcy51c2VyUHVia2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOSVAtNDYgc2lnbmVyIGlzIG5vdCBmdWxseSBpbml0aWFsaXplZCBmb3Igc2VyaWFsaXphdGlvblwiKTtcbiAgICB9XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIHR5cGU6IFwibmlwNDZcIixcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgYnVua2VyUHVia2V5OiB0aGlzLmJ1bmtlclB1YmtleSxcbiAgICAgICAgdXNlclB1YmtleTogdGhpcy51c2VyUHVia2V5LFxuICAgICAgICByZWxheVVybHM6IHRoaXMucmVsYXlVcmxzLFxuICAgICAgICBzZWNyZXQ6IHRoaXMuc2VjcmV0LFxuICAgICAgICBsb2NhbFNpZ25lclBheWxvYWQ6IHRoaXMubG9jYWxTaWduZXIudG9QYXlsb2FkKCksXG4gICAgICAgIC8vIFN0b3JlIG5pcDA1IGlmIGl0IHdhcyB1c2VkIGZvciBpbml0aWFsaXphdGlvbiwgb3RoZXJ3aXNlIG51bGxcbiAgICAgICAgbmlwMDU6IHRoaXMubmlwMDUgfHwgbnVsbFxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICB9XG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgdGhlIHNpZ25lciBmcm9tIGEgcGF5bG9hZCBzdHJpbmcuXG4gICAqIEBwYXJhbSBwYXlsb2FkU3RyaW5nIFRoZSBKU09OIHN0cmluZyBvYnRhaW5lZCBmcm9tIHRvUGF5bG9hZCgpLlxuICAgKiBAcGFyYW0gbmRrIFRoZSBOREsgaW5zdGFuY2UsIHJlcXVpcmVkIGZvciBOSVAtNDYuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIE5ES05pcDQ2U2lnbmVyLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21QYXlsb2FkKHBheWxvYWRTdHJpbmcsIG5kaykge1xuICAgIGlmICghbmRrKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2UgaXMgcmVxdWlyZWQgdG8gZGVzZXJpYWxpemUgTklQLTQ2IHNpZ25lclwiKTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShwYXlsb2FkU3RyaW5nKTtcbiAgICBpZiAocGFyc2VkLnR5cGUgIT09IFwibmlwNDZcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBheWxvYWQgdHlwZTogZXhwZWN0ZWQgJ25pcDQ2JywgZ290ICR7cGFyc2VkLnR5cGV9YCk7XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWQgPSBwYXJzZWQucGF5bG9hZDtcbiAgICBpZiAoIXBheWxvYWQgfHwgdHlwZW9mIHBheWxvYWQgIT09IFwib2JqZWN0XCIgfHwgIXBheWxvYWQubG9jYWxTaWduZXJQYXlsb2FkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBheWxvYWQgY29udGVudCBmb3IgbmlwNDYgc2lnbmVyXCIpO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbFNpZ25lciA9IGF3YWl0IG5ka1NpZ25lckZyb21QYXlsb2FkKHBheWxvYWQubG9jYWxTaWduZXJQYXlsb2FkLCBuZGspO1xuICAgIGlmICghbG9jYWxTaWduZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZXNlcmlhbGl6ZSBsb2NhbCBzaWduZXIgZm9yIE5JUC00NlwiKTtcbiAgICB9XG4gICAgbGV0IHNpZ25lcjtcbiAgICBpZiAocGF5bG9hZC5uaXAwNSkge1xuICAgICAgc2lnbmVyID0gbmV3IF9OREtOaXA0NlNpZ25lcihuZGssIHBheWxvYWQubmlwMDUsIGxvY2FsU2lnbmVyKTtcbiAgICAgIHNpZ25lci51c2VyUHVia2V5ID0gcGF5bG9hZC51c2VyUHVia2V5O1xuICAgICAgc2lnbmVyLmJ1bmtlclB1YmtleSA9IHBheWxvYWQuYnVua2VyUHVia2V5O1xuICAgICAgc2lnbmVyLnJlbGF5VXJscyA9IHBheWxvYWQucmVsYXlVcmxzO1xuICAgICAgc2lnbmVyLnNlY3JldCA9IHBheWxvYWQuc2VjcmV0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzaWduZXIgPSBuZXcgX05ES05pcDQ2U2lnbmVyKG5kaywgcGF5bG9hZC51c2VyUHVia2V5LCBsb2NhbFNpZ25lcik7XG4gICAgICBzaWduZXIuYnVua2VyUHVia2V5ID0gcGF5bG9hZC5idW5rZXJQdWJrZXk7XG4gICAgICBzaWduZXIucmVsYXlVcmxzID0gcGF5bG9hZC5yZWxheVVybHM7XG4gICAgICBzaWduZXIuc2VjcmV0ID0gcGF5bG9hZC5zZWNyZXQ7XG4gICAgfVxuICAgIHJldHVybiBzaWduZXI7XG4gIH1cbn07XG5cbi8vIHNyYy9kdm0vc2NoZWR1bGUudHNcbmZ1bmN0aW9uIGFkZFJlbGF5cyhldmVudCwgcmVsYXlzKSB7XG4gIGNvbnN0IHRhZ3MgPSBbXTtcbiAgaWYgKCFyZWxheXMgfHwgcmVsYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnN0IHBvb2xSZWxheXMgPSBldmVudC5uZGs/LnBvb2wucmVsYXlzO1xuICAgIHJlbGF5cyA9IHBvb2xSZWxheXMgPyBPYmplY3Qua2V5cyhwb29sUmVsYXlzKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocmVsYXlzICYmIHJlbGF5cy5sZW5ndGggPiAwKSB0YWdzLnB1c2goW1wicmVsYXlzXCIsIC4uLnJlbGF5c10pO1xuICByZXR1cm4gdGFncztcbn1cbmFzeW5jIGZ1bmN0aW9uIGR2bVNjaGVkdWxlKGV2ZW50cywgZHZtLCByZWxheXMsIGVuY3J5cHRlZCA9IHRydWUsIHdhaXRGb3JDb25maXJtYXRpb25Gb3JNcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXZlbnRzKSkge1xuICAgIGV2ZW50cyA9IFtldmVudHNdO1xuICB9XG4gIGNvbnN0IG5kayA9IGV2ZW50c1swXS5uZGs7XG4gIGlmICghbmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgbm90IHNldFwiKTtcbiAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICBpZiAoIWV2ZW50LnNpZykgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgbm90IHNpZ25lZFwiKTtcbiAgICBpZiAoIWV2ZW50LmNyZWF0ZWRfYXQpIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IGhhcyBubyBkYXRlXCIpO1xuICAgIGlmICghZHZtKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBEVk0gc3BlY2lmaWVkXCIpO1xuICAgIGlmIChldmVudC5jcmVhdGVkX2F0IDw9IERhdGUubm93KCkgLyAxZTMpIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IG5lZWRzIHRvIGJlIGluIHRoZSBmdXR1cmVcIik7XG4gIH1cbiAgY29uc3Qgc2NoZWR1bGVFdmVudCA9IG5ldyBOREtEVk1SZXF1ZXN0KG5kaywge1xuICAgIGtpbmQ6IDU5MDUgLyogRFZNRXZlbnRTY2hlZHVsZSAqL1xuICB9KTtcbiAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICBzY2hlZHVsZUV2ZW50LmFkZElucHV0KEpTT04uc3RyaW5naWZ5KGV2ZW50LnJhd0V2ZW50KCkpLCBcInRleHRcIik7XG4gIH1cbiAgc2NoZWR1bGVFdmVudC50YWdzLnB1c2goLi4uYWRkUmVsYXlzKGV2ZW50c1swXSwgcmVsYXlzKSk7XG4gIGlmIChlbmNyeXB0ZWQpIHtcbiAgICBhd2FpdCBzY2hlZHVsZUV2ZW50LmVuY3J5cHRpb24oZHZtKTtcbiAgfSBlbHNlIHtcbiAgICBzY2hlZHVsZUV2ZW50LmR2bSA9IGR2bTtcbiAgfVxuICBhd2FpdCBzY2hlZHVsZUV2ZW50LnNpZ24oKTtcbiAgbGV0IHJlcztcbiAgaWYgKHdhaXRGb3JDb25maXJtYXRpb25Gb3JNcykge1xuICAgIHJlcyA9IG5kay5zdWJzY3JpYmUoXG4gICAgICB7XG4gICAgICAgIGtpbmRzOiBbNTkwNSAvKiBEVk1FdmVudFNjaGVkdWxlICovICsgMWUzLCA3ZTMgLyogRFZNSm9iRmVlZGJhY2sgKi9dLFxuICAgICAgICAuLi5zY2hlZHVsZUV2ZW50LmZpbHRlcigpXG4gICAgICB9LFxuICAgICAgeyBncm91cGFibGU6IGZhbHNlLCBjbG9zZU9uRW9zZTogZmFsc2UgfVxuICAgICk7XG4gIH1cbiAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVqZWN0KSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZXM/LnN0b3AoKTtcbiAgICAgIHJlamVjdChcIlRpbWVvdXQgd2FpdGluZyBmb3IgYW4gYW5zd2VyIGZyb20gdGhlIERWTVwiKTtcbiAgICB9LCB3YWl0Rm9yQ29uZmlybWF0aW9uRm9yTXMpO1xuICB9KTtcbiAgY29uc3Qgc2NoZWR1bGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmICh3YWl0Rm9yQ29uZmlybWF0aW9uRm9yTXMpIHtcbiAgICAgIHJlcz8ub24oXCJldmVudFwiLCBhc3luYyAoZSkgPT4ge1xuICAgICAgICByZXM/LnN0b3AoKTtcbiAgICAgICAgaWYgKGUua2luZCA9PT0gN2UzIC8qIERWTUpvYkZlZWRiYWNrICovKSB7XG4gICAgICAgICAgY29uc3QgZmVlZGJhY2sgPSBhd2FpdCBOREtEVk1Kb2JGZWVkYmFjay5mcm9tKGUpO1xuICAgICAgICAgIGlmIChmZWVkYmFjay5zdGF0dXMgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzVGFnID0gZmVlZGJhY2suZ2V0TWF0Y2hpbmdUYWdzKFwic3RhdHVzXCIpO1xuICAgICAgICAgICAgcmVqZWN0KHN0YXR1c1RhZz8uWzJdID8/IGZlZWRiYWNrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShmZWVkYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgc2NoZWR1bGVFdmVudC5wdWJsaXNoKCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIXdhaXRGb3JDb25maXJtYXRpb25Gb3JNcykgcmVzb2x2ZSh2b2lkIDApO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAod2FpdEZvckNvbmZpcm1hdGlvbkZvck1zKSB7XG4gICAgICBQcm9taXNlLnJhY2UoW3RpbWVvdXRQcm9taXNlLCBzY2hlZHVsZVByb21pc2VdKS50aGVuKChlKSA9PiB7XG4gICAgICAgIHJlc29sdmUoZSk7XG4gICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZVByb21pc2UudGhlbihyZXNvbHZlKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvbmRrL2luZGV4LnRzXG5pbXBvcnQgZGVidWc3IGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjggfSBmcm9tIFwidHNlZXBcIjtcblxuLy8gc3JjL2V2ZW50cy9kZWR1cC50c1xuZnVuY3Rpb24gZGVkdXAoZXZlbnQxLCBldmVudDIpIHtcbiAgaWYgKGV2ZW50MS5jcmVhdGVkX2F0ID4gZXZlbnQyLmNyZWF0ZWRfYXQpIHtcbiAgICByZXR1cm4gZXZlbnQxO1xuICB9XG4gIHJldHVybiBldmVudDI7XG59XG5cbi8vIHNyYy9vdXRib3gvdHJhY2tlci50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjcgfSBmcm9tIFwidHNlZXBcIjtcbmltcG9ydCB7IExSVUNhY2hlIGFzIExSVUNhY2hlMiB9IGZyb20gXCJ0eXBlc2NyaXB0LWxydS1jYWNoZVwiO1xuXG4vLyBzcmMvdXRpbHMvZ2V0LXVzZXJzLXJlbGF5LWxpc3QudHNcbmFzeW5jIGZ1bmN0aW9uIGdldFJlbGF5TGlzdEZvclVzZXIocHVia2V5LCBuZGspIHtcbiAgY29uc3QgbGlzdCA9IGF3YWl0IGdldFJlbGF5TGlzdEZvclVzZXJzKFtwdWJrZXldLCBuZGspO1xuICByZXR1cm4gbGlzdC5nZXQocHVia2V5KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFJlbGF5TGlzdEZvclVzZXJzKHB1YmtleXMsIG5kaywgc2tpcENhY2hlID0gZmFsc2UsIHRpbWVvdXQgPSAxZTMpIHtcbiAgY29uc3QgcG9vbCA9IG5kay5vdXRib3hQb29sIHx8IG5kay5wb29sO1xuICBjb25zdCBzZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHJlbGF5IG9mIHBvb2wucmVsYXlzLnZhbHVlcygpKSBzZXQuYWRkKHJlbGF5KTtcbiAgY29uc3QgcmVsYXlMaXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGZyb21Db250YWN0TGlzdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHJlbGF5U2V0ID0gbmV3IE5ES1JlbGF5U2V0KHNldCwgbmRrKTtcbiAgaWYgKG5kay5jYWNoZUFkYXB0ZXI/LmxvY2tpbmcgJiYgIXNraXBDYWNoZSkge1xuICAgIGNvbnN0IGNhY2hlZExpc3QgPSBhd2FpdCBuZGsuZmV0Y2hFdmVudHMoXG4gICAgICB7IGtpbmRzOiBbMywgMTAwMDJdLCBhdXRob3JzOiBBcnJheS5mcm9tKG5ldyBTZXQocHVia2V5cykpIH0sXG4gICAgICB7IGNhY2hlVXNhZ2U6IFwiT05MWV9DQUNIRVwiIC8qIE9OTFlfQ0FDSEUgKi8sIHN1YklkOiBcIm5kay1yZWxheS1saXN0LWZldGNoXCIgfVxuICAgICk7XG4gICAgZm9yIChjb25zdCByZWxheUxpc3Qgb2YgY2FjaGVkTGlzdCkge1xuICAgICAgaWYgKHJlbGF5TGlzdC5raW5kID09PSAxMDAwMikgcmVsYXlMaXN0cy5zZXQocmVsYXlMaXN0LnB1YmtleSwgTkRLUmVsYXlMaXN0LmZyb20ocmVsYXlMaXN0KSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcmVsYXlMaXN0IG9mIGNhY2hlZExpc3QpIHtcbiAgICAgIGlmIChyZWxheUxpc3Qua2luZCA9PT0gMykge1xuICAgICAgICBpZiAocmVsYXlMaXN0cy5oYXMocmVsYXlMaXN0LnB1YmtleSkpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBsaXN0ID0gcmVsYXlMaXN0RnJvbUtpbmQzKG5kaywgcmVsYXlMaXN0KTtcbiAgICAgICAgaWYgKGxpc3QpIGZyb21Db250YWN0TGlzdC5zZXQocmVsYXlMaXN0LnB1YmtleSwgbGlzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHB1YmtleXMgPSBwdWJrZXlzLmZpbHRlcigocHVia2V5KSA9PiAhcmVsYXlMaXN0cy5oYXMocHVia2V5KSAmJiAhZnJvbUNvbnRhY3RMaXN0LmhhcyhwdWJrZXkpKTtcbiAgfVxuICBpZiAocHVia2V5cy5sZW5ndGggPT09IDApIHJldHVybiByZWxheUxpc3RzO1xuICBjb25zdCByZWxheUxpc3RFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBjb250YWN0TGlzdEV2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVN1YnNjcmlwdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHN1YnNjcmliZU9wdHMgPSB7XG4gICAgICAgIGNsb3NlT25Fb3NlOiB0cnVlLFxuICAgICAgICBwb29sLFxuICAgICAgICBncm91cGFibGU6IHRydWUsXG4gICAgICAgIHN1YklkOiBcIm5kay1yZWxheS1saXN0LWZldGNoXCIsXG4gICAgICAgIGFkZFNpbmNlRnJvbUNhY2hlOiB0cnVlLFxuICAgICAgICByZWxheVNldFxuICAgICAgfTtcbiAgICAgIGlmIChyZWxheVNldCkgc3Vic2NyaWJlT3B0cy5yZWxheVNldCA9IHJlbGF5U2V0O1xuICAgICAgbmRrLnN1YnNjcmliZSh7IGtpbmRzOiBbMywgMTAwMDJdLCBhdXRob3JzOiBwdWJrZXlzIH0sIHN1YnNjcmliZU9wdHMsIHtcbiAgICAgICAgb25FdmVudDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50LmtpbmQgPT09IDEwMDAyIC8qIFJlbGF5TGlzdCAqLykge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdFdmVudCA9IHJlbGF5TGlzdEV2ZW50cy5nZXQoZXZlbnQucHVia2V5KTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0V2ZW50ICYmIGV4aXN0aW5nRXZlbnQuY3JlYXRlZF9hdCA+IGV2ZW50LmNyZWF0ZWRfYXQpIHJldHVybjtcbiAgICAgICAgICAgIHJlbGF5TGlzdEV2ZW50cy5zZXQoZXZlbnQucHVia2V5LCBldmVudCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5raW5kID09PSAzIC8qIENvbnRhY3RzICovKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0V2ZW50ID0gY29udGFjdExpc3RFdmVudHMuZ2V0KGV2ZW50LnB1YmtleSk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdFdmVudCAmJiBleGlzdGluZ0V2ZW50LmNyZWF0ZWRfYXQgPiBldmVudC5jcmVhdGVkX2F0KSByZXR1cm47XG4gICAgICAgICAgICBjb250YWN0TGlzdEV2ZW50cy5zZXQoZXZlbnQucHVia2V5LCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkVvc2U6ICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHJlbGF5TGlzdEV2ZW50cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcmVsYXlMaXN0cy5zZXQoZXZlbnQucHVia2V5LCBOREtSZWxheUxpc3QuZnJvbShldmVudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IHB1YmtleSBvZiBwdWJrZXlzKSB7XG4gICAgICAgICAgICBpZiAocmVsYXlMaXN0cy5oYXMocHVia2V5KSkgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBjb250YWN0TGlzdCA9IGNvbnRhY3RMaXN0RXZlbnRzLmdldChwdWJrZXkpO1xuICAgICAgICAgICAgaWYgKCFjb250YWN0TGlzdCkgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBsaXN0ID0gcmVsYXlMaXN0RnJvbUtpbmQzKG5kaywgY29udGFjdExpc3QpO1xuICAgICAgICAgICAgaWYgKGxpc3QpIHJlbGF5TGlzdHMuc2V0KHB1YmtleSwgbGlzdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUocmVsYXlMaXN0cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlc29sdmUocmVsYXlMaXN0cyk7XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICB9O1xuICAgIGhhbmRsZVN1YnNjcmlwdGlvbigpO1xuICB9KTtcbn1cblxuLy8gc3JjL291dGJveC90cmFja2VyLnRzXG52YXIgT3V0Ym94SXRlbSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFR5cGUgb2YgaXRlbVxuICAgKi9cbiAgdHlwZTtcbiAgLyoqXG4gICAqIFRoZSByZWxheSBVUkxzIHRoYXQgYXJlIG9mIGludGVyZXN0IHRvIHRoaXMgaXRlbVxuICAgKi9cbiAgcmVsYXlVcmxTY29yZXM7XG4gIHJlYWRSZWxheXM7XG4gIHdyaXRlUmVsYXlzO1xuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnJlbGF5VXJsU2NvcmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnJlYWRSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMud3JpdGVSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG59O1xudmFyIE91dGJveFRyYWNrZXIgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjcge1xuICBkYXRhO1xuICBuZGs7XG4gIGRlYnVnO1xuICBjb25zdHJ1Y3RvcihuZGspIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMuZGVidWcgPSBuZGsuZGVidWcuZXh0ZW5kKFwib3V0Ym94LXRyYWNrZXJcIik7XG4gICAgdGhpcy5kYXRhID0gbmV3IExSVUNhY2hlMih7XG4gICAgICBtYXhTaXplOiAxZTUsXG4gICAgICBlbnRyeUV4cGlyYXRpb25UaW1lSW5NUzogMiAqIDYwICogMWUzXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBsaXN0IG9mIHVzZXJzIHRvIHRoZSB0cmFja2VyLlxuICAgKiBAcGFyYW0gaXRlbXNcbiAgICogQHBhcmFtIHNraXBDYWNoZVxuICAgKi9cbiAgYXN5bmMgdHJhY2tVc2VycyhpdGVtcywgc2tpcENhY2hlID0gZmFsc2UpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDQwMCkge1xuICAgICAgY29uc3Qgc2xpY2UgPSBpdGVtcy5zbGljZShpLCBpICsgNDAwKTtcbiAgICAgIGNvbnN0IHB1YmtleXMgPSBzbGljZS5tYXAoKGl0ZW0pID0+IGdldEtleUZyb21JdGVtKGl0ZW0pKS5maWx0ZXIoKHB1YmtleSkgPT4gIXRoaXMuZGF0YS5oYXMocHVia2V5KSk7XG4gICAgICBpZiAocHVia2V5cy5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuICAgICAgZm9yIChjb25zdCBwdWJrZXkgb2YgcHVia2V5cykge1xuICAgICAgICB0aGlzLmRhdGEuc2V0KHB1YmtleSwgbmV3IE91dGJveEl0ZW0oXCJ1c2VyXCIpKTtcbiAgICAgIH1cbiAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgZ2V0UmVsYXlMaXN0Rm9yVXNlcnMocHVia2V5cywgdGhpcy5uZGssIHNraXBDYWNoZSkudGhlbigocmVsYXlMaXN0cykgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbcHVia2V5LCByZWxheUxpc3RdIG9mIHJlbGF5TGlzdHMpIHtcbiAgICAgICAgICAgICAgbGV0IG91dGJveEl0ZW0gPSB0aGlzLmRhdGEuZ2V0KHB1YmtleSk7XG4gICAgICAgICAgICAgIG91dGJveEl0ZW0gPz89IG5ldyBPdXRib3hJdGVtKFwidXNlclwiKTtcbiAgICAgICAgICAgICAgaWYgKHJlbGF5TGlzdCkge1xuICAgICAgICAgICAgICAgIG91dGJveEl0ZW0ucmVhZFJlbGF5cyA9IG5ldyBTZXQobm9ybWFsaXplKHJlbGF5TGlzdC5yZWFkUmVsYXlVcmxzKSk7XG4gICAgICAgICAgICAgICAgb3V0Ym94SXRlbS53cml0ZVJlbGF5cyA9IG5ldyBTZXQobm9ybWFsaXplKHJlbGF5TGlzdC53cml0ZVJlbGF5VXJscykpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2Ygb3V0Ym94SXRlbS5yZWFkUmVsYXlzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZGsucG9vbC5ibGFja2xpc3RSZWxheVVybHMuaGFzKHJlbGF5VXJsKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRib3hJdGVtLnJlYWRSZWxheXMuZGVsZXRlKHJlbGF5VXJsKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZWxheVVybCBvZiBvdXRib3hJdGVtLndyaXRlUmVsYXlzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZGsucG9vbC5ibGFja2xpc3RSZWxheVVybHMuaGFzKHJlbGF5VXJsKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRib3hJdGVtLndyaXRlUmVsYXlzLmRlbGV0ZShyZWxheVVybCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zZXQocHVia2V5LCBvdXRib3hJdGVtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLmZpbmFsbHkocmVzb2x2ZSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ga2V5XG4gICAqIEBwYXJhbSBzY29yZVxuICAgKi9cbiAgdHJhY2soaXRlbSwgdHlwZSwgX3NraXBDYWNoZSA9IHRydWUpIHtcbiAgICBjb25zdCBrZXkgPSBnZXRLZXlGcm9tSXRlbShpdGVtKTtcbiAgICB0eXBlID8/PSBnZXRUeXBlRnJvbUl0ZW0oaXRlbSk7XG4gICAgbGV0IG91dGJveEl0ZW0gPSB0aGlzLmRhdGEuZ2V0KGtleSk7XG4gICAgaWYgKCFvdXRib3hJdGVtKSB7XG4gICAgICBvdXRib3hJdGVtID0gbmV3IE91dGJveEl0ZW0odHlwZSk7XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES1VzZXIpIHtcbiAgICAgICAgdGhpcy50cmFja1VzZXJzKFtpdGVtXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRib3hJdGVtO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0S2V5RnJvbUl0ZW0oaXRlbSkge1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES1VzZXIpIHtcbiAgICByZXR1cm4gaXRlbS5wdWJrZXk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5mdW5jdGlvbiBnZXRUeXBlRnJvbUl0ZW0oaXRlbSkge1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES1VzZXIpIHtcbiAgICByZXR1cm4gXCJ1c2VyXCI7XG4gIH1cbiAgcmV0dXJuIFwia2luZFwiO1xufVxuXG4vLyBzcmMvcmVsYXkvc2V0cy91dGlscy50c1xuZnVuY3Rpb24gY29ycmVjdFJlbGF5U2V0KHJlbGF5U2V0LCBwb29sKSB7XG4gIGNvbnN0IGNvbm5lY3RlZFJlbGF5cyA9IHBvb2wuY29ubmVjdGVkUmVsYXlzKCk7XG4gIGNvbnN0IGluY2x1ZGVzQ29ubmVjdGVkUmVsYXkgPSBBcnJheS5mcm9tKHJlbGF5U2V0LnJlbGF5cykuc29tZSgocmVsYXkpID0+IHtcbiAgICByZXR1cm4gY29ubmVjdGVkUmVsYXlzLm1hcCgocikgPT4gci51cmwpLmluY2x1ZGVzKHJlbGF5LnVybCk7XG4gIH0pO1xuICBpZiAoIWluY2x1ZGVzQ29ubmVjdGVkUmVsYXkpIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIGNvbm5lY3RlZFJlbGF5cykge1xuICAgICAgcmVsYXlTZXQuYWRkUmVsYXkocmVsYXkpO1xuICAgIH1cbiAgfVxuICBpZiAoY29ubmVjdGVkUmVsYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoY29uc3QgcmVsYXkgb2YgcG9vbC5yZWxheXMudmFsdWVzKCkpIHtcbiAgICAgIHJlbGF5U2V0LmFkZFJlbGF5KHJlbGF5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbGF5U2V0O1xufVxuXG4vLyBzcmMvc3Vic2NyaXB0aW9uL21hbmFnZXIudHNcbmltcG9ydCB7IG1hdGNoRmlsdGVycyB9IGZyb20gXCJub3N0ci10b29sc1wiO1xudmFyIE5ES1N1YnNjcmlwdGlvbk1hbmFnZXIgPSBjbGFzcyB7XG4gIHN1YnNjcmlwdGlvbnM7XG4gIHNlZW5FdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGFkZChzdWIpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuc2V0KHN1Yi5pbnRlcm5hbElkLCBzdWIpO1xuICAgIGlmIChzdWIub25TdG9wcGVkKSB7XG4gICAgfVxuICAgIHN1Yi5vblN0b3BwZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1Yi5pbnRlcm5hbElkKTtcbiAgICB9O1xuICAgIHN1Yi5vbihcImNsb3NlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kZWxldGUoc3ViLmludGVybmFsSWQpO1xuICAgIH0pO1xuICB9XG4gIHNlZW5FdmVudChldmVudElkLCByZWxheSkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnNlZW5FdmVudHMuZ2V0KGV2ZW50SWQpIHx8IFtdO1xuICAgIGN1cnJlbnQucHVzaChyZWxheSk7XG4gICAgdGhpcy5zZWVuRXZlbnRzLnNldChldmVudElkLCBjdXJyZW50KTtcbiAgfVxuICAvKipcbiAgICogV2hlbmV2ZXIgYW4gZXZlbnQgY29tZXMgaW4sIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKiBUaGlzIGZ1bmN0aW9uIG1hdGNoZXMgdGhlIHJlY2VpdmVkIGV2ZW50IGFnYWluc3QgYWxsIHRoZVxuICAgKiBrbm93biAoaS5lLiBhY3RpdmUpIE5ES1N1YnNjcmlwdGlvbnMsIGFuZCBpZiBpdCBtYXRjaGVzLFxuICAgKiBpdCBzZW5kcyB0aGUgZXZlbnQgdG8gdGhlIHN1YnNjcmlwdGlvbi5cbiAgICpcbiAgICogVGhpcyBpcyB0aGUgc2luZ2xlIHBsYWNlIGluIHRoZSBjb2RlYmFzZSB0aGF0IG1hdGNoZXNcbiAgICogaW5jb21pbmcgZXZlbnRzIHdpdGggcGFydGllcyBpbnRlcmVzdGVkIGluIHRoZSBldmVudC5cbiAgICpcbiAgICogVGhpcyBpcyBhbHNvIHdoYXQgYWxsb3dzIGZvciByZWFjdGl2aXR5IGluIE5ESyBhcHBzLCBzdWNoIHRoYXRcbiAgICogd2hlbmV2ZXIgYW4gYWN0aXZlIHN1YnNjcmlwdGlvbiByZWNlaXZlcyBhbiBldmVudCB0aGF0IHNvbWVcbiAgICogb3RoZXIgYWN0aXZlIHN1YnNjcmlwdGlvbiB3b3VsZCB3YW50IHRvIHJlY2VpdmUsIGJvdGggcmVjZWl2ZSBpdC5cbiAgICpcbiAgICogVE9ETyBUaGlzIGFsc28gYWxsb3dzIGZvciBzdWJzY3JpcHRpb25zIHRoYXQgb3ZlcmxhcCBpbiBtZWFuaW5nXG4gICAqIHRvIGJlIGNvbGxhcHNlZCBpbnRvIG9uZS5cbiAgICpcbiAgICogSS5lLiBpZiBhIHN1YnNjcmlwdGlvbiB3aXRoIGZpbHRlcjoga2luZHM6IFsxXSwgYXV0aG9yczogW2FsaWNlXVxuICAgKiBpcyBjcmVhdGVkIGFuZCBFT1NFcywgYW5kIHRoZW4gYSBzdWJzZXF1ZW50IHN1YnNjcmlwdGlvbiB3aXRoXG4gICAqIGtpbmRzOiBbMV0sIGF1dGhvcnM6IFthbGljZV0gaXMgY3JlYXRlZCwgb25jZSB0aGUgc2Vjb25kIHN1YnNjcmlwdGlvblxuICAgKiBFT1NFcyB3ZSBjYW4gc2FmZWx5IGNsb3NlIGl0LCBpbmNyZW1lbnQgaXRzIHJlZkNvdW50IGFuZCBjbG9zZSBpdCxcbiAgICogYW5kIHdoZW4gdGhlIGZpcnN0IHN1YnNjcmlwdGlvbiByZWNlaXZlcyBhIG5ldyBldmVudCBmcm9tIEFsaWNlIHRoaXNcbiAgICogY29kZSB3aWxsIG1ha2UgdGhlIHNlY29uZCBzdWJzY3JpcHRpb24gcmVjZWl2ZSB0aGUgZXZlbnQgZXZlbiB0aG91Z2hcbiAgICogaXQgaGFzIG5vIGFjdGl2ZSBzdWJzY3JpcHRpb24gb24gYSByZWxheS5cbiAgICogQHBhcmFtIGV2ZW50IFJhdyBldmVudCByZWNlaXZlZCBmcm9tIGEgcmVsYXlcbiAgICogQHBhcmFtIHJlbGF5IFJlbGF5IHRoYXQgc2VudCB0aGUgZXZlbnRcbiAgICogQHBhcmFtIG9wdGltaXN0aWNQdWJsaXNoIFdoZXRoZXIgdGhlIGV2ZW50IGlzIGNvbWluZyBmcm9tIGFuIG9wdGltaXN0aWMgcHVibGlzaFxuICAgKi9cbiAgZGlzcGF0Y2hFdmVudChldmVudCwgcmVsYXksIG9wdGltaXN0aWNQdWJsaXNoID0gZmFsc2UpIHtcbiAgICBpZiAocmVsYXkpIHRoaXMuc2VlbkV2ZW50KGV2ZW50LmlkLCByZWxheSk7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucy52YWx1ZXMoKTtcbiAgICBjb25zdCBtYXRjaGluZ1N1YnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHN1YiBvZiBzdWJzY3JpcHRpb25zKSB7XG4gICAgICBpZiAobWF0Y2hGaWx0ZXJzKHN1Yi5maWx0ZXJzLCBldmVudCkpIHtcbiAgICAgICAgbWF0Y2hpbmdTdWJzLnB1c2goc3ViKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBzdWIgb2YgbWF0Y2hpbmdTdWJzKSB7XG4gICAgICBzdWIuZXZlbnRSZWNlaXZlZChldmVudCwgcmVsYXksIGZhbHNlLCBvcHRpbWlzdGljUHVibGlzaCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvbmRrL2FjdGl2ZS11c2VyLnRzXG5pbXBvcnQgY3JlYXRlRGVidWczIGZyb20gXCJkZWJ1Z1wiO1xudmFyIGRlYnVnNiA9IGNyZWF0ZURlYnVnMyhcIm5kazphY3RpdmUtdXNlclwiKTtcbmFzeW5jIGZ1bmN0aW9uIGdldFVzZXJSZWxheUxpc3QodXNlcikge1xuICBpZiAoIXRoaXMuYXV0b0Nvbm5lY3RVc2VyUmVsYXlzKSByZXR1cm47XG4gIGNvbnN0IHVzZXJSZWxheXMgPSBhd2FpdCBnZXRSZWxheUxpc3RGb3JVc2VyKHVzZXIucHVia2V5LCB0aGlzKTtcbiAgaWYgKCF1c2VyUmVsYXlzKSByZXR1cm47XG4gIGZvciAoY29uc3QgdXJsIG9mIHVzZXJSZWxheXMucmVsYXlzKSB7XG4gICAgbGV0IHJlbGF5ID0gdGhpcy5wb29sLnJlbGF5cy5nZXQodXJsKTtcbiAgICBpZiAoIXJlbGF5KSB7XG4gICAgICByZWxheSA9IG5ldyBOREtSZWxheSh1cmwsIHRoaXMucmVsYXlBdXRoRGVmYXVsdFBvbGljeSwgdGhpcyk7XG4gICAgICB0aGlzLnBvb2wuYWRkUmVsYXkocmVsYXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdXNlclJlbGF5cztcbn1cbmFzeW5jIGZ1bmN0aW9uIHNldEFjdGl2ZVVzZXIodXNlcikge1xuICBjb25zdCBwb29sID0gdGhpcy5vdXRib3hQb29sIHx8IHRoaXMucG9vbDtcbiAgaWYgKHBvb2wuY29ubmVjdGVkUmVsYXlzLmxlbmd0aCA+IDApIHtcbiAgICBzZXRBY3RpdmVVc2VyQ29ubmVjdGVkLmNhbGwodGhpcywgdXNlcik7XG4gIH0gZWxzZSB7XG4gICAgcG9vbC5vbmNlKFwiY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICBzZXRBY3RpdmVVc2VyQ29ubmVjdGVkLmNhbGwodGhpcywgdXNlcik7XG4gICAgfSk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHNldEFjdGl2ZVVzZXJDb25uZWN0ZWQodXNlcikge1xuICBjb25zdCB1c2VyUmVsYXlzID0gYXdhaXQgZ2V0VXNlclJlbGF5TGlzdC5jYWxsKHRoaXMsIHVzZXIpO1xuICBjb25zdCBmaWx0ZXJzID0gW1xuICAgIHtcbiAgICAgIGtpbmRzOiBbMTAwMDYgLyogQmxvY2tSZWxheUxpc3QgKi9dLFxuICAgICAgYXV0aG9yczogW3VzZXIucHVia2V5XVxuICAgIH1cbiAgXTtcbiAgaWYgKHRoaXMuYXV0b0ZldGNoVXNlck11dGVsaXN0KSB7XG4gICAgZmlsdGVyc1swXS5raW5kcz8ucHVzaCgxZTQgLyogTXV0ZUxpc3QgKi8pO1xuICB9XG4gIGNvbnN0IGV2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHJlbGF5U2V0ID0gdXNlclJlbGF5cyA/IHVzZXJSZWxheXMucmVsYXlTZXQgOiB2b2lkIDA7XG4gIHRoaXMuc3Vic2NyaWJlKFxuICAgIGZpbHRlcnMsXG4gICAgeyBzdWJJZDogXCJhY3RpdmUtdXNlci1zZXR0aW5nc1wiLCBjbG9zZU9uRW9zZTogdHJ1ZSwgcmVsYXlTZXQgfSxcbiAgICB7XG4gICAgICBvbkV2ZW50OiAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgcHJldkV2ZW50ID0gZXZlbnRzLmdldChldmVudC5raW5kKTtcbiAgICAgICAgaWYgKHByZXZFdmVudCAmJiBwcmV2RXZlbnQuY3JlYXRlZF9hdCA+PSBldmVudC5jcmVhdGVkX2F0KSByZXR1cm47XG4gICAgICAgIGV2ZW50cy5zZXQoZXZlbnQua2luZCwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIG9uRW9zZTogKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cy52YWx1ZXMoKSkge1xuICAgICAgICAgIHByb2Nlc3NFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NFdmVudChldmVudCkge1xuICBpZiAoZXZlbnQua2luZCA9PT0gMTAwMDYgLyogQmxvY2tSZWxheUxpc3QgKi8pIHtcbiAgICBwcm9jZXNzQmxvY2tSZWxheUxpc3QuY2FsbCh0aGlzLCBldmVudCk7XG4gIH0gZWxzZSBpZiAoZXZlbnQua2luZCA9PT0gMWU0IC8qIE11dGVMaXN0ICovKSB7XG4gICAgcHJvY2Vzc011dGVMaXN0LmNhbGwodGhpcywgZXZlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzQmxvY2tSZWxheUxpc3QoZXZlbnQpIHtcbiAgY29uc3QgbGlzdCA9IGxpc3RzX2RlZmF1bHQuZnJvbShldmVudCk7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBsaXN0Lml0ZW1zKSB7XG4gICAgdGhpcy5wb29sLmJsYWNrbGlzdFJlbGF5VXJscy5hZGQoaXRlbVswXSk7XG4gIH1cbiAgZGVidWc2KFwiQWRkZWQgJWQgcmVsYXlzIHRvIHJlbGF5IGJsYWNrbGlzdFwiLCBsaXN0Lml0ZW1zLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBwcm9jZXNzTXV0ZUxpc3QobXV0ZUxpc3QpIHtcbiAgY29uc3QgbGlzdCA9IGxpc3RzX2RlZmF1bHQuZnJvbShtdXRlTGlzdCk7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBsaXN0Lml0ZW1zKSB7XG4gICAgdGhpcy5tdXRlZElkcy5zZXQoaXRlbVsxXSwgaXRlbVswXSk7XG4gIH1cbiAgZGVidWc2KFwiQWRkZWQgJWQgdXNlcnMgdG8gbXV0ZSBsaXN0XCIsIGxpc3QuaXRlbXMubGVuZ3RoKTtcbn1cblxuLy8gc3JjL25kay9lbnRpdHkudHNcbmltcG9ydCB7IG5pcDE5IGFzIG5pcDE5NyB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuZnVuY3Rpb24gZ2V0RW50aXR5KGVudGl0eSkge1xuICB0cnkge1xuICAgIGNvbnN0IGRlY29kZWQgPSBuaXAxOTcuZGVjb2RlKGVudGl0eSk7XG4gICAgaWYgKGRlY29kZWQudHlwZSA9PT0gXCJucHViXCIpIHJldHVybiBucHViKHRoaXMsIGRlY29kZWQuZGF0YSk7XG4gICAgaWYgKGRlY29kZWQudHlwZSA9PT0gXCJucHJvZmlsZVwiKSByZXR1cm4gbnByb2ZpbGUodGhpcywgZGVjb2RlZC5kYXRhKTtcbiAgICByZXR1cm4gZGVjb2RlZDtcbiAgfSBjYXRjaCAoX2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gbnB1YihuZGssIHB1YmtleSkge1xuICByZXR1cm4gbmRrLmdldFVzZXIoeyBwdWJrZXkgfSk7XG59XG5mdW5jdGlvbiBucHJvZmlsZShuZGssIHByb2ZpbGUpIHtcbiAgY29uc3QgdXNlciA9IG5kay5nZXRVc2VyKHsgcHVia2V5OiBwcm9maWxlLnB1YmtleSB9KTtcbiAgaWYgKHByb2ZpbGUucmVsYXlzKSB1c2VyLnJlbGF5VXJscyA9IHByb2ZpbGUucmVsYXlzO1xuICByZXR1cm4gdXNlcjtcbn1cblxuLy8gc3JjL25kay9mZXRjaC1ldmVudC1mcm9tLXRhZy50c1xuZnVuY3Rpb24gaXNWYWxpZEhpbnQoaGludCkge1xuICBpZiAoIWhpbnQgfHwgaGludCA9PT0gXCJcIikgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIG5ldyBVUkwoaGludCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKF9lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaEV2ZW50RnJvbVRhZyh0YWcsIG9yaWdpbmFsRXZlbnQsIHN1Yk9wdHMsIGZhbGxiYWNrID0ge1xuICB0eXBlOiBcInRpbWVvdXRcIlxufSkge1xuICBjb25zdCBkNCA9IHRoaXMuZGVidWcuZXh0ZW5kKFwiZmV0Y2gtZXZlbnQtZnJvbS10YWdcIik7XG4gIGNvbnN0IFtfLCBpZCwgaGludF0gPSB0YWc7XG4gIHN1Yk9wdHMgPSB7fTtcbiAgZDQoXCJmZXRjaGluZyBldmVudCBmcm9tIHRhZ1wiLCB0YWcsIHN1Yk9wdHMsIGZhbGxiYWNrKTtcbiAgY29uc3QgYXV0aG9yUmVsYXlzID0gZ2V0UmVsYXlzRm9yU3luYyh0aGlzLCBvcmlnaW5hbEV2ZW50LnB1YmtleSk7XG4gIGlmIChhdXRob3JSZWxheXMgJiYgYXV0aG9yUmVsYXlzLnNpemUgPiAwKSB7XG4gICAgZDQoXCJmZXRjaGluZyBldmVudCBmcm9tIGF1dGhvciByZWxheXMgJW9cIiwgQXJyYXkuZnJvbShhdXRob3JSZWxheXMpKTtcbiAgICBjb25zdCByZWxheVNldDIgPSBOREtSZWxheVNldC5mcm9tUmVsYXlVcmxzKEFycmF5LmZyb20oYXV0aG9yUmVsYXlzKSwgdGhpcyk7XG4gICAgY29uc3QgZXZlbnQyID0gYXdhaXQgdGhpcy5mZXRjaEV2ZW50KGlkLCBzdWJPcHRzLCByZWxheVNldDIpO1xuICAgIGlmIChldmVudDIpIHJldHVybiBldmVudDI7XG4gIH0gZWxzZSB7XG4gICAgZDQoXCJubyBhdXRob3IgcmVsYXlzIGZvdW5kIGZvciAlc1wiLCBvcmlnaW5hbEV2ZW50LnB1YmtleSwgb3JpZ2luYWxFdmVudCk7XG4gIH1cbiAgY29uc3QgcmVsYXlTZXQgPSBjYWxjdWxhdGVSZWxheVNldHNGcm9tRmlsdGVycyh0aGlzLCBbeyBpZHM6IFtpZF0gfV0sIHRoaXMucG9vbCk7XG4gIGQ0KFwiZmV0Y2hpbmcgZXZlbnQgd2l0aG91dCByZWxheSBoaW50XCIsIHJlbGF5U2V0KTtcbiAgY29uc3QgZXZlbnQgPSBhd2FpdCB0aGlzLmZldGNoRXZlbnQoaWQsIHN1Yk9wdHMpO1xuICBpZiAoZXZlbnQpIHJldHVybiBldmVudDtcbiAgaWYgKGhpbnQgJiYgaGludCAhPT0gXCJcIikge1xuICAgIGNvbnN0IGV2ZW50MiA9IGF3YWl0IHRoaXMuZmV0Y2hFdmVudChpZCwgc3ViT3B0cywgdGhpcy5wb29sLmdldFJlbGF5KGhpbnQsIHRydWUsIHRydWUsIFt7IGlkczogW2lkXSB9XSkpO1xuICAgIGlmIChldmVudDIpIHJldHVybiBldmVudDI7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IHZvaWQgMDtcbiAgY29uc3QgcmVsYXkgPSBpc1ZhbGlkSGludChoaW50KSA/IHRoaXMucG9vbC5nZXRSZWxheShoaW50LCBmYWxzZSwgdHJ1ZSwgW3sgaWRzOiBbaWRdIH1dKSA6IHZvaWQgMDtcbiAgY29uc3QgZmV0Y2hNYXliZVdpdGhSZWxheUhpbnQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHRoaXMuZmV0Y2hFdmVudChpZCwgc3ViT3B0cywgcmVsYXkpLnRoZW4ocmVzb2x2ZSk7XG4gIH0pO1xuICBpZiAoIWlzVmFsaWRIaW50KGhpbnQpIHx8IGZhbGxiYWNrLnR5cGUgPT09IFwibm9uZVwiKSB7XG4gICAgcmV0dXJuIGZldGNoTWF5YmVXaXRoUmVsYXlIaW50O1xuICB9XG4gIGNvbnN0IGZhbGxiYWNrRmV0Y2hQcm9taXNlID0gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBmYWxsYmFja1JlbGF5U2V0ID0gZmFsbGJhY2sucmVsYXlTZXQ7XG4gICAgY29uc3QgdGltZW91dCA9IGZhbGxiYWNrLnRpbWVvdXQgPz8gMTUwMDtcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlMikgPT4gc2V0VGltZW91dChyZXNvbHZlMiwgdGltZW91dCkpO1xuICAgIGlmIChmYWxsYmFjay50eXBlID09PSBcInRpbWVvdXRcIikgYXdhaXQgdGltZW91dFByb21pc2U7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkNChcImZhbGxiYWNrIGZldGNoIHRyaWdnZXJlZFwiKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrRXZlbnQgPSBhd2FpdCB0aGlzLmZldGNoRXZlbnQoaWQsIHN1Yk9wdHMsIGZhbGxiYWNrUmVsYXlTZXQpO1xuICAgICAgcmVzb2x2ZShmYWxsYmFja0V2ZW50KTtcbiAgICB9XG4gIH0pO1xuICBzd2l0Y2ggKGZhbGxiYWNrLnR5cGUpIHtcbiAgICBjYXNlIFwidGltZW91dFwiOlxuICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbZmV0Y2hNYXliZVdpdGhSZWxheUhpbnQsIGZhbGxiYWNrRmV0Y2hQcm9taXNlXSk7XG4gICAgY2FzZSBcImVvc2VcIjpcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGZldGNoTWF5YmVXaXRoUmVsYXlIaW50O1xuICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHJldHVybiBmYWxsYmFja0ZldGNoUHJvbWlzZTtcbiAgfVxufVxuXG4vLyBzcmMvbmRrL3F1ZXVlL2luZGV4LnRzXG52YXIgUXVldWUgPSBjbGFzcyB7XG4gIHF1ZXVlID0gW107XG4gIG1heENvbmN1cnJlbmN5O1xuICBwcm9jZXNzaW5nID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcHJvbWlzZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3RvcihfbmFtZSwgbWF4Q29uY3VycmVuY3kpIHtcbiAgICB0aGlzLm1heENvbmN1cnJlbmN5ID0gbWF4Q29uY3VycmVuY3k7XG4gIH1cbiAgYWRkKGl0ZW0pIHtcbiAgICBpZiAodGhpcy5wcm9taXNlcy5oYXMoaXRlbS5pZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb21pc2VzLmdldChpdGVtLmlkKTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucXVldWUucHVzaCh7XG4gICAgICAgIC4uLml0ZW0sXG4gICAgICAgIGZ1bmM6ICgpID0+IGl0ZW0uZnVuYygpLnRoZW4oXG4gICAgICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgICB0aGlzLnByb2Nlc3MoKTtcbiAgICB9KTtcbiAgICB0aGlzLnByb21pc2VzLnNldChpdGVtLmlkLCBwcm9taXNlKTtcbiAgICBwcm9taXNlLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdGhpcy5wcm9taXNlcy5kZWxldGUoaXRlbS5pZCk7XG4gICAgICB0aGlzLnByb2Nlc3NpbmcuZGVsZXRlKGl0ZW0uaWQpO1xuICAgICAgdGhpcy5wcm9jZXNzKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgcHJvY2VzcygpIHtcbiAgICBpZiAodGhpcy5wcm9jZXNzaW5nLnNpemUgPj0gdGhpcy5tYXhDb25jdXJyZW5jeSB8fCB0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgIGlmICghaXRlbSB8fCB0aGlzLnByb2Nlc3NpbmcuaGFzKGl0ZW0uaWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucHJvY2Vzc2luZy5hZGQoaXRlbS5pZCk7XG4gICAgaXRlbS5mdW5jKCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICB9XG4gIGNsZWFyUHJvY2Vzc2luZygpIHtcbiAgICB0aGlzLnByb2Nlc3NpbmcuY2xlYXIoKTtcbiAgfVxuICBjbGVhckFsbCgpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5jbGVhclByb2Nlc3NpbmcoKTtcbiAgfVxuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWUubGVuZ3RoO1xuICB9XG59O1xuXG4vLyBzcmMvbmRrL2luZGV4LnRzXG52YXIgREVGQVVMVF9PVVRCT1hfUkVMQVlTID0gW1wid3NzOi8vcHVycGxlcGFnLmVzL1wiLCBcIndzczovL25vcy5sb2wvXCJdO1xudmFyIERFRkFVTFRfQkxBQ0tMSVNURURfUkVMQVlTID0gW1xuICBcIndzczovL2JyYi5pby9cIixcbiAgLy8gQlJCXG4gIFwid3NzOi8vbm9zdHIubXV0aW55d2FsbGV0LmNvbS9cIlxuICAvLyBEb24ndCB0cnkgdG8gcmVhZCBmcm9tIHRoaXMgcmVsYXkgc2luY2UgaXQncyBhIHdyaXRlLW9ubHkgcmVsYXlcbiAgLy8gXCJ3c3M6Ly9wdXJwbGVwYWcuZXMvXCIsIC8vIFRoaXMgaXMgYSBoYWNrLCBzaW5jZSB0aGlzIGlzIGEgbW9zdGx5IHJlYWQtb25seSByZWxheSwgYnV0IG5vdCBmdWxseS4gT25jZSB3ZSBoYXZlIHJlbGF5IHJvdXRpbmcgdGhpcyBjYW4gYmUgcmVtb3ZlZCBzbyBpdCBvbmx5IHJlY2VpdmVzIHRoZSBzdXBwb3J0ZWQga2luZHNcbl07XG52YXIgTkRLID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXI4IHtcbiAgX2V4cGxpY2l0UmVsYXlVcmxzO1xuICBibGFja2xpc3RSZWxheVVybHM7XG4gIHBvb2w7XG4gIG91dGJveFBvb2w7XG4gIF9zaWduZXI7XG4gIF9hY3RpdmVVc2VyO1xuICBjYWNoZUFkYXB0ZXI7XG4gIGRlYnVnO1xuICBkZXZXcml0ZVJlbGF5U2V0O1xuICBvdXRib3hUcmFja2VyO1xuICBtdXRlZElkcztcbiAgY2xpZW50TmFtZTtcbiAgY2xpZW50TmlwODk7XG4gIHF1ZXVlc1phcENvbmZpZztcbiAgcXVldWVzTmlwMDU7XG4gIGFzeW5jU2lnVmVyaWZpY2F0aW9uID0gZmFsc2U7XG4gIGluaXRpYWxWYWxpZGF0aW9uUmF0aW8gPSAxO1xuICBsb3dlc3RWYWxpZGF0aW9uUmF0aW8gPSAxO1xuICB2YWxpZGF0aW9uUmF0aW9GbjtcbiAgc3ViTWFuYWdlcjtcbiAgcHVibGlzaGluZ0ZhaWx1cmVIYW5kbGVkID0gZmFsc2U7XG4gIHBvb2xzID0gW107XG4gIC8qKlxuICAgKiBEZWZhdWx0IHJlbGF5LWF1dGggcG9saWN5IHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gYSByZWxheSByZXF1ZXN0cyBhdXRoZW50aWNhdGlvbixcbiAgICogaWYgbm8gb3RoZXIgcG9saWN5IGlzIHNwZWNpZmllZCBmb3IgdGhhdCByZWxheS5cbiAgICpcbiAgICogQGV4YW1wbGUgRGlzY29ubmVjdCBmcm9tIHJlbGF5cyB0aGF0IHJlcXVlc3QgYXV0aGVudGljYXRpb246XG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogbmRrLnJlbGF5QXV0aERlZmF1bHRQb2xpY3kgPSBOREtBdXRoUG9saWNpZXMuZGlzY29ubmVjdChuZGsucG9vbCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZSBTaWduIGluIHRvIHJlbGF5cyB0aGF0IHJlcXVlc3QgYXV0aGVudGljYXRpb246XG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogbmRrLnJlbGF5QXV0aERlZmF1bHRQb2xpY3kgPSBOREtBdXRoUG9saWNpZXMuc2lnbkluKHtuZGt9KVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGUgU2lnbiBpbiB0byByZWxheXMgdGhhdCByZXF1ZXN0IGF1dGhlbnRpY2F0aW9uLCBhc2tpbmcgdGhlIHVzZXIgZm9yIGNvbmZpcm1hdGlvbjpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBuZGsucmVsYXlBdXRoRGVmYXVsdFBvbGljeSA9IChyZWxheTogTkRLUmVsYXkpID0+IHtcbiAgICogICAgIGNvbnN0IHNpZ25JbiA9IE5ES0F1dGhQb2xpY2llcy5zaWduSW4oe25ka30pO1xuICAgKiAgICAgaWYgKGNvbmZpcm0oYFJlbGF5ICR7cmVsYXkudXJsfSBpcyByZXF1ZXN0aW5nIGF1dGhlbnRpY2F0aW9uLCBkbyB5b3Ugd2FudCB0byBzaWduIGluP2ApKSB7XG4gICAqICAgICAgICBzaWduSW4ocmVsYXkpO1xuICAgKiAgICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgcmVsYXlBdXRoRGVmYXVsdFBvbGljeTtcbiAgLyoqXG4gICAqIEZldGNoIGZ1bmN0aW9uIHRvIHVzZSBmb3IgSFRUUCByZXF1ZXN0cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBpbXBvcnQgZmV0Y2ggZnJvbSBcIm5vZGUtZmV0Y2hcIjtcbiAgICpcbiAgICogbmRrLmh0dHBGZXRjaCA9IGZldGNoO1xuICAgKiBgYGBcbiAgICovXG4gIGh0dHBGZXRjaDtcbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBjYWxsZXIgZnVuY3Rpb24gdG8gcmVjZWl2ZSBhbGwgbmV0d29ya2luZyB0cmFmZmljIGZyb20gcmVsYXlzXG4gICAqL1xuICBuZXREZWJ1ZztcbiAgYXV0b0Nvbm5lY3RVc2VyUmVsYXlzID0gdHJ1ZTtcbiAgYXV0b0ZldGNoVXNlck11dGVsaXN0ID0gdHJ1ZTtcbiAgd2FsbGV0Q29uZmlnO1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGVidWcgPSBvcHRzLmRlYnVnIHx8IGRlYnVnNyhcIm5ka1wiKTtcbiAgICB0aGlzLm5ldERlYnVnID0gb3B0cy5uZXREZWJ1ZztcbiAgICB0aGlzLl9leHBsaWNpdFJlbGF5VXJscyA9IG9wdHMuZXhwbGljaXRSZWxheVVybHMgfHwgW107XG4gICAgdGhpcy5ibGFja2xpc3RSZWxheVVybHMgPSBvcHRzLmJsYWNrbGlzdFJlbGF5VXJscyB8fCBERUZBVUxUX0JMQUNLTElTVEVEX1JFTEFZUztcbiAgICB0aGlzLnN1Yk1hbmFnZXIgPSBuZXcgTkRLU3Vic2NyaXB0aW9uTWFuYWdlcigpO1xuICAgIHRoaXMucG9vbCA9IG5ldyBOREtQb29sKG9wdHMuZXhwbGljaXRSZWxheVVybHMgfHwgW10sIFtdLCB0aGlzKTtcbiAgICB0aGlzLnBvb2wubmFtZSA9IFwiTWFpblwiO1xuICAgIHRoaXMucG9vbC5vbihcInJlbGF5OmF1dGhcIiwgYXN5bmMgKHJlbGF5LCBjaGFsbGVuZ2UpID0+IHtcbiAgICAgIGlmICh0aGlzLnJlbGF5QXV0aERlZmF1bHRQb2xpY3kpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWxheUF1dGhEZWZhdWx0UG9saWN5KHJlbGF5LCBjaGFsbGVuZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYXV0b0Nvbm5lY3RVc2VyUmVsYXlzID0gb3B0cy5hdXRvQ29ubmVjdFVzZXJSZWxheXMgPz8gdHJ1ZTtcbiAgICB0aGlzLmF1dG9GZXRjaFVzZXJNdXRlbGlzdCA9IG9wdHMuYXV0b0ZldGNoVXNlck11dGVsaXN0ID8/IHRydWU7XG4gICAgdGhpcy5jbGllbnROYW1lID0gb3B0cy5jbGllbnROYW1lO1xuICAgIHRoaXMuY2xpZW50TmlwODkgPSBvcHRzLmNsaWVudE5pcDg5O1xuICAgIHRoaXMucmVsYXlBdXRoRGVmYXVsdFBvbGljeSA9IG9wdHMucmVsYXlBdXRoRGVmYXVsdFBvbGljeTtcbiAgICBpZiAob3B0cy5lbmFibGVPdXRib3hNb2RlbCkge1xuICAgICAgdGhpcy5vdXRib3hQb29sID0gbmV3IE5ES1Bvb2wob3B0cy5vdXRib3hSZWxheVVybHMgfHwgREVGQVVMVF9PVVRCT1hfUkVMQVlTLCBbXSwgdGhpcywge1xuICAgICAgICBkZWJ1ZzogdGhpcy5kZWJ1Zy5leHRlbmQoXCJvdXRib3gtcG9vbFwiKSxcbiAgICAgICAgbmFtZTogXCJPdXRib3ggUG9vbFwiXG4gICAgICB9KTtcbiAgICAgIHRoaXMub3V0Ym94VHJhY2tlciA9IG5ldyBPdXRib3hUcmFja2VyKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnNpZ25lciA9IG9wdHMuc2lnbmVyO1xuICAgIHRoaXMuY2FjaGVBZGFwdGVyID0gb3B0cy5jYWNoZUFkYXB0ZXI7XG4gICAgdGhpcy5tdXRlZElkcyA9IG9wdHMubXV0ZWRJZHMgfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBpZiAob3B0cy5kZXZXcml0ZVJlbGF5VXJscykge1xuICAgICAgdGhpcy5kZXZXcml0ZVJlbGF5U2V0ID0gTkRLUmVsYXlTZXQuZnJvbVJlbGF5VXJscyhvcHRzLmRldldyaXRlUmVsYXlVcmxzLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5xdWV1ZXNaYXBDb25maWcgPSBuZXcgUXVldWUoXCJ6YXBzXCIsIDMpO1xuICAgIHRoaXMucXVldWVzTmlwMDUgPSBuZXcgUXVldWUoXCJuaXAwNVwiLCAxMCk7XG4gICAgdGhpcy5zaWduYXR1cmVWZXJpZmljYXRpb25Xb3JrZXIgPSBvcHRzLnNpZ25hdHVyZVZlcmlmaWNhdGlvbldvcmtlcjtcbiAgICB0aGlzLmluaXRpYWxWYWxpZGF0aW9uUmF0aW8gPSBvcHRzLmluaXRpYWxWYWxpZGF0aW9uUmF0aW8gfHwgMTtcbiAgICB0aGlzLmxvd2VzdFZhbGlkYXRpb25SYXRpbyA9IG9wdHMubG93ZXN0VmFsaWRhdGlvblJhdGlvIHx8IDE7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuaHR0cEZldGNoID0gZmV0Y2g7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIHNldCBleHBsaWNpdFJlbGF5VXJscyh1cmxzKSB7XG4gICAgdGhpcy5fZXhwbGljaXRSZWxheVVybHMgPSB1cmxzLm1hcChub3JtYWxpemVSZWxheVVybCk7XG4gICAgdGhpcy5wb29sLnJlbGF5VXJscyA9IHVybHM7XG4gIH1cbiAgZ2V0IGV4cGxpY2l0UmVsYXlVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLl9leHBsaWNpdFJlbGF5VXJscyB8fCBbXTtcbiAgfVxuICBzZXQgc2lnbmF0dXJlVmVyaWZpY2F0aW9uV29ya2VyKHdvcmtlcjIpIHtcbiAgICB0aGlzLmFzeW5jU2lnVmVyaWZpY2F0aW9uID0gISF3b3JrZXIyO1xuICAgIGlmICh3b3JrZXIyKSB7XG4gICAgICBzaWduYXR1cmVWZXJpZmljYXRpb25Jbml0KHdvcmtlcjIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBleHBsaWNpdCByZWxheSB0byB0aGUgcG9vbC5cbiAgICogQHBhcmFtIHVybFxuICAgKiBAcGFyYW0gcmVsYXlBdXRoUG9saWN5IEF1dGhlbnRpY2F0aW9uIHBvbGljeSB0byB1c2UgaWYgZGlmZmVyZW50IGZyb20gdGhlIGRlZmF1bHRcbiAgICogQHBhcmFtIGNvbm5lY3QgV2hldGhlciB0byBjb25uZWN0IHRvIHRoZSByZWxheSBhdXRvbWF0aWNhbGx5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhZGRFeHBsaWNpdFJlbGF5KHVybE9yUmVsYXksIHJlbGF5QXV0aFBvbGljeSwgY29ubmVjdCA9IHRydWUpIHtcbiAgICBsZXQgcmVsYXk7XG4gICAgaWYgKHR5cGVvZiB1cmxPclJlbGF5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZWxheSA9IG5ldyBOREtSZWxheSh1cmxPclJlbGF5LCByZWxheUF1dGhQb2xpY3ksIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWxheSA9IHVybE9yUmVsYXk7XG4gICAgfVxuICAgIHRoaXMucG9vbC5hZGRSZWxheShyZWxheSwgY29ubmVjdCk7XG4gICAgdGhpcy5leHBsaWNpdFJlbGF5VXJscz8ucHVzaChyZWxheS51cmwpO1xuICAgIHJldHVybiByZWxheTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHsgcmVsYXlDb3VudDogdGhpcy5wb29sLnJlbGF5cy5zaXplIH0udG9TdHJpbmcoKTtcbiAgfVxuICBnZXQgYWN0aXZlVXNlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlVXNlcjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgYWN0aXZlIHVzZXIgZm9yIHRoaXMgTkRLIGluc3RhbmNlLCB0eXBpY2FsbHkgdGhpcyB3aWxsIGJlXG4gICAqIGNhbGxlZCB3aGVuIGFzc2lnbmluZyBhIHNpZ25lciB0byB0aGUgTkRLIGluc3RhbmNlLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYXV0b21hdGljYWxseSBjb25uZWN0IHRvIHRoZSB1c2VyJ3MgcmVsYXlzIGlmXG4gICAqIGBhdXRvQ29ubmVjdFVzZXJSZWxheXNgIGlzIHNldCB0byB0cnVlLlxuICAgKlxuICAgKiBJdCB3aWxsIGFsc28gZmV0Y2ggdGhlIHVzZXIncyBtdXRlbGlzdCBpZiBgYXV0b0ZldGNoVXNlck11dGVsaXN0YCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICovXG4gIHNldCBhY3RpdmVVc2VyKHVzZXIpIHtcbiAgICBjb25zdCBkaWZmZXJlbnRVc2VyID0gdGhpcy5fYWN0aXZlVXNlcj8ucHVia2V5ICE9PSB1c2VyPy5wdWJrZXk7XG4gICAgdGhpcy5fYWN0aXZlVXNlciA9IHVzZXI7XG4gICAgaWYgKHVzZXIgJiYgZGlmZmVyZW50VXNlcikge1xuICAgICAgc2V0QWN0aXZlVXNlci5jYWxsKHRoaXMsIHVzZXIpO1xuICAgIH0gZWxzZSBpZiAoIXVzZXIpIHtcbiAgICAgIHRoaXMubXV0ZWRJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIH1cbiAgfVxuICBnZXQgc2lnbmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9zaWduZXI7XG4gIH1cbiAgc2V0IHNpZ25lcihuZXdTaWduZXIpIHtcbiAgICB0aGlzLl9zaWduZXIgPSBuZXdTaWduZXI7XG4gICAgaWYgKG5ld1NpZ25lcikgdGhpcy5lbWl0KFwic2lnbmVyOnJlYWR5XCIsIG5ld1NpZ25lcik7XG4gICAgbmV3U2lnbmVyPy51c2VyKCkudGhlbigodXNlcikgPT4ge1xuICAgICAgdXNlci5uZGsgPSB0aGlzO1xuICAgICAgdGhpcy5hY3RpdmVVc2VyID0gdXNlcjtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ29ubmVjdCB0byByZWxheXMgd2l0aCBvcHRpb25hbCB0aW1lb3V0LlxuICAgKiBJZiB0aGUgdGltZW91dCBpcyByZWFjaGVkLCB0aGUgY29ubmVjdGlvbiB3aWxsIGJlIGNvbnRpbnVlZCB0byBiZSBlc3RhYmxpc2hlZCBpbiB0aGUgYmFja2dyb3VuZC5cbiAgICovXG4gIGFzeW5jIGNvbm5lY3QodGltZW91dE1zKSB7XG4gICAgaWYgKHRoaXMuX3NpZ25lciAmJiB0aGlzLmF1dG9Db25uZWN0VXNlclJlbGF5cykge1xuICAgICAgdGhpcy5kZWJ1ZyhcbiAgICAgICAgXCJBdHRlbXB0aW5nIHRvIGNvbm5lY3QgdG8gdXNlciByZWxheXMgc3BlY2lmaWVkIGJ5IHNpZ25lciAlb1wiLFxuICAgICAgICBhd2FpdCB0aGlzLl9zaWduZXIucmVsYXlzPy4odGhpcylcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5fc2lnbmVyLnJlbGF5cykge1xuICAgICAgICBjb25zdCByZWxheXMgPSBhd2FpdCB0aGlzLl9zaWduZXIucmVsYXlzKHRoaXMpO1xuICAgICAgICByZWxheXMuZm9yRWFjaCgocmVsYXkpID0+IHRoaXMucG9vbC5hZGRSZWxheShyZWxheSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IFt0aGlzLnBvb2wuY29ubmVjdCh0aW1lb3V0TXMpXTtcbiAgICBpZiAodGhpcy5vdXRib3hQb29sKSB7XG4gICAgICBjb25uZWN0aW9ucy5wdXNoKHRoaXMub3V0Ym94UG9vbC5jb25uZWN0KHRpbWVvdXRNcykpO1xuICAgIH1cbiAgICB0aGlzLmRlYnVnKFwiQ29ubmVjdGluZyB0byByZWxheXMgJW9cIiwgeyB0aW1lb3V0TXMgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsU2V0dGxlZChjb25uZWN0aW9ucykudGhlbigoKSA9PiB7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIE5ES1VzZXIgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSBvcHRzXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRVc2VyKG9wdHMpIHtcbiAgICBjb25zdCB1c2VyID0gbmV3IE5ES1VzZXIob3B0cyk7XG4gICAgdXNlci5uZGsgPSB0aGlzO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBOREtVc2VyIGZyb20gYSBOSVAwNVxuICAgKiBAcGFyYW0gbmlwMDUgTklQLTA1IElEXG4gICAqIEBwYXJhbSBza2lwQ2FjaGUgU2tpcCBjYWNoZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgZ2V0VXNlckZyb21OaXAwNShuaXAwNSwgc2tpcENhY2hlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gTkRLVXNlci5mcm9tTmlwMDUobmlwMDUsIHRoaXMsIHNraXBDYWNoZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIHN0YXJ0cyBhIG5ldyBzdWJzY3JpcHRpb24uXG4gICAqXG4gICAqIFN1YnNjcmlwdGlvbnMgYXV0b21hdGljYWxseSBzdGFydCB1bmxlc3MgYGF1dG9TdGFydGAgaXMgc2V0IHRvIGBmYWxzZWAuXG4gICAqIFlvdSBjYW4gY29udHJvbCBhdXRvbWF0aWMgY2xvc2luZyBvbiBFT1NFIHZpYSBgb3B0cy5jbG9zZU9uRW9zZWAuXG4gICAqXG4gICAqIEBwYXJhbSBmaWx0ZXJzIC0gQSBzaW5nbGUgTkRLRmlsdGVyIG9iamVjdCBvciBhbiBhcnJheSBvZiBmaWx0ZXJzLlxuICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbmFsIE5ES1N1YnNjcmlwdGlvbk9wdGlvbnMgdG8gY3VzdG9taXplIGJlaGF2aW9yIChlLmcuLCBjYWNoaW5nLCBncm91cGluZykuXG4gICAqIEBwYXJhbSBoYW5kbGVycyAtIE9wdGlvbmFsIGhhbmRsZXJzIGZvciBzdWJzY3JpcHRpb24gZXZlbnRzLiBQYXNzaW5nIGhhbmRsZXJzIGlzIHRoZSBwcmVmZXJyZWQgbWV0aG9kIG9mIHVzaW5nIG5kay5zdWJzY3JpYmUuXG4gICAqICAgLSBgb25FdmVudGA6IENhbGxlZCBmb3IgZWFjaCBldmVudCByZWNlaXZlZC5cbiAgICogIC0gYG9uRXZlbnRzYDogQ2FsbGVkIG9uY2Ugd2l0aCBhbiBhcnJheSBvZiBldmVudHMgd2hlbiB0aGUgc3Vic2NyaXB0aW9uIHN0YXJ0cyAoZnJvbSB0aGUgY2FjaGUpLlxuICAgKiAgLSBgb25Fb3NlYDogQ2FsbGVkIHdoZW4gdGhlIHN1YnNjcmlwdGlvbiByZWNlaXZlcyBFT1NFLlxuICAgKiAgRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB0aGlzIHRoaXJkIHBhcmFtZXRlciBhbHNvIGFjY2VwdHMgYSByZWxheVNldCwgdGhlIHJlbGF5U2V0IHNob3VsZCBiZSBwYXNzZWQgdmlhIGBvcHRzLnJlbGF5U2V0YC5cbiAgICpcbiAgICogQHBhcmFtIF9hdXRvU3RhcnQgLSBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHRoaXMgY2FuIGJlIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gc3RhcnQgdGhlIHN1YnNjcmlwdGlvbiBpbW1lZGlhdGVseS5cbiAgICogIFRoaXMgcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlxuICAgKiAgIC0gYGZhbHNlYDogQ3JlYXRlcyB0aGUgc3Vic2NyaXB0aW9uIGJ1dCBkb2VzIG5vdCBzdGFydCBpdCAoY2FsbCBgc3Vic2NyaXB0aW9uLnN0YXJ0KClgIG1hbnVhbGx5KS5cbiAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgTkRLU3Vic2NyaXB0aW9uIGluc3RhbmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZSBCYXNpYyBzdWJzY3JpcHRpb25cbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBzdWIgPSBuZGsuc3Vic2NyaWJlKHsga2luZHM6IFsxXSwgYXV0aG9yczogW3B1YmtleV0gfSk7XG4gICAqIHN1Yi5vbihcImV2ZW50XCIsIChldmVudCkgPT4gY29uc29sZS5sb2coXCJLaW5kIDEgZXZlbnQ6XCIsIGV2ZW50LmNvbnRlbnQpKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlIFN1YnNjcmlwdGlvbiB3aXRoIG9wdGlvbnMgYW5kIGRpcmVjdCBoYW5kbGVyc1xuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHN1YiA9IG5kay5zdWJzY3JpYmUoXG4gICAqICAgeyBraW5kczogWzBdLCBhdXRob3JzOiBbcHVia2V5XSB9LFxuICAgKiAgIHsgY2xvc2VPbkVvc2U6IHRydWUsIGNhY2hlVXNhZ2U6IE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UuUEFSQUxMRUwgfSxcbiAgICogICB1bmRlZmluZWQsIC8vIFVzZSBkZWZhdWx0IHJlbGF5IHNldCBjYWxjdWxhdGlvblxuICAgKiAgIHtcbiAgICogICAgIG9uRXZlbnRzOiAoZXZlbnRzKSA9PiB7IC8vIFJlbmFtZWQgcGFyYW1ldGVyXG4gICAqICAgICAgIGlmIChldmVudHMubGVuZ3RoID4gMCkge1xuICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGBHb3QgJHtldmVudHMubGVuZ3RofSBwcm9maWxlIGV2ZW50cyBmcm9tIGNhY2hlOmAsIGV2ZW50c1swXS5jb250ZW50KTtcbiAgICogICAgICAgfVxuICAgKiAgICAgfSxcbiAgICogICAgIG9uRXZlbnQ6IChldmVudCkgPT4geyAvLyBSZW5hbWVkIHBhcmFtZXRlclxuICAgKiAgICAgICBjb25zb2xlLmxvZyhcIkdvdCBwcm9maWxlIHVwZGF0ZSBmcm9tIHJlbGF5OlwiLCBldmVudC5jb250ZW50KTsgLy8gQ2xhcmlmaWVkIHNvdXJjZVxuICAgKiAgICAgfSxcbiAgICogICAgIG9uRW9zZTogKCkgPT4gY29uc29sZS5sb2coXCJQcm9maWxlIHN1YnNjcmlwdGlvbiBmaW5pc2hlZC5cIilcbiAgICogICB9XG4gICAqICk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2luY2UgMi4xMy4wIGByZWxheVNldGAgcGFyYW1ldGVyIHJlbW92ZWQ7IHBhc3MgYHJlbGF5U2V0YCBvciBgcmVsYXlVcmxzYCB2aWEgYG9wdHNgLlxuICAgKi9cbiAgc3Vic2NyaWJlKGZpbHRlcnMsIG9wdHMsIGF1dG9TdGFydE9yUmVsYXlTZXQgPSB0cnVlLCBfYXV0b1N0YXJ0ID0gdHJ1ZSkge1xuICAgIGxldCBfcmVsYXlTZXQgPSBvcHRzPy5yZWxheVNldDtcbiAgICBsZXQgYXV0b1N0YXJ0ID0gX2F1dG9TdGFydDtcbiAgICBpZiAoYXV0b1N0YXJ0T3JSZWxheVNldCBpbnN0YW5jZW9mIE5ES1JlbGF5U2V0KSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJyZWxheVNldCBpcyBkZXByZWNhdGVkLCB1c2Ugb3B0cy5yZWxheVNldCBpbnN0ZWFkLiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIHYyLjE0LjBcIik7XG4gICAgICBfcmVsYXlTZXQgPSBhdXRvU3RhcnRPclJlbGF5U2V0O1xuICAgICAgYXV0b1N0YXJ0ID0gX2F1dG9TdGFydDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhdXRvU3RhcnRPclJlbGF5U2V0ID09PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgYXV0b1N0YXJ0T3JSZWxheVNldCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgYXV0b1N0YXJ0ID0gYXV0b1N0YXJ0T3JSZWxheVNldDtcbiAgICB9XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbmV3IE5ES1N1YnNjcmlwdGlvbih0aGlzLCBmaWx0ZXJzLCB7IHJlbGF5U2V0OiBfcmVsYXlTZXQsIC4uLm9wdHMgfSk7XG4gICAgdGhpcy5zdWJNYW5hZ2VyLmFkZChzdWJzY3JpcHRpb24pO1xuICAgIGNvbnN0IHBvb2wgPSBzdWJzY3JpcHRpb24ucG9vbDtcbiAgICBpZiAoc3Vic2NyaXB0aW9uLnJlbGF5U2V0KSB7XG4gICAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHN1YnNjcmlwdGlvbi5yZWxheVNldC5yZWxheXMpIHtcbiAgICAgICAgcG9vbC51c2VUZW1wb3JhcnlSZWxheShyZWxheSwgdm9pZCAwLCBzdWJzY3JpcHRpb24uZmlsdGVycyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm91dGJveFBvb2wgJiYgc3Vic2NyaXB0aW9uLmhhc0F1dGhvcnNGaWx0ZXIoKSkge1xuICAgICAgY29uc3QgYXV0aG9ycyA9IHN1YnNjcmlwdGlvbi5maWx0ZXJzLmZpbHRlcigoZmlsdGVyKSA9PiBmaWx0ZXIuYXV0aG9ycyAmJiBmaWx0ZXIuYXV0aG9ycz8ubGVuZ3RoID4gMCkuZmxhdE1hcCgoZmlsdGVyKSA9PiBmaWx0ZXIuYXV0aG9ycyk7XG4gICAgICB0aGlzLm91dGJveFRyYWNrZXI/LnRyYWNrVXNlcnMoYXV0aG9ycyk7XG4gICAgfVxuICAgIGlmIChhdXRvU3RhcnQpIHtcbiAgICAgIGxldCBldmVudHNIYW5kbGVyO1xuICAgICAgaWYgKHR5cGVvZiBhdXRvU3RhcnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKGF1dG9TdGFydC5vbkV2ZW50KSBzdWJzY3JpcHRpb24ub24oXCJldmVudFwiLCBhdXRvU3RhcnQub25FdmVudCk7XG4gICAgICAgIGlmIChhdXRvU3RhcnQub25Fb3NlKSBzdWJzY3JpcHRpb24ub24oXCJlb3NlXCIsIGF1dG9TdGFydC5vbkVvc2UpO1xuICAgICAgICBpZiAoYXV0b1N0YXJ0Lm9uRXZlbnRzKSBldmVudHNIYW5kbGVyID0gYXV0b1N0YXJ0Lm9uRXZlbnRzO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhY2hlZEV2ZW50cyA9IHN1YnNjcmlwdGlvbi5zdGFydCghZXZlbnRzSGFuZGxlcik7XG4gICAgICAgIGlmIChjYWNoZWRFdmVudHMgJiYgY2FjaGVkRXZlbnRzLmxlbmd0aCA+IDAgJiYgISFldmVudHNIYW5kbGVyKSBldmVudHNIYW5kbGVyKGNhY2hlZEV2ZW50cyk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgfVxuICAvKipcbiAgICogUHVibGlzaCBhbiBldmVudCB0byBhIHJlbGF5XG4gICAqIEBwYXJhbSBldmVudCBldmVudCB0byBwdWJsaXNoXG4gICAqIEBwYXJhbSByZWxheVNldCBleHBsaWNpdCByZWxheSBzZXQgdG8gdXNlXG4gICAqIEBwYXJhbSB0aW1lb3V0TXMgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgdGhlIGV2ZW50IHRvIGJlIHB1Ymxpc2hlZFxuICAgKiBAcmV0dXJucyBUaGUgcmVsYXlzIHRoZSBldmVudCB3YXMgcHVibGlzaGVkIHRvXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgZXZlbnQucHVibGlzaCgpYCBpbnN0ZWFkXG4gICAqL1xuICBhc3luYyBwdWJsaXNoKGV2ZW50LCByZWxheVNldCwgdGltZW91dE1zKSB7XG4gICAgdGhpcy5kZWJ1ZyhcIkRlcHJlY2F0ZWQ6IFVzZSBgZXZlbnQucHVibGlzaCgpYCBpbnN0ZWFkXCIpO1xuICAgIHJldHVybiBldmVudC5wdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMpO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBmZXRjaCBhbiBldmVudCBmcm9tIGEgdGFnLCBmb2xsb3dpbmcgcmVsYXkgaGludHMgYW5kXG4gICAqIG90aGVyIGJlc3QgcHJhY3RpY2VzLlxuICAgKiBAcGFyYW0gdGFnIFRhZyB0byBmZXRjaCB0aGUgZXZlbnQgZnJvbVxuICAgKiBAcGFyYW0gb3JpZ2luYWxFdmVudCBFdmVudCB3aGVyZSB0aGUgdGFnIGNhbWUgZnJvbVxuICAgKiBAcGFyYW0gc3ViT3B0cyBTdWJzY3JpcHRpb24gb3B0aW9ucyB0byB1c2Ugd2hlbiBmZXRjaGluZyB0aGUgZXZlbnRcbiAgICogQHBhcmFtIGZhbGxiYWNrIEZhbGxiYWNrIG9wdGlvbnMgdG8gdXNlIHdoZW4gdGhlIGhpbnQgcmVsYXkgZG9lc24ndCByZXNwb25kXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBmZXRjaEV2ZW50RnJvbVRhZyA9IGZldGNoRXZlbnRGcm9tVGFnLmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBGZXRjaCBhbiBldmVudCBmcm9tIHRoZSBjYWNoZSBzeW5jaHJvbm91c2x5LlxuICAgKiBAcGFyYW0gaWRPckZpbHRlciBldmVudCBpZCBpbiBiZWNoMzIgZm9ybWF0IG9yIGZpbHRlclxuICAgKiBAcmV0dXJucyBldmVudHMgZnJvbSB0aGUgY2FjaGUgb3IgbnVsbCBpZiB0aGUgY2FjaGUgaXMgZW1wdHlcbiAgICovXG4gIGZldGNoRXZlbnRTeW5jKGlkT3JGaWx0ZXIpIHtcbiAgICBpZiAoIXRoaXMuY2FjaGVBZGFwdGVyKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWNoZSBhZGFwdGVyIG5vdCBzZXRcIik7XG4gICAgbGV0IGZpbHRlcnM7XG4gICAgaWYgKHR5cGVvZiBpZE9yRmlsdGVyID09PSBcInN0cmluZ1wiKSBmaWx0ZXJzID0gW2ZpbHRlckZyb21JZChpZE9yRmlsdGVyKV07XG4gICAgZWxzZSBmaWx0ZXJzID0gaWRPckZpbHRlcjtcbiAgICBjb25zdCBzdWIgPSBuZXcgTkRLU3Vic2NyaXB0aW9uKHRoaXMsIGZpbHRlcnMpO1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuY2FjaGVBZGFwdGVyLnF1ZXJ5KHN1Yik7XG4gICAgaWYgKGV2ZW50cyBpbnN0YW5jZW9mIFByb21pc2UpIHRocm93IG5ldyBFcnJvcihcIkNhY2hlIGFkYXB0ZXIgaXMgYXN5bmNcIik7XG4gICAgcmV0dXJuIGV2ZW50cy5tYXAoKGUpID0+IHtcbiAgICAgIGUubmRrID0gdGhpcztcbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHNpbmdsZSBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIGlkT3JGaWx0ZXIgZXZlbnQgaWQgaW4gYmVjaDMyIGZvcm1hdCBvciBmaWx0ZXJcbiAgICogQHBhcmFtIG9wdHMgc3Vic2NyaXB0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHJlbGF5U2V0T3JSZWxheSBleHBsaWNpdCByZWxheSBzZXQgdG8gdXNlXG4gICAqL1xuICBhc3luYyBmZXRjaEV2ZW50KGlkT3JGaWx0ZXIsIG9wdHMsIHJlbGF5U2V0T3JSZWxheSkge1xuICAgIGxldCBmaWx0ZXJzO1xuICAgIGxldCByZWxheVNldDtcbiAgICBpZiAocmVsYXlTZXRPclJlbGF5IGluc3RhbmNlb2YgTkRLUmVsYXkpIHtcbiAgICAgIHJlbGF5U2V0ID0gbmV3IE5ES1JlbGF5U2V0KC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtyZWxheVNldE9yUmVsYXldKSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChyZWxheVNldE9yUmVsYXkgaW5zdGFuY2VvZiBOREtSZWxheVNldCkge1xuICAgICAgcmVsYXlTZXQgPSByZWxheVNldE9yUmVsYXk7XG4gICAgfVxuICAgIGlmICghcmVsYXlTZXRPclJlbGF5ICYmIHR5cGVvZiBpZE9yRmlsdGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoIWlzTmlwMzNBVmFsdWUoaWRPckZpbHRlcikpIHtcbiAgICAgICAgY29uc3QgcmVsYXlzID0gcmVsYXlzRnJvbUJlY2gzMihpZE9yRmlsdGVyLCB0aGlzKTtcbiAgICAgICAgaWYgKHJlbGF5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmVsYXlTZXQgPSBuZXcgTkRLUmVsYXlTZXQobmV3IFNldChyZWxheXMpLCB0aGlzKTtcbiAgICAgICAgICByZWxheVNldCA9IGNvcnJlY3RSZWxheVNldChyZWxheVNldCwgdGhpcy5wb29sKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGlkT3JGaWx0ZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGZpbHRlcnMgPSBbZmlsdGVyRnJvbUlkKGlkT3JGaWx0ZXIpXTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaWRPckZpbHRlcikpIHtcbiAgICAgIGZpbHRlcnMgPSBpZE9yRmlsdGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWx0ZXJzID0gW2lkT3JGaWx0ZXJdO1xuICAgIH1cbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWx0ZXI6ICR7SlNPTi5zdHJpbmdpZnkoaWRPckZpbHRlcil9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgbGV0IGZldGNoZWRFdmVudCA9IG51bGw7XG4gICAgICBjb25zdCBzdWJzY3JpYmVPcHRzID0ge1xuICAgICAgICAuLi5vcHRzIHx8IHt9LFxuICAgICAgICBjbG9zZU9uRW9zZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGlmIChyZWxheVNldCkgc3Vic2NyaWJlT3B0cy5yZWxheVNldCA9IHJlbGF5U2V0O1xuICAgICAgY29uc3QgcyA9IHRoaXMuc3Vic2NyaWJlKFxuICAgICAgICBmaWx0ZXJzLFxuICAgICAgICBzdWJzY3JpYmVPcHRzLFxuICAgICAgICAvLyByZWxheVNldCwgLy8gUmVtb3ZlZDogUGFzc2VkIHZpYSBvcHRzXG4gICAgICAgIGZhbHNlXG4gICAgICAgIC8vIGF1dG9TdGFydCA9IGZhbHNlXG4gICAgICApO1xuICAgICAgY29uc3QgdDIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcy5zdG9wKCk7XG4gICAgICAgIHJlc29sdmUoZmV0Y2hlZEV2ZW50KTtcbiAgICAgIH0sIDFlNCk7XG4gICAgICBzLm9uKFwiZXZlbnRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50Lm5kayA9IHRoaXM7XG4gICAgICAgIGlmICghZXZlbnQuaXNSZXBsYWNlYWJsZSgpKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHQyKTtcbiAgICAgICAgICByZXNvbHZlKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICghZmV0Y2hlZEV2ZW50IHx8IGZldGNoZWRFdmVudC5jcmVhdGVkX2F0IDwgZXZlbnQuY3JlYXRlZF9hdCkge1xuICAgICAgICAgIGZldGNoZWRFdmVudCA9IGV2ZW50O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHMub24oXCJlb3NlXCIsICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHQyKTtcbiAgICAgICAgcmVzb2x2ZShmZXRjaGVkRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICBzLnN0YXJ0KCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGV2ZW50c1xuICAgKi9cbiAgYXN5bmMgZmV0Y2hFdmVudHMoZmlsdGVycywgb3B0cywgcmVsYXlTZXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBzdWJzY3JpYmVPcHRzID0ge1xuICAgICAgICAuLi5vcHRzIHx8IHt9LFxuICAgICAgICBjbG9zZU9uRW9zZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGlmIChyZWxheVNldCkgc3Vic2NyaWJlT3B0cy5yZWxheVNldCA9IHJlbGF5U2V0O1xuICAgICAgY29uc3QgcmVsYXlTZXRTdWJzY3JpcHRpb24gPSB0aGlzLnN1YnNjcmliZShcbiAgICAgICAgZmlsdGVycyxcbiAgICAgICAgc3Vic2NyaWJlT3B0cyxcbiAgICAgICAgLy8gcmVsYXlTZXQsIC8vIFJlbW92ZWQ6IFBhc3NlZCB2aWEgb3B0c1xuICAgICAgICBmYWxzZVxuICAgICAgICAvLyBhdXRvU3RhcnQgPSBmYWxzZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IG9uRXZlbnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgbGV0IF9ldmVudDtcbiAgICAgICAgaWYgKCEoZXZlbnQgaW5zdGFuY2VvZiBOREtFdmVudCkpIF9ldmVudCA9IG5ldyBOREtFdmVudCh2b2lkIDAsIGV2ZW50KTtcbiAgICAgICAgZWxzZSBfZXZlbnQgPSBldmVudDtcbiAgICAgICAgY29uc3QgZGVkdXBLZXkgPSBfZXZlbnQuZGVkdXBsaWNhdGlvbktleSgpO1xuICAgICAgICBjb25zdCBleGlzdGluZ0V2ZW50ID0gZXZlbnRzLmdldChkZWR1cEtleSk7XG4gICAgICAgIGlmIChleGlzdGluZ0V2ZW50KSB7XG4gICAgICAgICAgX2V2ZW50ID0gZGVkdXAoZXhpc3RpbmdFdmVudCwgX2V2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBfZXZlbnQubmRrID0gdGhpcztcbiAgICAgICAgZXZlbnRzLnNldChkZWR1cEtleSwgX2V2ZW50KTtcbiAgICAgIH07XG4gICAgICByZWxheVNldFN1YnNjcmlwdGlvbi5vbihcImV2ZW50XCIsIG9uRXZlbnQpO1xuICAgICAgcmVsYXlTZXRTdWJzY3JpcHRpb24ub24oXCJlb3NlXCIsICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShuZXcgU2V0KGV2ZW50cy52YWx1ZXMoKSkpO1xuICAgICAgfSk7XG4gICAgICByZWxheVNldFN1YnNjcmlwdGlvbi5zdGFydCgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoYXQgYSBzaWduZXIgaXMgYXZhaWxhYmxlIHRvIHNpZ24gYW4gZXZlbnQuXG4gICAqL1xuICBhc3NlcnRTaWduZXIoKSB7XG4gICAgaWYgKCF0aGlzLnNpZ25lcikge1xuICAgICAgdGhpcy5lbWl0KFwic2lnbmVyOnJlcXVpcmVkXCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbmVyIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgfVxuICBnZXRFbnRpdHkgPSBnZXRFbnRpdHkuYmluZCh0aGlzKTtcbiAgc2V0IHdhbGxldCh3YWxsZXQpIHtcbiAgICBpZiAoIXdhbGxldCkge1xuICAgICAgdGhpcy53YWxsZXRDb25maWcgPSB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMud2FsbGV0Q29uZmlnID8/PSB7fTtcbiAgICB0aGlzLndhbGxldENvbmZpZy5sblBheSA9IHdhbGxldD8ubG5QYXk/LmJpbmQod2FsbGV0KTtcbiAgICB0aGlzLndhbGxldENvbmZpZy5jYXNodVBheSA9IHdhbGxldD8uY2FzaHVQYXk/LmJpbmQod2FsbGV0KTtcbiAgfVxufTtcblxuLy8gc3JjL3phcC9pbnZvaWNlLnRzXG5pbXBvcnQgeyBkZWNvZGUgfSBmcm9tIFwibGlnaHQtYm9sdDExLWRlY29kZXJcIjtcbmZ1bmN0aW9uIHphcEludm9pY2VGcm9tRXZlbnQoZXZlbnQpIHtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJkZXNjcmlwdGlvblwiKVswXTtcbiAgY29uc3QgYm9sdDExID0gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwiYm9sdDExXCIpWzBdO1xuICBsZXQgZGVjb2RlZEludm9pY2U7XG4gIGxldCB6YXBSZXF1ZXN0O1xuICBpZiAoIWRlc2NyaXB0aW9uIHx8ICFib2x0MTEgfHwgIWJvbHQxMVsxXSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgbGV0IHphcFJlcXVlc3RQYXlsb2FkID0gZGVzY3JpcHRpb25bMV07XG4gICAgaWYgKHphcFJlcXVlc3RQYXlsb2FkLnN0YXJ0c1dpdGgoXCIlXCIpKSB7XG4gICAgICB6YXBSZXF1ZXN0UGF5bG9hZCA9IGRlY29kZVVSSUNvbXBvbmVudCh6YXBSZXF1ZXN0UGF5bG9hZCk7XG4gICAgfVxuICAgIGlmICh6YXBSZXF1ZXN0UGF5bG9hZCA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHphcFJlcXVlc3QgPSBKU09OLnBhcnNlKHphcFJlcXVlc3RQYXlsb2FkKTtcbiAgICBkZWNvZGVkSW52b2ljZSA9IGRlY29kZShib2x0MTFbMV0pO1xuICB9IGNhdGNoIChfZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGFtb3VudFNlY3Rpb24gPSBkZWNvZGVkSW52b2ljZS5zZWN0aW9ucy5maW5kKChzKSA9PiBzLm5hbWUgPT09IFwiYW1vdW50XCIpO1xuICBpZiAoIWFtb3VudFNlY3Rpb24pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBhbW91bnQgPSBOdW1iZXIucGFyc2VJbnQoYW1vdW50U2VjdGlvbi52YWx1ZSk7XG4gIGlmICghYW1vdW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY29udGVudCA9IHphcFJlcXVlc3QuY29udGVudDtcbiAgY29uc3Qgc2VuZGVyID0gemFwUmVxdWVzdC5wdWJrZXk7XG4gIGNvbnN0IHJlY2lwaWVudFRhZyA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcInBcIilbMF07XG4gIGNvbnN0IHJlY2lwaWVudCA9IHJlY2lwaWVudFRhZ1sxXTtcbiAgbGV0IHphcHBlZEV2ZW50ID0gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKVswXTtcbiAgaWYgKCF6YXBwZWRFdmVudCkge1xuICAgIHphcHBlZEV2ZW50ID0gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwiYVwiKVswXTtcbiAgfVxuICBjb25zdCB6YXBwZWRFdmVudElkID0gemFwcGVkRXZlbnQgPyB6YXBwZWRFdmVudFsxXSA6IHZvaWQgMDtcbiAgY29uc3QgemFwSW52b2ljZSA9IHtcbiAgICBpZDogZXZlbnQuaWQsXG4gICAgemFwcGVyOiBldmVudC5wdWJrZXksXG4gICAgemFwcGVlOiBzZW5kZXIsXG4gICAgemFwcGVkOiByZWNpcGllbnQsXG4gICAgemFwcGVkRXZlbnQ6IHphcHBlZEV2ZW50SWQsXG4gICAgYW1vdW50LFxuICAgIGNvbW1lbnQ6IGNvbnRlbnRcbiAgfTtcbiAgcmV0dXJuIHphcEludm9pY2U7XG59XG5cbi8vIHNyYy96YXBwZXIvaW5kZXgudHNcbmltcG9ydCBjcmVhdGVEZWJ1ZzUgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgYXMgRXZlbnRFbWl0dGVyOSB9IGZyb20gXCJ0c2VlcFwiO1xuXG4vLyBzcmMvemFwcGVyL2xuLnRzXG5pbXBvcnQgeyBiZWNoMzIgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbmltcG9ydCBjcmVhdGVEZWJ1ZzQgZnJvbSBcImRlYnVnXCI7XG52YXIgZDIgPSBjcmVhdGVEZWJ1ZzQoXCJuZGs6emFwcGVyOmxuXCIpO1xuYXN5bmMgZnVuY3Rpb24gZ2V0TmlwNTdaYXBTcGVjRnJvbUx1ZCh7IGx1ZDA2LCBsdWQxNiB9LCBuZGspIHtcbiAgbGV0IHphcEVuZHBvaW50O1xuICBpZiAobHVkMTYgJiYgIWx1ZDE2LnN0YXJ0c1dpdGgoXCJMTlVSTFwiKSkge1xuICAgIGNvbnN0IFtuYW1lLCBkb21haW5dID0gbHVkMTYuc3BsaXQoXCJAXCIpO1xuICAgIHphcEVuZHBvaW50ID0gYGh0dHBzOi8vJHtkb21haW59Ly53ZWxsLWtub3duL2xudXJscC8ke25hbWV9YDtcbiAgfSBlbHNlIGlmIChsdWQwNikge1xuICAgIGNvbnN0IHsgd29yZHMgfSA9IGJlY2gzMi5kZWNvZGUobHVkMDYsIDFlMyk7XG4gICAgY29uc3QgZGF0YSA9IGJlY2gzMi5mcm9tV29yZHMod29yZHMpO1xuICAgIGNvbnN0IHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG4gICAgemFwRW5kcG9pbnQgPSB1dGY4RGVjb2Rlci5kZWNvZGUoZGF0YSk7XG4gIH1cbiAgaWYgKCF6YXBFbmRwb2ludCkge1xuICAgIGQyKFwiTm8gemFwIGVuZHBvaW50IGZvdW5kICVvXCIsIHsgbHVkMDYsIGx1ZDE2IH0pO1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHphcCBlbmRwb2ludCBmb3VuZFwiKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IF9mZXRjaCA9IG5kay5odHRwRmV0Y2ggfHwgZmV0Y2g7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfZmV0Y2goemFwRW5kcG9pbnQpO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZldGNoIHphcCBlbmRwb2ludCAke3phcEVuZHBvaW50fTogJHt0ZXh0fWApO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmV0Y2ggemFwIGVuZHBvaW50ICR7emFwRW5kcG9pbnR9OiAke2V9YCk7XG4gIH1cbn1cblxuLy8gc3JjL3phcHBlci9uaXA1Ny50c1xuaW1wb3J0IHsgbmlwNTcgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlWmFwUmVxdWVzdCh0YXJnZXQsIG5kaywgZGF0YSwgcHVia2V5LCBhbW91bnQsIHJlbGF5cywgY29tbWVudCwgdGFncywgc2lnbmVyKSB7XG4gIGNvbnN0IHphcEVuZHBvaW50ID0gZGF0YS5jYWxsYmFjaztcbiAgY29uc3QgemFwUmVxdWVzdCA9IG5pcDU3Lm1ha2VaYXBSZXF1ZXN0KHtcbiAgICBwcm9maWxlOiBwdWJrZXksXG4gICAgLy8gc2V0IHRoZSBldmVudCB0byBudWxsIHNpbmNlIG5vc3RyLXRvb2xzIGRvZXNuJ3Qgc3VwcG9ydCBuaXAtMzMgemFwc1xuICAgIGV2ZW50OiBudWxsLFxuICAgIGFtb3VudCxcbiAgICBjb21tZW50OiBjb21tZW50IHx8IFwiXCIsXG4gICAgcmVsYXlzOiByZWxheXMuc2xpY2UoMCwgNClcbiAgfSk7XG4gIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBOREtFdmVudCkge1xuICAgIGNvbnN0IHRhZ3MyID0gdGFyZ2V0LnJlZmVyZW5jZVRhZ3MoKTtcbiAgICBjb25zdCBub25QVGFncyA9IHRhZ3MyLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwicFwiKTtcbiAgICB6YXBSZXF1ZXN0LnRhZ3MucHVzaCguLi5ub25QVGFncyk7XG4gIH1cbiAgemFwUmVxdWVzdC50YWdzLnB1c2goW1wibG51cmxcIiwgemFwRW5kcG9pbnRdKTtcbiAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB6YXBSZXF1ZXN0KTtcbiAgaWYgKHRhZ3MpIHtcbiAgICBldmVudC50YWdzID0gZXZlbnQudGFncy5jb25jYXQodGFncyk7XG4gIH1cbiAgY29uc3QgZVRhZ2dlZEV2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGFUYWdnZWRFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHRhZyBvZiBldmVudC50YWdzKSB7XG4gICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIpIHtcbiAgICAgIGVUYWdnZWRFdmVudHMuYWRkKHRhZ1sxXSk7XG4gICAgfSBlbHNlIGlmICh0YWdbMF0gPT09IFwiYVwiKSB7XG4gICAgICBhVGFnZ2VkRXZlbnRzLmFkZCh0YWdbMV0pO1xuICAgIH1cbiAgfVxuICBpZiAoZVRhZ2dlZEV2ZW50cy5zaXplID4gMSkgdGhyb3cgbmV3IEVycm9yKFwiT25seSBvbmUgZS10YWcgaXMgYWxsb3dlZFwiKTtcbiAgaWYgKGFUYWdnZWRFdmVudHMuc2l6ZSA+IDEpIHRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGEtdGFnIGlzIGFsbG93ZWRcIik7XG4gIGV2ZW50LnRhZ3MgPSBldmVudC50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwicFwiKTtcbiAgZXZlbnQudGFncy5wdXNoKFtcInBcIiwgcHVia2V5XSk7XG4gIGF3YWl0IGV2ZW50LnNpZ24oc2lnbmVyKTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vLyBzcmMvemFwcGVyL2luZGV4LnRzXG52YXIgZDMgPSBjcmVhdGVEZWJ1ZzUoXCJuZGs6emFwcGVyXCIpO1xudmFyIE5ES1phcHBlciA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyOSB7XG4gIHRhcmdldDtcbiAgbmRrO1xuICBjb21tZW50O1xuICBhbW91bnQ7XG4gIHVuaXQ7XG4gIHRhZ3M7XG4gIHNpZ25lcjtcbiAgemFwTWV0aG9kO1xuICBudXR6YXBBc0ZhbGxiYWNrO1xuICBsblBheTtcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgY2FzaHUgcGF5bWVudCBpcyB0byBiZSBtYWRlLlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBzd2FwL21pbnQgcHJvb2ZzIGZvciB0aGUgcmVxdWlyZWQgYW1vdW50LCBpbiB0aGUgcmVxdWlyZWQgdW5pdCxcbiAgICogaW4gYW55IG9mIHRoZSBwcm92aWRlZCBtaW50cyBhbmQgcmV0dXJuIHRoZSBwcm9vZnMgYW5kIG1pbnQgdXNlZC5cbiAgICovXG4gIGNhc2h1UGF5O1xuICBvbkNvbXBsZXRlO1xuICBtYXhSZWxheXMgPSAzO1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9mIHRoZSB6YXBcbiAgICogQHBhcmFtIGFtb3VudCBUaGUgYW1vdW50IHRvIHNlbmQgaW5kaWNhdGVkIGluIHRoZSB1bml0XG4gICAqIEBwYXJhbSB1bml0IFRoZSB1bml0IG9mIHRoZSBhbW91bnRcbiAgICogQHBhcmFtIG9wdHMgT3B0aW9ucyBmb3IgdGhlIHphcFxuICAgKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0LCBhbW91bnQsIHVuaXQgPSBcIm1zYXRcIiwgb3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLm5kayA9IG9wdHMubmRrIHx8IHRhcmdldC5uZGs7XG4gICAgaWYgKCF0aGlzLm5kaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIHByb3ZpZGVkXCIpO1xuICAgIH1cbiAgICB0aGlzLmFtb3VudCA9IGFtb3VudDtcbiAgICB0aGlzLmNvbW1lbnQgPSBvcHRzLmNvbW1lbnQ7XG4gICAgdGhpcy51bml0ID0gdW5pdDtcbiAgICB0aGlzLnRhZ3MgPSBvcHRzLnRhZ3M7XG4gICAgdGhpcy5zaWduZXIgPSBvcHRzLnNpZ25lcjtcbiAgICB0aGlzLm51dHphcEFzRmFsbGJhY2sgPSBvcHRzLm51dHphcEFzRmFsbGJhY2sgPz8gZmFsc2U7XG4gICAgdGhpcy5sblBheSA9IG9wdHMubG5QYXkgfHwgdGhpcy5uZGsud2FsbGV0Q29uZmlnPy5sblBheTtcbiAgICB0aGlzLmNhc2h1UGF5ID0gb3B0cy5jYXNodVBheSB8fCB0aGlzLm5kay53YWxsZXRDb25maWc/LmNhc2h1UGF5O1xuICAgIHRoaXMub25Db21wbGV0ZSA9IG9wdHMub25Db21wbGV0ZSB8fCB0aGlzLm5kay53YWxsZXRDb25maWc/Lm9uUGF5bWVudENvbXBsZXRlO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWF0ZSB6YXBwaW5nIHByb2Nlc3NcbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGNhbGN1bGF0ZSB0aGUgc3BsaXRzIGZvciB0aGlzIHphcCBhbmQgaW5pdGlhdGUgZWFjaCB6YXAgc3BsaXQuXG4gICAqL1xuICBhc3luYyB6YXAobWV0aG9kcykge1xuICAgIGNvbnN0IHNwbGl0cyA9IHRoaXMuZ2V0WmFwU3BsaXRzKCk7XG4gICAgY29uc3QgcmVzdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBzcGxpdHMubWFwKGFzeW5jIChzcGxpdCkgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuemFwU3BsaXQoc3BsaXQsIG1ldGhvZHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IEVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwic3BsaXQ6Y29tcGxldGVcIiwgc3BsaXQsIHJlc3VsdCk7XG4gICAgICAgIHJlc3VsdHMuc2V0KHNwbGl0LCByZXN1bHQpO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuZW1pdChcImNvbXBsZXRlXCIsIHJlc3VsdHMpO1xuICAgIGlmICh0aGlzLm9uQ29tcGxldGUpIHRoaXMub25Db21wbGV0ZShyZXN1bHRzKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBhc3luYyB6YXBOaXA1NyhzcGxpdCwgZGF0YSkge1xuICAgIGlmICghdGhpcy5sblBheSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gbG5QYXkgZnVuY3Rpb24gYXZhaWxhYmxlXCIpO1xuICAgIGNvbnN0IHphcFNwZWMgPSBhd2FpdCBnZXROaXA1N1phcFNwZWNGcm9tTHVkKGRhdGEsIHRoaXMubmRrKTtcbiAgICBpZiAoIXphcFNwZWMpIHRocm93IG5ldyBFcnJvcihcIk5vIHphcCBzcGVjIGF2YWlsYWJsZSBmb3IgcmVjaXBpZW50XCIpO1xuICAgIGNvbnN0IHJlbGF5cyA9IGF3YWl0IHRoaXMucmVsYXlzKHNwbGl0LnB1YmtleSk7XG4gICAgY29uc3QgemFwUmVxdWVzdCA9IGF3YWl0IGdlbmVyYXRlWmFwUmVxdWVzdChcbiAgICAgIHRoaXMudGFyZ2V0LFxuICAgICAgdGhpcy5uZGssXG4gICAgICB6YXBTcGVjLFxuICAgICAgc3BsaXQucHVia2V5LFxuICAgICAgc3BsaXQuYW1vdW50LFxuICAgICAgcmVsYXlzLFxuICAgICAgdGhpcy5jb21tZW50LFxuICAgICAgdGhpcy50YWdzLFxuICAgICAgdGhpcy5zaWduZXJcbiAgICApO1xuICAgIGlmICghemFwUmVxdWVzdCkge1xuICAgICAgZDMoXCJVbmFibGUgdG8gZ2VuZXJhdGUgemFwIHJlcXVlc3RcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZ2VuZXJhdGUgemFwIHJlcXVlc3RcIik7XG4gICAgfVxuICAgIGNvbnN0IHByID0gYXdhaXQgdGhpcy5nZXRMbkludm9pY2UoemFwUmVxdWVzdCwgc3BsaXQuYW1vdW50LCB6YXBTcGVjKTtcbiAgICBpZiAoIXByKSB7XG4gICAgICBkMyhcIlVuYWJsZSB0byBnZXQgcGF5bWVudCByZXF1ZXN0XCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGdldCBwYXltZW50IHJlcXVlc3RcIik7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcImxuX2ludm9pY2VcIiwge1xuICAgICAgYW1vdW50OiBzcGxpdC5hbW91bnQsXG4gICAgICByZWNpcGllbnRQdWJrZXk6IHNwbGl0LnB1YmtleSxcbiAgICAgIHVuaXQ6IHRoaXMudW5pdCxcbiAgICAgIG5pcDU3WmFwUmVxdWVzdDogemFwUmVxdWVzdCxcbiAgICAgIHByLFxuICAgICAgdHlwZTogXCJuaXA1N1wiXG4gICAgfSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5sblBheSh7XG4gICAgICB0YXJnZXQ6IHRoaXMudGFyZ2V0LFxuICAgICAgcmVjaXBpZW50UHVia2V5OiBzcGxpdC5wdWJrZXksXG4gICAgICBwYXltZW50RGVzY3JpcHRpb246IFwiTklQLTU3IFphcFwiLFxuICAgICAgcHIsXG4gICAgICBhbW91bnQ6IHNwbGl0LmFtb3VudCxcbiAgICAgIHVuaXQ6IHRoaXMudW5pdCxcbiAgICAgIG5pcDU3WmFwUmVxdWVzdDogemFwUmVxdWVzdFxuICAgIH0pO1xuICAgIGlmIChyZXM/LnByZWltYWdlKSB7XG4gICAgICB0aGlzLmVtaXQoXCJsbl9wYXltZW50XCIsIHtcbiAgICAgICAgcHJlaW1hZ2U6IHJlcy5wcmVpbWFnZSxcbiAgICAgICAgYW1vdW50OiBzcGxpdC5hbW91bnQsXG4gICAgICAgIHJlY2lwaWVudFB1YmtleTogc3BsaXQucHVia2V5LFxuICAgICAgICBwcixcbiAgICAgICAgdW5pdDogdGhpcy51bml0LFxuICAgICAgICBuaXA1N1phcFJlcXVlc3Q6IHphcFJlcXVlc3QsXG4gICAgICAgIHR5cGU6IFwibmlwNTdcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoZXMgaW5mb3JtYXRpb24gYWJvdXQgYSBOSVAtNjEgemFwIGFuZCBhc2tzIHRoZSBjYWxsZXIgdG8gY3JlYXRlIGNhc2h1IHByb29mcyBmb3IgdGhlIHphcC5cbiAgICpcbiAgICogKG5vdGUgdGhhdCB0aGUgY2FzaHVQYXkgZnVuY3Rpb24gY2FuIHVzZSBhbnkgbWV0aG9kIHRvIGNyZWF0ZSB0aGUgcHJvb2ZzLCBpbmNsdWRpbmcgdXNpbmcgbGlnaHRuaW5nXG4gICAqIHRvIG1pbnQgcHJvb2ZzIGluIHRoZSBzcGVjaWZpZWQgbWludCwgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIG1pbnRpbmcgdGhlIHByb29mcyBpcyBkZWxlZ2F0ZWQgdG8gdGhlIGNhbGxlciAoZS5nLiBuZGstd2FsbGV0KSlcbiAgICovXG4gIGFzeW5jIHphcE5pcDYxKHNwbGl0LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNhc2h1UGF5KSB0aHJvdyBuZXcgRXJyb3IoXCJObyBjYXNodVBheSBmdW5jdGlvbiBhdmFpbGFibGVcIik7XG4gICAgbGV0IHJldDtcbiAgICByZXQgPSBhd2FpdCB0aGlzLmNhc2h1UGF5KFxuICAgICAge1xuICAgICAgICB0YXJnZXQ6IHRoaXMudGFyZ2V0LFxuICAgICAgICByZWNpcGllbnRQdWJrZXk6IHNwbGl0LnB1YmtleSxcbiAgICAgICAgcGF5bWVudERlc2NyaXB0aW9uOiBcIk5JUC02MSBaYXBcIixcbiAgICAgICAgYW1vdW50OiBzcGxpdC5hbW91bnQsXG4gICAgICAgIHVuaXQ6IHRoaXMudW5pdCxcbiAgICAgICAgLi4uZGF0YSA/PyB7fVxuICAgICAgfSxcbiAgICAgIChwcikgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoXCJsbl9pbnZvaWNlXCIsIHtcbiAgICAgICAgICBwcixcbiAgICAgICAgICBhbW91bnQ6IHNwbGl0LmFtb3VudCxcbiAgICAgICAgICByZWNpcGllbnRQdWJrZXk6IHNwbGl0LnB1YmtleSxcbiAgICAgICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICAgICAgdHlwZTogXCJuaXA2MVwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gICAgZDMoXCJOSVAtNjEgWmFwIHJlc3VsdDogJW9cIiwgcmV0KTtcbiAgICBpZiAocmV0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGlmIChyZXQpIHtcbiAgICAgIGNvbnN0IHsgcHJvb2ZzLCBtaW50IH0gPSByZXQ7XG4gICAgICBpZiAoIXByb29mcyB8fCAhbWludCkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHphcCBjb25maXJtYXRpb246IG1pc3NpbmcgcHJvb2ZzIG9yIG1pbnQ6ICR7cmV0fWApO1xuICAgICAgY29uc3QgcmVsYXlzID0gYXdhaXQgdGhpcy5yZWxheXMoc3BsaXQucHVia2V5KTtcbiAgICAgIGNvbnN0IHJlbGF5U2V0ID0gTkRLUmVsYXlTZXQuZnJvbVJlbGF5VXJscyhyZWxheXMsIHRoaXMubmRrKTtcbiAgICAgIGNvbnN0IG51dHphcCA9IG5ldyBOREtOdXR6YXAodGhpcy5uZGspO1xuICAgICAgbnV0emFwLnRhZ3MgPSBbLi4ubnV0emFwLnRhZ3MsIC4uLnRoaXMudGFncyB8fCBbXV07XG4gICAgICBudXR6YXAucHJvb2ZzID0gcHJvb2ZzO1xuICAgICAgbnV0emFwLm1pbnQgPSBtaW50O1xuICAgICAgbnV0emFwLnRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgbnV0emFwLmNvbW1lbnQgPSB0aGlzLmNvbW1lbnQ7XG4gICAgICBudXR6YXAudW5pdCA9IFwic2F0XCI7XG4gICAgICBudXR6YXAucmVjaXBpZW50UHVia2V5ID0gc3BsaXQucHVia2V5O1xuICAgICAgYXdhaXQgbnV0emFwLnNpZ24odGhpcy5zaWduZXIpO1xuICAgICAgbnV0emFwLnB1Ymxpc2gocmVsYXlTZXQpO1xuICAgICAgcmV0dXJuIG51dHphcDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgemFwIG1ldGhvZHMgYXZhaWxhYmxlIGZvciB0aGUgcmVjaXBpZW50IGFuZCBpbml0aWF0ZXMgdGhlIHphcFxuICAgKiBpbiB0aGUgZGVzaXJlZCBtZXRob2QuXG4gICAqIEBwYXJhbSBzcGxpdFxuICAgKiBAcGFyYW0gbWV0aG9kcyAtIFRoZSBtZXRob2RzIHRvIHRyeSwgaWYgbm90IHByb3ZpZGVkLCBhbGwgbWV0aG9kcyB3aWxsIGJlIHRyaWVkLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgemFwU3BsaXQoc3BsaXQsIG1ldGhvZHMpIHtcbiAgICBjb25zdCByZWNpcGllbnQgPSB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5OiBzcGxpdC5wdWJrZXkgfSk7XG4gICAgY29uc3QgemFwTWV0aG9kcyA9IGF3YWl0IHJlY2lwaWVudC5nZXRaYXBJbmZvKDI1MDApO1xuICAgIGxldCByZXRWYWw7XG4gICAgY29uc3QgY2FuRmFsbGJhY2tUb05pcDYxID0gdGhpcy5udXR6YXBBc0ZhbGxiYWNrICYmIHRoaXMuY2FzaHVQYXk7XG4gICAgaWYgKHphcE1ldGhvZHMuc2l6ZSA9PT0gMCAmJiAhY2FuRmFsbGJhY2tUb05pcDYxKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gemFwIG1ldGhvZCBhdmFpbGFibGUgZm9yIHJlY2lwaWVudCBhbmQgTklQLTYxIGZhbGxiYWNrIGlzIGRpc2FibGVkXCIpO1xuICAgIGNvbnN0IG5pcDYxRmFsbGJhY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMubnV0emFwQXNGYWxsYmFjaykgcmV0dXJuO1xuICAgICAgY29uc3QgcmVsYXlMaXN0cyA9IGF3YWl0IGdldFJlbGF5TGlzdEZvclVzZXJzKFtzcGxpdC5wdWJrZXldLCB0aGlzLm5kayk7XG4gICAgICBsZXQgcmVsYXlVcmxzID0gcmVsYXlMaXN0cy5nZXQoc3BsaXQucHVia2V5KT8ucmVhZFJlbGF5VXJscztcbiAgICAgIHJlbGF5VXJscyA9IHRoaXMubmRrLnBvb2wuY29ubmVjdGVkUmVsYXlzKCkubWFwKChyKSA9PiByLnVybCk7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy56YXBOaXA2MShzcGxpdCwge1xuICAgICAgICAvLyB1c2UgdGhlIHVzZXIncyByZWxheSBsaXN0XG4gICAgICAgIHJlbGF5czogcmVsYXlVcmxzLFxuICAgICAgICAvLyBsb2NrIHRvIHRoZSB1c2VyJ3MgYWN0dWFsIHB1YmtleVxuICAgICAgICBwMnBrOiBzcGxpdC5wdWJrZXksXG4gICAgICAgIC8vIGFsbG93IGludHJhbWludCBmYWxsYmFja1xuICAgICAgICBhbGxvd0ludHJhbWludEZhbGxiYWNrOiAhIWNhbkZhbGxiYWNrVG9OaXA2MVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBjYW5Vc2VOaXA2MSA9ICFtZXRob2RzIHx8IG1ldGhvZHMuaW5jbHVkZXMoXCJuaXA2MVwiKTtcbiAgICBjb25zdCBjYW5Vc2VOaXA1NyA9ICFtZXRob2RzIHx8IG1ldGhvZHMuaW5jbHVkZXMoXCJuaXA1N1wiKTtcbiAgICBjb25zdCBuaXA2MU1ldGhvZCA9IHphcE1ldGhvZHMuZ2V0KFwibmlwNjFcIik7XG4gICAgaWYgKG5pcDYxTWV0aG9kICYmIGNhblVzZU5pcDYxKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXRWYWwgPSBhd2FpdCB0aGlzLnphcE5pcDYxKHNwbGl0LCBuaXA2MU1ldGhvZCk7XG4gICAgICAgIGlmIChyZXRWYWwgaW5zdGFuY2VvZiBOREtOdXR6YXApIHJldHVybiByZXRWYWw7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuZW1pdChcIm5vdGljZVwiLCBgTklQLTYxIGF0dGVtcHQgZmFpbGVkOiAke2UubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmlwNTdNZXRob2QgPSB6YXBNZXRob2RzLmdldChcIm5pcDU3XCIpO1xuICAgIGlmIChuaXA1N01ldGhvZCAmJiBjYW5Vc2VOaXA1Nykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0VmFsID0gYXdhaXQgdGhpcy56YXBOaXA1NyhzcGxpdCwgbmlwNTdNZXRob2QpO1xuICAgICAgICBpZiAoIShyZXRWYWwgaW5zdGFuY2VvZiBFcnJvcikpIHJldHVybiByZXRWYWw7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuZW1pdChcIm5vdGljZVwiLCBgTklQLTU3IGF0dGVtcHQgZmFpbGVkOiAke2UubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNhbkZhbGxiYWNrVG9OaXA2MSkge1xuICAgICAgcmV0VmFsID0gYXdhaXQgbmlwNjFGYWxsYmFjaygpO1xuICAgICAgaWYgKHJldFZhbCBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyByZXRWYWw7XG4gICAgICByZXR1cm4gcmV0VmFsO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJub3RpY2VcIiwgXCJaYXAgbWV0aG9kcyBleGhhdXN0ZWQgYW5kIHRoZXJlIHdhcyBubyBmYWxsYmFjayB0byBOSVAtNjFcIik7XG4gICAgaWYgKHJldFZhbCBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyByZXRWYWw7XG4gICAgcmV0dXJuIHJldFZhbDtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIGJvbHQxMSBmb3IgYSBuaXA1NyB6YXBcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEBwYXJhbSBhbW91bnRcbiAgICogQHBhcmFtIHphcEVuZHBvaW50XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBnZXRMbkludm9pY2UoemFwUmVxdWVzdCwgYW1vdW50LCBkYXRhKSB7XG4gICAgY29uc3QgemFwRW5kcG9pbnQgPSBkYXRhLmNhbGxiYWNrO1xuICAgIGNvbnN0IGV2ZW50UGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHphcFJlcXVlc3QucmF3RXZlbnQoKSk7XG4gICAgZDMoXG4gICAgICBgRmV0Y2hpbmcgaW52b2ljZSBmcm9tICR7emFwRW5kcG9pbnR9PyR7bmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFtb3VudDogYW1vdW50LnRvU3RyaW5nKCksXG4gICAgICAgIG5vc3RyOiBldmVudFBheWxvYWRcbiAgICAgIH0pfWBcbiAgICApO1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoemFwRW5kcG9pbnQpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiYW1vdW50XCIsIGFtb3VudC50b1N0cmluZygpKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcIm5vc3RyXCIsIGV2ZW50UGF5bG9hZCk7XG4gICAgZDMoYEZldGNoaW5nIGludm9pY2UgZnJvbSAke3VybC50b1N0cmluZygpfWApO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLnRvU3RyaW5nKCkpO1xuICAgIGQzKGBHb3QgcmVzcG9uc2UgZnJvbSB6YXAgZW5kcG9pbnQ6ICR7emFwRW5kcG9pbnR9YCwgeyBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyB9KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIGQzKGBSZWNlaXZlZCBub24tMjAwIHN0YXR1cyBmcm9tIHphcCBlbmRwb2ludDogJHt6YXBFbmRwb2ludH1gLCB7XG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBhbW91bnQsXG4gICAgICAgIG5vc3RyOiBldmVudFBheWxvYWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZldGNoIHphcCBlbmRwb2ludCAke3phcEVuZHBvaW50fTogJHt0ZXh0fWApO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiBib2R5LnByO1xuICB9XG4gIGdldFphcFNwbGl0cygpIHtcbiAgICBpZiAodGhpcy50YXJnZXQgaW5zdGFuY2VvZiBOREtVc2VyKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgcHVia2V5OiB0aGlzLnRhcmdldC5wdWJrZXksXG4gICAgICAgICAgYW1vdW50OiB0aGlzLmFtb3VudFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICBjb25zdCB6YXBUYWdzID0gdGhpcy50YXJnZXQuZ2V0TWF0Y2hpbmdUYWdzKFwiemFwXCIpO1xuICAgIGlmICh6YXBUYWdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHB1YmtleTogdGhpcy50YXJnZXQucHVia2V5LFxuICAgICAgICAgIGFtb3VudDogdGhpcy5hbW91bnRcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgY29uc3Qgc3BsaXRzID0gW107XG4gICAgY29uc3QgdG90YWwgPSB6YXBUYWdzLnJlZHVjZSgoYWNjLCB0YWcpID0+IGFjYyArIE51bWJlci5wYXJzZUludCh0YWdbMl0pLCAwKTtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiB6YXBUYWdzKSB7XG4gICAgICBjb25zdCBwdWJrZXkgPSB0YWdbMV07XG4gICAgICBjb25zdCBhbW91bnQgPSBNYXRoLmZsb29yKE51bWJlci5wYXJzZUludCh0YWdbMl0pIC8gdG90YWwgKiB0aGlzLmFtb3VudCk7XG4gICAgICBzcGxpdHMucHVzaCh7IHB1YmtleSwgYW1vdW50IH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3BsaXRzO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSB6YXAgbWV0aG9kIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gemFwIGEgcHViYmtleVxuICAgKiBAcGFyYW0gbmRrXG4gICAqIEBwYXJhbSBwdWJrZXlcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGdldFphcE1ldGhvZHMobmRrLCByZWNpcGllbnQsIHRpbWVvdXQgPSAyNTAwKSB7XG4gICAgY29uc3QgdXNlciA9IG5kay5nZXRVc2VyKHsgcHVia2V5OiByZWNpcGllbnQgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHVzZXIuZ2V0WmFwSW5mbyh0aW1lb3V0KTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgdGhlIHJlbGF5cyB0byB1c2UgZm9yIHRoZSB6YXAgcmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgcmVsYXlzKHB1YmtleSkge1xuICAgIGxldCByID0gW107XG4gICAgaWYgKHRoaXMubmRrPy5hY3RpdmVVc2VyKSB7XG4gICAgICBjb25zdCByZWxheUxpc3RzID0gYXdhaXQgZ2V0UmVsYXlMaXN0Rm9yVXNlcnMoW3RoaXMubmRrLmFjdGl2ZVVzZXIucHVia2V5LCBwdWJrZXldLCB0aGlzLm5kayk7XG4gICAgICBjb25zdCByZWxheVNjb3JlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGNvbnN0IHJlbGF5TGlzdCBvZiByZWxheUxpc3RzLnZhbHVlcygpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdXJsIG9mIHJlbGF5TGlzdC5yZWFkUmVsYXlVcmxzKSB7XG4gICAgICAgICAgY29uc3Qgc2NvcmUgPSByZWxheVNjb3Jlcy5nZXQodXJsKSB8fCAwO1xuICAgICAgICAgIHJlbGF5U2NvcmVzLnNldCh1cmwsIHNjb3JlICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHIgPSBBcnJheS5mcm9tKHJlbGF5U2NvcmVzLmVudHJpZXMoKSkuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pLm1hcCgoW3VybF0pID0+IHVybCkuc2xpY2UoMCwgdGhpcy5tYXhSZWxheXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZGs/LnBvb2w/LnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLmxlbmd0aCkge1xuICAgICAgciA9IHRoaXMubmRrLnBvb2wucGVybWFuZW50QW5kQ29ubmVjdGVkUmVsYXlzKCkubWFwKChyZWxheSkgPT4gcmVsYXkudXJsKTtcbiAgICB9XG4gICAgaWYgKCFyLmxlbmd0aCkge1xuICAgICAgciA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2ZpbHRlci50c1xuZnVuY3Rpb24gbWF0Y2hGaWx0ZXIoZmlsdGVyLCBldmVudCkge1xuICBpZiAoZmlsdGVyLmlkcyAmJiBmaWx0ZXIuaWRzLmluZGV4T2YoZXZlbnQuaWQpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZmlsdGVyLmtpbmRzICYmIGZpbHRlci5raW5kcy5pbmRleE9mKGV2ZW50LmtpbmQpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZmlsdGVyLmF1dGhvcnMgJiYgZmlsdGVyLmF1dGhvcnMuaW5kZXhPZihldmVudC5wdWJrZXkpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IGYgaW4gZmlsdGVyKSB7XG4gICAgaWYgKGZbMF0gPT09IFwiI1wiKSB7XG4gICAgICBjb25zdCB0YWdOYW1lID0gZi5zbGljZSgxKTtcbiAgICAgIGlmICh0YWdOYW1lID09PSBcInRcIikge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBmaWx0ZXJbYCMke3RhZ05hbWV9YF0/Lm1hcCgodikgPT4gdi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKHZhbHVlcyAmJiAhZXZlbnQudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IHRhZ05hbWUgJiYgdmFsdWVzPy5pbmRleE9mKHYudG9Mb3dlckNhc2UoKSkgIT09IC0xKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBmaWx0ZXJbYCMke3RhZ05hbWV9YF07XG4gICAgICAgIGlmICh2YWx1ZXMgJiYgIWV2ZW50LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSB0YWdOYW1lICYmIHZhbHVlcz8uaW5kZXhPZih2KSAhPT0gLTEpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChmaWx0ZXIuc2luY2UgJiYgZXZlbnQuY3JlYXRlZF9hdCA8IGZpbHRlci5zaW5jZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZmlsdGVyLnVudGlsICYmIGV2ZW50LmNyZWF0ZWRfYXQgPiBmaWx0ZXIudW50aWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQge1xuICBCRUNIMzJfUkVHRVgsXG4gIE5ES0FwcEhhbmRsZXJFdmVudCxcbiAgTkRLQXBwU2V0dGluZ3MsXG4gIE5ES0FydGljbGUsXG4gIE5ES0Nhc2h1TWludExpc3QsXG4gIE5ES0Nhc2h1VG9rZW4sXG4gIE5ES0Nhc2h1V2FsbGV0VHgsXG4gIE5ES0NsYXNzaWZpZWQsXG4gIE5ES0RWTUpvYkZlZWRiYWNrLFxuICBOREtEVk1Kb2JSZXN1bHQsXG4gIE5ES0RWTVJlcXVlc3QsXG4gIE5ES0RyYWZ0LFxuICBOREtEdm1Kb2JGZWVkYmFja1N0YXR1cyxcbiAgTkRLRXZlbnQsXG4gIE5ES0hpZ2hsaWdodCxcbiAgTkRLSW1hZ2UsXG4gIE5ES0tpbmQsXG4gIE5ES0xpc3QsXG4gIE5ES0xpc3RLaW5kcyxcbiAgTkRLTmlwMDdTaWduZXIsXG4gIE5ES05pcDQ2QmFja2VuZCxcbiAgTkRLTmlwNDZTaWduZXIsXG4gIE5ES05vc3RyUnBjLFxuICBOREtOdXR6YXAsXG4gIE5ES1Bvb2wsXG4gIE5ES1ByaXZhdGVLZXlTaWduZXIsXG4gIE5ES1B1Ymxpc2hFcnJvcixcbiAgTkRLUmVsYXksXG4gIE5ES1JlbGF5QXV0aFBvbGljaWVzLFxuICBOREtSZWxheUxpc3QsXG4gIE5ES1JlbGF5U2V0LFxuICBOREtSZWxheVN0YXR1cyxcbiAgTkRLUmVwb3N0LFxuICBOREtTaW1wbGVHcm91cCxcbiAgTkRLU2ltcGxlR3JvdXBNZW1iZXJMaXN0LFxuICBOREtTaW1wbGVHcm91cE1ldGFkYXRhLFxuICBOREtTdG9yeSxcbiAgTkRLU3RvcnlTdGlja2VyLFxuICBOREtTdG9yeVN0aWNrZXJUeXBlLFxuICBOREtTdWJzY3JpcHRpb24sXG4gIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UsXG4gIE5ES1N1YnNjcmlwdGlvblJlY2VpcHQsXG4gIE5ES1N1YnNjcmlwdGlvblN0YXJ0LFxuICBOREtTdWJzY3JpcHRpb25UaWVyLFxuICBOREtUcmFuc2NyaXB0aW9uRFZNLFxuICBOREtVc2VyLFxuICBOREtWaWRlbyxcbiAgTkRLV2lraSxcbiAgTkRLV2lraU1lcmdlUmVxdWVzdCxcbiAgTkRLWmFwcGVyLFxuICBOSVAzM19BX1JFR0VYLFxuICBOZGtOdXR6YXBTdGF0dXMsXG4gIGNhbGN1bGF0ZVJlbGF5U2V0RnJvbUV2ZW50LFxuICBjYWxjdWxhdGVUZXJtRHVyYXRpb25JblNlY29uZHMsXG4gIGNhc2h1UHVia2V5VG9Ob3N0clB1YmtleSxcbiAgY29tcGFyZUZpbHRlcixcbiAgTkRLIGFzIGRlZmF1bHQsXG4gIGRlZmF1bHRPcHRzLFxuICBkZXNlcmlhbGl6ZSxcbiAgZHZtU2NoZWR1bGUsXG4gIGV2ZW50SGFzRVRhZ01hcmtlcnMsXG4gIGV2ZW50SXNQYXJ0T2ZUaHJlYWQsXG4gIGV2ZW50SXNSZXBseSxcbiAgZXZlbnRSZXBsaWVzLFxuICBldmVudFRocmVhZElkcyxcbiAgZXZlbnRUaHJlYWRzLFxuICBldmVudHNCeVNhbWVBdXRob3IsXG4gIGZpbHRlckFuZFJlbGF5U2V0RnJvbUJlY2gzMixcbiAgZmlsdGVyRmluZ2VycHJpbnQsXG4gIGZpbHRlckZvckV2ZW50c1RhZ2dpbmdJZCxcbiAgZmlsdGVyRnJvbUlkLFxuICBnZW5lcmF0ZUNvbnRlbnRUYWdzLFxuICBnZW5lcmF0ZUhhc2h0YWdzLFxuICBnZW5lcmF0ZVN1YklkLFxuICBnZW5lcmF0ZVphcFJlcXVlc3QsXG4gIGdldEV2ZW50UmVwbHlJZCxcbiAgZ2V0TmlwNTdaYXBTcGVjRnJvbUx1ZCxcbiAgZ2V0UmVsYXlMaXN0Rm9yVXNlcixcbiAgZ2V0UmVsYXlMaXN0Rm9yVXNlcnMsXG4gIGdldFJlcGx5VGFnLFxuICBnZXRSb290RXZlbnRJZCxcbiAgZ2V0Um9vdFRhZyxcbiAgZ2lmdFVud3JhcCxcbiAgZ2lmdFdyYXAsXG4gIGltZXRhVGFnVG9UYWcsXG4gIGlzRXZlbnRPcmlnaW5hbFBvc3QsXG4gIGlzTmlwMzNBVmFsdWUsXG4gIG1hcEltZXRhVGFnLFxuICBtYXRjaEZpbHRlcixcbiAgbWVyZ2VGaWx0ZXJzLFxuICBtZXJnZVRhZ3MsXG4gIG5ka1NpZ25lckZyb21QYXlsb2FkLFxuICBuZXdBbW91bnQsXG4gIG5vcm1hbGl6ZSxcbiAgbm9ybWFsaXplUmVsYXlVcmwsXG4gIG5vcm1hbGl6ZVVybCxcbiAgcGFyc2VUYWdUb1N1YnNjcmlwdGlvbkFtb3VudCxcbiAgcGluRXZlbnQsXG4gIHBvc3NpYmxlSW50ZXJ2YWxGcmVxdWVuY2llcyxcbiAgcHJvZmlsZUZyb21FdmVudCxcbiAgcHJvb2ZQMnBrLFxuICBwcm9vZlAycGtOb3N0cixcbiAgcHJvb2ZzVG90YWxCYWxhbmNlLFxuICBxdWVyeUZ1bGx5RmlsbGVkLFxuICByZWxheUxpc3RGcm9tS2luZDMsXG4gIHJlbGF5c0Zyb21CZWNoMzIsXG4gIHNlcmlhbGl6ZSxcbiAgc2VyaWFsaXplUHJvZmlsZSxcbiAgc2lnbmVyUmVnaXN0cnksXG4gIHN0clRvRGltZW5zaW9uLFxuICBzdHJUb1Bvc2l0aW9uLFxuICB0cnlOb3JtYWxpemVSZWxheVVybCxcbiAgdW5pcXVlVGFnLFxuICB3cmFwRXZlbnQsXG4gIHphcEludm9pY2VGcm9tRXZlbnRcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-wallet/node_modules/@nostr-dev-kit/ndk/dist/index.mjs\n");

/***/ })

};
;