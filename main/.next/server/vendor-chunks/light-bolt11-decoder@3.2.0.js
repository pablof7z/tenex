/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/light-bolt11-decoder@3.2.0";
exports.ids = ["vendor-chunks/light-bolt11-decoder@3.2.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/light-bolt11-decoder@3.2.0/node_modules/light-bolt11-decoder/bolt11.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/light-bolt11-decoder@3.2.0/node_modules/light-bolt11-decoder/bolt11.js ***!
  \***************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {bech32, hex, utf8} = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/.pnpm/@scure+base@1.1.1/node_modules/@scure/base/lib/index.js\")\n\n// defaults for encode; default timestamp is current time at call\nconst DEFAULTNETWORK = {\n  // default network is bitcoin\n  bech32: 'bc',\n  pubKeyHash: 0x00,\n  scriptHash: 0x05,\n  validWitnessVersions: [0]\n}\nconst TESTNETWORK = {\n  bech32: 'tb',\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  validWitnessVersions: [0]\n}\nconst SIGNETNETWORK = {\n  bech32: 'tbs',\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  validWitnessVersions: [0]\n}\nconst REGTESTNETWORK = {\n  bech32: 'bcrt',\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  validWitnessVersions: [0]\n}\nconst SIMNETWORK = {\n  bech32: 'sb',\n  pubKeyHash: 0x3f,\n  scriptHash: 0x7b,\n  validWitnessVersions: [0]\n}\n\nconst FEATUREBIT_ORDER = [\n  'option_data_loss_protect',\n  'initial_routing_sync',\n  'option_upfront_shutdown_script',\n  'gossip_queries',\n  'var_onion_optin',\n  'gossip_queries_ex',\n  'option_static_remotekey',\n  'payment_secret',\n  'basic_mpp',\n  'option_support_large_channel'\n]\n\nconst DIVISORS = {\n  m: BigInt(1e3),\n  u: BigInt(1e6),\n  n: BigInt(1e9),\n  p: BigInt(1e12)\n}\n\nconst MAX_MILLISATS = BigInt('2100000000000000000')\n\nconst MILLISATS_PER_BTC = BigInt(1e11)\n\nconst TAGCODES = {\n  payment_hash: 1,\n  payment_secret: 16,\n  description: 13,\n  payee: 19,\n  description_hash: 23, // commit to longer descriptions (used by lnurl-pay)\n  expiry: 6, // default: 3600 (1 hour)\n  min_final_cltv_expiry: 24, // default: 9\n  fallback_address: 9,\n  route_hint: 3, // for extra routing info (private etc.)\n  feature_bits: 5,\n  metadata: 27\n}\n\n// reverse the keys and values of TAGCODES and insert into TAGNAMES\nconst TAGNAMES = {}\nfor (let i = 0, keys = Object.keys(TAGCODES); i < keys.length; i++) {\n  const currentName = keys[i]\n  const currentCode = TAGCODES[keys[i]].toString()\n  TAGNAMES[currentCode] = currentName\n}\n\nconst TAGPARSERS = {\n  1: words => hex.encode(bech32.fromWordsUnsafe(words)), // 256 bits\n  16: words => hex.encode(bech32.fromWordsUnsafe(words)), // 256 bits\n  13: words => utf8.encode(bech32.fromWordsUnsafe(words)), // string variable length\n  19: words => hex.encode(bech32.fromWordsUnsafe(words)), // 264 bits\n  23: words => hex.encode(bech32.fromWordsUnsafe(words)), // 256 bits\n  27: words => hex.encode(bech32.fromWordsUnsafe(words)), // variable\n  6: wordsToIntBE, // default: 3600 (1 hour)\n  24: wordsToIntBE, // default: 9\n  3: routingInfoParser, // for extra routing info (private etc.)\n  5: featureBitsParser // keep feature bits as array of 5 bit words\n}\n\nfunction getUnknownParser(tagCode) {\n  return words => ({\n    tagCode: parseInt(tagCode),\n    words: bech32.encode('unknown', words, Number.MAX_SAFE_INTEGER)\n  })\n}\n\nfunction wordsToIntBE(words) {\n  return words.reverse().reduce((total, item, index) => {\n    return total + item * Math.pow(32, index)\n  }, 0)\n}\n\n// first convert from words to buffer, trimming padding where necessary\n// parse in 51 byte chunks. See encoder for details.\nfunction routingInfoParser(words) {\n  const routes = []\n  let pubkey,\n    shortChannelId,\n    feeBaseMSats,\n    feeProportionalMillionths,\n    cltvExpiryDelta\n  let routesBuffer = bech32.fromWordsUnsafe(words)\n  while (routesBuffer.length > 0) {\n    pubkey = hex.encode(routesBuffer.slice(0, 33)) // 33 bytes\n    shortChannelId = hex.encode(routesBuffer.slice(33, 41)) // 8 bytes\n    feeBaseMSats = parseInt(hex.encode(routesBuffer.slice(41, 45)), 16) // 4 bytes\n    feeProportionalMillionths = parseInt(\n      hex.encode(routesBuffer.slice(45, 49)),\n      16\n    ) // 4 bytes\n    cltvExpiryDelta = parseInt(hex.encode(routesBuffer.slice(49, 51)), 16) // 2 bytes\n\n    routesBuffer = routesBuffer.slice(51)\n\n    routes.push({\n      pubkey,\n      short_channel_id: shortChannelId,\n      fee_base_msat: feeBaseMSats,\n      fee_proportional_millionths: feeProportionalMillionths,\n      cltv_expiry_delta: cltvExpiryDelta\n    })\n  }\n  return routes\n}\n\nfunction featureBitsParser(words) {\n  const bools = words\n    .slice()\n    .reverse()\n    .map(word => [\n      !!(word & 0b1),\n      !!(word & 0b10),\n      !!(word & 0b100),\n      !!(word & 0b1000),\n      !!(word & 0b10000)\n    ])\n    .reduce((finalArr, itemArr) => finalArr.concat(itemArr), [])\n  while (bools.length < FEATUREBIT_ORDER.length * 2) {\n    bools.push(false)\n  }\n\n  const featureBits = {}\n\n  FEATUREBIT_ORDER.forEach((featureName, index) => {\n    let status\n    if (bools[index * 2]) {\n      status = 'required'\n    } else if (bools[index * 2 + 1]) {\n      status = 'supported'\n    } else {\n      status = 'unsupported'\n    }\n    featureBits[featureName] = status\n  })\n\n  const extraBits = bools.slice(FEATUREBIT_ORDER.length * 2)\n  featureBits.extra_bits = {\n    start_bit: FEATUREBIT_ORDER.length * 2,\n    bits: extraBits,\n    has_required: extraBits.reduce(\n      (result, bit, index) =>\n        index % 2 !== 0 ? result || false : result || bit,\n      false\n    )\n  }\n\n  return featureBits\n}\n\nfunction hrpToMillisat(hrpString, outputString) {\n  let divisor, value\n  if (hrpString.slice(-1).match(/^[munp]$/)) {\n    divisor = hrpString.slice(-1)\n    value = hrpString.slice(0, -1)\n  } else if (hrpString.slice(-1).match(/^[^munp0-9]$/)) {\n    throw new Error('Not a valid multiplier for the amount')\n  } else {\n    value = hrpString\n  }\n\n  if (!value.match(/^\\d+$/))\n    throw new Error('Not a valid human readable amount')\n\n  const valueBN = BigInt(value)\n\n  const millisatoshisBN = divisor\n    ? (valueBN * MILLISATS_PER_BTC) / DIVISORS[divisor]\n    : valueBN * MILLISATS_PER_BTC\n\n  if (\n    (divisor === 'p' && !(valueBN % BigInt(10) === BigInt(0))) ||\n    millisatoshisBN > MAX_MILLISATS\n  ) {\n    throw new Error('Amount is outside of valid range')\n  }\n\n  return outputString ? millisatoshisBN.toString() : millisatoshisBN\n}\n\n// decode will only have extra comments that aren't covered in encode comments.\n// also if anything is hard to read I'll comment.\nfunction decode(paymentRequest, network) {\n  if (typeof paymentRequest !== 'string')\n    throw new Error('Lightning Payment Request must be string')\n  if (paymentRequest.slice(0, 2).toLowerCase() !== 'ln')\n    throw new Error('Not a proper lightning payment request')\n\n  const sections = []\n  const decoded = bech32.decode(paymentRequest, Number.MAX_SAFE_INTEGER)\n  paymentRequest = paymentRequest.toLowerCase()\n  const prefix = decoded.prefix\n  let words = decoded.words\n  let letters = paymentRequest.slice(prefix.length + 1)\n  let sigWords = words.slice(-104)\n  words = words.slice(0, -104)\n\n  // Without reverse lookups, can't say that the multipier at the end must\n  // have a number before it, so instead we parse, and if the second group\n  // doesn't have anything, there's a good chance the last letter of the\n  // coin type got captured by the third group, so just re-regex without\n  // the number.\n  let prefixMatches = prefix.match(/^ln(\\S+?)(\\d*)([a-zA-Z]?)$/)\n  if (prefixMatches && !prefixMatches[2])\n    prefixMatches = prefix.match(/^ln(\\S+)$/)\n  if (!prefixMatches) {\n    throw new Error('Not a proper lightning payment request')\n  }\n\n  // \"ln\" section\n  sections.push({\n    name: 'lightning_network',\n    letters: 'ln'\n  })\n\n  // \"bc\" section\n  const bech32Prefix = prefixMatches[1]\n  let coinNetwork\n  if (!network) {\n    switch (bech32Prefix) {\n      case DEFAULTNETWORK.bech32:\n        coinNetwork = DEFAULTNETWORK\n        break\n      case TESTNETWORK.bech32:\n        coinNetwork = TESTNETWORK\n        break\n      case SIGNETNETWORK.bech32:\n        coinNetwork = SIGNETNETWORK\n        break\n      case REGTESTNETWORK.bech32:\n        coinNetwork = REGTESTNETWORK\n        break\n      case SIMNETWORK.bech32:\n        coinNetwork = SIMNETWORK\n        break\n    }\n  } else {\n    if (\n      network.bech32 === undefined ||\n      network.pubKeyHash === undefined ||\n      network.scriptHash === undefined ||\n      !Array.isArray(network.validWitnessVersions)\n    )\n      throw new Error('Invalid network')\n    coinNetwork = network\n  }\n  if (!coinNetwork || coinNetwork.bech32 !== bech32Prefix) {\n    throw new Error('Unknown coin bech32 prefix')\n  }\n  sections.push({\n    name: 'coin_network',\n    letters: bech32Prefix,\n    value: coinNetwork\n  })\n\n  // amount section\n  const value = prefixMatches[2]\n  let millisatoshis\n  if (value) {\n    const divisor = prefixMatches[3]\n    millisatoshis = hrpToMillisat(value + divisor, true)\n    sections.push({\n      name: 'amount',\n      letters: prefixMatches[2] + prefixMatches[3],\n      value: millisatoshis\n    })\n  } else {\n    millisatoshis = null\n  }\n\n  // \"1\" separator\n  sections.push({\n    name: 'separator',\n    letters: '1'\n  })\n\n  // timestamp\n  const timestamp = wordsToIntBE(words.slice(0, 7))\n  words = words.slice(7) // trim off the left 7 words\n  sections.push({\n    name: 'timestamp',\n    letters: letters.slice(0, 7),\n    value: timestamp\n  })\n  letters = letters.slice(7)\n\n  let tagName, parser, tagLength, tagWords\n  // we have no tag count to go on, so just keep hacking off words\n  // until we have none.\n  while (words.length > 0) {\n    const tagCode = words[0].toString()\n    tagName = TAGNAMES[tagCode] || 'unknown_tag'\n    parser = TAGPARSERS[tagCode] || getUnknownParser(tagCode)\n    words = words.slice(1)\n\n    tagLength = wordsToIntBE(words.slice(0, 2))\n    words = words.slice(2)\n\n    tagWords = words.slice(0, tagLength)\n    words = words.slice(tagLength)\n\n    sections.push({\n      name: tagName,\n      tag: letters[0],\n      letters: letters.slice(0, 1 + 2 + tagLength),\n      value: parser(tagWords) // see: parsers for more comments\n    })\n    letters = letters.slice(1 + 2 + tagLength)\n  }\n\n  // signature\n  sections.push({\n    name: 'signature',\n    letters: letters.slice(0, 104),\n    value: hex.encode(bech32.fromWordsUnsafe(sigWords))\n  })\n  letters = letters.slice(104)\n\n  // checksum\n  sections.push({\n    name: 'checksum',\n    letters: letters\n  })\n\n  let result = {\n    paymentRequest,\n    sections,\n\n    get expiry() {\n      let exp = sections.find(s => s.name === 'expiry')\n      if (exp) return getValue('timestamp') + exp.value\n    },\n\n    get route_hints() {\n      return sections.filter(s => s.name === 'route_hint').map(s => s.value)\n    }\n  }\n\n  for (let name in TAGCODES) {\n    if (name === 'route_hint') {\n      // route hints can be multiple, so this won't work for them\n      continue\n    }\n\n    Object.defineProperty(result, name, {\n      get() {\n        return getValue(name)\n      }\n    })\n  }\n\n  return result\n\n  function getValue(name) {\n    let section = sections.find(s => s.name === name)\n    return section ? section.value : undefined\n  }\n}\n\nmodule.exports = {\n  decode,\n  hrpToMillisat\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vbGlnaHQtYm9sdDExLWRlY29kZXJAMy4yLjAvbm9kZV9tb2R1bGVzL2xpZ2h0LWJvbHQxMS1kZWNvZGVyL2JvbHQxMS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxPQUFPLG1CQUFtQixFQUFFLG1CQUFPLENBQUMsdUdBQWE7O0FBRWpELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsaUJBQWlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYWJsb2Zlcm5hbmRlei90ZXN0MTIzL1RFTkVYLXBma21jOS9tYWluL25vZGVfbW9kdWxlcy8ucG5wbS9saWdodC1ib2x0MTEtZGVjb2RlckAzLjIuMC9ub2RlX21vZHVsZXMvbGlnaHQtYm9sdDExLWRlY29kZXIvYm9sdDExLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHtiZWNoMzIsIGhleCwgdXRmOH0gPSByZXF1aXJlKCdAc2N1cmUvYmFzZScpXG5cbi8vIGRlZmF1bHRzIGZvciBlbmNvZGU7IGRlZmF1bHQgdGltZXN0YW1wIGlzIGN1cnJlbnQgdGltZSBhdCBjYWxsXG5jb25zdCBERUZBVUxUTkVUV09SSyA9IHtcbiAgLy8gZGVmYXVsdCBuZXR3b3JrIGlzIGJpdGNvaW5cbiAgYmVjaDMyOiAnYmMnLFxuICBwdWJLZXlIYXNoOiAweDAwLFxuICBzY3JpcHRIYXNoOiAweDA1LFxuICB2YWxpZFdpdG5lc3NWZXJzaW9uczogWzBdXG59XG5jb25zdCBURVNUTkVUV09SSyA9IHtcbiAgYmVjaDMyOiAndGInLFxuICBwdWJLZXlIYXNoOiAweDZmLFxuICBzY3JpcHRIYXNoOiAweGM0LFxuICB2YWxpZFdpdG5lc3NWZXJzaW9uczogWzBdXG59XG5jb25zdCBTSUdORVRORVRXT1JLID0ge1xuICBiZWNoMzI6ICd0YnMnLFxuICBwdWJLZXlIYXNoOiAweDZmLFxuICBzY3JpcHRIYXNoOiAweGM0LFxuICB2YWxpZFdpdG5lc3NWZXJzaW9uczogWzBdXG59XG5jb25zdCBSRUdURVNUTkVUV09SSyA9IHtcbiAgYmVjaDMyOiAnYmNydCcsXG4gIHB1YktleUhhc2g6IDB4NmYsXG4gIHNjcmlwdEhhc2g6IDB4YzQsXG4gIHZhbGlkV2l0bmVzc1ZlcnNpb25zOiBbMF1cbn1cbmNvbnN0IFNJTU5FVFdPUksgPSB7XG4gIGJlY2gzMjogJ3NiJyxcbiAgcHViS2V5SGFzaDogMHgzZixcbiAgc2NyaXB0SGFzaDogMHg3YixcbiAgdmFsaWRXaXRuZXNzVmVyc2lvbnM6IFswXVxufVxuXG5jb25zdCBGRUFUVVJFQklUX09SREVSID0gW1xuICAnb3B0aW9uX2RhdGFfbG9zc19wcm90ZWN0JyxcbiAgJ2luaXRpYWxfcm91dGluZ19zeW5jJyxcbiAgJ29wdGlvbl91cGZyb250X3NodXRkb3duX3NjcmlwdCcsXG4gICdnb3NzaXBfcXVlcmllcycsXG4gICd2YXJfb25pb25fb3B0aW4nLFxuICAnZ29zc2lwX3F1ZXJpZXNfZXgnLFxuICAnb3B0aW9uX3N0YXRpY19yZW1vdGVrZXknLFxuICAncGF5bWVudF9zZWNyZXQnLFxuICAnYmFzaWNfbXBwJyxcbiAgJ29wdGlvbl9zdXBwb3J0X2xhcmdlX2NoYW5uZWwnXG5dXG5cbmNvbnN0IERJVklTT1JTID0ge1xuICBtOiBCaWdJbnQoMWUzKSxcbiAgdTogQmlnSW50KDFlNiksXG4gIG46IEJpZ0ludCgxZTkpLFxuICBwOiBCaWdJbnQoMWUxMilcbn1cblxuY29uc3QgTUFYX01JTExJU0FUUyA9IEJpZ0ludCgnMjEwMDAwMDAwMDAwMDAwMDAwMCcpXG5cbmNvbnN0IE1JTExJU0FUU19QRVJfQlRDID0gQmlnSW50KDFlMTEpXG5cbmNvbnN0IFRBR0NPREVTID0ge1xuICBwYXltZW50X2hhc2g6IDEsXG4gIHBheW1lbnRfc2VjcmV0OiAxNixcbiAgZGVzY3JpcHRpb246IDEzLFxuICBwYXllZTogMTksXG4gIGRlc2NyaXB0aW9uX2hhc2g6IDIzLCAvLyBjb21taXQgdG8gbG9uZ2VyIGRlc2NyaXB0aW9ucyAodXNlZCBieSBsbnVybC1wYXkpXG4gIGV4cGlyeTogNiwgLy8gZGVmYXVsdDogMzYwMCAoMSBob3VyKVxuICBtaW5fZmluYWxfY2x0dl9leHBpcnk6IDI0LCAvLyBkZWZhdWx0OiA5XG4gIGZhbGxiYWNrX2FkZHJlc3M6IDksXG4gIHJvdXRlX2hpbnQ6IDMsIC8vIGZvciBleHRyYSByb3V0aW5nIGluZm8gKHByaXZhdGUgZXRjLilcbiAgZmVhdHVyZV9iaXRzOiA1LFxuICBtZXRhZGF0YTogMjdcbn1cblxuLy8gcmV2ZXJzZSB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIFRBR0NPREVTIGFuZCBpbnNlcnQgaW50byBUQUdOQU1FU1xuY29uc3QgVEFHTkFNRVMgPSB7fVxuZm9yIChsZXQgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhUQUdDT0RFUyk7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gIGNvbnN0IGN1cnJlbnROYW1lID0ga2V5c1tpXVxuICBjb25zdCBjdXJyZW50Q29kZSA9IFRBR0NPREVTW2tleXNbaV1dLnRvU3RyaW5nKClcbiAgVEFHTkFNRVNbY3VycmVudENvZGVdID0gY3VycmVudE5hbWVcbn1cblxuY29uc3QgVEFHUEFSU0VSUyA9IHtcbiAgMTogd29yZHMgPT4gaGV4LmVuY29kZShiZWNoMzIuZnJvbVdvcmRzVW5zYWZlKHdvcmRzKSksIC8vIDI1NiBiaXRzXG4gIDE2OiB3b3JkcyA9PiBoZXguZW5jb2RlKGJlY2gzMi5mcm9tV29yZHNVbnNhZmUod29yZHMpKSwgLy8gMjU2IGJpdHNcbiAgMTM6IHdvcmRzID0+IHV0ZjguZW5jb2RlKGJlY2gzMi5mcm9tV29yZHNVbnNhZmUod29yZHMpKSwgLy8gc3RyaW5nIHZhcmlhYmxlIGxlbmd0aFxuICAxOTogd29yZHMgPT4gaGV4LmVuY29kZShiZWNoMzIuZnJvbVdvcmRzVW5zYWZlKHdvcmRzKSksIC8vIDI2NCBiaXRzXG4gIDIzOiB3b3JkcyA9PiBoZXguZW5jb2RlKGJlY2gzMi5mcm9tV29yZHNVbnNhZmUod29yZHMpKSwgLy8gMjU2IGJpdHNcbiAgMjc6IHdvcmRzID0+IGhleC5lbmNvZGUoYmVjaDMyLmZyb21Xb3Jkc1Vuc2FmZSh3b3JkcykpLCAvLyB2YXJpYWJsZVxuICA2OiB3b3Jkc1RvSW50QkUsIC8vIGRlZmF1bHQ6IDM2MDAgKDEgaG91cilcbiAgMjQ6IHdvcmRzVG9JbnRCRSwgLy8gZGVmYXVsdDogOVxuICAzOiByb3V0aW5nSW5mb1BhcnNlciwgLy8gZm9yIGV4dHJhIHJvdXRpbmcgaW5mbyAocHJpdmF0ZSBldGMuKVxuICA1OiBmZWF0dXJlQml0c1BhcnNlciAvLyBrZWVwIGZlYXR1cmUgYml0cyBhcyBhcnJheSBvZiA1IGJpdCB3b3Jkc1xufVxuXG5mdW5jdGlvbiBnZXRVbmtub3duUGFyc2VyKHRhZ0NvZGUpIHtcbiAgcmV0dXJuIHdvcmRzID0+ICh7XG4gICAgdGFnQ29kZTogcGFyc2VJbnQodGFnQ29kZSksXG4gICAgd29yZHM6IGJlY2gzMi5lbmNvZGUoJ3Vua25vd24nLCB3b3JkcywgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHdvcmRzVG9JbnRCRSh3b3Jkcykge1xuICByZXR1cm4gd29yZHMucmV2ZXJzZSgpLnJlZHVjZSgodG90YWwsIGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIHRvdGFsICsgaXRlbSAqIE1hdGgucG93KDMyLCBpbmRleClcbiAgfSwgMClcbn1cblxuLy8gZmlyc3QgY29udmVydCBmcm9tIHdvcmRzIHRvIGJ1ZmZlciwgdHJpbW1pbmcgcGFkZGluZyB3aGVyZSBuZWNlc3Nhcnlcbi8vIHBhcnNlIGluIDUxIGJ5dGUgY2h1bmtzLiBTZWUgZW5jb2RlciBmb3IgZGV0YWlscy5cbmZ1bmN0aW9uIHJvdXRpbmdJbmZvUGFyc2VyKHdvcmRzKSB7XG4gIGNvbnN0IHJvdXRlcyA9IFtdXG4gIGxldCBwdWJrZXksXG4gICAgc2hvcnRDaGFubmVsSWQsXG4gICAgZmVlQmFzZU1TYXRzLFxuICAgIGZlZVByb3BvcnRpb25hbE1pbGxpb250aHMsXG4gICAgY2x0dkV4cGlyeURlbHRhXG4gIGxldCByb3V0ZXNCdWZmZXIgPSBiZWNoMzIuZnJvbVdvcmRzVW5zYWZlKHdvcmRzKVxuICB3aGlsZSAocm91dGVzQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICBwdWJrZXkgPSBoZXguZW5jb2RlKHJvdXRlc0J1ZmZlci5zbGljZSgwLCAzMykpIC8vIDMzIGJ5dGVzXG4gICAgc2hvcnRDaGFubmVsSWQgPSBoZXguZW5jb2RlKHJvdXRlc0J1ZmZlci5zbGljZSgzMywgNDEpKSAvLyA4IGJ5dGVzXG4gICAgZmVlQmFzZU1TYXRzID0gcGFyc2VJbnQoaGV4LmVuY29kZShyb3V0ZXNCdWZmZXIuc2xpY2UoNDEsIDQ1KSksIDE2KSAvLyA0IGJ5dGVzXG4gICAgZmVlUHJvcG9ydGlvbmFsTWlsbGlvbnRocyA9IHBhcnNlSW50KFxuICAgICAgaGV4LmVuY29kZShyb3V0ZXNCdWZmZXIuc2xpY2UoNDUsIDQ5KSksXG4gICAgICAxNlxuICAgICkgLy8gNCBieXRlc1xuICAgIGNsdHZFeHBpcnlEZWx0YSA9IHBhcnNlSW50KGhleC5lbmNvZGUocm91dGVzQnVmZmVyLnNsaWNlKDQ5LCA1MSkpLCAxNikgLy8gMiBieXRlc1xuXG4gICAgcm91dGVzQnVmZmVyID0gcm91dGVzQnVmZmVyLnNsaWNlKDUxKVxuXG4gICAgcm91dGVzLnB1c2goe1xuICAgICAgcHVia2V5LFxuICAgICAgc2hvcnRfY2hhbm5lbF9pZDogc2hvcnRDaGFubmVsSWQsXG4gICAgICBmZWVfYmFzZV9tc2F0OiBmZWVCYXNlTVNhdHMsXG4gICAgICBmZWVfcHJvcG9ydGlvbmFsX21pbGxpb250aHM6IGZlZVByb3BvcnRpb25hbE1pbGxpb250aHMsXG4gICAgICBjbHR2X2V4cGlyeV9kZWx0YTogY2x0dkV4cGlyeURlbHRhXG4gICAgfSlcbiAgfVxuICByZXR1cm4gcm91dGVzXG59XG5cbmZ1bmN0aW9uIGZlYXR1cmVCaXRzUGFyc2VyKHdvcmRzKSB7XG4gIGNvbnN0IGJvb2xzID0gd29yZHNcbiAgICAuc2xpY2UoKVxuICAgIC5yZXZlcnNlKClcbiAgICAubWFwKHdvcmQgPT4gW1xuICAgICAgISEod29yZCAmIDBiMSksXG4gICAgICAhISh3b3JkICYgMGIxMCksXG4gICAgICAhISh3b3JkICYgMGIxMDApLFxuICAgICAgISEod29yZCAmIDBiMTAwMCksXG4gICAgICAhISh3b3JkICYgMGIxMDAwMClcbiAgICBdKVxuICAgIC5yZWR1Y2UoKGZpbmFsQXJyLCBpdGVtQXJyKSA9PiBmaW5hbEFyci5jb25jYXQoaXRlbUFyciksIFtdKVxuICB3aGlsZSAoYm9vbHMubGVuZ3RoIDwgRkVBVFVSRUJJVF9PUkRFUi5sZW5ndGggKiAyKSB7XG4gICAgYm9vbHMucHVzaChmYWxzZSlcbiAgfVxuXG4gIGNvbnN0IGZlYXR1cmVCaXRzID0ge31cblxuICBGRUFUVVJFQklUX09SREVSLmZvckVhY2goKGZlYXR1cmVOYW1lLCBpbmRleCkgPT4ge1xuICAgIGxldCBzdGF0dXNcbiAgICBpZiAoYm9vbHNbaW5kZXggKiAyXSkge1xuICAgICAgc3RhdHVzID0gJ3JlcXVpcmVkJ1xuICAgIH0gZWxzZSBpZiAoYm9vbHNbaW5kZXggKiAyICsgMV0pIHtcbiAgICAgIHN0YXR1cyA9ICdzdXBwb3J0ZWQnXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXR1cyA9ICd1bnN1cHBvcnRlZCdcbiAgICB9XG4gICAgZmVhdHVyZUJpdHNbZmVhdHVyZU5hbWVdID0gc3RhdHVzXG4gIH0pXG5cbiAgY29uc3QgZXh0cmFCaXRzID0gYm9vbHMuc2xpY2UoRkVBVFVSRUJJVF9PUkRFUi5sZW5ndGggKiAyKVxuICBmZWF0dXJlQml0cy5leHRyYV9iaXRzID0ge1xuICAgIHN0YXJ0X2JpdDogRkVBVFVSRUJJVF9PUkRFUi5sZW5ndGggKiAyLFxuICAgIGJpdHM6IGV4dHJhQml0cyxcbiAgICBoYXNfcmVxdWlyZWQ6IGV4dHJhQml0cy5yZWR1Y2UoXG4gICAgICAocmVzdWx0LCBiaXQsIGluZGV4KSA9PlxuICAgICAgICBpbmRleCAlIDIgIT09IDAgPyByZXN1bHQgfHwgZmFsc2UgOiByZXN1bHQgfHwgYml0LFxuICAgICAgZmFsc2VcbiAgICApXG4gIH1cblxuICByZXR1cm4gZmVhdHVyZUJpdHNcbn1cblxuZnVuY3Rpb24gaHJwVG9NaWxsaXNhdChocnBTdHJpbmcsIG91dHB1dFN0cmluZykge1xuICBsZXQgZGl2aXNvciwgdmFsdWVcbiAgaWYgKGhycFN0cmluZy5zbGljZSgtMSkubWF0Y2goL15bbXVucF0kLykpIHtcbiAgICBkaXZpc29yID0gaHJwU3RyaW5nLnNsaWNlKC0xKVxuICAgIHZhbHVlID0gaHJwU3RyaW5nLnNsaWNlKDAsIC0xKVxuICB9IGVsc2UgaWYgKGhycFN0cmluZy5zbGljZSgtMSkubWF0Y2goL15bXm11bnAwLTldJC8pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YWxpZCBtdWx0aXBsaWVyIGZvciB0aGUgYW1vdW50JylcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGhycFN0cmluZ1xuICB9XG5cbiAgaWYgKCF2YWx1ZS5tYXRjaCgvXlxcZCskLykpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YWxpZCBodW1hbiByZWFkYWJsZSBhbW91bnQnKVxuXG4gIGNvbnN0IHZhbHVlQk4gPSBCaWdJbnQodmFsdWUpXG5cbiAgY29uc3QgbWlsbGlzYXRvc2hpc0JOID0gZGl2aXNvclxuICAgID8gKHZhbHVlQk4gKiBNSUxMSVNBVFNfUEVSX0JUQykgLyBESVZJU09SU1tkaXZpc29yXVxuICAgIDogdmFsdWVCTiAqIE1JTExJU0FUU19QRVJfQlRDXG5cbiAgaWYgKFxuICAgIChkaXZpc29yID09PSAncCcgJiYgISh2YWx1ZUJOICUgQmlnSW50KDEwKSA9PT0gQmlnSW50KDApKSkgfHxcbiAgICBtaWxsaXNhdG9zaGlzQk4gPiBNQVhfTUlMTElTQVRTXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignQW1vdW50IGlzIG91dHNpZGUgb2YgdmFsaWQgcmFuZ2UnKVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFN0cmluZyA/IG1pbGxpc2F0b3NoaXNCTi50b1N0cmluZygpIDogbWlsbGlzYXRvc2hpc0JOXG59XG5cbi8vIGRlY29kZSB3aWxsIG9ubHkgaGF2ZSBleHRyYSBjb21tZW50cyB0aGF0IGFyZW4ndCBjb3ZlcmVkIGluIGVuY29kZSBjb21tZW50cy5cbi8vIGFsc28gaWYgYW55dGhpbmcgaXMgaGFyZCB0byByZWFkIEknbGwgY29tbWVudC5cbmZ1bmN0aW9uIGRlY29kZShwYXltZW50UmVxdWVzdCwgbmV0d29yaykge1xuICBpZiAodHlwZW9mIHBheW1lbnRSZXF1ZXN0ICE9PSAnc3RyaW5nJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpZ2h0bmluZyBQYXltZW50IFJlcXVlc3QgbXVzdCBiZSBzdHJpbmcnKVxuICBpZiAocGF5bWVudFJlcXVlc3Quc2xpY2UoMCwgMikudG9Mb3dlckNhc2UoKSAhPT0gJ2xuJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHByb3BlciBsaWdodG5pbmcgcGF5bWVudCByZXF1ZXN0JylcblxuICBjb25zdCBzZWN0aW9ucyA9IFtdXG4gIGNvbnN0IGRlY29kZWQgPSBiZWNoMzIuZGVjb2RlKHBheW1lbnRSZXF1ZXN0LCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUilcbiAgcGF5bWVudFJlcXVlc3QgPSBwYXltZW50UmVxdWVzdC50b0xvd2VyQ2FzZSgpXG4gIGNvbnN0IHByZWZpeCA9IGRlY29kZWQucHJlZml4XG4gIGxldCB3b3JkcyA9IGRlY29kZWQud29yZHNcbiAgbGV0IGxldHRlcnMgPSBwYXltZW50UmVxdWVzdC5zbGljZShwcmVmaXgubGVuZ3RoICsgMSlcbiAgbGV0IHNpZ1dvcmRzID0gd29yZHMuc2xpY2UoLTEwNClcbiAgd29yZHMgPSB3b3Jkcy5zbGljZSgwLCAtMTA0KVxuXG4gIC8vIFdpdGhvdXQgcmV2ZXJzZSBsb29rdXBzLCBjYW4ndCBzYXkgdGhhdCB0aGUgbXVsdGlwaWVyIGF0IHRoZSBlbmQgbXVzdFxuICAvLyBoYXZlIGEgbnVtYmVyIGJlZm9yZSBpdCwgc28gaW5zdGVhZCB3ZSBwYXJzZSwgYW5kIGlmIHRoZSBzZWNvbmQgZ3JvdXBcbiAgLy8gZG9lc24ndCBoYXZlIGFueXRoaW5nLCB0aGVyZSdzIGEgZ29vZCBjaGFuY2UgdGhlIGxhc3QgbGV0dGVyIG9mIHRoZVxuICAvLyBjb2luIHR5cGUgZ290IGNhcHR1cmVkIGJ5IHRoZSB0aGlyZCBncm91cCwgc28ganVzdCByZS1yZWdleCB3aXRob3V0XG4gIC8vIHRoZSBudW1iZXIuXG4gIGxldCBwcmVmaXhNYXRjaGVzID0gcHJlZml4Lm1hdGNoKC9ebG4oXFxTKz8pKFxcZCopKFthLXpBLVpdPykkLylcbiAgaWYgKHByZWZpeE1hdGNoZXMgJiYgIXByZWZpeE1hdGNoZXNbMl0pXG4gICAgcHJlZml4TWF0Y2hlcyA9IHByZWZpeC5tYXRjaCgvXmxuKFxcUyspJC8pXG4gIGlmICghcHJlZml4TWF0Y2hlcykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgcHJvcGVyIGxpZ2h0bmluZyBwYXltZW50IHJlcXVlc3QnKVxuICB9XG5cbiAgLy8gXCJsblwiIHNlY3Rpb25cbiAgc2VjdGlvbnMucHVzaCh7XG4gICAgbmFtZTogJ2xpZ2h0bmluZ19uZXR3b3JrJyxcbiAgICBsZXR0ZXJzOiAnbG4nXG4gIH0pXG5cbiAgLy8gXCJiY1wiIHNlY3Rpb25cbiAgY29uc3QgYmVjaDMyUHJlZml4ID0gcHJlZml4TWF0Y2hlc1sxXVxuICBsZXQgY29pbk5ldHdvcmtcbiAgaWYgKCFuZXR3b3JrKSB7XG4gICAgc3dpdGNoIChiZWNoMzJQcmVmaXgpIHtcbiAgICAgIGNhc2UgREVGQVVMVE5FVFdPUksuYmVjaDMyOlxuICAgICAgICBjb2luTmV0d29yayA9IERFRkFVTFRORVRXT1JLXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFRFU1RORVRXT1JLLmJlY2gzMjpcbiAgICAgICAgY29pbk5ldHdvcmsgPSBURVNUTkVUV09SS1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSBTSUdORVRORVRXT1JLLmJlY2gzMjpcbiAgICAgICAgY29pbk5ldHdvcmsgPSBTSUdORVRORVRXT1JLXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFJFR1RFU1RORVRXT1JLLmJlY2gzMjpcbiAgICAgICAgY29pbk5ldHdvcmsgPSBSRUdURVNUTkVUV09SS1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSBTSU1ORVRXT1JLLmJlY2gzMjpcbiAgICAgICAgY29pbk5ldHdvcmsgPSBTSU1ORVRXT1JLXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChcbiAgICAgIG5ldHdvcmsuYmVjaDMyID09PSB1bmRlZmluZWQgfHxcbiAgICAgIG5ldHdvcmsucHViS2V5SGFzaCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBuZXR3b3JrLnNjcmlwdEhhc2ggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgIUFycmF5LmlzQXJyYXkobmV0d29yay52YWxpZFdpdG5lc3NWZXJzaW9ucylcbiAgICApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbmV0d29yaycpXG4gICAgY29pbk5ldHdvcmsgPSBuZXR3b3JrXG4gIH1cbiAgaWYgKCFjb2luTmV0d29yayB8fCBjb2luTmV0d29yay5iZWNoMzIgIT09IGJlY2gzMlByZWZpeCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb2luIGJlY2gzMiBwcmVmaXgnKVxuICB9XG4gIHNlY3Rpb25zLnB1c2goe1xuICAgIG5hbWU6ICdjb2luX25ldHdvcmsnLFxuICAgIGxldHRlcnM6IGJlY2gzMlByZWZpeCxcbiAgICB2YWx1ZTogY29pbk5ldHdvcmtcbiAgfSlcblxuICAvLyBhbW91bnQgc2VjdGlvblxuICBjb25zdCB2YWx1ZSA9IHByZWZpeE1hdGNoZXNbMl1cbiAgbGV0IG1pbGxpc2F0b3NoaXNcbiAgaWYgKHZhbHVlKSB7XG4gICAgY29uc3QgZGl2aXNvciA9IHByZWZpeE1hdGNoZXNbM11cbiAgICBtaWxsaXNhdG9zaGlzID0gaHJwVG9NaWxsaXNhdCh2YWx1ZSArIGRpdmlzb3IsIHRydWUpXG4gICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGxldHRlcnM6IHByZWZpeE1hdGNoZXNbMl0gKyBwcmVmaXhNYXRjaGVzWzNdLFxuICAgICAgdmFsdWU6IG1pbGxpc2F0b3NoaXNcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIG1pbGxpc2F0b3NoaXMgPSBudWxsXG4gIH1cblxuICAvLyBcIjFcIiBzZXBhcmF0b3JcbiAgc2VjdGlvbnMucHVzaCh7XG4gICAgbmFtZTogJ3NlcGFyYXRvcicsXG4gICAgbGV0dGVyczogJzEnXG4gIH0pXG5cbiAgLy8gdGltZXN0YW1wXG4gIGNvbnN0IHRpbWVzdGFtcCA9IHdvcmRzVG9JbnRCRSh3b3Jkcy5zbGljZSgwLCA3KSlcbiAgd29yZHMgPSB3b3Jkcy5zbGljZSg3KSAvLyB0cmltIG9mZiB0aGUgbGVmdCA3IHdvcmRzXG4gIHNlY3Rpb25zLnB1c2goe1xuICAgIG5hbWU6ICd0aW1lc3RhbXAnLFxuICAgIGxldHRlcnM6IGxldHRlcnMuc2xpY2UoMCwgNyksXG4gICAgdmFsdWU6IHRpbWVzdGFtcFxuICB9KVxuICBsZXR0ZXJzID0gbGV0dGVycy5zbGljZSg3KVxuXG4gIGxldCB0YWdOYW1lLCBwYXJzZXIsIHRhZ0xlbmd0aCwgdGFnV29yZHNcbiAgLy8gd2UgaGF2ZSBubyB0YWcgY291bnQgdG8gZ28gb24sIHNvIGp1c3Qga2VlcCBoYWNraW5nIG9mZiB3b3Jkc1xuICAvLyB1bnRpbCB3ZSBoYXZlIG5vbmUuXG4gIHdoaWxlICh3b3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgdGFnQ29kZSA9IHdvcmRzWzBdLnRvU3RyaW5nKClcbiAgICB0YWdOYW1lID0gVEFHTkFNRVNbdGFnQ29kZV0gfHwgJ3Vua25vd25fdGFnJ1xuICAgIHBhcnNlciA9IFRBR1BBUlNFUlNbdGFnQ29kZV0gfHwgZ2V0VW5rbm93blBhcnNlcih0YWdDb2RlKVxuICAgIHdvcmRzID0gd29yZHMuc2xpY2UoMSlcblxuICAgIHRhZ0xlbmd0aCA9IHdvcmRzVG9JbnRCRSh3b3Jkcy5zbGljZSgwLCAyKSlcbiAgICB3b3JkcyA9IHdvcmRzLnNsaWNlKDIpXG5cbiAgICB0YWdXb3JkcyA9IHdvcmRzLnNsaWNlKDAsIHRhZ0xlbmd0aClcbiAgICB3b3JkcyA9IHdvcmRzLnNsaWNlKHRhZ0xlbmd0aClcblxuICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgbmFtZTogdGFnTmFtZSxcbiAgICAgIHRhZzogbGV0dGVyc1swXSxcbiAgICAgIGxldHRlcnM6IGxldHRlcnMuc2xpY2UoMCwgMSArIDIgKyB0YWdMZW5ndGgpLFxuICAgICAgdmFsdWU6IHBhcnNlcih0YWdXb3JkcykgLy8gc2VlOiBwYXJzZXJzIGZvciBtb3JlIGNvbW1lbnRzXG4gICAgfSlcbiAgICBsZXR0ZXJzID0gbGV0dGVycy5zbGljZSgxICsgMiArIHRhZ0xlbmd0aClcbiAgfVxuXG4gIC8vIHNpZ25hdHVyZVxuICBzZWN0aW9ucy5wdXNoKHtcbiAgICBuYW1lOiAnc2lnbmF0dXJlJyxcbiAgICBsZXR0ZXJzOiBsZXR0ZXJzLnNsaWNlKDAsIDEwNCksXG4gICAgdmFsdWU6IGhleC5lbmNvZGUoYmVjaDMyLmZyb21Xb3Jkc1Vuc2FmZShzaWdXb3JkcykpXG4gIH0pXG4gIGxldHRlcnMgPSBsZXR0ZXJzLnNsaWNlKDEwNClcblxuICAvLyBjaGVja3N1bVxuICBzZWN0aW9ucy5wdXNoKHtcbiAgICBuYW1lOiAnY2hlY2tzdW0nLFxuICAgIGxldHRlcnM6IGxldHRlcnNcbiAgfSlcblxuICBsZXQgcmVzdWx0ID0ge1xuICAgIHBheW1lbnRSZXF1ZXN0LFxuICAgIHNlY3Rpb25zLFxuXG4gICAgZ2V0IGV4cGlyeSgpIHtcbiAgICAgIGxldCBleHAgPSBzZWN0aW9ucy5maW5kKHMgPT4gcy5uYW1lID09PSAnZXhwaXJ5JylcbiAgICAgIGlmIChleHApIHJldHVybiBnZXRWYWx1ZSgndGltZXN0YW1wJykgKyBleHAudmFsdWVcbiAgICB9LFxuXG4gICAgZ2V0IHJvdXRlX2hpbnRzKCkge1xuICAgICAgcmV0dXJuIHNlY3Rpb25zLmZpbHRlcihzID0+IHMubmFtZSA9PT0gJ3JvdXRlX2hpbnQnKS5tYXAocyA9PiBzLnZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IG5hbWUgaW4gVEFHQ09ERVMpIHtcbiAgICBpZiAobmFtZSA9PT0gJ3JvdXRlX2hpbnQnKSB7XG4gICAgICAvLyByb3V0ZSBoaW50cyBjYW4gYmUgbXVsdGlwbGUsIHNvIHRoaXMgd29uJ3Qgd29yayBmb3IgdGhlbVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBuYW1lLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBnZXRWYWx1ZShuYW1lKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG5cbiAgZnVuY3Rpb24gZ2V0VmFsdWUobmFtZSkge1xuICAgIGxldCBzZWN0aW9uID0gc2VjdGlvbnMuZmluZChzID0+IHMubmFtZSA9PT0gbmFtZSlcbiAgICByZXR1cm4gc2VjdGlvbiA/IHNlY3Rpb24udmFsdWUgOiB1bmRlZmluZWRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVjb2RlLFxuICBocnBUb01pbGxpc2F0XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/light-bolt11-decoder@3.2.0/node_modules/light-bolt11-decoder/bolt11.js\n");

/***/ })

};
;