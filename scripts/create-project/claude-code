#!/usr/bin/env bun
// scripts/create-project/claude-code

import path from 'path';
import { mkdir, writeFile, access } from 'fs/promises';
import { exec } from 'child_process';
import { promisify } from 'util';
import { getProjectPath } from '../../lib/projectUtils'; // Adjust path relative to script location

const execAsync = promisify(exec);

// --- Argument Parsing ---
// Simple argument parsing: expects --slug <slug> --desc <desc> --title <title> --eventId <eventId> --repo <repoUrl>
interface Args {
    slug?: string;
    desc?: string;
    title?: string;
    repo?: string;
    eventId?: string;
}

const args: Args = {};
const argv = process.argv.slice(2); // Skip node/bun executable and script path

for (let i = 0; i < argv.length; i++) {
    if (argv[i] === '--slug' && i + 1 < argv.length) {
        args.slug = argv[i + 1];
        i++;
    } else if (argv[i] === '--desc' && i + 1 < argv.length) {
        args.desc = argv[i + 1];
        i++;
    } else if (argv[i] === '--title' && i + 1 < argv.length) {
        args.title = argv[i + 1];
        i++;
    } else if (argv[i] === '--repo' && i + 1 < argv.length) {
        args.repo = argv[i + 1];
        i++;
    } else if (argv[i] === '--eventId' && i + 1 < argv.length) {
        args.eventId = argv[i + 1];
        i++;
    }
}

// --- Validation ---
if (!args.slug) {
    console.error(JSON.stringify({ success: false, error: 'Project slug is required (--slug)' }));
    process.exit(1);
}
if (!args.eventId) {
    console.error(JSON.stringify({ success: false, error: 'Event ID is required (--eventId)' }));
    process.exit(1);
}
if (!args.title) {
    console.error(JSON.stringify({ success: false, error: 'Project title is required (--title)' }));
    process.exit(1);
}
if (!args.repo) {
    console.error(JSON.stringify({ success: false, error: 'Git repository URL is required for Claude Code backend (--repo)' }));
    process.exit(1);
}

if (!args.desc) {
    // Default description if not provided
    args.desc = `Project specification for ${args.slug}`;
    console.warn(`Description not provided (--desc), using default: "${args.desc}"`);
}

const projectSlug = args.slug!;
const description = args.desc;
const title = args.title!;
const repoUrl = args.repo!;
const eventId = args.eventId!;

// --- Main Logic ---
async function createProject() {
    let projectPath: string | undefined;
    try {
        projectPath = getProjectPath(projectSlug);
    } catch (error: unknown) {
        const message = error instanceof Error ? error.message : 'Server configuration error';
        console.error(JSON.stringify({ success: false, error: `Error getting project path: ${message}` }));
        process.exit(1);
    }

    if (!projectPath) {
        console.error(JSON.stringify({ success: false, error: 'Failed to determine project path.' }));
        process.exit(1);
    }

    try {
        // 1. Check if project directory already exists
        try {
            await access(projectPath!);
            console.error(JSON.stringify({ success: false, error: 'Project directory already exists.', code: 'CONFLICT' }));
            process.exit(1);
        } catch (accessError: unknown) {
            if (typeof accessError === 'object' && accessError !== null && 'code' in accessError && accessError.code !== 'ENOENT') {
                throw accessError;
            } else if (!(typeof accessError === 'object' && accessError !== null && 'code' in accessError && accessError.code === 'ENOENT')) {
                throw accessError;
            }
        }

        // 2. Create project directory
        console.log(`Creating project directory: ${projectPath!}`);
        await mkdir(projectPath!, { recursive: true });

        // 3. Clone Git repo (required for Claude Code)
        console.log(`Cloning repository from ${repoUrl} into ${projectPath!}...`);
        try {
            await execAsync(`git clone --depth 1 "${repoUrl}" "${projectPath!}"`);
            console.log(`Repository cloned successfully.`);
        } catch (cloneError: unknown) {
            let errorMessage = 'Unknown error during clone.';
            if (typeof cloneError === 'object' && cloneError !== null) {
                errorMessage = ('stderr' in cloneError && cloneError.stderr) ? String(cloneError.stderr) :
                               ('message' in cloneError && cloneError.message) ? String(cloneError.message) :
                               JSON.stringify(cloneError);
            } else if (cloneError instanceof Error) {
                errorMessage = cloneError.message;
            }
            console.error(`Failed to clone repository: ${errorMessage}`);
            throw new Error(`Failed to clone repository: ${errorMessage}`);
        }

        // 4. Create .tenex.json for project metadata
        const tenexConfigPath = path.join(projectPath!, '.tenex.json');
        const tenexConfig = {
            title: title,
            repoUrl: repoUrl,
            eventId: eventId,
            backendType: 'claude-code'
        };

        try {
            await writeFile(tenexConfigPath, JSON.stringify(tenexConfig, null, 2));
            console.log(`.tenex.json created successfully at ${tenexConfigPath}`);
        } catch (tenexWriteError: unknown) {
            console.error(`Failed to write .tenex.json at ${tenexConfigPath}:`, tenexWriteError);
            console.warn(`Proceeding without .tenex.json due to write error.`);
        }

        // 5. Output Success JSON
        console.log(JSON.stringify({
            success: true,
            message: 'Project created successfully with Claude Code backend.',
            projectSlug: projectSlug,
            path: projectPath!,
            configured: false, // Claude Code doesn't use MCP configuration
            tenexConfigPath: tenexConfigPath
        }));
        process.exit(0);

    } catch (error: unknown) {
        const message = error instanceof Error ? error.message : String(error);
        console.error(`Error during project creation for ${projectSlug}: ${message}`, error);
        
        if (projectPath) {
            try {
                await access(projectPath);
                console.warn(`Creation failed, attempting to remove directory: ${projectPath}`);
                await execAsync(`rm -rf "${projectPath}"`);
            } catch (cleanupError: unknown) {
                console.error(`Failed to cleanup directory ${projectPath}:`, cleanupError);
            }
        } else {
            console.warn("Creation failed before project path could be determined. No cleanup needed.");
        }
        
        const finalErrorMessage = error instanceof Error ? error.message : String(error);
        console.error(JSON.stringify({ success: false, error: `Failed to create project: ${finalErrorMessage}` }));
        process.exit(1);
    }
}

// --- Execute ---
createProject();